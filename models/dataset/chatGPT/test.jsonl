{"code": "for (int y = 0; y < HEI; y++)\n  for (int x = 0; x < WID; x++)\n{\n  float d = 0;\n  int i = 0;\n  int D = _mm_setzero_ps();\n  do\n  {\n    int xx = _mm_sub_ps(_mm_load_ps(X + i), _mm_set1_ps(x));\n    int yy = _mm_sub_ps(_mm_load_ps(Y + i), _mm_set1_ps(y));\n    D = _mm_add_ps(D, _mm_mul_ps(_mm_load_ps(F + i), _mm_rsqrt_ps(_mm_add_ps(_mm_mul_ps(xx, xx), _mm_mul_ps(yy, yy)))));\n  }\n  while ((i += 4) < ms);\n  const int f = _mm_add_ps(D, _mm_movehl_ps(D, D));\n  _mm_store_ss(&d, _mm_add_ss(f, _mm_shuffle_ps(f, f, 1)));\n  memcpy(manor + (((((HEI - 1) - y) * WID) + x) * 3), col[(d > 255) ? (255) : ((d < 0) ? (0) : ((unsigned char) d))], 3);\n}\n\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < (ms - 1); i++)\n{\n  float h = ((X[i] - X[ms - 1]) * (X[i] - X[ms - 1])) + ((Y[i] - Y[ms - 1]) * (Y[i] - Y[ms - 1]));\n  if (h < d)\n  {\n    c = i;\n    d = h;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 256; i++)\n{\n  col[i][0] = ((i * i) * i) >> 16;\n  col[i][1] = (i * i) >> 8;\n  col[i][2] = i;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < NoThreads; i++)\n{\n  printf(\"Thread %d execute init for globals for i = %d\\n\", omp_get_thread_num(), i);\n  if (omp_get_thread_num() > 0)\n  {\n    pr_globals = (float *) malloc(progs->numglobals * (sizeof(float)));\n    pr_global_struct = (globalvars_t *) pr_globals;\n    memcpy(pr_globals, pr_globals_temp, progs->numglobals * (sizeof(float)));\n  }\n  else\n  {\n    pr_global_struct = pr_global_struct_temp;\n    pr_globals = (float *) pr_global_struct;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 32 + 1; i < sv.num_edicts; i++)\n{\n  e = EDICT_NUM(i);\n  if (e->free && ((e->freetime < 2) || ((sv.time - e->freetime) > 0.5)))\n  {\n    ED_ClearEdict(e);\n    relaxed = true;\n  }\n\n}\n\nedict_t *EDICT_NUM(int n)\n{\n  if ((n < 0) || (n >= 768))\n    SV_Error(\"EDICT_NUM: bad number %i\", n);\n\n  return (edict_t *) (((byte *) sv.edicts) + (n * pr_edict_size));\n}\n\n\nvoid ED_ClearEdict(edict_t *e)\n{\n  Q_memset(&e->v, 0, progs->entityfields * 4);\n  e->free = false;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numglobaldefs; i++)\n{\n  def = &pr_globaldefs[i];\n  if (def->ofs == ofs)\n    return def;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfielddefs; i++)\n{\n  def = &pr_fielddefs[i];\n  if (def->ofs == ofs)\n    return def;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfielddefs; i++)\n{\n  def = &pr_fielddefs[i];\n  if (!Q_strcmp(PR_GetString(def->s_name), name))\n    return def;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfunctions; i++)\n{\n  func = &pr_functions[i];\n  if (!strcmp(PR_GetString(func->s_name), name))\n    return func;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n{\n  if (!Q_strcmp(field, gefvCache[i].field))\n  {\n    def = gefvCache[i].pcache;\n    goto Done;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 20; i++)\n  Q_strcat(line, \" \");\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 20; i++)\n  Q_strcat(line, \" \");\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < progs->numfielddefs; i++)\n{\n  d = &pr_fielddefs[i];\n  name = PR_GetString(d->s_name);\n  if (name[Q_strlen(name) - 2] == '_')\n    continue;\n\n  v = (int *) (((char *) (&ed->v)) + (d->ofs * 4));\n  type = d->type & (~(1 << 15));\n  for (j = 0; j < type_size[type]; j++)\n    if (v[j])\n    break;\n\n\n  if (j == type_size[type])\n    continue;\n\n  Con_Printf(\"%s\", name);\n  l = Q_strlen(name);\n  while ((l++) < 15)\n    Con_Printf(\" \");\n\n  Con_Printf(\"%s\\n\", PR_ValueString(d->type, (eval_t *) v));\n}\n\nchar *PR_ValueString(unsigned short ddef_type, eval_t *val)\n{\n  static char line[256];\n  ddef_t *def;\n  dfunction_t *f;\n  etype_t type;\n  ddef_type &= ~(1 << 15);\n  type = (etype_t) ddef_type;\n  switch (type)\n  {\n    case ev_string:\n      Q_sprintf(line, \"%s\", PR_GetString(val->string));\n      break;\n\n    case ev_entity:\n      Q_sprintf(line, \"entity %i\", NUM_FOR_EDICT((edict_t *) (((byte *) sv.edicts) + val->edict)));\n      break;\n\n    case ev_function:\n      f = pr_functions + val->function;\n      Q_sprintf(line, \"%s()\", PR_GetString(f->s_name));\n      break;\n\n    case ev_field:\n      def = ED_FieldAtOfs(val->_int);\n      Q_sprintf(line, \".%s\", PR_GetString(def->s_name));\n      break;\n\n    case ev_void:\n      Q_sprintf(line, \"void\");\n      break;\n\n    case ev_float:\n      Q_sprintf(line, \"%5.1f\", val->_float);\n      break;\n\n    case ev_vector:\n      Q_sprintf(line, \"'%5.1f %5.1f %5.1f'\", val->vector[0], val->vector[1], val->vector[2]);\n      break;\n\n    case ev_pointer:\n      Q_sprintf(line, \"pointer\");\n      break;\n\n    default:\n      Q_sprintf(line, \"bad type %d\", (short) type);\n      break;\n\n  }\n\n  return line;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sv.num_edicts; i++)\n{\n  Con_Printf(\"\\nEDICT %i:\\n\", i);\n  ED_PrintNum(i);\n}\n\nvoid ED_PrintNum(int ent)\n{\n  ED_Print(EDICT_NUM(ent));\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sv.num_edicts; i++)\n{\n  ent = EDICT_NUM(i);\n  if (ent->free)\n    continue;\n\n  active++;\n  if (ent->v.solid)\n    solid++;\n\n  if (ent->v.model)\n    models++;\n\n  if (ent->v.movetype == 4)\n    step++;\n\n}\n\nedict_t *EDICT_NUM(int n)\n{\n  if ((n < 0) || (n >= 768))\n    SV_Error(\"EDICT_NUM: bad number %i\", n);\n\n  return (edict_t *) (((byte *) sv.edicts) + (n * pr_edict_size));\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < l; i++)\n{\n  if ((string[i] == '\\\\') && (i < (l - 1)))\n  {\n    i++;\n    if (string[i] == 'n')\n      *(new_p++) = '\\n';\n    else\n      *(new_p++) = '\\\\';\n\n  }\n  else\n    *(new_p++) = string[i];\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n{\n  while ((*v) && ((*v) != ' '))\n    v++;\n\n  *v = 0;\n  ((float *) d)[i] = atof(w);\n  w = (v = v + 1);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfunctions; i++)\n{\n  printf(\"------------------------\\nFUNCTION %d\\n------------------------\\n\", i);\n  printf(\"first_statement = %d\\n\", pr_functions[i].first_statement);\n  printf(\"param_start = %d\\n\", pr_functions[i].parm_start);\n  printf(\"s_name = %s\\n\", PR_GetString(pr_functions[i].s_name));\n  printf(\"s_file = %s\\n\", PR_GetString(pr_functions[i].s_file));\n  printf(\"num_params = %d\\n\", pr_functions[i].numparms);\n  printf(\"locals = %d\\n\\n\", pr_functions[i].locals);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n  gefvCache[i].field[0] = 0;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((sizeof(*progs)) / 4); i++)\n  ((int *) progs)[i] = LittleLong(((int *) progs)[i]);\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numstatements; i++)\n{\n  pr_statements[i].op = LittleShort(pr_statements[i].op);\n  pr_statements[i].a = LittleShort(pr_statements[i].a);\n  pr_statements[i].b = LittleShort(pr_statements[i].b);\n  pr_statements[i].c = LittleShort(pr_statements[i].c);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfunctions; i++)\n{\n  pr_functions[i].first_statement = LittleLong(pr_functions[i].first_statement);\n  pr_functions[i].parm_start = LittleLong(pr_functions[i].parm_start);\n  pr_functions[i].s_name = LittleLong(pr_functions[i].s_name);\n  pr_functions[i].s_file = LittleLong(pr_functions[i].s_file);\n  pr_functions[i].numparms = LittleLong(pr_functions[i].numparms);\n  pr_functions[i].locals = LittleLong(pr_functions[i].locals);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numglobaldefs; i++)\n{\n  pr_globaldefs[i].type = LittleShort(pr_globaldefs[i].type);\n  pr_globaldefs[i].ofs = LittleShort(pr_globaldefs[i].ofs);\n  pr_globaldefs[i].s_name = LittleLong(pr_globaldefs[i].s_name);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numfielddefs; i++)\n{\n  pr_fielddefs[i].type = LittleShort(pr_fielddefs[i].type);\n  if (pr_fielddefs[i].type & (1 << 15))\n    SV_Error(\"PR_LoadProgs: pr_fielddefs[i].type & DEF_SAVEGLOBAL\");\n\n  pr_fielddefs[i].ofs = LittleShort(pr_fielddefs[i].ofs);\n  pr_fielddefs[i].s_name = LittleLong(pr_fielddefs[i].s_name);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < progs->numglobals; i++)\n  ((int *) pr_globals_temp)[i] = LittleLong(((int *) pr_globals_temp)[i]);\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < NoThreads; i++)\n{\n  for (j = 0; j < 8; j++)\n    msg_nest_level[j] = 0;\n\n  for (j = 0; j < 32; j++)\n    client_nest_level[j] = 0;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n  if (cl->state >= cs_spawned)\n  Netchan_Transmit(&cl->netchan, net_message.cursize, net_message.data);\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (frame = cl->frames, i = 0; i < 64; i++, frame++)\n{\n  if (frame->ping_time > 0)\n  {\n    ping += frame->ping_time;\n    count++;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  cl = &svs.clients[i];\n  if (((cl->state == cs_connected) || (cl->state == cs_spawned)) && (!cl->spectator))\n  {\n    top = atoi(Info_ValueForKey(cl->userinfo, \"topcolor\"));\n    bottom = atoi(Info_ValueForKey(cl->userinfo, \"bottomcolor\"));\n    top = (top < 0) ? (0) : ((top > 13) ? (13) : (top));\n    bottom = (bottom < 0) ? (0) : ((bottom > 13) ? (13) : (bottom));\n    ping = SV_CalcPing(cl);\n    Con_Printf(\"%i %i %i %i \\\"%s\\\" \\\"%s\\\" %i %i\\n\", cl->userid, cl->old_frags, ((int) (realtime - cl->connection_started)) / 60, ping, cl->name, Info_ValueForKey(cl->userinfo, \"skin\"), top, bottom);\n  }\n\n}\n\nint SV_CalcPing(client_t *cl)\n{\n  float ping;\n  int i;\n  int count;\n  register client_frame_t *frame;\n  ping = 0;\n  count = 0;\n  for (frame = cl->frames, i = 0; i < 64; i++, frame++)\n  {\n    if (frame->ping_time > 0)\n    {\n      ping += frame->ping_time;\n      count++;\n    }\n\n  }\n\n  if (!count)\n    return 9999;\n\n  ping /= count;\n  return ping * 1000;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (NET_CompareBaseAdr(net_from, svs.challenges[i].adr))\n    break;\n\n  if (svs.challenges[i].time < oldestTime)\n  {\n    oldestTime = svs.challenges[i].time;\n    oldest = i;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (NET_CompareBaseAdr(net_from, svs.challenges[i].adr))\n  {\n    if (challenge == svs.challenges[i].challenge)\n      break;\n\n    Netchan_OutOfBandPrint(net_from, \"%c\\nBad challenge.\\n\", 'n');\n    return;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = (byte *) newcl->userinfo, q = (byte *) userinfo; (*q) && (p < ((((byte *) newcl->userinfo) + (sizeof(newcl->userinfo))) - 1)); q++)\n  if (((*q) > 31) && ((*q) <= 127))\n  *(p++) = *q;\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if (cl->state == cs_free)\n    continue;\n\n  if (NET_CompareBaseAdr(adr, cl->netchan.remote_address) && ((cl->netchan.qport == qport) || (adr.port == cl->netchan.remote_address.port)))\n  {\n    if (cl->state == cs_connected)\n    {\n      Con_Printf(\"%s:dup connect\\n\", NET_AdrToString(adr));\n      userid--;\n      return;\n    }\n\n    Con_Printf(\"%s:reconnect\\n\", NET_AdrToString(adr));\n    SV_DropClient(cl);\n    break;\n  }\n\n}\n\nvoid SV_DropClient(client_t *drop)\n{\n  do\n  {\n    {\n      MSG_WriteByte(&drop->netchan.message, 2);\n    }\n  }\n  while (0);\n  ;\n  if (drop->state == cs_spawned)\n  {\n    if (!drop->spectator)\n    {\n      pr_global_struct->self = ((byte *) drop->edict) - ((byte *) sv.edicts);\n      PR_ExecuteProgram(pr_global_struct->ClientDisconnect);\n    }\n    else\n      if (SpectatorDisconnect)\n    {\n      pr_global_struct->self = ((byte *) drop->edict) - ((byte *) sv.edicts);\n      PR_ExecuteProgram(SpectatorDisconnect);\n    }\n\n\n  }\n\n  if (drop->spectator)\n    Con_Printf(\"Spectator %s removed\\n\", drop->name);\n  else\n    Con_Printf(\"Client %s removed\\n\", drop->name);\n\n  if (drop->download)\n  {\n    TM_fclose(drop->download);\n    drop->download = 0;\n  }\n\n  if (drop->upload)\n  {\n    TM_fclose(drop->upload);\n    drop->upload = 0;\n  }\n\n  *drop->uploadfn = 0;\n  drop->state = cs_zombie;\n  drop->connection_started = realtime;\n  drop->old_frags = 0;\n  drop->edict->v.frags = 0;\n  drop->name[0] = 0;\n  Q_memset(drop->userinfo, 0, sizeof(drop->userinfo));\n  do\n  {\n    {\n      do\n      {\n        {\n          SV_FullClientUpdate(drop, &sv.reliable_datagram);\n        }\n      }\n      while (0);\n      ;\n    }\n  }\n  while (0);\n  ;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if (cl->state == cs_free)\n    continue;\n\n  if (cl->spectator)\n    spectators++;\n  else\n    clients++;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if (cl->state == cs_free)\n  {\n    newcl = cl;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  newcl->whensaid[i] = 0.0;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  newcl->spawn_parms[i] = (&pr_global_struct->parm1)[i];\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 2; i < Cmd_Argc(); i++)\n{\n  strcat(remaining, Cmd_Argv(i));\n  strcat(remaining, \" \");\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  b[i] = 0;\n  m[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  if (((*s) < '0') || ((*s) > '9'))\n  {\n    Con_Printf(\"Bad filter address: %s\\n\", s);\n    return false;\n  }\n\n  j = 0;\n  while (((*s) >= '0') && ((*s) <= '9'))\n  {\n    num[j++] = *(s++);\n  }\n\n  num[j] = 0;\n  b[i] = atoi(num);\n  if (b[i] != 0)\n    m[i] = 255;\n\n  if (!(*s))\n    break;\n\n  s++;\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numipfilters; i++)\n  if (ipfilters[i].compare == 0xffffffff)\n  break;\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numipfilters; i++)\n  if ((ipfilters[i].mask == f.mask) && (ipfilters[i].compare == f.compare))\n{\n  for (j = i + 1; j < numipfilters; j++)\n    ipfilters[j - 1] = ipfilters[j];\n\n  numipfilters--;\n  Con_Printf(\"Removed.\\n\");\n  return;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numipfilters; i++)\n{\n  *((unsigned *) b) = ipfilters[i].compare;\n  Con_Printf(\"%3i.%3i.%3i.%3i\\n\", b[0], b[1], b[2], b[3]);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numipfilters; i++)\n{\n  *((unsigned *) b) = ipfilters[i].compare;\n  fprintf(f, \"addip %i.%i.%i.%i\\n\", b[0], b[1], b[2], b[3]);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numipfilters; i++)\n  if ((in & ipfilters[i].mask) == ipfilters[i].compare)\n  return (filterban.value == 0) ? (false) : (true);\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  retry[i][0] = 0;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if (cl->state == cs_free)\n    continue;\n\n  if (!NET_CompareBaseAdr(net_from, cl->netchan.remote_address))\n    continue;\n\n  if (cl->netchan.qport != qport)\n    continue;\n\n  svs.stats.packets++;\n  ClearRetry(ThreadId);\n  if (cl->netchan.remote_address.port != net_from.port)\n  {\n    Con_DPrintf(\"SV_ReadPackets: fixing up a translated port\\n\");\n    cl->netchan.remote_address.port = net_from.port;\n  }\n\n  if (Netchan_Process(&cl->netchan, i))\n  {\n    cl->send_message = true;\n    if (((DEBUG & (~0x03)) & 4) && ((DEBUG & 0x03) >= 1))\n      printf(\"Thread: %d\\t\\tclient %d\\tname: %s\\tstate %d\\n\", ThreadId, i, cl->name, (int) cl->state);\n\n    if (cl->state != cs_zombie)\n      SV_ExecuteClientMessage(cl);\n\n  }\n\n  FlushTMOutput();\n}\n\nvoid ClearRetry(int Id)\n{\n  retry[Id][0] = 0;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if ((cl->state == cs_connected) || (cl->state == cs_spawned))\n  {\n    if (!cl->spectator)\n      nclients++;\n\n    if (cl->netchan.last_received < droptime)\n    {\n      SV_BroadcastPrintf(2, \"%s timed out\\n\", cl->name);\n      SV_DropClient(cl);\n      cl->state = cs_free;\n    }\n\n  }\n\n  if ((cl->state == cs_zombie) && ((realtime - cl->connection_started) > zombietime.value))\n  {\n    cl->state = cs_free;\n  }\n\n}\n\nvoid SV_DropClient(client_t *drop)\n{\n  do\n  {\n    {\n      MSG_WriteByte(&drop->netchan.message, 2);\n    }\n  }\n  while (0);\n  ;\n  if (drop->state == cs_spawned)\n  {\n    if (!drop->spectator)\n    {\n      pr_global_struct->self = ((byte *) drop->edict) - ((byte *) sv.edicts);\n      PR_ExecuteProgram(pr_global_struct->ClientDisconnect);\n    }\n    else\n      if (SpectatorDisconnect)\n    {\n      pr_global_struct->self = ((byte *) drop->edict) - ((byte *) sv.edicts);\n      PR_ExecuteProgram(SpectatorDisconnect);\n    }\n\n\n  }\n\n  if (drop->spectator)\n    Con_Printf(\"Spectator %s removed\\n\", drop->name);\n  else\n    Con_Printf(\"Client %s removed\\n\", drop->name);\n\n  if (drop->download)\n  {\n    TM_fclose(drop->download);\n    drop->download = 0;\n  }\n\n  if (drop->upload)\n  {\n    TM_fclose(drop->upload);\n    drop->upload = 0;\n  }\n\n  *drop->uploadfn = 0;\n  drop->state = cs_zombie;\n  drop->connection_started = realtime;\n  drop->old_frags = 0;\n  drop->edict->v.frags = 0;\n  drop->name[0] = 0;\n  Q_memset(drop->userinfo, 0, sizeof(drop->userinfo));\n  do\n  {\n    {\n      do\n      {\n        {\n          SV_FullClientUpdate(drop, &sv.reliable_datagram);\n        }\n      }\n      while (0);\n      ;\n    }\n  }\n  while (0);\n  ;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  sprintf(localmodels[i], \"*%i\", i);\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  if ((svs.clients[i].state == cs_connected) || (svs.clients[i].state == cs_spawned))\n  active++;\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  if (master_adr[i].port)\n{\n  Con_Printf(\"Sending heartbeat to %s\\n\", NET_AdrToString(master_adr[i]));\n  NET_SendPacket(strlen(string), string, master_adr[i]);\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  if (master_adr[i].port)\n{\n  Con_Printf(\"Sending heartbeat to %s\\n\", NET_AdrToString(master_adr[i]));\n  NET_SendPacket(strlen(string), string, master_adr[i]);\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = newname; ((((*p) == ' ') || ((*p) == '\\r')) || ((*p) == '\\n')) && (*p); p++)\n  ;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (q = newname; *p; *(q++) = *(p++))\n  ;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = (newname + Q_strlen(newname)) - 1; (p != newname) && ((((*p) == ' ') || ((*p) == '\\r')) || ((*p) == '\\n')); p--)\n  ;\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, client = svs.clients; i < 32; i++, client++)\n{\n  if ((client->state != cs_spawned) || (client == cl))\n    continue;\n\n  if (!Q_strcasecmp(client->name, val))\n    break;\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  old_origin[i][0] = 0;\n  old_origin[i][1] = 0;\n  old_origin[i][2] = 0;\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  switch (cl->state)\n  {\n    case cs_free:\n      sprintf(state, \"free\\t\");\n      break;\n\n    case cs_zombie:\n      sprintf(state, \"zombie\\t\");\n      printf(\"%d\\t%s\\n\", i, state);\n      break;\n\n    case cs_connected:\n      sprintf(state, \"connected\\t\");\n      sprintf(state, \"%s%s\\t\", state, cl->name);\n      printf(\"%d\\t%s\\n\", i, state);\n      break;\n\n    case cs_spawned:\n      sprintf(state, \"spawned\\t\");\n      sprintf(state, \"%s%s\\t\\t\", state, cl->name);\n      if (((cl->edict->v.origin[0] != old_origin[i][0]) || (cl->edict->v.origin[1] != old_origin[i][1])) || (cl->edict->v.origin[2] != old_origin[i][2]))\n    {\n      sprintf(state, \"%smoved : ( %f , %f , %f ) \", state, old_origin[i][0], old_origin[i][1], old_origin[i][2]);\n      sprintf(state, \"%s-> ( %f , %f , %f )\", state, cl->edict->v.origin[0], cl->edict->v.origin[1], cl->edict->v.origin[2]);\n      old_origin[i][0] = cl->edict->v.origin[0];\n      old_origin[i][1] = cl->edict->v.origin[1];\n      old_origin[i][2] = cl->edict->v.origin[2];\n    }\n\n      printf(\"%d\\t%s\\n\", i, state);\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  for (j = 0; j < (16 * 1); j++)\n  {\n    checkpoint[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < NoThreads; i++)\n{\n  printf(\"\\nThread %d\\n------------------------\\n\\n\", i);\n  for (j = 0; j < (16 * 1); j++)\n  {\n    printf(\"%d:\\t%d\\n\", j, checkpoint[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sv.num_edicts; i++)\n{\n  edict_t *ent = (edict_t *) (ent_global_ptr + (pr_edict_size * i));\n  if (ent->free || (i <= 32))\n    continue;\n\n  if (((DEBUG & (~0x03)) & 8) && ((DEBUG & 0x03) >= 2))\n    printf(\"Thread= %d\\t\\tBefore Transaction\\n\", omp_get_thread_num());\n\n  inTransaction = true;\n  SV_RunEntity(ent);\n  SV_RunNewmis();\n  inTransaction = false;\n  if (((DEBUG & (~0x03)) & 8) && ((DEBUG & 0x03) >= 2))\n    printf(\"Thread= %d\\t\\tAfter Transaction\\n\", omp_get_thread_num());\n\n  FlushTMOutput();\n}\n\nvoid SV_RunEntity(edict_t *ent)\n{\n  if (ent->v.lastruntime == ((float) realtime))\n    return;\n\n  ent->v.lastruntime = (float) realtime;\n  switch ((int) ent->v.movetype)\n  {\n    case 7:\n      SV_Physics_Pusher(ent);\n      break;\n\n    case 0:\n      SV_Physics_None(ent);\n      break;\n\n    case 8:\n      SV_Physics_Noclip(ent);\n      break;\n\n    case 4:\n      SV_Physics_Step(ent);\n      break;\n\n    case 3:\n\n    case 6:\n\n    case 10:\n\n    case 5:\n\n    case 9:\n      SV_Physics_Toss(ent);\n      break;\n\n    default:\n      SV_Error(\"SV_Physics: bad movetype %i\", (int) ent->v.movetype);\n\n  }\n\n}\n\n\nvoid SV_RunNewmis(void)\n{\n  edict_t *ent;\n  if (!pr_global_struct->newmis)\n    return;\n\n  ent = (edict_t *) (((byte *) sv.edicts) + pr_global_struct->newmis);\n  host_frametime = 0.05;\n  pr_global_struct->newmis = 0;\n  SV_RunEntity(ent);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n{\n  if (((*((int *) (&ent->v.velocity[i]))) & nanmask) == nanmask)\n  {\n    Con_Printf(\"Got a NaN velocity on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.velocity[i] = 0;\n  }\n\n  if (((*((int *) (&ent->v.origin[i]))) & nanmask) == nanmask)\n  {\n    Con_Printf(\"Got a NaN origin on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.origin[i] = 0;\n  }\n\n  if (ent->v.velocity[i] > sv_maxvelocity.value)\n    ent->v.velocity[i] = sv_maxvelocity.value;\n  else\n    if (ent->v.velocity[i] < (-sv_maxvelocity.value))\n    ent->v.velocity[i] = -sv_maxvelocity.value;\n\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n{\n  change = normal[i] * backoff;\n  out[i] = in[i] - change;\n  if ((out[i] > (-0.1)) && (out[i] < 0.1))\n    out[i] = 0;\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (bumpcount = 0; bumpcount < numbumps; bumpcount++)\n{\n  for (i = 0; i < 3; i++)\n    end[i] = ent->v.origin[i] + (time_left * ent->v.velocity[i]);\n\n  trace = SV_Move(ent->v.origin, ent->v.mins, ent->v.maxs, end, false, ent);\n  if (trace.allsolid)\n  {\n    {\n      ent->v.velocity[0] = vec3_origin[0];\n      ent->v.velocity[1] = vec3_origin[1];\n      ent->v.velocity[2] = vec3_origin[2];\n    }\n    ;\n    return 3;\n  }\n\n  if (trace.fraction > 0)\n  {\n    {\n      ent->v.origin[0] = trace.endpos[0];\n      ent->v.origin[1] = trace.endpos[1];\n      ent->v.origin[2] = trace.endpos[2];\n    }\n    ;\n    {\n      original_velocity[0] = ent->v.velocity[0];\n      original_velocity[1] = ent->v.velocity[1];\n      original_velocity[2] = ent->v.velocity[2];\n    }\n    ;\n    numplanes = 0;\n  }\n\n  if (trace.fraction == 1)\n    break;\n\n  if (!trace.ent)\n    SV_Error(\"SV_FlyMove: !trace.ent\");\n\n  if (trace.plane.normal[2] > 0.7)\n  {\n    blocked |= 1;\n    if (trace.ent->v.solid == 4)\n    {\n      ent->v.flags = ((int) ent->v.flags) | 512;\n      ent->v.groundentity = ((byte *) trace.ent) - ((byte *) sv.edicts);\n    }\n\n  }\n\n  if (!trace.plane.normal[2])\n  {\n    blocked |= 2;\n    if (steptrace)\n      *steptrace = trace;\n\n  }\n\n  SV_Impact(ent, trace.ent);\n  if (ent->free)\n    break;\n\n  time_left -= time_left * trace.fraction;\n  if (numplanes >= 5)\n  {\n    {\n      ent->v.velocity[0] = vec3_origin[0];\n      ent->v.velocity[1] = vec3_origin[1];\n      ent->v.velocity[2] = vec3_origin[2];\n    }\n    ;\n    return 3;\n  }\n\n  {\n    planes[numplanes][0] = trace.plane.normal[0];\n    planes[numplanes][1] = trace.plane.normal[1];\n    planes[numplanes][2] = trace.plane.normal[2];\n  }\n  ;\n  numplanes++;\n  for (i = 0; i < numplanes; i++)\n  {\n    ClipVelocity(original_velocity, planes[i], new_velocity, 1);\n    for (j = 0; j < numplanes; j++)\n      if (j != i)\n    {\n      if ((((new_velocity[0] * planes[j][0]) + (new_velocity[1] * planes[j][1])) + (new_velocity[2] * planes[j][2])) < 0)\n        break;\n\n    }\n\n\n    if (j == numplanes)\n      break;\n\n  }\n\n  if (i != numplanes)\n  {\n    {\n      ent->v.velocity[0] = new_velocity[0];\n      ent->v.velocity[1] = new_velocity[1];\n      ent->v.velocity[2] = new_velocity[2];\n    }\n    ;\n  }\n  else\n  {\n    if (numplanes != 2)\n    {\n      {\n        ent->v.velocity[0] = vec3_origin[0];\n        ent->v.velocity[1] = vec3_origin[1];\n        ent->v.velocity[2] = vec3_origin[2];\n      }\n      ;\n      return 7;\n    }\n\n    CrossProduct(planes[0], planes[1], dir);\n    d = ((dir[0] * ent->v.velocity[0]) + (dir[1] * ent->v.velocity[1])) + (dir[2] * ent->v.velocity[2]);\n    VectorScale(dir, d, ent->v.velocity);\n  }\n\n  if ((((ent->v.velocity[0] * primal_velocity[0]) + (ent->v.velocity[1] * primal_velocity[1])) + (ent->v.velocity[2] * primal_velocity[2])) <= 0)\n  {\n    {\n      ent->v.velocity[0] = vec3_origin[0];\n      ent->v.velocity[1] = vec3_origin[1];\n      ent->v.velocity[2] = vec3_origin[2];\n    }\n    ;\n    return blocked;\n  }\n\n}\n\nvoid SV_Impact(edict_t *e1, edict_t *e2)\n{\n  int old_self;\n  int old_other;\n  old_self = pr_global_struct->self;\n  old_other = pr_global_struct->other;\n  pr_global_struct->time = sv.time;\n  if (e1->v.touch && (e1->v.solid != 0))\n  {\n    pr_global_struct->self = ((byte *) e1) - ((byte *) sv.edicts);\n    pr_global_struct->other = ((byte *) e2) - ((byte *) sv.edicts);\n    PR_ExecuteProgram(e1->v.touch);\n  }\n\n  if (e2->v.touch && (e2->v.solid != 0))\n  {\n    pr_global_struct->self = ((byte *) e2) - ((byte *) sv.edicts);\n    pr_global_struct->other = ((byte *) e1) - ((byte *) sv.edicts);\n    PR_ExecuteProgram(e2->v.touch);\n  }\n\n  pr_global_struct->self = old_self;\n  pr_global_struct->other = old_other;\n}\n\n\nint ClipVelocity(vec3_t in, vec3_t normal, vec3_t out, float overbounce)\n{\n  float backoff;\n  float change;\n  int i;\n  int blocked;\n  blocked = 0;\n  if (normal[2] > 0)\n    blocked |= 1;\n\n  if (!normal[2])\n    blocked |= 2;\n\n  backoff = (((in[0] * normal[0]) + (in[1] * normal[1])) + (in[2] * normal[2])) * overbounce;\n  for (i = 0; i < 3; i++)\n  {\n    change = normal[i] * backoff;\n    out[i] = in[i] - change;\n    if ((out[i] > (-0.1)) && (out[i] < 0.1))\n      out[i] = 0;\n\n  }\n\n  return blocked;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n{\n  mins[i] = pusher->v.absmin[i] + move[i];\n  maxs[i] = pusher->v.absmax[i] + move[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (e = 1; e < sv.num_edicts; e++, check = (edict_t *) (((byte *) check) + pr_edict_size))\n{\n  if (check->free)\n    continue;\n\n  if (((check->v.movetype == 7) || (check->v.movetype == 0)) || (check->v.movetype == 8))\n    continue;\n\n  pusher->v.solid = 0;\n  block = SV_TestEntityPosition(check);\n  pusher->v.solid = 4;\n  if (block)\n    continue;\n\n  if (!((((int) check->v.flags) & 512) && (((edict_t *) (((byte *) sv.edicts) + check->v.groundentity)) == pusher)))\n  {\n    if ((((((check->v.absmin[0] >= maxs[0]) || (check->v.absmin[1] >= maxs[1])) || (check->v.absmin[2] >= maxs[2])) || (check->v.absmax[0] <= mins[0])) || (check->v.absmax[1] <= mins[1])) || (check->v.absmax[2] <= mins[2]))\n      continue;\n\n    if (!SV_TestEntityPosition(check))\n      continue;\n\n  }\n\n  {\n    moved_from[num_moved][0] = check->v.origin[0];\n    moved_from[num_moved][1] = check->v.origin[1];\n    moved_from[num_moved][2] = check->v.origin[2];\n  }\n  ;\n  moved_edict[num_moved] = check;\n  num_moved++;\n  {\n    check->v.origin[0] = check->v.origin[0] + move[0];\n    check->v.origin[1] = check->v.origin[1] + move[1];\n    check->v.origin[2] = check->v.origin[2] + move[2];\n  }\n  ;\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    SV_LinkEdict(check, false);\n    continue;\n  }\n\n  {\n    check->v.origin[0] = check->v.origin[0] - move[0];\n    check->v.origin[1] = check->v.origin[1] - move[1];\n    check->v.origin[2] = check->v.origin[2] - move[2];\n  }\n  ;\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    num_moved--;\n    continue;\n  }\n\n  if (check->v.mins[0] == check->v.maxs[0])\n  {\n    SV_LinkEdict(check, false);\n    continue;\n  }\n\n  if ((check->v.solid == 0) || (check->v.solid == 1))\n  {\n    check->v.mins[0] = (check->v.mins[1] = 0);\n    {\n      check->v.maxs[0] = check->v.mins[0];\n      check->v.maxs[1] = check->v.mins[1];\n      check->v.maxs[2] = check->v.mins[2];\n    }\n    ;\n    SV_LinkEdict(check, false);\n    continue;\n  }\n\n  {\n    pusher->v.origin[0] = pushorig[0];\n    pusher->v.origin[1] = pushorig[1];\n    pusher->v.origin[2] = pushorig[2];\n  }\n  ;\n  SV_LinkEdict(pusher, false);\n  if (pusher->v.blocked)\n  {\n    pr_global_struct->self = ((byte *) pusher) - ((byte *) sv.edicts);\n    pr_global_struct->other = ((byte *) check) - ((byte *) sv.edicts);\n    PR_ExecuteProgram(pusher->v.blocked);\n  }\n\n  for (i = 0; i < num_moved; i++)\n  {\n    {\n      moved_edict[i]->v.origin[0] = moved_from[i][0];\n      moved_edict[i]->v.origin[1] = moved_from[i][1];\n      moved_edict[i]->v.origin[2] = moved_from[i][2];\n    }\n    ;\n    SV_LinkEdict(moved_edict[i], false);\n  }\n\n  return false;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n  move[i] = pusher->v.velocity[i] * movetime;\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sv.num_edicts; i++, ent = (edict_t *) (((byte *) ent) + pr_edict_size))\n{\n  if (ent->free)\n    continue;\n\n  SV_LinkEdict(ent, true);\n  if ((i > 0) && (i <= 32))\n    continue;\n\n  SV_RunEntity(ent);\n  SV_RunNewmis();\n}\n\nvoid SV_RunEntity(edict_t *ent)\n{\n  if (ent->v.lastruntime == ((float) realtime))\n    return;\n\n  ent->v.lastruntime = (float) realtime;\n  switch ((int) ent->v.movetype)\n  {\n    case 7:\n      SV_Physics_Pusher(ent);\n      break;\n\n    case 0:\n      SV_Physics_None(ent);\n      break;\n\n    case 8:\n      SV_Physics_Noclip(ent);\n      break;\n\n    case 4:\n      SV_Physics_Step(ent);\n      break;\n\n    case 3:\n\n    case 6:\n\n    case 10:\n\n    case 5:\n\n    case 9:\n      SV_Physics_Toss(ent);\n      break;\n\n    default:\n      SV_Error(\"SV_Physics: bad movetype %i\", (int) ent->v.movetype);\n\n  }\n\n}\n\n\nvoid SV_RunNewmis(void)\n{\n  edict_t *ent;\n  if (!pr_global_struct->newmis)\n    return;\n\n  ent = (edict_t *) (((byte *) sv.edicts) + pr_global_struct->newmis);\n  host_frametime = 0.05;\n  pr_global_struct->newmis = 0;\n  SV_RunEntity(ent);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) shared(svs, sv, sv_areanodes, pr_global_struct, realtime, movevars)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  host_client = &svs.clients[i];\n  if (host_client->state != cs_spawned)\n    continue;\n\n  inTransaction = true;\n  do\n  {\n    {\n      if (host_client->sendinfo)\n      {\n        host_client->sendinfo = false;\n        SV_FullClientUpdate(host_client, &sv.reliable_datagram);\n      }\n\n      if (host_client->old_frags != host_client->edict->v.frags)\n      {\n        for (j = 0, client = svs.clients; j < 32; j++, client++)\n        {\n          if (client->state < cs_connected)\n            continue;\n\n          ClientReliableWrite_Begin(client, 14, 4);\n          ClientReliableWrite_Byte(client, i);\n          ClientReliableWrite_Short(client, host_client->edict->v.frags);\n        }\n\n        host_client->old_frags = host_client->edict->v.frags;\n      }\n\n      ent = host_client->edict;\n      val = GetEdictFieldValue(ent, \"gravity\");\n      if (val && (host_client->entgravity != val->_float))\n      {\n        host_client->entgravity = val->_float;\n        ClientReliableWrite_Begin(host_client, 50, 5);\n        ClientReliableWrite_Float(host_client, host_client->entgravity);\n      }\n\n      val = GetEdictFieldValue(ent, \"maxspeed\");\n      if (val && (host_client->maxspeed != val->_float))\n      {\n        host_client->maxspeed = val->_float;\n        ClientReliableWrite_Begin(host_client, 49, 5);\n        ClientReliableWrite_Float(host_client, host_client->maxspeed);\n      }\n\n    }\n  }\n  while (0);\n  ;\n  inTransaction = false;\n  FlushTMOutput();\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv) private(i, j, client, ent, val)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 32; j++)\n{\n  client = &svs.clients[j];\n  if (client->state < cs_connected)\n    continue;\n\n  if (client->state != cs_spawned)\n    continue;\n\n  SZ_Write(&client->datagram, sv.datagram.data, sv.datagram.cursize);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(j, client) shared(sv, svs)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  c = &svs.clients[i];\n  if (!c->state)\n    continue;\n\n  int ThreadId = ThreadNumber();\n  inTransaction = true;\n  if (c->drop)\n  {\n    SV_DropClient(c);\n    c->drop = false;\n  }\n  else\n  {\n    if (c->num_backbuf)\n    {\n      if ((c->netchan.message.cursize + c->backbuf_size[0]) < c->netchan.message.maxsize)\n      {\n        Con_DPrintf(\"%s: backbuf %d bytes\\n\", c->name, c->backbuf_size[0]);\n        SZ_Write(&c->netchan.message, c->backbuf_data[0], c->backbuf_size[0]);\n        for (j = 1; j < c->num_backbuf; j++)\n        {\n          Q_memcpy(c->backbuf_data[j - 1], c->backbuf_data[j], c->backbuf_size[j]);\n          c->backbuf_size[j - 1] = c->backbuf_size[j];\n        }\n\n        c->num_backbuf--;\n        if (c->num_backbuf)\n        {\n          Q_memset(&c->backbuf, 0, sizeof(c->backbuf));\n          c->backbuf.data = c->backbuf_data[c->num_backbuf - 1];\n          c->backbuf.cursize = c->backbuf_size[c->num_backbuf - 1];\n          c->backbuf.maxsize = sizeof(c->backbuf_data[c->num_backbuf - 1]);\n        }\n\n      }\n\n    }\n\n    if (c->netchan.message.overflowed)\n    {\n      SZ_Clear(&c->netchan.message);\n      SZ_Clear(&c->datagram);\n      SV_BroadcastPrintf(2, \"%s overflowed\\n\", c->name);\n      Con_Printf(\"WARNING: reliable overflow for %s\\n\", c->name);\n      SV_DropClient(c);\n      c->send_message = true;\n      c->netchan.cleartime = 0;\n    }\n\n    if (c->send_message)\n    {\n      if (((DEBUG & (~0x03)) & 16) && ((DEBUG & 0x03) >= 2))\n        printf(\"Thread: %d\\tShould send to %s\\n\", ThreadId, c->name);\n\n      c->send_message = false;\n      if ((!sv.paused) && (!Netchan_CanPacket(&c->netchan)))\n      {\n        if (((DEBUG & (~0x03)) & 16) && ((DEBUG & 0x03) >= 2))\n          printf(\"Thread: %d\\tChoke for %s\\n\", ThreadId, c->name);\n\n        c->chokecount++;\n      }\n      else\n      {\n        if (c->state == cs_spawned)\n          SV_SendClientDatagram(c);\n        else\n          Netchan_Transmit(&c->netchan, 0, 0);\n\n      }\n\n    }\n\n  }\n\n  inTransaction = false;\n  FlushTMOutput();\n}\n\nvoid Con_DPrintf(char *fmt, ...)\n{\n  va_list argptr;\n  char msg[8192];\n  if (!developer.value)\n    return;\n\n  __builtin_va_start(argptr);\n  Q_vsprintf(msg, fmt, argptr);\n  ;\n  Con_Printf(\"%s\", msg);\n}\n\n\nvoid SV_BroadcastPrintf(int level, char *fmt, ...)\n{\n  va_list argptr;\n  char string[1024];\n  client_t *cl;\n  int i;\n  __builtin_va_start(argptr);\n  Q_vsprintf(string, fmt, argptr);\n  ;\n  Sys_Printf(\"%s\", string);\n  for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n  {\n    if (level < cl->messagelevel)\n      continue;\n\n    if (!cl->state)\n      continue;\n\n    SV_PrintToClient(cl, level, string);\n  }\n\n}\n\n\nvoid Con_Printf(char *fmt, ...)\n{\n  va_list argptr;\n  char msg[8192];\n  __builtin_va_start(argptr);\n  Q_vsprintf(msg, fmt, argptr);\n  ;\n  if (sv_redirected)\n  {\n    if ((Q_strlen(msg) + Q_strlen(outputbuf)) > ((8192 * (sizeof(char))) - 1))\n      SV_FlushRedirect();\n\n    Q_strcat(outputbuf, msg);\n    return;\n  }\n\n  if (inTransaction == true)\n  {\n    AddMsg2List(false, msg);\n    return;\n  }\n\n  Sys_Printf(\"%s\", msg);\n  if (sv_logfile)\n    fprintf(sv_logfile, \"%s\", msg);\n\n}\n\n\nqboolean SV_SendClientDatagram(client_t *client)\n{\n  byte buf[1450];\n  sizebuf_t msg;\n  msg.data = buf;\n  msg.maxsize = sizeof(buf);\n  msg.cursize = 0;\n  msg.allowoverflow = true;\n  msg.overflowed = false;\n  SV_WriteClientdataToMessage(client, &msg);\n  SV_WriteEntitiesToClient(client, &msg);\n  if (client->datagram.overflowed)\n    Con_Printf(\"WARNING: datagram overflowed for %s\\n\", client->name);\n  else\n    SZ_Write(&msg, client->datagram.data, client->datagram.cursize);\n\n  SZ_Clear(&client->datagram);\n  if (Netchan_CanReliable(&client->netchan))\n    SV_UpdateClientStats(client);\n\n  if (msg.overflowed)\n  {\n    Con_Printf(\"WARNING: msg overflowed for %s\\n\", client->name);\n    SZ_Clear(&msg);\n  }\n\n  Netchan_Transmit(&client->netchan, msg.cursize, buf);\n  return true;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0, cl = svs.clients; i < 32; i++, cl++)\n{\n  if (level < cl->messagelevel)\n    continue;\n\n  if (!cl->state)\n    continue;\n\n  SV_PrintToClient(cl, level, string);\n}\n\nstatic void SV_PrintToClient(client_t *cl, int level, char *string)\n{\n  do\n  {\n    {\n      ClientReliableWrite_Begin(cl, 8, Q_strlen(string) + 3);\n      ClientReliableWrite_Byte(cl, level);\n      ClientReliableWrite_String(cl, string);\n    }\n  }\n  while (0);\n  ;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0, client = svs.clients; j < 32; j++, client++)\n{\n  if (client->state != cs_spawned)\n    continue;\n\n  inrange = false;\n  if ((to == 4) || (to == 1))\n  {\n    vec3_t delta;\n    {\n      delta[0] = origin[0] - client->edict->v.origin[0];\n      delta[1] = origin[1] - client->edict->v.origin[1];\n      delta[2] = origin[2] - client->edict->v.origin[2];\n    }\n    ;\n    if (Length(delta) <= 1024)\n      inrange = true;\n\n  }\n\n  if (!inrange)\n  {\n    leaf = Mod_PointInLeaf(client->edict->v.origin, sv.worldmodel);\n    if (leaf)\n    {\n      leafnum = (leaf - sv.worldmodel->leafs) - 1;\n      if (!(mask[leafnum >> 3] & (1 << (leafnum & 7))))\n      {\n        continue;\n      }\n\n    }\n\n  }\n\n  do\n  {\n    {\n      if (reliable)\n      {\n        ClientReliableCheckBlock(client, sv.multicast.cursize);\n        ClientReliableWrite_SZ(client, sv.multicast.data, sv.multicast.cursize);\n      }\n      else\n        SZ_Write(&client->datagram, sv.multicast.data, sv.multicast.cursize);\n\n    }\n  }\n  while (0);\n  ;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (sound_num = 1; (sound_num < 256) && sv.sound_precache[sound_num]; sound_num++)\n  if (!Q_strcmp(sample, sv.sound_precache[sound_num]))\n  break;\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n  origin[i] = entity->v.origin[i] + (0.5 * (entity->v.mins[i] + entity->v.maxs[i]));\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n  MSG_WriteCoord(&sv.multicast, origin[i]);\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n{\n  if (!sv.model_precache[i])\n    break;\n\n  if (!strcmp(sv.model_precache[i], \"progs/spike.mdl\"))\n    sv_nailmodel = i;\n\n  if (!strcmp(sv.model_precache[i], \"progs/s_spike.mdl\"))\n    sv_supernailmodel = i;\n\n  if (!strcmp(sv.model_precache[i], \"progs/player.mdl\"))\n    sv_playermodel = i;\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n  MSG_WriteCoord(msg, other->v.origin[i] + (0.5 * (other->v.mins[i] + other->v.maxs[i])));\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 3; i++)\n  MSG_WriteAngle(msg, ent->v.angles[i]);\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  if (stats[i] != client->stats[i])\n{\n  client->stats[i] = stats[i];\n  if ((stats[i] >= 0) && (stats[i] <= 255))\n  {\n    ClientReliableWrite_Begin(client, 3, 3);\n    ClientReliableWrite_Byte(client, i);\n    ClientReliableWrite_Byte(client, stats[i]);\n  }\n  else\n  {\n    ClientReliableWrite_Begin(client, 38, 6);\n    ClientReliableWrite_Byte(client, i);\n    ClientReliableWrite_Long(client, stats[i]);\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, c = svs.clients; i < 32; i++, c++)\n  if (c->state)\n  c->send_message = true;\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, c = svs.clients; i < 32; i++, c++)\n{\n  if (c->state > cs_connected)\n  {\n    if ((c->netchan.message.cursize + 5) <= c->netchan.message.maxsize)\n    {\n      MSG_WriteByte(&c->netchan.message, 54);\n      MSG_WriteFloat(&c->netchan.message, srv_frametime_avg);\n    }\n    else\n      Con_Printf(\"OOOPS: Didn't send the average frametime for client %d!\\n\", i);\n\n  }\n\n}\n\nvoid Con_Printf(char *fmt, ...)\n{\n  va_list argptr;\n  char msg[8192];\n  __builtin_va_start(argptr);\n  Q_vsprintf(msg, fmt, argptr);\n  ;\n  if (sv_redirected)\n  {\n    if ((Q_strlen(msg) + Q_strlen(outputbuf)) > ((8192 * (sizeof(char))) - 1))\n      SV_FlushRedirect();\n\n    Q_strcat(outputbuf, msg);\n    return;\n  }\n\n  if (inTransaction == true)\n  {\n    AddMsg2List(false, msg);\n    return;\n  }\n\n  Sys_Printf(\"%s\", msg);\n  if (sv_logfile)\n    fprintf(sv_logfile, \"%s\", msg);\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(svs, sv, realtime, net_socket, sv_nailmodel, sv_supernailmodel, sv_playermodel) private(i, j, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (axis = 0; axis <= 2; axis++)\n{\n  fprintf(stderr, \"%s: doing axis %d projections ... \\n\", me, axis);\n  fflush(stderr);\n  if (ninspect_proj(nproj[axis], nin, axis, smart, amount))\n  {\n    fprintf(stderr, \"ERROR\\n\");\n    sprintf(err, \"%s: trouble doing projections for axis %d\", me, axis);\n    biffAdd(\"ninspect\", err);\n    airMopError(mop);\n    abort = 1;\n  }\n\n  fprintf(stderr, \"%s: ... done with axis %d projections\\n\", me, axis);\n}\n\nint ninspect_proj(Nrrd *nout, Nrrd *nin, int axis, int smart, float amount)\n{\n  char me[] = \"ninspect_proj\";\n  char err[BIFF_STRLEN];\n  airArray *mop;\n  Nrrd *ntmpA;\n  Nrrd *ntmpB;\n  Nrrd *nrgb[3];\n  int bins;\n  if (!(nout && nin))\n  {\n    sprintf(err, \"%s: got NULL pointer\", me);\n    biffAdd(\"ninspect\", err);\n    return 1;\n  }\n\n  if (!((0 <= axis) && (axis <= 2)))\n  {\n    sprintf(err, \"%s: given axis %d outside valid range [0,1,2]\", me, axis);\n    biffAdd(\"ninspect\", err);\n    return 1;\n  }\n\n  mop = airMopNew();\n  airMopAdd(mop, ntmpA = nrrdNew(), (airMopper) nrrdNuke, airMopAlways);\n  airMopAdd(mop, ntmpB = nrrdNew(), (airMopper) nrrdNuke, airMopAlways);\n  airMopAdd(mop, nrgb[0] = nrrdNew(), (airMopper) nrrdNuke, airMopAlways);\n  airMopAdd(mop, nrgb[1] = nrrdNew(), (airMopper) nrrdNuke, airMopAlways);\n  airMopAdd(mop, nrgb[2] = nrrdNew(), (airMopper) nrrdNuke, airMopAlways);\n  bins = 3000;\n  if ((((((((nrrdProject(ntmpA, nin, axis, nrrdMeasureSum, nrrdTypeDefault) || nrrdHistoEq(ntmpB, ntmpA, 0, bins, smart, amount)) || nrrdQuantize(nrgb[0], ntmpB, 0, 8)) || nrrdProject(ntmpA, nin, axis, nrrdMeasureVariance, nrrdTypeDefault)) || nrrdHistoEq(ntmpB, ntmpA, 0, bins, smart, amount)) || nrrdQuantize(nrgb[1], ntmpB, 0, 8)) || nrrdProject(ntmpA, nin, axis, nrrdMeasureMax, nrrdTypeDefault)) || nrrdQuantize(nrgb[2], ntmpA, 0, 8)) || nrrdJoin(nout, (const Nrrd **) nrgb, 3, 0, 1))\n  {\n    sprintf(err, \"%s: trouble with nrrd operations\", me);\n    biffMove(\"ninspect\", err, nrrdBiffKey);\n    airMopError(mop);\n    return 1;\n  }\n\n  airMopOkay(mop);\n  return 0;\n}\n\n\n", "pragma": "omp parallel for shared(nproj,nin)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 0; ii < 3; ii++)\n{\n  dot[0] = ((vec[ii][0] * nvol->axis[0].spaceDirection[0]) + (vec[ii][1] * nvol->axis[0].spaceDirection[1])) + (vec[ii][2] * nvol->axis[0].spaceDirection[2]);\n  dot[1] = ((vec[ii][0] * nvol->axis[1].spaceDirection[0]) + (vec[ii][1] * nvol->axis[1].spaceDirection[1])) + (vec[ii][2] * nvol->axis[1].spaceDirection[2]);\n  dot[2] = ((vec[ii][0] * nvol->axis[2].spaceDirection[0]) + (vec[ii][1] * nvol->axis[2].spaceDirection[1])) + (vec[ii][2] * nvol->axis[2].spaceDirection[2]);\n  dot[0] = (dot[0] > 0.0f) ? (dot[0]) : (-dot[0]);\n  dot[1] = (dot[1] > 0.0f) ? (dot[1]) : (-dot[1]);\n  dot[2] = (dot[2] > 0.0f) ? (dot[2]) : (-dot[2]);\n  map[ii] = (dot[0] > dot[1]) ? ((dot[1] > dot[2]) ? (0) : ((dot[0] > dot[2]) ? (0) : (2))) : ((dot[2] > dot[1]) ? (2) : (1));\n}\n\n", "pragma": "omp parallel for shared(nproj,nin)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 0; ii < 3; ii++)\n{\n  if (h[map[ii]] != map[h[ii]])\n  {\n    if (!E)\n      E |= nrrdAxesSwap(ntmp[ii], nproj[map[ii]], 1, 2);\n\n  }\n  else\n  {\n    if (!E)\n      E |= nrrdCopy(ntmp[ii], nproj[map[ii]]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(nproj,nin)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 0; ii < 3; ii++)\n{\n  sz[ii] = nvol->axis[map[ii]].size;\n  sp[ii] = sqrt(((nvol->axis[map[ii]].spaceDirection[0] * nvol->axis[map[ii]].spaceDirection[0]) + (nvol->axis[map[ii]].spaceDirection[1] * nvol->axis[map[ii]].spaceDirection[1])) + (nvol->axis[map[ii]].spaceDirection[2] * nvol->axis[map[ii]].spaceDirection[2]));\n}\n\n", "pragma": "omp parallel for shared(nproj,nin)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = 0; pos < nin->axis[axis].size; pos++)\n{\n  if ((nout == 0) && (nnout == 0))\n  {\n    nout = nrrdNew();\n    airMopAdd(mop, nout, (airMopper) nrrdNuke, airMopAlways);\n    nnout = (Nrrd **) malloc(sizeof(Nrrd *));\n    nnout[0] = nout;\n  }\n\n  if (nrrdSlice(nout, nin, axis, pos))\n  {\n    airMopAdd(mop, err = biffGetDone(nrrdBiffKey), airFree, airMopAlways);\n    fprintf(stderr, \"%s: error slicing nrrd:%s\\n\", me, err);\n    airMopError(mop);\n    abort = 1;\n  }\n\n  fprintf(stderr, \"%s: \", me);\n  fprintf(stderr, fnout, pos + start);\n  fprintf(stderr, \" ...\\n\");\n  if (nrrdSaveMulti(fnout, (const Nrrd * const *) nnout, 1, pos + start, 0))\n  {\n    airMopAdd(mop, err = biffGetDone(nrrdBiffKey), airFree, airMopAlways);\n    fprintf(stderr, \"%s: error writing nrrd to \\\"%s\\\":%s\\n\", me, fnout, err);\n    airMopError(mop);\n    abort = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(nout, nnout)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (new_keys)\n    sevenzip_kdf(index, master[index]);\n\n  cracked[index] = sevenzip_decrypt(master[index]);\n}\n\nstatic void sevenzip_kdf(int index, unsigned char *master)\n{\n  long long rounds = ((long long) 1) << sevenzip_salt->NumCyclesPower;\n  long long round;\n  int i;\n  unsigned char temp[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  jtr_sha256_ctx sha;\n  jtr_sha256_init(&sha, 1);\n  for (round = 0; round < rounds; round++)\n  {\n    if (sevenzip_salt->SaltSize)\n      jtr_sha256_update(&sha, sevenzip_salt->salt, sevenzip_salt->SaltSize);\n\n    jtr_sha256_update(&sha, (char *) saved_key[index], saved_len[index]);\n    jtr_sha256_update(&sha, temp, 8);\n    for (i = 0; i < 8; i++)\n      if ((++temp[i]) != 0)\n      break;\n\n\n  }\n\n  jtr_sha256_final(master, &sha);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (round = 0; round < rounds; round++)\n{\n  if (sevenzip_salt->SaltSize)\n    jtr_sha256_update(&sha, sevenzip_salt->salt, sevenzip_salt->SaltSize);\n\n  jtr_sha256_update(&sha, (char *) saved_key[index], saved_len[index]);\n  jtr_sha256_update(&sha, temp, 8);\n  for (i = 0; i < 8; i++)\n    if ((++temp[i]) != 0)\n    break;\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  UTF16 Buf[125 + 1];\n  unsigned char hash[16];\n  unsigned char hex[33];\n  int len;\n  int cnt;\n  int i;\n  MD4_CTX ctx;\n  cnt = 1;\n  if (dirty)\n    for (i = 0; i < cnt; ++i)\n  {\n    len = enc_to_utf16(Buf, 125, (UTF8 *) saved_key[index + i], strlen(saved_key[index + i]));\n    if (len < 0)\n      len = 0;\n\n    john_MD4_Init(&ctx);\n    john_MD4_Update(&ctx, Buf, len * 2);\n    john_MD4_Final(hash, &ctx);\n    base64_convert(hash, e_b64_raw, 16, hex, e_b64_hex, sizeof(hex), 0x01, 0);\n    for (len = 0; len < 32; ++len)\n      saved_nt[index + i][len << 1] = hex[len];\n\n  }\n\n\n  pbkdf2_sha256((unsigned char *) saved_nt[index], 64, AzureAD_cur_salt->salt, AzureAD_cur_salt->salt_len, AzureAD_cur_salt->iterations, (unsigned char *) crypt_out[index], 32, 0);\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 4))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (saved_key[index][0] != 0)\n    blowfish_encrypt_pass(saved_key[index], (char *) crypt_out[index]);\n\n}\n\nstatic void blowfish_encrypt_pass(char *text, char *new)\n{\n  unsigned int left;\n  unsigned int right;\n  unsigned int bf_S[4][256];\n  unsigned int bf_P[16 + 2];\n  blowfish_init(bf_P, bf_S, (unsigned char *) text, strlen(text));\n  left = 0xdeadd061;\n  right = 0x23f6b095;\n  blowfish_encipher(bf_P, bf_S, &left, &right);\n  left = __builtin_bswap32(left);\n  right = __builtin_bswap32(right);\n  memcpy(new, (unsigned char *) (&right), 32 / 8);\n  memcpy(new + (32 / 8), (unsigned char *) (&left), (32 / 8) - 1);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = &ciphertext[1]; atoi64[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = _itoa64; pos <= (&_itoa64[63]); pos++)\n  _atoi64[ARCH_INDEX(*pos)] = pos - _itoa64;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 4))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < n; t++)\n{\n  struct BF_ctx BF_current;\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  int index;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current.S, BF_init_state.S, sizeof(BF_current.S));\n    memcpy(BF_current.P, BF_init_key[index], sizeof(BF_current.P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_current.P[i] = L0;\n      BF_current.P[i + 1] = R0;\n    }\n\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current.P[0] ^= BF_exp_key[index][0];\n      BF_current.P[1] ^= BF_exp_key[index][1];\n      BF_current.P[2] ^= BF_exp_key[index][2];\n      BF_current.P[3] ^= BF_exp_key[index][3];\n      BF_current.P[4] ^= BF_exp_key[index][4];\n      BF_current.P[5] ^= BF_exp_key[index][5];\n      BF_current.P[6] ^= BF_exp_key[index][6];\n      BF_current.P[7] ^= BF_exp_key[index][7];\n      BF_current.P[8] ^= BF_exp_key[index][8];\n      BF_current.P[9] ^= BF_exp_key[index][9];\n      BF_current.P[10] ^= BF_exp_key[index][10];\n      BF_current.P[11] ^= BF_exp_key[index][11];\n      BF_current.P[12] ^= BF_exp_key[index][12];\n      BF_current.P[13] ^= BF_exp_key[index][13];\n      BF_current.P[14] ^= BF_exp_key[index][14];\n      BF_current.P[15] ^= BF_exp_key[index][15];\n      BF_current.P[16] ^= BF_exp_key[index][16];\n      BF_current.P[17] ^= BF_exp_key[index][17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current.P[0] ^= u1;\n      BF_current.P[1] ^= u2;\n      BF_current.P[2] ^= u3;\n      BF_current.P[3] ^= u4;\n      BF_current.P[4] ^= u1;\n      BF_current.P[5] ^= u2;\n      BF_current.P[6] ^= u3;\n      BF_current.P[7] ^= u4;\n      BF_current.P[8] ^= u1;\n      BF_current.P[9] ^= u2;\n      BF_current.P[10] ^= u3;\n      BF_current.P[11] ^= u4;\n      BF_current.P[12] ^= u1;\n      BF_current.P[13] ^= u2;\n      BF_current.P[14] ^= u3;\n      BF_current.P[15] ^= u4;\n      BF_current.P[16] ^= u1;\n      BF_current.P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current.P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, BF_init_state, BF_init_key, BF_exp_key, salt, BF_magic_w, BF_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (16 + 2); i++)\n{\n  tmp = 0;\n  for (j = 0; j < 4; j++)\n  {\n    tmp <<= 8;\n    if (sign_extension_bug)\n      tmp |= (int) ((signed char) (*ptr));\n    else\n      tmp |= (unsigned char) (*ptr);\n\n    if (!(*ptr))\n      ptr = key;\n    else\n      ptr++;\n\n  }\n\n  BF_exp_key[index][i] = tmp;\n  BF_init_key[index][i] = BF_init_state.P[i] ^ tmp;\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, BF_init_state, BF_init_key, BF_exp_key, salt, BF_magic_w, BF_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  value = binary[0];\n  b = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]);\n  mask = b[0] ^ (-(value & 1));\n  mask |= b[1] ^ (-((value >> 1) & 1));\n  mask |= b[2] ^ (-((value >> 2) & 1));\n  mask |= b[3] ^ (-((value >> 3) & 1));\n  if (mask == (~((long) 0)))\n    goto next_depth;\n\n  value >>= 4;\n  b += 4;\n  for (bit = 4; bit < 32; bit += 2)\n  {\n    mask |= b[0] ^ (-(value & 1));\n    if (mask == (~((long) 0)))\n      goto next_depth;\n\n    mask |= b[1] ^ (-((value >> 1) & 1));\n    if (mask == (~((long) 0)))\n      goto next_depth;\n\n    value >>= 2;\n    b += 2;\n  }\n\n  retval = 1;\n  next_depth:\n  ;\n\n}\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  k = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).KS.p;\n  s = 0;\n  for (round = 0; round < 16; round++)\n  {\n    s += DES_ROT[round];\n    for (index = 0; index < 48; index++)\n    {\n      p = DES_PC2[index];\n      q = (p < 28) ? (0) : (28);\n      p += s;\n      while (p >= 28)\n        p -= 28;\n\n      bit = DES_PC1[p + q];\n      bit ^= 070;\n      bit -= bit >> 3;\n      bit = 55 - bit;\n      if (LM == 1)\n        bit = DES_LM_KP[bit];\n\n      *(k++) = &(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).K[bit];\n    }\n\n  }\n\n  for (index = 0; index < ARCH_BITS; index++)\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).pxkeys[index] = &(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.c[0][index & 7][index >> 3];\n\n  if (LM == 1)\n  {\n    for (c = 0; c < 0x100; c++)\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.u[c] = CP_up[c];\n\n  }\n  else\n    if (LM == 0)\n  {\n    for (index = 0; index < 48; index++)\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[index] = &(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[DES_E[index]];\n\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).salt = 0xffffff;\n    DES_bs_set_salt_for_thread(t, 0);\n  }\n\n\n  memset(&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).zero, 0, sizeof((*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).zero));\n  memset(&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).ones, -1, sizeof((*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).ones));\n  for (bit = 0; bit < 8; bit++)\n    memset(&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).masks[bit], 1 << bit, sizeof((*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).masks[bit]));\n\n}\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < 16; index += 2)\n{\n  l = atoi16[ARCH_INDEX(ciphertext[index])];\n  h = atoi16[ARCH_INDEX(ciphertext[index + 1])];\n  value = DES_LM_reverse[l] | (DES_LM_reverse[h] << 4);\n  block[index >> 3] |= value << ((index << 2) & 0x18);\n}\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < 16; index += 2)\n{\n  value = (block[index >> 3] >> ((index << 2) & 0x18)) & 0xff;\n  l = DES_LM_reverse[value & 0xf];\n  h = DES_LM_reverse[value >> 4];\n  *(p++) = itoa16[l];\n  *(p++) = itoa16[h];\n}\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (bit = 26; bit >= 0; bit--)\n  if (((((unsigned int) (*((unsigned char *) (&b[bit])))) >> index) ^ (binary[0] >> bit)) & 1)\n  return 0;\n\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (bit = 0; bit < count; bit++)\n  if (((((unsigned int) (*((unsigned char *) (&b[bit])))) >> index) ^ (binary[1] >> bit)) & 1)\n  return 0;\n\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  long value = -((long) ((plaintext[i >> 3] >> (7 - (i & 7))) & 1));\n  DES_bs_P[i] = value;\n}\n\n", "pragma": "omp parallel for if(n >= 96) default(none) private(value, mask, bit, b, t) shared(n, DES_bs_all_p, retval, binary)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  long **k;\n  int iterations;\n  int rounds_and_swapped;\n  if ((*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).keys_changed)\n    goto finalize_keys;\n\n  body:\n  DES_bs_set_salt_for_thread(t, (*((DES_bs_combined *) (((char *) DES_bs_all_p) + ((-1) * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1))))))).salt);\n\n  {\n    vtype zero = 0;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 7)) = zero;\n    }\n    ;\n  }\n  k = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).KS.p;\n  rounds_and_swapped = 8;\n  iterations = 25;\n  start:\n  s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[0][0]))) ^ (*((vtype *) (&k[0][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[1][0]))) ^ (*((vtype *) (&k[1][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[2][0]))) ^ (*((vtype *) (&k[2][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[3][0]))) ^ (*((vtype *) (&k[3][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[4][0]))) ^ (*((vtype *) (&k[4][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[5][0]))) ^ (*((vtype *) (&k[5][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]));\n\n  s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[6][0]))) ^ (*((vtype *) (&k[6][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[7][0]))) ^ (*((vtype *) (&k[7][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[8][0]))) ^ (*((vtype *) (&k[8][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[9][0]))) ^ (*((vtype *) (&k[9][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[10][0]))) ^ (*((vtype *) (&k[10][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[11][0]))) ^ (*((vtype *) (&k[11][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]));\n  s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]))) ^ (*((vtype *) (&k[12][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]))) ^ (*((vtype *) (&k[13][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]))) ^ (*((vtype *) (&k[14][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]))) ^ (*((vtype *) (&k[15][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[16][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[17][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]));\n  s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[18][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[19][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]))) ^ (*((vtype *) (&k[20][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]))) ^ (*((vtype *) (&k[21][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]))) ^ (*((vtype *) (&k[22][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]))) ^ (*((vtype *) (&k[23][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]));\n  s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[24][0]))) ^ (*((vtype *) (&k[24][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[25][0]))) ^ (*((vtype *) (&k[25][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[26][0]))) ^ (*((vtype *) (&k[26][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[27][0]))) ^ (*((vtype *) (&k[27][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[28][0]))) ^ (*((vtype *) (&k[28][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[29][0]))) ^ (*((vtype *) (&k[29][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]));\n  s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[30][0]))) ^ (*((vtype *) (&k[30][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[31][0]))) ^ (*((vtype *) (&k[31][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[32][0]))) ^ (*((vtype *) (&k[32][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[33][0]))) ^ (*((vtype *) (&k[33][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[34][0]))) ^ (*((vtype *) (&k[34][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[35][0]))) ^ (*((vtype *) (&k[35][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]));\n  s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]))) ^ (*((vtype *) (&k[36][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]))) ^ (*((vtype *) (&k[37][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]))) ^ (*((vtype *) (&k[38][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]))) ^ (*((vtype *) (&k[39][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[40][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[41][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]));\n  s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[42][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[43][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]))) ^ (*((vtype *) (&k[44][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]))) ^ (*((vtype *) (&k[45][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]))) ^ (*((vtype *) (&k[46][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]))) ^ (*((vtype *) (&k[47][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]));\n  if (rounds_and_swapped == 0x100)\n    goto next;\n\n  swap:\n  s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[48][0]))) ^ (*((vtype *) (&k[48][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[49][0]))) ^ (*((vtype *) (&k[49][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[50][0]))) ^ (*((vtype *) (&k[50][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[51][0]))) ^ (*((vtype *) (&k[51][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[52][0]))) ^ (*((vtype *) (&k[52][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[53][0]))) ^ (*((vtype *) (&k[53][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]));\n\n  s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[54][0]))) ^ (*((vtype *) (&k[54][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[55][0]))) ^ (*((vtype *) (&k[55][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[56][0]))) ^ (*((vtype *) (&k[56][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[57][0]))) ^ (*((vtype *) (&k[57][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[58][0]))) ^ (*((vtype *) (&k[58][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[59][0]))) ^ (*((vtype *) (&k[59][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]));\n  s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]))) ^ (*((vtype *) (&k[60][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]))) ^ (*((vtype *) (&k[61][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]))) ^ (*((vtype *) (&k[62][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]))) ^ (*((vtype *) (&k[63][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[64][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[65][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]));\n  s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[66][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[67][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]))) ^ (*((vtype *) (&k[68][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]))) ^ (*((vtype *) (&k[69][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]))) ^ (*((vtype *) (&k[70][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]))) ^ (*((vtype *) (&k[71][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]));\n  s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[72][0]))) ^ (*((vtype *) (&k[72][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[73][0]))) ^ (*((vtype *) (&k[73][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[74][0]))) ^ (*((vtype *) (&k[74][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[75][0]))) ^ (*((vtype *) (&k[75][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[76][0]))) ^ (*((vtype *) (&k[76][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[77][0]))) ^ (*((vtype *) (&k[77][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]));\n  s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[78][0]))) ^ (*((vtype *) (&k[78][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[79][0]))) ^ (*((vtype *) (&k[79][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[80][0]))) ^ (*((vtype *) (&k[80][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[81][0]))) ^ (*((vtype *) (&k[81][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[82][0]))) ^ (*((vtype *) (&k[82][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[83][0]))) ^ (*((vtype *) (&k[83][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]));\n  s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]))) ^ (*((vtype *) (&k[84][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]))) ^ (*((vtype *) (&k[85][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]))) ^ (*((vtype *) (&k[86][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]))) ^ (*((vtype *) (&k[87][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[88][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[89][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]));\n  s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[90][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[91][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]))) ^ (*((vtype *) (&k[92][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]))) ^ (*((vtype *) (&k[93][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]))) ^ (*((vtype *) (&k[94][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]))) ^ (*((vtype *) (&k[95][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]));\n  k += 96;\n  if (--rounds_and_swapped)\n    goto start;\n\n  k -= 0x300 + 48;\n  rounds_and_swapped = 0x108;\n  if (--iterations)\n    goto swap;\n\n  if (precheck)\n  {\n    struct db_password *pw = salt->list;\n    do\n    {\n      uint32_t binary = *((uint32_t *) pw->binary);\n      {\n        uint32_t u = binary;\n        vtype mask = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]));\n        if (u & (1 << 26))\n          mask = ~mask;\n\n        int bit = 0;\n        do\n        {\n          vtype v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit]));\n          if (u & 1)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 1]));\n          if (u & 2)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 2]));\n          if (u & 4)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 3]));\n          if (u & 8)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          u >>= 4;\n        }\n        while ((bit += 4) <= 28);\n        precheck = 0;\n        goto next_batch;\n        next_depth:\n        ;\n\n      }\n    }\n    while (pw = pw->next);\n  }\n\n  next_batch:\n  continue;\n\n  next:\n  k -= 0x300 - 48;\n\n  rounds_and_swapped = 8;\n  iterations--;\n  goto start;\n  finalize_keys:\n  (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).keys_changed = 0;\n\n  DES_bs_finalize_keys(t);\n  goto body;\n}\n\ninline void DES_bs_set_salt_for_thread(int t, unsigned int salt)\n{\n  unsigned int new = salt;\n  unsigned int old = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).salt;\n  int dst;\n  (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).salt = new;\n  for (dst = 0; dst < 24; dst++)\n  {\n    if ((new ^ old) & 1)\n    {\n      long *sp1;\n      long *sp2;\n      int src1 = dst;\n      int src2 = dst + 24;\n      if (new & 1)\n      {\n        src1 = src2;\n        src2 = dst;\n      }\n\n      sp1 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src1];\n      sp2 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src2];\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst] = (long *) sp1;\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 24] = (long *) sp2;\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 48] = (long *) (sp1 + 32);\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 72] = (long *) (sp2 + 32);\n    }\n\n    new >>= 1;\n    old >>= 1;\n    if (new == old)\n      break;\n\n  }\n\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void DES_bs_finalize_keys(int t)\n{\n  {\n    long *kp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).K[0]);\n    int ic;\n    for (ic = 0; ic < 8; ic++)\n    {\n      long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n      vtype v0 = *((vtype *) (&vp[0]));\n      vtype v1 = *((vtype *) (&vp[1]));\n      vtype v2 = *((vtype *) (&vp[2]));\n      vtype v3 = *((vtype *) (&vp[3]));\n      vtype v4 = *((vtype *) (&vp[4]));\n      vtype v5 = *((vtype *) (&vp[5]));\n      vtype v6 = *((vtype *) (&vp[6]));\n      vtype v7 = *((vtype *) (&vp[7]));\n      {\n        vtype m = 0x0101010101010101UL;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        va = v0 & m;\n        tmp = v1 & m;\n        vb = tmp << 1;\n        tmp = v2 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 6;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 7;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 1;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 1;\n        vb = v1 & m;\n        tmp = v2 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 5;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 6;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 2;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 2;\n        tmp = v1 & m;\n        vb = tmp >> 1;\n        tmp = v2 & m;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 3;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 3;\n        tmp = v1 & m;\n        vb = tmp >> 2;\n        tmp = v2 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 4;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 4;\n        tmp = v1 & m;\n        vb = tmp >> 3;\n        tmp = v2 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 5;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 5;\n        tmp = v1 & m;\n        vb = tmp >> 4;\n        tmp = v2 & m;\n        tmp = tmp >> 3;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 6;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 6;\n        tmp = v1 & m;\n        vb = tmp >> 5;\n        tmp = v2 & m;\n        tmp = tmp >> 4;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n    }\n\n  }\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, salt, precheck)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  long **k;\n  int iterations;\n  int rounds_and_swapped;\n  if ((*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).keys_changed)\n    goto finalize_keys;\n\n  body:\n  DES_bs_set_salt_for_thread(t, (*((DES_bs_combined *) (((char *) DES_bs_all_p) + ((-1) * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1))))))).salt);\n\n  {\n    vtype zero = 0;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 7)) = zero;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 0)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 1)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 2)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 3)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 4)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 5)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 6)) = zero;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 7)) = zero;\n    }\n    ;\n  }\n  k = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).KS.p;\n  rounds_and_swapped = 8;\n  iterations = count;\n  start:\n  s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[0][0]))) ^ (*((vtype *) (&k[0][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[1][0]))) ^ (*((vtype *) (&k[1][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[2][0]))) ^ (*((vtype *) (&k[2][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[3][0]))) ^ (*((vtype *) (&k[3][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[4][0]))) ^ (*((vtype *) (&k[4][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[5][0]))) ^ (*((vtype *) (&k[5][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]));\n\n  s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[6][0]))) ^ (*((vtype *) (&k[6][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[7][0]))) ^ (*((vtype *) (&k[7][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[8][0]))) ^ (*((vtype *) (&k[8][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[9][0]))) ^ (*((vtype *) (&k[9][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[10][0]))) ^ (*((vtype *) (&k[10][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[11][0]))) ^ (*((vtype *) (&k[11][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]));\n  s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[12][0]))) ^ (*((vtype *) (&k[12][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[13][0]))) ^ (*((vtype *) (&k[13][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[14][0]))) ^ (*((vtype *) (&k[14][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[15][0]))) ^ (*((vtype *) (&k[15][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[16][0]))) ^ (*((vtype *) (&k[16][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[17][0]))) ^ (*((vtype *) (&k[17][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]));\n  s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[18][0]))) ^ (*((vtype *) (&k[18][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[19][0]))) ^ (*((vtype *) (&k[19][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[20][0]))) ^ (*((vtype *) (&k[20][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[21][0]))) ^ (*((vtype *) (&k[21][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[22][0]))) ^ (*((vtype *) (&k[22][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[23][0]))) ^ (*((vtype *) (&k[23][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]));\n  s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[24][0]))) ^ (*((vtype *) (&k[24][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[25][0]))) ^ (*((vtype *) (&k[25][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[26][0]))) ^ (*((vtype *) (&k[26][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[27][0]))) ^ (*((vtype *) (&k[27][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[28][0]))) ^ (*((vtype *) (&k[28][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[29][0]))) ^ (*((vtype *) (&k[29][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]));\n  s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[30][0]))) ^ (*((vtype *) (&k[30][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[31][0]))) ^ (*((vtype *) (&k[31][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[32][0]))) ^ (*((vtype *) (&k[32][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[33][0]))) ^ (*((vtype *) (&k[33][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[34][0]))) ^ (*((vtype *) (&k[34][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[35][0]))) ^ (*((vtype *) (&k[35][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]));\n  s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[36][0]))) ^ (*((vtype *) (&k[36][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[37][0]))) ^ (*((vtype *) (&k[37][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[38][0]))) ^ (*((vtype *) (&k[38][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[39][0]))) ^ (*((vtype *) (&k[39][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[40][0]))) ^ (*((vtype *) (&k[40][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[41][0]))) ^ (*((vtype *) (&k[41][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]));\n  s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[42][0]))) ^ (*((vtype *) (&k[42][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[43][0]))) ^ (*((vtype *) (&k[43][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[44][0]))) ^ (*((vtype *) (&k[44][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[45][0]))) ^ (*((vtype *) (&k[45][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[46][0]))) ^ (*((vtype *) (&k[46][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[47][0]))) ^ (*((vtype *) (&k[47][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]));\n  if (rounds_and_swapped == 0x100)\n    goto next;\n\n  swap:\n  s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[48][0]))) ^ (*((vtype *) (&k[48][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[49][0]))) ^ (*((vtype *) (&k[49][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[50][0]))) ^ (*((vtype *) (&k[50][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[51][0]))) ^ (*((vtype *) (&k[51][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[52][0]))) ^ (*((vtype *) (&k[52][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[53][0]))) ^ (*((vtype *) (&k[53][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]));\n\n  s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[54][0]))) ^ (*((vtype *) (&k[54][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[55][0]))) ^ (*((vtype *) (&k[55][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[56][0]))) ^ (*((vtype *) (&k[56][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[57][0]))) ^ (*((vtype *) (&k[57][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[58][0]))) ^ (*((vtype *) (&k[58][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[59][0]))) ^ (*((vtype *) (&k[59][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]));\n  s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[60][0]))) ^ (*((vtype *) (&k[60][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[61][0]))) ^ (*((vtype *) (&k[61][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[62][0]))) ^ (*((vtype *) (&k[62][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[63][0]))) ^ (*((vtype *) (&k[63][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[64][0]))) ^ (*((vtype *) (&k[64][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[65][0]))) ^ (*((vtype *) (&k[65][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]));\n  s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[66][0]))) ^ (*((vtype *) (&k[66][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[67][0]))) ^ (*((vtype *) (&k[67][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[68][0]))) ^ (*((vtype *) (&k[68][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[69][0]))) ^ (*((vtype *) (&k[69][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[70][0]))) ^ (*((vtype *) (&k[70][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[71][0]))) ^ (*((vtype *) (&k[71][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]));\n  s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[72][0]))) ^ (*((vtype *) (&k[72][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[73][0]))) ^ (*((vtype *) (&k[73][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[74][0]))) ^ (*((vtype *) (&k[74][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[75][0]))) ^ (*((vtype *) (&k[75][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[76][0]))) ^ (*((vtype *) (&k[76][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[77][0]))) ^ (*((vtype *) (&k[77][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]));\n  s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[78][0]))) ^ (*((vtype *) (&k[78][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[79][0]))) ^ (*((vtype *) (&k[79][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[80][0]))) ^ (*((vtype *) (&k[80][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[81][0]))) ^ (*((vtype *) (&k[81][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[82][0]))) ^ (*((vtype *) (&k[82][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[83][0]))) ^ (*((vtype *) (&k[83][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]));\n  s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[84][0]))) ^ (*((vtype *) (&k[84][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[85][0]))) ^ (*((vtype *) (&k[85][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[86][0]))) ^ (*((vtype *) (&k[86][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[87][0]))) ^ (*((vtype *) (&k[87][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[88][0]))) ^ (*((vtype *) (&k[88][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[89][0]))) ^ (*((vtype *) (&k[89][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]));\n  s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[90][0]))) ^ (*((vtype *) (&k[90][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[91][0]))) ^ (*((vtype *) (&k[91][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[92][0]))) ^ (*((vtype *) (&k[92][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[93][0]))) ^ (*((vtype *) (&k[93][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[94][0]))) ^ (*((vtype *) (&k[94][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[95][0]))) ^ (*((vtype *) (&k[95][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]));\n  k += 96;\n  if (--rounds_and_swapped)\n    goto start;\n\n  k -= 0x300 + 48;\n  rounds_and_swapped = 0x108;\n  if (--iterations)\n    goto swap;\n\n  continue;\n  next:\n  k -= 0x300 - 48;\n\n  rounds_and_swapped = 8;\n  if (--iterations)\n    goto start;\n\n  continue;\n  finalize_keys:\n  (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).keys_changed = 0;\n\n  DES_bs_finalize_keys(t);\n  goto body;\n}\n\ninline void DES_bs_set_salt_for_thread(int t, unsigned int salt)\n{\n  unsigned int new = salt;\n  unsigned int old = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).salt;\n  int dst;\n  (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).salt = new;\n  for (dst = 0; dst < 24; dst++)\n  {\n    if ((new ^ old) & 1)\n    {\n      long *sp1;\n      long *sp2;\n      int src1 = dst;\n      int src2 = dst + 24;\n      if (new & 1)\n      {\n        src1 = src2;\n        src2 = dst;\n      }\n\n      sp1 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src1];\n      sp2 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src2];\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst] = (long *) sp1;\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 24] = (long *) sp2;\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 48] = (long *) (sp1 + 32);\n      (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 72] = (long *) (sp2 + 32);\n    }\n\n    new >>= 1;\n    old >>= 1;\n    if (new == old)\n      break;\n\n  }\n\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void DES_bs_finalize_keys(int t)\n{\n  {\n    long *kp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).K[0]);\n    int ic;\n    for (ic = 0; ic < 8; ic++)\n    {\n      long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n      vtype v0 = *((vtype *) (&vp[0]));\n      vtype v1 = *((vtype *) (&vp[1]));\n      vtype v2 = *((vtype *) (&vp[2]));\n      vtype v3 = *((vtype *) (&vp[3]));\n      vtype v4 = *((vtype *) (&vp[4]));\n      vtype v5 = *((vtype *) (&vp[5]));\n      vtype v6 = *((vtype *) (&vp[6]));\n      vtype v7 = *((vtype *) (&vp[7]));\n      {\n        vtype m = 0x0101010101010101UL;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        va = v0 & m;\n        tmp = v1 & m;\n        vb = tmp << 1;\n        tmp = v2 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 6;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 7;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 1;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 1;\n        vb = v1 & m;\n        tmp = v2 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 5;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 6;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 2;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 2;\n        tmp = v1 & m;\n        vb = tmp >> 1;\n        tmp = v2 & m;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 3;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 3;\n        tmp = v1 & m;\n        vb = tmp >> 2;\n        tmp = v2 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 4;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 4;\n        tmp = v1 & m;\n        vb = tmp >> 3;\n        tmp = v2 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 5;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 5;\n        tmp = v1 & m;\n        vb = tmp >> 4;\n        tmp = v2 & m;\n        tmp = tmp >> 3;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 6;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 6;\n        tmp = v1 & m;\n        vb = tmp >> 5;\n        tmp = v2 & m;\n        tmp = tmp >> 4;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n    }\n\n  }\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, count, keys_count)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  long **k;\n  int rounds;\n  {\n    vtype z = 0;\n    vtype o = ~((vtype) 0);\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 0)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 2)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 5)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 6)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0])) + 7)) = z;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 0)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 1)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 2)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 4)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 5)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 6)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8])) + 7)) = z;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 0)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 2)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 5)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 6)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16])) + 7)) = o;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 0)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 2)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 5)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 6)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24])) + 7)) = o;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 0)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 2)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 3)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 5)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 6)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32])) + 7)) = o;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 0)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 2)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 5)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 6)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40])) + 7)) = z;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 0)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 1)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 2)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 4)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 5)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 6)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48])) + 7)) = z;\n    }\n    ;\n    {\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 0)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 1)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 2)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 3)) = z;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 4)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 5)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 6)) = o;\n      *((vtype *) (((long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56])) + 7)) = o;\n    }\n    ;\n  }\n  DES_bs_finalize_keys_LM(t);\n  k = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).KS.p;\n  rounds = 8;\n  do\n  {\n    s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]))) ^ (*((vtype *) (&k[0][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]))) ^ (*((vtype *) (&k[1][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]))) ^ (*((vtype *) (&k[2][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]))) ^ (*((vtype *) (&k[3][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]))) ^ (*((vtype *) (&k[4][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]))) ^ (*((vtype *) (&k[5][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]));\n    s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]))) ^ (*((vtype *) (&k[6][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]))) ^ (*((vtype *) (&k[7][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]))) ^ (*((vtype *) (&k[8][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]))) ^ (*((vtype *) (&k[9][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]))) ^ (*((vtype *) (&k[10][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]))) ^ (*((vtype *) (&k[11][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]));\n    s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]))) ^ (*((vtype *) (&k[12][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]))) ^ (*((vtype *) (&k[13][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]))) ^ (*((vtype *) (&k[14][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]))) ^ (*((vtype *) (&k[15][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[16][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[17][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]));\n    s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[18][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[19][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]))) ^ (*((vtype *) (&k[20][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]))) ^ (*((vtype *) (&k[21][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]))) ^ (*((vtype *) (&k[22][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]))) ^ (*((vtype *) (&k[23][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]));\n    s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]))) ^ (*((vtype *) (&k[24][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]))) ^ (*((vtype *) (&k[25][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]))) ^ (*((vtype *) (&k[26][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]))) ^ (*((vtype *) (&k[27][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]))) ^ (*((vtype *) (&k[28][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]))) ^ (*((vtype *) (&k[29][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]));\n    s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]))) ^ (*((vtype *) (&k[30][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]))) ^ (*((vtype *) (&k[31][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]))) ^ (*((vtype *) (&k[32][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]))) ^ (*((vtype *) (&k[33][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]))) ^ (*((vtype *) (&k[34][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]))) ^ (*((vtype *) (&k[35][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]));\n    s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]))) ^ (*((vtype *) (&k[36][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]))) ^ (*((vtype *) (&k[37][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]))) ^ (*((vtype *) (&k[38][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]))) ^ (*((vtype *) (&k[39][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[40][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[41][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]));\n    s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[42][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[43][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]))) ^ (*((vtype *) (&k[44][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]))) ^ (*((vtype *) (&k[45][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]))) ^ (*((vtype *) (&k[46][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]))) ^ (*((vtype *) (&k[47][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]));\n    s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]))) ^ (*((vtype *) (&k[48][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]))) ^ (*((vtype *) (&k[49][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]))) ^ (*((vtype *) (&k[50][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]))) ^ (*((vtype *) (&k[51][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]))) ^ (*((vtype *) (&k[52][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]))) ^ (*((vtype *) (&k[53][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]));\n    s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]))) ^ (*((vtype *) (&k[54][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]))) ^ (*((vtype *) (&k[55][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]))) ^ (*((vtype *) (&k[56][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]))) ^ (*((vtype *) (&k[57][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]))) ^ (*((vtype *) (&k[58][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]))) ^ (*((vtype *) (&k[59][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]));\n    s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]))) ^ (*((vtype *) (&k[60][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]))) ^ (*((vtype *) (&k[61][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]))) ^ (*((vtype *) (&k[62][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]))) ^ (*((vtype *) (&k[63][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[64][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[65][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]));\n    s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[66][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[67][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]))) ^ (*((vtype *) (&k[68][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]))) ^ (*((vtype *) (&k[69][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]))) ^ (*((vtype *) (&k[70][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]))) ^ (*((vtype *) (&k[71][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]));\n    s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]))) ^ (*((vtype *) (&k[72][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]))) ^ (*((vtype *) (&k[73][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]))) ^ (*((vtype *) (&k[74][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]))) ^ (*((vtype *) (&k[75][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]))) ^ (*((vtype *) (&k[76][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]))) ^ (*((vtype *) (&k[77][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]));\n    s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]))) ^ (*((vtype *) (&k[78][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]))) ^ (*((vtype *) (&k[79][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]))) ^ (*((vtype *) (&k[80][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]))) ^ (*((vtype *) (&k[81][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]))) ^ (*((vtype *) (&k[82][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]))) ^ (*((vtype *) (&k[83][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]));\n    s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]))) ^ (*((vtype *) (&k[84][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]))) ^ (*((vtype *) (&k[85][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]))) ^ (*((vtype *) (&k[86][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]))) ^ (*((vtype *) (&k[87][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[88][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[89][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]));\n    s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[90][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[91][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]))) ^ (*((vtype *) (&k[92][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]))) ^ (*((vtype *) (&k[93][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]))) ^ (*((vtype *) (&k[94][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]))) ^ (*((vtype *) (&k[95][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]));\n    k += 96;\n  }\n  while (--rounds);\n  if (precheck)\n  {\n    struct db_password *pw = salt->list;\n    do\n    {\n      uint32_t binary = *((uint32_t *) pw->binary);\n      {\n        uint32_t u = binary;\n        vtype mask = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]));\n        if (u & (1 << 20))\n          mask = ~mask;\n\n        vtype v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]));\n        if (u & (1 << 14))\n          v = ~v;\n\n        mask = mask | v;\n        v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]));\n        if (u & (1 << 26))\n          v = ~v;\n\n        mask = mask | v;\n        if (mask == (~((vtype) 0)))\n          goto next_depth;\n\n        int bit = 0;\n        do\n        {\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit]));\n          if (u & 1)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 1]));\n          if (u & 2)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 2]));\n          if (u & 4)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          v = *((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[bit + 3]));\n          if (u & 8)\n            v = ~v;\n\n          mask = mask | v;\n          if (mask == (~((vtype) 0)))\n            goto next_depth;\n\n          u >>= 4;\n        }\n        while ((bit += 4) <= 28);\n        precheck = 0;\n        goto next_batch;\n        next_depth:\n        ;\n\n      }\n    }\n    while (pw = pw->next);\n  }\n\n  next_batch:\n  ;\n\n}\n\ninline static void DES_bs_finalize_keys_LM(int t)\n{\n  {\n    long *kp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).K[0]);\n    int ic;\n    for (ic = 0; ic < 7; ic++)\n    {\n      long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n      vtype v0 = *((vtype *) (&vp[0]));\n      vtype v1 = *((vtype *) (&vp[1]));\n      vtype v2 = *((vtype *) (&vp[2]));\n      vtype v3 = *((vtype *) (&vp[3]));\n      vtype v4 = *((vtype *) (&vp[4]));\n      vtype v5 = *((vtype *) (&vp[5]));\n      vtype v6 = *((vtype *) (&vp[6]));\n      vtype v7 = *((vtype *) (&vp[7]));\n      {\n        vtype m = 0x0101010101010101UL;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        va = v0 & m;\n        tmp = v1 & m;\n        vb = tmp << 1;\n        tmp = v2 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 6;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 7;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 1;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 1;\n        vb = v1 & m;\n        tmp = v2 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 5;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 6;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 2;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 2;\n        tmp = v1 & m;\n        vb = tmp >> 1;\n        tmp = v2 & m;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 3;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 3;\n        tmp = v1 & m;\n        vb = tmp >> 2;\n        tmp = v2 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 4;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 4;\n        tmp = v1 & m;\n        vb = tmp >> 3;\n        tmp = v2 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 5;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 5;\n        tmp = v1 & m;\n        vb = tmp >> 4;\n        tmp = v2 & m;\n        tmp = tmp >> 3;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 6;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 6;\n        tmp = v1 & m;\n        vb = tmp >> 5;\n        tmp = v2 & m;\n        tmp = tmp >> 4;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 7;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 7;\n        tmp = v1 & m;\n        vb = tmp >> 6;\n        tmp = v2 & m;\n        tmp = tmp >> 5;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 4;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 3;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp >> 2;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v7 & m;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n    }\n\n  }\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, salt, precheck)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(DES_bs_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  long **k;\n  int rounds;\n  int i;\n  for (i = 0; i < 64; i++)\n  {\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[i] = DES_bs_P[i];\n  }\n\n  DES_bs_finalize_keys_plain(t);\n  k = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).KS.p;\n  rounds = 8;\n  do\n  {\n    s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]))) ^ (*((vtype *) (&k[0][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]))) ^ (*((vtype *) (&k[1][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]))) ^ (*((vtype *) (&k[2][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]))) ^ (*((vtype *) (&k[3][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]))) ^ (*((vtype *) (&k[4][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]))) ^ (*((vtype *) (&k[5][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]));\n    s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]))) ^ (*((vtype *) (&k[6][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]))) ^ (*((vtype *) (&k[7][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]))) ^ (*((vtype *) (&k[8][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]))) ^ (*((vtype *) (&k[9][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]))) ^ (*((vtype *) (&k[10][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]))) ^ (*((vtype *) (&k[11][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]));\n    s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]))) ^ (*((vtype *) (&k[12][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]))) ^ (*((vtype *) (&k[13][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]))) ^ (*((vtype *) (&k[14][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]))) ^ (*((vtype *) (&k[15][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[16][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[17][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]));\n    s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]))) ^ (*((vtype *) (&k[18][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]))) ^ (*((vtype *) (&k[19][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]))) ^ (*((vtype *) (&k[20][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]))) ^ (*((vtype *) (&k[21][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]))) ^ (*((vtype *) (&k[22][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]))) ^ (*((vtype *) (&k[23][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]));\n    s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]))) ^ (*((vtype *) (&k[24][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]))) ^ (*((vtype *) (&k[25][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]))) ^ (*((vtype *) (&k[26][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]))) ^ (*((vtype *) (&k[27][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]))) ^ (*((vtype *) (&k[28][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]))) ^ (*((vtype *) (&k[29][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]));\n    s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]))) ^ (*((vtype *) (&k[30][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]))) ^ (*((vtype *) (&k[31][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]))) ^ (*((vtype *) (&k[32][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]))) ^ (*((vtype *) (&k[33][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]))) ^ (*((vtype *) (&k[34][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]))) ^ (*((vtype *) (&k[35][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]));\n    s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]))) ^ (*((vtype *) (&k[36][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]))) ^ (*((vtype *) (&k[37][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]))) ^ (*((vtype *) (&k[38][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]))) ^ (*((vtype *) (&k[39][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[40][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[41][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]));\n    s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]))) ^ (*((vtype *) (&k[42][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]))) ^ (*((vtype *) (&k[43][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]))) ^ (*((vtype *) (&k[44][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]))) ^ (*((vtype *) (&k[45][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]))) ^ (*((vtype *) (&k[46][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]))) ^ (*((vtype *) (&k[47][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]));\n    s1((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]))) ^ (*((vtype *) (&k[48][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]))) ^ (*((vtype *) (&k[49][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[33]))) ^ (*((vtype *) (&k[50][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[34]))) ^ (*((vtype *) (&k[51][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]))) ^ (*((vtype *) (&k[52][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]))) ^ (*((vtype *) (&k[53][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[8]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[16]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[22]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[30]));\n    s2((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[35]))) ^ (*((vtype *) (&k[54][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[36]))) ^ (*((vtype *) (&k[55][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[37]))) ^ (*((vtype *) (&k[56][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[38]))) ^ (*((vtype *) (&k[57][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]))) ^ (*((vtype *) (&k[58][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]))) ^ (*((vtype *) (&k[59][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[12]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[27]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[1]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[17]));\n    s3((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[39]))) ^ (*((vtype *) (&k[60][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[40]))) ^ (*((vtype *) (&k[61][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[41]))) ^ (*((vtype *) (&k[62][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[42]))) ^ (*((vtype *) (&k[63][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[64][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[65][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[23]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[15]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[29]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[5]));\n    s4((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[43]))) ^ (*((vtype *) (&k[66][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[44]))) ^ (*((vtype *) (&k[67][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[45]))) ^ (*((vtype *) (&k[68][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[46]))) ^ (*((vtype *) (&k[69][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]))) ^ (*((vtype *) (&k[70][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]))) ^ (*((vtype *) (&k[71][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[25]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[19]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[9]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[0]));\n    s5((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[47]))) ^ (*((vtype *) (&k[72][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[48]))) ^ (*((vtype *) (&k[73][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[49]))) ^ (*((vtype *) (&k[74][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[50]))) ^ (*((vtype *) (&k[75][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]))) ^ (*((vtype *) (&k[76][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]))) ^ (*((vtype *) (&k[77][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[7]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[13]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[24]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[2]));\n    s6((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[51]))) ^ (*((vtype *) (&k[78][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[52]))) ^ (*((vtype *) (&k[79][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[53]))) ^ (*((vtype *) (&k[80][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[54]))) ^ (*((vtype *) (&k[81][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]))) ^ (*((vtype *) (&k[82][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]))) ^ (*((vtype *) (&k[83][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[3]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[28]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[10]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[18]));\n    s7((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[55]))) ^ (*((vtype *) (&k[84][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[56]))) ^ (*((vtype *) (&k[85][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[57]))) ^ (*((vtype *) (&k[86][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[58]))) ^ (*((vtype *) (&k[87][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[88][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[89][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[31]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[11]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[21]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[6]));\n    s8((*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[59]))) ^ (*((vtype *) (&k[90][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[60]))) ^ (*((vtype *) (&k[91][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[61]))) ^ (*((vtype *) (&k[92][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[62]))) ^ (*((vtype *) (&k[93][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[63]))) ^ (*((vtype *) (&k[94][0]))), (*((vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[32]))) ^ (*((vtype *) (&k[95][0]))), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[4]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[26]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[14]), (vtype *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).B[20]));\n    k += 96;\n  }\n  while (--rounds);\n}\n\ninline static void DES_bs_finalize_keys_plain(int t)\n{\n  {\n    long *kp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).K[0]);\n    int ic;\n    for (ic = 0; ic < 8; ic++)\n    {\n      long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n      vtype v0 = *((vtype *) (&vp[0]));\n      vtype v1 = *((vtype *) (&vp[1]));\n      vtype v2 = *((vtype *) (&vp[2]));\n      vtype v3 = *((vtype *) (&vp[3]));\n      vtype v4 = *((vtype *) (&vp[4]));\n      vtype v5 = *((vtype *) (&vp[5]));\n      vtype v6 = *((vtype *) (&vp[6]));\n      vtype v7 = *((vtype *) (&vp[7]));\n      {\n        vtype m = 0x0101010101010101UL;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        va = v0 & m;\n        tmp = v1 & m;\n        vb = tmp << 1;\n        tmp = v2 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 6;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 7;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 1;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 1;\n        vb = v1 & m;\n        tmp = v2 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 5;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 6;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 2;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 2;\n        tmp = v1 & m;\n        vb = tmp >> 1;\n        tmp = v2 & m;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 4;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 5;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 3;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 3;\n        tmp = v1 & m;\n        vb = tmp >> 2;\n        tmp = v2 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v3 & m;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 3;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 4;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 4;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 4;\n        tmp = v1 & m;\n        vb = tmp >> 3;\n        tmp = v2 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 2;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 3;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 5;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 5;\n        tmp = v1 & m;\n        vb = tmp >> 4;\n        tmp = v2 & m;\n        tmp = tmp >> 3;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 2;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 1;\n        va = va | tmp;\n        tmp = v5 & m;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        tmp = tmp << 1;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 2;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n      {\n        vtype m = 0x0101010101010101UL << 6;\n        vtype va;\n        vtype vb;\n        vtype tmp;\n        tmp = v0 & m;\n        va = tmp >> 6;\n        tmp = v1 & m;\n        vb = tmp >> 5;\n        tmp = v2 & m;\n        tmp = tmp >> 4;\n        va = va | tmp;\n        tmp = v3 & m;\n        tmp = tmp >> 3;\n        vb = vb | tmp;\n        tmp = v4 & m;\n        tmp = tmp >> 2;\n        va = va | tmp;\n        tmp = v5 & m;\n        tmp = tmp >> 1;\n        vb = vb | tmp;\n        tmp = v6 & m;\n        va = va | tmp;\n        tmp = v7 & m;\n        tmp = tmp << 1;\n        vb = vb | tmp;\n        *((vtype *) kp) = va | vb;\n        kp++;\n      }\n    }\n\n  }\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s1(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x55005500;\n  vtype x5A0F5A0F;\n  vtype x3333FFFF;\n  vtype x66666666;\n  vtype x22226666;\n  vtype x2D2D6969;\n  vtype x25202160;\n  vtype x00FFFF00;\n  vtype x33CCCC33;\n  vtype x4803120C;\n  vtype x2222FFFF;\n  vtype x6A21EDF3;\n  vtype x4A01CC93;\n  vtype x5555FFFF;\n  vtype x7F75FFFF;\n  vtype x00D20096;\n  vtype x7FA7FF69;\n  vtype x0A0A0000;\n  vtype x0AD80096;\n  vtype x00999900;\n  vtype x0AD99996;\n  vtype x22332233;\n  vtype x257AA5F0;\n  vtype x054885C0;\n  vtype xFAB77A3F;\n  vtype x2221EDF3;\n  vtype xD89697CC;\n  vtype x05B77AC0;\n  vtype x05F77AD6;\n  vtype x36C48529;\n  vtype x6391D07C;\n  vtype xBB0747B0;\n  vtype x4C460000;\n  vtype x4EDF9996;\n  vtype x2D4E49EA;\n  vtype xBBFFFFB0;\n  vtype x96B1B65A;\n  vtype x5AFF5AFF;\n  vtype x52B11215;\n  vtype x4201C010;\n  vtype x10B0D205;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x55005500 = a1 & (~a5);\n  x5A0F5A0F = a4 ^ x55005500;\n  x3333FFFF = a3 | a6;\n  x66666666 = a1 ^ a3;\n  x22226666 = x3333FFFF & x66666666;\n  x2D2D6969 = a4 ^ x22226666;\n  x25202160 = x2D2D6969 & (~x5A0F5A0F);\n  x00FFFF00 = a5 ^ a6;\n  x33CCCC33 = a3 ^ x00FFFF00;\n  x4803120C = x5A0F5A0F & (~x33CCCC33);\n  x2222FFFF = a6 | x22226666;\n  x6A21EDF3 = x4803120C ^ x2222FFFF;\n  x4A01CC93 = x6A21EDF3 & (~x25202160);\n  x5555FFFF = a1 | a6;\n  x7F75FFFF = x6A21EDF3 | x5555FFFF;\n  x00D20096 = a5 & (~x2D2D6969);\n  x7FA7FF69 = x7F75FFFF ^ x00D20096;\n  x0A0A0000 = a4 & (~x5555FFFF);\n  x0AD80096 = x00D20096 ^ x0A0A0000;\n  x00999900 = x00FFFF00 & (~x66666666);\n  x0AD99996 = x0AD80096 | x00999900;\n  x22332233 = a3 & (~x55005500);\n  x257AA5F0 = x5A0F5A0F ^ x7F75FFFF;\n  x054885C0 = x257AA5F0 & (~x22332233);\n  xFAB77A3F = ~x054885C0;\n  x2221EDF3 = x3333FFFF & x6A21EDF3;\n  xD89697CC = xFAB77A3F ^ x2221EDF3;\n  x20 = x7FA7FF69 & (~a2);\n  x21 = x20 ^ xD89697CC;\n  *out3 = (*out3) ^ x21;\n  x05B77AC0 = x00FFFF00 ^ x054885C0;\n  x05F77AD6 = x00D20096 | x05B77AC0;\n  x36C48529 = x3333FFFF ^ x05F77AD6;\n  x6391D07C = a1 ^ x36C48529;\n  xBB0747B0 = xD89697CC ^ x6391D07C;\n  x00 = x25202160 | a2;\n  x01 = x00 ^ xBB0747B0;\n  *out1 = (*out1) ^ x01;\n  x4C460000 = x3333FFFF ^ x7F75FFFF;\n  x4EDF9996 = x0AD99996 | x4C460000;\n  x2D4E49EA = x6391D07C ^ x4EDF9996;\n  xBBFFFFB0 = x00FFFF00 | xBB0747B0;\n  x96B1B65A = x2D4E49EA ^ xBBFFFFB0;\n  x10 = x4A01CC93 | a2;\n  x11 = x10 ^ x96B1B65A;\n  *out2 = (*out2) ^ x11;\n  x5AFF5AFF = a5 | x5A0F5A0F;\n  x52B11215 = x5AFF5AFF & (~x2D4E49EA);\n  x4201C010 = x4A01CC93 & x6391D07C;\n  x10B0D205 = x52B11215 ^ x4201C010;\n  x30 = x10B0D205 | a2;\n  x31 = x30 ^ x0AD99996;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s2(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x55550000;\n  vtype x00AA00FF;\n  vtype x33BB33FF;\n  vtype x33CC0000;\n  vtype x11441144;\n  vtype x11BB11BB;\n  vtype x003311BB;\n  vtype x00000F0F;\n  vtype x336600FF;\n  vtype x332200FF;\n  vtype x332200F0;\n  vtype x0302000F;\n  vtype xAAAAAAAA;\n  vtype xA9A8AAA5;\n  vtype x33CCCC33;\n  vtype x33CCC030;\n  vtype x9A646A95;\n  vtype x00333303;\n  vtype x118822B8;\n  vtype xA8208805;\n  vtype x3CC3C33C;\n  vtype x94E34B39;\n  vtype x0331330C;\n  vtype x3FF3F33C;\n  vtype xA9DF596A;\n  vtype xA9DF5F6F;\n  vtype x962CAC53;\n  vtype x97D27835;\n  vtype x81D25825;\n  vtype x812D58DA;\n  vtype x802158DA;\n  vtype x1A45324F;\n  vtype x0A451047;\n  vtype xBBDFDD7B;\n  vtype xB19ACD3C;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x55550000 = a1 & (~a6);\n  x00AA00FF = a5 & (~x55550000);\n  x33BB33FF = a2 | x00AA00FF;\n  x33CC0000 = x33CC33CC & (~a6);\n  x11441144 = a1 & x33CC33CC;\n  x11BB11BB = a5 ^ x11441144;\n  x003311BB = x11BB11BB & (~x33CC0000);\n  x00000F0F = a3 & a6;\n  x336600FF = x00AA00FF ^ x33CC0000;\n  x332200FF = x33BB33FF & x336600FF;\n  x332200F0 = x332200FF & (~x00000F0F);\n  x0302000F = a3 & x332200FF;\n  xAAAAAAAA = ~a1;\n  xA9A8AAA5 = x0302000F ^ xAAAAAAAA;\n  x33CCCC33 = a6 ^ x33CC33CC;\n  x33CCC030 = x33CCCC33 & (~x00000F0F);\n  x9A646A95 = xA9A8AAA5 ^ x33CCC030;\n  x10 = a4 & (~x332200F0);\n  x11 = x10 ^ x9A646A95;\n  *out2 = (*out2) ^ x11;\n  x00333303 = a2 & (~x33CCC030);\n  x118822B8 = x11BB11BB ^ x00333303;\n  xA8208805 = xA9A8AAA5 & (~x118822B8);\n  x3CC3C33C = a3 ^ x33CCCC33;\n  x94E34B39 = xA8208805 ^ x3CC3C33C;\n  x00 = x33BB33FF & (~a4);\n  x01 = x00 ^ x94E34B39;\n  *out1 = (*out1) ^ x01;\n  x0331330C = x0302000F ^ x00333303;\n  x3FF3F33C = x3CC3C33C | x0331330C;\n  xA9DF596A = x33BB33FF ^ x9A646A95;\n  xA9DF5F6F = x00000F0F | xA9DF596A;\n  x962CAC53 = x3FF3F33C ^ xA9DF5F6F;\n  x97D27835 = x94E34B39 ^ x0331330C;\n  x81D25825 = xA9DF5F6F & x97D27835;\n  x812D58DA = a5 ^ x81D25825;\n  x802158DA = x812D58DA & (~x33CC0000);\n  x1A45324F = x9A646A95 ^ x802158DA;\n  x20 = x1A45324F | a4;\n  x21 = x20 ^ x962CAC53;\n  *out3 = (*out3) ^ x21;\n  x0A451047 = x1A45324F & (~x118822B8);\n  xBBDFDD7B = x33CCCC33 | xA9DF596A;\n  xB19ACD3C = x0A451047 ^ xBBDFDD7B;\n  x30 = x003311BB | a4;\n  x31 = x30 ^ xB19ACD3C;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s3(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x44444444;\n  vtype x0F0FF0F0;\n  vtype x4F4FF4F4;\n  vtype x00FFFF00;\n  vtype x00AAAA00;\n  vtype x4FE55EF4;\n  vtype x3C3CC3C3;\n  vtype x3C3C0000;\n  vtype x7373F4F4;\n  vtype x0C840A00;\n  vtype x00005EF4;\n  vtype x00FF5EFF;\n  vtype x00555455;\n  vtype x3C699796;\n  vtype x000FF000;\n  vtype x55AA55AA;\n  vtype x26D9A15E;\n  vtype x2FDFAF5F;\n  vtype x2FD00F5F;\n  vtype x55AAFFAA;\n  vtype x28410014;\n  vtype x000000FF;\n  vtype x000000CC;\n  vtype x284100D8;\n  vtype x204000D0;\n  vtype x3C3CC3FF;\n  vtype x1C3CC32F;\n  vtype x4969967A;\n  vtype x4CC44CC4;\n  vtype x40C040C0;\n  vtype x69963C69;\n  vtype x9669C396;\n  vtype xD6A98356;\n  vtype x000F00F0;\n  vtype xFEBDC3D7;\n  vtype xFEB0C307;\n  vtype x4CEEEEC4;\n  vtype xB25E2DC3;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x44444444 = a1 & (~a2);\n  x0F0FF0F0 = a3 ^ a6;\n  x4F4FF4F4 = x44444444 | x0F0FF0F0;\n  x00FFFF00 = a4 ^ a6;\n  x00AAAA00 = x00FFFF00 & (~a1);\n  x4FE55EF4 = x4F4FF4F4 ^ x00AAAA00;\n  x3C3CC3C3 = a2 ^ x0F0FF0F0;\n  x3C3C0000 = x3C3CC3C3 & (~a6);\n  x7373F4F4 = x4F4FF4F4 ^ x3C3C0000;\n  x0C840A00 = x4FE55EF4 & (~x7373F4F4);\n  x00005EF4 = a6 & x4FE55EF4;\n  x00FF5EFF = a4 | x00005EF4;\n  x00555455 = a1 & x00FF5EFF;\n  x3C699796 = x3C3CC3C3 ^ x00555455;\n  x30 = x4FE55EF4 & (~a5);\n  x31 = x30 ^ x3C699796;\n  *out4 = (*out4) ^ x31;\n  x000FF000 = x0F0FF0F0 & x00FFFF00;\n  x55AA55AA = a1 ^ a4;\n  x26D9A15E = x7373F4F4 ^ x55AA55AA;\n  x2FDFAF5F = a3 | x26D9A15E;\n  x2FD00F5F = x2FDFAF5F & (~x000FF000);\n  x55AAFFAA = x00AAAA00 | x55AA55AA;\n  x28410014 = x3C699796 & (~x55AAFFAA);\n  x000000FF = a4 & a6;\n  x000000CC = x000000FF & (~a2);\n  x284100D8 = x28410014 ^ x000000CC;\n  x204000D0 = x284100D8 & (~a3);\n  x3C3CC3FF = x3C3CC3C3 | x000000FF;\n  x1C3CC32F = x3C3CC3FF & (~x204000D0);\n  x4969967A = a1 ^ x1C3CC32F;\n  x10 = x2FD00F5F & a5;\n  x11 = x10 ^ x4969967A;\n  *out2 = (*out2) ^ x11;\n  x4CC44CC4 = x4FE55EF4 & (~a2);\n  x40C040C0 = x4CC44CC4 & (~a3);\n  x69963C69 = x3C3CC3C3 ^ x55AAFFAA;\n  x9669C396 = ~x69963C69;\n  xD6A98356 = x40C040C0 ^ x9669C396;\n  x00 = a5 & (~x0C840A00);\n  x01 = x00 ^ xD6A98356;\n  *out1 = (*out1) ^ x01;\n  x000F00F0 = a4 & x0F0FF0F0;\n  xFEBDC3D7 = x3C3CC3C3 | xD6A98356;\n  xFEB0C307 = xFEBDC3D7 & (~x000F00F0);\n  x4CEEEEC4 = x00AAAA00 | x4CC44CC4;\n  xB25E2DC3 = xFEB0C307 ^ x4CEEEEC4;\n  x20 = x284100D8 | a5;\n  x21 = x20 ^ xB25E2DC3;\n  *out3 = (*out3) ^ x21;\n}\n\n\ninline static void s4(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x5A5A5A5A;\n  vtype x0F0FF0F0;\n  vtype x33FF33FF;\n  vtype x33FFCC00;\n  vtype x0C0030F0;\n  vtype x0C0CC0C0;\n  vtype x0CF3C03F;\n  vtype x5EFBDA7F;\n  vtype x52FBCA0F;\n  vtype x61C8F93C;\n  vtype x00C0C03C;\n  vtype x0F0F30C0;\n  vtype x3B92A366;\n  vtype x30908326;\n  vtype x3C90B3D6;\n  vtype x33CC33CC;\n  vtype x0C0CFFFF;\n  vtype x379E5C99;\n  vtype x04124C11;\n  vtype x56E9861E;\n  vtype xA91679E1;\n  vtype x9586CA37;\n  vtype x8402C833;\n  vtype x84C2C83F;\n  vtype xB35C94A6;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x5A5A5A5A = a1 ^ a3;\n  x0F0FF0F0 = a3 ^ a5;\n  x33FF33FF = a2 | a4;\n  x33FFCC00 = a5 ^ x33FF33FF;\n  x0C0030F0 = x0F0FF0F0 & (~x33FFCC00);\n  x0C0CC0C0 = x0F0FF0F0 & (~a2);\n  x0CF3C03F = a4 ^ x0C0CC0C0;\n  x5EFBDA7F = x5A5A5A5A | x0CF3C03F;\n  x52FBCA0F = x5EFBDA7F & (~x0C0030F0);\n  x61C8F93C = a2 ^ x52FBCA0F;\n  x00C0C03C = x0CF3C03F & x61C8F93C;\n  x0F0F30C0 = x0F0FF0F0 & (~x00C0C03C);\n  x3B92A366 = x5A5A5A5A ^ x61C8F93C;\n  x30908326 = x3B92A366 & (~x0F0F30C0);\n  x3C90B3D6 = x0C0030F0 ^ x30908326;\n  x33CC33CC = a2 ^ a4;\n  x0C0CFFFF = a5 | x0C0CC0C0;\n  x379E5C99 = x3B92A366 ^ x0C0CFFFF;\n  x04124C11 = x379E5C99 & (~x33CC33CC);\n  x56E9861E = x52FBCA0F ^ x04124C11;\n  x00 = a6 & (~x3C90B3D6);\n  x01 = x00 ^ x56E9861E;\n  *out1 = (*out1) ^ x01;\n  xA91679E1 = ~x56E9861E;\n  x10 = x3C90B3D6 & (~a6);\n  x11 = x10 ^ xA91679E1;\n  *out2 = (*out2) ^ x11;\n  x9586CA37 = x3C90B3D6 ^ xA91679E1;\n  x8402C833 = x9586CA37 & (~x33CC33CC);\n  x84C2C83F = x00C0C03C | x8402C833;\n  xB35C94A6 = x379E5C99 ^ x84C2C83F;\n  x20 = x61C8F93C | a6;\n  x21 = x20 ^ xB35C94A6;\n  *out3 = (*out3) ^ x21;\n  x30 = a6 & x61C8F93C;\n  x31 = x30 ^ xB35C94A6;\n  *out4 = (*out4) ^ x31;\n}\n\n\ninline static void s5(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x77777777;\n  vtype x77770000;\n  vtype x22225555;\n  vtype x11116666;\n  vtype x1F1F6F6F;\n  vtype x70700000;\n  vtype x43433333;\n  vtype x00430033;\n  vtype x55557777;\n  vtype x55167744;\n  vtype x5A19784B;\n  vtype x5A1987B4;\n  vtype x7A3BD7F5;\n  vtype x003B00F5;\n  vtype x221955A0;\n  vtype x05050707;\n  vtype x271C52A7;\n  vtype x2A2A82A0;\n  vtype x6969B193;\n  vtype x1FE06F90;\n  vtype x16804E00;\n  vtype xE97FB1FF;\n  vtype x43403302;\n  vtype x35CAED30;\n  vtype x37DEFFB7;\n  vtype x349ECCB5;\n  vtype x0B01234A;\n  vtype x101884B4;\n  vtype x0FF8EB24;\n  vtype x41413333;\n  vtype x4FF9FB37;\n  vtype x4FC2FBC2;\n  vtype x22222222;\n  vtype x16BCEE97;\n  vtype x0F080B04;\n  vtype x19B4E593;\n  vtype x5C5C5C5C;\n  vtype x4448184C;\n  vtype x2DDABE71;\n  vtype x6992A63D;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x77777777 = a1 | a3;\n  x77770000 = x77777777 & (~a6);\n  x22225555 = a1 ^ x77770000;\n  x11116666 = a3 ^ x22225555;\n  x1F1F6F6F = a4 | x11116666;\n  x70700000 = x77770000 & (~a4);\n  x43433333 = a3 ^ x70700000;\n  x00430033 = a5 & x43433333;\n  x55557777 = a1 | x11116666;\n  x55167744 = x00430033 ^ x55557777;\n  x5A19784B = a4 ^ x55167744;\n  x5A1987B4 = a6 ^ x5A19784B;\n  x7A3BD7F5 = x22225555 | x5A1987B4;\n  x003B00F5 = a5 & x7A3BD7F5;\n  x221955A0 = x22225555 ^ x003B00F5;\n  x05050707 = a4 & x55557777;\n  x271C52A7 = x221955A0 ^ x05050707;\n  x2A2A82A0 = x7A3BD7F5 & (~a1);\n  x6969B193 = x43433333 ^ x2A2A82A0;\n  x1FE06F90 = a5 ^ x1F1F6F6F;\n  x16804E00 = x1FE06F90 & (~x6969B193);\n  xE97FB1FF = ~x16804E00;\n  x20 = xE97FB1FF & (~a2);\n  x21 = x20 ^ x5A19784B;\n  *out3 = (*out3) ^ x21;\n  x43403302 = x43433333 & (~x003B00F5);\n  x35CAED30 = x2A2A82A0 ^ x1FE06F90;\n  x37DEFFB7 = x271C52A7 | x35CAED30;\n  x349ECCB5 = x37DEFFB7 & (~x43403302);\n  x0B01234A = x1F1F6F6F & (~x349ECCB5);\n  x101884B4 = x5A1987B4 & x349ECCB5;\n  x0FF8EB24 = x1FE06F90 ^ x101884B4;\n  x41413333 = x43433333 & x55557777;\n  x4FF9FB37 = x0FF8EB24 | x41413333;\n  x4FC2FBC2 = x003B00F5 ^ x4FF9FB37;\n  x30 = x4FC2FBC2 & a2;\n  x31 = x30 ^ x271C52A7;\n  *out4 = (*out4) ^ x31;\n  x22222222 = a1 ^ x77777777;\n  x16BCEE97 = x349ECCB5 ^ x22222222;\n  x0F080B04 = a4 & x0FF8EB24;\n  x19B4E593 = x16BCEE97 ^ x0F080B04;\n  x00 = x0B01234A | a2;\n  x01 = x00 ^ x19B4E593;\n  *out1 = (*out1) ^ x01;\n  x5C5C5C5C = x1F1F6F6F ^ x43433333;\n  x4448184C = x5C5C5C5C & (~x19B4E593);\n  x2DDABE71 = x22225555 ^ x0FF8EB24;\n  x6992A63D = x4448184C ^ x2DDABE71;\n  x10 = x1F1F6F6F & a2;\n  x11 = x10 ^ x6992A63D;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s6(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x33CC33CC;\n  vtype x3333FFFF;\n  vtype x11115555;\n  vtype x22DD6699;\n  vtype x22DD9966;\n  vtype x00220099;\n  vtype x00551144;\n  vtype x33662277;\n  vtype x5A5A5A5A;\n  vtype x7B7E7A7F;\n  vtype x59A31CE6;\n  vtype x09030C06;\n  vtype x09030000;\n  vtype x336622FF;\n  vtype x3A6522FF;\n  vtype x484D494C;\n  vtype x0000B6B3;\n  vtype x0F0FB9BC;\n  vtype x00FC00F9;\n  vtype x0FFFB9FD;\n  vtype x5DF75DF7;\n  vtype x116600F7;\n  vtype x1E69B94B;\n  vtype x1668B94B;\n  vtype x7B7B7B7B;\n  vtype x411E5984;\n  vtype x1FFFFDFD;\n  vtype x5EE1A479;\n  vtype x3CB4DFD2;\n  vtype x004B002D;\n  vtype xB7B2B6B3;\n  vtype xCCC9CDC8;\n  vtype xCC82CDE5;\n  vtype x0055EEBB;\n  vtype x5A5AECE9;\n  vtype x0050ECA9;\n  vtype xC5CAC1CE;\n  vtype xC59A2D67;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x33CC33CC = a2 ^ a5;\n  x3333FFFF = a2 | a6;\n  x11115555 = a1 & x3333FFFF;\n  x22DD6699 = x33CC33CC ^ x11115555;\n  x22DD9966 = a6 ^ x22DD6699;\n  x00220099 = a5 & (~x22DD9966);\n  x00551144 = a1 & x22DD9966;\n  x33662277 = a2 ^ x00551144;\n  x5A5A5A5A = a1 ^ a3;\n  x7B7E7A7F = x33662277 | x5A5A5A5A;\n  x59A31CE6 = x22DD6699 ^ x7B7E7A7F;\n  x09030C06 = a3 & x59A31CE6;\n  x09030000 = x09030C06 & (~a6);\n  x336622FF = x00220099 | x33662277;\n  x3A6522FF = x09030000 ^ x336622FF;\n  x30 = x3A6522FF & a4;\n  x31 = x30 ^ x59A31CE6;\n  *out4 = (*out4) ^ x31;\n  x484D494C = a2 ^ x7B7E7A7F;\n  x0000B6B3 = a6 & (~x484D494C);\n  x0F0FB9BC = a3 ^ x0000B6B3;\n  x00FC00F9 = a5 & (~x09030C06);\n  x0FFFB9FD = x0F0FB9BC | x00FC00F9;\n  x5DF75DF7 = a1 | x59A31CE6;\n  x116600F7 = x336622FF & x5DF75DF7;\n  x1E69B94B = x0F0FB9BC ^ x116600F7;\n  x1668B94B = x1E69B94B & (~x09030000);\n  x20 = x00220099 | a4;\n  x21 = x20 ^ x1668B94B;\n  *out3 = (*out3) ^ x21;\n  x7B7B7B7B = a2 | x5A5A5A5A;\n  x411E5984 = x3A6522FF ^ x7B7B7B7B;\n  x1FFFFDFD = x11115555 | x0FFFB9FD;\n  x5EE1A479 = x411E5984 ^ x1FFFFDFD;\n  x3CB4DFD2 = x22DD6699 ^ x1E69B94B;\n  x004B002D = a5 & (~x3CB4DFD2);\n  xB7B2B6B3 = ~x484D494C;\n  xCCC9CDC8 = x7B7B7B7B ^ xB7B2B6B3;\n  xCC82CDE5 = x004B002D ^ xCCC9CDC8;\n  x10 = xCC82CDE5 & (~a4);\n  x11 = x10 ^ x5EE1A479;\n  *out2 = (*out2) ^ x11;\n  x0055EEBB = a6 ^ x00551144;\n  x5A5AECE9 = a1 ^ x0F0FB9BC;\n  x0050ECA9 = x0055EEBB & x5A5AECE9;\n  xC5CAC1CE = x09030C06 ^ xCCC9CDC8;\n  xC59A2D67 = x0050ECA9 ^ xC5CAC1CE;\n  x00 = x0FFFB9FD & (~a4);\n  x01 = x00 ^ xC59A2D67;\n  *out1 = (*out1) ^ x01;\n}\n\n\ninline static void s7(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0FF00FF0;\n  vtype x3CC33CC3;\n  vtype x00003CC3;\n  vtype x0F000F00;\n  vtype x5A555A55;\n  vtype x00001841;\n  vtype x00000F00;\n  vtype x33333C33;\n  vtype x7B777E77;\n  vtype x0FF0F00F;\n  vtype x74878E78;\n  vtype x003C003C;\n  vtype x5A7D5A7D;\n  vtype x333300F0;\n  vtype x694E5A8D;\n  vtype x0FF0CCCC;\n  vtype x000F0303;\n  vtype x5A505854;\n  vtype x33CC000F;\n  vtype x699C585B;\n  vtype x7F878F78;\n  vtype x21101013;\n  vtype x7F979F7B;\n  vtype x30030CC0;\n  vtype x4F9493BB;\n  vtype x6F9CDBFB;\n  vtype x0000DBFB;\n  vtype x00005151;\n  vtype x26DAC936;\n  vtype x26DA9867;\n  vtype x21FF10FF;\n  vtype x21FFCB04;\n  vtype x2625C9C9;\n  vtype x27FFCBCD;\n  vtype x27FF1036;\n  vtype x27FF103E;\n  vtype xB06B6C44;\n  vtype x97947C7A;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0FF00FF0 = a4 ^ a5;\n  x3CC33CC3 = a3 ^ x0FF00FF0;\n  x00003CC3 = a6 & x3CC33CC3;\n  x0F000F00 = a4 & x0FF00FF0;\n  x5A555A55 = a2 ^ x0F000F00;\n  x00001841 = x00003CC3 & x5A555A55;\n  x00000F00 = a6 & x0F000F00;\n  x33333C33 = a3 ^ x00000F00;\n  x7B777E77 = x5A555A55 | x33333C33;\n  x0FF0F00F = a6 ^ x0FF00FF0;\n  x74878E78 = x7B777E77 ^ x0FF0F00F;\n  x30 = a1 & (~x00001841);\n  x31 = x30 ^ x74878E78;\n  *out4 = (*out4) ^ x31;\n  x003C003C = a5 & (~x3CC33CC3);\n  x5A7D5A7D = x5A555A55 | x003C003C;\n  x333300F0 = x00003CC3 ^ x33333C33;\n  x694E5A8D = x5A7D5A7D ^ x333300F0;\n  x0FF0CCCC = x00003CC3 ^ x0FF0F00F;\n  x000F0303 = a4 & (~x0FF0CCCC);\n  x5A505854 = x5A555A55 & (~x000F0303);\n  x33CC000F = a5 ^ x333300F0;\n  x699C585B = x5A505854 ^ x33CC000F;\n  x7F878F78 = x0F000F00 | x74878E78;\n  x21101013 = a3 & x699C585B;\n  x7F979F7B = x7F878F78 | x21101013;\n  x30030CC0 = x3CC33CC3 & (~x0FF0F00F);\n  x4F9493BB = x7F979F7B ^ x30030CC0;\n  x00 = x4F9493BB & (~a1);\n  x01 = x00 ^ x694E5A8D;\n  *out1 = (*out1) ^ x01;\n  x6F9CDBFB = x699C585B | x4F9493BB;\n  x0000DBFB = a6 & x6F9CDBFB;\n  x00005151 = a2 & x0000DBFB;\n  x26DAC936 = x694E5A8D ^ x4F9493BB;\n  x26DA9867 = x00005151 ^ x26DAC936;\n  x21FF10FF = a5 | x21101013;\n  x21FFCB04 = x0000DBFB ^ x21FF10FF;\n  x2625C9C9 = a5 ^ x26DAC936;\n  x27FFCBCD = x21FFCB04 | x2625C9C9;\n  x20 = x27FFCBCD & a1;\n  x21 = x20 ^ x699C585B;\n  *out3 = (*out3) ^ x21;\n  x27FF1036 = x0000DBFB ^ x27FFCBCD;\n  x27FF103E = x003C003C | x27FF1036;\n  xB06B6C44 = ~x4F9493BB;\n  x97947C7A = x27FF103E ^ xB06B6C44;\n  x10 = x97947C7A & (~a1);\n  x11 = x10 ^ x26DA9867;\n  *out2 = (*out2) ^ x11;\n}\n\n\ninline static void s8(vtype a1, vtype a2, vtype a3, vtype a4, vtype a5, vtype a6, vtype *out1, vtype *out2, vtype *out3, vtype *out4)\n{\n  vtype x0C0C0C0C;\n  vtype x0000F0F0;\n  vtype x00FFF00F;\n  vtype x00555005;\n  vtype x00515001;\n  vtype x33000330;\n  vtype x77555775;\n  vtype x30303030;\n  vtype x3030CFCF;\n  vtype x30104745;\n  vtype x30555745;\n  vtype xFF000FF0;\n  vtype xCF1048B5;\n  vtype x080A080A;\n  vtype xC71A40BF;\n  vtype xCB164CB3;\n  vtype x9E4319E6;\n  vtype x000019E6;\n  vtype xF429738C;\n  vtype xF4296A6A;\n  vtype xC729695A;\n  vtype xC47C3D2F;\n  vtype xF77F3F3F;\n  vtype x9E43E619;\n  vtype x693CD926;\n  vtype xF719A695;\n  vtype xF4FF73FF;\n  vtype x03E6D56A;\n  vtype x56B3803F;\n  vtype xF700A600;\n  vtype x61008000;\n  vtype x03B7856B;\n  vtype x62B7056B;\n  vtype x00;\n  vtype x01;\n  vtype x10;\n  vtype x11;\n  vtype x20;\n  vtype x21;\n  vtype x30;\n  vtype x31;\n  x0C0C0C0C = a3 & (~a2);\n  x0000F0F0 = a5 & (~a3);\n  x00FFF00F = a4 ^ x0000F0F0;\n  x00555005 = a1 & x00FFF00F;\n  x00515001 = x00555005 & (~x0C0C0C0C);\n  x33000330 = a2 & (~x00FFF00F);\n  x77555775 = a1 | x33000330;\n  x30303030 = a2 & (~a3);\n  x3030CFCF = a5 ^ x30303030;\n  x30104745 = x77555775 & x3030CFCF;\n  x30555745 = x00555005 | x30104745;\n  xFF000FF0 = ~x00FFF00F;\n  xCF1048B5 = x30104745 ^ xFF000FF0;\n  x080A080A = a3 & (~x77555775);\n  xC71A40BF = xCF1048B5 ^ x080A080A;\n  xCB164CB3 = x0C0C0C0C ^ xC71A40BF;\n  x10 = x00515001 | a6;\n  x11 = x10 ^ xCB164CB3;\n  *out2 = (*out2) ^ x11;\n  x9E4319E6 = a1 ^ xCB164CB3;\n  x000019E6 = a5 & x9E4319E6;\n  xF429738C = a2 ^ xC71A40BF;\n  xF4296A6A = x000019E6 ^ xF429738C;\n  xC729695A = x33000330 ^ xF4296A6A;\n  xC47C3D2F = x30555745 ^ xF4296A6A;\n  xF77F3F3F = a2 | xC47C3D2F;\n  x9E43E619 = a5 ^ x9E4319E6;\n  x693CD926 = xF77F3F3F ^ x9E43E619;\n  x20 = x30555745 & a6;\n  x21 = x20 ^ x693CD926;\n  *out3 = (*out3) ^ x21;\n  xF719A695 = x3030CFCF ^ xC729695A;\n  xF4FF73FF = a4 | xF429738C;\n  x03E6D56A = xF719A695 ^ xF4FF73FF;\n  x56B3803F = a1 ^ x03E6D56A;\n  x30 = x56B3803F & a6;\n  x31 = x30 ^ xC729695A;\n  *out4 = (*out4) ^ x31;\n  xF700A600 = xF719A695 & (~a4);\n  x61008000 = x693CD926 & xF700A600;\n  x03B7856B = x00515001 ^ x03E6D56A;\n  x62B7056B = x61008000 ^ x03B7856B;\n  x00 = x62B7056B | a6;\n  x01 = x00 ^ xC729695A;\n  *out1 = (*out1) ^ x01;\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, DES_bs_P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (ic = 0; ic < 8; ic++)\n{\n  long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n  vtype v0 = *((vtype *) (&vp[0]));\n  vtype v1 = *((vtype *) (&vp[1]));\n  vtype v2 = *((vtype *) (&vp[2]));\n  vtype v3 = *((vtype *) (&vp[3]));\n  vtype v4 = *((vtype *) (&vp[4]));\n  vtype v5 = *((vtype *) (&vp[5]));\n  vtype v6 = *((vtype *) (&vp[6]));\n  vtype v7 = *((vtype *) (&vp[7]));\n  {\n    vtype m = 0x0101010101010101UL;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    va = v0 & m;\n    tmp = v1 & m;\n    vb = tmp << 1;\n    tmp = v2 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 6;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 7;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 1;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 1;\n    vb = v1 & m;\n    tmp = v2 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 5;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 6;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 2;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 2;\n    tmp = v1 & m;\n    vb = tmp >> 1;\n    tmp = v2 & m;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 3;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 3;\n    tmp = v1 & m;\n    vb = tmp >> 2;\n    tmp = v2 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 4;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 4;\n    tmp = v1 & m;\n    vb = tmp >> 3;\n    tmp = v2 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 5;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 5;\n    tmp = v1 & m;\n    vb = tmp >> 4;\n    tmp = v2 & m;\n    tmp = tmp >> 3;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 6;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 6;\n    tmp = v1 & m;\n    vb = tmp >> 5;\n    tmp = v2 & m;\n    tmp = tmp >> 4;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, DES_bs_P)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (dst = 0; dst < 24; dst++)\n{\n  if ((new ^ old) & 1)\n  {\n    long *sp1;\n    long *sp2;\n    int src1 = dst;\n    int src2 = dst + 24;\n    if (new & 1)\n    {\n      src1 = src2;\n      src2 = dst;\n    }\n\n    sp1 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src1];\n    sp2 = (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).Ens[src2];\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst] = (long *) sp1;\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 24] = (long *) sp2;\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 48] = (long *) (sp1 + 32);\n    (*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).E.E[dst + 72] = (long *) (sp2 + 32);\n  }\n\n  new >>= 1;\n  old >>= 1;\n  if (new == old)\n    break;\n\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, DES_bs_P)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ic = 0; ic < 7; ic++)\n{\n  long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n  vtype v0 = *((vtype *) (&vp[0]));\n  vtype v1 = *((vtype *) (&vp[1]));\n  vtype v2 = *((vtype *) (&vp[2]));\n  vtype v3 = *((vtype *) (&vp[3]));\n  vtype v4 = *((vtype *) (&vp[4]));\n  vtype v5 = *((vtype *) (&vp[5]));\n  vtype v6 = *((vtype *) (&vp[6]));\n  vtype v7 = *((vtype *) (&vp[7]));\n  {\n    vtype m = 0x0101010101010101UL;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    va = v0 & m;\n    tmp = v1 & m;\n    vb = tmp << 1;\n    tmp = v2 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 6;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 7;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 1;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 1;\n    vb = v1 & m;\n    tmp = v2 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 5;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 6;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 2;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 2;\n    tmp = v1 & m;\n    vb = tmp >> 1;\n    tmp = v2 & m;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 3;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 3;\n    tmp = v1 & m;\n    vb = tmp >> 2;\n    tmp = v2 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 4;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 4;\n    tmp = v1 & m;\n    vb = tmp >> 3;\n    tmp = v2 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 5;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 5;\n    tmp = v1 & m;\n    vb = tmp >> 4;\n    tmp = v2 & m;\n    tmp = tmp >> 3;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 6;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 6;\n    tmp = v1 & m;\n    vb = tmp >> 5;\n    tmp = v2 & m;\n    tmp = tmp >> 4;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 7;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 7;\n    tmp = v1 & m;\n    vb = tmp >> 6;\n    tmp = v2 & m;\n    tmp = tmp >> 5;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 4;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 3;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp >> 2;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v7 & m;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, DES_bs_P)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ic = 0; ic < 8; ic++)\n{\n  long *vp = (long *) (&(*((DES_bs_combined *) (((char *) DES_bs_all_p) + t))).xkeys.v[ic][0]);\n  vtype v0 = *((vtype *) (&vp[0]));\n  vtype v1 = *((vtype *) (&vp[1]));\n  vtype v2 = *((vtype *) (&vp[2]));\n  vtype v3 = *((vtype *) (&vp[3]));\n  vtype v4 = *((vtype *) (&vp[4]));\n  vtype v5 = *((vtype *) (&vp[5]));\n  vtype v6 = *((vtype *) (&vp[6]));\n  vtype v7 = *((vtype *) (&vp[7]));\n  {\n    vtype m = 0x0101010101010101UL;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    va = v0 & m;\n    tmp = v1 & m;\n    vb = tmp << 1;\n    tmp = v2 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 6;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 7;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 1;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 1;\n    vb = v1 & m;\n    tmp = v2 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 5;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 6;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 2;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 2;\n    tmp = v1 & m;\n    vb = tmp >> 1;\n    tmp = v2 & m;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 4;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 5;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 3;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 3;\n    tmp = v1 & m;\n    vb = tmp >> 2;\n    tmp = v2 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v3 & m;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 3;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 4;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 4;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 4;\n    tmp = v1 & m;\n    vb = tmp >> 3;\n    tmp = v2 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 2;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 3;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 5;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 5;\n    tmp = v1 & m;\n    vb = tmp >> 4;\n    tmp = v2 & m;\n    tmp = tmp >> 3;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 2;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 1;\n    va = va | tmp;\n    tmp = v5 & m;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    tmp = tmp << 1;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 2;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n  {\n    vtype m = 0x0101010101010101UL << 6;\n    vtype va;\n    vtype vb;\n    vtype tmp;\n    tmp = v0 & m;\n    va = tmp >> 6;\n    tmp = v1 & m;\n    vb = tmp >> 5;\n    tmp = v2 & m;\n    tmp = tmp >> 4;\n    va = va | tmp;\n    tmp = v3 & m;\n    tmp = tmp >> 3;\n    vb = vb | tmp;\n    tmp = v4 & m;\n    tmp = tmp >> 2;\n    va = va | tmp;\n    tmp = v5 & m;\n    tmp = tmp >> 1;\n    vb = vb | tmp;\n    tmp = v6 & m;\n    va = va | tmp;\n    tmp = v7 & m;\n    tmp = tmp << 1;\n    vb = vb | tmp;\n    *((vtype *) kp) = va | vb;\n    kp++;\n  }\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, DES_bs_all_p, DES_bs_P)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char hash[16];\n  unsigned char hex_hash[2 * 16];\n  unsigned char *ptr_src;\n  unsigned char *ptr_dst;\n  MD5_CTX ctx;\n  int i;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, cur_salt->login_id, cur_salt->login_id_len);\n  john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  john_MD5_Final(hash, &ctx);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, hash, 16);\n  john_MD5_Update(&ctx, cur_salt->nonces, cur_salt->nonces_len);\n  john_MD5_Final(hash, &ctx);\n  ptr_src = hash;\n  ptr_dst = hex_hash;\n  for (i = 0; i < 16; ++i)\n  {\n    unsigned char v = *(ptr_src++);\n    *(ptr_dst++) = itoa16_shr_04[ARCH_INDEX(v)];\n    *(ptr_dst++) = itoa16_and_0f[ARCH_INDEX(v)];\n  }\n\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, hex_hash, 2 * 16);\n  john_MD5_Update(&ctx, cur_salt->prehash_KD, cur_salt->prehash_KD_len);\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ((unsigned char *) out)[i] = (atoi16[ARCH_INDEX(response[i * 2])] << 4) + atoi16[ARCH_INDEX(response[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  v = *(ptr_src++);\n  *(ptr_dst++) = itoa16_shr_04[ARCH_INDEX(v)];\n  *(ptr_dst++) = itoa16_and_0f[ARCH_INDEX(v)];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (crypt_key[index][0] == b)\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 3)\n{\n  int i;\n  int j;\n  if (keys_changed)\n  {\n    char *k0 = saved_key[index];\n    char *k1 = saved_key[index + 1];\n    char *k2 = saved_key[index + 2];\n    unsigned char digest16[3][16];\n    domino_big_md_3((unsigned char *) k0, strlen(k0), (unsigned char *) k1, strlen(k1), (unsigned char *) k2, strlen(k2), digest16[0], digest16[1], digest16[2]);\n    for (i = 0, j = 6; i < 14; i++, j += 2)\n    {\n      const char *hex2 = hex_table[ARCH_INDEX(digest16[0][i])];\n      digest34[index][j] = hex2[0];\n      digest34[index][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[1][i])];\n      digest34[index + 1][j] = hex2[0];\n      digest34[index + 1][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[2][i])];\n      digest34[index + 2][j] = hex2[0];\n      digest34[index + 2][j + 1] = hex2[1];\n    }\n\n  }\n\n  if (salt_changed)\n  {\n    digest34[index + 2][0] = (digest34[index + 1][0] = (digest34[index][0] = cur_salt->salt[0]));\n    digest34[index + 2][1] = (digest34[index + 1][1] = (digest34[index][1] = cur_salt->salt[1]));\n    digest34[index + 2][2] = (digest34[index + 1][2] = (digest34[index][2] = cur_salt->salt[2]));\n    digest34[index + 2][3] = (digest34[index + 1][3] = (digest34[index][3] = cur_salt->salt[3]));\n    digest34[index + 2][4] = (digest34[index + 1][4] = (digest34[index][4] = cur_salt->salt[4]));\n    digest34[index + 2][5] = (digest34[index + 1][5] = (digest34[index][5] = '('));\n  }\n\n  domino_big_md_3_34(digest34[index], digest34[index + 1], digest34[index + 2], (unsigned char *) crypt_out[index], (unsigned char *) crypt_out[index + 1], (unsigned char *) crypt_out[index + 2]);\n  for (i = 0; i < 3; i++)\n  {\n    unsigned char buffer[22 + 1] = {0};\n    unsigned char tmp_hash[(22 + 1) + 3] = {0};\n    memcpy(tmp_hash, cur_salt->salt, 5);\n    memcpy(tmp_hash + 5, crypt_out[index + i], 16);\n    domino_encode(tmp_hash, buffer);\n    sprintf((char *) tmp_hash, \"(G%s)\", buffer);\n    pbkdf2_sha1(tmp_hash, 22, cur_salt->salt, 16, cur_salt->iterations, (unsigned char *) crypt_out_real[index + i], 8, 0);\n  }\n\n}\n\nstatic void domino_big_md_3(unsigned char *in0, unsigned int size0, unsigned char *in1, unsigned int size1, unsigned char *in2, unsigned int size2, unsigned char *out0, unsigned char *out1, unsigned char *out2)\n{\n  unsigned char state[3][16] = {{0}, {0}, {0}};\n  unsigned char checksum[3][16] = {{0}, {0}, {0}};\n  unsigned char block[3][16];\n  unsigned int min;\n  unsigned int curpos = 0;\n  unsigned int curpos0;\n  unsigned int curpos1;\n  unsigned int curpos2;\n  min = (size0 < size1) ? (size0) : (size1);\n  if (size2 < min)\n    min = size2;\n\n  while ((curpos + 15) < min)\n  {\n    mdtransform_3(state, checksum, in0 + curpos, in1 + curpos, in2 + curpos);\n    curpos += 16;\n  }\n\n  curpos0 = curpos;\n  while ((curpos0 + 15) < size0)\n  {\n    mdtransform_1(state[0], checksum[0], in0 + curpos0);\n    curpos0 += 16;\n  }\n\n  curpos1 = curpos;\n  while ((curpos1 + 15) < size1)\n  {\n    mdtransform_1(state[1], checksum[1], in1 + curpos1);\n    curpos1 += 16;\n  }\n\n  curpos2 = curpos;\n  while ((curpos2 + 15) < size2)\n  {\n    mdtransform_1(state[2], checksum[2], in2 + curpos2);\n    curpos2 += 16;\n  }\n\n  {\n    unsigned int pad0 = size0 - curpos0;\n    unsigned int pad1 = size1 - curpos1;\n    unsigned int pad2 = size2 - curpos2;\n    memcpy(block[0], in0 + curpos0, pad0);\n    memcpy(block[1], in1 + curpos1, pad1);\n    memcpy(block[2], in2 + curpos2, pad2);\n    memset(block[0] + pad0, 16 - pad0, 16 - pad0);\n    memset(block[1] + pad1, 16 - pad1, 16 - pad1);\n    memset(block[2] + pad2, 16 - pad2, 16 - pad2);\n    mdtransform_3(state, checksum, block[0], block[1], block[2]);\n  }\n  mdtransform_norecalc_3(state, checksum[0], checksum[1], checksum[2]);\n  memcpy(out0, state[0], 16);\n  memcpy(out1, state[1], 16);\n  memcpy(out2, state[2], 16);\n}\n\n\nstatic void domino_big_md_3_34(unsigned char *in0, unsigned char *in1, unsigned char *in2, unsigned char *out0, unsigned char *out1, unsigned char *out2)\n{\n  unsigned char state[3][16] = {{0}, {0}, {0}};\n  unsigned char checksum[3][16] = {{0}, {0}, {0}};\n  unsigned char block[3][16];\n  mdtransform_3(state, checksum, in0, in1, in2);\n  mdtransform_3(state, checksum, in0 + 16, in1 + 16, in2 + 16);\n  memcpy(block[0], in0 + 32, 2);\n  memcpy(block[1], in1 + 32, 2);\n  memcpy(block[2], in2 + 32, 2);\n  memset(block[0] + 2, 14, 14);\n  memset(block[1] + 2, 14, 14);\n  memset(block[2] + 2, 14, 14);\n  mdtransform_3(state, checksum, block[0], block[1], block[2]);\n  mdtransform_norecalc_3(state, checksum[0], checksum[1], checksum[2]);\n  memcpy(out0, state[0], 16);\n  memcpy(out1, state[1], 16);\n  memcpy(out2, state[2], 16);\n}\n\n\nstatic void domino_encode(unsigned char *salt, unsigned char *hash)\n{\n  unsigned char output[25] = {0};\n  int byte10 = ((char) salt[3]) + 4;\n  if (byte10 > 255)\n    byte10 = byte10 - 256;\n\n  salt[3] = (char) byte10;\n  domino_base64_encode(((salt[0] << 16) | (salt[1] << 8)) | salt[2], 4, output);\n  domino_base64_encode(((salt[3] << 16) | (salt[4] << 8)) | salt[5], 4, output + 4);\n  domino_base64_encode(((salt[6] << 16) | (salt[7] << 8)) | salt[8], 4, output + 8);\n  domino_base64_encode(((salt[9] << 16) | (salt[10] << 8)) | salt[11], 4, output + 12);\n  domino_base64_encode(((salt[12] << 16) | (salt[13] << 8)) | salt[14], 4, output + 16);\n  output[19] = '\\x00';\n  memcpy(hash, output, 20);\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  t = state[p - x.c] ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 16; j--)\n{\n  t = block[(p - x.c) - 16] ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 0; j--)\n{\n  t = (state[(p - x.c) - 32] ^ block[(p - x.c) - 32]) ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  p = x.c;\n  for (j = 48; j > 0; j--)\n  {\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[j + t]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  state[p - x.c] = (t = (*p) ^ lotus_magic_table[j + t]);\n  p++;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  c = lotus_magic_table[block[i] ^ t];\n  t = (checksum[i] ^= c);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  t0 = state[0][p0 - x[0].c] ^ lotus_magic_table[j + t0];\n  t1 = state[1][p1 - x[1].c] ^ lotus_magic_table[j + t1];\n  t2 = state[2][p2 - x[2].c] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 16; j--)\n{\n  t0 = block0[(p0 - x[0].c) - 16] ^ lotus_magic_table[j + t0];\n  t1 = block1[(p1 - x[1].c) - 16] ^ lotus_magic_table[j + t1];\n  t2 = block2[(p2 - x[2].c) - 16] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 0; j--)\n{\n  t0 = (state[0][(p0 - x[0].c) - 32] ^ block0[(p0 - x[0].c) - 32]) ^ lotus_magic_table[j + t0];\n  t1 = (state[1][(p1 - x[1].c) - 32] ^ block1[(p1 - x[1].c) - 32]) ^ lotus_magic_table[j + t1];\n  t2 = (state[2][(p2 - x[2].c) - 32] ^ block2[(p2 - x[2].c) - 32]) ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  p0 = x[0].c;\n  p1 = x[1].c;\n  p2 = x[2].c;\n  for (j = 48; j > 0; j--)\n  {\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[j + t2]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  state[0][p0 - x[0].c] = (t0 = (*p0) ^ lotus_magic_table[j + t0]);\n  state[1][p1 - x[1].c] = (t1 = (*p1) ^ lotus_magic_table[j + t1]);\n  state[2][p2 - x[2].c] = (t2 = (*p2) ^ lotus_magic_table[j + t2]);\n  p0++;\n  p1++;\n  p2++;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  t0 = (checksum[0][i] ^= lotus_magic_table[block0[i] ^ t0]);\n  t1 = (checksum[1][i] ^= lotus_magic_table[block1[i] ^ t1]);\n  t2 = (checksum[2][i] ^= lotus_magic_table[block2[i] ^ t2]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (51 - 1); ++i)\n{\n  ch = ciphertext[i];\n  if (((!isalnum(ch)) && (ch != '+')) && (ch != '/'))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out_real[index], 8))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 3)\n{\n  int i;\n  int j;\n  if (keys_changed)\n  {\n    char *k0 = saved_key[index];\n    char *k1 = saved_key[index + 1];\n    char *k2 = saved_key[index + 2];\n    unsigned char digest16[3][16];\n    domino_big_md_3((unsigned char *) k0, strlen(k0), (unsigned char *) k1, strlen(k1), (unsigned char *) k2, strlen(k2), digest16[0], digest16[1], digest16[2]);\n    for (i = 0, j = 6; i < 14; i++, j += 2)\n    {\n      const char *hex2 = hex_table[ARCH_INDEX(digest16[0][i])];\n      digest34[index][j] = hex2[0];\n      digest34[index][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[1][i])];\n      digest34[index + 1][j] = hex2[0];\n      digest34[index + 1][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[2][i])];\n      digest34[index + 2][j] = hex2[0];\n      digest34[index + 2][j + 1] = hex2[1];\n    }\n\n  }\n\n  if (salt_changed)\n  {\n    digest34[index + 2][0] = (digest34[index + 1][0] = (digest34[index][0] = saved_salt[0]));\n    digest34[index + 2][1] = (digest34[index + 1][1] = (digest34[index][1] = saved_salt[1]));\n    digest34[index + 2][2] = (digest34[index + 1][2] = (digest34[index][2] = saved_salt[2]));\n    digest34[index + 2][3] = (digest34[index + 1][3] = (digest34[index][3] = saved_salt[3]));\n    digest34[index + 2][4] = (digest34[index + 1][4] = (digest34[index][4] = saved_salt[4]));\n    digest34[index + 2][5] = (digest34[index + 1][5] = (digest34[index][5] = '('));\n  }\n\n  domino_big_md_3_34(digest34[index], digest34[index + 1], digest34[index + 2], (unsigned char *) crypt_out[index], (unsigned char *) crypt_out[index + 1], (unsigned char *) crypt_out[index + 2]);\n}\n\nstatic void domino_big_md_3(unsigned char *in0, unsigned int size0, unsigned char *in1, unsigned int size1, unsigned char *in2, unsigned int size2, unsigned char *out0, unsigned char *out1, unsigned char *out2)\n{\n  unsigned char state[3][16] = {{0}, {0}, {0}};\n  unsigned char checksum[3][16] = {{0}, {0}, {0}};\n  unsigned char block[3][16];\n  unsigned int min;\n  unsigned int curpos = 0;\n  unsigned int curpos0;\n  unsigned int curpos1;\n  unsigned int curpos2;\n  min = (size0 < size1) ? (size0) : (size1);\n  if (size2 < min)\n    min = size2;\n\n  while ((curpos + 15) < min)\n  {\n    mdtransform_3(state, checksum, in0 + curpos, in1 + curpos, in2 + curpos);\n    curpos += 16;\n  }\n\n  curpos0 = curpos;\n  while ((curpos0 + 15) < size0)\n  {\n    mdtransform_1(state[0], checksum[0], in0 + curpos0);\n    curpos0 += 16;\n  }\n\n  curpos1 = curpos;\n  while ((curpos1 + 15) < size1)\n  {\n    mdtransform_1(state[1], checksum[1], in1 + curpos1);\n    curpos1 += 16;\n  }\n\n  curpos2 = curpos;\n  while ((curpos2 + 15) < size2)\n  {\n    mdtransform_1(state[2], checksum[2], in2 + curpos2);\n    curpos2 += 16;\n  }\n\n  {\n    unsigned int pad0 = size0 - curpos0;\n    unsigned int pad1 = size1 - curpos1;\n    unsigned int pad2 = size2 - curpos2;\n    memcpy(block[0], in0 + curpos0, pad0);\n    memcpy(block[1], in1 + curpos1, pad1);\n    memcpy(block[2], in2 + curpos2, pad2);\n    memset(block[0] + pad0, 16 - pad0, 16 - pad0);\n    memset(block[1] + pad1, 16 - pad1, 16 - pad1);\n    memset(block[2] + pad2, 16 - pad2, 16 - pad2);\n    mdtransform_3(state, checksum, block[0], block[1], block[2]);\n  }\n  mdtransform_norecalc_3(state, checksum[0], checksum[1], checksum[2]);\n  memcpy(out0, state[0], 16);\n  memcpy(out1, state[1], 16);\n  memcpy(out2, state[2], 16);\n}\n\n\nstatic void domino_big_md_3_34(unsigned char *in0, unsigned char *in1, unsigned char *in2, unsigned char *out0, unsigned char *out1, unsigned char *out2)\n{\n  unsigned char state[3][16] = {{0}, {0}, {0}};\n  unsigned char checksum[3][16] = {{0}, {0}, {0}};\n  unsigned char block[3][16];\n  mdtransform_3(state, checksum, in0, in1, in2);\n  mdtransform_3(state, checksum, in0 + 16, in1 + 16, in2 + 16);\n  memcpy(block[0], in0 + 32, 2);\n  memcpy(block[1], in1 + 32, 2);\n  memcpy(block[2], in2 + 32, 2);\n  memset(block[0] + 2, 14, 14);\n  memset(block[1] + 2, 14, 14);\n  memset(block[2] + 2, 14, 14);\n  mdtransform_3(state, checksum, block[0], block[1], block[2]);\n  mdtransform_norecalc_3(state, checksum[0], checksum[1], checksum[2]);\n  memcpy(out0, state[0], 16);\n  memcpy(out1, state[1], 16);\n  memcpy(out2, state[2], 16);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  t = state[p - x.c] ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 16; j--)\n{\n  t = block[(p - x.c) - 16] ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 0; j--)\n{\n  t = (state[(p - x.c) - 32] ^ block[(p - x.c) - 32]) ^ lotus_magic_table[j + t];\n  *(p++) = t;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  p = x.c;\n  for (j = 48; j > 0; j--)\n  {\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[(j--) + t]);\n    t = (*(p++) ^= lotus_magic_table[j + t]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  state[p - x.c] = (t = (*p) ^ lotus_magic_table[j + t]);\n  p++;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  c = lotus_magic_table[block[i] ^ t];\n  t = (checksum[i] ^= c);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  t0 = state[0][p0 - x[0].c] ^ lotus_magic_table[j + t0];\n  t1 = state[1][p1 - x[1].c] ^ lotus_magic_table[j + t1];\n  t2 = state[2][p2 - x[2].c] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 16; j--)\n{\n  t0 = block0[(p0 - x[0].c) - 16] ^ lotus_magic_table[j + t0];\n  t1 = block1[(p1 - x[1].c) - 16] ^ lotus_magic_table[j + t1];\n  t2 = block2[(p2 - x[2].c) - 16] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j > 0; j--)\n{\n  t0 = (state[0][(p0 - x[0].c) - 32] ^ block0[(p0 - x[0].c) - 32]) ^ lotus_magic_table[j + t0];\n  t1 = (state[1][(p1 - x[1].c) - 32] ^ block1[(p1 - x[1].c) - 32]) ^ lotus_magic_table[j + t1];\n  t2 = (state[2][(p2 - x[2].c) - 32] ^ block2[(p2 - x[2].c) - 32]) ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  p0 = x[0].c;\n  p1 = x[1].c;\n  p2 = x[2].c;\n  for (j = 48; j > 0; j--)\n  {\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[(j--) + t2]);\n    t0 = (*(p0++) ^= lotus_magic_table[j + t0]);\n    t1 = (*(p1++) ^= lotus_magic_table[j + t1]);\n    t2 = (*(p2++) ^= lotus_magic_table[j + t2]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 48; j > 32; j--)\n{\n  state[0][p0 - x[0].c] = (t0 = (*p0) ^ lotus_magic_table[j + t0]);\n  state[1][p1 - x[1].c] = (t1 = (*p1) ^ lotus_magic_table[j + t1]);\n  state[2][p2 - x[2].c] = (t2 = (*p2) ^ lotus_magic_table[j + t2]);\n  p0++;\n  p1++;\n  p2++;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  t0 = (checksum[0][i] ^= lotus_magic_table[block0[i] ^ t0]);\n  t1 = (checksum[1][i] ^= lotus_magic_table[block1[i] ^ t1]);\n  t2 = (checksum[2][i] ^= lotus_magic_table[block2[i] ^ t2]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (22 - 1); ++i)\n{\n  ch = ciphertext[i];\n  if (((!isalnum(ch)) && (ch != '+')) && (ch != '/'))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, (unsigned char *) global_salt, 30 - 1);\n  sph_sha1(&ctx, saved_key[i], key_len[i]);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[i]);\n}\n\n", "pragma": "omp parallel for private(i) shared(global_salt, saved_key, key_len, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (n = 2; (n < 62) && (atoi16u[ARCH_INDEX(ciphertext[n])] != 0x7F); ++n)\n  ;\n\n", "pragma": "omp parallel for private(i) shared(global_salt, saved_key, key_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (n = 65; (n < 105) && (atoi16u[ARCH_INDEX(ciphertext[n])] != 0x7F); ++n)\n  ;\n\n", "pragma": "omp parallel for private(i) shared(global_salt, saved_key, key_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (n = 0; n < len; ++n)\n  dst[n] = (atoi16[ARCH_INDEX(src[n * 2])] << 4) | atoi16[ARCH_INDEX(src[(n * 2) + 1])];\n\n", "pragma": "omp parallel for private(i) shared(global_salt, saved_key, key_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for private(i) shared(global_salt, saved_key, key_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], (16 * 2) * 2);\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  binary_cipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; ++i)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  ((char *) hex_salt)[i * 2] = itoa16[ARCH_INDEX(salt_hash[i] >> 4)];\n  ((char *) hex_salt)[(i * 2) + 1] = itoa16[ARCH_INDEX(salt_hash[i] & 0x0f)];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < (threads * 1); index++)\n  memcpy(saved_key[index], salt, 16 * 2);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  v = *(kh++);\n  *(key_ptr++) = itoa16_shr_04[ARCH_INDEX(v)];\n  *(key_ptr++) = itoa16_and_0f[ARCH_INDEX(v)];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < omp_para; t++)\n  md5cryptsse((unsigned char *) (&saved_key[t * (1 * 4)]), cursalt, (char *) (&sout[((t * (1 * 4)) * 16) / (sizeof(MD5_word))]), CryptType);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= 6; i += 2)\n{\n  h = (unsigned char) atoi64[ARCH_INDEX(((char *) salt)[i])];\n  h ^= ((unsigned char *) salt)[i + 1];\n  h <<= 6;\n  h ^= (unsigned char) atoi64[ARCH_INDEX(((char *) salt)[i + 1])];\n  h ^= ((unsigned char *) salt)[i];\n  retval += h;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (y = 0; y < (1 * omp_para); y++)\n  for (x = 0; x < 4; x++)\n{\n  if (((MD5_word *) binary)[0] == ((MD5_word *) sout)[x + ((y * 4) * 4)])\n    return 1;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (n * (((sizeof(MD5_std_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(MD5_std_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  if (salt_changed)\n    MD5_std_set_salt_for_thread(t, saved_salt);\n\n  MD5_std_crypt_for_thread(t);\n}\n\ninline static void MD5_std_set_salt_for_thread(int t, char *salt)\n{\n  int length;\n  for (length = 0; (length < 8) && salt[length]; length++)\n    ;\n\n  memcpy((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool[0].s, salt, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool[0].l.s = length);\n  if (salt[8] == 2)\n  {\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prefix = \"$1$\";\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen = (sizeof(\"$1$\")) - 1;\n  }\n  else\n    if (salt[8] == 1)\n  {\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prefix = \"$apr1$\";\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen = (sizeof(\"$apr1$\")) - 1;\n  }\n  else\n    if (salt[8] == 3)\n  {\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prefix = \"\";\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen = 0;\n  }\n\n\n\n}\n\n\ninline static void MD5_std_crypt_for_thread(int t)\n{\n  int length;\n  int index;\n  int mask;\n  MD5_pattern *line;\n  memcpy((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.ps.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.p.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.ps.b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->s, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.ps.b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps + 16], PADDING, 40 - (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.ps.w[14] = ((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps + 16) << 3;\n  memcpy((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.psp.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.ps.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.psp.b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.p.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.psp.b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp + 16], PADDING, 40 - (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.psp.w[14] = ((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp + 16) << 3;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.b[16], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->s, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.b[16 + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.p.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.b[16 + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps], PADDING, 40 - (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.w[14] = ((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps + 16) << 3;\n  {\n    MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.w;\n    MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.sp.w;\n    int loop_count = 14;\n    MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n    do\n    {\n      MD5_word tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n    }\n    while (loop_count -= 2);\n  }\n  ;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.b[16], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->s, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.b[16 + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.pp.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.pp);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.b[16 + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp], PADDING, 40 - (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.w[14] = ((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp + 16) << 3;\n  {\n    MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.w;\n    MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->e.spp.w;\n    int loop_count = 14;\n    MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n    do\n    {\n      MD5_word tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n    }\n    while (loop_count -= 2);\n  }\n  ;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[2][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[3][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[5][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[6][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[8][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[9][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[11][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[12][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[14][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[15][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[17][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[18][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[20][0].length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.psp.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp], PADDING, 56 - (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w[14] = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp << 3;\n  {\n    MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w;\n    MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w;\n    int loop_count = 14;\n    MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n    do\n    {\n      MD5_word tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n    }\n    while (loop_count -= 2);\n  }\n  ;\n  MD5_body_for_thread(t, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0]);\n  {\n    MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0];\n    MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0];\n    int loop_count = 4;\n    MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n    do\n    {\n      MD5_word tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n    }\n    while (loop_count -= 2);\n  }\n  ;\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.p.b, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prefix, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->s, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.s);\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.ps + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p);\n  length = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.psp + (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).prelen;\n  if (mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->l.p)\n    do\n  {\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[length++] = (mask & 1) ? (0) : ((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool->o.p.b[0]);\n  }\n  while (mask >>= 1);\n\n  memcpy(&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].b[length], PADDING, 56 - length);\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w[14] = length << 3;\n  {\n    MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w;\n    MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w;\n    int loop_count = 14;\n    MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n    do\n    {\n      MD5_word tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      tmp = *(sptr++);\n      tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n      *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n    }\n    while (loop_count -= 2);\n  }\n  ;\n  MD5_body_for_thread(t, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0][0].even->w);\n  index = 500;\n  line = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0];\n  do\n  {\n    MD5_body_for_thread(t, line[0].even->w, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0]);\n    {\n      MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0];\n      MD5_word *sptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0];\n      int loop_count = 4;\n      MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n      do\n      {\n        MD5_word tmp = *(sptr++);\n        tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n        *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n        tmp = *(sptr++);\n        tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n        *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      }\n      while (loop_count -= 2);\n    }\n    ;\n    memcpy(&line[0].odd->b[line[0].length], (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0], 16);\n    {\n      MD5_word *dptr = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w;\n      MD5_word *sptr = line[0].odd->w;\n      int loop_count = 14;\n      MD5_word mask = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data.masks[1];\n      do\n      {\n        MD5_word tmp = *(sptr++);\n        tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n        *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n        tmp = *(sptr++);\n        tmp = (tmp << 16) | (((MD5_word) tmp) >> (32 - 16));\n        *(dptr++) = ((tmp & mask) << 8) | ((tmp >> 8) & mask);\n      }\n      while (loop_count -= 2);\n    }\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w[14] = line[0].odd->w[14];\n    if ((++line) > (&(*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[20][0]))\n      line = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0];\n\n    MD5_body_for_thread(t, (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._block[0].w, line[0].even->w);\n  }\n  while (--index);\n  memcpy((*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).out[0], line[0].even, 16);\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, salt_changed, saved_salt)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < (MD5_std_nt * (((sizeof(MD5_std_combined)) + (64 - 1)) & (~(64 - 1)))); t += ((sizeof(MD5_std_combined)) + (64 - 1)) & (~(64 - 1)))\n{\n  (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t))).data = MD5_data_init;\n  current = (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._pool;\n  for (index = 0; index < (1 * 4); index++)\n  {\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0][index].even = &current->e.p;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[0][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[1][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[1][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[2][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[2][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[3][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[3][index].odd = &current->o.ps;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[4][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[4][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[5][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[5][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[6][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[6][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[7][index].even = &current->e.sp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[7][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[8][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[8][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[9][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[9][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[10][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[10][index].odd = &current->o.p;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[11][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[11][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[12][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[12][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[13][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[13][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[14][index].even = &current->e.sp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[14][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[15][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[15][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[16][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[16][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[17][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[17][index].odd = &current->o.ps;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[18][index].even = &current->e.pp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[18][index].odd = &current->o.psp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[19][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[19][index].odd = &current->o.pp;\n    ;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[20][index].even = &current->e.spp;\n    (*((MD5_std_combined *) (((char *) MD5_std_all_p) + t)))._order[20][index].odd = &current->o.psp;\n    ;\n    current++;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, salt_changed, saved_salt)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (length = 0; (length < 8) && salt[length]; length++)\n  ;\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, salt_changed, saved_salt)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (length = 0; key[length] && (length < 15); length++)\n  ;\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, salt_changed, saved_salt)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; ((*p) != '$') && (i < 8); i++)\n  *(q++) = *(p++);\n\n", "pragma": "omp parallel for default(none) private(t) shared(n, salt_changed, saved_salt)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  int len;\n  len = E_md4hash((unsigned char *) saved_plain[i], saved_len[i], saved_key[i]);\n  if (len <= 0)\n    saved_plain[i][-len] = 0;\n\n  setup_des_key(saved_key[i], i);\n}\n\ninline static void setup_des_key(unsigned char key_56[], int index)\n{\n  char key[8];\n  key[0] = (key_56[0] >> 1) | 0x80;\n  key[1] = (((key_56[0] << 7) | (key_56[1] >> 1)) >> 1) | 0x80;\n  key[2] = (((key_56[1] << 6) | (key_56[2] >> 2)) >> 1) | 0x80;\n  key[3] = (((key_56[2] << 5) | (key_56[3] >> 3)) >> 1) | 0x80;\n  key[4] = (((key_56[3] << 4) | (key_56[4] >> 4)) >> 1) | 0x80;\n  key[5] = (((key_56[4] << 3) | (key_56[5] >> 5)) >> 1) | 0x80;\n  key[6] = (((key_56[5] << 2) | (key_56[6] >> 6)) >> 1) | 0x80;\n  key[7] = ((key_56[6] << 1) >> 1) | 0x80;\n  DES_bs_set_key((char *) key, index);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos2 = pos; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos2 = pos; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = (sizeof(\"$MSCHAPv2$\")) - 1; (i < ((((13 + 256) + 64) + 48) + 1)) && (j < 3); i++)\n{\n  if ((out[i] >= 'A') && (out[i] <= 'Z'))\n    out[i] |= 0x20;\n  else\n    if (out[i] == '$')\n    j++;\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (chr = 0; chr < 24; chr = chr + 8)\n{\n  dst = 0;\n  for (i = 0; i < 8; i++)\n  {\n    value = binary[chr + i];\n    mask = 0x80;\n    for (src = 0; src < 8; src++)\n    {\n      if (value & mask)\n        block[(chr / 4) + (dst >> 5)] |= 1U << (dst & 0x1F);\n\n      mask >>= 1;\n      dst++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 6; i = i + 2)\n{\n  ptr = DES_do_IP(&block[i]);\n  out[i] = ptr[1];\n  out[i + 1] = ptr[0];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 24; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  binary_salt.u8[i] = (atoi16[ARCH_INDEX(pos[i * 2])] << 4) + atoi16[ARCH_INDEX(pos[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  cnt = DES_IP[i ^ 0x20];\n  j = (unsigned char) ((binary_salt.u8[cnt >> 3] >> (7 - (cnt & 7))) & 1);\n  temp[i / 8] |= j << (7 - (i % 8));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  tmp[i] = (atoi16[ARCH_INDEX(pos[i * 2])] << 4) + atoi16[ARCH_INDEX(pos[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  tmp[i] = (atoi16[ARCH_INDEX(pos[i * 2])] << 4) + atoi16[ARCH_INDEX(pos[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  pos[i << 1] = itoa16[digest[i] >> 4];\n  pos[(i << 1) + 1] = itoa16[digest[i] & 0xF];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char *p = (unsigned char *) saved_key[i];\n  if (*p)\n  {\n    uint32_t nr;\n    uint32_t add;\n    uint32_t tmp;\n    while (((*p) == ' ') || ((*p) == '\\t'))\n      p++;\n\n    tmp = (uint32_t) ((unsigned char) (*(p++)));\n    nr = 1345345333 ^ ((((1345345333 & 63) + 7) * tmp) + (1345345333U << 8));\n    add = 7 + tmp;\n    for (; *p; p++)\n    {\n      if (((*p) == ' ') || ((*p) == '\\t'))\n        continue;\n\n      tmp = (uint32_t) ((unsigned char) (*p));\n      nr ^= (((nr & 63) + add) * tmp) + (nr << 8);\n      add += tmp;\n    }\n\n    crypt_key[i][0] = nr & ((((uint32_t) 1) << 31) - 1);\n    continue;\n  }\n\n  crypt_key[i][0] = 1345345333 & ((((uint32_t) 1) << 31) - 1);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  if (atoi16[ARCH_INDEX(ciphertext[i])] > 15)\n  return 0;\n\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  buff[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  if ((*((uint32_t *) binary)) == crypt_key[i][0])\n{\n  retval |= 1;\n}\n\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  if ((*((uint32_t *) binary)) == crypt_key[i][0])\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; *p; p++)\n{\n  if (((*p) == ' ') || ((*p) == '\\t'))\n    continue;\n\n  tmp = (uint32_t) (*p);\n  nr ^= (((nr & 63) + add) * tmp) + (nr << 8);\n  nr2 += (nr2 << 8) ^ nr;\n  add += tmp;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  setup_des_key(saved_key[i], &ks);\n  DES_ecb_encrypt((DES_cblock *) challenge, (DES_cblock *) output[i], &ks, 1);\n}\n\ninline static void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)\n{\n  DES_cblock key;\n  key[0] = key_56[0];\n  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);\n  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);\n  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);\n  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);\n  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);\n  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);\n  key[7] = key_56[6] << 1;\n  DES_set_key_unchecked(&key, ks);\n}\n\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (pos = &ciphertext[24]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 24; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(output[index], binary, 8))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  setup_des_key(saved_pre[i], &ks);\n  DES_ecb_encrypt((DES_cblock *) challenge, (DES_cblock *) output[i], &ks, 1);\n}\n\ninline static void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)\n{\n  DES_cblock key;\n  key[0] = key_56[0];\n  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);\n  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);\n  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);\n  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);\n  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);\n  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);\n  key[7] = key_56[6] << 1;\n  DES_set_key_unchecked(&key, ks);\n}\n\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (pos = &ciphertext[28]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  binary.c[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary.c[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(output[index], binary, 8))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n{\n  out.c[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char ntlm_v2_hash[16];\n  HMACMD5Context ctx;\n  if (!keys_prepared)\n  {\n    int len;\n    unsigned char ntlm[16];\n    len = E_md4hash(saved_plain[i], saved_len[i], ntlm);\n    hmac_md5_init_K16(ntlm, &saved_ctx[i]);\n    if (len <= 0)\n      saved_plain[i][-len] = 0;\n\n  }\n\n  memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n  hmac_md5_update(&challenge[17], (int) challenge[16], &ctx);\n  hmac_md5_final(ntlm_v2_hash, &ctx);\n  hmac_md5(ntlm_v2_hash, challenge, 16, (unsigned char *) output[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos2 = pos; (*pos2) != '$'; pos2++)\n  if (((unsigned char) (*pos2)) < 0x20)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; atoi16[ARCH_INDEX(*pos2)] != 0x7F; pos2++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(output[index], binary, 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n  binary_salt[i + 8] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  int len;\n  len = E_md4hash((unsigned char *) saved_plain[i], saved_len[i], saved_key[i]);\n  if (len <= 0)\n    saved_plain[i][-len] = 0;\n\n  setup_des_key(saved_key[i], i);\n}\n\ninline static void setup_des_key(unsigned char key_56[], int index)\n{\n  char key[8];\n  key[0] = (key_56[0] >> 1) | 0x80;\n  key[1] = (((key_56[0] << 7) | (key_56[1] >> 1)) >> 1) | 0x80;\n  key[2] = (((key_56[1] << 6) | (key_56[2] >> 2)) >> 1) | 0x80;\n  key[3] = (((key_56[2] << 5) | (key_56[3] >> 3)) >> 1) | 0x80;\n  key[4] = (((key_56[3] << 4) | (key_56[4] >> 4)) >> 1) | 0x80;\n  key[5] = (((key_56[4] << 3) | (key_56[5] >> 5)) >> 1) | 0x80;\n  key[6] = (((key_56[5] << 2) | (key_56[6] >> 6)) >> 1) | 0x80;\n  key[7] = ((key_56[6] << 1) >> 1) | 0x80;\n  DES_bs_set_key((char *) key, index);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = &ciphertext[(sizeof(\"$NETNTLM$\")) - 1]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos++; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (chr = 0; chr < 24; chr = chr + 8)\n{\n  dst = 0;\n  for (i = 0; i < 8; i++)\n  {\n    value = binary[chr + i];\n    mask = 0x80;\n    for (src = 0; src < 8; src++)\n    {\n      if (value & mask)\n        block[(chr / 4) + (dst >> 5)] |= 1U << (dst & 0x1F);\n\n      mask >>= 1;\n      dst++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 6; i = i + 2)\n{\n  ptr = DES_do_IP(&block[i]);\n  out[i] = ptr[1];\n  out[i + 1] = ptr[0];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 24; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (2 * 8); ++i)\n  es_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  cnt = DES_IP[i ^ 0x20];\n  j = (unsigned char) ((binary_salt[cnt >> 3] >> (7 - (cnt & 7))) & 1);\n  temp[i / 8] |= j << (7 - (i % 8));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char ntlm_v2_hash[16];\n  HMACMD5Context ctx;\n  if (!keys_prepared)\n  {\n    unsigned char ntlm[16];\n    int len;\n    len = E_md4hash(saved_plain[i], saved_len[i], ntlm);\n    hmac_md5_init_K16(ntlm, &saved_ctx[i]);\n    if (len <= 0)\n      saved_plain[i][-len] = 0;\n\n  }\n\n  memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n  hmac_md5_update((unsigned char *) (&challenge[1]), identity_length, &ctx);\n  hmac_md5_final(ntlm_v2_hash, &ctx);\n  hmac_md5(ntlm_v2_hash, (((challenge + 1) + identity_length) + 1) + 2, challenge_size, (unsigned char *) output[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos2 = pos; (*pos2) != '$'; pos2++)\n  if (((unsigned char) (*pos2)) < 0x20)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; (*pos2) != '$'; pos2++)\n  if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; atoi16[ARCH_INDEX(*pos2)] != 0x7F; pos2++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETNTLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETNTLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(output[index], binary, 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext + ((sizeof(\"$NETNTLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (16 / 2); i++)\n  binary_salt[(((identity_length + 1) + 2) + 1) + i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (strlen(ciphertext) / 2); ++i)\n  binary_salt[((((identity_length + 1) + 2) + 1) + (16 / 2)) + i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  DES_cblock des_key;\n  DES_key_schedule schedule;\n  int i;\n  int saved_key_length = strlen(saved_key[index]);\n  if (saved_key_length <= 8)\n  {\n    for (i = 0; saved_key[index][i]; i++)\n      des_key[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    while (i < 8)\n      des_key[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key, &schedule);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, (DES_cblock *) crypt_out[index], &schedule, 1);\n  }\n  else\n  {\n    DES_cblock des_key1;\n    DES_cblock des_key2;\n    DES_key_schedule schedule1;\n    DES_key_schedule schedule2;\n    DES_cblock hash_1;\n    DES_cblock hash_2;\n    unsigned char output[8];\n    for (i = 0; i < 8; i++)\n      des_key1[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    for (i = 0; i < (saved_key_length - 8); i++)\n      des_key2[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][8 + i])];\n\n    while (i < 8)\n      des_key2[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key1, &schedule1);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, &hash_1, &schedule1, 1);\n    DES_set_key_unchecked(&des_key2, &schedule2);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, &hash_2, &schedule2, 1);\n    for (i = 0; i < 8; i++)\n    {\n      output[i] = hash_1[i] ^ hash_2[i];\n    }\n\n    memcpy((unsigned char *) crypt_out[index], output, 8);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n  str[i] = a2e[str[i]];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen((const char *) str); i < 8; ++i)\n  str[i] = 0x40;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha256_ctx ctx;\n  if (dirty)\n  {\n    jtr_sha256_init(&prep_ctx[index], 1);\n    jtr_sha256_update(&prep_ctx[index], prep_key[index], 510);\n  }\n\n  memcpy(&ctx, &prep_ctx[index], sizeof(ctx));\n  jtr_sha256_update(&ctx, prep_key[index] + (510 / 2), 8);\n  jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(out.u8)); i++)\n{\n  out.u8[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < kpc; index++)\n{\n  memcpy(((unsigned char *) prep_key[index]) + 510, (unsigned char *) salt, 8);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_out[index])))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  generate_hash((unsigned char *) saved_key[index], saved_salt, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (56 / 2); i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  memcpy(&ctx, &ctx_salt, sizeof(ctx));\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(buf.c)); i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  sph_sha1_context ctx;\n  memcpy(&ctx, &ctx_salt, sizeof(ctx));\n  sph_sha1(&ctx, saved_key[i], saved_len[i]);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[i]);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  if (b0 != crypt_out[i][0])\n    continue;\n\n  if (!memcmp(binary, crypt_out[i], 20))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  adxcrypt(saved_key[index], (unsigned char *) crypt_out[index], strlen(saved_key[index]));\n}\n\nstatic void adxcrypt(char *input, unsigned char *output, int16_t length)\n{\n  char *in;\n  int count;\n  int32_t idx;\n  uint32_t a;\n  uint32_t b;\n  union \n  {\n    char b[8];\n    uint32_t w[2];\n  } buffer;\n  if (length > 0)\n    memcpy(buffer.b, input, length);\n  else\n    return;\n\n  count = length;\n  while (count < 8)\n  {\n    if ((count < 8) && (length > 0))\n    {\n      in = input;\n      idx = 0;\n      do\n      {\n        ++idx;\n        buffer.b[count] = (*(in++)) + count;\n        count++;\n      }\n      while ((count < 8) && (length > idx));\n    }\n\n  }\n\n  idx = 0;\n  a = __builtin_bswap32((buffer.w[0] + buffer.w[1]) ^ 0xCEFAEFBE);\n  do\n  {\n    if ((a & 0xF) <= 9)\n      b = a & 0xF;\n    else\n      b = (a & 0xF) - 7;\n\n    ++idx;\n    *(output++) = b + 48;\n    a >>= 4;\n  }\n  while (idx < 8);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[32];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt[0], cur_salt->saltlen[0], cur_salt->iterations[0], master, 16, 0);\n  if (akcdecrypt(master, cur_salt->ct[0]) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int akcdecrypt(unsigned char *derived_key, unsigned char *data)\n{\n  unsigned char out[1040];\n  int n;\n  int key_size;\n  AES_KEY akey;\n  unsigned char iv[16];\n  memcpy(iv, (data + 1040) - 32, 16);\n  JTR_AES_set_decrypt_key(derived_key, 128, &akey);\n  JTR_AES_cbc_encrypt((data + 1040) - 16, (out + 1040) - 16, 16, &akey, iv, 0);\n  n = check_pkcs_pad(out, 1040, 16);\n  if (n < 0)\n    return -1;\n\n  key_size = n / 8;\n  if (((key_size != 128) && (key_size != 192)) && (key_size != 256))\n    return -1;\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += inc)\n{\n  int j = index;\n  while (j < (index + inc))\n  {\n    if (cur_salt->type == 1)\n    {\n      pbkdf2_sha1((const unsigned char *) saved_key[j], strlen(saved_key[j]), cur_salt->salt, strlen((char *) cur_salt->salt), cur_salt->iterations, (unsigned char *) crypt_out[j], 20, 0);\n      ++j;\n    }\n    else\n      if (cur_salt->type == 256)\n    {\n      pbkdf2_sha256((const unsigned char *) saved_key[j], strlen(saved_key[j]), cur_salt->salt, strlen((char *) cur_salt->salt), cur_salt->iterations, (unsigned char *) crypt_out[j], 20, 0);\n      ++j;\n    }\n    else\n    {\n      pbkdf2_sha512((const unsigned char *) saved_key[j], strlen(saved_key[j]), cur_salt->salt, strlen((char *) cur_salt->salt), cur_salt->iterations, (unsigned char *) crypt_out[j], 20, 0);\n      ++j;\n    }\n\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((len / 4) * 3); i += 3)\n{\n  value = ((((uint32_t) atoi64[ARCH_INDEX(pos[0])]) | (((uint32_t) atoi64[ARCH_INDEX(pos[1])]) << 6)) | (((uint32_t) atoi64[ARCH_INDEX(pos[2])]) << 12)) | (((uint32_t) atoi64[ARCH_INDEX(pos[3])]) << 18);\n  pos += 4;\n  out.c[i] = value >> 16;\n  out.c[i + 1] = value >> 8;\n  out.c[i + 2] = value;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  int t = omp_get_thread_num();\n  if (t >= max_threads)\n  {\n    failed = -1;\n    continue;\n  }\n\n  uint8_t *hash;\n  hash = yescrypt_r(0, &local[t], (const uint8_t *) buffer[index].key, strlen(buffer[index].key), (const uint8_t *) saved_salt, 0, (uint8_t *) buffer[index].out, sizeof(buffer[index].out));\n  if (!hash)\n  {\n    failed = (errno) ? (errno) : (EINVAL);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, max_threads, local, saved_salt, buffer)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (!memcmp(binary, crypt_out[index], (20 - 2) - 2))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, max_threads, local, saved_salt, buffer)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  hash_plugin_check_hash(index);\n}\n\nvoid hash_plugin_check_hash(int index)\n{\n  unsigned char keycandidate2[255];\n  unsigned char decrypted1[512];\n  unsigned char decrypted2[512];\n  AES_KEY aeskey;\n  uint16_t v2;\n  uint16_t v3;\n  uint16_t v4;\n  uint32_t v1;\n  uint32_t v5;\n  int j = 0;\n  unsigned char keycandidate[255];\n  char *password = saved_key[index];\n  pbkdf2_sha1((const uint8_t *) password, strlen(password), (const uint8_t *) cur_salt->salt, 16, 2000, keycandidate, cur_salt->keysize + 16, 0);\n  j = 0;\n  JTR_AES_set_decrypt_key(keycandidate, cur_salt->keysize * 8, &aeskey);\n  JTR_AES_cbc_encrypt(cur_salt->mkey, keycandidate2, 16, &aeskey, keycandidate + 16, 0);\n  AES_cbc_essiv(cur_salt->data, decrypted1, keycandidate2, 0, 32);\n  AES_cbc_essiv(cur_salt->data + 1024, decrypted2, keycandidate2, 2, 128);\n  if (!memcmp(decrypted1 + 3, \"MSDOS5.0\", 8))\n    cracked[index + j] = 1;\n  else\n  {\n    memcpy(&v1, decrypted2 + 72, 4);\n    memcpy(&v2, decrypted2 + 0x3a, 2);\n    memcpy(&v3, decrypted2 + 0x3c, 2);\n    memcpy(&v4, decrypted2 + 0x4c, 2);\n    memcpy(&v5, decrypted2 + 0x48, 4);\n    v1 = __builtin_bswap32(v1);\n    v2 = __builtin_bswap32(v2);\n    v3 = __builtin_bswap32(v3);\n    v4 = __builtin_bswap32(v4);\n    v5 = __builtin_bswap32(v5);\n    if (((((v1 < 5) && (v2 < 4)) && (v3 < 5)) && (v4 < 2)) && (v5 < 5))\n      cracked[index + j] = 1;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n{\n  cs.salt[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.keysize; i++)\n{\n  cs.mkey[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (512 * 3); i++)\n{\n  cs.data[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 32);\n\n  for (i = 0; i < 1; ++i)\n  {\n    JTR_hmac_sha256(master[i], 32, cur_salt->blob, cur_salt->bloblen, (unsigned char *) crypt_out[index + i], 16);\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  argon2_hash(saved_salt.t_cost, saved_salt.m_cost, saved_salt.lanes, saved_key[i], saved_len[i], saved_salt.salt, saved_salt.salt_length, crypted[i], saved_salt.hash_size, 0, 0, saved_salt.type, ARGON2_VERSION_NUMBER, memory[omp_get_thread_num() % sc_threads].aligned, pseudo_rands[omp_get_thread_num() % sc_threads]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n{\n  init_region_t(&memory[i]);\n  pseudo_rands[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n{\n  free_region_t(&memory[i]);\n  {\n    if (pseudo_rands[i])\n    {\n      free(pseudo_rands[i]);\n      pseudo_rands[i] = 0;\n    }\n\n  }\n  ;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; tests[i].ciphertext; i++)\n{\n  struct argon2_salt *salt;\n  salt = get_salt(tests[i].ciphertext);\n  m_cost = (m_cost > salt->m_cost) ? (m_cost) : (salt->m_cost);\n  if (i == 0)\n  {\n    printf(\"\\n\");\n    prev_m_cost = m_cost;\n    print_memory((sizeof(block)) * m_cost);\n  }\n\n}\n\nstatic void *get_salt(char *ciphertext)\n{\n  static struct argon2_salt salt;\n  argon2_context ctx;\n  memset(&salt, 0, sizeof(salt));\n  ctx_init(&ctx);\n  if (!strncmp(ciphertext, \"$argon2d$\", (sizeof(\"$argon2d$\")) - 1))\n  {\n    argon2_decode_string(&ctx, ciphertext, Argon2_d);\n    salt.type = Argon2_d;\n  }\n  else\n  {\n    argon2_decode_string(&ctx, ciphertext, Argon2_i);\n    salt.type = Argon2_i;\n  }\n\n  salt.salt_length = ctx.saltlen;\n  salt.m_cost = ctx.m_cost;\n  salt.t_cost = ctx.t_cost;\n  salt.lanes = ctx.lanes;\n  salt.hash_size = ctx.outlen;\n  memcpy(salt.salt, ctx.salt, ctx.saltlen);\n  return (void *) (&salt);\n}\n\n\nstatic void print_memory(double memory)\n{\n  char s[] = \"\\0kMGT\";\n  int i = 0;\n  while ((memory >= 1024) && s[i + 1])\n  {\n    memory /= 1024;\n    i++;\n  }\n\n  fprintf(stderr, \"memory per hash : %.2lf %cB\\n\", memory, s[i]);\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n  free_region_t(&memory[i]);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n  alloc_region_t(&memory[i], mem_size);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n{\n  if (pseudo_rands[i])\n  {\n    free(pseudo_rands[i]);\n    pseudo_rands[i] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < sc_threads; i++)\n  pseudo_rands[i] = mem_calloc(sizeof(uint64_t), segment_length);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  if (!memcmp(binary, crypted[i], saved_salt.hash_size))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->salt_length; i++)\n{\n  hash <<= 1;\n  hash += (unsigned char) (*(p++));\n  if (hash >> 20)\n  {\n    hash ^= hash >> 20;\n    hash &= (1 << 20) - 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  if (cur_salt->hash_id == (0x80 + 1))\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_64 *pbe64;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    sph_whirlpool_context ctx;\n    unsigned char hash[64];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock64 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(2, cur_salt->iterations, 1, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe64 = (pbe_format_v5_64 *) cur_salt->key;\n    memcpy(iv, pbe64->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe64->keyblock, 256, 256);\n    }\n\n    if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe64->iv, 8);\n      JTR_AES_set_decrypt_key(key, 256, &aes_key);\n      JTR_AES_cbc_encrypt(pbe64->keyblock, out, 160, &aes_key, iv, 0);\n    }\n\n    sph_whirlpool_init(&ctx);\n    sph_whirlpool(&ctx, out, 90);\n    sph_whirlpool_close(&ctx, hash);\n    p = (struct KGEncryptedBlock64 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n  else\n    if (cur_salt->hash_id == 0x80)\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_32 *pbe32;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    jtr_sha256_ctx ctx;\n    unsigned char hash[32];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock32 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(256, cur_salt->iterations, 1, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe32 = (pbe_format_v5_32 *) cur_salt->key;\n    memcpy(iv, pbe32->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe32->keyblock, 256, 256);\n    }\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe32->iv, 8);\n      JTR_AES_set_decrypt_key(key, 256, &aes_key);\n      JTR_AES_cbc_encrypt(pbe32->keyblock, out, 128, &aes_key, iv, 0);\n    }\n\n\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, out, 90);\n    jtr_sha256_final(hash, &ctx);\n    p = (struct KGEncryptedBlock32 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n  else\n    if (cur_salt->hash_id == 10)\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_64 *pbe64;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    jtr_sha512_ctx ctx;\n    unsigned char hash[64];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock64 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(10, cur_salt->iterations, 1, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe64 = (pbe_format_v5_64 *) cur_salt->key;\n    memcpy(iv, pbe64->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe64->keyblock, 256, 256);\n    }\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe64->iv, 8);\n      JTR_AES_set_decrypt_key(key, 256, &aes_key);\n      JTR_AES_cbc_encrypt(pbe64->keyblock, out, 160, &aes_key, iv, 0);\n    }\n\n\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, out, 90);\n    jtr_sha512_final(hash, &ctx);\n    p = (struct KGEncryptedBlock64 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; (i < cs.salt_size) && p[2 * i]; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; (i < (cs.active_slots * 256)) && p[2 * i]; i++)\n  cs.key[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  hash_plugin_check_hash(index);\n}\n\nstatic void hash_plugin_check_hash(int index)\n{\n  unsigned char hmacsha1_key_[20];\n  unsigned char aes_key_[32];\n  int j;\n  if (cur_salt->headerver == 1)\n  {\n    unsigned char derived_key[32];\n    const char *password = saved_key[index];\n    pbkdf2_sha1((const unsigned char *) password, strlen(password), cur_salt->salt, 20, cur_salt->iterations, derived_key, 32, 0);\n    j = 0;\n    if (apple_des3_ede_unwrap_key1(cur_salt->wrapped_aes_key, cur_salt->len_wrapped_aes_key, derived_key) && apple_des3_ede_unwrap_key1(cur_salt->wrapped_hmac_sha1_key, cur_salt->len_hmac_sha1_key, derived_key))\n    {\n      cracked[index + j] = 1;\n    }\n\n  }\n  else\n  {\n    DES_key_schedule ks1;\n    DES_key_schedule ks2;\n    DES_key_schedule ks3;\n    unsigned char TEMP1[sizeof(cur_salt->wrapped_hmac_sha1_key)];\n    AES_KEY aes_decrypt_key;\n    unsigned char outbuf[8192 + 1];\n    unsigned char outbuf2[4096 + 1];\n    unsigned char iv[20];\n    const char nulls[8] = {0};\n    unsigned char derived_key[32];\n    const char *password = saved_key[index];\n    pbkdf2_sha1((const unsigned char *) password, strlen(password), cur_salt->salt, 20, cur_salt->iterations, derived_key, 32, 0);\n    j = 0;\n    DES_set_key_unchecked((DES_cblock *) (derived_key + 0), &ks1);\n    DES_set_key_unchecked((DES_cblock *) (derived_key + 8), &ks2);\n    DES_set_key_unchecked((DES_cblock *) (derived_key + 16), &ks3);\n    memcpy(iv, cur_salt->iv, 8);\n    DES_ede3_cbc_encrypt(cur_salt->encrypted_keyblob, TEMP1, cur_salt->encrypted_keyblob_size, &ks1, &ks2, &ks3, (DES_cblock *) iv, 0);\n    memcpy(aes_key_, TEMP1, 32);\n    memcpy(hmacsha1_key_, TEMP1, 20);\n    JTR_hmac_sha1(hmacsha1_key_, 20, (unsigned char *) (&cur_salt->cno), 4, iv, 20);\n    if (cur_salt->encrypted_keyblob_size == 48)\n      JTR_AES_set_decrypt_key(aes_key_, 128, &aes_decrypt_key);\n    else\n      JTR_AES_set_decrypt_key(aes_key_, 128 * 2, &aes_decrypt_key);\n\n    JTR_AES_cbc_encrypt(cur_salt->chunk, outbuf, cur_salt->data_size, &aes_decrypt_key, iv, 0);\n    if (jtr_memmem(outbuf, cur_salt->data_size, (void *) nulls, 8))\n    {\n      cracked[index + j] = 1;\n    }\n\n    if ((!cracked[index + j]) && (cur_salt->scp == 1))\n    {\n      int cno = 0;\n      JTR_hmac_sha1(hmacsha1_key_, 20, (unsigned char *) (&cno), 4, iv, 20);\n      if (cur_salt->encrypted_keyblob_size == 48)\n        JTR_AES_set_decrypt_key(aes_key_, 128, &aes_decrypt_key);\n      else\n        JTR_AES_set_decrypt_key(aes_key_, 128 * 2, &aes_decrypt_key);\n\n      JTR_AES_cbc_encrypt(cur_salt->zchunk, outbuf2, 4096, &aes_decrypt_key, iv, 0);\n      if (jtr_memmem(outbuf2, 4096, (void *) nulls, 8))\n      {\n        cracked[index + j] = 1;\n      }\n\n    }\n\n  }\n\n  return;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.ivlen; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.encrypted_keyblob_size; i++)\n  cs.encrypted_keyblob[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.data_size; i++)\n  cs.chunk[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4096; i++)\n  cs.zchunk[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.len_wrapped_aes_key; i++)\n  cs.wrapped_aes_key[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.len_hmac_sha1_key; i++)\n  cs.wrapped_hmac_sha1_key[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < outlen; i++)\n  TEMP2[i] = TEMP1[(outlen - i) - 1];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char *passwordBuf;\n  int passwordBufSize;\n  int i;\n  unsigned char out[1][32];\n  jtr_sha256_ctx ctx;\n  unsigned char output[256] = {0};\n  uint32_t data_size = 0;\n  uint32_t version = 0;\n  unsigned char *vmk_blob = 0;\n  unsigned char v1;\n  unsigned char v2;\n  for (i = 0; i < 1; ++i)\n  {\n    passwordBuf = (unsigned char *) saved_key[index + i];\n    passwordBufSize = strlen16((UTF16 *) passwordBuf) * 2;\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, passwordBuf, passwordBufSize);\n    jtr_sha256_final(out[i], &ctx);\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, out[i], 32);\n    jtr_sha256_final(out[i], &ctx);\n    bitlocker_kdf(out[i], out[i]);\n    libcaes_crypt_ccm(out[i], 256, 0, cur_salt->iv, 12, cur_salt->data, cur_salt->data_size, output, cur_salt->data_size);\n    version = output[20] | (output[21] << 8);\n    data_size = output[16] | (output[17] << 8);\n    vmk_blob = &output[16];\n    v1 = vmk_blob[8];\n    v2 = vmk_blob[9];\n    if ((((version == 1) && (data_size == 0x2c)) && (v1 <= 0x05)) && (v2 == 0x20))\n      cracked[index + i] = 1;\n    else\n    {\n      cracked[index + i] = 0;\n    }\n\n  }\n\n}\n\nstatic void bitlocker_kdf(unsigned char *password_hash, unsigned char *out)\n{\n  struct libbde_password_key_data pkd;\n  jtr_sha256_ctx ctx;\n  uint64_t ic;\n  memset(&pkd, 0, sizeof(struct libbde_password_key_data));\n  memcpy(pkd.initial_sha256_hash, password_hash, 32);\n  memcpy(pkd.salt, cur_salt->salt, cur_salt->salt_length);\n  for (ic = 0; ic < cur_salt->iterations; ic++)\n  {\n    jtr_sha256_init(&ctx, 1);\n    pkd.iteration_count = __builtin_bswap64(ic);\n    jtr_sha256_update(&ctx, &pkd, sizeof(struct libbde_password_key_data));\n    jtr_sha256_final(pkd.last_sha256_hash, &ctx);\n  }\n\n  memcpy(out, pkd.last_sha256_hash, 32);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ic = 0; ic < cur_salt->iterations; ic++)\n{\n  jtr_sha256_init(&ctx, 1);\n  pkd.iteration_count = __builtin_bswap64(ic);\n  jtr_sha256_update(&ctx, &pkd, sizeof(struct libbde_password_key_data));\n  jtr_sha256_final(pkd.last_sha256_hash, &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  int j;\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_key[index], strlen(saved_key[index]));\n  jtr_sha512_update(&ctx, cur_salt->salt, strlen((char *) cur_salt->salt));\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n  for (j = 0; j < 99; j++)\n  {\n    jtr_sha512_ctx ctx;\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, (unsigned char *) crypt_out[index], 64);\n    jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[32];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->data, 16, cur_salt->iter, master, 32, 0);\n  if (blockchain_decrypt(master, cur_salt->data) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char *passwordBuf;\n  int passwordBufSize;\n  unsigned char *sidBuf;\n  int sidBufSize;\n  unsigned char out[1][32 + 16];\n  unsigned char out2[1][32 + 16];\n  sph_sha1_context ctx;\n  MD4_CTX ctx2;\n  int i;\n  int digestlens[1];\n  for (i = 0; i < 1; ++i)\n  {\n    digestlens[i] = 16;\n    passwordBuf = (unsigned char *) saved_key[index + i];\n    passwordBufSize = strlen16((UTF16 *) passwordBuf) * 2;\n    if (cur_salt->cred_type == 1)\n    {\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, passwordBuf, passwordBufSize);\n      sph_sha1_close(&ctx, out[i]);\n      digestlens[i] = 20;\n    }\n    else\n      if ((cur_salt->cred_type == 2) || (cur_salt->cred_type == 3))\n    {\n      john_MD4_Init(&ctx2);\n      john_MD4_Update(&ctx2, passwordBuf, passwordBufSize);\n      john_MD4_Final(out[i], &ctx2);\n      digestlens[i] = 16;\n    }\n\n\n  }\n\n  if (cur_salt->cred_type == 3)\n  {\n    sidBuf = (unsigned char *) cur_salt->SID;\n    sidBufSize = strlen16(cur_salt->SID) * 2;\n    for (i = 0; i < 1; ++i)\n    {\n      pbkdf2_sha256(out[i], 16, sidBuf, sidBufSize, 10000, out2[i], 32, 0);\n      pbkdf2_sha256(out2[i], 32, sidBuf, sidBufSize, 1, out[i], 16, 0);\n    }\n\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    passwordBuf = (unsigned char *) cur_salt->SID;\n    passwordBufSize = (strlen16(cur_salt->SID) + 1) * 2;\n    JTR_hmac_sha1(out[i], digestlens[i], passwordBuf, passwordBufSize, out2[i], 20);\n  }\n\n  if (cur_salt->version == 1)\n    pbkdf2_sha1(out2[0], 20, cur_salt->iv, 16, cur_salt->pbkdf2_iterations, out[0], 24 + 8, 0);\n  else\n    if (cur_salt->version == 2)\n    pbkdf2_sha512(out2[0], 20, cur_salt->iv, 16, cur_salt->pbkdf2_iterations, out[0], 32 + 16, 0);\n\n\n  if (cur_salt->version == 1)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      memset(out2[i] + 20, 0, 32 - 20);\n      if (decrypt_v1(out[i], out[i] + 24, out2[i], cur_salt->encrypted) == 0)\n        cracked[index + i] = 1;\n      else\n        cracked[index + i] = 0;\n\n    }\n\n  }\n  else\n    if (cur_salt->version == 2)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      if (decrypt_v2(out[i], out[i] + 32, out2[i], cur_salt->encrypted) == 0)\n        cracked[index + i] = 1;\n      else\n        cracked[index + i] = 0;\n\n    }\n\n  }\n\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int decrypt_v1(unsigned char *key, unsigned char *iv, unsigned char *pwdhash, unsigned char *data)\n{\n  unsigned char out[4096 + 16];\n  unsigned char *last_key;\n  unsigned char *hmacSalt;\n  unsigned char *expected_hmac;\n  unsigned char computed_hmac[20];\n  unsigned char encKey[20];\n  DES_cblock ivec;\n  DES_key_schedule ks1;\n  DES_key_schedule ks2;\n  DES_key_schedule ks3;\n  memset(out, 0, sizeof(out));\n  DES_set_key_unchecked((DES_cblock *) key, &ks1);\n  DES_set_key_unchecked((DES_cblock *) (key + 8), &ks2);\n  DES_set_key_unchecked((DES_cblock *) (key + 16), &ks3);\n  memcpy(ivec, iv, 8);\n  DES_ede3_cbc_encrypt(data, out, cur_salt->encrypted_len, &ks1, &ks2, &ks3, &ivec, 0);\n  hmacSalt = out;\n  expected_hmac = out + 16;\n  last_key = (out + cur_salt->encrypted_len) - 64;\n  JTR_hmac_sha1(pwdhash, 32, hmacSalt, 16, encKey, 20);\n  JTR_hmac_sha1(encKey, 20, last_key, 64, computed_hmac, 20);\n  return memcmp(expected_hmac, computed_hmac, 20);\n}\n\n\nstatic int decrypt_v2(unsigned char *key, unsigned char *iv, unsigned char *pwdhash, unsigned char *data)\n{\n  unsigned char out[4096 + 16];\n  unsigned char *last_key;\n  unsigned char *hmacSalt;\n  unsigned char *expected_hmac;\n  unsigned char hmacComputed[64];\n  unsigned char encKey[64];\n  AES_KEY aeskey;\n  JTR_AES_set_decrypt_key(key, 32 * 8, &aeskey);\n  JTR_AES_cbc_encrypt(data, out, cur_salt->encrypted_len, &aeskey, iv, 0);\n  hmacSalt = out;\n  expected_hmac = out + 16;\n  last_key = (out + cur_salt->encrypted_len) - 64;\n  JTR_hmac_sha512(pwdhash, 20, hmacSalt, 16, encKey, 64);\n  JTR_hmac_sha512(encKey, 64, last_key, 64, hmacComputed, 64);\n  return memcmp(expected_hmac, hmacComputed, 64);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.encrypted_len; i++)\n  cs.encrypted[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, &cur_salt->id, 1);\n  john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  john_MD5_Update(&ctx, cur_salt->challenge, cur_salt->challenge_length);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.challenge_length; i++)\n  cs.challenge[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < loops; ++index)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, (unsigned char *) saved_salt, 8);\n  sph_sha1(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]) + 1);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  uint64_t key[8];\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, (unsigned char *) key, 64, 0);\n  cracked[index] = ckcdecrypt((unsigned char *) key);\n}\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int ckcdecrypt(unsigned char *key)\n{\n  unsigned char tmp[32];\n  JTR_hmac_sha256(key + 32, 32, cur_salt->hmacdata, cur_salt->hmacdatalen, tmp, 32);\n  if (!memcmp(tmp, cur_salt->expectedhmac, 16))\n    return 1;\n  else\n    return 0;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.masterkeylen; i++)\n  cs.masterkey[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.ivlen; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.cryptextlen; i++)\n  cs.cryptext[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.expectedhmaclen; i++)\n  cs.expectedhmac[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.hmacdatalen; i++)\n  cs.hmacdata[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char key[1][24];\n  unsigned char iv[1][8];\n  int i;\n  for (i = 0; i < 1; i++)\n  {\n    pkcs12_pbe_derive_key(1, cur_salt->iterations, 1, (unsigned char *) saved_key[index + i], saved_len[index + i], cur_salt->salt, cur_salt->salt_size, key[i], 24);\n    pkcs12_pbe_derive_key(1, cur_salt->iterations, 2, (unsigned char *) saved_key[index + i], saved_len[index + i], cur_salt->salt, cur_salt->salt_size, iv[i], 8);\n  }\n\n  for (i = 0; i < 1; i++)\n  {\n    unsigned char out[16];\n    unsigned char input[48 + 8];\n    int padbyte;\n    DES_cblock ivec;\n    DES_key_schedule ks1;\n    DES_key_schedule ks2;\n    DES_key_schedule ks3;\n    DES_set_key_unchecked((DES_cblock *) key[i], &ks1);\n    DES_set_key_unchecked((DES_cblock *) (key[i] + 8), &ks2);\n    DES_set_key_unchecked((DES_cblock *) (key[i] + 16), &ks3);\n    memcpy(ivec, iv[i], 8);\n    memcpy(input, saved_key[index + i], saved_len[index + i]);\n    padbyte = 8 - (saved_len[index + i] % 8);\n    if ((padbyte < 8) && (padbyte > 0))\n      memset(input + saved_len[index + i], padbyte, padbyte);\n\n    DES_ede3_cbc_encrypt(input, out, 8, &ks1, &ks2, &ks3, &ivec, 1);\n    cracked[index + i] = !memcmp(out, cur_salt->encrypted_pin, 8);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (dirty)\n  {\n    DES_cblock des_key;\n    int i;\n    for (i = 0; saved_key[index][i]; i++)\n      des_key[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    while (i < 8)\n      des_key[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key, &schedules[index]);\n  }\n\n  char key[10];\n  strnzcpy(key, saved_key[index], 9);\n  ascii2ebcdic((unsigned char *) key);\n  ebcdic_padding((unsigned char *) key);\n  DES_ecb_encrypt((const_DES_cblock *) key, (DES_cblock *) crypt_out[index], &schedules[index], 1);\n}\n\nstatic void ascii2ebcdic(unsigned char *str)\n{\n  int i;\n  int n = strlen((const char *) str);\n  for (i = 0; i < n; ++i)\n    str[i] = a2e[str[i]];\n\n}\n\n\nstatic void ebcdic_padding(unsigned char *str)\n{\n  int i;\n  for (i = strlen((const char *) str); i < 9; ++i)\n    str[i] = 0x40;\n\n  str[9] = 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n  str[i] = a2e[str[i]];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen((const char *) str); i < 9; ++i)\n  str[i] = 0x40;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*ciphertext)] << 4) | atoi16[ARCH_INDEX(ciphertext[1])];\n  ciphertext += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char key[40];\n  if (((cur_salt->algorithm == 5) || (cur_salt->algorithm == 6)) || (cur_salt->algorithm == 7))\n  {\n    AES_KEY aes_key;\n    pgpdisk_kdf(saved_key[index], cur_salt->salt, key, 32);\n    JTR_AES_set_encrypt_key(key, 256, &aes_key);\n    (1 == 1) ? (JTR_AES_encrypt(key, (unsigned char *) crypt_out[index], &aes_key)) : (JTR_AES_decrypt(key, (unsigned char *) crypt_out[index], &aes_key));\n  }\n  else\n    if (cur_salt->algorithm == 4)\n  {\n    Twofish_key tkey;\n    pgpdisk_kdf(saved_key[index], cur_salt->salt, key, 32);\n    Twofish_prepare_key(key, 32, &tkey);\n    Twofish_encrypt(&tkey, key, (unsigned char *) crypt_out[index]);\n  }\n  else\n    if (cur_salt->algorithm == 3)\n  {\n    CAST_KEY ck;\n    pgpdisk_kdf(saved_key[index], cur_salt->salt, key, 16);\n    CAST_set_key(&ck, 16, key);\n    memset((unsigned char *) crypt_out[index], 0, 16);\n    CAST_ecb_encrypt(key, (unsigned char *) crypt_out[index], &ck, 1);\n  }\n\n\n\n}\n\nstatic void pgpdisk_kdf(char *password, unsigned char *salt, unsigned char *key, int key_length)\n{\n  uint32_t bytesNeeded = key_length;\n  uint32_t offset = 0;\n  unsigned char hash[20];\n  int plen;\n  int iterations = cur_salt->iterations;\n  sph_sha1_context ctx;\n  plen = strlen(password);\n  while (bytesNeeded > 0)\n  {\n    uint32_t bytesThisTime = (20 < bytesNeeded) ? (20) : (bytesNeeded);\n    uint32_t j = 0;\n    sph_sha1_init(&ctx);\n    if (offset > 0)\n    {\n      sph_sha1(&ctx, key, 20);\n    }\n\n    sph_sha1(&ctx, password, plen);\n    sph_sha1_close(&ctx, hash);\n    sph_sha1_init(&ctx);\n    if (cur_salt->algorithm == 3)\n      sph_sha1(&ctx, salt, 8);\n    else\n      sph_sha1(&ctx, salt, 16);\n\n    for (j = 0; j < iterations; j++)\n    {\n      sph_sha1(&ctx, hash, bytesThisTime);\n      sph_sha1(&ctx, ((uint8_t *) (&j)) + 3, 1);\n    }\n\n    sph_sha1_close(&ctx, key + offset);\n    bytesNeeded -= bytesThisTime;\n    offset += bytesThisTime;\n  }\n\n}\n\n\nstatic void pgpdisk_kdf(char *password, unsigned char *salt, unsigned char *key, int key_length)\n{\n  uint32_t bytesNeeded = key_length;\n  uint32_t offset = 0;\n  unsigned char hash[20];\n  int plen;\n  int iterations = cur_salt->iterations;\n  sph_sha1_context ctx;\n  plen = strlen(password);\n  while (bytesNeeded > 0)\n  {\n    uint32_t bytesThisTime = (20 < bytesNeeded) ? (20) : (bytesNeeded);\n    uint32_t j = 0;\n    sph_sha1_init(&ctx);\n    if (offset > 0)\n    {\n      sph_sha1(&ctx, key, 20);\n    }\n\n    sph_sha1(&ctx, password, plen);\n    sph_sha1_close(&ctx, hash);\n    sph_sha1_init(&ctx);\n    if (cur_salt->algorithm == 3)\n      sph_sha1(&ctx, salt, 8);\n    else\n      sph_sha1(&ctx, salt, 16);\n\n    for (j = 0; j < iterations; j++)\n    {\n      sph_sha1(&ctx, hash, bytesThisTime);\n      sph_sha1(&ctx, ((uint8_t *) (&j)) + 3, 1);\n    }\n\n    sph_sha1_close(&ctx, key + offset);\n    bytesNeeded -= bytesThisTime;\n    offset += bytesThisTime;\n  }\n\n}\n\n\nstatic void pgpdisk_kdf(char *password, unsigned char *salt, unsigned char *key, int key_length)\n{\n  uint32_t bytesNeeded = key_length;\n  uint32_t offset = 0;\n  unsigned char hash[20];\n  int plen;\n  int iterations = cur_salt->iterations;\n  sph_sha1_context ctx;\n  plen = strlen(password);\n  while (bytesNeeded > 0)\n  {\n    uint32_t bytesThisTime = (20 < bytesNeeded) ? (20) : (bytesNeeded);\n    uint32_t j = 0;\n    sph_sha1_init(&ctx);\n    if (offset > 0)\n    {\n      sph_sha1(&ctx, key, 20);\n    }\n\n    sph_sha1(&ctx, password, plen);\n    sph_sha1_close(&ctx, hash);\n    sph_sha1_init(&ctx);\n    if (cur_salt->algorithm == 3)\n      sph_sha1(&ctx, salt, 8);\n    else\n      sph_sha1(&ctx, salt, 16);\n\n    for (j = 0; j < iterations; j++)\n    {\n      sph_sha1(&ctx, hash, bytesThisTime);\n      sph_sha1(&ctx, ((uint8_t *) (&j)) + 3, 1);\n    }\n\n    sph_sha1_close(&ctx, key + offset);\n    bytesNeeded -= bytesThisTime;\n    offset += bytesThisTime;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < iterations; j++)\n{\n  sph_sha1(&ctx, hash, bytesThisTime);\n  sph_sha1(&ctx, ((uint8_t *) (&j)) + 3, 1);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, 8, cur_salt->iterations, master[0], cur_salt->key_length, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    if (pem_decrypt(master[i], cur_salt->iv, cur_salt->ciphertext, cur_salt) == 0)\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  *crypt_key[index] = AdEncryptPassword(saved_salt, saved_key[index]);\n\nunsigned int AdEncryptPassword(const char *username, const char *password)\n{\n  unsigned int userlength;\n  unsigned int passlength;\n  unsigned int a = 0;\n  int i;\n  for (i = 0; username[i] != 0; i++)\n  {\n    a += AdRandomNumbers[(i + username[i]) & 0x7ff];\n  }\n\n  userlength = i;\n  for (i = 0; password[i] != 0; i++)\n  {\n    a += AdRandomNumbers[((i + password[i]) + userlength) & 0x7ff];\n  }\n\n  passlength = i;\n  return AdRandomNumbers[(userlength + passlength) & 0x7ff] + a;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; username[i] != 0; i++)\n{\n  a += AdRandomNumbers[(i + username[i]) & 0x7ff];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; password[i] != 0; i++)\n{\n  a += AdRandomNumbers[((i + password[i]) + userlength) & 0x7ff];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n  if ((*((unsigned int *) binary)) == (*((unsigned int *) crypt_key[i])))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n{\n  CRC32_t crc = crcsalt;\n  unsigned char *p = (unsigned char *) saved_key[i];\n  while (*p)\n    crc = JTR_CRC32_table[(unsigned char) (crc ^ (*(p++)))] ^ (crc >> 8);\n\n  crcs[i] = crc;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n{\n  CRC32_t crc = crcsalt;\n  unsigned char *p = (unsigned char *) saved_key[i];\n  while (*p)\n    crc = JTR_CRC32_tableC[(unsigned char) (crc ^ (*(p++)))] ^ (crc >> 8);\n\n  crcs[i] = crc;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n{\n  int c1 = ARCH_INDEX(p[1 + i]);\n  int c2 = ARCH_INDEX(p[10 + i]);\n  if ((atoi16[c1] == 0x7F) || (atoi16[c2] == 0x7F))\n    return 0;\n\n  if ((c1 >= 'A') && (c1 <= 'F'))\n    return 0;\n\n  if ((c2 >= 'A') && (c2 <= 'F'))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n  if (crc == crcs[i])\n  return 1;\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char key[1][32];\n  unsigned char hash[1][32];\n  BF_KEY bf_key;\n  int bf_ivec_pos;\n  int i;\n  unsigned char ivec[8];\n  unsigned char output[1024];\n  sph_sha1_context ctx;\n  if ((cur_salt->checksum_type == 0) && (cur_salt->cipher_type == 0))\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, (unsigned char *) saved_key[index + i], strlen(saved_key[index + i]));\n      sph_sha1_close(&ctx, (unsigned char *) hash[i]);\n    }\n\n    pbkdf2_sha1(hash[0], 20, cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, key[0], cur_salt->key_size, 0);\n    for (i = 0; i < 1; ++i)\n    {\n      unsigned int crypt[5];\n      bf_ivec_pos = 0;\n      memcpy(ivec, cur_salt->iv, 8);\n      BF_set_key(&bf_key, cur_salt->key_size, key[i]);\n      BF_cfb64_encrypt(cur_salt->content, output, cur_salt->content_length, &bf_key, ivec, &bf_ivec_pos, 0);\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, output, cur_salt->original_length);\n      sph_sha1_close(&ctx, (unsigned char *) crypt);\n      crypt_out[index + i][0] = crypt[0];\n      if (((cur_salt->original_length % 64) >= 52) && ((cur_salt->original_length % 64) <= 55))\n        SHA1_odf_buggy(output, cur_salt->original_length, crypt);\n\n      crypt_out[index + i][1] = crypt[0];\n    }\n\n  }\n  else\n  {\n    jtr_sha256_ctx ctx;\n    AES_KEY akey;\n    unsigned char iv[16];\n    for (i = 0; i < 1; ++i)\n    {\n      jtr_sha256_init(&ctx, 1);\n      jtr_sha256_update(&ctx, (unsigned char *) saved_key[index + i], strlen(saved_key[index + i]));\n      jtr_sha256_final((unsigned char *) hash[i], &ctx);\n    }\n\n    pbkdf2_sha1(hash[0], 32, cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, key[0], cur_salt->key_size, 0);\n    for (i = 0; i < 1; ++i)\n    {\n      unsigned int crypt[8];\n      memcpy(iv, cur_salt->iv, 16);\n      JTR_AES_set_decrypt_key(key[i], 256, &akey);\n      JTR_AES_cbc_encrypt(cur_salt->content, output, cur_salt->content_length, &akey, iv, 0);\n      jtr_sha256_init(&ctx, 1);\n      jtr_sha256_update(&ctx, output, cur_salt->content_length);\n      jtr_sha256_final((unsigned char *) crypt, &ctx);\n      crypt_out[index + i][0] = crypt[0];\n      crypt_out[index + i][1] = crypt[0];\n    }\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n    return 1;\n\n  if ((*((uint32_t *) binary)) == crypt_out[index][1])\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  unsigned char *out = (unsigned char *) crypt_out[index];\n  unsigned char hash[16];\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  john_MD5_Final(hash, &ctx);\n  compressor(hash, out);\n}\n\nstatic void compressor(unsigned char *in, unsigned char *out)\n{\n  int i;\n  int j;\n  for (i = 0, j = 0; i < 16; i += 2, j++)\n  {\n    out[j] = (in[i] + in[i + 1]) % 62;\n    if (out[j] < 10)\n    {\n      out[j] += 48;\n    }\n    else\n      if (out[j] < 36)\n    {\n      out[j] += 55;\n    }\n    else\n    {\n      out[j] += 61;\n    }\n\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  if (!isalnum((int) ((unsigned char) p[i])))\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, j = 0; i < 16; i += 2, j++)\n{\n  out[j] = (in[i] + in[i + 1]) % 62;\n  if (out[j] < 10)\n  {\n    out[j] += 48;\n  }\n  else\n    if (out[j] < 36)\n  {\n    out[j] += 55;\n  }\n  else\n  {\n    out[j] += 61;\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char pkey[1][32];\n  int i;\n  for (i = 0; i < 1; i++)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 32, 10204, pkey[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; i++)\n  {\n    if (dashlane_verify(cur_salt, pkey[i]))\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt.c, strlen((char *) cur_salt->salt.c), cur_salt->iterations, (unsigned char *) crypt_out[index], 32, 0);\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  int t = omp_get_thread_num();\n  if (t >= max_threads)\n  {\n    failed = -1;\n    continue;\n  }\n\n  if (yescrypt_kdf(0, &local[t], (const uint8_t *) saved_key[index], strlen(saved_key[index]), (const uint8_t *) cur_salt->salt, strlen(cur_salt->salt), &params, (uint8_t *) crypt_out[index], sizeof(crypt_out[index])))\n  {\n    failed = (errno) ? (errno) : (EINVAL);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_free_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  sph_whirlpool_context wctx;\n  int i;\n  union \n  {\n    unsigned char buf[64];\n    uint64_t p64[1];\n  } output1[1];\n  union \n  {\n    unsigned char buf[64];\n    uint64_t p64[1];\n  } output2;\n  jtr_sha512_ctx sctx;\n  jtr_sha512_init(&sctx, 1);\n  jtr_sha512_update(&sctx, saved_key[index], saved_len[index]);\n  jtr_sha512_update(&sctx, cur_salt->salt, cur_salt->saltlen);\n  jtr_sha512_final(output1[0].buf, &sctx);\n  for (i = 0; i < 1; ++i)\n  {\n    sph_whirlpool_init(&wctx);\n    sph_whirlpool(&wctx, cur_salt->salt, cur_salt->saltlen);\n    sph_whirlpool(&wctx, saved_key[index + i], saved_len[index + i]);\n    sph_whirlpool_close(&wctx, output2.buf);\n    crypt_out[index + i][0] = output1[i].p64[0] ^ output2.p64[0];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint64_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; ++i)\n  output1[i] ^= output2[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  jtr_sha256_ctx ctx;\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha256_update(&ctx, cur_salt, salt_len);\n  jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext; (*pos) && ((*pos) != '$'); pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n{\n  value = ((((uint32_t) atoi64[ARCH_INDEX(pos[0])]) | (((uint32_t) atoi64[ARCH_INDEX(pos[1])]) << 6)) | (((uint32_t) atoi64[ARCH_INDEX(pos[2])]) << 12)) | (((uint32_t) atoi64[ARCH_INDEX(pos[3])]) << 18);\n  pos += 4;\n  out[i] = value >> 16;\n  out[i + 11] = value >> 8;\n  out[i + 21] = value;\n  ;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (*((unsigned char *) salt)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha512_update(&ctx, cur_salt, salt_len);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext; (*pos) && ((*pos) != '$'); pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  value = ((((uint32_t) atoi64[ARCH_INDEX(pos[0])]) | (((uint32_t) atoi64[ARCH_INDEX(pos[1])]) << 6)) | (((uint32_t) atoi64[ARCH_INDEX(pos[2])]) << 12)) | (((uint32_t) atoi64[ARCH_INDEX(pos[3])]) << 18);\n  pos += 4;\n  out[i] = value >> 16;\n  out[i + 21] = value >> 8;\n  out[i + 42] = value;\n  ;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 62))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (*((unsigned char *) salt)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  unsigned char tmp[(512 / 8) + 47];\n  int len = EncKeyLen[index];\n  unsigned Lcount = loopCnt - 1;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, cursalt, 8);\n  jtr_sha512_update(&ctx, EncKey[index], len);\n  memcpy(&tmp[512 / 8], (char *) EncKey[index], len);\n  jtr_sha512_final(tmp, &ctx);\n  len += 512 / 8;\n  do\n  {\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, tmp, len);\n    jtr_sha512_final(tmp, &ctx);\n  }\n  while (--Lcount);\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, tmp, len);\n  jtr_sha512_final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  MD5_CTX ctx;\n  if (new_keys)\n  {\n    john_MD5_Init(&ipad_ctx[index]);\n    john_MD5_Update(&ipad_ctx[index], ipad[index], 64);\n    john_MD5_Init(&opad_ctx[index]);\n    john_MD5_Update(&opad_ctx[index], opad[index], 64);\n  }\n\n  memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n  john_MD5_Update(&ctx, cur_salt, strlen((char *) cur_salt));\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n  memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n  john_MD5_Update(&ctx, crypt_key[index], 16);\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pos; i < ((16 * 2) + pos); i++)\n{\n  if (!(((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m_Dynamic_Count; i += inc)\n  DynamicFunc__crypt2_md5(i, i + inc, omp_get_thread_num());\n\nvoid DynamicFunc__crypt2_md5(unsigned int first, unsigned int last, unsigned int tid)\n{\n  unsigned int i;\n  unsigned int til;\n  i = first;\n  til = last;\n  for (; i < til; ++i)\n  {\n    unsigned int len = total_len2_X86[i];\n    do\n    {\n      if ((!force_md5_ctx) && (len < 55))\n      {\n        input_buf2_X86[i >> MD5_X2].x1.b[len] = 0x80;\n        input_buf2_X86[i >> MD5_X2].x1.w[14] = len << 3;\n        MD5_swap(input_buf2_X86[i >> MD5_X2].x1.w, input_buf2_X86[i >> MD5_X2].x1.w, (len + 4) >> 2);\n        MD5_body_for_thread(0, input_buf2_X86[i >> MD5_X2].x1.w, crypt_key2_X86[i >> MD5_X2].x1.w);\n        MD5_swap(crypt_key2_X86[i >> MD5_X2].x1.w, crypt_key2_X86[i >> MD5_X2].x1.w, 4);\n      }\n      else\n      {\n        MD5_CTX ctx;\n        john_MD5_Init(&ctx);\n        john_MD5_Update(&ctx, input_buf2_X86[i >> MD5_X2].x1.b, len);\n        john_MD5_Final((unsigned char *) crypt_key2_X86[i >> MD5_X2].x1.b, &ctx);\n      }\n\n    }\n    while (0);\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < m_Dynamic_Count; j += inc)\n{\n  unsigned int i;\n  unsigned int top = j + inc;\n  if (top > Dynamic_curdat.pFmtMain->params.max_keys_per_crypt)\n    top = Dynamic_curdat.pFmtMain->params.max_keys_per_crypt;\n\n  for (i = 0; Dynamic_curdat.dynamic_FUNCTIONS[i]; ++i)\n    (*Dynamic_curdat.dynamic_FUNCTIONS[i])(j, top, omp_get_thread_num());\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  if (atoi64[ARCH_INDEX(cp[i])] == 0x7F)\n    return 0;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cipherTextLen; i++)\n{\n  if (atoi16[ARCH_INDEX(cp[i])] == 0x7f)\n    return 0;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pPriv->dynamic_SALT_OFFSET + 4; ciphertext[i]; i++)\n  if (atoi16[ARCH_INDEX(ciphertext[i])] == 0x7f)\n  return 0;\n\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; ++i)\n{\n  if ((pPriv->FldMask & (0x00008000 << i)) == (0x00008000 << i))\n  {\n    char Fld[8];\n    sprintf(Fld, \"$$F%d\", i);\n    if (!strstr(&ciphertext[pPriv->dynamic_SALT_OFFSET - 1], Fld))\n      return 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < m_ompt; ++i)\n  dyna_eLargeOut[i] = what;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < m_ompt; ++i)\n  dyna_nLargeOff[i] = val;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < m_ompt; ++i)\n  md5_unicode_convert[i] = what;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < (((1 << MD5_X2) * 2) * 2); ++i)\n{\n  memset(input_buf_X86[i >> MD5_X2].x1.b, 0, (total_len_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len_X86[i] + 8));\n  total_len_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < (((1 << MD5_X2) * 2) * 2); ++i)\n{\n  memset(input_buf2_X86[i >> MD5_X2].x1.b, 0, (total_len2_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len2_X86[i] + 8));\n  total_len2_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m_ompt; ++i)\n{\n  dyna_eLargeOut[i] = eBase16;\n  dyna_nLargeOff[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; ++i)\n  dynamic_BHO[i].dat = mem_calloc_align(((1 << MD5_X2) * 2) * 2, sizeof(*dynamic_BHO[0].dat), 16);\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 7; ++i)\n{\n  fmt_Dynamic.methods.binary_hash[i] = pFmt->methods.binary_hash[i];\n  fmt_Dynamic.methods.get_hash[i] = pFmt->methods.get_hash[i];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (((1 << MD5_X2) * 2) * 2); ++i)\n  total_len2_X86[i] = 32;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; ++i)\n{\n  if (dynamic_BHO[i].dat)\n  {\n    free(dynamic_BHO[i].dat);\n    dynamic_BHO[i].dat = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; ++i)\n{\n  if (pPriv->FldMask & (0x00008000 << i))\n  {\n    sprintf(Tmp, \"$$F%d\", i);\n    if (((split_fields[i] && split_fields[i][0]) && strcmp(split_fields[i], \"/\")) && (!strstr(cpBuilding, Tmp)))\n    {\n      static char ct[1024];\n      char ct2[1024];\n      snprintf(ct2, sizeof(ct2), \"%s$$F%d%s\", cpBuilding, i, split_fields[i]);\n      strcpy(ct, ct2);\n      cpBuilding = ct;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; ++i, bit <<= 1)\n{\n  if (todo_bits & bit)\n  {\n    todo_bits ^= bit;\n    fld_lens[i] = *(cpsalt++);\n    flds[i] = cpsalt;\n    if (todo_bits == 0)\n      return;\n\n    cpsalt += fld_lens[i];\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < saved_key_len[index]; ++i)\n  out[i] = cp[i];\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  if (!(((uint32_t *) binary)[0] - crypt_key_X86[i >> MD5_X2].x1.w[0]))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  if (!(((uint32_t *) binary)[0] - (crypt_key_X86[i >> MD5_X2].x1.w[0] & 0xffffff00)))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m_Dynamic_Count; ++i)\n  total_len_X86[i] = Dynamic_curdat.store_keys_normal_but_precompute_hash_to_output2_base16_to_input1_offsetX;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m_Dynamic_Count; ++i)\n{\n  if (Dynamic_curdat.store_keys_in_input)\n  {\n    dc.iPw = input_buf_X86[i >> MD5_X2].x1.b;\n  }\n  else\n    dc.iPw = saved_key[i];\n\n  dc.nPw = saved_key_len[i];\n  dc.oBin = crypt_key_X86[i >> MD5_X2].x1.B;\n  run_one_RDP_test(&dc);\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; Dynamic_curdat.dynamic_FUNCTIONS[i]; ++i)\n  (*Dynamic_curdat.dynamic_FUNCTIONS[i])(0, m_Dynamic_Count, 0);\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n  crc = JTR_CRC32_table[(unsigned char) (crc ^ salt[i])] ^ (crc >> 8);\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 4; x; --x, i += 2)\n{\n  *(cp++) = (atoi16[ARCH_INDEX(p[i])] * 16) + atoi16[ARCH_INDEX(p[i + 1])];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = len - 3; i >= 0; --i)\n{\n  if ((extern_salt[i] == '$') && (extern_salt[i + 1] == '$'))\n  {\n    switch (extern_salt[i + 2])\n    {\n      case '2':\n        if (Dynamic_curdat.b2Salts)\n      {\n        salt2 = &extern_salt[i + 3];\n        nsalt2 = strlen((char *) salt2);\n        nsalt2 = ConvertFromHex(salt2, nsalt2);\n        extern_salt[i] = 0;\n        bit_array |= 1;\n        the_real_len += nsalt2 + 1;\n      }\n\n        break;\n\n      case 'U':\n        if (Dynamic_curdat.nUserName)\n      {\n        userid = &extern_salt[i + 3];\n        nuserid = strlen((char *) userid);\n        nuserid = ConvertFromHex(userid, nuserid);\n        extern_salt[i] = 0;\n        bit_array |= 2;\n        the_real_len += nuserid + 1;\n      }\n\n        break;\n\n      case 'F':\n      {\n        if ((extern_salt[i + 3] >= '0') && (extern_salt[i + 3] <= '9'))\n        {\n          if (Dynamic_curdat.FldMask && ((Dynamic_curdat.FldMask & (0x00008000 << (extern_salt[i + 3] - '0'))) == (0x00008000 << (extern_salt[i + 3] - '0'))))\n          {\n            Flds[extern_salt[i + 3] - '0'] = &extern_salt[i + 4];\n            nFlds[extern_salt[i + 3] - '0'] = strlen((char *) Flds[extern_salt[i + 3] - '0']);\n            nFlds[extern_salt[i + 3] - '0'] = ConvertFromHex(Flds[extern_salt[i + 3] - '0'], nFlds[extern_salt[i + 3] - '0']);\n            extern_salt[i] = 0;\n            bit_array |= 1 << ((2 + extern_salt[i + 3]) - '0');\n            the_real_len += nFlds[extern_salt[i + 3] - '0'] + 1;\n          }\n\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\nstatic int ConvertFromHex(unsigned char *p, int len)\n{\n  unsigned char *cp;\n  unsigned int i;\n  unsigned int x;\n  if ((!p) || memcmp(p, \"HEX$\", 4))\n    return len;\n\n  len -= 4;\n  len >>= 1;\n  cp = p;\n  x = len;\n  for (i = 4; x; --x, i += 2)\n  {\n    *(cp++) = (atoi16[ARCH_INDEX(p[i])] * 16) + atoi16[ARCH_INDEX(p[i + 1])];\n  }\n\n  *cp = 0;\n  return len;\n}\n\n\nstatic int ConvertFromHex(unsigned char *p, int len)\n{\n  unsigned char *cp;\n  unsigned int i;\n  unsigned int x;\n  if ((!p) || memcmp(p, \"HEX$\", 4))\n    return len;\n\n  len -= 4;\n  len >>= 1;\n  cp = p;\n  x = len;\n  for (i = 4; x; --x, i += 2)\n  {\n    *(cp++) = (atoi16[ARCH_INDEX(p[i])] * 16) + atoi16[ARCH_INDEX(p[i + 1])];\n  }\n\n  *cp = 0;\n  return len;\n}\n\n\nstatic int ConvertFromHex(unsigned char *p, int len)\n{\n  unsigned char *cp;\n  unsigned int i;\n  unsigned int x;\n  if ((!p) || memcmp(p, \"HEX$\", 4))\n    return len;\n\n  len -= 4;\n  len >>= 1;\n  cp = p;\n  x = len;\n  for (i = 4; x; --x, i += 2)\n  {\n    *(cp++) = (atoi16[ARCH_INDEX(p[i])] * 16) + atoi16[ARCH_INDEX(p[i + 1])];\n  }\n\n  *cp = 0;\n  return len;\n}\n\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; ++i, bit <<= 1)\n{\n  if (nFlds[i])\n  {\n    *(Buffer++) = nFlds[i];\n    memcpy((char *) Buffer, (char *) Flds[i], nFlds[i]);\n    Buffer += nFlds[i];\n    bit_array &= ~bit;\n    if (!bit_array)\n      return the_real_len;\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < slen; ++i)\n{\n  s2[i << 1] = Salt[i];\n  s2[(i << 1) + 1] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 28; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 40; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 48; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; ++i)\n{\n  *(cpo++) = itoa16[(*cpi) >> 4];\n  *(cpo++) = itoa16[(*cpi) & 0xF];\n  ++cpi;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  b[i] = ((atoi64[ARCH_INDEX(pos[(i * 4) + 0])] + (atoi64[ARCH_INDEX(pos[(i * 4) + 1])] << 6)) + (atoi64[ARCH_INDEX(pos[(i * 4) + 2])] << 12)) + (atoi64[ARCH_INDEX(pos[(i * 4) + 3])] << 18);\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; ++i)\n{\n  sprintf(buf, \"%X%X\", i >> 4, i & 0xF);\n  memcpy(&__Dynamic_itoa_w2_u[i], buf, 2);\n  sprintf(buf, \"%x%x\", i >> 4, i & 0xF);\n  memcpy(&__Dynamic_itoa_w2_l[i], buf, 2);\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = (unsigned char *) utf16Str;\n  if ((total_len_X86[j] + outlen) <= (256 - 17))\n  {\n    cp = &input_buf_X86[j >> MD5_X2].x1.B[total_len_X86[j]];\n    for (z = 0; z < outlen; ++z)\n    {\n      *(cp++) = *(cpi++);\n    }\n\n    total_len_X86[j] += outlen;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = Str;\n  if ((total_len_X86[j] + (len << 1)) <= (256 - 17))\n  {\n    cp = &input_buf_X86[j >> MD5_X2].x1.B[total_len_X86[j]];\n    for (z = 0; z < len; ++z)\n    {\n      *(cp++) = *(cpi++);\n      *(cp++) = 0;\n    }\n\n    total_len_X86[j] += len << 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  memcpy(&input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]], Str, len);\n  total_len_X86[j] += len;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = (unsigned char *) utf16Str;\n  if ((total_len2_X86[j] + outlen) <= (256 - 17))\n  {\n    cp = &input_buf2_X86[j >> MD5_X2].x1.B[total_len2_X86[j]];\n    for (z = 0; z < outlen; ++z)\n    {\n      *(cp++) = *(cpi++);\n    }\n\n    total_len2_X86[j] += outlen;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = Str;\n  if ((total_len2_X86[j] + (len << 1)) <= (256 - 17))\n  {\n    cp = &input_buf2_X86[j >> MD5_X2].x1.B[total_len2_X86[j]];\n    for (z = 0; z < len; ++z)\n    {\n      *(cp++) = *(cpi++);\n      *(cp++) = 0;\n    }\n\n    total_len2_X86[j] += len << 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  memcpy(&input_buf2_X86[j >> MD5_X2].x1.b[total_len2_X86[j]], Str, len);\n  total_len2_X86[j] += len;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf_X86[i >> MD5_X2].x1.b, 0, (total_len_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len_X86[i] + 8));\n  total_len_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf2_X86[i >> MD5_X2].x1.b, 0, (total_len2_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len2_X86[i] + 8));\n  total_len2_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf_X86[i >> MD5_X2].x1.b, 0, (total_len_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len_X86[i] + 8));\n  total_len_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf2_X86[i >> MD5_X2].x1.b, 0, (total_len2_X86[i] > ((sizeof(input_buf_X86[0].x1.b)) - 8)) ? (sizeof(input_buf_X86[0].x1.b)) : (total_len2_X86[i] + 8));\n  total_len2_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf_X86[i >> MD5_X2].x1.b, 0, total_len_X86[i] + 5);\n  total_len_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = first; i < last; ++i)\n{\n  memset(input_buf2_X86[i >> MD5_X2].x1.b, 0, total_len2_X86[i] + 5);\n  total_len2_X86[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi;\n  UTF16 utf16Str[((((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125)) + 1];\n  int outlen;\n  if (utf16 == 1)\n    outlen = enc_to_utf16(utf16Str, (((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125), (unsigned char *) saved_key[j], saved_key_len[j]) * (sizeof(UTF16));\n  else\n    outlen = enc_to_utf16_be(utf16Str, (((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125), (unsigned char *) saved_key[j], saved_key_len[j]) * (sizeof(UTF16));\n\n  if (outlen <= 0)\n  {\n    saved_key_len[j] = (-outlen) / (sizeof(UTF16));\n    if (outlen < 0)\n      outlen = strlen16(utf16Str) * (sizeof(UTF16));\n\n  }\n\n  if ((total_len_X86[j] + outlen) <= (256 - 17))\n  {\n    cp = &input_buf_X86[j >> MD5_X2].x1.B[total_len_X86[j]];\n    for (cpi = (unsigned char *) utf16Str, z = 0; z < outlen; ++z)\n      *(cp++) = *(cpi++);\n\n    total_len_X86[j] += outlen;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = (unsigned char *) saved_key[j];\n  if ((total_len_X86[j] + (saved_key_len[j] << 1)) <= (256 - 17))\n  {\n    cp = &input_buf_X86[j >> MD5_X2].x1.B[total_len_X86[j]];\n    for (z = 0; z < saved_key_len[j]; ++z)\n    {\n      *(cp++) = *(cpi++);\n      *(cp++) = 0;\n    }\n\n    total_len_X86[j] += saved_key_len[j] << 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  memcpy(&input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]], saved_key[j], saved_key_len[j]);\n  total_len_X86[j] += saved_key_len[j];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  saved_key[j][saved_key_len[j]] = 0;\n  strncpy(&input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]], saved_key[j], 17);\n  total_len_X86[j] += 16;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  saved_key[j][saved_key_len[j]] = 0;\n  strncpy(&input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]], saved_key[j], 21);\n  total_len_X86[j] += 20;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi;\n  UTF16 utf16Str[((((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125)) + 1];\n  int outlen;\n  if (utf16 == 1)\n    outlen = enc_to_utf16(utf16Str, (((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125), (unsigned char *) saved_key[j], saved_key_len[j]) * (sizeof(UTF16));\n  else\n    outlen = enc_to_utf16_be(utf16Str, (((124 > 124) ? (124) : (124)) > 125) ? ((124 > 124) ? (124) : (124)) : (125), (unsigned char *) saved_key[j], saved_key_len[j]) * (sizeof(UTF16));\n\n  if (outlen <= 0)\n  {\n    saved_key_len[j] = (-outlen) / (sizeof(UTF16));\n    if (outlen < 0)\n      outlen = strlen16(utf16Str) * (sizeof(UTF16));\n\n  }\n\n  if ((total_len_X86[j] + outlen) <= (256 - 17))\n  {\n    cp = &input_buf2_X86[j >> MD5_X2].x1.B[total_len2_X86[j]];\n    for (cpi = (unsigned char *) utf16Str, z = 0; z < outlen; ++z)\n      *(cp++) = *(cpi++);\n\n    total_len2_X86[j] += outlen;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned int z;\n  unsigned char *cp;\n  unsigned char *cpi = (unsigned char *) saved_key[j];\n  if ((total_len2_X86[j] + (saved_key_len[j] << 1)) <= (256 - 17))\n  {\n    cp = &input_buf2_X86[j >> MD5_X2].x1.B[total_len2_X86[j]];\n    for (z = 0; z < saved_key_len[j]; ++z)\n    {\n      *(cp++) = *(cpi++);\n      *(cp++) = 0;\n    }\n\n    total_len2_X86[j] += saved_key_len[j] << 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  memcpy(&input_buf2_X86[j >> MD5_X2].x1.b[total_len2_X86[j]], saved_key[j], saved_key_len[j]);\n  total_len2_X86[j] += saved_key_len[j];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  {\n    while (total_len_X86[j] < 16)\n      input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]++] = 0;\n\n  }\n  total_len_X86[j] = 16;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  {\n    while (total_len2_X86[j] < 16)\n      input_buf2_X86[j >> MD5_X2].x1.b[total_len2_X86[j]++] = 0;\n\n  }\n  total_len2_X86[j] = 16;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  {\n    while (total_len_X86[j] < 20)\n      input_buf_X86[j >> MD5_X2].x1.b[total_len_X86[j]++] = 0;\n\n  }\n  total_len_X86[j] = 20;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  {\n    while (total_len2_X86[j] < 20)\n      input_buf2_X86[j >> MD5_X2].x1.b[total_len2_X86[j]++] = 0;\n\n  }\n  total_len2_X86[j] = 20;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 32;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  total_len_X86[j] = 32;\n  {\n    memset(&input_buf_X86[j >> MD5_X2].x1.B[32], 0, 24);\n  }\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 32;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  total_len2_X86[j] = 32;\n  {\n    memset(&input_buf2_X86[j >> MD5_X2].x1.B[32], 0, 24);\n  }\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 40;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 40;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  total_len2_X86[j] = 40;\n  {\n    memset(&input_buf2_X86[j >> MD5_X2].x1.B[40], 0, 16);\n  }\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 64;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 64;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n{\n  unsigned char *cp;\n  cp = &input_buf_X86[j >> MD5_X2].x1.B[total_len_X86[j]];\n  while (*cp)\n    *(cp++) = 0;\n\n  total_len_X86[j] = 100;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 24;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 28;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 48;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 56;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 80;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 96;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 112;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 128;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 160;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 192;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len_X86[j] = 256;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 24;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 28;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 48;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 56;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 80;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 96;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 112;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 128;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 160;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 192;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; j < til; ++j)\n  total_len2_X86[j] = 256;\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < til; ++i)\n{\n  memcpy(&input_buf_X86[i >> MD5_X2].x1.b[total_len_X86[i]], input_buf2_X86[i >> MD5_X2].x1.b, total_len2_X86[i]);\n  total_len_X86[i] += total_len2_X86[i];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < til; ++i)\n{\n  memcpy(&input_buf2_X86[i >> MD5_X2].x1.b[total_len2_X86[i]], input_buf_X86[i >> MD5_X2].x1.b, total_len_X86[i]);\n  total_len2_X86[i] += total_len_X86[i];\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < til; ++i)\n{\n  memcpy(&input_buf_X86[i >> MD5_X2].x1.b[total_len_X86[i]], input_buf_X86[i >> MD5_X2].x1.b, total_len_X86[i]);\n  total_len_X86[i] <<= 1;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < til; ++i)\n{\n  memcpy(&input_buf2_X86[i >> MD5_X2].x1.b[total_len2_X86[i]], input_buf2_X86[i >> MD5_X2].x1.b, total_len2_X86[i]);\n  total_len2_X86[i] <<= 1;\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1; j++)\n{\n  p = input_buf[i + j].w;\n  for (k = 0; k < SIMD_COEF_32; k++)\n    p[(14 * SIMD_COEF_32) + k] = total_len[i + j][k] << 3;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1; j++)\n{\n  p = input_buf2[i + j].w;\n  for (k = 0; k < SIMD_COEF_32; k++)\n    p[(14 * SIMD_COEF_32) + k] = total_len2[i + j][k] << 3;\n\n}\n\n", "pragma": "omp parallel for shared(curdat, inc, m_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  int j;\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, cur_salt->salt, 8);\n  jtr_sha512_update(&ctx, saved_key[index], strlen(saved_key[index]));\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n  for (j = 1; j <= 65536; j++)\n  {\n    jtr_sha512_ctx ctx;\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, (unsigned char *) crypt_out[index], 64);\n    jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 8))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  if (cur_salt->algo_type == 2)\n  {\n    memcpy(&ctx, &cur_salt->prep_salt, sizeof(MD5_CTX));\n    john_MD5_Update(&ctx, saved_key[index], saved_len[index]);\n    if (saved_len[index] < 16)\n    {\n      john_MD5_Update(&ctx, zeropad, 16 - saved_len[index]);\n    }\n\n    if (cur_salt->have_extra_salt)\n    {\n      john_MD5_Update(&ctx, cur_salt->extra_salt, cur_salt->extra_salt_length);\n    }\n\n    john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n  else\n  {\n    libcperciva_HMAC_SHA256_CTX hctx[1];\n    unsigned char output[32];\n    unsigned char buffer[((1 + 81) + 45) + 1] = {0};\n    buffer[0] = '\\n';\n    memcpy(buffer + 1, saved_key[index], saved_len[index]);\n    memcpy((buffer + 1) + saved_len[index], cur_salt->ip, cur_salt->ip_length);\n    libcperciva_HMAC_SHA256_Init(hctx, buffer, (1 + saved_len[index]) + cur_salt->ip_length);\n    libcperciva_HMAC_SHA256_Update(hctx, cur_salt->salt, cur_salt->length);\n    libcperciva_HMAC_SHA256_Final(output, hctx);\n    memcpy((unsigned char *) crypt_out[index], output, 16);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.extra_salt_length; i++)\n  cs.extra_salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, 20, 1000, master[0], 24, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    if (kcdecrypt(master[i], cur_salt->iv, cur_salt->ct) == 0)\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int kcdecrypt(unsigned char *key, unsigned char *iv, unsigned char *data)\n{\n  unsigned char out[48];\n  DES_cblock key1;\n  DES_cblock key2;\n  DES_cblock key3;\n  DES_cblock ivec;\n  DES_key_schedule ks1;\n  DES_key_schedule ks2;\n  DES_key_schedule ks3;\n  memset(out, 0, sizeof(out));\n  memcpy(key1, key, 8);\n  memcpy(key2, key + 8, 8);\n  memcpy(key3, key + 16, 8);\n  DES_set_key_unchecked((DES_cblock *) key1, &ks1);\n  DES_set_key_unchecked((DES_cblock *) key2, &ks2);\n  DES_set_key_unchecked((DES_cblock *) key3, &ks3);\n  memcpy(ivec, iv, 8);\n  DES_ede3_cbc_encrypt(data, out, 48, &ks1, &ks2, &ks3, &ivec, 0);\n  if ((out[47] != 4) || (check_pkcs_pad(out, 48, 8) < 0))\n    return -1;\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += batch_size)\n{\n  unsigned char master[1][32];\n  unsigned char output[24];\n  unsigned char *iv_in;\n  unsigned char iv_out[16];\n  int size;\n  int i;\n  AES_KEY akey;\n  if (cur_salt->version == 5)\n  {\n    for (i = 0; i < batch_size; ++i)\n      pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 16, cur_salt->iterations, master[i], 32, 0);\n\n  }\n  else\n  {\n    for (i = 0; i < batch_size; ++i)\n      pbkdf2_sha512((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 16, cur_salt->iterations, master[i], 32, 0);\n\n  }\n\n  for (i = 0; i < batch_size; ++i)\n  {\n    size = page_sz - reserve_sz;\n    iv_in = (cur_salt->data + 16) + size;\n    memcpy(iv_out, iv_in, 16);\n    JTR_AES_set_decrypt_key(master[i], 256, &akey);\n    JTR_AES_cbc_encrypt(cur_salt->data + 16, output + 16, 8, &akey, iv_out, 0);\n    if (enpass_verify_page(output) == 0)\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int enpass_verify_page(unsigned char *page1)\n{\n  uint32_t pageSize;\n  uint32_t usableSize;\n  if (page1[19] > 2)\n  {\n    return -1;\n  }\n\n  if (memcmp(&page1[21], \"\\100\\040\\040\", 3) != 0)\n  {\n    return -1;\n  }\n\n  pageSize = (page1[16] << 8) | (page1[17] << 16);\n  if (((((pageSize - 1) & pageSize) != 0) || (pageSize > 65536)) || (pageSize <= 256))\n  {\n    return -1;\n  }\n\n  if ((pageSize & 7) != 0)\n  {\n    return -1;\n  }\n\n  usableSize = pageSize - page1[20];\n  if (usableSize < 480)\n  {\n    return -1;\n  }\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char passwordBuf[(32 * 2) + 2];\n  int len;\n  len = enc_to_utf16((UTF16 *) passwordBuf, 32, (UTF8 *) saved_key[index], strlen(saved_key[index]));\n  if (len < 0)\n    len = strlen16((UTF16 *) passwordBuf);\n\n  len <<= 1;\n  if (cur_salt->version == 0)\n  {\n    sph_sha1_context ctx;\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, cur_salt->esalt, 16);\n    sph_sha1(&ctx, passwordBuf, len);\n    sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n  }\n  else\n  {\n    jtr_sha256_ctx ctx;\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, cur_salt->esalt, 16);\n    jtr_sha256_update(&ctx, passwordBuf, len);\n    jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  if (cur_salt->type == 0)\n  {\n    for (i = 0; i < 1; ++i)\n      pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  }\n  else\n    if (cur_salt->type == 1)\n  {\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    yescrypt_params_t params = {.N = cur_salt->N, .r = cur_salt->r, .p = cur_salt->p};\n    for (i = 0; i < 1; ++i)\n    {\n      if (yescrypt_kdf(0, &local[t], (const uint8_t *) saved_key[index + i], strlen(saved_key[index + i]), (const uint8_t *) cur_salt->salt, strlen((const char *) cur_salt->salt), &params, master[i], 32))\n      {\n        failed = (errno) ? (errno) : (EINVAL);\n      }\n\n    }\n\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    if (new_keys)\n    {\n      for (i = 0; i < 1; ++i)\n      {\n        pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), (unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), 2000, master[i], 16, 0);\n      }\n\n      for (i = 0; i < 1; ++i)\n      {\n        memcpy(saved_presale[index + i], master[i], 32);\n      }\n\n    }\n    else\n    {\n      for (i = 0; i < 1; ++i)\n        memcpy(master[i], saved_presale[index + i], 32);\n\n    }\n\n  }\n\n\n\n  if ((cur_salt->type == 0) || (cur_salt->type == 1))\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      Keccak_HashInstance hash;\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, master[i] + 16, 16 * 8);\n      Keccak_HashUpdate(&hash, cur_salt->ct, cur_salt->ctlen * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      AES_KEY akey;\n      Keccak_HashInstance hash;\n      unsigned char iv[16];\n      unsigned char seed[4096];\n      int padbyte;\n      int datalen;\n      JTR_AES_set_decrypt_key(master[i], 128, &akey);\n      memcpy(iv, cur_salt->encseed, 16);\n      JTR_AES_cbc_encrypt(cur_salt->encseed + 16, seed, cur_salt->eslen - 16, &akey, iv, 0);\n      if (check_pkcs_pad(seed, cur_salt->eslen - 16, 16) < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      padbyte = seed[(cur_salt->eslen - 16) - 1];\n      datalen = (cur_salt->eslen - 16) - padbyte;\n      if (datalen < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, seed, datalen * 8);\n      Keccak_HashUpdate(&hash, dpad.data, 1 * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_free_local(&local[i]);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], outlen, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    cracked[index + i] = fvde_decrypt(cur_salt, master[i]);\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int fvde_decrypt(fvde_custom_salt *cur_salt, unsigned char *key)\n{\n  uint64_t *C = cur_salt->blob.qword;\n  int n = (40 / 8) - 1;\n  uint64_t R[5];\n  union \n  {\n    uint64_t qword[2];\n    unsigned char stream[16];\n  } todecrypt;\n  int i;\n  int j;\n  AES_KEY akey;\n  uint64_t A = C[0];\n  if (cur_salt->type == 1)\n  {\n    JTR_AES_set_decrypt_key(key, 128, &akey);\n    n = 2;\n  }\n  else\n  {\n    JTR_AES_set_decrypt_key(key, 256, &akey);\n  }\n\n  for (i = 0; i < (n + 1); i++)\n    R[i] = C[i];\n\n  for (j = 5; j >= 0; j--)\n  {\n    for (i = n; i >= 1; i--)\n    {\n      todecrypt.qword[0] = A ^ ((n * j) + i);\n      todecrypt.qword[1] = R[i];\n      (0 == 1) ? (JTR_AES_encrypt(todecrypt.stream, todecrypt.stream, &akey)) : (JTR_AES_decrypt(todecrypt.stream, todecrypt.stream, &akey));\n      A = todecrypt.qword[0];\n      R[i] = todecrypt.qword[1];\n    }\n\n  }\n\n  if (A == 0xa6a6a6a6a6a6a6a6ULL)\n    return 1;\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (n + 1); i++)\n  R[i] = C[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 5; j >= 0; j--)\n{\n  for (i = n; i >= 1; i--)\n  {\n    todecrypt.qword[0] = A ^ ((n * j) + i);\n    todecrypt.qword[1] = R[i];\n    (0 == 1) ? (JTR_AES_encrypt(todecrypt.stream, todecrypt.stream, &akey)) : (JTR_AES_decrypt(todecrypt.stream, todecrypt.stream, &akey));\n    A = todecrypt.qword[0];\n    R[i] = todecrypt.qword[1];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][64];\n  unsigned char key[1][64];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha512((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->md_salt, 64, cur_salt->md_iterations, master[i], 64, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    JTR_hmac_sha512((const unsigned char *) \"\", 0, master[i], 64, key[i], 64);\n    cracked[index + i] = geli_decrypt_verify(cur_salt, key[i]);\n  }\n\n}\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  gost_ctx ctx;\n  if (is_cryptopro)\n    john_gost_cryptopro_init(&ctx);\n  else\n    john_gost_init(&ctx);\n\n  john_gost_update(&ctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n  john_gost_final(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (crypt_out[index][0] == (*((uint32_t *) binary)))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  has160_ctx ctx;\n  rhash_has160_init(&ctx);\n  rhash_has160_update(&ctx, (unsigned char *) saved_key[index], saved_len[index]);\n  rhash_has160_final(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_haval256_3_context ctx;\n  sph_haval256_3_init(&ctx);\n  sph_haval256_3(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_haval256_3_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_haval128_4_context ctx;\n  sph_haval128_4_init(&ctx);\n  sph_haval128_4(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_haval128_4_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  sph_sha1_context ctx;\n  if (new_keys)\n  {\n    sph_sha1_init(&ipad_ctx[index]);\n    sph_sha1(&ipad_ctx[index], ipad[index], 64);\n    sph_sha1_init(&opad_ctx[index]);\n    sph_sha1(&opad_ctx[index], opad[index], 64);\n  }\n\n  memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n  sph_sha1(&ctx, cur_salt, strlen((char *) cur_salt));\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n  memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n  sph_sha1(&ctx, crypt_key[index], 20);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pos; i < ((20 * 2) + pos); i++)\n{\n  if (!(((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha256_ctx ctx;\n  if (B_LEN == (256 / 8))\n  {\n    if (new_keys)\n    {\n      jtr_sha256_init(&ipad_ctx[index], 1);\n      jtr_sha256_update(&ipad_ctx[index], ipad[index], 64);\n      jtr_sha256_init(&opad_ctx[index], 1);\n      jtr_sha256_update(&opad_ctx[index], opad[index], 64);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    jtr_sha256_update(&ctx, cur_salt, strlen((char *) cur_salt));\n    jtr_sha256_final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    jtr_sha256_update(&ctx, crypt_key[index], B_LEN);\n    jtr_sha256_final((unsigned char *) crypt_key[index], &ctx);\n  }\n  else\n  {\n    if (new_keys)\n    {\n      jtr_sha256_init(&ipad_ctx[index], 0);\n      jtr_sha256_update(&ipad_ctx[index], ipad[index], 64);\n      jtr_sha256_init(&opad_ctx[index], 0);\n      jtr_sha256_update(&opad_ctx[index], opad[index], 64);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    jtr_sha256_update(&ctx, cur_salt, strlen((char *) cur_salt));\n    jtr_sha256_final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    jtr_sha256_update(&ctx, crypt_key[index], B_LEN);\n    jtr_sha256_final((unsigned char *) crypt_key[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pos; i < ((B_LEN * 2) + pos); i++)\n{\n  if (!(((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen(ciphertext); ciphertext[i] != '#'; i--)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < B_LEN; i++)\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[(i * 2) + pos])] * 16) + atoi16[ARCH_INDEX(ciphertext[((i * 2) + 1) + pos])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  if (B_LEN == (512 / 8))\n  {\n    if (new_keys)\n    {\n      jtr_sha512_init(&ipad_ctx[index], 1);\n      jtr_sha512_update(&ipad_ctx[index], ipad[index], 128);\n      jtr_sha512_init(&opad_ctx[index], 1);\n      jtr_sha512_update(&opad_ctx[index], opad[index], 128);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    jtr_sha512_update(&ctx, cur_salt, strlen((char *) cur_salt));\n    jtr_sha512_final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    jtr_sha512_update(&ctx, crypt_key[index], B_LEN);\n    jtr_sha512_final((unsigned char *) crypt_key[index], &ctx);\n  }\n  else\n  {\n    if (new_keys)\n    {\n      jtr_sha512_init(&ipad_ctx[index], 0);\n      jtr_sha512_update(&ipad_ctx[index], ipad[index], 128);\n      jtr_sha512_init(&opad_ctx[index], 0);\n      jtr_sha512_update(&opad_ctx[index], opad[index], 128);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    jtr_sha512_update(&ctx, cur_salt, strlen((char *) cur_salt));\n    jtr_sha512_final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    jtr_sha512_update(&ctx, crypt_key[index], B_LEN);\n    jtr_sha512_final((unsigned char *) crypt_key[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pos; i < ((B_LEN * 2) + pos); i++)\n{\n  if (!(((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen(ciphertext); ciphertext[i] != '#'; i--)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < B_LEN; i++)\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[(i * 2) + pos])] * 16) + atoi16[ARCH_INDEX(ciphertext[((i * 2) + 1) + pos])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  int len = saved_len[index];\n  if (dirty)\n  {\n    unsigned int *block = (unsigned int *) saved_key[index];\n    john_MD5_Init(&saved_ctx[index]);\n    saved_key[index][len] = 0x80;\n    block[14] = len << 3;\n    block[14] = __builtin_bswap32(block[14]);\n    john_MD5_Update(&saved_ctx[index], (unsigned char *) block, 64);\n    saved_key[index][len] = 0;\n  }\n\n  memcpy(&ctx, &saved_ctx[index], sizeof(MD5_CTX));\n  john_MD5_Update(&ctx, cur_salt->salt, cur_salt->length);\n  john_MD5_Update(&ctx, saved_key[index], len);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  compute_hash(cur_salt, saved_key[index], (unsigned char *) crypt_out[index]);\n}\n\ninline static void compute_hash(const psk_entry *psk_params, char *password, unsigned char *hash_r)\n{\n  size_t password_len = strlen(password);\n  unsigned char skeyid[20];\n  if (psk_params->nortel_user[0] == 0)\n  {\n    if (psk_params->hash_type == 1)\n    {\n      hmac_md5((unsigned char *) psk_params->skeyid_data, psk_params->skeyid_data_len, (unsigned char *) password, password_len, skeyid);\n    }\n    else\n    {\n      hmac_sha1(psk_params->skeyid_data, psk_params->skeyid_data_len, (unsigned char *) password, password_len, skeyid);\n    }\n\n  }\n  else\n  {\n    unsigned char nortel_psk[20];\n    unsigned char nortel_pwd_hash[20];\n    sph_sha1_context ctx;\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, password, password_len);\n    sph_sha1_close(&ctx, nortel_pwd_hash);\n    hmac_sha1((unsigned char *) psk_params->nortel_user, strlen(psk_params->nortel_user), nortel_pwd_hash, 20, nortel_psk);\n    if (psk_params->hash_type == 1)\n    {\n      hmac_md5((unsigned char *) psk_params->skeyid_data, psk_params->skeyid_data_len, nortel_psk, 20, skeyid);\n    }\n    else\n    {\n      hmac_sha1(psk_params->skeyid_data, psk_params->skeyid_data_len, nortel_psk, 20, skeyid);\n    }\n\n  }\n\n  if (psk_params->hash_type == 1)\n  {\n    hmac_md5((unsigned char *) psk_params->hash_r_data, psk_params->hash_r_data_len, skeyid, psk_params->hash_r_len, hash_r);\n  }\n  else\n  {\n    hmac_sha1(psk_params->hash_r_data, psk_params->hash_r_data_len, skeyid, psk_params->hash_r_len, hash_r);\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  if (cur_salt->version == 9)\n  {\n    for (i = 0; i < 1; ++i)\n      pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 20, cur_salt->iterations, master[i], 32, 0);\n\n    for (i = 0; i < 1; ++i)\n    {\n      cracked[index + i] = itunes_common_decrypt(cur_salt, master[i]);\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->dpsl, 20, cur_salt->dpic, master[i], 32, 0);\n      pbkdf2_sha1(master[i], 32, cur_salt->salt, 20, cur_salt->iterations, master[i], 32, 0);\n    }\n\n    for (i = 0; i < 1; ++i)\n    {\n      cracked[index + i] = itunes_common_decrypt(cur_salt, master[i]);\n    }\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][16];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), fctx->salt, fctx->salt_length, fctx->iterations, master[i], 16, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    cracked[index + i] = iwork_decrypt(fctx, master[i], fctx->iv, fctx->blob);\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int iwork_decrypt(struct format_context *fctx, unsigned char *key, unsigned char *iv, unsigned char *data)\n{\n  unsigned char out[64];\n  unsigned char ivec[16];\n  uint8_t hash[32];\n  jtr_sha256_ctx ctx;\n  AES_KEY aes_decrypt_key;\n  JTR_AES_set_decrypt_key(key, 128, &aes_decrypt_key);\n  memcpy(ivec, iv, 16);\n  JTR_AES_cbc_encrypt(fctx->blob, out, 64, &aes_decrypt_key, ivec, 0);\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, out, 32);\n  jtr_sha256_final(hash, &ctx);\n  return memcmp(hash, &out[32], 32) == 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char key[32];\n  unsigned char i;\n  AES_KEY aeskey;\n  int key_size;\n  if ((cur_salt->etype == 18) || (cur_salt->etype == 17))\n  {\n    if (cur_salt->etype == 18)\n    {\n      key_size = 32;\n    }\n    else\n    {\n      key_size = 16;\n    }\n\n    pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), (const unsigned char *) cur_salt->saved_salt, strlen(cur_salt->saved_salt), 4096, key, key_size, 0);\n    i = 0;\n    JTR_AES_set_encrypt_key(key, key_size * 8, &aeskey);\n    JTR_AES_encrypt((unsigned char *) \"kerberos{\\x9b[+\\x93\\x13+\\x93\", (unsigned char *) crypt_out[index + i], &aeskey);\n    JTR_AES_encrypt((unsigned char *) crypt_out[index + i], (unsigned char *) (&crypt_out[index + i][4]), &aeskey);\n  }\n  else\n    if (cur_salt->etype == 3)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      des_string_to_key_shishi(saved_key[index + i], strlen(saved_key[index + i]), cur_salt->saved_salt, strlen(cur_salt->saved_salt), (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < binary_size; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (crypt_out[index][0] == (*((uint32_t *) binary)))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char tkey[1][32];\n  unsigned char base_key[32];\n  unsigned char Ke[32];\n  unsigned char plaintext[44];\n  int i;\n  int len[1];\n  for (i = 0; i < 1; ++i)\n  {\n    len[i] = strlen(saved_key[index + i]);\n  }\n\n  pbkdf2_sha1((const unsigned char *) saved_key[index], len[0], cur_salt->salt, strlen((char *) cur_salt->salt), 4096, tkey[0], key_size, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    dk(base_key, tkey[i], key_size, constant, 16);\n    dk(Ke, base_key, key_size, ke_input, 16);\n    krb_decrypt(cur_salt->ct, 44, plaintext, Ke, key_size);\n    if (((plaintext[22] == '2') && (plaintext[23] == '0')) && (plaintext[36] == 'Z'))\n    {\n      unsigned char Ki[32];\n      unsigned char checksum[20];\n      dk(Ki, base_key, key_size, ki_input, 16);\n      JTR_hmac_sha1(Ki, key_size, plaintext, 44, checksum, 20);\n      memcpy(crypt_out[index + i], checksum, 12);\n    }\n    else\n    {\n      memset(crypt_out[index + i], 0, 12);\n    }\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 44; i++)\n  cs.ct[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 12; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < tot_todo; index += 1)\n{\n  sph_sha1_context ctx;\n  if (dirty)\n    getPreKeyedHash(MixOrder[index]);\n\n  if (saved_len[MixOrder[index]] == 0)\n    memcpy(crypt_out[MixOrder[index]], keystore_cur_salt->data_hash, 20);\n  else\n  {\n    memcpy(&ctx, &saved_ctx[MixOrder[index]], sizeof(ctx));\n    sph_sha1(&ctx, keystore_cur_salt->data, keystore_cur_salt->data_length);\n    sph_sha1_close(&ctx, (unsigned char *) crypt_out[MixOrder[index]]);\n  }\n\n}\n\ninline static void getPreKeyedHash(int idx)\n{\n  int i;\n  int j;\n  unsigned char passwdBytes[125 * 2];\n  const char *magic = \"Mighty Aphrodite\";\n  char *password = saved_key[idx];\n  sph_sha1_context *ctxp = &saved_ctx[idx];\n  for (i = 0, j = 0; i < strlen(password); i++)\n  {\n    passwdBytes[j++] = 0;\n    passwdBytes[j++] = password[i];\n  }\n\n  sph_sha1_init(ctxp);\n  sph_sha1(ctxp, passwdBytes, saved_len[idx] * 2);\n  sph_sha1(ctxp, magic, 16);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, j = 0; i < strlen(password); i++)\n{\n  passwdBytes[j++] = 0;\n  passwdBytes[j++] = password[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.data_length; i++)\n{\n  cs.data[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.keysize; i++)\n  cs.keydata[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; ++index)\n  MixOrder[index] = index;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char key[1][56];\n  int key_size[1];\n  int i;\n  if (cur_salt->kwallet_minor_version == 0)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      password2hash(saved_key[index + i], key[i], &key_size[i]);\n      cracked[index + i] = !verify_key(key[i], key_size[i]);\n    }\n\n  }\n  else\n    if (cur_salt->kwallet_minor_version == 1)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      pbkdf2_sha512((const unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, key[i], 56, 0);\n    }\n\n    for (i = 0; i < 1; ++i)\n      cracked[index + i] = !verify_key(key[i], 56);\n\n  }\n\n\n}\n\nstatic void password2hash(const char *password, unsigned char *hash, int *key_size)\n{\n  sph_sha1_context ctx;\n  unsigned char output[20 * ((125 + 15) / 16)];\n  unsigned char buf[20];\n  int i;\n  int j;\n  int oindex = 0;\n  int plength = strlen(password);\n  for (i = 0; i <= plength; i += 16)\n  {\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, password + i, ((plength - i) < 16) ? (plength - i) : (16));\n    for (j = 0; j < 2000; j++)\n    {\n      sph_sha1_close(&ctx, buf);\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, buf, 20);\n    }\n\n    memcpy(output + oindex, buf, 20);\n    oindex += 20;\n  }\n\n  if (plength < 16)\n  {\n    memcpy(hash, output, 20);\n    *key_size = 20;\n  }\n  else\n    if (plength < 32)\n  {\n    memcpy(hash, output, 40);\n    *key_size = 40;\n  }\n  else\n    if (plength < 48)\n  {\n    memcpy(hash, output, 56);\n    *key_size = 56;\n  }\n  else\n  {\n    memcpy(hash + (14 * 0), output + 0, 14);\n    memcpy(hash + (14 * 1), output + 20, 14);\n    memcpy(hash + (14 * 2), output + 40, 14);\n    *key_size = 56;\n  }\n\n\n\n}\n\n\nstatic int verify_key(unsigned char *key, int key_size)\n{\n  sph_sha1_context ctx;\n  BF_KEY bf_key;\n  int sz;\n  int i;\n  unsigned char testhash[20];\n  unsigned char buffer[0x10000];\n  const char *t;\n  size_t fsize;\n  memcpy(buffer, cur_salt->ct, cur_salt->ctlen);\n  alter_endianity(buffer, cur_salt->ctlen);\n  if (cur_salt->kwallet_minor_version == 0)\n  {\n    BF_set_key(&bf_key, key_size, key);\n    for (i = 0; i < cur_salt->ctlen; i += 8)\n    {\n      BF_ecb_encrypt(buffer + i, buffer + i, &bf_key, 0);\n    }\n\n  }\n  else\n    if (cur_salt->kwallet_minor_version == 1)\n  {\n    unsigned char ivec[8] = {0};\n    key_size = 56;\n    BF_set_key(&bf_key, key_size, key);\n    BF_cbc_encrypt(buffer, buffer, cur_salt->ctlen, &bf_key, ivec, 0);\n  }\n\n\n  alter_endianity(buffer, cur_salt->ctlen);\n  t = (char *) buffer;\n  t += 8;\n  fsize = 0;\n  fsize |= (((size_t) (*t)) << 24) & 0xff000000;\n  t++;\n  fsize |= (((size_t) (*t)) << 16) & 0x00ff0000;\n  t++;\n  fsize |= (((size_t) (*t)) << 8) & 0x0000ff00;\n  t++;\n  fsize |= ((size_t) (*t)) & 0x000000ff;\n  t++;\n  if (fsize > ((((size_t) cur_salt->ctlen) - 8) - 4))\n  {\n    return -1;\n  }\n\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, t, fsize);\n  sph_sha1_close(&ctx, testhash);\n  sz = cur_salt->ctlen;\n  for (i = 0; i < 20; i++)\n  {\n    if (testhash[i] != buffer[(sz - 20) + i])\n    {\n      return -2;\n    }\n\n  }\n\n  return 0;\n}\n\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int verify_key(unsigned char *key, int key_size)\n{\n  sph_sha1_context ctx;\n  BF_KEY bf_key;\n  int sz;\n  int i;\n  unsigned char testhash[20];\n  unsigned char buffer[0x10000];\n  const char *t;\n  size_t fsize;\n  memcpy(buffer, cur_salt->ct, cur_salt->ctlen);\n  alter_endianity(buffer, cur_salt->ctlen);\n  if (cur_salt->kwallet_minor_version == 0)\n  {\n    BF_set_key(&bf_key, key_size, key);\n    for (i = 0; i < cur_salt->ctlen; i += 8)\n    {\n      BF_ecb_encrypt(buffer + i, buffer + i, &bf_key, 0);\n    }\n\n  }\n  else\n    if (cur_salt->kwallet_minor_version == 1)\n  {\n    unsigned char ivec[8] = {0};\n    key_size = 56;\n    BF_set_key(&bf_key, key_size, key);\n    BF_cbc_encrypt(buffer, buffer, cur_salt->ctlen, &bf_key, ivec, 0);\n  }\n\n\n  alter_endianity(buffer, cur_salt->ctlen);\n  t = (char *) buffer;\n  t += 8;\n  fsize = 0;\n  fsize |= (((size_t) (*t)) << 24) & 0xff000000;\n  t++;\n  fsize |= (((size_t) (*t)) << 16) & 0x00ff0000;\n  t++;\n  fsize |= (((size_t) (*t)) << 8) & 0x0000ff00;\n  t++;\n  fsize |= ((size_t) (*t)) & 0x000000ff;\n  t++;\n  if (fsize > ((((size_t) cur_salt->ctlen) - 8) - 4))\n  {\n    return -1;\n  }\n\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, t, fsize);\n  sph_sha1_close(&ctx, testhash);\n  sz = cur_salt->ctlen;\n  for (i = 0; i < 20; i++)\n  {\n    if (testhash[i] != buffer[(sz - 20) + i])\n    {\n      return -2;\n    }\n\n  }\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->ctlen; i++)\n  salt->ct[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->saltlen; i++)\n  salt->salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= plength; i += 16)\n{\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, password + i, ((plength - i) < 16) ? (plength - i) : (16));\n  for (j = 0; j < 2000; j++)\n  {\n    sph_sha1_close(&ctx, buf);\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, buf, 20);\n  }\n\n  memcpy(output + oindex, buf, 20);\n  oindex += 20;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cur_salt->ctlen; i += 8)\n{\n  BF_ecb_encrypt(buffer + i, buffer + i, &bf_key, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (testhash[i] != buffer[(sz - 20) + i])\n  {\n    return -2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char user_key[8];\n  unsigned char deciphered_userid[0x64];\n  memset(lotus85_last_binary_hash1[index], 0, 5);\n  memset(lotus85_last_binary_hash2[index], 0, 5);\n  memset(user_key, 0, sizeof(user_key));\n  memset(deciphered_userid, 0, sizeof(deciphered_userid));\n  get_user_id_secret_key(lotus85_saved_passwords[index], user_key);\n  decipher_userid_blob(cur_salt->lotus85_user_blob, cur_salt->lotus85_user_blob_len, user_key, deciphered_userid);\n  memcpy(lotus85_last_binary_hash1[index], (deciphered_userid + cur_salt->lotus85_user_blob_len) - 5, 5);\n  compute_msg_mac(deciphered_userid, cur_salt->lotus85_user_blob_len - 5, lotus85_last_binary_hash2[index]);\n}\n\nstatic void get_user_id_secret_key(const char *password, uint8_t *secret_key)\n{\n  uint8_t key[16 + 20];\n  uint8_t mac[8];\n  memset(key, 0, sizeof(key));\n  memset(mac, 0, sizeof(mac));\n  custom_password_hash(password, key);\n  password_hash(password, key + 16);\n  compute_key_mac(key, sizeof(key), mac, sizeof(mac));\n  memcpy(secret_key, mac, sizeof(mac));\n}\n\n\nstatic void decipher_userid_blob(uint8_t *ciphered_blob, uint32_t len, uint8_t *userid_key, uint8_t *deciphered_blob)\n{\n  RC2_KEY rc_key;\n  uint8_t buf[0x64 + 8];\n  uint8_t rc_iv[8];\n  memset(buf, 0x0, sizeof(buf));\n  memset(rc_iv, 0, sizeof(rc_iv));\n  RC2_set_key(&rc_key, 8, userid_key, 64);\n  RC2_cbc_encrypt(ciphered_blob, buf, len, &rc_key, rc_iv, 0);\n  memcpy(deciphered_blob, buf, len);\n}\n\n\nstatic void compute_msg_mac(uint8_t *msg, size_t len, uint8_t *msg_mac)\n{\n  size_t i;\n  size_t j;\n  uint8_t c;\n  for (i = (j = 0); i < len; i++)\n  {\n    if (j != 4)\n    {\n      msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[j + 1]];\n      j++;\n    }\n    else\n    {\n      msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[0]];\n      j = 0;\n    }\n\n  }\n\n  c = msg_mac[0];\n  for (i = 0; i < 4; i++)\n  {\n    msg_mac[i] = msg_mac[i + 1];\n  }\n\n  msg_mac[i] = c;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i += 4)\n{\n  buffer[32 + i] = data[i] ^ state[i];\n  buffer[(32 + i) + 1] = data[i + 1] ^ state[i + 1];\n  buffer[(32 + i) + 2] = data[i + 2] ^ state[i + 2];\n  buffer[(32 + i) + 3] = data[i + 3] ^ state[i + 3];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = (c = 0); j < 18; j++)\n{\n  for (i = 0; i < (sizeof(buffer)); i += 6)\n  {\n    buffer[i] ^= ebits_to_num[((c - i) + 48) & 0xFF];\n    buffer[i + 1] ^= ebits_to_num[((buffer[i] - i) + 47) & 0xFF];\n    buffer[i + 2] ^= ebits_to_num[((buffer[i + 1] - i) + 46) & 0xFF];\n    buffer[i + 3] ^= ebits_to_num[((buffer[i + 2] - i) + 45) & 0xFF];\n    buffer[i + 4] ^= ebits_to_num[((buffer[i + 3] - i) + 44) & 0xFF];\n    buffer[i + 5] ^= ebits_to_num[((buffer[i + 4] - i) + 43) & 0xFF];\n    c = buffer[i + 5];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i += 4)\n{\n  out[i] ^= ebits_to_num[data[i] ^ c];\n  out[i + 1] ^= ebits_to_num[data[i + 1] ^ out[i]];\n  out[i + 2] ^= ebits_to_num[data[i + 2] ^ out[i + 1]];\n  out[i + 3] ^= ebits_to_num[data[i + 3] ^ out[i + 2]];\n  c = out[i + 3];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  k = ebits_to_num[mac[0] ^ mac[1]];\n  for (j = 0; j < mlen; j++)\n  {\n    mac[j] = mac[j + 1];\n  }\n\n  mac[mlen] = key[i] ^ k;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = (j = 0); i < len; i++)\n{\n  if (j != 4)\n  {\n    msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[j + 1]];\n    j++;\n  }\n  else\n  {\n    msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[0]];\n    j = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  msg_mac[i] = msg_mac[i + 1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs.lotus85_user_blob[i] = (atoi16[ARCH_INDEX(ciphertext[i << 1])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i << 1) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  if (!memcmp(lotus85_last_binary_hash1[i], lotus85_last_binary_hash2[i], 5))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  JtR_MDC2_CTX ctx;\n  JtR_MDC2_Init(&ctx);\n  JtR_MDC2_Update(&ctx, (unsigned char *) saved_key[index], saved_len[index]);\n  JtR_MDC2_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  int len;\n  unsigned char K[16];\n  unsigned char K1[16];\n  len = E_md4hash((unsigned char *) saved_plain[i], saved_len[i], K);\n  if (len <= 0)\n    ((char *) saved_plain[i])[-len] = 0;\n\n  hmac_md5(K, (unsigned char *) (&one), 4, K1);\n  hmac_md5_init_K16(K1, &saved_ctx[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char K3[16];\n  unsigned char cleartext[36];\n  HMACMD5Context ctx;\n  memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n  hmac_md5_update((unsigned char *) cur_salt->checksum, 16, &ctx);\n  hmac_md5_final(K3, &ctx);\n  RC4_single(K3, 16, cur_salt->timestamp, 16, cleartext);\n  if ((cleartext[14] == '2') && (cleartext[15] == '0'))\n  {\n    RC4_single(K3, 16, cur_salt->timestamp, 36, cleartext);\n    if (cleartext[28] == 'Z')\n    {\n      memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n      hmac_md5_update(cleartext, 36, &ctx);\n      hmac_md5_final((unsigned char *) output[i], &ctx);\n    }\n\n  }\n  else\n  {\n    output[i][0] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 36; i++)\n{\n  salt.timestamp[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  ((unsigned char *) salt.checksum)[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  binary[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == output[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_sha1_context ctx;\n  sph_sha1_context ctxi;\n  sph_sha1_context ctxo;\n  int i;\n  union \n  {\n    unsigned char uc[64];\n    uint32_t ui[64 / 4];\n  } pad;\n  unsigned char buffer[20];\n  unsigned char tk[20];\n  unsigned char key[40];\n  DES_cblock ivec;\n  DES_key_schedule ks1;\n  DES_key_schedule ks2;\n  DES_key_schedule ks3;\n  memcpy(&ctx, &cur_salt->pctx, sizeof(sph_sha1_context));\n  sph_sha1(&ctx, saved_key[index], saved_len[index]);\n  sph_sha1_close(&ctx, buffer);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, buffer, 20);\n  sph_sha1(&ctx, cur_salt->local_salt, cur_salt->local_salt_length);\n  sph_sha1_close(&ctx, buffer);\n  sph_sha1_init(&ctxi);\n  sph_sha1_init(&ctxo);\n  memset(pad.uc, 0x36, 64);\n  for (i = 0; i < 20; ++i)\n    pad.uc[i] ^= buffer[i];\n\n  sph_sha1(&ctxi, pad.uc, 64);\n  for (i = 0; i < (64 / 4); ++i)\n    pad.ui[i] ^= 0x36363636 ^ 0x5c5c5c5c;\n\n  sph_sha1(&ctxo, pad.uc, 64);\n  memcpy(&ctx, &ctxi, sizeof(ctx));\n  sph_sha1(&ctx, cur_salt->local_salt, 20);\n  sph_sha1(&ctx, cur_salt->local_salt, cur_salt->local_salt_length);\n  sph_sha1_close(&ctx, buffer);\n  memcpy(&ctx, &ctxo, sizeof(ctx));\n  sph_sha1(&ctx, buffer, 20);\n  sph_sha1_close(&ctx, key);\n  memcpy(&ctx, &ctxi, sizeof(ctx));\n  sph_sha1(&ctx, cur_salt->local_salt, 20);\n  sph_sha1_close(&ctx, buffer);\n  memcpy(&ctx, &ctxo, sizeof(ctx));\n  sph_sha1(&ctx, buffer, 20);\n  sph_sha1_close(&ctx, tk);\n  sph_sha1(&ctxi, tk, 20);\n  sph_sha1(&ctxi, cur_salt->local_salt, cur_salt->local_salt_length);\n  sph_sha1_close(&ctxi, buffer);\n  sph_sha1(&ctxo, buffer, 20);\n  sph_sha1_close(&ctxo, key + 20);\n  DES_set_key_unchecked((DES_cblock *) key, &ks1);\n  DES_set_key_unchecked((DES_cblock *) (key + 8), &ks2);\n  DES_set_key_unchecked((DES_cblock *) (key + 16), &ks3);\n  memcpy(ivec, key + 32, 8);\n  DES_ede3_cbc_encrypt((unsigned char *) \"password-check\\x02\\x02\", (unsigned char *) crypt_out[index], 16, &ks1, &ks2, &ks3, &ivec, 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.local_salt_length; i++)\n  cs.local_salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.global_salt_length; i++)\n  cs.global_salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  uint32_t key[1][8];\n  int i;\n  if (cur_salt->iterations != 1)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      pbkdf2_sha256((unsigned char *) saved_key[i + index], strlen(saved_key[i + index]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, (unsigned char *) key[i], 32, 0);\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      jtr_sha256_ctx ctx;\n      jtr_sha256_init(&ctx, 1);\n      jtr_sha256_update(&ctx, cur_salt->salt, cur_salt->salt_length);\n      jtr_sha256_update(&ctx, saved_key[i + index], strlen(saved_key[i + index]));\n      jtr_sha256_final((unsigned char *) key[i], &ctx);\n    }\n\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    unsigned char iv[16];\n    AES_KEY akey;\n    memcpy(iv, cur_salt->iv, 16);\n    JTR_AES_set_encrypt_key((unsigned char *) key[i], 256, &akey);\n    JTR_AES_cbc_encrypt((const unsigned char *) \"`lpass` was written by LastPass.\\n\", (unsigned char *) crypt_out[i + index], 16, &akey, iv, 1);\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  uint32_t key[1][8];\n  int i;\n  for (i = 0; i < 1; ++i)\n  {\n    pbkdf2_sha256((unsigned char *) saved_key[i + index], strlen(saved_key[i + index]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, (unsigned char *) key[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    AES_KEY akey;\n    JTR_AES_set_encrypt_key((unsigned char *) key[i], 256, &akey);\n    (1 == 1) ? (JTR_AES_encrypt((unsigned char *) \"lastpass rocks\\x02\\x02\", (unsigned char *) crypt_out[i + index], &akey)) : (JTR_AES_decrypt((unsigned char *) \"lastpass rocks\\x02\\x02\", (unsigned char *) crypt_out[i + index], &akey));\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  uint32_t key[1][8];\n  unsigned i;\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->username, strlen(cur_salt->username), cur_salt->iterations, (unsigned char *) (&key[0]), 32, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    unsigned char *Key = (unsigned char *) key[i];\n    AES_KEY akey;\n    unsigned char iv[16];\n    unsigned char out[32];\n    JTR_AES_set_encrypt_key(Key, 256, &akey);\n    memset(iv, 0, sizeof(iv));\n    JTR_AES_cbc_encrypt((const unsigned char *) cur_salt->username, out, 32, &akey, iv, 1);\n    memcpy(crypt_key[index + i], out, 16);\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 3)\n{\n  struct \n  {\n    union \n    {\n      unsigned char m[64];\n      unsigned char m4[4][16];\n      long m4w[4][16 / ARCH_SIZE];\n    } u;\n  } ctx[3];\n  int password_length;\n  memset(ctx[0].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index]);\n  memset(ctx[0].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[0].u.m4[1], saved_key[index], password_length);\n  memcpy(ctx[0].u.m4[2], ctx[0].u.m4[1], 16);\n  memset(ctx[1].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index + 1]);\n  memset(ctx[1].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[1].u.m4[1], saved_key[index + 1], password_length);\n  memcpy(ctx[1].u.m4[2], ctx[1].u.m4[1], 16);\n  memset(ctx[2].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index + 2]);\n  memset(ctx[2].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[2].u.m4[1], saved_key[index + 2], password_length);\n  memcpy(ctx[2].u.m4[2], ctx[2].u.m4[1], 16);\n  lotus_transform_password(ctx[0].u.m4[1], ctx[0].u.m4[3], ctx[1].u.m4[1], ctx[1].u.m4[3], ctx[2].u.m4[1], ctx[2].u.m4[3]);\n  lotus_mix(ctx[0].u.m, ctx[1].u.m, ctx[2].u.m);\n  memcpy(ctx[0].u.m4[1], ctx[0].u.m4[3], 16);\n  memcpy(ctx[1].u.m4[1], ctx[1].u.m4[3], 16);\n  memcpy(ctx[2].u.m4[1], ctx[2].u.m4[3], 16);\n  {\n    int i;\n    for (i = 0; i < (16 / ARCH_SIZE); i++)\n    {\n      ctx[0].u.m4w[2][i] = ctx[0].u.m4w[0][i] ^ ctx[0].u.m4w[1][i];\n      ctx[1].u.m4w[2][i] = ctx[1].u.m4w[0][i] ^ ctx[1].u.m4w[1][i];\n      ctx[2].u.m4w[2][i] = ctx[2].u.m4w[0][i] ^ ctx[2].u.m4w[1][i];\n    }\n\n  }\n  lotus_mix(ctx[0].u.m, ctx[1].u.m, ctx[2].u.m);\n  memcpy(crypt_key[index], ctx[0].u.m4[0], 16);\n  memcpy(crypt_key[index + 1], ctx[1].u.m4[0], 16);\n  memcpy(crypt_key[index + 2], ctx[2].u.m4[0], 16);\n}\n\ninline static void lotus_transform_password(unsigned char *i0, unsigned char *o0, unsigned char *i1, unsigned char *o1, unsigned char *i2, unsigned char *o2)\n{\n  unsigned char t0;\n  unsigned char t1;\n  unsigned char t2;\n  int i;\n  t0 = (t1 = (t2 = 0));\n  for (i = 0; i < 8; i++)\n  {\n    t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n    t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n    t2 = (*(o2++) = lotus_magic_table[ARCH_INDEX((*(i2++)) ^ t2)]);\n    t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n    t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n    t2 = (*(o2++) = lotus_magic_table[ARCH_INDEX((*(i2++)) ^ t2)]);\n  }\n\n}\n\n\nstatic void lotus_mix(unsigned char *m0, unsigned char *m1, unsigned char *m2)\n{\n  unsigned char t0;\n  unsigned char t1;\n  unsigned char *p0;\n  unsigned char *p1;\n  unsigned char t2;\n  unsigned char *p2;\n  int i;\n  int j;\n  t0 = (t1 = (t2 = 0));\n  for (i = 18; i > 0; i--)\n  {\n    p0 = m0;\n    p1 = m1;\n    p2 = m2;\n    for (j = 48; j > 0; j--)\n    {\n      t0 = (p0[0] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n      t1 = (p1[0] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n      t2 = (p2[0] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n      j--;\n      t0 = (p0[1] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n      p0 += 2;\n      t1 = (p1[1] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n      p1 += 2;\n      t2 = (p2[1] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n      p2 += 2;\n    }\n\n  }\n\n}\n\n\nstatic void lotus_mix(unsigned char *m0, unsigned char *m1, unsigned char *m2)\n{\n  unsigned char t0;\n  unsigned char t1;\n  unsigned char *p0;\n  unsigned char *p1;\n  unsigned char t2;\n  unsigned char *p2;\n  int i;\n  int j;\n  t0 = (t1 = (t2 = 0));\n  for (i = 18; i > 0; i--)\n  {\n    p0 = m0;\n    p1 = m1;\n    p2 = m2;\n    for (j = 48; j > 0; j--)\n    {\n      t0 = (p0[0] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n      t1 = (p1[0] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n      t2 = (p2[0] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n      j--;\n      t0 = (p0[1] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n      p0 += 2;\n      t1 = (p1[1] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n      p1 += 2;\n      t2 = (p2[1] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n      p2 += 2;\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  if (!(((ciphertext[i] >= '0') && (ciphertext[i] <= '9')) || ((ciphertext[i] >= 'A') && (ciphertext[i] <= 'F'))))\n{\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n  t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n  t2 = (*(o2++) = lotus_magic_table[ARCH_INDEX((*(i2++)) ^ t2)]);\n  t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n  t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n  t2 = (*(o2++) = lotus_magic_table[ARCH_INDEX((*(i2++)) ^ t2)]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 18; i > 0; i--)\n{\n  p0 = m0;\n  p1 = m1;\n  p2 = m2;\n  for (j = 48; j > 0; j--)\n  {\n    t0 = (p0[0] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n    t1 = (p1[0] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n    t2 = (p2[0] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n    j--;\n    t0 = (p0[1] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n    p0 += 2;\n    t1 = (p1[1] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n    p1 += 2;\n    t2 = (p2[1] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n    p2 += 2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_whirlpool0_context ctx;\n  sph_whirlpool_init(&ctx);\n  sph_whirlpool0(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_whirlpool0_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_whirlpool1_context ctx;\n  sph_whirlpool_init(&ctx);\n  sph_whirlpool1(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_whirlpool1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_whirlpool_context ctx;\n  sph_whirlpool_init(&ctx);\n  sph_whirlpool(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_whirlpool_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char *af_decrypted = (unsigned char *) mem_alloc(cur_salt->afsize + 20);\n  int i;\n  int iterations = cur_salt->bestiter;\n  int dklen = cur_salt->myphdr.keyBytes;\n  uint32_t keycandidate[1][256 / 4];\n  uint32_t masterkeycandidate[1][256 / 4];\n  pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), (const unsigned char *) cur_salt->myphdr.keyblock[cur_salt->bestslot].passwordSalt, 32, iterations, (unsigned char *) keycandidate[0], dklen, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    decrypt_aes_cbc_essiv(cur_salt->cipherbuf, af_decrypted, (unsigned char *) keycandidate[i], cur_salt->afsize, cur_salt);\n    AF_merge(af_decrypted, (unsigned char *) masterkeycandidate[i], cur_salt->afsize, cur_salt->myphdr.keyblock[cur_salt->bestslot].stripes);\n  }\n\n  pbkdf2_sha1((unsigned char *) masterkeycandidate[0], cur_salt->myphdr.keyBytes, (const unsigned char *) cur_salt->myphdr.mkDigestSalt, 32, cur_salt->myphdr.mkDigestIterations, (unsigned char *) crypt_out[index], 20, 0);\n  {\n    if (af_decrypted)\n    {\n      free(af_decrypted);\n      af_decrypted = 0;\n    }\n\n  }\n  ;\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void decrypt_aes_cbc_essiv(unsigned char *src, unsigned char *dst, unsigned char *key, int size, struct custom_salt_LUKS *cs)\n{\n  AES_KEY aeskey;\n  unsigned char essiv[16];\n  unsigned char essivhash[32];\n  unsigned a;\n  jtr_sha256_ctx ctx;\n  unsigned char sectorbuf[16];\n  unsigned char zeroiv[16];\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, key, cs->myphdr.keyBytes);\n  jtr_sha256_final(essivhash, &ctx);\n  memset(sectorbuf, 0, 16);\n  memset(essiv, 0, 16);\n  for (a = 0; a < (size / 512); a++)\n  {\n    memset(zeroiv, 0, 16);\n    {\n      unsigned b = __builtin_bswap32(a);\n      memcpy(sectorbuf, &b, 4);\n    }\n    JTR_AES_set_encrypt_key(essivhash, 256, &aeskey);\n    JTR_AES_cbc_encrypt(sectorbuf, essiv, 16, &aeskey, zeroiv, 1);\n    JTR_AES_set_decrypt_key(key, cs->myphdr.keyBytes * 8, &aeskey);\n    JTR_AES_cbc_encrypt(src + (a * 512), dst + (a * 512), 512, &aeskey, essiv, 0);\n  }\n\n}\n\n\nstatic int AF_merge(unsigned char *src, unsigned char *dst, int afsize, int stripes)\n{\n  int i;\n  char *bufblock;\n  int blocksize = afsize / stripes;\n  bufblock = mem_calloc(1, blocksize + 20);\n  for (i = 0; i < (stripes - 1); i++)\n  {\n    XORblock((char *) (src + (blocksize * i)), bufblock, bufblock, blocksize);\n    diffuse((unsigned char *) bufblock, (unsigned char *) bufblock, blocksize);\n  }\n\n  XORblock((char *) (src + (blocksize * (stripes - 1))), bufblock, (char *) dst, blocksize);\n  {\n    if (bufblock)\n    {\n      free(bufblock);\n      bufblock = 0;\n    }\n\n  }\n  ;\n  return 0;\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n  dst[j] = src1[j] ^ src2[j];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < fullblocks; i++)\n{\n  IV = i;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, &IV, 4);\n  sph_sha1(&ctx, src + (20 * i), 20);\n  sph_sha1_close(&ctx, dst + (20 * i));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (stripes - 1); i++)\n{\n  XORblock((char *) (src + (blocksize * i)), bufblock, bufblock, blocksize);\n  diffuse((unsigned char *) bufblock, (unsigned char *) bufblock, blocksize);\n}\n\nstatic void XORblock(char *src1, char *src2, char *dst, int n)\n{\n  int j;\n  for (j = 0; j < n; j++)\n    dst[j] = src1[j] ^ src2[j];\n\n}\n\n\nstatic int diffuse(unsigned char *src, unsigned char *dst, int size)\n{\n  uint32_t i;\n  uint32_t IV;\n  sph_sha1_context ctx;\n  int fullblocks = size / 20;\n  int padding = size % 20;\n  for (i = 0; i < fullblocks; i++)\n  {\n    IV = i;\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, &IV, 4);\n    sph_sha1(&ctx, src + (20 * i), 20);\n    sph_sha1_close(&ctx, dst + (20 * i));\n  }\n\n  if (padding)\n  {\n    IV = fullblocks;\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, &IV, 4);\n    sph_sha1(&ctx, src + (20 * fullblocks), padding);\n    sph_sha1_close(&ctx, dst + (20 * fullblocks));\n  }\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (a = 0; a < (size / 512); a++)\n{\n  memset(zeroiv, 0, 16);\n  {\n    unsigned b = __builtin_bswap32(a);\n    memcpy(sectorbuf, &b, 4);\n  }\n  JTR_AES_set_encrypt_key(essivhash, 256, &aeskey);\n  JTR_AES_cbc_encrypt(sectorbuf, essiv, 16, &aeskey, zeroiv, 1);\n  JTR_AES_set_decrypt_key(key, cs->myphdr.keyBytes * 8, &aeskey);\n  JTR_AES_cbc_encrypt(src + (a * 512), dst + (a * 512), 512, &aeskey, essiv, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < hdr_size; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  if (((cs.myphdr.keyblock[i].passwordIterations < bestiter) && (cs.myphdr.keyblock[i].passwordIterations > 1)) && (cs.myphdr.keyblock[i].active == 0x00ac71f3))\n  {\n    bestslot = i;\n    bestiter = cs.myphdr.keyblock[i].passwordIterations;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < res; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (cnt = 0; cnt < 8; cnt++)\n{\n  if (((cs.myphdr.keyblock[cnt].passwordIterations < cs.bestiter) && (cs.myphdr.keyblock[cnt].passwordIterations > 1)) && (cs.myphdr.keyblock[cnt].active == 0x00ac71f3))\n  {\n    cs.bestslot = cnt;\n    cs.bestiter = cs.myphdr.keyblock[cnt].passwordIterations;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 20))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_md2_context ctx;\n  sph_md2_init(&ctx);\n  sph_md2(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_md2_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  crypt_md5(saved_key[index], (char *) cur_salt->salt, cur_salt->is_standard, (char *) crypt_out[index]);\n}\n\nstatic void crypt_md5(char *pw, char *salt, int is_standard, char *passwd)\n{\n  const char *magic = (is_standard - 1) ? (\"$apr1$\") : (\"$1$\");\n  const int magiclen = (is_standard - 1) ? ((sizeof(\"$apr1$\")) - 1) : ((sizeof(\"$1$\")) - 1);\n  char *sp;\n  char *ep;\n  unsigned char final[16];\n  int sl;\n  int pl;\n  int i;\n  int j;\n  MD5_CTX ctx;\n  int pwlen = strlen(pw);\n  if (pwlen > 125)\n    pwlen = 125;\n\n  sp = salt;\n  if (is_standard && (!strncmp(sp, magic, magiclen)))\n    sp += magiclen;\n\n  for (ep = sp; ((*ep) && ((*ep) != '$')) && (ep < (sp + 8)); ep++)\n    continue;\n\n  sl = ep - sp;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, pw, pwlen);\n  john_MD5_Update(&ctx, sp, sl);\n  john_MD5_Update(&ctx, pw, pwlen);\n  john_MD5_Final(final, &ctx);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, pw, pwlen);\n  if (is_standard)\n    john_MD5_Update(&ctx, magic, magiclen);\n\n  john_MD5_Update(&ctx, sp, sl);\n  for (pl = pwlen; pl > 0; pl -= 16)\n    john_MD5_Update(&ctx, final, (pl > 16) ? (16) : (pl));\n\n  for (i = pwlen; i; i >>= 1)\n  {\n    if (i & 1)\n      john_MD5_Update(&ctx, \"\", 1);\n    else\n      john_MD5_Update(&ctx, pw, 1);\n\n  }\n\n  john_MD5_Final(final, &ctx);\n  unsigned char buf[(8 * 2) + (125 * 3)];\n  memcpy(buf, sp, sl);\n  memcpy(&buf[sl], pw, pwlen);\n  memcpy(&buf[sl + pwlen], pw, pwlen);\n  memcpy(&buf[sl + (pwlen << 1)], sp, sl);\n  memcpy(&buf[(sl + (pwlen << 1)) + sl], pw, pwlen);\n  unsigned char *bufp[6];\n  unsigned int bufl[6];\n  bufp[0] = &buf[sl];\n  bufl[0] = pwlen;\n  bufp[1] = bufp[0];\n  bufl[1] = pwlen << 1;\n  bufp[2] = buf;\n  bufl[2] = sl + pwlen;\n  bufp[3] = bufp[2];\n  bufl[3] = bufl[2] + pwlen;\n  bufp[4] = &buf[sl + pwlen];\n  bufl[4] = bufl[2];\n  bufp[5] = bufp[4];\n  bufl[5] = bufl[4] + pwlen;\n  static const uint8_t map[42] = {0, 5, 3, 1, 3, 5, 1, 4, 3, 1, 3, 5, 1, 5, 2, 1, 3, 5, 1, 5, 3, 0, 3, 5, 1, 5, 3, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 5, 3, 1, 3, 5};\n  i = 500;\n  j = 0;\n  do\n  {\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, final, 16);\n    john_MD5_Update(&ctx, bufp[map[j]], bufl[map[j]]);\n    john_MD5_Final(final, &ctx);\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, bufp[map[j + 1]], bufl[map[j + 1]]);\n    if ((j += 2) >= 42)\n      j = 0;\n\n    john_MD5_Update(&ctx, final, 16);\n    john_MD5_Final(final, &ctx);\n  }\n  while (--i);\n  memcpy(passwd, final, 16);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ep = sp; ((*ep) && ((*ep) != '$')) && (ep < (sp + 8)); ep++)\n  continue;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pl = pwlen; pl > 0; pl -= 16)\n  john_MD5_Update(&ctx, final, (pl > 16) ? (16) : (pl));\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = pwlen; i; i >>= 1)\n{\n  if (i & 1)\n    john_MD5_Update(&ctx, \"\", 1);\n  else\n    john_MD5_Update(&ctx, pw, 1);\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; idx++)\n{\n  unsigned char buf[sizeof(cur_salt)];\n  unsigned char buf2[((30 * 2) + 4) + (120 * 2)];\n  DES_key_schedule sched_local;\n  unsigned int l;\n  l = salt_length + key_length[idx];\n  memcpy(buf2, cur_salt, salt_length);\n  memcpy(buf2 + salt_length, cur_key[idx], key_length[idx]);\n  crypt_key[idx][0] = 0;\n  crypt_key[idx][1] = 0;\n  DES_ncbc_encrypt(buf2, buf, l, &desschedule_static, (DES_cblock *) crypt_key[idx], 1);\n  DES_set_key_unchecked((DES_cblock *) crypt_key[idx], &sched_local);\n  crypt_key[idx][0] = 0;\n  crypt_key[idx][1] = 0;\n  DES_ncbc_encrypt(buf2, buf, l, &sched_local, (DES_cblock *) crypt_key[idx], 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = l; i < (l + 16); i++)\n{\n  if (!(((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  out3[i] = (atoi16[ARCH_INDEX(ciphertext[(i * 2) + l])] * 16) + atoi16[ARCH_INDEX(ciphertext[((i * 2) + l) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n  if (b == (*((uint32_t *) crypt_key[i])))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < loops; index++)\n{\n  unsigned Lcount;\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, cursalt, 8);\n  john_MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n  strcpy(((char *) (&crypt_key[index])) + 16, saved_key[index]);\n  Lcount = loopCnt;\n  do\n  {\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, crypt_key[index], 16 + saved_len[index]);\n    john_MD5_Final((unsigned char *) (&crypt_key[index]), &ctx);\n  }\n  while (--Lcount);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  if (!memcmp(binary, crypt_key[i], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (dirty)\n  {\n    DES_cblock des_key;\n    int i;\n    for (i = 0; saved_key[index][i]; i++)\n      des_key[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    while (i < 8)\n      des_key[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key, &schedules[index]);\n  }\n\n  DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, (DES_cblock *) crypt_out[index], &schedules[index], 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n  str[i] = a2e[str[i]];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen((const char *) str); i < 8; ++i)\n  str[i] = 0x40;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char key[24];\n  unsigned char out[32];\n  if (cur_salt->type == 0)\n  {\n    MD5_CTX mctx;\n    john_MD5_Init(&mctx);\n    john_MD5_Update(&mctx, saved_key[index], 40);\n    john_MD5_Final(key, &mctx);\n  }\n  else\n    if (cur_salt->type == 1)\n  {\n    sph_sha1_context sctx;\n    sph_sha1_init(&sctx);\n    sph_sha1(&sctx, saved_key[index], 40);\n    sph_sha1_close(&sctx, key);\n  }\n\n\n  memcpy(key + 16, cur_salt->salt, 8);\n  RC4_single(key, 24, cur_salt->encrypted_bytes, 4, out);\n  if (memcmp(out, cur_salt->salt, 4) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  cs.encrypted_bytes[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (cur_salt->type == 0)\n  {\n    MD5_CTX ctx;\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, cur_salt->username, strlen((char *) cur_salt->username));\n    john_MD5_Update(&ctx, \":mongo:\", 7);\n    john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n    john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n  else\n  {\n    unsigned char hexout[32];\n    unsigned char out[32];\n    MD5_CTX ctx;\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, cur_salt->username, strlen((char *) cur_salt->username));\n    john_MD5_Update(&ctx, \":mongo:\", 7);\n    john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n    john_MD5_Final(out, &ctx);\n    hex_encode(out, 16, hexout);\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, cur_salt->salt, 16);\n    john_MD5_Update(&ctx, cur_salt->username, strlen((char *) cur_salt->username));\n    john_MD5_Update(&ctx, hexout, 32);\n    john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n{\n  out[0] = itoa16[str[i] >> 4];\n  out[1] = itoa16[str[i] & 0xF];\n  out += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  sph_sha1_context ctx;\n  MD5_CTX mctx;\n  unsigned char hexhash[32];\n  unsigned char hash[16];\n  unsigned char out[20];\n  john_MD5_Init(&mctx);\n  john_MD5_Update(&mctx, cur_salt->username, strlen((char *) cur_salt->username));\n  john_MD5_Update(&mctx, \":mongo:\", 7);\n  john_MD5_Update(&mctx, saved_key[index], strlen(saved_key[index]));\n  john_MD5_Final(hash, &mctx);\n  hex_encode(hash, 16, hexhash);\n  pbkdf2_sha1(hexhash, 32, cur_salt->salt, 16, cur_salt->iterations, out, 20, 0);\n  JTR_hmac_sha1(out, 20, (unsigned char *) \"Client Key\", 10, out, 20);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, out, 20);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n{\n  out[0] = itoa16[str[i] >> 4];\n  out[1] = itoa16[str[i] & 0xF];\n  out += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  int x;\n  int i;\n  int n;\n  int n_key;\n  int ml;\n  char mac1[32] = {0};\n  char t1[32] = {0};\n  unsigned char key[32];\n  unsigned char *key_p = key;\n  unsigned char m[(16 + 32) + 32];\n  unsigned char *t1f = mem_alloc(32 * cur_salt->mfact);\n  unsigned char *h_out = (unsigned char *) crypt_out[index];\n  unsigned char plaint[16];\n  AES_KEY akey;\n  unsigned char zeroiv[16];\n  unsigned char dh[8];\n  ml = cur_salt->length;\n  memset(key_p, 0, sizeof(key));\n  memcpy(m, cur_salt->salt, ml);\n  get_des_hash(saved_key[index], dh);\n  for (n = 0; n < cur_salt->mfact; n++)\n  {\n    JTR_hmac_sha256(dh, 8, m, ml, h_out, 32);\n    ml = 32;\n    memcpy(t1, h_out, 32);\n    for (x = 0; x < ((cur_salt->rfact * 100) - 1); x++)\n    {\n      memcpy(mac1, h_out, 32);\n      JTR_hmac_sha256(dh, 8, h_out, ml, h_out, 32);\n      for (i = 0; i < 32; i++)\n        t1[i] ^= h_out[i];\n\n    }\n\n    memcpy(m, mac1, 16);\n    memcpy(m + 16, t1, 32);\n    memcpy(m + 48, \"\\x00\\x00\\x00\\x01\", 4);\n    ml = 52;\n    memcpy(t1f + (n * 32), t1, 32);\n  }\n\n  memcpy(key, t1, 32);\n  for (n = 0; n < cur_salt->mfact; n++)\n  {\n    n_key = (((((key_p[28] << 24) & 0xff000000) + ((key_p[29] << 16) & 0xff0000)) + ((key_p[30] << 8) & 0xff00)) + (key_p[31] & 0xff)) & (cur_salt->mfact - 1);\n    memcpy(m, t1f + (n_key * 32), 32);\n    memcpy(m + 32, \"\\x00\\x00\\x00\\x01\", 4);\n    JTR_hmac_sha256(key_p, 32, m, 32 + 4, h_out, 32);\n    memcpy(t1f + (n * 32), h_out, 32);\n    memcpy(key, h_out, 32);\n  }\n\n  memcpy(t1f + (32 * (cur_salt->mfact - 1)), \"\\x00\\x00\\x00\\x01\", 4);\n  ml = (32 * (cur_salt->mfact - 1)) + 4;\n  JTR_hmac_sha256(key_p, 32, t1f, ml, h_out, 32);\n  ml = 32;\n  memcpy(t1, h_out, 32);\n  for (x = 0; x < ((cur_salt->rfact * 100) - 1); x++)\n  {\n    JTR_hmac_sha256(key_p, 32, h_out, ml, h_out, 32);\n    for (i = 0; i < 32; i++)\n      t1[i] ^= h_out[i];\n\n  }\n\n  memcpy(h_out, t1, 32);\n  memset(plaint, '\\x00', sizeof(plaint));\n  memcpy(plaint, cur_salt->userid, 8);\n  memset(zeroiv, 0, 16);\n  JTR_AES_set_encrypt_key((unsigned char *) crypt_out[index], 256, &akey);\n  JTR_AES_cbc_encrypt(plaint, (unsigned char *) crypt_out[index], 16, &akey, zeroiv, 1);\n  {\n    if (t1f)\n    {\n      free(t1f);\n      t1f = 0;\n    }\n\n  }\n  ;\n}\n\nstatic void get_des_hash(char *key, unsigned char *dhash)\n{\n  DES_cblock des_key;\n  DES_key_schedule schedule;\n  DES_cblock ivec;\n  int j;\n  for (j = 0; key[j]; j++)\n    des_key[j] = a2e_precomputed[ARCH_INDEX(key[j])];\n\n  while (j < 8)\n    des_key[j++] = 0x2a;\n\n  DES_set_key_unchecked(&des_key, &schedule);\n  memset(ivec, 0, 8);\n  DES_cbc_encrypt(cur_salt->userid, dhash, 8, &schedule, &ivec, 1);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n  str[i] = a2e[str[i]];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = strlen((const char *) str); i < 8; ++i)\n  str[i] = 0x40;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  cs.salt[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 16; i < (16 + 7); i++)\n{\n  cs.salt[i] = strtol(\"00\", 0, 16);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; key[j]; j++)\n  des_key[j] = a2e_precomputed[ARCH_INDEX(key[j])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; index < count; index++)\n{\n  if (!memcmp(binary, crypt_out[index], 16))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned int a;\n  unsigned int b;\n  unsigned int c;\n  unsigned int d;\n  a = 0xFFFFFFFF + ms_buffer1x[(16 * i) + 0];\n  a = (a << 3) | (a >> 29);\n  d = (0x10325476 + (0x98badcfe ^ (a & 0x77777777))) + ms_buffer1x[(16 * i) + 1];\n  d = (d << 7) | (d >> 25);\n  c = (0x98badcfe + (0xefcdab89 ^ (d & (a ^ 0xefcdab89)))) + ms_buffer1x[(16 * i) + 2];\n  c = (c << 11) | (c >> 21);\n  b = (0xefcdab89 + (a ^ (c & (d ^ a)))) + ms_buffer1x[(16 * i) + 3];\n  b = (b << 19) | (b >> 13);\n  a += (d ^ (b & (c ^ d))) + ms_buffer1x[(16 * i) + 4];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + ms_buffer1x[(16 * i) + 5];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + ms_buffer1x[(16 * i) + 6];\n  c = (c << 11) | (c >> 21);\n  b += (a ^ (c & (d ^ a))) + ms_buffer1x[(16 * i) + 7];\n  b = (b << 19) | (b >> 13);\n  a += (d ^ (b & (c ^ d))) + ms_buffer1x[(16 * i) + 8];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + ms_buffer1x[(16 * i) + 9];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + ms_buffer1x[(16 * i) + 10];\n  c = (c << 11) | (c >> 21);\n  b += (a ^ (c & (d ^ a))) + ms_buffer1x[(16 * i) + 11];\n  b = (b << 19) | (b >> 13);\n  a += (d ^ (b & (c ^ d))) + ms_buffer1x[(16 * i) + 12];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + ms_buffer1x[(16 * i) + 13];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + ms_buffer1x[(16 * i) + 14];\n  c = (c << 11) | (c >> 21);\n  b += a ^ (c & (d ^ a));\n  b = (b << 19) | (b >> 13);\n  a += (((b & (c | d)) | (c & d)) + ms_buffer1x[(16 * i) + 0]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + ms_buffer1x[(16 * i) + 4]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + ms_buffer1x[(16 * i) + 8]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + ms_buffer1x[(16 * i) + 12]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + ms_buffer1x[(16 * i) + 1]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + ms_buffer1x[(16 * i) + 5]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + ms_buffer1x[(16 * i) + 9]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + ms_buffer1x[(16 * i) + 13]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + ms_buffer1x[(16 * i) + 2]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + ms_buffer1x[(16 * i) + 6]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + ms_buffer1x[(16 * i) + 10]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + ms_buffer1x[(16 * i) + 14]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + ms_buffer1x[(16 * i) + 3]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + ms_buffer1x[(16 * i) + 7]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + ms_buffer1x[(16 * i) + 11]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += ((c & (d | a)) | (d & a)) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b ^ c) ^ d) + ms_buffer1x[(16 * i) + 0]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + ms_buffer1x[(16 * i) + 8]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + ms_buffer1x[(16 * i) + 4]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += (((c ^ d) ^ a) + ms_buffer1x[(16 * i) + 12]) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  a += (((b ^ c) ^ d) + ms_buffer1x[(16 * i) + 2]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + ms_buffer1x[(16 * i) + 10]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + ms_buffer1x[(16 * i) + 6]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += (((c ^ d) ^ a) + ms_buffer1x[(16 * i) + 14]) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  a += (((b ^ c) ^ d) + ms_buffer1x[(16 * i) + 1]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + ms_buffer1x[(16 * i) + 9]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + ms_buffer1x[(16 * i) + 5]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += (((c ^ d) ^ a) + ms_buffer1x[(16 * i) + 13]) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  a += (((b ^ c) ^ d) + ms_buffer1x[(16 * i) + 3]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + ms_buffer1x[(16 * i) + 11]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + ms_buffer1x[(16 * i) + 7]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += ((c ^ d) ^ a) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  crypt_out[(4 * i) + 0] = a + 0x67452301;\n  crypt_out[(4 * i) + 1] = b + 0xefcdab89;\n  crypt_out[(4 * i) + 2] = c + 0x98badcfe;\n  crypt_out[(4 * i) + 3] = d + 0x10325476;\n  a = 0xFFFFFFFF + crypt_out[(4 * i) + 0];\n  a = (a << 3) | (a >> 29);\n  d = (0x10325476 + (0x98badcfe ^ (a & 0x77777777))) + crypt_out[(4 * i) + 1];\n  d = (d << 7) | (d >> 25);\n  c = (0x98badcfe + (0xefcdab89 ^ (d & (a ^ 0xefcdab89)))) + crypt_out[(4 * i) + 2];\n  c = (c << 11) | (c >> 21);\n  b = (0xefcdab89 + (a ^ (c & (d ^ a)))) + crypt_out[(4 * i) + 3];\n  b = (b << 19) | (b >> 13);\n  last[(4 * i) + 0] = a;\n  last[(4 * i) + 1] = b;\n  last[(4 * i) + 2] = c;\n  last[(4 * i) + 3] = d;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, ms_buffer1x, crypt_out, last)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned int a;\n  unsigned int b;\n  unsigned int c;\n  unsigned int d;\n  a = last[(4 * i) + 0];\n  b = last[(4 * i) + 1];\n  c = last[(4 * i) + 2];\n  d = last[(4 * i) + 3];\n  a += (d ^ (b & (c ^ d))) + salt_buffer[0];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + salt_buffer[1];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + salt_buffer[2];\n  c = (c << 11) | (c >> 21);\n  b += (a ^ (c & (d ^ a))) + salt_buffer[3];\n  b = (b << 19) | (b >> 13);\n  a += (d ^ (b & (c ^ d))) + salt_buffer[4];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + salt_buffer[5];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + salt_buffer[6];\n  c = (c << 11) | (c >> 21);\n  b += (a ^ (c & (d ^ a))) + salt_buffer[7];\n  b = (b << 19) | (b >> 13);\n  a += (d ^ (b & (c ^ d))) + salt_buffer[8];\n  a = (a << 3) | (a >> 29);\n  d += (c ^ (a & (b ^ c))) + salt_buffer[9];\n  d = (d << 7) | (d >> 25);\n  c += (b ^ (d & (a ^ b))) + salt_buffer[10];\n  c = (c << 11) | (c >> 21);\n  b += a ^ (c & (d ^ a));\n  b = (b << 19) | (b >> 13);\n  a += (((b & (c | d)) | (c & d)) + crypt_out[(4 * i) + 0]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + salt_buffer[0]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + salt_buffer[4]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + salt_buffer[8]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + crypt_out[(4 * i) + 1]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + salt_buffer[1]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + salt_buffer[5]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + salt_buffer[9]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + crypt_out[(4 * i) + 2]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + salt_buffer[2]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + salt_buffer[6]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += (((c & (d | a)) | (d & a)) + salt_buffer[10]) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b & (c | d)) | (c & d)) + crypt_out[(4 * i) + 3]) + 0x5a827999;\n  a = (a << 3) | (a >> 29);\n  d += (((a & (b | c)) | (b & c)) + salt_buffer[3]) + 0x5a827999;\n  d = (d << 5) | (d >> 27);\n  c += (((d & (a | b)) | (a & b)) + salt_buffer[7]) + 0x5a827999;\n  c = (c << 9) | (c >> 23);\n  b += ((c & (d | a)) | (d & a)) + 0x5a827999;\n  b = (b << 13) | (b >> 19);\n  a += (((b ^ c) ^ d) + crypt_out[(4 * i) + 0]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + salt_buffer[4]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + salt_buffer[0]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += (((c ^ d) ^ a) + salt_buffer[8]) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  a += (((b ^ c) ^ d) + crypt_out[(4 * i) + 2]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += (((a ^ b) ^ c) + salt_buffer[6]) + 0x6ed9eba1;\n  d = (d << 9) | (d >> 23);\n  c += (((d ^ a) ^ b) + salt_buffer[2]) + 0x6ed9eba1;\n  c = (c << 11) | (c >> 21);\n  b += (((c ^ d) ^ a) + salt_buffer[10]) + 0x6ed9eba1;\n  b = (b << 15) | (b >> 17);\n  a += (((b ^ c) ^ d) + crypt_out[(4 * i) + 1]) + 0x6ed9eba1;\n  a = (a << 3) | (a >> 29);\n  d += ((a ^ b) ^ c) + salt_buffer[5];\n  output1x[(4 * i) + 0] = a;\n  output1x[(4 * i) + 1] = b;\n  output1x[(4 * i) + 2] = c;\n  output1x[(4 * i) + 3] = d;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; (&ciphertext[i]) < lasth; i++)\n  input[i] = ciphertext[i];\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 4; i++)\n{\n  temp = ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 0])]) << 4;\n  temp |= (unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 1])];\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 2])]) << 12;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 3])]) << 8;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 4])]) << 20;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 5])]) << 16;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 6])]) << 28;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 7])]) << 24;\n  out[i] = temp;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < count; i++)\n  if (d == output1x[(i * 4) + 3])\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 11; i++)\n  if (salt[i] != salt_buffer[i])\n  return 0;\n\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; key[md4_size] && (md4_size < 27); i += xBuf, md4_size++)\n{\n  unsigned int temp;\n  if (temp = key[++md4_size])\n  {\n    keybuffer[i] = key[md4_size - 1] | (temp << 16);\n  }\n  else\n  {\n    keybuffer[i] = key[md4_size - 1] | 0x800000;\n    goto key_cleaning;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i <= (*last_length); i += xBuf)\n  keybuffer[i] = 0;\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i <= (*last_length); i += xBuf)\n  keybuffer[i] = 0;\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (md4_size = 0; md4_size < len; i++, md4_size += 2)\n{\n  key.u16[md4_size] = keybuffer[i] >> 16;\n  key.u16[md4_size + 1] = keybuffer[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, last, crypt_out, salt_buffer, output1x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n{\n  int utf16len;\n  UTF16 pass_unicode[125 + 1];\n  MD4_CTX ctx;\n  utf16len = enc_to_utf16(pass_unicode, 125, &key[(125 + 1) * i], strlen((char *) (&key[(125 + 1) * i])));\n  if (utf16len <= 0)\n  {\n    key[((125 + 1) * i) - utf16len] = 0;\n    if (utf16len != 0)\n      utf16len = strlen16(pass_unicode);\n\n  }\n\n  john_MD4_Init(&ctx);\n  john_MD4_Update(&ctx, pass_unicode, utf16len << 1);\n  john_MD4_Final(&md4hash[(16 + 48) * i], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, key, md4hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (t1 = 0; t1 < count; t1 += 1)\n{\n  MD4_CTX ctx;\n  int i;\n  t = t1 / 1;\n  for (i = 0; i < 1; ++i)\n  {\n    john_MD4_Init(&ctx);\n    john_MD4_Update(&ctx, &md4hash[((t * 1) + i) * (16 + 48)], 16);\n    john_MD4_Update(&ctx, salt_buffer, salt_len);\n    john_MD4_Final((unsigned char *) (&crypt_out[((t * 1) + i) * 4]), &ctx);\n    pbkdf2(&crypt_out[((t * 1) + i) * 4]);\n  }\n\n}\n\nstatic void pbkdf2(unsigned int _key[])\n{\n  sph_sha1_context ctx1;\n  sph_sha1_context ctx2;\n  sph_sha1_context tmp_ctx1;\n  sph_sha1_context tmp_ctx2;\n  unsigned char ipad[64];\n  unsigned char opad[64];\n  unsigned int tmp_hash[20 / 4];\n  unsigned i;\n  unsigned j;\n  unsigned char *key = (unsigned char *) _key;\n  for (i = 0; i < 16; i++)\n  {\n    ipad[i] = key[i] ^ 0x36;\n    opad[i] = key[i] ^ 0x5C;\n  }\n\n  memset(&ipad[16], 0x36, (sizeof(ipad)) - 16);\n  memset(&opad[16], 0x5C, (sizeof(opad)) - 16);\n  sph_sha1_init(&ctx1);\n  sph_sha1_init(&ctx2);\n  sph_sha1(&ctx1, ipad, 64);\n  sph_sha1(&ctx2, opad, 64);\n  memcpy(&tmp_ctx1, &ctx1, sizeof(sph_sha1_context));\n  memcpy(&tmp_ctx2, &ctx2, sizeof(sph_sha1_context));\n  sph_sha1(&ctx1, salt_buffer, salt_len);\n  sph_sha1(&ctx1, \"\\x0\\x0\\x0\\x1\", 4);\n  sph_sha1_close(&ctx1, (unsigned char *) tmp_hash);\n  sph_sha1(&ctx2, (unsigned char *) tmp_hash, 20);\n  sph_sha1_close(&ctx2, (unsigned char *) tmp_hash);\n  memcpy(_key, tmp_hash, 16);\n  for (i = 1; i < iteration_cnt; i++)\n  {\n    memcpy(&ctx1, &tmp_ctx1, (sizeof(sph_sha1_context)) - (64 + (sizeof(unsigned int))));\n    sph_sha1(&ctx1, (unsigned char *) tmp_hash, 20);\n    sph_sha1_close(&ctx1, (unsigned char *) tmp_hash);\n    memcpy(&ctx2, &tmp_ctx2, (sizeof(sph_sha1_context)) - (64 + (sizeof(unsigned int))));\n    sph_sha1(&ctx2, (unsigned char *) tmp_hash, 20);\n    sph_sha1_close(&ctx2, (unsigned char *) tmp_hash);\n    for (j = 0; j < 4; j++)\n      _key[j] ^= tmp_hash[j];\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; (&ciphertext[i]) < lasth; i++)\n  input[i] = (unsigned char) ciphertext[i];\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  temp = ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 6])]) << 4;\n  temp |= (unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 7])];\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 4])]) << 12;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 5])]) << 8;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 2])]) << 20;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 3])]) << 16;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 0])]) << 28;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 1])]) << 24;\n  out[i] = temp;\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < count; i++)\n  if (d == crypt_out[(i * 4) + 3])\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((*n) + 2); ++i)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  ipad[i] = key[i] ^ 0x36;\n  opad[i] = key[i] ^ 0x5C;\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < iteration_cnt; i++)\n{\n  memcpy(&ctx1, &tmp_ctx1, (sizeof(sph_sha1_context)) - (64 + (sizeof(unsigned int))));\n  sph_sha1(&ctx1, (unsigned char *) tmp_hash, 20);\n  sph_sha1_close(&ctx1, (unsigned char *) tmp_hash);\n  memcpy(&ctx2, &tmp_ctx2, (sizeof(sph_sha1_context)) - (64 + (sizeof(unsigned int))));\n  sph_sha1(&ctx2, (unsigned char *) tmp_hash, 20);\n  sph_sha1_close(&ctx2, (unsigned char *) tmp_hash);\n  for (j = 0; j < 4; j++)\n    _key[j] ^= tmp_hash[j];\n\n}\n\n", "pragma": "omp parallel for default(none) private(t) shared(count, salt_buffer, salt_len, crypt_out, md4hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  memcpy(saved_key[index] + saved_len[index], cursalt, 4);\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index] + 4);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 6; i < (54 + (44 * 2)); i++)\n{\n  if (!((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) || (('A' <= ciphertext[i]) && (ciphertext[i] <= 'F'))))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (l = 0; l < 4; l++)\n{\n  out2[l] = (atoi16[ARCH_INDEX(ciphertext[(l * 2) + 6])] * 16) + atoi16[ARCH_INDEX(ciphertext[(l * 2) + 7])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (saved_len[index] = 0; s[saved_len[index]]; saved_len[index]++)\n  d[saved_len[index]] = s[saved_len[index]] << 8;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[(i * 2) + 14])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 15])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint64_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char iv[16];\n  unsigned char key[32];\n  unsigned char outbuf[16];\n  AES_KEY aes_decrypt_key;\n  int len = strlen(saved_key[index]);\n  if (cracked[index])\n    cracked[index] = 0;\n\n  if (cur_salt->type == 1)\n  {\n    unsigned char c;\n    MD5_CTX ctx;\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, saved_key[index], len);\n    john_MD5_Update(&ctx, cur_salt->salt, 8);\n    john_MD5_Final(key, &ctx);\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, key, 16);\n    john_MD5_Update(&ctx, saved_key[index], len);\n    john_MD5_Update(&ctx, cur_salt->salt, 8);\n    john_MD5_Final(key + 16, &ctx);\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, key + 16, 16);\n    john_MD5_Update(&ctx, saved_key[index], len);\n    john_MD5_Update(&ctx, cur_salt->salt, 8);\n    john_MD5_Final(iv, &ctx);\n    JTR_AES_set_decrypt_key(key, 256, &aes_decrypt_key);\n    JTR_AES_cbc_encrypt(cur_salt->block, outbuf, 16, &aes_decrypt_key, iv, 0);\n    c = outbuf[0];\n    if ((((c == 'L') || (c == 'K')) || (c == '5')) || (c == 'Q'))\n    {\n      if (is_base58(outbuf + 1, 15))\n      {\n        JTR_AES_cbc_encrypt(cur_salt->block + 16, outbuf, 16, &aes_decrypt_key, iv, 0);\n        if (is_base58(outbuf, 16))\n          cracked[index] = 1;\n\n      }\n\n    }\n    else\n      if (c == '#')\n    {\n      if (memcmp((const char *) outbuf, \"# KEEP YOUR PRIV\", 8) == 0)\n        cracked[index] = 1;\n\n    }\n    else\n      if (c == '\\x0a')\n    {\n      if (is_bitcoinj_protobuf_data(outbuf))\n        cracked[index] = 1;\n\n    }\n\n\n\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    UTF16 password[(125 * 2) + 1];\n    len = enc_to_utf16_be(password, 125, (const unsigned char *) saved_key[index], len + 1);\n    if (len < 0)\n      len = strlen16(password);\n\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    static const yescrypt_params_t params = {.N = 16384, .r = 8, .p = 1};\n    if (yescrypt_kdf(0, &local[t], (const uint8_t *) password, (len + 1) * 2, (const uint8_t *) salt_hardcoded, 8, &params, key, 32))\n    {\n      failed = (errno) ? (errno) : (EINVAL);\n    }\n\n    JTR_AES_set_decrypt_key(key, 128 * 2, &aes_decrypt_key);\n    memcpy(iv, cur_salt->iv, 16);\n    JTR_AES_cbc_encrypt(cur_salt->block, outbuf, 16, &aes_decrypt_key, iv, 0);\n    if (is_bitcoinj_protobuf_data(outbuf))\n      cracked[index] = 1;\n    else\n    {\n      JTR_AES_set_decrypt_key(key, 128 * 2, &aes_decrypt_key);\n      memcpy(iv, iv_hardcoded, 16);\n      JTR_AES_cbc_encrypt(cur_salt->block2, outbuf, 16, &aes_decrypt_key, iv, 0);\n      if (is_bitcoinj_protobuf_data(outbuf))\n        cracked[index] = 1;\n\n    }\n\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    UTF16 password[(125 * 2) + 1];\n    len = enc_to_utf16_be(password, 125, (const unsigned char *) saved_key[index], len + 1);\n    if (len < 0)\n      len = strlen16(password);\n\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    yescrypt_params_t params = {.N = cur_salt->n, .r = cur_salt->r, .p = cur_salt->p};\n    if (yescrypt_kdf(0, &local[t], (const uint8_t *) password, (len + 1) * 2, (const uint8_t *) cur_salt->salt, 8, &params, key, 32))\n    {\n      failed = (errno) ? (errno) : (EINVAL);\n    }\n\n    memcpy(iv, cur_salt->block, 16);\n    JTR_AES_set_decrypt_key(key, 256, &aes_decrypt_key);\n    JTR_AES_cbc_encrypt(cur_salt->block + 16, outbuf, 16, &aes_decrypt_key, iv, 0);\n    if (!memcmp(outbuf, \"\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\", 16))\n      cracked[index] = 1;\n\n  }\n\n\n\n}\n\nstatic int is_base58(unsigned char *buffer, int length)\n{\n  unsigned char c;\n  int i;\n  for (i = 0; i < length; i++)\n  {\n    c = buffer[i];\n    if ((((c > 'z') || (c < '1')) || ((c > '9') && (c < 'A'))) || ((c > 'Z') && (c < 'a')))\n    {\n      return 0;\n    }\n\n  }\n\n  return 1;\n}\n\n\nstatic int is_base58(unsigned char *buffer, int length)\n{\n  unsigned char c;\n  int i;\n  for (i = 0; i < length; i++)\n  {\n    c = buffer[i];\n    if ((((c > 'z') || (c < '1')) || ((c > '9') && (c < 'A'))) || ((c > 'Z') && (c < 'a')))\n    {\n      return 0;\n    }\n\n  }\n\n  return 1;\n}\n\n\nstatic int is_bitcoinj_protobuf_data(unsigned char *block)\n{\n  unsigned char c;\n  int i;\n  if (((block[0] == '\\x0a') && (block[1] < 128)) && (!memcmp(((const char *) block) + 2, \"org.\", 4)))\n  {\n    for (i = 6; i < 14; i++)\n    {\n      c = block[i];\n      if ((c > 'z') || ((c < 'a') && (c != '.')))\n        return 0;\n\n    }\n\n    return 1;\n  }\n\n  return 0;\n}\n\n\nstatic int is_bitcoinj_protobuf_data(unsigned char *block)\n{\n  unsigned char c;\n  int i;\n  if (((block[0] == '\\x0a') && (block[1] < 128)) && (!memcmp(((const char *) block) + 2, \"org.\", 4)))\n  {\n    for (i = 6; i < 14; i++)\n    {\n      c = block[i];\n      if ((c > 'z') || ((c < 'a') && (c != '.')))\n        return 0;\n\n    }\n\n    return 1;\n  }\n\n  return 0;\n}\n\n\nstatic int is_bitcoinj_protobuf_data(unsigned char *block)\n{\n  unsigned char c;\n  int i;\n  if (((block[0] == '\\x0a') && (block[1] < 128)) && (!memcmp(((const char *) block) + 2, \"org.\", 4)))\n  {\n    for (i = 6; i < 14; i++)\n    {\n      c = block[i];\n      if ((c > 'z') || ((c < 'a') && (c != '.')))\n        return 0;\n\n    }\n\n    return 1;\n  }\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_free_local(&local[i]);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  cs.block[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.block[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.block2[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  cs.block[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 6; i < 14; i++)\n{\n  c = block[i];\n  if ((c > 'z') || ((c < 'a') && (c != '.')))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < length; i++)\n{\n  c = buffer[i];\n  if ((((c > 'z') || (c < '1')) || ((c > '9') && (c < 'A'))) || ((c > 'Z') && (c < 'a')))\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  int i16 = index * 16;\n  unsigned int i;\n  unsigned char RawPsw[((2 * 28) + 8) + 3];\n  int RawLength;\n  sph_sha1_context ctx;\n  sph_sha1_context tempctx;\n  unsigned int digest[5];\n  unsigned char *PswNum;\n  unsigned char tempout[20];\n  RawLength = (saved_len[index] + 8) + 3;\n  PswNum = (unsigned char *) (&RawPsw[saved_len[index] + 8]);\n  PswNum[1] = (PswNum[2] = 0);\n  memcpy(RawPsw, &saved_key[(2 * 28) * index], saved_len[index]);\n  memcpy(RawPsw + saved_len[index], saved_salt, 8);\n  sph_sha1_init(&ctx);\n  for (i = 0; i < 0x40000; i++)\n  {\n    PswNum[0] = (unsigned char) i;\n    if (((unsigned char) i) == 0)\n    {\n      PswNum[1] = (unsigned char) (i >> 8);\n      PswNum[2] = (unsigned char) (i >> 16);\n    }\n\n    sph_sha1(&ctx, RawPsw, RawLength);\n    if ((i % (0x40000 / 16)) == 0)\n    {\n      tempctx = ctx;\n      sph_sha1_close(&tempctx, tempout);\n      aes_iv[i16 + (i / (0x40000 / 16))] = tempout[19];\n    }\n\n  }\n\n  sph_sha1_close(&ctx, (unsigned char *) digest);\n  for (i = 0; i < 4; i++)\n    digest[i] = __builtin_bswap32(digest[i]);\n\n  memcpy(&aes_key[i16], (unsigned char *) digest, 16);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  check_rar(cur_file, index, &aes_key[index * 16], &aes_iv[index * 16]);\n\ninline static void check_rar(rar_file *cur_file, int index, unsigned char *key, const unsigned char *_iv)\n{\n  AES_KEY aes_ctx;\n  unsigned char iv[16];\n  unsigned char plain[16 + 8];\n  memcpy(iv, _iv, 16);\n  if (cur_file->type == 0)\n  {\n    JTR_AES_set_decrypt_key(key, 128, &aes_ctx);\n    JTR_AES_cbc_encrypt(cur_file->data, plain, 16, &aes_ctx, iv, 0);\n    cracked[index] = !memcmp(plain, \"\\xc4\\x3d\\x7b\\x00\\x40\\x07\\x00\", 7);\n    return;\n  }\n  else\n  {\n    if (cur_file->method == 0x30)\n    {\n      CRC32_t crc;\n      unsigned char crc_out[4];\n      uint64_t size = cur_file->unp_size;\n      unsigned char *cipher = cur_file->data;\n      if (cur_file->unp_size % 16)\n      {\n        const char zeros[16] = {0};\n        const int pad_start = cur_file->unp_size % 16;\n        const int pad_size = 16 - pad_start;\n        unsigned char last_iv[16];\n        JTR_AES_set_decrypt_key(key, 128, &aes_ctx);\n        if (cur_file->pack_size < 32)\n        {\n          memcpy(last_iv, iv, 16);\n          JTR_AES_cbc_encrypt(cur_file->data, plain, 16, &aes_ctx, last_iv, 0);\n        }\n        else\n        {\n          memcpy(last_iv, (cur_file->data + cur_file->pack_size) - 32, 16);\n          JTR_AES_cbc_encrypt((cur_file->data + cur_file->pack_size) - 16, plain, 16, &aes_ctx, last_iv, 0);\n        }\n\n        if (!(cracked[index] = !memcmp(&plain[pad_start], zeros, pad_size)))\n          return;\n\n      }\n\n      CRC32_Init(&crc);\n      JTR_AES_set_decrypt_key(key, 128, &aes_ctx);\n      while (size)\n      {\n        unsigned int inlen = (size > 16) ? (16) : (size);\n        JTR_AES_cbc_encrypt(cipher, plain, 16, &aes_ctx, iv, 0);\n        CRC32_Update(&crc, plain, inlen);\n        size -= inlen;\n        cipher += inlen;\n      }\n\n      CRC32_Final(crc_out, crc);\n      cracked[index] = !memcmp(crc_out, &cur_file->crc.c, 4);\n      return;\n    }\n    else\n    {\n      const int solid = 0;\n      unpack_data_t *unpack_t;\n      unsigned char pre_iv[16];\n      memcpy(pre_iv, iv, 16);\n      JTR_AES_set_decrypt_key(key, 128, &aes_ctx);\n      JTR_AES_cbc_encrypt(cur_file->data, plain, 16, &aes_ctx, pre_iv, 0);\n      if (plain[0] & 0x80)\n      {\n        if ((!(plain[0] & 0x20)) || (plain[1] & 0x80))\n        {\n          cracked[index] = 0;\n          return;\n        }\n\n      }\n      else\n      {\n        if ((plain[0] & 0x40) || (!check_huffman(plain)))\n        {\n          cracked[index] = 0;\n          return;\n        }\n\n      }\n\n      unpack_t = &unpack_data[omp_get_thread_num()];\n      unpack_t->max_size = cur_file->unp_size;\n      unpack_t->dest_unp_size = cur_file->unp_size;\n      unpack_t->pack_size = cur_file->pack_size;\n      unpack_t->iv = iv;\n      unpack_t->ctx = &aes_ctx;\n      unpack_t->key = key;\n      JTR_AES_set_decrypt_key(key, 128, &aes_ctx);\n      if (rar_unpack29(cur_file->data, solid, unpack_t))\n        cracked[index] = !memcmp(&unpack_t->unp_crc, &cur_file->crc.c, 4);\n      else\n        cracked[index] = 0;\n\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char stage1_hash[20];\n  unsigned char inner_hash[20];\n  unsigned char token[20];\n  sph_sha1_context ctx;\n  int i;\n  unsigned char *p = (unsigned char *) crypt_out[index];\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_sha1_close(&ctx, stage1_hash);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, stage1_hash, 20);\n  sph_sha1_close(&ctx, inner_hash);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->scramble, 20);\n  sph_sha1(&ctx, inner_hash, 20);\n  sph_sha1_close(&ctx, token);\n  for (i = 0; i < 20; i++)\n  {\n    p[i] = token[i] ^ stage1_hash[i];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n  cs.scramble[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  HMACMD5Context ctx;\n  hmac_md5_init_rfc2104((const unsigned char *) saved_key[index], strlen(saved_key[index]), &ctx);\n  hmac_md5_update(cur_salt->salt, cur_salt->length, &ctx);\n  hmac_md5_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 12; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, cur_salt->salt, cur_salt->length);\n  john_MD5_Update(&ctx, saved_key[index], 16);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs->salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->salt, cur_salt->length);\n  sph_sha1(&ctx, saved_key[index], 20);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs->salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][16];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 16, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    cracked[index + i] = notes_decrypt(cur_salt, master[i]);\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int notes_decrypt(struct custom_salt *cur_salt, unsigned char *key)\n{\n  uint64_t *C = cur_salt->blob.qword;\n  int n = 2;\n  uint64_t R[3];\n  union \n  {\n    uint64_t qword[2];\n    unsigned char stream[16];\n  } todecrypt;\n  int i;\n  int j;\n  AES_KEY akey;\n  uint64_t A = C[0];\n  JTR_AES_set_decrypt_key(key, 128, &akey);\n  for (i = 0; i < (n + 1); i++)\n    R[i] = C[i];\n\n  for (j = 5; j >= 0; j--)\n  {\n    for (i = 2; i >= 1; i--)\n    {\n      todecrypt.qword[0] = A ^ ((n * j) + i);\n      todecrypt.qword[1] = R[i];\n      (0 == 1) ? (JTR_AES_encrypt(todecrypt.stream, todecrypt.stream, &akey)) : (JTR_AES_decrypt(todecrypt.stream, todecrypt.stream, &akey));\n      A = todecrypt.qword[0];\n      R[i] = todecrypt.qword[1];\n    }\n\n  }\n\n  if (A == 0xa6a6a6a6a6a6a6a6ULL)\n    return 1;\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (n + 1); i++)\n  R[i] = C[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 5; j >= 0; j--)\n{\n  for (i = 2; i >= 1; i--)\n  {\n    todecrypt.qword[0] = A ^ ((n * j) + i);\n    todecrypt.qword[1] = R[i];\n    (0 == 1) ? (JTR_AES_encrypt(todecrypt.stream, todecrypt.stream, &akey)) : (JTR_AES_decrypt(todecrypt.stream, todecrypt.stream, &akey));\n    A = todecrypt.qword[0];\n    R[i] = todecrypt.qword[1];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  MD4_CTX ctx;\n  john_MD4_Init(&ctx);\n  john_MD4_Update(&ctx, (unsigned char *) saved_key[i], saved_len[i]);\n  john_MD4_Final((unsigned char *) crypt_key[i], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 8; j++)\n  *(p++) = itoa16[(b[i] >> ((j ^ 1) * 4)) & 0xf];\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pos = ciphertext; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  temp = ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 0])]) << 4;\n  temp |= (unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 1])];\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 2])]) << 12;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 3])]) << 8;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 4])]) << 20;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 5])]) << 16;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 6])]) << 28;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 7])]) << 24;\n  out[i] = __builtin_bswap32(temp);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  if (!memcmp(binary, crypt_key[i], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < loops; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  john_MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  temp = ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 0])]) << 4;\n  temp |= (unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 1])];\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 2])]) << 12;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 3])]) << 8;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 4])]) << 20;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 5])]) << 16;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 6])]) << 28;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 7])]) << 24;\n  out[i] = __builtin_bswap32(temp);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 8; j++)\n  *(p++) = itoa16[(b[i] >> ((j ^ 1) * 4)) & 0xf];\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char pass[40 + 1];\n  unsigned char out[80];\n  int i;\n  int k;\n  int idx = 0;\n  MD5_CTX c;\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_sha1_close(&ctx, out);\n  hex_encode(out, 20, pass);\n  for (i = 0, k = cur_salt->decal; i < 40; ++i, ++k)\n  {\n    out[idx++] = pass[i];\n    if (k > 19)\n      k = 0;\n\n    out[idx++] = cur_salt->HASHKEY[k];\n  }\n\n  john_MD5_Init(&c);\n  john_MD5_Update(&c, out, 80);\n  john_MD5_Final((unsigned char *) crypt_out[index], &c);\n}\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n{\n  out[0] = itoa16[str[i] >> 4];\n  out[1] = itoa16[str[i] & 0xF];\n  out += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n  cs.HASHKEY[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char buffer[16];\n  MD5_CTX ctx;\n  int n = 49999;\n  unsigned char hex_buffer[16 * 2];\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  john_MD5_Final(buffer, &ctx);\n  hex_encode_uppercase(buffer, hex_buffer);\n  do\n  {\n    john_MD5_Init(&ctx);\n    john_MD5_Update(&ctx, hex_buffer, 16 * 2);\n    john_MD5_Final(buffer, &ctx);\n    hex_encode_uppercase(buffer, hex_buffer);\n    --n;\n  }\n  while (n);\n  memcpy((unsigned char *) crypt_out[index], buffer, 16);\n}\n\ninline static void hex_encode_uppercase(unsigned char *str, unsigned char *_out)\n{\n  int i;\n  unsigned short *out = (unsigned short *) _out;\n  for (i = 0; i < 16; ++i)\n  {\n    out[i] = itoa16u_w[str[i]];\n  }\n\n}\n\n\ninline static void hex_encode_uppercase(unsigned char *str, unsigned char *_out)\n{\n  int i;\n  unsigned short *out = (unsigned short *) _out;\n  for (i = 0; i < 16; ++i)\n  {\n    out[i] = itoa16u_w[str[i]];\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; ++i)\n{\n  sprintf(buf, \"%X%X\", i >> 4, i & 0xF);\n  memcpy(&itoa16u_w[i], buf, 2);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; (i < 16) && (*p); i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  out[i] = itoa16u_w[str[i]];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += inc)\n{\n  if (cur_salt->version == 2007)\n    GeneratePasswordHashUsingSHA1(index, &encryptionKey[index]);\n  else\n    if (cur_salt->version == 2010)\n    GenerateAgileEncryptionKey(index, &verifierKeys1[index]);\n  else\n    GenerateAgileEncryptionKey512(index, &verifierKeys512[index]);\n\n\n}\n\nstatic void GeneratePasswordHashUsingSHA1(int idx, uint8_t final[1][40])\n{\n  uint8_t hashBuf[20];\n  uint8_t *key;\n  UTF16 *passwordBuf = saved_key[idx];\n  int passwordBufSize = saved_len[idx];\n  uint32_t inputBuf[((0x14 + 0x04) + 4) / (sizeof(int))];\n  uint8_t X3[40];\n  int i;\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->salt, cur_salt->saltSize);\n  sph_sha1(&ctx, passwordBuf, passwordBufSize);\n  sph_sha1_close(&ctx, hashBuf);\n  memcpy(&inputBuf[1], hashBuf, 20);\n  for (i = 0; i < 50000; i++)\n  {\n    *inputBuf = __builtin_bswap32(i);\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, inputBuf, 0x14 + 0x04);\n    sph_sha1_close(&ctx, (uint8_t *) (&inputBuf[1]));\n  }\n\n  memset(&inputBuf[6], 0, 4);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, &inputBuf[1], 0x14 + 0x04);\n  sph_sha1_close(&ctx, hashBuf);\n  key = DeriveKey(hashBuf, X3);\n  memcpy(final[0], key, cur_salt->keySize / 8);\n}\n\n\nstatic void GenerateAgileEncryptionKey(int idx, uint8_t hashBuf[1][64])\n{\n  UTF16 *passwordBuf = saved_key[idx];\n  int passwordBufSize = saved_len[idx];\n  int hashSize = cur_salt->keySize >> 3;\n  uint32_t inputBuf[(28 + 4) / (sizeof(int))];\n  uint32_t i;\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->salt, cur_salt->saltSize);\n  sph_sha1(&ctx, passwordBuf, passwordBufSize);\n  sph_sha1_close(&ctx, hashBuf[0]);\n  memcpy(&inputBuf[1], hashBuf[0], 20);\n  for (i = 0; i < cur_salt->spinCount; i++)\n  {\n    *inputBuf = __builtin_bswap32(i);\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, inputBuf, 0x14 + 0x04);\n    sph_sha1_close(&ctx, (uint8_t *) (&inputBuf[1]));\n  }\n\n  memcpy(&inputBuf[6], encryptedVerifierHashInputBlockKey, 8);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, &inputBuf[1], 28);\n  sph_sha1_close(&ctx, hashBuf[0]);\n  memcpy(&inputBuf[6], encryptedVerifierHashValueBlockKey, 8);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, &inputBuf[1], 28);\n  sph_sha1_close(&ctx, &hashBuf[0][32]);\n  if (hashSize > 20)\n  {\n    for (i = 20; i < hashSize; i++)\n    {\n      hashBuf[0][i] = 0x36;\n      hashBuf[0][32 + i] = 0x36;\n    }\n\n  }\n\n}\n\n\nstatic void GenerateAgileEncryptionKey512(int idx, uint8_t hashBuf[1][128])\n{\n  UTF16 *passwordBuf = saved_key[idx];\n  int passwordBufSize = saved_len[idx];\n  uint32_t inputBuf[128 / (sizeof(int))];\n  int i;\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, cur_salt->salt, cur_salt->saltSize);\n  jtr_sha512_update(&ctx, passwordBuf, passwordBufSize);\n  jtr_sha512_final(hashBuf[0], &ctx);\n  memcpy(&inputBuf[1], hashBuf, 64);\n  for (i = 0; i < cur_salt->spinCount; i++)\n  {\n    *inputBuf = __builtin_bswap32(i);\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, inputBuf, 64 + 0x04);\n    jtr_sha512_final((uint8_t *) (&inputBuf[1]), &ctx);\n  }\n\n  memcpy(&inputBuf[68 / 4], encryptedVerifierHashInputBlockKey, 8);\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, &inputBuf[1], 64 + 8);\n  jtr_sha512_final(hashBuf[0], &ctx);\n  memcpy(&inputBuf[68 / 4], encryptedVerifierHashValueBlockKey, 8);\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, &inputBuf[1], 64 + 8);\n  jtr_sha512_final(&hashBuf[0][64], &ctx);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (cur_salt->version == 2007)\n    cracked[index] = PasswordVerifier(blob, encryptionKey[index]);\n  else\n    if (cur_salt->version == 2010)\n  {\n    uint8_t decryptedVerifierHashInputBytes[16];\n    uint8_t decryptedVerifierHashBytes[32];\n    uint8_t hash[20];\n    sph_sha1_context ctx;\n    DecryptUsingSymmetricKeyAlgorithm(cur_salt, verifierKeys1[index], blob->encryptedVerifier, decryptedVerifierHashInputBytes, 16);\n    DecryptUsingSymmetricKeyAlgorithm(cur_salt, &verifierKeys1[index][32], blob->encryptedVerifierHash, decryptedVerifierHashBytes, 32);\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, decryptedVerifierHashInputBytes, 16);\n    sph_sha1_close(&ctx, hash);\n    cracked[index] = !memcmp(hash, decryptedVerifierHashBytes, 20);\n  }\n  else\n  {\n    uint8_t decryptedVerifierHashInputBytes[16];\n    uint8_t decryptedVerifierHashBytes[32];\n    uint8_t hash[64];\n    jtr_sha512_ctx ctx;\n    DecryptUsingSymmetricKeyAlgorithm(cur_salt, verifierKeys512[index], blob->encryptedVerifier, decryptedVerifierHashInputBytes, 16);\n    DecryptUsingSymmetricKeyAlgorithm(cur_salt, &verifierKeys512[index][64], blob->encryptedVerifierHash, decryptedVerifierHashBytes, 32);\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, decryptedVerifierHashInputBytes, 16);\n    jtr_sha512_final(hash, &ctx);\n    cracked[index] = !memcmp(hash, decryptedVerifierHashBytes, 20);\n  }\n\n\n}\n\nstatic int PasswordVerifier(ms_office_binary_blob *blob, uint8_t *key)\n{\n  uint8_t decryptedVerifier[16];\n  uint8_t decryptedVerifierHash[16];\n  AES_KEY akey;\n  sph_sha1_context ctx;\n  uint8_t checkHash[20];\n  JTR_AES_set_decrypt_key(key, cur_salt->keySize, &akey);\n  (0 == 1) ? (JTR_AES_encrypt(blob->encryptedVerifier, decryptedVerifier, &akey)) : (JTR_AES_decrypt(blob->encryptedVerifier, decryptedVerifier, &akey));\n  JTR_AES_set_decrypt_key(key, cur_salt->keySize, &akey);\n  (0 == 1) ? (JTR_AES_encrypt(blob->encryptedVerifierHash, decryptedVerifierHash, &akey)) : (JTR_AES_decrypt(blob->encryptedVerifierHash, decryptedVerifierHash, &akey));\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, decryptedVerifier, 16);\n  sph_sha1_close(&ctx, checkHash);\n  return !memcmp(checkHash, decryptedVerifierHash, 16);\n}\n\n\nstatic void DecryptUsingSymmetricKeyAlgorithm(ms_office_custom_salt *cur_salt, uint8_t *verifierInputKey, uint8_t *encryptedVerifier, const uint8_t *decryptedVerifier, int length)\n{\n  uint8_t iv[32];\n  AES_KEY akey;\n  memcpy(iv, cur_salt->salt, 16);\n  memset(&iv[16], 0, 16);\n  JTR_AES_set_decrypt_key(verifierInputKey, cur_salt->keySize, &akey);\n  JTR_AES_cbc_encrypt(encryptedVerifier, (uint8_t *) decryptedVerifier, length, &akey, iv, 0);\n}\n\n\nstatic void DecryptUsingSymmetricKeyAlgorithm(ms_office_custom_salt *cur_salt, uint8_t *verifierInputKey, uint8_t *encryptedVerifier, const uint8_t *decryptedVerifier, int length)\n{\n  uint8_t iv[32];\n  AES_KEY akey;\n  memcpy(iv, cur_salt->salt, 16);\n  memset(&iv[16], 0, 16);\n  JTR_AES_set_decrypt_key(verifierInputKey, cur_salt->keySize, &akey);\n  JTR_AES_cbc_encrypt(encryptedVerifier, (uint8_t *) decryptedVerifier, length, &akey, iv, 0);\n}\n\n\nstatic void DecryptUsingSymmetricKeyAlgorithm(ms_office_custom_salt *cur_salt, uint8_t *verifierInputKey, uint8_t *encryptedVerifier, const uint8_t *decryptedVerifier, int length)\n{\n  uint8_t iv[32];\n  AES_KEY akey;\n  memcpy(iv, cur_salt->salt, 16);\n  memset(&iv[16], 0, 16);\n  JTR_AES_set_decrypt_key(verifierInputKey, cur_salt->keySize, &akey);\n  JTR_AES_cbc_encrypt(encryptedVerifier, (uint8_t *) decryptedVerifier, length, &akey, iv, 0);\n}\n\n\nstatic void DecryptUsingSymmetricKeyAlgorithm(ms_office_custom_salt *cur_salt, uint8_t *verifierInputKey, uint8_t *encryptedVerifier, const uint8_t *decryptedVerifier, int length)\n{\n  uint8_t iv[32];\n  AES_KEY akey;\n  memcpy(iv, cur_salt->salt, 16);\n  memset(&iv[16], 0, 16);\n  JTR_AES_set_decrypt_key(verifierInputKey, cur_salt->keySize, &akey);\n  JTR_AES_cbc_encrypt(encryptedVerifier, (uint8_t *) decryptedVerifier, length, &akey, iv, 0);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  derivedKey[i] = (i < 20) ? (0x36 ^ hashValue[i]) : (0x36);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  derivedKey[i] = (i < 20) ? (0x5C ^ hashValue[i]) : (0x5C);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50000; i++)\n{\n  *inputBuf = __builtin_bswap32(i);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, inputBuf, 0x14 + 0x04);\n  sph_sha1_close(&ctx, (uint8_t *) (&inputBuf[1]));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cur_salt->spinCount; i++)\n{\n  *inputBuf = __builtin_bswap32(i);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, inputBuf, 0x14 + 0x04);\n  sph_sha1_close(&ctx, (uint8_t *) (&inputBuf[1]));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 20; i < hashSize; i++)\n{\n  hashBuf[0][i] = 0x36;\n  hashBuf[0][32 + i] = 0x36;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cur_salt->spinCount; i++)\n{\n  *inputBuf = __builtin_bswap32(i);\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, inputBuf, 64 + 0x04);\n  jtr_sha512_final((uint8_t *) (&inputBuf[1]), &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  AES_KEY akey;\n  unsigned char mask_key[1][32];\n  unsigned char unmasked_keys[64 * 32];\n  unsigned char hashed_mask_key[20];\n  int i;\n  int j;\n  if (cur_salt->kdf_type == 1)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      pbkdf2_sha1((const unsigned char *) key_buffer[index + i], strlen(key_buffer[index + i]), cur_salt->salt, 128, cur_salt->num_iterations, mask_key[i], 32, 0);\n    }\n\n  }\n  else\n    if (cur_salt->kdf_type == 3)\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      bcrypt_pbkdf((const char *) key_buffer[index + i], strlen(key_buffer[index + i]), cur_salt->salt, 128, mask_key[i], 32, cur_salt->num_iterations);\n    }\n\n  }\n\n\n  for (i = 0; i < 1; ++i)\n  {\n    JTR_AES_set_decrypt_key(mask_key[i], 256, &akey);\n    for (j = 0; j < ((64 * 32) / 16); j++)\n    {\n      JTR_AES_decrypt(&cur_salt->masked_keys[16 * j], &unmasked_keys[16 * j], &akey);\n    }\n\n    sph_sha1_context ctx;\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, mask_key[i], 32);\n    sph_sha1_close(&ctx, hashed_mask_key);\n    JTR_hmac_sha1(hashed_mask_key, 20, unmasked_keys, 64 * 32, (unsigned char *) crypt_out[index + i], 20);\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_out[index])))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (decrypt(saved_key[index]) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\nstatic int decrypt(char *password)\n{\n  unsigned char out[16];\n  AES_KEY akey;\n  unsigned char iv[16];\n  unsigned char biv[16];\n  unsigned char key[32];\n  int nrounds = 1;\n  switch (cur_salt->cipher)\n  {\n    case 0:\n      switch (cur_salt->md)\n    {\n      case 0:\n        BytesToKey(256, md5, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 256, &akey);\n        break;\n\n      case 1:\n        BytesToKey(256, sha1, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 256, &akey);\n        break;\n\n      case 2:\n        BytesToKey(256, sha256, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 256, &akey);\n        break;\n\n    }\n\n      break;\n\n    case 1:\n      switch (cur_salt->md)\n    {\n      case 0:\n        BytesToKey(128, md5, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 128, &akey);\n        break;\n\n      case 1:\n        BytesToKey(128, sha1, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 128, &akey);\n        break;\n\n      case 2:\n        BytesToKey(128, sha256, cur_salt->salt, (unsigned char *) password, strlen(password), nrounds, key, iv);\n        JTR_AES_set_decrypt_key(key, 128, &akey);\n        break;\n\n    }\n\n      break;\n\n  }\n\n  memcpy(biv, iv, 16);\n  if (cur_salt->inlined)\n    JTR_AES_cbc_encrypt(cur_salt->last_chunks, out, 16, &akey, iv, 0);\n  else\n  {\n    memcpy(iv, cur_salt->last_chunks, 16);\n    JTR_AES_cbc_encrypt(cur_salt->last_chunks + 16, out, 16, &akey, iv, 0);\n  }\n\n  if (check_pkcs_pad(out, 16, 16) < 0)\n    return -1;\n\n  if (cur_salt->kpa)\n    return kpa(key, biv, cur_salt->inlined);\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < res; i++)\n  cs.last_chunks[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.datalen; i++)\n  cs.data[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (c = 0; c < len; c++)\n{\n  if (((data[c] == 0x0a) || (data[c] == 0x0d)) || ((data[c] >= 32) && (data[c] < 127)))\n    nascii++;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  int i = 0;\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->saltlen, 4096, (unsigned char *) crypt_out[index], 64, 0);\n  for (i = 0; i < 1; i++)\n  {\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, (unsigned char *) crypt_out[index + i], 64);\n    jtr_sha512_update(&ctx, cur_salt->salt, 16);\n    jtr_sha512_final((unsigned char *) crypt_out[index + i], &ctx);\n  }\n\n}\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; (i < 64) && (*p); i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < count; t++)\n{\n  unsigned char temp_key[8 * 2];\n  unsigned char final_key[8 * 2];\n  unsigned int i;\n  unsigned int sum20;\n  unsigned char destArray[4 * 16];\n  MD5_CTX ctx;\n  if (keyLen[t] < 0)\n  {\n    keyLen[t] = strlen(saved_plain[t]);\n    while (saved_plain[t][keyLen[t] - 1] == ' ')\n    {\n      if (keyLen[t] == 0)\n        break;\n\n      saved_plain[t][--keyLen[t]] = 0;\n    }\n\n    for (i = 0; i < keyLen[t]; i++)\n      saved_key[t][i] = transtable[ARCH_INDEX(saved_plain[t][i])];\n\n  }\n\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[t], keyLen[t]);\n  john_MD5_Update(&ctx, cur_salt->s, cur_salt->l);\n  john_MD5_Final(temp_key, &ctx);\n  sum20 = walld0rf_magic(t, temp_key, destArray);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, destArray, sum20);\n  john_MD5_Final(final_key, &ctx);\n  for (i = 0; i < 8; i++)\n    ((char *) crypt_key[t])[i] = final_key[i + 8] ^ final_key[i];\n\n}\n\nstatic unsigned int walld0rf_magic(const int index, const unsigned char *temp_key, unsigned char *destArray)\n{\n  unsigned int sum20;\n  unsigned int I1;\n  unsigned int I2;\n  unsigned int I3;\n  const int len = keyLen[index];\n  sum20 = (*((unsigned int *) temp_key)) & 0x03030303;\n  sum20 = (unsigned char) ((((sum20 >> 24) + (sum20 >> 16)) + (sum20 >> 8)) + sum20);\n  sum20 += (temp_key[5] & 3) | 0x20;\n  if (temp_key[15] & 0x01)\n  {\n    destArray[0] = bcodeArr[47];\n    I2 = 1;\n  }\n  else\n  {\n    I2 = 0;\n  }\n\n  destArray[I2++] = saved_key[index][0];\n  destArray[I2++] = cur_salt->s[0];\n  destArray[I2] = bcodeArr[I2 - 2];\n  destArray[++I2] = 0;\n  I2++;\n  if (len >= 6)\n  {\n    I1 = 6;\n    if (cur_salt->l >= 4)\n    {\n      if (temp_key[14] & 0x01)\n        destArray[I2++] = bcodeArr[46];\n\n      destArray[I2++] = saved_key[index][1];\n      destArray[I2++] = cur_salt->s[1];\n      destArray[I2] = bcodeArr[I2 - 4];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[13] & 0x01)\n        destArray[I2++] = bcodeArr[45];\n\n      destArray[I2++] = saved_key[index][2];\n      destArray[I2++] = cur_salt->s[2];\n      destArray[I2] = bcodeArr[I2 - 6];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[12] & 0x01)\n        destArray[I2++] = bcodeArr[44];\n\n      destArray[I2++] = saved_key[index][3];\n      destArray[I2++] = cur_salt->s[3];\n      destArray[I2] = bcodeArr[I2 - 8];\n      destArray[++I2] = 0;\n      I2++;\n      I3 = 4;\n      if (temp_key[15 - 4] & 0x01)\n        destArray[I2++] = bcodeArr[43];\n\n      destArray[I2++] = saved_key[index][4];\n      if (4 < cur_salt->l)\n        destArray[I2++] = cur_salt->s[I3++];\n\n      destArray[I2] = bcodeArr[(I2 - 5) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[15 - 5] & 0x01)\n        destArray[I2++] = bcodeArr[42];\n\n      destArray[I2++] = saved_key[index][5];\n      if (5 < cur_salt->l)\n        destArray[I2++] = cur_salt->s[I3++];\n\n      destArray[I2] = bcodeArr[(I2 - 6) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (6 < len)\n      {\n        if (temp_key[15 - 6] & 0x01)\n          destArray[I2++] = bcodeArr[(3 * 16) - 7];\n\n        destArray[I2++] = saved_key[index][6];\n        I1++;\n      }\n\n      if (6 < cur_salt->l)\n        destArray[I2++] = cur_salt->s[I3++];\n\n    }\n    else\n    {\n      I3 = 1;\n      if (temp_key[15 - 1] & 0x01)\n        destArray[I2++] = bcodeArr[(3 * 16) - 2];\n\n      destArray[I2++] = saved_key[index][1];\n      if (1 < cur_salt->l)\n        destArray[I2++] = cur_salt->s[I3++];\n\n      destArray[I2] = bcodeArr[(I2 - 2) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[15 - 2] & 0x01)\n        destArray[I2++] = bcodeArr[(3 * 16) - 3];\n\n      destArray[I2++] = saved_key[index][2];\n      if (2 < cur_salt->l)\n        destArray[I2++] = cur_salt->s[I3++];\n\n      destArray[I2] = bcodeArr[(I2 - 3) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[15 - 3] & 0x01)\n        destArray[I2++] = bcodeArr[(3 * 16) - 4];\n\n      destArray[I2++] = saved_key[index][3];\n      destArray[I2] = bcodeArr[(I2 - 4) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[15 - 4] & 0x01)\n        destArray[I2++] = bcodeArr[(3 * 16) - 5];\n\n      destArray[I2++] = saved_key[index][4];\n      destArray[I2] = bcodeArr[(I2 - 5) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (temp_key[15 - 5] & 0x01)\n        destArray[I2++] = bcodeArr[(3 * 16) - 6];\n\n      destArray[I2++] = saved_key[index][5];\n      destArray[I2] = bcodeArr[(I2 - 6) - I3];\n      destArray[++I2] = 0;\n      I2++;\n      if (6 < len)\n      {\n        if (temp_key[15 - 6] & 0x01)\n          destArray[I2++] = bcodeArr[(3 * 16) - 7];\n\n        destArray[I2++] = saved_key[index][6];\n        I1++;\n      }\n\n    }\n\n    destArray[I2] = bcodeArr[(I2 - I1) - I3];\n    destArray[++I2] = 0;\n    I2++;\n  }\n  else\n  {\n    I1 = (I3 = 1);\n  }\n\n  while (I2 < sum20)\n  {\n    if (I1 < len)\n    {\n      if (temp_key[15 - I1] & 0x01)\n        destArray[I2++] = bcodeArr[((3 * 16) - I1) - 1];\n\n      destArray[I2++] = saved_key[index][I1];\n      I1++;\n    }\n\n    if (I3 < cur_salt->l)\n      destArray[I2++] = cur_salt->s[I3++];\n\n    destArray[I2] = bcodeArr[(I2 - I1) - I3];\n    destArray[++I2] = 0;\n    I2++;\n  }\n\n  return sum20;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (p - ciphertext); i++)\n{\n  if ((ciphertext[i] >= 'a') && (ciphertext[i] <= 'z'))\n    return 0;\n\n  if ((i >= 12) && (ciphertext[i] != ' '))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (p - ciphertext); ++i)\n{\n  if (ciphertext[i] == ' ')\n    continue;\n\n  break;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (8 * 2); i++)\n  if (!(((p[i] >= '0') && (p[i] <= '9')) || ((p[i] >= 'A') && (p[i] <= 'F'))))\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < keyLen[index]; i++)\n{\n  if ((saved_plain[index][i] >= 'a') && (saved_plain[index][i] <= 'z'))\n    saved_plain[index][i] ^= 0x20;\n  else\n    if (saved_plain[index][i] & 0x80)\n    saved_plain[index][i] = '^';\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], 8 / 2))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  realcipher[i] = (atoi16[ARCH_INDEX(newCiphertextPointer[i * 2])] * 16) + atoi16[ARCH_INDEX(newCiphertextPointer[(i * 2) + 1])];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < out.l; ++i)\n  out.s[i] = transtable[ARCH_INDEX(ciphertext[i])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < s->l; i++)\n  hash = ((hash << 5) + hash) ^ s->s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  int plen = strlen(saved_key[index]);\n  unsigned char key[64];\n  unsigned char out[64];\n  if (cur_salt->type == 1)\n  {\n    sph_sha1_context ctx;\n    if (plen < 20)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 20 - plen);\n    }\n    else\n      if (plen == 20)\n    {\n      memcpy(key, saved_key[index], 20);\n    }\n    else\n    {\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, saved_key[index], plen);\n      sph_sha1_close(&ctx, key);\n    }\n\n\n    JTR_hmac_sha1(key, 20, cur_salt->salt, cur_salt->salt_length + 20, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    jtr_sha256_ctx ctx;\n    if (plen < 32)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 32 - plen);\n    }\n    else\n      if (plen == 32)\n    {\n      memcpy(key, saved_key[index], 32);\n    }\n    else\n    {\n      jtr_sha256_init(&ctx, 1);\n      jtr_sha256_update(&ctx, saved_key[index], plen);\n      jtr_sha256_final(key, &ctx);\n    }\n\n\n    JTR_hmac_sha256(key, 32, cur_salt->salt, cur_salt->salt_length + 32, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    jtr_sha512_ctx ctx;\n    if (plen < 48)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 48 - plen);\n    }\n    else\n      if (plen == 48)\n    {\n      memcpy(key, saved_key[index], 48);\n    }\n    else\n    {\n      jtr_sha512_init(&ctx, 0);\n      jtr_sha512_update(&ctx, saved_key[index], plen);\n      jtr_sha512_final(key, &ctx);\n    }\n\n\n    JTR_hmac_sha384(key, 48, cur_salt->salt, cur_salt->salt_length + 48, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 4)\n  {\n    jtr_sha512_ctx ctx;\n    if (plen < 64)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 64 - plen);\n    }\n    else\n      if (plen == 64)\n    {\n      memcpy(key, saved_key[index], 64);\n    }\n    else\n    {\n      jtr_sha512_init(&ctx, 1);\n      jtr_sha512_update(&ctx, saved_key[index], plen);\n      jtr_sha512_final(key, &ctx);\n    }\n\n\n    JTR_hmac_sha512(key, 64, cur_salt->salt, cur_salt->salt_length + 64, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  unsigned char output[4096] = {0};\n  int i;\n  unsigned char *tag = (cur_salt->ct + cur_salt->ctlen) - cur_salt->tag_len;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    memset(output, 0, 4096);\n    aes_ccm_auth_decrypt(master[i], 256, cur_salt->ctlen - cur_salt->tag_len, cur_salt->iv, 13, cur_salt->add, cur_salt->addlen, cur_salt->ct, output, tag, cur_salt->tag_len);\n    if ((cur_salt->ctlen - cur_salt->tag_len) == 2)\n    {\n      if (strncmp((const char *) output, \"[]\", 2) == 0)\n        cracked[index + i] = 1;\n\n    }\n    else\n    {\n      if (output[0] != '[')\n        cracked[index + i] = 0;\n      else\n        if (strstr((const char *) output, \"\\\"updated\\\"\"))\n        cracked[index + i] = 1;\n\n\n    }\n\n  }\n\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.addlen; i++)\n  cs.add[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.ctlen; i++)\n  cs.ct[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char m1[53];\n  unsigned char buffer[16 + 20];\n  unsigned char *cp;\n  int i;\n  MD5_CTX mctx;\n  sph_sha1_context sctx;\n  john_MD5_Init(&mctx);\n  john_MD5_Update(&mctx, saved_key[index], saved_len[index]);\n  john_MD5_Final(buffer, &mctx);\n  sph_sha1_init(&sctx);\n  sph_sha1(&sctx, saved_key[index], saved_len[index]);\n  sph_sha1_close(&sctx, buffer + 16);\n  cp = m1;\n  *(cp++) = itoa16[buffer[5] & 0xF];\n  for (i = 6; i < (25 + 6); ++i)\n  {\n    cp[0] = itoa16[buffer[i] >> 4];\n    cp[1] = itoa16[buffer[i] & 0xF];\n    cp += 2;\n  }\n\n  cp[-1] = itoa16[buffer[0] >> 4];\n  john_MD5_Init(&mctx);\n  john_MD5_Update(&mctx, m1, 51);\n  john_MD5_Final(buffer, &mctx);\n  memcpy((unsigned char *) crypt_out[index], buffer + 6, 10);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_panama_context ctx;\n  sph_panama_init(&ctx);\n  sph_panama(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_panama_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_md4((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 16, 0);\n}\n\nstatic void pbkdf2_md4(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[16 / (sizeof(uint32_t))];\n    unsigned char out[16];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  MD4_CTX ipad;\n  MD4_CTX opad;\n  _pbkdf2_md4_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (16 - 1)) / 16;\n  loop = (skip_bytes / 16) + 1;\n  skip_bytes %= 16;\n  while (loop <= loops)\n  {\n    _pbkdf2_md4(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 16) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_md5((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 16, 0);\n}\n\nstatic void pbkdf2_md5(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[16 / (sizeof(uint32_t))];\n    unsigned char out[16];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  MD5_CTX ipad;\n  MD5_CTX opad;\n  _pbkdf2_md5_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (16 - 1)) / 16;\n  loop = (skip_bytes / 16) + 1;\n  skip_bytes %= 16;\n  while (loop <= loops)\n  {\n    _pbkdf2_md5(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 16) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 20, 0);\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 64, 0);\n}\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha256((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 32, 0);\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += inc)\n{\n  if (cur_salt->mac_algo == 1)\n  {\n    unsigned char mackey[20];\n    int mackeylen = cur_salt->key_length;\n    pkcs12_pbe_derive_key(cur_salt->mac_algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->saltlen, mackey, mackeylen);\n    JTR_hmac_sha1(mackey, mackeylen, cur_salt->data, cur_salt->data_length, (unsigned char *) crypt_out[index], 20);\n  }\n  else\n    if (cur_salt->mac_algo == 256)\n  {\n    unsigned char mackey[32];\n    int mackeylen = cur_salt->key_length;\n    pkcs12_pbe_derive_key(cur_salt->mac_algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->saltlen, mackey, mackeylen);\n    JTR_hmac_sha256(mackey, mackeylen, cur_salt->data, cur_salt->data_length, (unsigned char *) crypt_out[index], 20);\n  }\n  else\n    if (cur_salt->mac_algo == 512)\n  {\n    unsigned char mackey[64];\n    int mackeylen = cur_salt->key_length;\n    pkcs12_pbe_derive_key(cur_salt->mac_algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->saltlen, mackey, mackeylen);\n    JTR_hmac_sha512(mackey, mackeylen, cur_salt->data, cur_salt->data_length, (unsigned char *) crypt_out[index], 20);\n  }\n  else\n    if (cur_salt->mac_algo == 224)\n  {\n    unsigned char mackey[32];\n    int mackeylen = cur_salt->key_length;\n    pkcs12_pbe_derive_key(cur_salt->mac_algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->saltlen, mackey, mackeylen);\n    JTR_hmac_sha224(mackey, mackeylen, cur_salt->data, cur_salt->data_length, (unsigned char *) crypt_out[index], 20);\n  }\n  else\n    if (cur_salt->mac_algo == 384)\n  {\n    unsigned char mackey[64];\n    int mackeylen = cur_salt->key_length;\n    pkcs12_pbe_derive_key(cur_salt->mac_algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->saltlen, mackey, mackeylen);\n    JTR_hmac_sha384(mackey, mackeylen, cur_salt->data, cur_salt->data_length, (unsigned char *) crypt_out[index], 20);\n  }\n\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char key[40];\n  int ret;\n  S2KPGPWDE(saved_key[index], cur_salt->salt, key, 32);\n  ret = pgpwde_decrypt_and_verify(key, cur_salt->esk, 128);\n  cracked[index] = 0 == ret;\n}\n\nstatic void S2KPGPWDE(char *password, unsigned char *salt, unsigned char *key, int key_length)\n{\n  sph_sha1_context ctx;\n  uint32_t num = ((key_length - 1) / 20) + 1;\n  int i;\n  int j;\n  uint32_t bytes;\n  int slen;\n  const unsigned char b = 0;\n  uint32_t cbytes = cur_salt->bytes;\n  slen = strlen(password);\n  if (cbytes < (slen + 16))\n    cbytes = (uint32_t) (slen + 16);\n\n  for (i = 0; i < num; i++)\n  {\n    bytes = cbytes;\n    sph_sha1_init(&ctx);\n    for (j = 0; j < i; j++)\n    {\n      sph_sha1(&ctx, &b, 1);\n    }\n\n    while (bytes > (slen + 16))\n    {\n      sph_sha1(&ctx, salt, 16);\n      sph_sha1(&ctx, password, slen);\n      bytes -= slen + 16;\n    }\n\n    if (bytes <= 16)\n    {\n      sph_sha1(&ctx, salt, bytes);\n    }\n    else\n    {\n      sph_sha1(&ctx, salt, 16);\n      sph_sha1(&ctx, password, bytes - 16);\n    }\n\n    sph_sha1_close(&ctx, key + (i * 20));\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num; i++)\n{\n  bytes = cbytes;\n  sph_sha1_init(&ctx);\n  for (j = 0; j < i; j++)\n  {\n    sph_sha1(&ctx, &b, 1);\n  }\n\n  while (bytes > (slen + 16))\n  {\n    sph_sha1(&ctx, salt, 16);\n    sph_sha1(&ctx, password, slen);\n    bytes -= slen + 16;\n  }\n\n  if (bytes <= 16)\n  {\n    sph_sha1(&ctx, salt, bytes);\n  }\n  else\n  {\n    sph_sha1(&ctx, salt, 16);\n    sph_sha1(&ctx, password, bytes - 16);\n  }\n\n  sph_sha1_close(&ctx, key + (i * 20));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < _count; ++idx)\n{\n  int cur_hash_count = salt->cnt;\n  int cur_hash_idx = -1;\n  MY_WORD key0;\n  MY_WORD key1;\n  MY_WORD key2;\n  u8 C;\n  const u8 *b;\n  u8 curDecryBuf[256];\n  u8 curInfBuf[128];\n  int k;\n  int SigChecked;\n  u16 e;\n  u16 v1;\n  u16 v2;\n  z_stream strm;\n  int ret;\n  if (dirty)\n  {\n    u8 *p = (u8 *) saved_key[idx];\n    key0.u = 0x12345678UL;\n    key1.u = 0x23456789UL;\n    key2.u = 0x34567890UL;\n    do\n    {\n      key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ (*(p++)))] ^ (key0.u >> 8);\n      key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n      key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n    }\n    while (*p);\n    K12[idx * 3] = key0.u, K12[(idx * 3) + 1] = key1.u, K12[(idx * 3) + 2] = key2.u;\n    goto SkipKeyLoadInit;\n  }\n\n  do\n  {\n    key0.u = K12[idx * 3], key1.u = K12[(idx * 3) + 1], key2.u = K12[(idx * 3) + 2];\n    SkipKeyLoadInit:\n    ;\n\n    b = salt->H[++cur_hash_idx].h;\n    k = 11;\n    e = salt->H[cur_hash_idx].c;\n    do\n    {\n      C = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n      key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ C)] ^ (key0.u >> 8);\n      key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n      key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n    }\n    while (--k);\n    if (salt->H[cur_hash_idx].type == 2)\n    {\n      u16 e2 = salt->H[cur_hash_idx].c2;\n      if (((salt->chk_bytes == 2) && (C != (e & 0xff))) && (C != (e2 & 0xff)))\n        goto Failed_Bailout;\n\n      C = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n      if ((C != (e >> 8)) && (C != (e2 >> 8)))\n        goto Failed_Bailout;\n\n    }\n    else\n    {\n      if ((salt->chk_bytes == 2) && (C != (e & 0xff)))\n        goto Failed_Bailout;\n\n      C = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n      if (C != (e >> 8))\n        goto Failed_Bailout;\n\n    }\n\n    key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ C)] ^ (key0.u >> 8);\n    key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n    key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n    e = 0;\n    C = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n    SigChecked = 0;\n    if (salt->H[cur_hash_idx].compType == 0)\n    {\n      if (salt->H[cur_hash_idx].pSig->max_len)\n      {\n        int len = salt->H[cur_hash_idx].pSig->max_len;\n        if (len > (salt->H[cur_hash_idx].datlen - 12))\n          len = salt->H[cur_hash_idx].datlen - 12;\n\n        SigChecked = 1;\n        curDecryBuf[0] = C;\n        for (; e < len;)\n        {\n          key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n          key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n          key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n          curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n        }\n\n        if (salt->H[cur_hash_idx].magic == 255)\n        {\n          if (!validate_ascii(&curDecryBuf[5], len - 5))\n            goto Failed_Bailout;\n\n        }\n        else\n        {\n          if (!CheckSigs(curDecryBuf, len, salt->H[cur_hash_idx].pSig))\n            goto Failed_Bailout;\n\n        }\n\n      }\n\n      continue;\n    }\n\n    if ((C & 6) == 6)\n      goto Failed_Bailout;\n\n    if ((C & 6) == 0)\n    {\n      if (C > 1)\n        goto Failed_Bailout;\n\n      curDecryBuf[0] = C;\n      for (e = 0; e <= 4;)\n      {\n        key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n        key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n        key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n        curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n      }\n\n      v1 = curDecryBuf[1] | (((u16) curDecryBuf[2]) << 8);\n      v2 = curDecryBuf[3] | (((u16) curDecryBuf[4]) << 8);\n      if (v1 != (v2 ^ 0xFFFF))\n        goto Failed_Bailout;\n\n      if (salt->H[cur_hash_idx].pSig->max_len)\n      {\n        int len = salt->H[cur_hash_idx].pSig->max_len + 5;\n        if (len > (salt->H[cur_hash_idx].datlen - 12))\n          len = salt->H[cur_hash_idx].datlen - 12;\n\n        SigChecked = 1;\n        for (; e < len;)\n        {\n          key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n          key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n          key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n          curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n        }\n\n        if (salt->H[cur_hash_idx].magic == 255)\n        {\n          if (!validate_ascii(&curDecryBuf[5], len - 5))\n            goto Failed_Bailout;\n\n        }\n        else\n        {\n          if (!CheckSigs(&curDecryBuf[5], len - 5, salt->H[cur_hash_idx].pSig))\n            goto Failed_Bailout;\n\n        }\n\n      }\n\n    }\n    else\n    {\n      curDecryBuf[0] = C;\n      if ((C & 6) == 4)\n      {\n        for (; e < 10;)\n        {\n          key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n          key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n          key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n          curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n        }\n\n        if (!check_inflate_CODE2(curDecryBuf))\n          goto Failed_Bailout;\n\n      }\n      else\n      {\n        int til;\n        til = 36;\n        if ((salt->H[cur_hash_idx].datlen - 12) < til)\n          til = salt->H[cur_hash_idx].datlen - 12;\n\n        for (; e < til;)\n        {\n          key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n          key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n          key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n          curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n        }\n\n        if (!check_inflate_CODE1(curDecryBuf, til))\n          goto Failed_Bailout;\n\n      }\n\n    }\n\n    if ((!SigChecked) && salt->H[cur_hash_idx].pSig->max_len)\n    {\n      int til = 180;\n      if ((salt->H[cur_hash_idx].datlen - 12) < til)\n        til = salt->H[cur_hash_idx].datlen - 12;\n\n      for (; e < til;)\n      {\n        key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n        key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n        key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n        curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n      }\n\n      strm.zalloc = Z_NULL;\n      strm.zfree = Z_NULL;\n      strm.opaque = Z_NULL;\n      strm.next_in = Z_NULL;\n      strm.avail_in = til;\n      ret = inflateInit2(&strm, -15);\n      if (ret != Z_OK)\n        perror(\"Error, initializing the libz inflateInit2() system\\n\");\n\n      strm.next_in = curDecryBuf;\n      strm.avail_out = sizeof(curInfBuf);\n      strm.next_out = curInfBuf;\n      ret = inflate(&strm, Z_SYNC_FLUSH);\n      inflateEnd(&strm);\n      if (ret != Z_OK)\n      {\n        if ((ret == Z_STREAM_END) && (salt->deCompLen == strm.total_out))\n          ;\n        else\n          goto Failed_Bailout;\n\n      }\n\n      if (!strm.total_out)\n        goto Failed_Bailout;\n\n      ret = salt->H[cur_hash_idx].pSig->max_len;\n      if (salt->H[cur_hash_idx].magic == 255)\n      {\n        if (!validate_ascii(curInfBuf, strm.total_out))\n          goto Failed_Bailout;\n\n      }\n      else\n      {\n        if (strm.total_out < ret)\n          goto Failed_Bailout;\n\n        if (!CheckSigs(curInfBuf, strm.total_out, salt->H[cur_hash_idx].pSig))\n          goto Failed_Bailout;\n\n      }\n\n    }\n\n    if (salt->H[cur_hash_idx].full_zip)\n    {\n      u8 inflateBufTmp[1024];\n      if ((salt->compLen > 240) && (salt->H[cur_hash_idx].datlen >= 200))\n      {\n        for (; e < 200;)\n        {\n          key0.u = JTR_CRC32_table[(unsigned char) (key0.u ^ curDecryBuf[e])] ^ (key0.u >> 8);\n          key1.u = ((key1.u + key0.c[3]) * 134775813) + 1;\n          key2.u = JTR_CRC32_table[(unsigned char) (key2.u ^ key1.c[0])] ^ (key2.u >> 8);\n          curDecryBuf[++e] = (*(b++)) ^ mult_tab[((u16) key2.u) >> 2];\n        }\n\n        strm.zalloc = Z_NULL;\n        strm.zfree = Z_NULL;\n        strm.opaque = Z_NULL;\n        strm.next_in = Z_NULL;\n        strm.avail_in = e;\n        ret = inflateInit2(&strm, -15);\n        if (ret != Z_OK)\n          perror(\"Error, initializing the libz inflateInit2() system\\n\");\n\n        strm.next_in = curDecryBuf;\n        strm.avail_out = sizeof(inflateBufTmp);\n        strm.next_out = inflateBufTmp;\n        ret = inflate(&strm, Z_SYNC_FLUSH);\n        inflateEnd(&strm);\n        if (ret != Z_OK)\n        {\n          goto Failed_Bailout;\n        }\n\n      }\n\n      goto KnownSuccess;\n    }\n\n  }\n  while (--cur_hash_count);\n  KnownSuccess:\n  ;\n\n  chk[idx] = 1;\n  continue;\n  Failed_Bailout:\n  ;\n\n  chk[idx] = 0;\n}\n\nstatic int validate_ascii(const u8 *out, int inplen)\n{\n  int i;\n  int unicode = 0;\n  for (i = 0; i < (inplen - 1); ++i)\n  {\n    if (out[i] > 0x7E)\n    {\n      if (unicode)\n        return 0;\n\n      if (out[i] > 0xC0)\n      {\n        int len;\n        if (i > (inplen - 4))\n          return 1;\n\n        len = isLegalUTF8_char(&out[i], 5);\n        if (len < 0)\n          return 0;\n\n        i += len - 1;\n      }\n      else\n      {\n        if (i)\n        {\n          if (((out[0] == 0xEF) && (out[1] == 0xBB)) && (out[2] == 0xBF))\n          {\n            i = 2;\n            continue;\n          }\n\n          if ((out[0] == 0xFF) && (out[1] == 0xFE))\n          {\n            unicode = 1;\n            i++;\n            continue;\n          }\n\n          if ((out[0] == 0xFE) && (out[1] == 0xFF))\n          {\n            unicode = 1;\n            i += 2;\n            continue;\n          }\n\n          if ((((out[0] == 0xFF) && (out[1] == 0xFE)) && (out[2] == 0)) && (out[3] == 0))\n          {\n            unicode = 3;\n            i += 3;\n            continue;\n          }\n\n          if ((((out[0] == 0) && (out[1] == 0)) && (out[2] == 0xFE)) && (out[3] == 0xFF))\n          {\n            unicode = 3;\n            i += 6;\n            continue;\n          }\n\n          if ((out[1] <= 0x7E) && (out[1] >= 0x20))\n          {\n            ++i;\n            continue;\n          }\n\n          return 0;\n        }\n\n      }\n\n    }\n    else\n      if (out[i] < 0x20)\n    {\n      if ((((out[i] != '\\n') && (out[i] != '\\r')) && (out[i] != '\\t')) && (out[i] != 0x1B))\n        return 0;\n\n    }\n\n\n    i += unicode;\n  }\n\n  return 1;\n}\n\n\nstatic int CheckSigs(const u8 *p, int len, ZIP_SIGS *pSig)\n{\n  int i;\n  int j;\n  for (i = 0; i < pSig->magic_count; ++i)\n  {\n    int fnd = 1;\n    u8 *pS = pSig->magic_signature[i];\n    for (j = 0; j < pSig->magic_sig_len[i]; ++j)\n    {\n      if (p[j] != pS[j])\n      {\n        fnd = 0;\n        break;\n      }\n\n    }\n\n    if (fnd)\n      return 1;\n\n  }\n\n  return 0;\n}\n\n\nstatic int validate_ascii(const u8 *out, int inplen)\n{\n  int i;\n  int unicode = 0;\n  for (i = 0; i < (inplen - 1); ++i)\n  {\n    if (out[i] > 0x7E)\n    {\n      if (unicode)\n        return 0;\n\n      if (out[i] > 0xC0)\n      {\n        int len;\n        if (i > (inplen - 4))\n          return 1;\n\n        len = isLegalUTF8_char(&out[i], 5);\n        if (len < 0)\n          return 0;\n\n        i += len - 1;\n      }\n      else\n      {\n        if (i)\n        {\n          if (((out[0] == 0xEF) && (out[1] == 0xBB)) && (out[2] == 0xBF))\n          {\n            i = 2;\n            continue;\n          }\n\n          if ((out[0] == 0xFF) && (out[1] == 0xFE))\n          {\n            unicode = 1;\n            i++;\n            continue;\n          }\n\n          if ((out[0] == 0xFE) && (out[1] == 0xFF))\n          {\n            unicode = 1;\n            i += 2;\n            continue;\n          }\n\n          if ((((out[0] == 0xFF) && (out[1] == 0xFE)) && (out[2] == 0)) && (out[3] == 0))\n          {\n            unicode = 3;\n            i += 3;\n            continue;\n          }\n\n          if ((((out[0] == 0) && (out[1] == 0)) && (out[2] == 0xFE)) && (out[3] == 0xFF))\n          {\n            unicode = 3;\n            i += 6;\n            continue;\n          }\n\n          if ((out[1] <= 0x7E) && (out[1] >= 0x20))\n          {\n            ++i;\n            continue;\n          }\n\n          return 0;\n        }\n\n      }\n\n    }\n    else\n      if (out[i] < 0x20)\n    {\n      if ((((out[i] != '\\n') && (out[i] != '\\r')) && (out[i] != '\\t')) && (out[i] != 0x1B))\n        return 0;\n\n    }\n\n\n    i += unicode;\n  }\n\n  return 1;\n}\n\n\nstatic int CheckSigs(const u8 *p, int len, ZIP_SIGS *pSig)\n{\n  int i;\n  int j;\n  for (i = 0; i < pSig->magic_count; ++i)\n  {\n    int fnd = 1;\n    u8 *pS = pSig->magic_signature[i];\n    for (j = 0; j < pSig->magic_sig_len[i]; ++j)\n    {\n      if (p[j] != pS[j])\n      {\n        fnd = 0;\n        break;\n      }\n\n    }\n\n    if (fnd)\n      return 1;\n\n  }\n\n  return 0;\n}\n\n\ninline static int check_inflate_CODE2(u8 *next)\n{\n  u32 bits;\n  u32 hold;\n  u32 thisget;\n  u32 have;\n  u32 i;\n  int left;\n  u32 ncode;\n  u32 ncount[2];\n  u8 *count;\n  hold = (((*next) + (((u32) next[1]) << 8)) + (((u32) next[2]) << 16)) + (((u32) next[3]) << 24);\n  next += 3;\n  hold >>= 3;\n  count = (u8 *) ncount;\n  if ((257 + (hold & 0x1F)) > 286)\n    return 0;\n\n  hold >>= 5;\n  if ((1 + (hold & 0x1F)) > 30)\n    return 0;\n\n  hold >>= 5;\n  ncode = 4 + (hold & 0xF);\n  hold >>= 4;\n  hold += ((u32) (*(++next))) << 15;\n  hold += ((u32) (*(++next))) << 23;\n  bits = 31;\n  have = 0;\n  ncount[0] = (ncount[1] = 0);\n  for (;;)\n  {\n    if ((have + 7) > ncode)\n      thisget = ncode - have;\n    else\n      thisget = 7;\n\n    have += thisget;\n    bits -= thisget * 3;\n    while (thisget--)\n    {\n      ++count[hold & 7];\n      hold >>= 3;\n    }\n\n    if (have == ncode)\n      break;\n\n    hold += ((u32) (*(++next))) << bits;\n    bits += 8;\n    hold += ((u32) (*(++next))) << bits;\n    bits += 8;\n  }\n\n  count[0] = 0;\n  if ((!ncount[0]) && (!ncount[1]))\n    return 0;\n\n  left = 1;\n  for (i = 1; i <= 7; ++i)\n  {\n    left <<= 1;\n    left -= count[i];\n    if (left < 0)\n      return 0;\n\n  }\n\n  if (left > 0)\n    return 0;\n\n  return 1;\n}\n\n\ninline static int check_inflate_CODE1(u8 *next, int left)\n{\n  u32 whave = 0;\n  u32 op;\n  u32 bits;\n  u32 hold;\n  u32 len;\n  code here;\n  hold = (((*next) + (((u32) next[1]) << 8)) + (((u32) next[2]) << 16)) + (((u32) next[3]) << 24);\n  next += 3;\n  left -= 4;\n  hold >>= 3;\n  bits = 32 - 3;\n  for (;;)\n  {\n    if (bits < 15)\n    {\n      if (left < 2)\n        return 1;\n\n      left -= 2;\n      hold += ((u32) (*(++next))) << bits;\n      bits += 8;\n      hold += ((u32) (*(++next))) << bits;\n      bits += 8;\n    }\n\n    here = lenfix[hold & 0x1FF];\n    op = (unsigned) here.bits;\n    hold >>= op;\n    bits -= op;\n    op = (unsigned) here.op;\n    if (op == 0)\n      ++whave;\n    else\n      if (op & 16)\n    {\n      len = (unsigned) here.val;\n      op &= 15;\n      if (op)\n      {\n        if (bits < op)\n        {\n          if (!left)\n            return 1;\n\n          --left;\n          hold += ((u32) (*(++next))) << bits;\n          bits += 8;\n        }\n\n        len += ((unsigned) hold) & ((1U << op) - 1);\n        hold >>= op;\n        bits -= op;\n      }\n\n      if (bits < 15)\n      {\n        if (left < 2)\n          return 1;\n\n        left -= 2;\n        hold += ((u32) (*(++next))) << bits;\n        bits += 8;\n        hold += ((u32) (*(++next))) << bits;\n        bits += 8;\n      }\n\n      here = distfix[hold & 0x1F];\n      op = (unsigned) here.bits;\n      hold >>= op;\n      bits -= op;\n      op = (unsigned) here.op;\n      if (op & 16)\n      {\n        u32 dist = (unsigned) here.val;\n        op &= 15;\n        if (bits < op)\n        {\n          if (!left)\n            return 1;\n\n          --left;\n          hold += ((u32) (*(++next))) << bits;\n          bits += 8;\n          if (bits < op)\n          {\n            if (!left)\n              return 1;\n\n            --left;\n            hold += ((u32) (*(++next))) << bits;\n            bits += 8;\n          }\n\n        }\n\n        dist += ((unsigned) hold) & ((1U << op) - 1);\n        if (dist > whave)\n          return 0;\n\n        hold >>= op;\n        bits -= op;\n        whave += len;\n      }\n      else\n        return 0;\n\n    }\n    else\n      if (op & 32)\n    {\n      if (left == 0)\n        return 1;\n\n      return 0;\n    }\n    else\n    {\n      return 0;\n    }\n\n\n\n  }\n\n}\n\n\nstatic int validate_ascii(const u8 *out, int inplen)\n{\n  int i;\n  int unicode = 0;\n  for (i = 0; i < (inplen - 1); ++i)\n  {\n    if (out[i] > 0x7E)\n    {\n      if (unicode)\n        return 0;\n\n      if (out[i] > 0xC0)\n      {\n        int len;\n        if (i > (inplen - 4))\n          return 1;\n\n        len = isLegalUTF8_char(&out[i], 5);\n        if (len < 0)\n          return 0;\n\n        i += len - 1;\n      }\n      else\n      {\n        if (i)\n        {\n          if (((out[0] == 0xEF) && (out[1] == 0xBB)) && (out[2] == 0xBF))\n          {\n            i = 2;\n            continue;\n          }\n\n          if ((out[0] == 0xFF) && (out[1] == 0xFE))\n          {\n            unicode = 1;\n            i++;\n            continue;\n          }\n\n          if ((out[0] == 0xFE) && (out[1] == 0xFF))\n          {\n            unicode = 1;\n            i += 2;\n            continue;\n          }\n\n          if ((((out[0] == 0xFF) && (out[1] == 0xFE)) && (out[2] == 0)) && (out[3] == 0))\n          {\n            unicode = 3;\n            i += 3;\n            continue;\n          }\n\n          if ((((out[0] == 0) && (out[1] == 0)) && (out[2] == 0xFE)) && (out[3] == 0xFF))\n          {\n            unicode = 3;\n            i += 6;\n            continue;\n          }\n\n          if ((out[1] <= 0x7E) && (out[1] >= 0x20))\n          {\n            ++i;\n            continue;\n          }\n\n          return 0;\n        }\n\n      }\n\n    }\n    else\n      if (out[i] < 0x20)\n    {\n      if ((((out[i] != '\\n') && (out[i] != '\\r')) && (out[i] != '\\t')) && (out[i] != 0x1B))\n        return 0;\n\n    }\n\n\n    i += unicode;\n  }\n\n  return 1;\n}\n\n\nstatic int CheckSigs(const u8 *p, int len, ZIP_SIGS *pSig)\n{\n  int i;\n  int j;\n  for (i = 0; i < pSig->magic_count; ++i)\n  {\n    int fnd = 1;\n    u8 *pS = pSig->magic_signature[i];\n    for (j = 0; j < pSig->magic_sig_len[i]; ++j)\n    {\n      if (p[j] != pS[j])\n      {\n        fnd = 0;\n        break;\n      }\n\n    }\n\n    if (fnd)\n      return 1;\n\n  }\n\n  return 0;\n}\n\n\n", "pragma": "omp parallel for private(idx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (n = 0; n < 16384; n++)\n  mult_tab[n] = ((((unsigned) ((n * 4) + 3)) * ((n * 4) + 2)) >> 8) & 0xff;\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  if (!salt->H[i].h)\n  {\n    need_fixup = 1;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; i++)\n{\n  salt->H[i].h = &salt->zip_data[i + tot_len];\n  tot_len += salt->H[i].datlen;\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->cnt; ++i)\n{\n  int data_enum;\n  salt->H[i].type = (type2) ? (2) : (1);\n  cp = strtokm(0, \"*\");\n  data_enum = (*cp) - '0';\n  cp = strtokm(0, \"*\");\n  {\n    unsigned jnk;\n    sscanf(cp, \"%x\", &jnk);\n    salt->H[i].magic = (unsigned char) jnk;\n  }\n  salt->H[i].pSig = &SIGS[salt->H[i].magic];\n  if (data_enum > 1)\n  {\n    cp = strtokm(0, \"*\");\n    sscanf(cp, \"%x\", &salt->compLen);\n    cp = strtokm(0, \"*\");\n    sscanf(cp, \"%x\", &salt->deCompLen);\n    cp = strtokm(0, \"*\");\n    sscanf(cp, \"%x\", &salt->crc32);\n    cp = strtokm(0, \"*\");\n    sscanf(cp, \"%lx\", &offset);\n    cp = strtokm(0, \"*\");\n    sscanf(cp, \"%x\", &offex);\n  }\n\n  cp = strtokm(0, \"*\");\n  sscanf(cp, \"%x\", &salt->H[i].compType);\n  cp = strtokm(0, \"*\");\n  sscanf(cp, \"%x\", &salt->H[i].datlen);\n  cp = strtokm(0, \"*\");\n  for (j = 0; j < 4; ++j)\n  {\n    salt->H[i].c <<= 4;\n    salt->H[i].c |= atoi16[ARCH_INDEX(cp[j])];\n  }\n\n  if (type2)\n  {\n    cp = strtokm(0, \"*\");\n    for (j = 0; j < 4; ++j)\n    {\n      salt->H[i].c2 <<= 4;\n      salt->H[i].c2 |= atoi16[ARCH_INDEX(cp[j])];\n    }\n\n  }\n\n  cp = strtokm(0, \"*\");\n  if (data_enum > 1)\n  {\n    if (data_enum == 3)\n    {\n      FILE *fp;\n      fp = fopen(cp, \"rb\");\n      if (!fp)\n      {\n        fprintf(stderr, \"Error opening file for pkzip data:  %s\\n\", cp);\n        {\n          if (cpalloc)\n          {\n            free(cpalloc);\n            cpalloc = 0;\n          }\n\n        }\n        ;\n        return 0;\n      }\n\n      fseek(fp, offset + offex, 0);\n      if (salt->compLen < (16 * 1024))\n      {\n        ex_len[i] = salt->compLen;\n        H[i] = mem_alloc(salt->compLen);\n        if (fread(H[i], 1, salt->compLen, fp) != salt->compLen)\n        {\n          fprintf(stderr, \"Error reading zip file for pkzip data:  %s\\n\", cp);\n          fclose(fp);\n          {\n            if (cpalloc)\n            {\n              free(cpalloc);\n              cpalloc = 0;\n            }\n\n          }\n          ;\n          return 0;\n        }\n\n        fclose(fp);\n        salt->H[i].datlen = salt->compLen;\n      }\n      else\n      {\n        strnzcpy(salt->fname, (const char *) cp, sizeof(salt->fname));\n        salt->offset = offset + offex;\n        ex_len[i] = 384;\n        H[i] = mem_alloc(384);\n        if (fread(H[i], 1, 384, fp) != 384)\n        {\n          fprintf(stderr, \"Error reading zip file for pkzip data:  %s\\n\", cp);\n          fclose(fp);\n          {\n            if (cpalloc)\n            {\n              free(cpalloc);\n              cpalloc = 0;\n            }\n\n          }\n          ;\n          return 0;\n        }\n\n        fclose(fp);\n        salt->H[i].datlen = 384;\n      }\n\n    }\n    else\n    {\n      ex_len[i] = salt->compLen;\n      H[i] = mem_alloc(salt->compLen);\n      for (j = 0; j < salt->H[i].datlen; ++j)\n        H[i][j] = (atoi16[ARCH_INDEX(cp[j * 2])] << 4) + atoi16[ARCH_INDEX(cp[(j * 2) + 1])];\n\n    }\n\n    salt->compType = salt->H[i].compType;\n    salt->H[i].full_zip = 1;\n    salt->full_zip_idx = i;\n  }\n  else\n  {\n    ex_len[i] = salt->H[i].datlen;\n    H[i] = mem_alloc(salt->H[i].datlen);\n    for (j = 0; j < salt->H[i].datlen; ++j)\n      H[i][j] = (atoi16[ARCH_INDEX(cp[j * 2])] << 4) + atoi16[ARCH_INDEX(cp[(j * 2) + 1])];\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->cnt; ++i)\n{\n  if (salt->H[i].compType == 8)\n  {\n    if ((salt->cnt == 1) && (salt->chk_bytes == 1))\n      j += 10;\n    else\n      break;\n\n  }\n\n  j += 1;\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->cnt; ++i)\n  salt->H[i].magic = 0;\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->cnt; i++)\n  tot_len += ex_len[i];\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < salt->cnt; i++)\n{\n  memcpy((psalt->zip_data + i) + tot_len, H[i], ex_len[i]);\n  tot_len += ex_len[i];\n  {\n    if (H[i])\n    {\n      free(H[i]);\n      H[i] = 0;\n    }\n\n  }\n  ;\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = (j = 0); i < count; ++i)\n  j += chk[i];\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < new_bytes; ++k)\n{\n  C = in[k] ^ mult_tab[((u16) (*pkey2).u) >> 2];\n  pkey0->u = JTR_CRC32_table[(unsigned char) (pkey0->u ^ C)] ^ (pkey0->u >> 8);\n  pkey1->u = ((pkey1->u + pkey0->c[3]) * 134775813) + 1;\n  pkey2->u = JTR_CRC32_table[(unsigned char) (pkey2->u ^ pkey1->c[0])] ^ (pkey2->u >> 8);\n  in[k] = C;\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < avail_in; ++k)\n  crc = JTR_CRC32_table[(unsigned char) (crc ^ in[k])] ^ (crc >> 8);\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < have; ++k)\n  crc = JTR_CRC32_table[(unsigned char) (crc ^ out[k])] ^ (crc >> 8);\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < (salt->compLen - 12); ++k)\n  crc = JTR_CRC32_table[(unsigned char) (crc ^ decrBuf[k])] ^ (crc >> 8);\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < strm.total_out; ++k)\n  crc = JTR_CRC32_table[(unsigned char) (crc ^ decompBuf[k])] ^ (crc >> 8);\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (inplen - 1); ++i)\n{\n  if (out[i] > 0x7E)\n  {\n    if (unicode)\n      return 0;\n\n    if (out[i] > 0xC0)\n    {\n      int len;\n      if (i > (inplen - 4))\n        return 1;\n\n      len = isLegalUTF8_char(&out[i], 5);\n      if (len < 0)\n        return 0;\n\n      i += len - 1;\n    }\n    else\n    {\n      if (i)\n      {\n        if (((out[0] == 0xEF) && (out[1] == 0xBB)) && (out[2] == 0xBF))\n        {\n          i = 2;\n          continue;\n        }\n\n        if ((out[0] == 0xFF) && (out[1] == 0xFE))\n        {\n          unicode = 1;\n          i++;\n          continue;\n        }\n\n        if ((out[0] == 0xFE) && (out[1] == 0xFF))\n        {\n          unicode = 1;\n          i += 2;\n          continue;\n        }\n\n        if ((((out[0] == 0xFF) && (out[1] == 0xFE)) && (out[2] == 0)) && (out[3] == 0))\n        {\n          unicode = 3;\n          i += 3;\n          continue;\n        }\n\n        if ((((out[0] == 0) && (out[1] == 0)) && (out[2] == 0xFE)) && (out[3] == 0xFF))\n        {\n          unicode = 3;\n          i += 6;\n          continue;\n        }\n\n        if ((out[1] <= 0x7E) && (out[1] >= 0x20))\n        {\n          ++i;\n          continue;\n        }\n\n        return 0;\n      }\n\n    }\n\n  }\n  else\n    if (out[i] < 0x20)\n  {\n    if ((((out[i] != '\\n') && (out[i] != '\\r')) && (out[i] != '\\t')) && (out[i] != 0x1B))\n      return 0;\n\n  }\n\n\n  i += unicode;\n}\n\nstatic int isLegalUTF8_char(const u8 *source, int length)\n{\n  u8 a;\n  int len;\n  const u8 *srcptr;\n  if ((*source) < 0xC0)\n    return 1;\n\n  len = exBytesUTF8[(*source) & 0x3f];\n  srcptr = source + len;\n  if ((len + 1) > length)\n    return -1;\n\n  switch (len)\n  {\n    default:\n      return -1;\n\n    case 4:\n      if (((a = *(--srcptr)) < 0x80) || (a > 0xBF))\n      return -1;\n\n\n    case 3:\n      if (((a = *(--srcptr)) < 0x80) || (a > 0xBF))\n      return -1;\n\n\n    case 2:\n      if (((a = *(--srcptr)) < 0x80) || (a > 0xBF))\n      return -1;\n\n      switch (*source)\n    {\n      case 0xE0:\n        if (a < 0xA0)\n        return -1;\n\n        break;\n\n      case 0xED:\n        if (a > 0x9F)\n        return -1;\n\n        break;\n\n      case 0xF0:\n        if (a < 0x90)\n        return -1;\n\n        break;\n\n      case 0xF4:\n        if (a > 0x8F)\n        return -1;\n\n\n    }\n\n\n    case 1:\n      if (((*source) >= 0x80) && ((*source) < 0xC2))\n      return -1;\n\n\n  }\n\n  if ((*source) > 0xF4)\n    return -1;\n\n  return len + 1;\n}\n\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < pSig->magic_count; ++i)\n{\n  int fnd = 1;\n  u8 *pS = pSig->magic_signature[i];\n  for (j = 0; j < pSig->magic_sig_len[i]; ++j)\n  {\n    if (p[j] != pS[j])\n    {\n      fnd = 0;\n      break;\n    }\n\n  }\n\n  if (fnd)\n    return 1;\n\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (;;)\n{\n  if ((have + 7) > ncode)\n    thisget = ncode - have;\n  else\n    thisget = 7;\n\n  have += thisget;\n  bits -= thisget * 3;\n  while (thisget--)\n  {\n    ++count[hold & 7];\n    hold >>= 3;\n  }\n\n  if (have == ncode)\n    break;\n\n  hold += ((u32) (*(++next))) << bits;\n  bits += 8;\n  hold += ((u32) (*(++next))) << bits;\n  bits += 8;\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 7; ++i)\n{\n  left <<= 1;\n  left -= count[i];\n  if (left < 0)\n    return 0;\n\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (;;)\n{\n  if (bits < 15)\n  {\n    if (left < 2)\n      return 1;\n\n    left -= 2;\n    hold += ((u32) (*(++next))) << bits;\n    bits += 8;\n    hold += ((u32) (*(++next))) << bits;\n    bits += 8;\n  }\n\n  here = lenfix[hold & 0x1FF];\n  op = (unsigned) here.bits;\n  hold >>= op;\n  bits -= op;\n  op = (unsigned) here.op;\n  if (op == 0)\n    ++whave;\n  else\n    if (op & 16)\n  {\n    len = (unsigned) here.val;\n    op &= 15;\n    if (op)\n    {\n      if (bits < op)\n      {\n        if (!left)\n          return 1;\n\n        --left;\n        hold += ((u32) (*(++next))) << bits;\n        bits += 8;\n      }\n\n      len += ((unsigned) hold) & ((1U << op) - 1);\n      hold >>= op;\n      bits -= op;\n    }\n\n    if (bits < 15)\n    {\n      if (left < 2)\n        return 1;\n\n      left -= 2;\n      hold += ((u32) (*(++next))) << bits;\n      bits += 8;\n      hold += ((u32) (*(++next))) << bits;\n      bits += 8;\n    }\n\n    here = distfix[hold & 0x1F];\n    op = (unsigned) here.bits;\n    hold >>= op;\n    bits -= op;\n    op = (unsigned) here.op;\n    if (op & 16)\n    {\n      u32 dist = (unsigned) here.val;\n      op &= 15;\n      if (bits < op)\n      {\n        if (!left)\n          return 1;\n\n        --left;\n        hold += ((u32) (*(++next))) << bits;\n        bits += 8;\n        if (bits < op)\n        {\n          if (!left)\n            return 1;\n\n          --left;\n          hold += ((u32) (*(++next))) << bits;\n          bits += 8;\n        }\n\n      }\n\n      dist += ((unsigned) hold) & ((1U << op) - 1);\n      if (dist > whave)\n        return 0;\n\n      hold >>= op;\n      bits -= op;\n      whave += len;\n    }\n    else\n      return 0;\n\n  }\n  else\n    if (op & 32)\n  {\n    if (left == 0)\n      return 1;\n\n    return 0;\n  }\n  else\n  {\n    return 0;\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  unsigned char out[32];\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  john_MD5_Update(&ctx, cur_salt->user, strlen((char *) cur_salt->user));\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n  hex_encode((unsigned char *) crypt_out[index], 16, out);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, out, 32);\n  john_MD5_Update(&ctx, cur_salt->salt, 4);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n{\n  out[0] = itoa16[str[i] >> 4];\n  out[1] = itoa16[str[i] & 0xF];\n  out += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n{\n  CRC32_t crc = 0;\n  unsigned char *p = (unsigned char *) saved_key[i];\n  while (*p)\n    crc = JTR_CRC32_table[(unsigned char) (crc ^ (*(p++)))] ^ (crc >> 8);\n\n  crypt_out[i] = crc;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; ++i)\n  if (crc == crypt_out[i])\n  return 1;\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha256_ctx ctx;\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, saved_key[index], strlen(saved_key[index]));\n  jtr_sha256_update(&ctx, cur_salt->salt, 32);\n  jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n  pwsafe_sha256_iterate(ctx.h, cur_salt->iterations);\n  memcpy(crypt_out[index], ctx.h, 32);\n}\n\nstatic void pwsafe_sha256_iterate(unsigned int *state, unsigned int iterations)\n{\n  unsigned int word00;\n  unsigned int word01;\n  unsigned int word02;\n  unsigned int word03;\n  unsigned int word04;\n  unsigned int word05;\n  unsigned int word06;\n  unsigned int word07;\n  unsigned int word08;\n  unsigned int word09;\n  unsigned int word10;\n  unsigned int word11;\n  unsigned int word12;\n  unsigned int word13;\n  unsigned int word14;\n  unsigned int word15;\n  unsigned int temp0;\n  unsigned int temp1;\n  unsigned int temp2;\n  unsigned int temp3;\n  unsigned int temp4;\n  unsigned int temp5;\n  unsigned int temp6;\n  unsigned int temp7;\n  iterations++;\n  word00 = state[0];\n  word01 = state[1];\n  word02 = state[2];\n  word03 = state[3];\n  word04 = state[4];\n  word05 = state[5];\n  word06 = state[6];\n  word07 = state[7];\n  while (iterations)\n  {\n    iterations--;\n    temp0 = 0x6a09e667UL;\n    temp1 = 0xbb67ae85UL;\n    temp2 = 0x3c6ef372UL;\n    temp3 = 0xa54ff53aUL;\n    temp4 = 0x510e527fUL;\n    temp5 = 0x9b05688cUL;\n    temp6 = 0x1f83d9abUL;\n    temp7 = 0x5be0cd19UL;\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0x428a2f98) + word00;\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0x71374491) + word01;\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0xb5c0fbcf) + word02;\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0xe9b5dba5) + word03;\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x3956c25b) + word04;\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0x59f111f1) + word05;\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x923f82a4) + word06;\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0xab1c5ed5) + word07;\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0xd807aa98) + (word08 = 0x80000000U);\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0x12835b01) + (word09 = 0);\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0x243185be) + (word10 = 0);\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0x550c7dc3) + (word11 = 0);\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x72be5d74) + (word12 = 0);\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0x80deb1fe) + (word13 = 0);\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x9bdc06a7) + (word14 = 0);\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0xc19bf174) + (word15 = 256);\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0xe49b69c1) + (word00 += (((((word14 >> 17) | (word14 << (32 - 17))) ^ ((word14 >> 19) | (word14 << (32 - 19)))) ^ (word14 >> 10)) + word09) + ((((word01 >> 7) | (word01 << (32 - 7))) ^ ((word01 >> 18) | (word01 << (32 - 18)))) ^ (word01 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0xefbe4786) + (word01 += (((((word15 >> 17) | (word15 << (32 - 17))) ^ ((word15 >> 19) | (word15 << (32 - 19)))) ^ (word15 >> 10)) + word10) + ((((word02 >> 7) | (word02 << (32 - 7))) ^ ((word02 >> 18) | (word02 << (32 - 18)))) ^ (word02 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0x0fc19dc6) + (word02 += (((((word00 >> 17) | (word00 << (32 - 17))) ^ ((word00 >> 19) | (word00 << (32 - 19)))) ^ (word00 >> 10)) + word11) + ((((word03 >> 7) | (word03 << (32 - 7))) ^ ((word03 >> 18) | (word03 << (32 - 18)))) ^ (word03 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0x240ca1cc) + (word03 += (((((word01 >> 17) | (word01 << (32 - 17))) ^ ((word01 >> 19) | (word01 << (32 - 19)))) ^ (word01 >> 10)) + word12) + ((((word04 >> 7) | (word04 << (32 - 7))) ^ ((word04 >> 18) | (word04 << (32 - 18)))) ^ (word04 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x2de92c6f) + (word04 += (((((word02 >> 17) | (word02 << (32 - 17))) ^ ((word02 >> 19) | (word02 << (32 - 19)))) ^ (word02 >> 10)) + word13) + ((((word05 >> 7) | (word05 << (32 - 7))) ^ ((word05 >> 18) | (word05 << (32 - 18)))) ^ (word05 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0x4a7484aa) + (word05 += (((((word03 >> 17) | (word03 << (32 - 17))) ^ ((word03 >> 19) | (word03 << (32 - 19)))) ^ (word03 >> 10)) + word14) + ((((word06 >> 7) | (word06 << (32 - 7))) ^ ((word06 >> 18) | (word06 << (32 - 18)))) ^ (word06 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x5cb0a9dc) + (word06 += (((((word04 >> 17) | (word04 << (32 - 17))) ^ ((word04 >> 19) | (word04 << (32 - 19)))) ^ (word04 >> 10)) + word15) + ((((word07 >> 7) | (word07 << (32 - 7))) ^ ((word07 >> 18) | (word07 << (32 - 18)))) ^ (word07 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0x76f988da) + (word07 += (((((word05 >> 17) | (word05 << (32 - 17))) ^ ((word05 >> 19) | (word05 << (32 - 19)))) ^ (word05 >> 10)) + word00) + ((((word08 >> 7) | (word08 << (32 - 7))) ^ ((word08 >> 18) | (word08 << (32 - 18)))) ^ (word08 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0x983e5152) + (word08 += (((((word06 >> 17) | (word06 << (32 - 17))) ^ ((word06 >> 19) | (word06 << (32 - 19)))) ^ (word06 >> 10)) + word01) + ((((word09 >> 7) | (word09 << (32 - 7))) ^ ((word09 >> 18) | (word09 << (32 - 18)))) ^ (word09 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0xa831c66d) + (word09 += (((((word07 >> 17) | (word07 << (32 - 17))) ^ ((word07 >> 19) | (word07 << (32 - 19)))) ^ (word07 >> 10)) + word02) + ((((word10 >> 7) | (word10 << (32 - 7))) ^ ((word10 >> 18) | (word10 << (32 - 18)))) ^ (word10 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0xb00327c8) + (word10 += (((((word08 >> 17) | (word08 << (32 - 17))) ^ ((word08 >> 19) | (word08 << (32 - 19)))) ^ (word08 >> 10)) + word03) + ((((word11 >> 7) | (word11 << (32 - 7))) ^ ((word11 >> 18) | (word11 << (32 - 18)))) ^ (word11 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0xbf597fc7) + (word11 += (((((word09 >> 17) | (word09 << (32 - 17))) ^ ((word09 >> 19) | (word09 << (32 - 19)))) ^ (word09 >> 10)) + word04) + ((((word12 >> 7) | (word12 << (32 - 7))) ^ ((word12 >> 18) | (word12 << (32 - 18)))) ^ (word12 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0xc6e00bf3) + (word12 += (((((word10 >> 17) | (word10 << (32 - 17))) ^ ((word10 >> 19) | (word10 << (32 - 19)))) ^ (word10 >> 10)) + word05) + ((((word13 >> 7) | (word13 << (32 - 7))) ^ ((word13 >> 18) | (word13 << (32 - 18)))) ^ (word13 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0xd5a79147) + (word13 += (((((word11 >> 17) | (word11 << (32 - 17))) ^ ((word11 >> 19) | (word11 << (32 - 19)))) ^ (word11 >> 10)) + word06) + ((((word14 >> 7) | (word14 << (32 - 7))) ^ ((word14 >> 18) | (word14 << (32 - 18)))) ^ (word14 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x06ca6351) + (word14 += (((((word12 >> 17) | (word12 << (32 - 17))) ^ ((word12 >> 19) | (word12 << (32 - 19)))) ^ (word12 >> 10)) + word07) + ((((word15 >> 7) | (word15 << (32 - 7))) ^ ((word15 >> 18) | (word15 << (32 - 18)))) ^ (word15 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0x14292967) + (word15 += (((((word13 >> 17) | (word13 << (32 - 17))) ^ ((word13 >> 19) | (word13 << (32 - 19)))) ^ (word13 >> 10)) + word08) + ((((word00 >> 7) | (word00 << (32 - 7))) ^ ((word00 >> 18) | (word00 << (32 - 18)))) ^ (word00 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0x27b70a85) + (word00 += (((((word14 >> 17) | (word14 << (32 - 17))) ^ ((word14 >> 19) | (word14 << (32 - 19)))) ^ (word14 >> 10)) + word09) + ((((word01 >> 7) | (word01 << (32 - 7))) ^ ((word01 >> 18) | (word01 << (32 - 18)))) ^ (word01 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0x2e1b2138) + (word01 += (((((word15 >> 17) | (word15 << (32 - 17))) ^ ((word15 >> 19) | (word15 << (32 - 19)))) ^ (word15 >> 10)) + word10) + ((((word02 >> 7) | (word02 << (32 - 7))) ^ ((word02 >> 18) | (word02 << (32 - 18)))) ^ (word02 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0x4d2c6dfc) + (word02 += (((((word00 >> 17) | (word00 << (32 - 17))) ^ ((word00 >> 19) | (word00 << (32 - 19)))) ^ (word00 >> 10)) + word11) + ((((word03 >> 7) | (word03 << (32 - 7))) ^ ((word03 >> 18) | (word03 << (32 - 18)))) ^ (word03 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0x53380d13) + (word03 += (((((word01 >> 17) | (word01 << (32 - 17))) ^ ((word01 >> 19) | (word01 << (32 - 19)))) ^ (word01 >> 10)) + word12) + ((((word04 >> 7) | (word04 << (32 - 7))) ^ ((word04 >> 18) | (word04 << (32 - 18)))) ^ (word04 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x650a7354) + (word04 += (((((word02 >> 17) | (word02 << (32 - 17))) ^ ((word02 >> 19) | (word02 << (32 - 19)))) ^ (word02 >> 10)) + word13) + ((((word05 >> 7) | (word05 << (32 - 7))) ^ ((word05 >> 18) | (word05 << (32 - 18)))) ^ (word05 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0x766a0abb) + (word05 += (((((word03 >> 17) | (word03 << (32 - 17))) ^ ((word03 >> 19) | (word03 << (32 - 19)))) ^ (word03 >> 10)) + word14) + ((((word06 >> 7) | (word06 << (32 - 7))) ^ ((word06 >> 18) | (word06 << (32 - 18)))) ^ (word06 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x81c2c92e) + (word06 += (((((word04 >> 17) | (word04 << (32 - 17))) ^ ((word04 >> 19) | (word04 << (32 - 19)))) ^ (word04 >> 10)) + word15) + ((((word07 >> 7) | (word07 << (32 - 7))) ^ ((word07 >> 18) | (word07 << (32 - 18)))) ^ (word07 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0x92722c85) + (word07 += (((((word05 >> 17) | (word05 << (32 - 17))) ^ ((word05 >> 19) | (word05 << (32 - 19)))) ^ (word05 >> 10)) + word00) + ((((word08 >> 7) | (word08 << (32 - 7))) ^ ((word08 >> 18) | (word08 << (32 - 18)))) ^ (word08 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0xa2bfe8a1) + (word08 += (((((word06 >> 17) | (word06 << (32 - 17))) ^ ((word06 >> 19) | (word06 << (32 - 19)))) ^ (word06 >> 10)) + word01) + ((((word09 >> 7) | (word09 << (32 - 7))) ^ ((word09 >> 18) | (word09 << (32 - 18)))) ^ (word09 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0xa81a664b) + (word09 += (((((word07 >> 17) | (word07 << (32 - 17))) ^ ((word07 >> 19) | (word07 << (32 - 19)))) ^ (word07 >> 10)) + word02) + ((((word10 >> 7) | (word10 << (32 - 7))) ^ ((word10 >> 18) | (word10 << (32 - 18)))) ^ (word10 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0xc24b8b70) + (word10 += (((((word08 >> 17) | (word08 << (32 - 17))) ^ ((word08 >> 19) | (word08 << (32 - 19)))) ^ (word08 >> 10)) + word03) + ((((word11 >> 7) | (word11 << (32 - 7))) ^ ((word11 >> 18) | (word11 << (32 - 18)))) ^ (word11 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0xc76c51a3) + (word11 += (((((word09 >> 17) | (word09 << (32 - 17))) ^ ((word09 >> 19) | (word09 << (32 - 19)))) ^ (word09 >> 10)) + word04) + ((((word12 >> 7) | (word12 << (32 - 7))) ^ ((word12 >> 18) | (word12 << (32 - 18)))) ^ (word12 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0xd192e819) + (word12 += (((((word10 >> 17) | (word10 << (32 - 17))) ^ ((word10 >> 19) | (word10 << (32 - 19)))) ^ (word10 >> 10)) + word05) + ((((word13 >> 7) | (word13 << (32 - 7))) ^ ((word13 >> 18) | (word13 << (32 - 18)))) ^ (word13 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0xd6990624) + (word13 += (((((word11 >> 17) | (word11 << (32 - 17))) ^ ((word11 >> 19) | (word11 << (32 - 19)))) ^ (word11 >> 10)) + word06) + ((((word14 >> 7) | (word14 << (32 - 7))) ^ ((word14 >> 18) | (word14 << (32 - 18)))) ^ (word14 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0xf40e3585) + (word14 += (((((word12 >> 17) | (word12 << (32 - 17))) ^ ((word12 >> 19) | (word12 << (32 - 19)))) ^ (word12 >> 10)) + word07) + ((((word15 >> 7) | (word15 << (32 - 7))) ^ ((word15 >> 18) | (word15 << (32 - 18)))) ^ (word15 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0x106aa070) + (word15 += (((((word13 >> 17) | (word13 << (32 - 17))) ^ ((word13 >> 19) | (word13 << (32 - 19)))) ^ (word13 >> 10)) + word08) + ((((word00 >> 7) | (word00 << (32 - 7))) ^ ((word00 >> 18) | (word00 << (32 - 18)))) ^ (word00 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0x19a4c116) + (word00 += (((((word14 >> 17) | (word14 << (32 - 17))) ^ ((word14 >> 19) | (word14 << (32 - 19)))) ^ (word14 >> 10)) + word09) + ((((word01 >> 7) | (word01 << (32 - 7))) ^ ((word01 >> 18) | (word01 << (32 - 18)))) ^ (word01 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0x1e376c08) + (word01 += (((((word15 >> 17) | (word15 << (32 - 17))) ^ ((word15 >> 19) | (word15 << (32 - 19)))) ^ (word15 >> 10)) + word10) + ((((word02 >> 7) | (word02 << (32 - 7))) ^ ((word02 >> 18) | (word02 << (32 - 18)))) ^ (word02 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0x2748774c) + (word02 += (((((word00 >> 17) | (word00 << (32 - 17))) ^ ((word00 >> 19) | (word00 << (32 - 19)))) ^ (word00 >> 10)) + word11) + ((((word03 >> 7) | (word03 << (32 - 7))) ^ ((word03 >> 18) | (word03 << (32 - 18)))) ^ (word03 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0x34b0bcb5) + (word03 += (((((word01 >> 17) | (word01 << (32 - 17))) ^ ((word01 >> 19) | (word01 << (32 - 19)))) ^ (word01 >> 10)) + word12) + ((((word04 >> 7) | (word04 << (32 - 7))) ^ ((word04 >> 18) | (word04 << (32 - 18)))) ^ (word04 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x391c0cb3) + (word04 += (((((word02 >> 17) | (word02 << (32 - 17))) ^ ((word02 >> 19) | (word02 << (32 - 19)))) ^ (word02 >> 10)) + word13) + ((((word05 >> 7) | (word05 << (32 - 7))) ^ ((word05 >> 18) | (word05 << (32 - 18)))) ^ (word05 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0x4ed8aa4a) + (word05 += (((((word03 >> 17) | (word03 << (32 - 17))) ^ ((word03 >> 19) | (word03 << (32 - 19)))) ^ (word03 >> 10)) + word14) + ((((word06 >> 7) | (word06 << (32 - 7))) ^ ((word06 >> 18) | (word06 << (32 - 18)))) ^ (word06 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0x5b9cca4f) + (word06 += (((((word04 >> 17) | (word04 << (32 - 17))) ^ ((word04 >> 19) | (word04 << (32 - 19)))) ^ (word04 >> 10)) + word15) + ((((word07 >> 7) | (word07 << (32 - 7))) ^ ((word07 >> 18) | (word07 << (32 - 18)))) ^ (word07 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0x682e6ff3) + (word07 += (((((word05 >> 17) | (word05 << (32 - 17))) ^ ((word05 >> 19) | (word05 << (32 - 19)))) ^ (word05 >> 10)) + word00) + ((((word08 >> 7) | (word08 << (32 - 7))) ^ ((word08 >> 18) | (word08 << (32 - 18)))) ^ (word08 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    temp7 += ((((((temp4 >> 6) | (temp4 << (32 - 6))) ^ ((temp4 >> 11) | (temp4 << (32 - 11)))) ^ ((temp4 >> 25) | (temp4 << (32 - 25)))) + (temp6 ^ (temp4 & (temp5 ^ temp6)))) + 0x748f82ee) + (word08 += (((((word06 >> 17) | (word06 << (32 - 17))) ^ ((word06 >> 19) | (word06 << (32 - 19)))) ^ (word06 >> 10)) + word01) + ((((word09 >> 7) | (word09 << (32 - 7))) ^ ((word09 >> 18) | (word09 << (32 - 18)))) ^ (word09 >> 3)));\n    temp3 += temp7;\n    temp7 += ((((temp0 >> 2) | (temp0 << (32 - 2))) ^ ((temp0 >> 13) | (temp0 << (32 - 13)))) ^ ((temp0 >> 22) | (temp0 << (32 - 22)))) + ((temp0 & temp1) | (temp2 & (temp0 | temp1)));\n    temp6 += ((((((temp3 >> 6) | (temp3 << (32 - 6))) ^ ((temp3 >> 11) | (temp3 << (32 - 11)))) ^ ((temp3 >> 25) | (temp3 << (32 - 25)))) + (temp5 ^ (temp3 & (temp4 ^ temp5)))) + 0x78a5636f) + (word09 += (((((word07 >> 17) | (word07 << (32 - 17))) ^ ((word07 >> 19) | (word07 << (32 - 19)))) ^ (word07 >> 10)) + word02) + ((((word10 >> 7) | (word10 << (32 - 7))) ^ ((word10 >> 18) | (word10 << (32 - 18)))) ^ (word10 >> 3)));\n    temp2 += temp6;\n    temp6 += ((((temp7 >> 2) | (temp7 << (32 - 2))) ^ ((temp7 >> 13) | (temp7 << (32 - 13)))) ^ ((temp7 >> 22) | (temp7 << (32 - 22)))) + ((temp7 & temp0) | (temp1 & (temp7 | temp0)));\n    temp5 += ((((((temp2 >> 6) | (temp2 << (32 - 6))) ^ ((temp2 >> 11) | (temp2 << (32 - 11)))) ^ ((temp2 >> 25) | (temp2 << (32 - 25)))) + (temp4 ^ (temp2 & (temp3 ^ temp4)))) + 0x84c87814) + (word10 += (((((word08 >> 17) | (word08 << (32 - 17))) ^ ((word08 >> 19) | (word08 << (32 - 19)))) ^ (word08 >> 10)) + word03) + ((((word11 >> 7) | (word11 << (32 - 7))) ^ ((word11 >> 18) | (word11 << (32 - 18)))) ^ (word11 >> 3)));\n    temp1 += temp5;\n    temp5 += ((((temp6 >> 2) | (temp6 << (32 - 2))) ^ ((temp6 >> 13) | (temp6 << (32 - 13)))) ^ ((temp6 >> 22) | (temp6 << (32 - 22)))) + ((temp6 & temp7) | (temp0 & (temp6 | temp7)));\n    temp4 += ((((((temp1 >> 6) | (temp1 << (32 - 6))) ^ ((temp1 >> 11) | (temp1 << (32 - 11)))) ^ ((temp1 >> 25) | (temp1 << (32 - 25)))) + (temp3 ^ (temp1 & (temp2 ^ temp3)))) + 0x8cc70208) + (word11 += (((((word09 >> 17) | (word09 << (32 - 17))) ^ ((word09 >> 19) | (word09 << (32 - 19)))) ^ (word09 >> 10)) + word04) + ((((word12 >> 7) | (word12 << (32 - 7))) ^ ((word12 >> 18) | (word12 << (32 - 18)))) ^ (word12 >> 3)));\n    temp0 += temp4;\n    temp4 += ((((temp5 >> 2) | (temp5 << (32 - 2))) ^ ((temp5 >> 13) | (temp5 << (32 - 13)))) ^ ((temp5 >> 22) | (temp5 << (32 - 22)))) + ((temp5 & temp6) | (temp7 & (temp5 | temp6)));\n    temp3 += ((((((temp0 >> 6) | (temp0 << (32 - 6))) ^ ((temp0 >> 11) | (temp0 << (32 - 11)))) ^ ((temp0 >> 25) | (temp0 << (32 - 25)))) + (temp2 ^ (temp0 & (temp1 ^ temp2)))) + 0x90befffa) + (word12 += (((((word10 >> 17) | (word10 << (32 - 17))) ^ ((word10 >> 19) | (word10 << (32 - 19)))) ^ (word10 >> 10)) + word05) + ((((word13 >> 7) | (word13 << (32 - 7))) ^ ((word13 >> 18) | (word13 << (32 - 18)))) ^ (word13 >> 3)));\n    temp7 += temp3;\n    temp3 += ((((temp4 >> 2) | (temp4 << (32 - 2))) ^ ((temp4 >> 13) | (temp4 << (32 - 13)))) ^ ((temp4 >> 22) | (temp4 << (32 - 22)))) + ((temp4 & temp5) | (temp6 & (temp4 | temp5)));\n    temp2 += ((((((temp7 >> 6) | (temp7 << (32 - 6))) ^ ((temp7 >> 11) | (temp7 << (32 - 11)))) ^ ((temp7 >> 25) | (temp7 << (32 - 25)))) + (temp1 ^ (temp7 & (temp0 ^ temp1)))) + 0xa4506ceb) + (word13 += (((((word11 >> 17) | (word11 << (32 - 17))) ^ ((word11 >> 19) | (word11 << (32 - 19)))) ^ (word11 >> 10)) + word06) + ((((word14 >> 7) | (word14 << (32 - 7))) ^ ((word14 >> 18) | (word14 << (32 - 18)))) ^ (word14 >> 3)));\n    temp6 += temp2;\n    temp2 += ((((temp3 >> 2) | (temp3 << (32 - 2))) ^ ((temp3 >> 13) | (temp3 << (32 - 13)))) ^ ((temp3 >> 22) | (temp3 << (32 - 22)))) + ((temp3 & temp4) | (temp5 & (temp3 | temp4)));\n    temp1 += ((((((temp6 >> 6) | (temp6 << (32 - 6))) ^ ((temp6 >> 11) | (temp6 << (32 - 11)))) ^ ((temp6 >> 25) | (temp6 << (32 - 25)))) + (temp0 ^ (temp6 & (temp7 ^ temp0)))) + 0xbef9a3f7) + (word14 += (((((word12 >> 17) | (word12 << (32 - 17))) ^ ((word12 >> 19) | (word12 << (32 - 19)))) ^ (word12 >> 10)) + word07) + ((((word15 >> 7) | (word15 << (32 - 7))) ^ ((word15 >> 18) | (word15 << (32 - 18)))) ^ (word15 >> 3)));\n    temp5 += temp1;\n    temp1 += ((((temp2 >> 2) | (temp2 << (32 - 2))) ^ ((temp2 >> 13) | (temp2 << (32 - 13)))) ^ ((temp2 >> 22) | (temp2 << (32 - 22)))) + ((temp2 & temp3) | (temp4 & (temp2 | temp3)));\n    temp0 += ((((((temp5 >> 6) | (temp5 << (32 - 6))) ^ ((temp5 >> 11) | (temp5 << (32 - 11)))) ^ ((temp5 >> 25) | (temp5 << (32 - 25)))) + (temp7 ^ (temp5 & (temp6 ^ temp7)))) + 0xc67178f2) + (word15 += (((((word13 >> 17) | (word13 << (32 - 17))) ^ ((word13 >> 19) | (word13 << (32 - 19)))) ^ (word13 >> 10)) + word08) + ((((word00 >> 7) | (word00 << (32 - 7))) ^ ((word00 >> 18) | (word00 << (32 - 18)))) ^ (word00 >> 3)));\n    temp4 += temp0;\n    temp0 += ((((temp1 >> 2) | (temp1 << (32 - 2))) ^ ((temp1 >> 13) | (temp1 << (32 - 13)))) ^ ((temp1 >> 22) | (temp1 << (32 - 22)))) + ((temp1 & temp2) | (temp3 & (temp1 | temp2)));\n    word00 = 0x6a09e667UL + temp0;\n    word01 = 0xbb67ae85UL + temp1;\n    word02 = 0x3c6ef372UL + temp2;\n    word03 = 0xa54ff53aUL + temp3;\n    word04 = 0x510e527fUL + temp4;\n    word05 = 0x9b05688cUL + temp5;\n    word06 = 0x1f83d9abUL + temp6;\n    word07 = 0x5be0cd19UL + temp7;\n  }\n\n  state[0] = word00;\n  state[1] = word01;\n  state[2] = word02;\n  state[3] = word03;\n  state[4] = word04;\n  state[5] = word05;\n  state[6] = word06;\n  state[7] = word07;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < niter; i++)\n{\n  pi = pi + (pow(-1, i) * (4 / ((2 * ((double) i)) + 1)));\n}\n\n", "pragma": "omp parallel for reduction(+ : pi)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (index = 0; index < tot_todo; index += inc)\n{\n  {\n    int i;\n    int len = saved_len[index];\n    char *pass = saved_key[index];\n    switch (cur_salt->type)\n    {\n      case 5:\n      {\n        MD5_CTX ctx;\n        john_MD5_Init(&ctx);\n        john_MD5_Update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          john_MD5_Update(&ctx, pass, len);\n\n        john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 256:\n      {\n        jtr_sha256_ctx ctx;\n        jtr_sha256_init(&ctx, 1);\n        jtr_sha256_update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          jtr_sha256_update(&ctx, pass, len);\n\n        jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 512:\n      {\n        jtr_sha512_ctx ctx;\n        jtr_sha512_init(&ctx, 1);\n        jtr_sha512_update(&ctx, cur_salt->salt, cur_salt->len);\n        if ((len && ((128 % len) == 0)) && ((cur_salt->len + (len * cur_salt->rounds)) > 256))\n        {\n          int ex;\n          for (i = 0; i <= cur_salt->rounds; ++i)\n          {\n            jtr_sha512_update(&ctx, pass, len);\n            if (ctx.total > (128 + cur_salt->len))\n              break;\n\n          }\n\n          ++i;\n          ex = (256 - ctx.total) / len;\n          i += ex;\n          ctx.total += ex * len;\n          jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n          while ((i + (128 / len)) <= cur_salt->rounds)\n          {\n            ctx.total += 128;\n            jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n            i += 128 / len;\n          }\n\n          for (; i <= cur_salt->rounds; ++i)\n            ctx.total += len;\n\n        }\n        else\n        {\n          for (i = 0; i <= cur_salt->rounds; ++i)\n            jtr_sha512_update(&ctx, pass, len);\n\n        }\n\n        ctx.bIsQnxBuggy = 1;\n        jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n    }\n\n  }\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(struct qnx_saltstruct)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, saved_key[index], sizeof(saved_key[index]));\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  sph_sha1_context ctx;\n  if (new_keys)\n  {\n    sph_sha1_init(&ipad_ctx[index]);\n    sph_sha1(&ipad_ctx[index], ipad[index], 64);\n    sph_sha1_init(&opad_ctx[index]);\n    sph_sha1(&opad_ctx[index], opad[index], 64);\n  }\n\n  memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n  sph_sha1(&ctx, cur_salt.salt, cur_salt.length);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n  memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n  sph_sha1(&ctx, crypt_key[index], 20);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char PswCheckValue[32];\n  unsigned char PswCheck[8];\n  int i;\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, 16, cur_salt->iterations + 32, PswCheckValue, 32, 0);\n  memset(PswCheck, 0, sizeof(PswCheck));\n  for (i = 0; i < 32; i++)\n    PswCheck[i % 8] ^= PswCheckValue[i];\n\n  memcpy((void *) crypt_out[index], PswCheck, 8);\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  (void) blake2b((uint8_t *) crypt_out[index], saved_key[index], 0, 64, saved_len[index], 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  Keccak_HashInstance hash;\n  Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n  Keccak_HashUpdate(&hash, (unsigned char *) saved_key[index], saved_len[index] * 8);\n  Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  Keccak_HashInstance hash;\n  Keccak_HashInitialize(&hash, 576, 1024, 512, 0x01);\n  Keccak_HashUpdate(&hash, (unsigned char *) saved_key[index], saved_len[index] * 8);\n  Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < loops; index++)\n{\n  MD4_CTX ctx;\n  john_MD4_Init(&ctx);\n  john_MD4_Update(&ctx, saved_key[index], saved_len[index]);\n  john_MD4_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  temp = ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 0])]) << 4;\n  temp |= (unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 1])];\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 2])]) << 12;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 3])]) << 8;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 4])]) << 20;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 5])]) << 16;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 6])]) << 28;\n  temp |= ((unsigned int) atoi16[ARCH_INDEX(ciphertext[(i * 8) + 7])]) << 24;\n  out[i] = __builtin_bswap32(temp);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 8; j++)\n  *(p++) = itoa16[(b[i] >> ((j ^ 1) * 4)) & 0xf];\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_key[index], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < loops; ++index)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  for (j = 0; j < 8; j++)\n  *(p++) = itoa16[(hash[i] >> ((j ^ 1) * 4)) & 0xf];\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha256_ctx ctx;\n  jtr_sha256_init(&ctx, 0);\n  jtr_sha256_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 28; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha256_ctx ctx;\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha256_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 0);\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 48; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint64_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint64_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  union \n  {\n    uint8_t u8[80];\n    uint64_t u64[10];\n  } kdf_out;\n  int t = omp_get_thread_num();\n  if (t >= max_threads)\n  {\n    failed = -1;\n    continue;\n  }\n\n  if (yescrypt_kdf(0, &local[t], (const uint8_t *) saved_key[index], strlen(saved_key[index]), (const uint8_t *) cur_salt->salt, sizeof(cur_salt->salt), &params, kdf_out.u8, 64))\n  {\n    failed = (errno) ? (errno) : (EINVAL);\n  }\n\n  static const union \n  {\n    uint8_t u8[16];\n    uint64_t u64[2];\n  } key_mask = {.u8 = {0xff, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0x0f}};\n  kdf_out.u64[6] &= key_mask.u64[0];\n  kdf_out.u64[7] &= key_mask.u64[1];\n  const uint8_t *poly1305_key = &kdf_out.u8[32];\n  const unsigned char *nonce = cur_salt->data;\n  const unsigned char *ciphertext = cur_salt->data + 16;\n  AES_KEY aeskey;\n  JTR_AES_set_encrypt_key(poly1305_key, 128, &aeskey);\n  unsigned char *prepared_key = &kdf_out.u8[48];\n  (1 == 1) ? (JTR_AES_encrypt(nonce, prepared_key + 16, &aeskey)) : (JTR_AES_decrypt(nonce, prepared_key + 16, &aeskey));\n  john_poly1305_auth((unsigned char *) crypt_out[index], ciphertext, 128, prepared_key);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_free_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  c[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(cur_salt->salt)); i++)\n  cur_salt->salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(cur_salt->data)); i++)\n  cur_salt->data[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, failed, params, max_threads, local, saved_key, cur_salt, crypt_out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_ripemd160_context ctx;\n  sph_ripemd160_init(&ctx);\n  sph_ripemd160(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_ripemd160_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_ripemd128_context ctx;\n  sph_ripemd128_init(&ctx);\n  sph_ripemd128(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_ripemd128_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += inc)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  sph_sha1(&ctx, (unsigned char *) saved_salt->data.c, saved_salt->len);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == ((uint32_t *) (&crypt_key[index][0]))[0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; idx += 1)\n{\n  sph_sha1_context ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 20];\n  unsigned char *cp = &tmp[len];\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, saved_plain[idx], len);\n  sph_sha1(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 20;\n  sph_sha1_close(&ctx, cp);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, tmp, len);\n    sph_sha1_close(&ctx, cp);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; idx += 1)\n{\n  jtr_sha256_ctx ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 32];\n  unsigned char *cp = &tmp[len];\n  jtr_sha256_init(&ctx, 1);\n  jtr_sha256_update(&ctx, saved_plain[idx], len);\n  jtr_sha256_update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 32;\n  jtr_sha256_final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, tmp, len);\n    jtr_sha256_final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; idx += 1)\n{\n  jtr_sha512_ctx ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 48];\n  unsigned char *cp = &tmp[len];\n  jtr_sha512_init(&ctx, 0);\n  jtr_sha512_update(&ctx, saved_plain[idx], len);\n  jtr_sha512_update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 48;\n  jtr_sha512_final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    jtr_sha512_init(&ctx, 0);\n    jtr_sha512_update(&ctx, tmp, len);\n    jtr_sha512_final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; idx += 1)\n{\n  jtr_sha512_ctx ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 64];\n  unsigned char *cp = &tmp[len];\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_plain[idx], len);\n  jtr_sha512_update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 64;\n  jtr_sha512_final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, tmp, len);\n    jtr_sha512_final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_key[index])))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(struct sapH_salt)); i++)\n  hash = ((hash << 5) + hash) ^ cp[i];\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (bits = 0; bits < srcbits; bits += 6)\n{\n  if (dstlen < 2)\n    return 0;\n\n  *(dst++) = itoa64[src & 0x3f];\n  dstlen--;\n  src >>= 6;\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (bits = 0; bits < dstbits; bits += 6)\n{\n  uint32_t c = atoi64[*(src++)];\n  if (c > 63)\n  {\n    *dst = 0;\n    return 0;\n  }\n\n  *dst |= c << bits;\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_free_local(&local[i]);\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = ciphertext + ((sizeof(\"$7$\")) - 1); p < (ciphertext + (((((sizeof(\"$7$\")) - 1) + 1) + 5) + 5)); p++)\n  if (atoi64[ARCH_INDEX(*p)] == 0x7F)\n  return 0;\n\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!strncmp((char *) binary, buffer[index].out, len))\n  return 1;\n\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf1_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], 20, 0);\n}\n\nstatic void pbkdf1_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(struct saltstruct)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < tot_todo; index += 1)\n{\n  union xx\n  {\n    unsigned char c[32];\n    long a[32 / (sizeof(long))];\n  } u;\n  unsigned char *temp_result = u.c;\n  jtr_sha256_ctx ctx;\n  jtr_sha256_ctx alt_ctx;\n  size_t cnt;\n  int idx;\n  char *cp;\n  char p_bytes[35 + 1];\n  char s_bytes[35 + 1];\n  char tmp_cls[(sizeof(cryptloopstruct)) + 16];\n  cryptloopstruct *crypt_struct;\n  crypt_struct = (cryptloopstruct *) ((void *) (((char *) tmp_cls) + ((16 - 1) - ((((size_t) ((char *) tmp_cls)) - 1) & (16 - 1)))));\n  for (idx = 0; idx < 1; ++idx)\n  {\n    jtr_sha256_init(&ctx, 1);\n    jtr_sha256_update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha256_update(&ctx, cur_salt->salt, cur_salt->len);\n    jtr_sha256_init(&alt_ctx, 1);\n    jtr_sha256_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha256_update(&alt_ctx, cur_salt->salt, cur_salt->len);\n    jtr_sha256_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha256_final((unsigned char *) crypt_out[MixOrder[index + idx]], &alt_ctx);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 32; cnt -= 32)\n      jtr_sha256_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 32);\n\n    jtr_sha256_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], cnt);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 0; cnt >>= 1)\n      if ((cnt & 1) != 0)\n      jtr_sha256_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 32);\n    else\n      jtr_sha256_update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n\n    jtr_sha256_final((unsigned char *) crypt_out[MixOrder[index + idx]], &ctx);\n    jtr_sha256_init(&alt_ctx, 1);\n    for (cnt = 0; cnt < saved_len[MixOrder[index + idx]]; ++cnt)\n      jtr_sha256_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n    jtr_sha256_final(temp_result, &alt_ctx);\n    cp = p_bytes;\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt >= 32; cnt -= 32)\n      cp = ((char *) memcpy(cp, temp_result, 32)) + 32;\n\n    memcpy(cp, temp_result, cnt);\n    jtr_sha256_init(&alt_ctx, 1);\n    for (cnt = 0; cnt < (16 + ((unsigned char *) crypt_out[MixOrder[index + idx]])[0]); ++cnt)\n      jtr_sha256_update(&alt_ctx, cur_salt->salt, cur_salt->len);\n\n    jtr_sha256_final(temp_result, &alt_ctx);\n    cp = s_bytes;\n    for (cnt = cur_salt->len; cnt >= 32; cnt -= 32)\n      cp = ((char *) memcpy(cp, temp_result, 32)) + 32;\n\n    memcpy(cp, temp_result, cnt);\n    LoadCryptStruct(crypt_struct, MixOrder[index + idx], idx, p_bytes, s_bytes);\n  }\n\n  idx = 0;\n  jtr_sha256_init(&ctx, 1);\n  for (cnt = 1;; ++cnt)\n  {\n    jtr_sha256_update(&ctx, crypt_struct->bufs[0][idx], crypt_struct->datlen[idx]);\n    if (cnt == cur_salt->rounds)\n      break;\n\n    memcpy(crypt_struct->cptr[0][idx], ctx.h, 32);\n    if ((++idx) == 42)\n      idx = 0;\n\n    memcpy(ctx.h, ctx_init, sizeof(ctx_init));\n  }\n\n  memcpy(crypt_out[MixOrder[index]], ctx.h, 32);\n}\n\nstatic void LoadCryptStruct(cryptloopstruct *crypt_struct, int index, int idx, char *p_bytes, char *s_bytes)\n{\n  unsigned len_pc;\n  unsigned len_ppsc;\n  unsigned len_ppc;\n  unsigned len_psc;\n  unsigned tot_pc;\n  unsigned tot_ppsc;\n  unsigned tot_ppc;\n  unsigned tot_psc;\n  unsigned off_pc;\n  unsigned off_pspc;\n  unsigned off_ppc;\n  unsigned off_psc;\n  unsigned dlen_pc;\n  unsigned dlen_ppsc;\n  unsigned dlen_ppc;\n  unsigned dlen_psc;\n  unsigned plen = saved_len[index];\n  unsigned char *cp = crypt_struct->buf;\n  cryptloopstruct *pstr = crypt_struct;\n  len_pc = plen + 32;\n  len_ppsc = ((plen << 1) + cur_salt->len) + 32;\n  len_ppc = (plen << 1) + 32;\n  len_psc = (plen + cur_salt->len) + 32;\n  if (len_pc <= 55)\n  {\n    tot_pc = 64;\n    dlen_pc = 64;\n  }\n  else\n  {\n    tot_pc = 128;\n    dlen_pc = 128;\n  }\n\n  if (len_ppsc <= 55)\n  {\n    tot_ppsc = 64;\n    dlen_ppsc = 64;\n  }\n  else\n  {\n    tot_ppsc = 128;\n    dlen_ppsc = 128;\n  }\n\n  if (len_ppc <= 55)\n  {\n    tot_ppc = 64;\n    dlen_ppc = 64;\n  }\n  else\n  {\n    tot_ppc = 128;\n    dlen_ppc = 128;\n  }\n\n  if (len_psc <= 55)\n  {\n    tot_psc = 64;\n    dlen_psc = 64;\n  }\n  else\n  {\n    tot_psc = 128;\n    dlen_psc = 128;\n  }\n\n  off_pc = len_pc - 32;\n  off_pspc = len_ppsc - 32;\n  off_ppc = len_ppc - 32;\n  off_psc = len_psc - 32;\n  pstr->bufs[idx][0] = (pstr->cptr[idx][41] = cp);\n  memcpy(cp, crypt_out[index], 32);\n  cp += 32;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[0] = dlen_pc;\n\n  memcpy(cp, padding, (tot_pc - 2) - len_pc);\n  cp += tot_pc - len_pc;\n  pstr->bufs[idx][0][tot_pc - 2] = (len_pc << 3) >> 8;\n  pstr->bufs[idx][0][tot_pc - 1] = (len_pc << 3) & 0xFF;\n  pstr->bufs[idx][1] = cp;\n  pstr->cptr[idx][0] = cp + off_pspc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 32;\n  if (!idx)\n    pstr->datlen[1] = dlen_ppsc;\n\n  memcpy(cp, padding, (tot_ppsc - 2) - len_ppsc);\n  cp += tot_ppsc - len_ppsc;\n  pstr->bufs[idx][1][tot_ppsc - 2] = (len_ppsc << 3) >> 8;\n  pstr->bufs[idx][1][tot_ppsc - 1] = (len_ppsc << 3) & 0xFF;\n  pstr->bufs[idx][2] = (pstr->cptr[idx][1] = cp);\n  cp += 32;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[2] = dlen_ppsc;\n\n  memcpy(cp, padding, (tot_ppsc - 2) - len_ppsc);\n  cp += tot_ppsc - len_ppsc;\n  pstr->bufs[idx][2][tot_ppsc - 2] = (len_ppsc << 3) >> 8;\n  pstr->bufs[idx][2][tot_ppsc - 1] = (len_ppsc << 3) & 0xFF;\n  pstr->bufs[idx][3] = cp;\n  pstr->cptr[idx][2] = cp + off_ppc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 32;\n  if (!idx)\n    pstr->datlen[3] = dlen_ppc;\n\n  memcpy(cp, padding, (tot_ppc - 2) - len_ppc);\n  cp += tot_ppc - len_ppc;\n  pstr->bufs[idx][3][tot_ppc - 2] = (len_ppc << 3) >> 8;\n  pstr->bufs[idx][3][tot_ppc - 1] = (len_ppc << 3) & 0xFF;\n  pstr->bufs[idx][4] = (pstr->cptr[idx][3] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[4] = dlen_ppsc;\n\n  pstr->bufs[idx][5] = pstr->bufs[idx][1];\n  pstr->cptr[idx][4] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[5] = dlen_ppsc;\n\n  pstr->bufs[idx][6] = (pstr->cptr[idx][5] = cp);\n  cp += 32;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[6] = dlen_ppc;\n\n  memcpy(cp, padding, (tot_ppc - 2) - len_ppc);\n  cp += tot_ppc - len_ppc;\n  pstr->bufs[idx][6][tot_ppc - 2] = (len_ppc << 3) >> 8;\n  pstr->bufs[idx][6][tot_ppc - 1] = (len_ppc << 3) & 0xFF;\n  pstr->bufs[idx][7] = cp;\n  pstr->cptr[idx][6] = cp + off_psc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len + 32;\n  if (!idx)\n    pstr->datlen[7] = dlen_psc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_psc);\n  cp += tot_psc - len_psc;\n  pstr->bufs[idx][7][tot_psc - 2] = (len_psc << 3) >> 8;\n  pstr->bufs[idx][7][tot_psc - 1] = (len_psc << 3) & 0xFF;\n  pstr->bufs[idx][8] = (pstr->cptr[idx][7] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[8] = dlen_ppsc;\n\n  pstr->bufs[idx][9] = pstr->bufs[idx][3];\n  pstr->cptr[idx][8] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[9] = dlen_ppc;\n\n  pstr->bufs[idx][10] = (pstr->cptr[idx][9] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[10] = dlen_ppsc;\n\n  pstr->bufs[idx][11] = pstr->bufs[idx][1];\n  pstr->cptr[idx][10] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[11] = dlen_ppsc;\n\n  pstr->bufs[idx][12] = (pstr->cptr[idx][11] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[12] = dlen_ppc;\n\n  pstr->bufs[idx][13] = pstr->bufs[idx][1];\n  pstr->cptr[idx][12] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[13] = dlen_ppsc;\n\n  pstr->bufs[idx][14] = (pstr->cptr[idx][13] = cp);\n  cp += 32;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[14] = dlen_psc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_psc);\n  cp += tot_psc - len_psc;\n  pstr->bufs[idx][14][tot_psc - 2] = (len_psc << 3) >> 8;\n  pstr->bufs[idx][14][tot_psc - 1] = (len_psc << 3) & 0xFF;\n  pstr->bufs[idx][15] = pstr->bufs[idx][3];\n  pstr->cptr[idx][14] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[15] = dlen_ppc;\n\n  pstr->bufs[idx][16] = (pstr->cptr[idx][15] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[16] = dlen_ppsc;\n\n  pstr->bufs[idx][17] = pstr->bufs[idx][1];\n  pstr->cptr[idx][16] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[17] = dlen_ppsc;\n\n  pstr->bufs[idx][18] = (pstr->cptr[idx][17] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[18] = dlen_ppc;\n\n  pstr->bufs[idx][19] = pstr->bufs[idx][1];\n  pstr->cptr[idx][18] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[19] = dlen_ppsc;\n\n  pstr->bufs[idx][20] = (pstr->cptr[idx][19] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[20] = dlen_ppsc;\n\n  pstr->bufs[idx][21] = cp;\n  pstr->cptr[idx][20] = cp + off_pc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 32;\n  if (!idx)\n    pstr->datlen[21] = dlen_pc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_pc);\n  pstr->bufs[idx][21][tot_pc - 2] = (len_pc << 3) >> 8;\n  pstr->bufs[idx][21][tot_pc - 1] = (len_pc << 3) & 0xFF;\n  pstr->bufs[idx][22] = (pstr->cptr[idx][21] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[22] = dlen_ppsc;\n\n  pstr->bufs[idx][23] = pstr->bufs[idx][1];\n  pstr->cptr[idx][22] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[23] = dlen_ppsc;\n\n  pstr->bufs[idx][24] = (pstr->cptr[idx][23] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[24] = dlen_ppc;\n\n  pstr->bufs[idx][25] = pstr->bufs[idx][1];\n  pstr->cptr[idx][24] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[25] = dlen_ppsc;\n\n  pstr->bufs[idx][26] = (pstr->cptr[idx][25] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[26] = dlen_ppsc;\n\n  pstr->bufs[idx][27] = pstr->bufs[idx][3];\n  pstr->cptr[idx][26] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[27] = dlen_ppc;\n\n  pstr->bufs[idx][28] = (pstr->cptr[idx][27] = pstr->bufs[idx][14]);\n  if (!idx)\n    pstr->datlen[28] = dlen_psc;\n\n  pstr->bufs[idx][29] = pstr->bufs[idx][1];\n  pstr->cptr[idx][28] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[29] = dlen_ppsc;\n\n  pstr->bufs[idx][30] = (pstr->cptr[idx][29] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[30] = dlen_ppc;\n\n  pstr->bufs[idx][31] = pstr->bufs[idx][1];\n  pstr->cptr[idx][30] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[31] = dlen_ppsc;\n\n  pstr->bufs[idx][32] = (pstr->cptr[idx][31] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[32] = dlen_ppsc;\n\n  pstr->bufs[idx][33] = pstr->bufs[idx][3];\n  pstr->cptr[idx][32] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[33] = dlen_ppc;\n\n  pstr->bufs[idx][34] = (pstr->cptr[idx][33] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[34] = dlen_ppsc;\n\n  pstr->bufs[idx][35] = pstr->bufs[idx][7];\n  pstr->cptr[idx][34] = pstr->cptr[idx][6];\n  if (!idx)\n    pstr->datlen[35] = dlen_psc;\n\n  pstr->bufs[idx][36] = (pstr->cptr[idx][35] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[36] = dlen_ppc;\n\n  pstr->bufs[idx][37] = pstr->bufs[idx][1];\n  pstr->cptr[idx][36] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[37] = dlen_ppsc;\n\n  pstr->bufs[idx][38] = (pstr->cptr[idx][37] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[38] = dlen_ppsc;\n\n  pstr->bufs[idx][39] = pstr->bufs[idx][3];\n  pstr->cptr[idx][38] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[39] = dlen_ppc;\n\n  pstr->bufs[idx][40] = (pstr->cptr[idx][39] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[40] = dlen_ppsc;\n\n  pstr->bufs[idx][41] = pstr->bufs[idx][1];\n  pstr->cptr[idx][40] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[41] = dlen_ppsc;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; ++index)\n  MixOrder[index] = index;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(struct saltstruct)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  Keccak_HashInstance hash;\n  Keccak_HashInitialize(&hash, 576, 1024, 512, 0x06);\n  Keccak_HashUpdate(&hash, (unsigned char *) saved_key[index], saved_len[index] * 8);\n  Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < tot_todo; index += 1)\n{\n  union xx\n  {\n    unsigned char c[64];\n    long a[64 / (sizeof(long))];\n  } u;\n  unsigned char *temp_result = u.c;\n  jtr_sha512_ctx ctx;\n  jtr_sha512_ctx alt_ctx;\n  size_t cnt;\n  int idx;\n  char *cp;\n  char p_bytes[79 + 1];\n  char s_bytes[79 + 1];\n  char tmp_cls[(sizeof(cryptloopstruct)) + 16];\n  cryptloopstruct *crypt_struct;\n  crypt_struct = (cryptloopstruct *) ((void *) (((char *) tmp_cls) + ((16 - 1) - ((((size_t) ((char *) tmp_cls)) - 1) & (16 - 1)))));\n  for (idx = 0; idx < 1; ++idx)\n  {\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha512_update(&ctx, cur_salt->salt, cur_salt->len);\n    jtr_sha512_init(&alt_ctx, 1);\n    jtr_sha512_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha512_update(&alt_ctx, cur_salt->salt, cur_salt->len);\n    jtr_sha512_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    jtr_sha512_final((unsigned char *) crypt_out[MixOrder[index + idx]], &alt_ctx);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 64; cnt -= 64)\n      jtr_sha512_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 64);\n\n    jtr_sha512_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], cnt);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 0; cnt >>= 1)\n      if ((cnt & 1) != 0)\n      jtr_sha512_update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 64);\n    else\n      jtr_sha512_update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n\n    jtr_sha512_final((unsigned char *) crypt_out[MixOrder[index + idx]], &ctx);\n    jtr_sha512_init(&alt_ctx, 1);\n    for (cnt = 0; cnt < saved_len[MixOrder[index + idx]]; ++cnt)\n      jtr_sha512_update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n    jtr_sha512_final(temp_result, &alt_ctx);\n    cp = p_bytes;\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt >= 64; cnt -= 64)\n      cp = ((char *) memcpy(cp, temp_result, 64)) + 64;\n\n    memcpy(cp, temp_result, cnt);\n    jtr_sha512_init(&alt_ctx, 1);\n    for (cnt = 0; cnt < (16 + ((unsigned char *) crypt_out[MixOrder[index + idx]])[0]); ++cnt)\n      jtr_sha512_update(&alt_ctx, cur_salt->salt, cur_salt->len);\n\n    jtr_sha512_final(temp_result, &alt_ctx);\n    cp = s_bytes;\n    for (cnt = cur_salt->len; cnt >= 64; cnt -= 64)\n      cp = ((char *) memcpy(cp, temp_result, 64)) + 64;\n\n    memcpy(cp, temp_result, cnt);\n    LoadCryptStruct(crypt_struct, MixOrder[index + idx], idx, p_bytes, s_bytes);\n  }\n\n  idx = 0;\n  jtr_sha512_init(&ctx, 1);\n  for (cnt = 1;; ++cnt)\n  {\n    jtr_sha512_update(&ctx, crypt_struct->bufs[0][idx], crypt_struct->datlen[idx]);\n    if (cnt == cur_salt->rounds)\n      break;\n\n    memcpy(crypt_struct->cptr[0][idx], ctx.h, 64);\n    if ((++idx) == 42)\n      idx = 0;\n\n    memcpy(ctx.h, ctx_init, sizeof(ctx_init));\n  }\n\n  memcpy(crypt_out[MixOrder[index]], ctx.h, 64);\n}\n\nstatic void LoadCryptStruct(cryptloopstruct *crypt_struct, int index, int idx, char *p_bytes, char *s_bytes)\n{\n  unsigned len_pc;\n  unsigned len_ppsc;\n  unsigned len_ppc;\n  unsigned len_psc;\n  unsigned tot_pc;\n  unsigned tot_ppsc;\n  unsigned tot_ppc;\n  unsigned tot_psc;\n  unsigned off_pc;\n  unsigned off_pspc;\n  unsigned off_ppc;\n  unsigned off_psc;\n  unsigned dlen_pc;\n  unsigned dlen_ppsc;\n  unsigned dlen_ppc;\n  unsigned dlen_psc;\n  unsigned plen = saved_len[index];\n  unsigned char *cp = crypt_struct->buf;\n  cryptloopstruct *pstr = crypt_struct;\n  len_pc = plen + 64;\n  len_ppsc = ((plen << 1) + cur_salt->len) + 64;\n  len_ppc = (plen << 1) + 64;\n  len_psc = (plen + cur_salt->len) + 64;\n  if (len_pc <= 111)\n  {\n    tot_pc = 128;\n    dlen_pc = 128;\n  }\n  else\n  {\n    tot_pc = 256;\n    dlen_pc = 256;\n  }\n\n  if (len_ppsc <= 111)\n  {\n    tot_ppsc = 128;\n    dlen_ppsc = 128;\n  }\n  else\n  {\n    tot_ppsc = 256;\n    dlen_ppsc = 256;\n  }\n\n  if (len_ppc <= 111)\n  {\n    tot_ppc = 128;\n    dlen_ppc = 128;\n  }\n  else\n  {\n    tot_ppc = 256;\n    dlen_ppc = 256;\n  }\n\n  if (len_psc <= 111)\n  {\n    tot_psc = 128;\n    dlen_psc = 128;\n  }\n  else\n  {\n    tot_psc = 256;\n    dlen_psc = 256;\n  }\n\n  off_pc = len_pc - 64;\n  off_pspc = len_ppsc - 64;\n  off_ppc = len_ppc - 64;\n  off_psc = len_psc - 64;\n  pstr->bufs[idx][0] = (pstr->cptr[idx][41] = cp);\n  memcpy(cp, crypt_out[index], 64);\n  cp += 64;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[0] = dlen_pc;\n\n  memcpy(cp, padding, (tot_pc - 2) - len_pc);\n  cp += tot_pc - len_pc;\n  pstr->bufs[idx][0][tot_pc - 2] = (len_pc << 3) >> 8;\n  pstr->bufs[idx][0][tot_pc - 1] = (len_pc << 3) & 0xFF;\n  pstr->bufs[idx][1] = cp;\n  pstr->cptr[idx][0] = cp + off_pspc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 64;\n  if (!idx)\n    pstr->datlen[1] = dlen_ppsc;\n\n  memcpy(cp, padding, (tot_ppsc - 2) - len_ppsc);\n  cp += tot_ppsc - len_ppsc;\n  pstr->bufs[idx][1][tot_ppsc - 2] = (len_ppsc << 3) >> 8;\n  pstr->bufs[idx][1][tot_ppsc - 1] = (len_ppsc << 3) & 0xFF;\n  pstr->bufs[idx][2] = (pstr->cptr[idx][1] = cp);\n  cp += 64;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[2] = dlen_ppsc;\n\n  memcpy(cp, padding, (tot_ppsc - 2) - len_ppsc);\n  cp += tot_ppsc - len_ppsc;\n  pstr->bufs[idx][2][tot_ppsc - 2] = (len_ppsc << 3) >> 8;\n  pstr->bufs[idx][2][tot_ppsc - 1] = (len_ppsc << 3) & 0xFF;\n  pstr->bufs[idx][3] = cp;\n  pstr->cptr[idx][2] = cp + off_ppc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 64;\n  if (!idx)\n    pstr->datlen[3] = dlen_ppc;\n\n  memcpy(cp, padding, (tot_ppc - 2) - len_ppc);\n  cp += tot_ppc - len_ppc;\n  pstr->bufs[idx][3][tot_ppc - 2] = (len_ppc << 3) >> 8;\n  pstr->bufs[idx][3][tot_ppc - 1] = (len_ppc << 3) & 0xFF;\n  pstr->bufs[idx][4] = (pstr->cptr[idx][3] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[4] = dlen_ppsc;\n\n  pstr->bufs[idx][5] = pstr->bufs[idx][1];\n  pstr->cptr[idx][4] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[5] = dlen_ppsc;\n\n  pstr->bufs[idx][6] = (pstr->cptr[idx][5] = cp);\n  cp += 64;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[6] = dlen_ppc;\n\n  memcpy(cp, padding, (tot_ppc - 2) - len_ppc);\n  cp += tot_ppc - len_ppc;\n  pstr->bufs[idx][6][tot_ppc - 2] = (len_ppc << 3) >> 8;\n  pstr->bufs[idx][6][tot_ppc - 1] = (len_ppc << 3) & 0xFF;\n  pstr->bufs[idx][7] = cp;\n  pstr->cptr[idx][6] = cp + off_psc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len + 64;\n  if (!idx)\n    pstr->datlen[7] = dlen_psc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_psc);\n  cp += tot_psc - len_psc;\n  pstr->bufs[idx][7][tot_psc - 2] = (len_psc << 3) >> 8;\n  pstr->bufs[idx][7][tot_psc - 1] = (len_psc << 3) & 0xFF;\n  pstr->bufs[idx][8] = (pstr->cptr[idx][7] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[8] = dlen_ppsc;\n\n  pstr->bufs[idx][9] = pstr->bufs[idx][3];\n  pstr->cptr[idx][8] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[9] = dlen_ppc;\n\n  pstr->bufs[idx][10] = (pstr->cptr[idx][9] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[10] = dlen_ppsc;\n\n  pstr->bufs[idx][11] = pstr->bufs[idx][1];\n  pstr->cptr[idx][10] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[11] = dlen_ppsc;\n\n  pstr->bufs[idx][12] = (pstr->cptr[idx][11] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[12] = dlen_ppc;\n\n  pstr->bufs[idx][13] = pstr->bufs[idx][1];\n  pstr->cptr[idx][12] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[13] = dlen_ppsc;\n\n  pstr->bufs[idx][14] = (pstr->cptr[idx][13] = cp);\n  cp += 64;\n  memcpy(cp, s_bytes, cur_salt->len);\n  cp += cur_salt->len;\n  memcpy(cp, p_bytes, plen);\n  cp += plen;\n  if (!idx)\n    pstr->datlen[14] = dlen_psc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_psc);\n  cp += tot_psc - len_psc;\n  pstr->bufs[idx][14][tot_psc - 2] = (len_psc << 3) >> 8;\n  pstr->bufs[idx][14][tot_psc - 1] = (len_psc << 3) & 0xFF;\n  pstr->bufs[idx][15] = pstr->bufs[idx][3];\n  pstr->cptr[idx][14] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[15] = dlen_ppc;\n\n  pstr->bufs[idx][16] = (pstr->cptr[idx][15] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[16] = dlen_ppsc;\n\n  pstr->bufs[idx][17] = pstr->bufs[idx][1];\n  pstr->cptr[idx][16] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[17] = dlen_ppsc;\n\n  pstr->bufs[idx][18] = (pstr->cptr[idx][17] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[18] = dlen_ppc;\n\n  pstr->bufs[idx][19] = pstr->bufs[idx][1];\n  pstr->cptr[idx][18] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[19] = dlen_ppsc;\n\n  pstr->bufs[idx][20] = (pstr->cptr[idx][19] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[20] = dlen_ppsc;\n\n  pstr->bufs[idx][21] = cp;\n  pstr->cptr[idx][20] = cp + off_pc;\n  memcpy(cp, p_bytes, plen);\n  cp += plen + 64;\n  if (!idx)\n    pstr->datlen[21] = dlen_pc;\n\n  memcpy(cp, padding, (tot_psc - 2) - len_pc);\n  pstr->bufs[idx][21][tot_pc - 2] = (len_pc << 3) >> 8;\n  pstr->bufs[idx][21][tot_pc - 1] = (len_pc << 3) & 0xFF;\n  pstr->bufs[idx][22] = (pstr->cptr[idx][21] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[22] = dlen_ppsc;\n\n  pstr->bufs[idx][23] = pstr->bufs[idx][1];\n  pstr->cptr[idx][22] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[23] = dlen_ppsc;\n\n  pstr->bufs[idx][24] = (pstr->cptr[idx][23] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[24] = dlen_ppc;\n\n  pstr->bufs[idx][25] = pstr->bufs[idx][1];\n  pstr->cptr[idx][24] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[25] = dlen_ppsc;\n\n  pstr->bufs[idx][26] = (pstr->cptr[idx][25] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[26] = dlen_ppsc;\n\n  pstr->bufs[idx][27] = pstr->bufs[idx][3];\n  pstr->cptr[idx][26] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[27] = dlen_ppc;\n\n  pstr->bufs[idx][28] = (pstr->cptr[idx][27] = pstr->bufs[idx][14]);\n  if (!idx)\n    pstr->datlen[28] = dlen_psc;\n\n  pstr->bufs[idx][29] = pstr->bufs[idx][1];\n  pstr->cptr[idx][28] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[29] = dlen_ppsc;\n\n  pstr->bufs[idx][30] = (pstr->cptr[idx][29] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[30] = dlen_ppc;\n\n  pstr->bufs[idx][31] = pstr->bufs[idx][1];\n  pstr->cptr[idx][30] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[31] = dlen_ppsc;\n\n  pstr->bufs[idx][32] = (pstr->cptr[idx][31] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[32] = dlen_ppsc;\n\n  pstr->bufs[idx][33] = pstr->bufs[idx][3];\n  pstr->cptr[idx][32] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[33] = dlen_ppc;\n\n  pstr->bufs[idx][34] = (pstr->cptr[idx][33] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[34] = dlen_ppsc;\n\n  pstr->bufs[idx][35] = pstr->bufs[idx][7];\n  pstr->cptr[idx][34] = pstr->cptr[idx][6];\n  if (!idx)\n    pstr->datlen[35] = dlen_psc;\n\n  pstr->bufs[idx][36] = (pstr->cptr[idx][35] = pstr->bufs[idx][6]);\n  if (!idx)\n    pstr->datlen[36] = dlen_ppc;\n\n  pstr->bufs[idx][37] = pstr->bufs[idx][1];\n  pstr->cptr[idx][36] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[37] = dlen_ppsc;\n\n  pstr->bufs[idx][38] = (pstr->cptr[idx][37] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[38] = dlen_ppsc;\n\n  pstr->bufs[idx][39] = pstr->bufs[idx][3];\n  pstr->cptr[idx][38] = pstr->cptr[idx][2];\n  if (!idx)\n    pstr->datlen[39] = dlen_ppc;\n\n  pstr->bufs[idx][40] = (pstr->cptr[idx][39] = pstr->bufs[idx][2]);\n  if (!idx)\n    pstr->datlen[40] = dlen_ppsc;\n\n  pstr->bufs[idx][41] = pstr->bufs[idx][1];\n  pstr->cptr[idx][40] = pstr->cptr[idx][0];\n  if (!idx)\n    pstr->datlen[41] = dlen_ppsc;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; ++index)\n  MixOrder[index] = index;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char key[16];\n  int keylen = 16;\n  unsigned char hash[20];\n  pkcs12_pbe_derive_key(1, cur_salt->iterations, 1, (unsigned char *) saved_key[index], saved_len[index], cur_salt->mac_salt, cur_salt->mac_salt_size, key, keylen);\n  JTR_hmac_sha1(key, keylen, cur_salt->master_secret, cur_salt->master_secret_size - 20, hash, 20);\n  cracked[index] = !memcmp(hash, (cur_salt->master_secret + cur_salt->master_secret_size) - 20, 20);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (len = 0; ciphertext[len] != '$'; len++)\n  ;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (sizeof(struct saltstruct)); i++)\n  hash = ((hash << 5) + hash) ^ s[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.mac_salt_size; i++)\n  cs.mac_salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.master_secret_size; i++)\n  cs.master_secret[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX md5_ctx;\n  unsigned char md5_bin_hash[16];\n  char dynamic_hash[32 + 1];\n  memcpy(&md5_ctx, &pSalt->ctx_dyna_data, sizeof(md5_ctx));\n  john_MD5_Update(&md5_ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  john_MD5_Final(md5_bin_hash, &md5_ctx);\n  bin_to_hex(bin2hex_table, md5_bin_hash, 16, dynamic_hash, 32);\n  john_MD5_Init(&md5_ctx);\n  john_MD5_Update(&md5_ctx, (unsigned char *) dynamic_hash, 32);\n  john_MD5_Update(&md5_ctx, (unsigned char *) pSalt->static_hash_data, pSalt->static_hash_data_len);\n  john_MD5_Final((unsigned char *) crypt_key[index], &md5_ctx);\n}\n\nvoid bin_to_hex(char bin2hex_table[256][2], const unsigned char *bin_buffer, size_t bin_buffer_size, char *hex_buffer, size_t hex_buffer_size)\n{\n  unsigned i;\n  for (i = 0; i < bin_buffer_size; ++i)\n  {\n    hex_buffer[i * 2] = bin2hex_table[bin_buffer[i]][0];\n    hex_buffer[(i * 2) + 1] = bin2hex_table[bin_buffer[i]][1];\n  }\n\n  hex_buffer[bin_buffer_size * 2] = 0x00;\n  return;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < strlen(ciphertext); i++)\n  if (ciphertext[i] == '*')\n  res++;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  bin_val[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == ((uint32_t *) (&crypt_key[index][0]))[0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_skein256_context ctx;\n  sph_skein256_init(&ctx);\n  sph_skein256(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_skein256_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_skein512_context ctx;\n  sph_skein512_init(&ctx);\n  sph_skein512(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_skein512_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 28))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, (unsigned char *) saved_key[index], 15);\n  sph_sha1(&ctx, (unsigned char *) saved_salt, 9);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_key[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == ((uint32_t *) (&crypt_key[index][0]))[0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  snefru_ctx ctx;\n  ;\n  rhash_snefru256_init(&ctx);\n  rhash_snefru_update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  rhash_snefru_final(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  snefru_ctx ctx;\n  ;\n  rhash_snefru128_init(&ctx);\n  rhash_snefru_update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  rhash_snefru_final(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 32; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 16))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  HMACMD5Context ctx;\n  unsigned char authKey[20];\n  unsigned char out[20];\n  if (cur_salt->authProtocol == 1)\n  {\n    snmp_usm_password_to_key_md5((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_md5_init_rfc2104(authKey, 16, &ctx);\n    hmac_md5_update(cur_salt->salt, cur_salt->salt_length, &ctx);\n    hmac_md5_final(out, &ctx);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n    else\n      cracked[index] = 0;\n\n  }\n  else\n    if (cur_salt->authProtocol == 2)\n  {\n    snmp_usm_password_to_key_sha((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    JTR_hmac_sha1(authKey, 20, cur_salt->salt, cur_salt->salt_length, out, 12);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n    else\n      cracked[index] = 0;\n\n  }\n  else\n    if (cur_salt->authProtocol == 0)\n  {\n    cracked[index] = 0;\n    snmp_usm_password_to_key_md5((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_md5_init_rfc2104(authKey, 16, &ctx);\n    hmac_md5_update(cur_salt->salt, cur_salt->salt_length, &ctx);\n    hmac_md5_final(out, &ctx);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n    {\n      cracked[index] = 1;\n      continue;\n    }\n\n    snmp_usm_password_to_key_sha((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    JTR_hmac_sha1(authKey, 20, cur_salt->salt, cur_salt->salt_length, out, 12);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n\n  }\n\n\n\n}\n\nstatic void snmp_usm_password_to_key_md5(const uint8_t *password, uint32_t passwordlen, const uint8_t *engineID, uint32_t engineLength, uint8_t *key)\n{\n  uint8_t *cp;\n  uint8_t password_buf[64];\n  uint32_t password_index = 0;\n  uint32_t count = 0;\n  uint32_t i;\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  while (count < 1048576)\n  {\n    cp = password_buf;\n    if (passwordlen != 0)\n    {\n      for (i = 0; i < 64; i++)\n      {\n        *(cp++) = password[password_index++];\n        if (password_index >= passwordlen)\n          password_index = 0;\n\n      }\n\n    }\n    else\n    {\n      *cp = 0;\n    }\n\n    john_MD5_Update(&ctx, password_buf, 64);\n    count += 64;\n  }\n\n  john_MD5_Final(key, &ctx);\n  memcpy(password_buf, key, 16);\n  memcpy(password_buf + 16, engineID, engineLength);\n  memcpy((password_buf + 16) + engineLength, key, 16);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, password_buf, 32 + engineLength);\n  john_MD5_Final(key, &ctx);\n}\n\n\nstatic void snmp_usm_password_to_key_sha(const uint8_t *password, uint32_t passwordlen, const uint8_t *engineID, uint32_t engineLength, uint8_t *key)\n{\n  uint8_t *cp;\n  uint8_t password_buf[72];\n  uint32_t password_index = 0;\n  uint32_t count = 0;\n  uint32_t i;\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  while (count < 1048576)\n  {\n    cp = password_buf;\n    if (passwordlen != 0)\n    {\n      for (i = 0; i < 64; i++)\n      {\n        *(cp++) = password[password_index++];\n        if (password_index >= passwordlen)\n          password_index = 0;\n\n      }\n\n    }\n    else\n    {\n      *cp = 0;\n    }\n\n    sph_sha1(&ctx, password_buf, 64);\n    count += 64;\n  }\n\n  sph_sha1_close(&ctx, key);\n  memcpy(password_buf, key, 20);\n  memcpy(password_buf + 20, engineID, engineLength);\n  memcpy((password_buf + 20) + engineLength, key, 20);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, password_buf, 40 + engineLength);\n  sph_sha1_close(&ctx, key);\n}\n\n\nstatic void snmp_usm_password_to_key_md5(const uint8_t *password, uint32_t passwordlen, const uint8_t *engineID, uint32_t engineLength, uint8_t *key)\n{\n  uint8_t *cp;\n  uint8_t password_buf[64];\n  uint32_t password_index = 0;\n  uint32_t count = 0;\n  uint32_t i;\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  while (count < 1048576)\n  {\n    cp = password_buf;\n    if (passwordlen != 0)\n    {\n      for (i = 0; i < 64; i++)\n      {\n        *(cp++) = password[password_index++];\n        if (password_index >= passwordlen)\n          password_index = 0;\n\n      }\n\n    }\n    else\n    {\n      *cp = 0;\n    }\n\n    john_MD5_Update(&ctx, password_buf, 64);\n    count += 64;\n  }\n\n  john_MD5_Final(key, &ctx);\n  memcpy(password_buf, key, 16);\n  memcpy(password_buf + 16, engineID, engineLength);\n  memcpy((password_buf + 16) + engineLength, key, 16);\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, password_buf, 32 + engineLength);\n  john_MD5_Final(key, &ctx);\n}\n\n\nstatic void snmp_usm_password_to_key_sha(const uint8_t *password, uint32_t passwordlen, const uint8_t *engineID, uint32_t engineLength, uint8_t *key)\n{\n  uint8_t *cp;\n  uint8_t password_buf[72];\n  uint32_t password_index = 0;\n  uint32_t count = 0;\n  uint32_t i;\n  sph_sha1_context ctx;\n  sph_sha1_init(&ctx);\n  while (count < 1048576)\n  {\n    cp = password_buf;\n    if (passwordlen != 0)\n    {\n      for (i = 0; i < 64; i++)\n      {\n        *(cp++) = password[password_index++];\n        if (password_index >= passwordlen)\n          password_index = 0;\n\n      }\n\n    }\n    else\n    {\n      *cp = 0;\n    }\n\n    sph_sha1(&ctx, password_buf, 64);\n    count += 64;\n  }\n\n  sph_sha1_close(&ctx, key);\n  memcpy(password_buf, key, 20);\n  memcpy(password_buf + 20, engineID, engineLength);\n  memcpy((password_buf + 20) + engineLength, key, 20);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, password_buf, 40 + engineLength);\n  sph_sha1_close(&ctx, key);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.engineLength; i++)\n  cs.engineID[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 12; i++)\n  cs.msgAuthenticationParameters[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  *(cp++) = password[password_index++];\n  if (password_index >= passwordlen)\n    password_index = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n{\n  *(cp++) = password[password_index++];\n  if (password_index >= passwordlen)\n    password_index = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][1024];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), (unsigned char *) cur_salt->salt, 8, 1000, master[i], 1024, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    jtr_sha512_ctx ctx;\n    jtr_sha512_init(&ctx, 1);\n    jtr_sha512_update(&ctx, master[i], 1024);\n    jtr_sha512_final((unsigned char *) crypt_out[index + i], &ctx);\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  jtr_sha512_ctx ctx;\n  jtr_sha512_init(&ctx, 1);\n  jtr_sha512_update(&ctx, saved_key[index], saved_len[index]);\n  jtr_sha512_update(&ctx, saved_salt->data.c, saved_salt->len);\n  jtr_sha512_final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  uint32_t c;\n  sph_sha1_context ctx;\n  jtr_sha256_ctx sctx;\n  jtr_sha512_ctx sctx2;\n  MD5_CTX mctx;\n  unsigned char buf[64];\n  if (cur_salt->fmt == 0)\n  {\n    john_MD5_Init(&mctx);\n    john_MD5_Update(&mctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    john_MD5_Final(buf, &mctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      john_MD5_Init(&mctx);\n      john_MD5_Update(&mctx, buf, 16);\n      john_MD5_Final(buf, &mctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 1)\n  {\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    sph_sha1_close(&ctx, buf);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, buf, 20);\n      sph_sha1_close(&ctx, buf);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 2)\n  {\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, cur_salt->salt, cur_salt->saltlen);\n    sph_sha1(&ctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    sph_sha1_close(&ctx, buf);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      sph_sha1_init(&ctx);\n      sph_sha1(&ctx, buf, 20);\n      sph_sha1_close(&ctx, buf);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 3)\n  {\n    jtr_sha256_init(&sctx, 1);\n    jtr_sha256_update(&sctx, cur_salt->salt, cur_salt->saltlen);\n    jtr_sha256_update(&sctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    jtr_sha256_final(buf, &sctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      jtr_sha256_init(&sctx, 1);\n      jtr_sha256_update(&sctx, buf, 32);\n      jtr_sha256_final(buf, &sctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 4)\n  {\n    jtr_sha512_init(&sctx2, 1);\n    jtr_sha512_update(&sctx2, cur_salt->salt, cur_salt->saltlen);\n    jtr_sha512_update(&sctx2, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    jtr_sha512_final(buf, &sctx2);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      jtr_sha512_init(&sctx2, 1);\n      jtr_sha512_update(&sctx2, buf, 64);\n      jtr_sha512_final(buf, &sctx2);\n    }\n\n  }\n\n\n\n\n\n  memcpy(crypt_out[index], buf, 16);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  unsigned char output[24];\n  unsigned char *iv_in;\n  unsigned char iv_out[16];\n  int size;\n  int i;\n  int page_sz = 1008;\n  int reserve_sz = 16;\n  AES_KEY akey;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, 16, 4000, master[0], 32, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    size = page_sz - reserve_sz;\n    iv_in = (cur_salt->data + size) + 16;\n    memcpy(iv_out, iv_in, 16);\n    JTR_AES_set_decrypt_key(master[i], 256, &akey);\n    JTR_AES_cbc_encrypt(cur_salt->data + 16, output + 16, 8, &akey, iv_out, 0);\n    if (strip_verify_page(output) == 0)\n    {\n      cracked[index + i] = 1;\n    }\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (group_idx = 0; group_idx < ngroups; ++group_idx)\n{\n  int roundasciilen;\n  int round;\n  int maxrounds = 4096 + getrounds(saved_salt);\n  char roundascii[8];\n  int idx_begin = group_idx * group_sz;\n  int idx_end = ((idx_begin + group_sz) > count) ? (count) : (idx_begin + group_sz);\n  roundascii[0] = '0';\n  roundascii[1] = 0;\n  roundasciilen = 1;\n  for (round = 0; round < maxrounds; round++)\n  {\n    for (idx = idx_begin; idx < idx_end; ++idx)\n    {\n      pConx px = &data[idx];\n      int indirect_a = (md5bit(px->digest, round)) ? ((((((coin_step(px->digest, 1, 4, 0) | coin_step(px->digest, 2, 5, 1)) | coin_step(px->digest, 3, 6, 2)) | coin_step(px->digest, 4, 7, 3)) | coin_step(px->digest, 5, 8, 4)) | coin_step(px->digest, 6, 9, 5)) | coin_step(px->digest, 7, 10, 6)) : ((((((coin_step(px->digest, 0, 3, 0) | coin_step(px->digest, 1, 4, 1)) | coin_step(px->digest, 2, 5, 2)) | coin_step(px->digest, 3, 6, 3)) | coin_step(px->digest, 4, 7, 4)) | coin_step(px->digest, 5, 8, 5)) | coin_step(px->digest, 6, 9, 6));\n      int indirect_b = (md5bit(px->digest, round + 64)) ? ((((((coin_step(px->digest, 9, 12, 0) | coin_step(px->digest, 10, 13, 1)) | coin_step(px->digest, 11, 14, 2)) | coin_step(px->digest, 12, 15, 3)) | coin_step(px->digest, 13, 0, 4)) | coin_step(px->digest, 14, 1, 5)) | coin_step(px->digest, 15, 2, 6)) : ((((((coin_step(px->digest, 8, 11, 0) | coin_step(px->digest, 9, 12, 1)) | coin_step(px->digest, 10, 13, 2)) | coin_step(px->digest, 11, 14, 3)) | coin_step(px->digest, 12, 15, 4)) | coin_step(px->digest, 13, 0, 5)) | coin_step(px->digest, 14, 1, 6));\n      int bit = md5bit(px->digest, indirect_a) ^ md5bit(px->digest, indirect_b);\n      john_MD5_Init(&px->context);\n      john_MD5_Update(&px->context, px->digest, sizeof(px->digest));\n      if (bit)\n        john_MD5_Update(&px->context, (unsigned char *) constant_phrase, 1517);\n\n      john_MD5_Update(&px->context, (unsigned char *) roundascii, roundasciilen);\n      john_MD5_Final(px->digest, &px->context);\n    }\n\n    if ((++roundascii[roundasciilen - 1]) == ('9' + 1))\n    {\n      int j = roundasciilen - 1;\n      if (j > 0)\n      {\n        do\n        {\n          roundascii[j] = '0';\n          ++roundascii[--j];\n        }\n        while ((j > 0) && (roundascii[j] == ('9' + 1)));\n      }\n\n      if ((!j) && (roundascii[0] == ('9' + 1)))\n      {\n        roundascii[0] = '1';\n        roundascii[roundasciilen++] = '0';\n        roundascii[roundasciilen] = 0;\n      }\n\n    }\n\n  }\n\n}\n\nstatic unsigned int getrounds(const char *s)\n{\n  char *r;\n  char *p;\n  char *e;\n  long val;\n  if (s == 0)\n    return 0;\n\n  if ((r = strstr(s, \"rounds=\")) == 0)\n  {\n    return 0;\n  }\n\n  if (strncmp(r, \"rounds=\", 7) != 0)\n  {\n    return 0;\n  }\n\n  p = r + 7;\n  val = strtol(p, &e, 10);\n  if ((val < 0) || (!((((*e) == '\\0') || ((*e) == ',')) || ((*e) == '$'))))\n  {\n    fprintf(stderr, \"crypt_sunmd5: invalid rounds specification \\\"%s\\\"\", s);\n    return 0;\n  }\n\n  return (unsigned int) val;\n}\n\n\ninline static int md5bit(unsigned char *digest, int bit_num)\n{\n  return (digest[(bit_num >> 3) & 0xF] >> (bit_num & 7)) & 1;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int md5bit(unsigned char *digest, int bit_num)\n{\n  return (digest[(bit_num >> 3) & 0xF] >> (bit_num & 7)) & 1;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int coin_step(unsigned char *digest, int i, int j, int shift)\n{\n  return md5bit(digest, digest[(digest[i] >> mod5[digest[j]]) & 0x0F] >> ((digest[j] >> (digest[i] & 0x07)) & 0x01)) << shift;\n}\n\n\ninline static int md5bit(unsigned char *digest, int bit_num)\n{\n  return (digest[(bit_num >> 3) & 0xF] >> (bit_num & 7)) & 1;\n}\n\n\ninline static int md5bit(unsigned char *digest, int bit_num)\n{\n  return (digest[(bit_num >> 3) & 0xF] >> (bit_num & 7)) & 1;\n}\n\n\n", "pragma": "omp parallel for private(idx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 0x100; i++)\n  mod5[i] = i % 5;\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_out[index])))\n  return 1;\n\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; ++idx)\n{\n  john_MD5_Init(&data[idx].context);\n  john_MD5_Update(&data[idx].context, (unsigned char *) saved_key[idx], strlen(saved_key[idx]));\n  john_MD5_Update(&data[idx].context, (unsigned char *) saved_salt, strlen(saved_salt));\n  john_MD5_Final(data[idx].digest, &data[idx].context);\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < count; ++idx)\n{\n  pConx px = &data[idx];\n  memcpy(crypt_out[idx], px->digest, 16);\n}\n\n", "pragma": "omp parallel for private(idx)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, cur_salt->salt, cur_salt->length);\n  john_MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_tiger_context ctx;\n  sph_tiger_init(&ctx);\n  sph_tiger(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_tiger_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 24; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i += psalt->loop_inc)\n{\n  unsigned char key[64];\n  int j;\n  int ksz = strlen((char *) key_buffer[i]);\n  {\n    strncpy((char *) key, (char *) key_buffer[i], 64);\n    if (psalt->nkeyfiles)\n    {\n      apply_keyfiles(key, 64, psalt->nkeyfiles);\n      ksz = 64;\n    }\n\n  }\n  if (psalt->hash_type == 1)\n  {\n    pbkdf2_sha512((const unsigned char *) key, ksz, psalt->salt, 64, psalt->num_iterations, key, sizeof(key), 0);\n  }\n  else\n    if ((psalt->hash_type == 2) || (psalt->hash_type == 4))\n    pbkdf2_ripemd160((const unsigned char *) key, ksz, psalt->salt, 64, psalt->num_iterations, key, sizeof(key), 0);\n  else\n    pbkdf2_whirlpool((const unsigned char *) key, ksz, psalt->salt, 64, psalt->num_iterations, key, sizeof(key), 0);\n\n\n  for (j = 0; j < psalt->loop_inc; ++j)\n  {\n    cracked[i + j] = 0;\n    if (decrypt_and_verify(key, 0))\n      cracked[i + j] = 1;\n    else\n    {\n      if (decrypt_and_verify(key, 1))\n        cracked[i + j] = 1;\n      else\n      {\n        if (decrypt_and_verify(key, 2))\n          cracked[i + j] = 1;\n\n      }\n\n    }\n\n  }\n\n}\n\nstatic int apply_keyfiles(unsigned char *pass, size_t pass_memsz, int nkeyfiles)\n{\n  int pl;\n  int k;\n  unsigned char *kpool;\n  unsigned char *kdata;\n  int kpool_idx;\n  size_t i;\n  size_t kdata_sz;\n  uint32_t crc;\n  if (pass_memsz < 64)\n  {\n    real_error(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 403);\n  }\n\n  pl = strlen((char *) pass);\n  memset(pass + pl, 0, 64 - pl);\n  if ((kpool = mem_calloc(1, 64)) == 0)\n  {\n    real_error(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 410);\n  }\n\n  for (k = 0; k < nkeyfiles; k++)\n  {\n    kpool_idx = 0;\n    kdata_sz = keyfiles_length[k];\n    kdata = keyfiles_data[k];\n    crc = ~0U;\n    for (i = 0; i < kdata_sz; i++)\n    {\n      crc = JTR_CRC32_table[(unsigned char) (crc ^ kdata[i])] ^ (crc >> 8);\n      kpool[kpool_idx++] += (unsigned char) (crc >> 24);\n      kpool[kpool_idx++] += (unsigned char) (crc >> 16);\n      kpool[kpool_idx++] += (unsigned char) (crc >> 8);\n      kpool[kpool_idx++] += (unsigned char) crc;\n      if (kpool_idx == 64)\n        kpool_idx = 0;\n\n    }\n\n  }\n\n  for (i = 0; i < 64; i++)\n    pass[i] += kpool[i];\n\n  {\n    if (kpool)\n    {\n      free(kpool);\n      kpool = 0;\n    }\n\n  }\n  ;\n  return 0;\n}\n\n\nstatic void pbkdf2_sha512(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint64_t x64[64 / (sizeof(uint64_t))];\n    unsigned char out[64];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha512_ctx ipad;\n  jtr_sha512_ctx opad;\n  _pbkdf2_sha512_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (64 - 1)) / 64;\n  loop = (skip_bytes / 64) + 1;\n  skip_bytes %= 64;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha512(S, SL, R, tmp.x64, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 64) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_ripemd160(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_ripemd160_context ipad;\n  sph_ripemd160_context opad;\n  _pbkdf2_ripemd160_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_ripemd160(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_whirlpool(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[(512 / 8) / (sizeof(uint32_t))];\n    unsigned char out[512 / 8];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_whirlpool_context ipad;\n  sph_whirlpool_context opad;\n  _pbkdf2_whirlpool_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + ((512 / 8) - 1)) / (512 / 8);\n  loop = (skip_bytes / (512 / 8)) + 1;\n  skip_bytes %= 512 / 8;\n  while (loop <= loops)\n  {\n    _pbkdf2_whirlpool(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < (512 / 8)) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int decrypt_and_verify(unsigned char *key, int algorithm)\n{\n  unsigned char decr_header[512 - 64];\n  CRC32_t check_sum;\n  switch (algorithm)\n  {\n    case 0:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 0);\n      break;\n\n    case 1:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 1);\n      break;\n\n    case 2:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 2);\n      break;\n\n  }\n\n  if (memcmp(decr_header, \"TRUE\", 4))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, &decr_header[256 - 64], 256);\n  if (!cmp_crc32s(&decr_header[8], ~check_sum))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, decr_header, (256 - 64) - 4);\n  if (!cmp_crc32s(&decr_header[(256 - 64) - 4], ~check_sum))\n    return 0;\n\n  return 1;\n}\n\n\nstatic int decrypt_and_verify(unsigned char *key, int algorithm)\n{\n  unsigned char decr_header[512 - 64];\n  CRC32_t check_sum;\n  switch (algorithm)\n  {\n    case 0:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 0);\n      break;\n\n    case 1:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 1);\n      break;\n\n    case 2:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 2);\n      break;\n\n  }\n\n  if (memcmp(decr_header, \"TRUE\", 4))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, &decr_header[256 - 64], 256);\n  if (!cmp_crc32s(&decr_header[8], ~check_sum))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, decr_header, (256 - 64) - 4);\n  if (!cmp_crc32s(&decr_header[(256 - 64) - 4], ~check_sum))\n    return 0;\n\n  return 1;\n}\n\n\nstatic int decrypt_and_verify(unsigned char *key, int algorithm)\n{\n  unsigned char decr_header[512 - 64];\n  CRC32_t check_sum;\n  switch (algorithm)\n  {\n    case 0:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 0);\n      break;\n\n    case 1:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 1);\n      break;\n\n    case 2:\n      XTS_decrypt(key, decr_header, psalt->bin, 512 - 64, 256, 2);\n      break;\n\n  }\n\n  if (memcmp(decr_header, \"TRUE\", 4))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, &decr_header[256 - 64], 256);\n  if (!cmp_crc32s(&decr_header[8], ~check_sum))\n    return 0;\n\n  CRC32_Init(&check_sum);\n  CRC32_Update(&check_sum, decr_header, (256 - 64) - 4);\n  if (!cmp_crc32s(&decr_header[(256 - 64) - 4], ~check_sum))\n    return 0;\n\n  return 1;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < nkeyfiles; idx++)\n{\n  p = strchr(p, '$') + 1;\n  q = strchr(p, '$');\n  if (!q)\n  {\n    if (idx != (nkeyfiles - 1))\n      return 0;\n\n    len = strlen(p);\n  }\n  else\n  {\n    len = q - p;\n  }\n\n  if (len > ((sizeof(tpath)) - 1))\n    return 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (512 * 2); i++)\n{\n  if (atoi16l[i] == 0x7F)\n    return 0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  s->salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 512; i++)\n  s->bin[i - 64] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (idx = 0; idx < s->nkeyfiles; idx++)\n{\n  p = strchr(p, '$') + 1;\n  q = strchr(p, '$');\n  if (!q)\n  {\n    len = strlen(p);\n  }\n  else\n  {\n    len = q - p;\n  }\n\n  if (len > ((sizeof(tpath)) - 1))\n  {\n    if (john_main_process)\n      fprintf(stderr, \"Error, path is too long in truecrypt::get_salt(), [%.10s...]\\n\", p);\n\n    real_error(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 360);\n  }\n\n  memcpy(tpath, p, len);\n  tpath[len] = '\\0';\n  fp = fopen(tpath, \"rb\");\n  if (!fp)\n    real_pexit(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 367, \"fopen %s\", tpath);\n\n  if (fseek(fp, 0L, 2) == (-1))\n    real_pexit(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 370, \"fseek\");\n\n  sz = ftell(fp);\n  if (sz > 1048576)\n  {\n    if (john_main_process)\n      fprintf(stderr, \"Error: keyfile '%s' is bigger than maximum size (MAX_KFILE_SZ is %d).\\n\", tpath, 1048576);\n\n    real_error(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 377);\n  }\n\n  if (fseek(fp, 0L, 0) == (-1))\n    real_pexit(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 381, \"fseek\");\n\n  if (fread(keyfiles_data[idx], 1, sz, fp) != sz)\n    real_pexit(\"/home/reemh/CLPP/github-clone-all/repos_final/openwall/john/src/truecrypt_fmt_plug.c\", 384, \"fread\");\n\n  keyfiles_length[idx] = sz;\n  fclose(fp);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < nkeyfiles; k++)\n{\n  kpool_idx = 0;\n  kdata_sz = keyfiles_length[k];\n  kdata = keyfiles_data[k];\n  crc = ~0U;\n  for (i = 0; i < kdata_sz; i++)\n  {\n    crc = JTR_CRC32_table[(unsigned char) (crc ^ kdata[i])] ^ (crc >> 8);\n    kpool[kpool_idx++] += (unsigned char) (crc >> 24);\n    kpool[kpool_idx++] += (unsigned char) (crc >> 16);\n    kpool[kpool_idx++] += (unsigned char) (crc >> 8);\n    kpool[kpool_idx++] += (unsigned char) crc;\n    if (kpool_idx == 64)\n      kpool_idx = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  pass[i] += kpool[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; ++i)\n{\n  v *= 11;\n  v += psalt->salt[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i += 1)\n{\n  unsigned char key[64];\n  unsigned char Decr[1][64];\n  int ksz = strlen((char *) key_buffer[i]);\n  int j;\n  pbkdf2_sha256((const unsigned char *) key_buffer[i], ksz, psalt->salt1, psalt->saltlen, psalt->rounds1, key, psalt->keylen, 0);\n  for (j = 0; j < 1; ++j)\n  {\n    AES_XTS_decrypt(key, Decr[j], psalt->encr, psalt->keylen, psalt->evp_type);\n  }\n\n  pbkdf2_sha256(Decr[0], psalt->keylen, psalt->salt2, psalt->saltlen, psalt->rounds2, crypt_out[i], psalt->saltlen, 0);\n}\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha256(const unsigned char *K, int KL, unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[32 / (sizeof(uint32_t))];\n    unsigned char out[32];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  jtr_sha256_ctx ipad;\n  jtr_sha256_ctx opad;\n  _pbkdf2_sha256_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (32 - 1)) / 32;\n  loop = (skip_bytes / 32) + 1;\n  skip_bytes %= 32;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha256(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 32) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 4))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; ++i)\n{\n  v *= 11;\n  v += psalt[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  uaf_test_password(cur_salt, saved_key[index], 0, crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  for (i = 0; i < 1; ++i)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    cracked[index + i] = vmx_decrypt(cur_salt, master[i], cur_salt->blob);\n  }\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic int vmx_decrypt(struct custom_salt *cur_salt, unsigned char *key, unsigned char *data)\n{\n  unsigned char out[116];\n  unsigned char ivec[16];\n  AES_KEY aes_decrypt_key;\n  memcpy(ivec, data, 16);\n  JTR_AES_set_decrypt_key(key, 256, &aes_decrypt_key);\n  JTR_AES_cbc_encrypt(cur_salt->blob + 16, out, 116 - 16, &aes_decrypt_key, ivec, 0);\n  return memcmp(out, \"type=key:cipher=\", 16) == 0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  if (dirty)\n    vtp_secret_derive(saved_key[index], saved_len[index], secret[index]);\n\n  john_MD5_Init(&ctx);\n  john_MD5_Update(&ctx, secret[index], 16);\n  john_MD5_Update(&ctx, &cur_salt->vsp, sizeof(vtp_summary_packet));\n  if (cur_salt->version != 1)\n    john_MD5_Update(&ctx, cur_salt->trailer_data, cur_salt->trailer_length);\n\n  john_MD5_Update(&ctx, cur_salt->vlans_data, cur_salt->vlans_data_length);\n  john_MD5_Update(&ctx, secret[index], 16);\n  john_MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\nstatic void vtp_secret_derive(char *password, int length, unsigned char *output)\n{\n  MD5_CTX ctx;\n  unsigned char *cp;\n  unsigned char buf[55][64];\n  int bufs_used = 0;\n  int local_cnt = 0;\n  int i;\n  int j;\n  if (length == 0)\n  {\n    memset(output, 0, 16);\n    return;\n  }\n\n  cp = buf[bufs_used];\n  for (;;)\n  {\n    if ((local_cnt + length) <= 64)\n    {\n      memcpy(&cp[local_cnt], password, length);\n      local_cnt += length;\n      if (local_cnt == 64)\n      {\n        bufs_used++;\n        break;\n      }\n\n    }\n    else\n    {\n      int spill = (local_cnt + length) - 64;\n      memcpy(&cp[local_cnt], password, length - spill);\n      cp = buf[++bufs_used];\n      memcpy(cp, &password[length - spill], spill);\n      local_cnt = spill;\n    }\n\n  }\n\n  john_MD5_Init(&ctx);\n  for (i = 0, j = 0; i < 1563; ++i)\n  {\n    john_MD5_Update(&ctx, buf[j++], 64);\n    if (j == bufs_used)\n      j = 0;\n\n  }\n\n  john_MD5_Final(output, &ctx);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.vlans_data_length; i++)\n  cs.vlans_data[i] = (atoi16[ARCH_INDEX(q[2 * i])] << 4) | atoi16[ARCH_INDEX(q[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(q[2 * i])] << 4) | atoi16[ARCH_INDEX(q[(2 * i) + 1])];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (;;)\n{\n  if ((local_cnt + length) <= 64)\n  {\n    memcpy(&cp[local_cnt], password, length);\n    local_cnt += length;\n    if (local_cnt == 64)\n    {\n      bufs_used++;\n      break;\n    }\n\n  }\n  else\n  {\n    int spill = (local_cnt + length) - 64;\n    memcpy(&cp[local_cnt], password, length - spill);\n    cp = buf[++bufs_used];\n    memcpy(cp, &password[length - spill], spill);\n    local_cnt = spill;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0, j = 0; i < 1563; ++i)\n{\n  john_MD5_Update(&ctx, buf[j++], 64);\n  if (j == bufs_used)\n    j = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char hexhash[40];\n  sph_sha1_context ctx;\n  if (dirty)\n  {\n    unsigned char out[20];\n    sph_sha1_init(&ctx);\n    sph_sha1(&ctx, saved_key[index], strlen(saved_key[index]));\n    sph_sha1_close(&ctx, out);\n    hex_encode(out, 20, hexhash1[index]);\n  }\n\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->salt, 40);\n  sph_sha1(&ctx, hexhash1[index], 40);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n  hex_encode((unsigned char *) crypt_out[index], 20, hexhash);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, cur_salt->salt, 40);\n  sph_sha1(&ctx, hexhash, 40);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\ninline static void hex_encode(unsigned char *str, int len, unsigned char *out)\n{\n  int i;\n  for (i = 0; i < len; ++i)\n  {\n    out[0] = itoa16[str[i] >> 4];\n    out[1] = itoa16[str[i] & 0xF];\n    out += 2;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; ++i)\n{\n  out[0] = itoa16[str[i] >> 4];\n  out[1] = itoa16[str[i] & 0xF];\n  out += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < count; j++)\n{\n  pbkdf2_sha1((const unsigned char *) in[j].v, in[j].length, salt->essid, salt->length, 4096, (unsigned char *) (&out[j]), 32, 0);\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for default(none) private(j) shared(count, salt, in, out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < self->params.max_keys_per_crypt; i++)\n  inbuffer[i].length = 0;\n\n", "pragma": "omp parallel for default(none) private(j) shared(count, salt, in, out)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char out[20];\n  sph_sha1_context ctx;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, out, 20, 0);\n  JTR_hmac_sha1(out, 20, (unsigned char *) \"Client Key\", 10, out, 20);\n  sph_sha1_init(&ctx);\n  sph_sha1(&ctx, out, 20);\n  sph_sha1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cs.saltlen; i++)\n{\n  cs.salt[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += inc)\n{\n  pkcs12_pbe_derive_key(algo, cur_salt->iteration_count, 3, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, 8, (unsigned char *) crypt_out[index], 8);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index++)\n{\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n    return 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char pwd_ver[3 * 20];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), saved_salt->salt, (4 * (saved_salt->v.mode & 3)) + 4, 1000, (pwd_ver + early_skip) - late_skip, 20, early_skip);\n  if (!memcmp((pwd_ver + (2 * key_len)) - late_skip, saved_salt->passverify, 2))\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), saved_salt->salt, (4 * (saved_salt->v.mode & 3)) + 4, 1000, pwd_ver, late_size, late_skip);\n    JTR_hmac_sha1((pwd_ver + key_len) - late_skip, key_len, (const unsigned char *) saved_salt->datablob, saved_salt->comp_len, crypt_key[index], 10);\n  }\n  else\n    memset(crypt_key[index], 0, 10);\n\n}\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\nstatic void pbkdf2_sha1(const unsigned char *K, int KL, const unsigned char *S, int SL, int R, unsigned char *out, int outlen, int skip_bytes)\n{\n  union \n  {\n    uint32_t x32[20 / (sizeof(uint32_t))];\n    unsigned char out[20];\n  } tmp;\n  int loop;\n  int loops;\n  int i;\n  int accum = 0;\n  sph_sha1_context ipad;\n  sph_sha1_context opad;\n  _pbkdf2_sha1_load_hmac(K, KL, &ipad, &opad);\n  loops = ((skip_bytes + outlen) + (20 - 1)) / 20;\n  loop = (skip_bytes / 20) + 1;\n  skip_bytes %= 20;\n  while (loop <= loops)\n  {\n    _pbkdf2_sha1(S, SL, R, tmp.x32, loop, &ipad, &opad);\n    for (i = skip_bytes; (i < 20) && (accum < outlen); i++)\n    {\n      out[accum++] = ((uint8_t *) tmp.out)[i];\n    }\n\n    loop++;\n    skip_bytes = 0;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  if (((uint32_t *) (&crypt_key[i]))[0] == ((uint32_t *) binary)[0])\n  return 1;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *data_temp = PyArray_GETPTR2(array_temp, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++data_temp, ++node_type)\n  {\n    if ((*data) == 5)\n    {\n      *data_temp = 10;\n    }\n    else\n      if ((*data) == 10)\n    {\n      *data_temp = 5;\n    }\n    else\n    {\n      *data_temp = *data;\n    }\n\n\n    if ((-1) == (*node_type))\n    {\n      *data_temp = reverse4(*data_temp);\n    }\n\n    if ((-2) == (*node_type))\n    {\n      double r = ((double) rand()) / ((double) 32767);\n      if (r < 0.8)\n      {\n        int n = rand() % 16;\n        *data_temp = n;\n        continue;\n      }\n\n    }\n\n    if ((*data) == 0)\n    {\n      *data_temp = 0;\n      continue;\n    }\n\n    if ((-3) == (*node_type))\n    {\n      *data_temp = 0;\n    }\n\n  }\n\n}\n\ninline long reverse4(long x)\n{\n  x = (x << 2) + (x >> 2);\n  return x & 15;\n}\n\n\n", "pragma": "omp parallel for shared(array, array_temp, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  double temp_r = rand() / ((double) 32767);\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  long mod_iRowM1 = mod(iRow - 1, H);\n  long mod_iRowP1 = mod(iRow + 1, H);\n  uint32_t *cell_color = PyArray_GETPTR2(cell_colors, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++cell_color, ++node_type)\n  {\n    if ((iCol == 0) || (iCol == (W - 1)))\n    {\n      long *n = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n      long *e = PyArray_GETPTR2(array_temp, iRow, mod(iCol + 1, W));\n      long *s = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n      long *w = PyArray_GETPTR2(array_temp, iRow, mod(iCol - 1, W));\n      *data = move4(*n, *e, *s, *w);\n    }\n    else\n    {\n      long *n = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n      long *e = PyArray_GETPTR2(array_temp, iRow, iCol + 1);\n      long *s = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n      long *w = PyArray_GETPTR2(array_temp, iRow, iCol - 1);\n      *data = move4(*n, *e, *s, *w);\n    }\n\n    if ((*node_type) != (-1))\n    {\n      *cell_color = 255 - (nSetBits[*data] * 63);\n      if (((temperature != 0) && ((*cell_color) != 3)) && ((*cell_color) != 255))\n      {\n        long this_temp_r = (((((iCol * iRow) * temp_r) * (*cell_color)) + iCol) + iRow) + temp_r;\n        if ((this_temp_r % 100000) < temperature)\n        {\n          switch (*cell_color)\n          {\n            case 255 - (1 * 63):\n              *data = 255 - random_table1[this_temp_r % size_random1];\n              break;\n\n            case 255 - (2 * 63):\n              *data = 255 - random_table2[this_temp_r % size_random2];\n              break;\n\n            case 255 - (3 * 63):\n              *data = 255 - random_table3[this_temp_r % size_random3];\n              break;\n\n            default:\n              fprintf(stderr, \"Bad magic %ui :(\\n\", *cell_color);\n              break;\n\n          }\n\n        }\n\n      }\n\n      *cell_color = ((((*cell_color) << 24) | ((*cell_color) << 16)) | ((*cell_color) << 8)) | ((*cell_color) << 0);\n    }\n\n  }\n\n}\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long move4(long n, long e, long s, long w)\n{\n  return (((n & 1) | (e & 2)) | (s & 4)) | (w & 8);\n}\n\n\ninline long move4(long n, long e, long s, long w)\n{\n  return (((n & 1) | (e & 2)) | (s & 4)) | (w & 8);\n}\n\n\n", "pragma": "omp parallel for shared(array, array_temp, cell_colors, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *data_temp = PyArray_GETPTR2(array_temp, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++data_temp, ++node_type)\n  {\n    if (collide[*data] == 0)\n    {\n      *data_temp = *data;\n    }\n    else\n    {\n      *data_temp = collide[*data];\n    }\n\n    if ((-1) == (*node_type))\n    {\n      *data_temp = reverse6(*data_temp);\n    }\n\n    if ((-2) == (*node_type))\n    {\n      double r = ((double) rand()) / ((double) 32767);\n      if (r < 0.8)\n      {\n        int n = rand() % 64;\n        *data_temp |= n;\n      }\n\n    }\n\n    if ((-3) == (*node_type))\n    {\n      *data_temp = 0;\n    }\n\n  }\n\n}\n\ninline long reverse6(long x)\n{\n  return ((x << 3) + (x >> 3)) & 63;\n}\n\n\n", "pragma": "omp parallel for shared(array, array_temp, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  double temp_r = rand() / ((double) 32767);\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  long mod_iRowM1 = mod(iRow - 1, H);\n  long mod_iRowP1 = mod(iRow + 1, H);\n  uint32_t *cell_color = PyArray_GETPTR2(cell_colors, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++cell_color, ++node_type)\n  {\n    if ((iCol == 0) || (iCol == (W - 1)))\n    {\n      if ((iRow % 2) == 0)\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, mod(iCol - 1, W));\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *e = PyArray_GETPTR2(array_temp, iRow, mod(iCol + 1, W));\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, mod(iCol - 1, W));\n        long *w = PyArray_GETPTR2(array_temp, iRow, mod(iCol - 1, W));\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n      else\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, mod(iCol + 1, W));\n        long *e = PyArray_GETPTR2(array_temp, iRow, mod(iCol + 1, W));\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, mod(iCol + 1, W));\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *w = PyArray_GETPTR2(array_temp, iRow, mod(iCol - 1, W));\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n\n    }\n    else\n    {\n      if ((iRow % 2) == 0)\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol - 1);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *e = PyArray_GETPTR2(array_temp, iRow, iCol + 1);\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol - 1);\n        long *w = PyArray_GETPTR2(array_temp, iRow, iCol - 1);\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n      else\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol + 1);\n        long *e = PyArray_GETPTR2(array_temp, iRow, iCol + 1);\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol + 1);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *w = PyArray_GETPTR2(array_temp, iRow, iCol - 1);\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n\n    }\n\n    if ((*node_type) != (-1))\n    {\n      *cell_color = 255 - (nSetBits[*data] * 42);\n      if (((temperature != 0) && ((*cell_color) != (255 - (6 * 42)))) && ((*cell_color) != 255))\n      {\n        long this_temp_r = (((((iCol * iRow) * temp_r) * (*cell_color)) + iCol) + iRow) + temp_r;\n        if ((this_temp_r % 100000) < temperature)\n        {\n          switch (*cell_color)\n          {\n            case 255 - (1 * 42):\n              *data = 255 - random_table1[this_temp_r % size_random1];\n              break;\n\n            case 255 - (2 * 42):\n              *data = 255 - random_table2[this_temp_r % size_random2];\n              break;\n\n            case 255 - (3 * 42):\n              *data = 255 - random_table3[this_temp_r % size_random3];\n              break;\n\n            case 255 - (4 * 42):\n              *data = 255 - random_table4[this_temp_r % size_random4];\n              break;\n\n            case 255 - (5 * 42):\n              *data = 255 - random_table5[this_temp_r % size_random5];\n              break;\n\n            default:\n              fprintf(stderr, \"Bad magic %ui :(\\n\", *cell_color);\n              break;\n\n          }\n\n        }\n\n      }\n\n      *cell_color = ((((*cell_color) << 24) | ((*cell_color) << 16)) | ((*cell_color) << 8)) | ((*cell_color) << 0);\n    }\n\n  }\n\n}\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long move6(long nw, long ne, long e, long se, long sw, long w)\n{\n  return (((((ne & 1) | (e & 2)) | (se & 4)) | (sw & 8)) | (w & 16)) | (nw & 32);\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long mod(long n, long k)\n{\n  if (n < 0)\n    return k + n;\n\n  return n % k;\n}\n\n\ninline long move6(long nw, long ne, long e, long se, long sw, long w)\n{\n  return (((((ne & 1) | (e & 2)) | (se & 4)) | (sw & 8)) | (w & 16)) | (nw & 32);\n}\n\n\ninline long move6(long nw, long ne, long e, long se, long sw, long w)\n{\n  return (((((ne & 1) | (e & 2)) | (se & 4)) | (sw & 8)) | (w & 16)) | (nw & 32);\n}\n\n\ninline long move6(long nw, long ne, long e, long se, long sw, long w)\n{\n  return (((((ne & 1) | (e & 2)) | (se & 4)) | (sw & 8)) | (w & 16)) | (nw & 32);\n}\n\n\n", "pragma": "omp parallel for shared(array, array_temp, cell_colors, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  long *cell = PyArray_GETPTR2(cells, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++cell, ++node_type)\n  {\n    if ((*node_type) > 0)\n    {\n      long r = rand() % 256;\n      if ((*node_type) > r)\n      {\n        *cell = particle_init;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(array, array_temp, cell_colors, H, W, iRow) private (iCol)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n  for (j = 0; j < 2; j++)\n  for (k = 0; k < 2; k++)\n  a[i][j][k] = (i + (j * 4)) + (k * 16);\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n  for (j = 0; j < 2; j++)\n  for (k = 0; k < 2; k++)\n  if (a[i][j][k] != ((i + (j * 4)) + (k * 16)))\n  l = 1;\n\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = -2; i < m1; i++)\n  for (j = m2; j < (-2); j++)\n{\n  for (k = 13; k < m3; k++)\n  {\n    if ((omp_get_num_threads() == 8) && (((((i + 2) * 12) + ((j + 5) * 4)) + (k - 13)) != ((omp_get_thread_num() * 9) + (f++))))\n      l++;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for num_threads (8) collapse(3) schedule(static, 9) reduction(+:l) firstprivate(f)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < 2; i++)\n  for (int j = 0; j < 2; j++)\n  for (int k = 0; k < 2; k++)\n  a[i][j][k] = (i + (j * 4)) + (k * 16);\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i2 = 0; i2 < 2; i2++)\n  for (int j = 0; j < 2; j++)\n  for (int k = 0; k < 2; k++)\n  if (a[i2][j][k] != ((i2 + (j * 4)) + (k * 16)))\n  l = 1;\n\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  buf[i] = i;\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  buf[i] += i;\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  if (buf[i] != (2 * i))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = buf; p < (&buf[8]); p++)\n  for (q = &buf2[0]; q <= (buf2 + 7); q++)\n  sum += ((*p) - '0') + ((*q) - '0');\n\n\n", "pragma": "omp parallel for collapse (2) reduction (+:sum) lastprivate (p, q)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 50; i += 3)\n  ;\n\n", "pragma": "omp parallel for lastprivate (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = -50; j < 70; j += 7)\n  ;\n\n", "pragma": "omp parallel for lastprivate (j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  a = a + i;\n\n", "pragma": "omp parallel for firstprivate (a) lastprivate (a) num_threads (2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  sum = sum + (a[i] * b[i]);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n{\n  if (first_time == 'y')\n  {\n    tid = omp_get_thread_num();\n    first_time = 'n';\n  }\n\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (static, 1) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (static, 1) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (runtime) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (runtime) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (dynamic) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (dynamic) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (guided) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (guided) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  if (n != 6)\n    ++x;\n\n  n = i;\n}\n\n", "pragma": "omp parallel for num_threads (16) firstprivate (n) lastprivate (n) schedule (static, 1) reduction (+: x)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  a[i] = work(i);\n\nint work(x)\n{\n  int i;\n  int y = 0;\n  for (i = 0; i < 20000; i++)\n    y += i;\n\n  return y;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static, 2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static, 2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (dynamic, 3)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < j; i += 1)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < j; ++i)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < j; i++)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; i += 1)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; ++i)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 3;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for shared (n, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 5;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 7;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for shared (n, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 1))\n    abort();\n\n\n  if (a[i] != (i + 1))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 3))\n    abort();\n\n\n  if (a[i] != (i + 3))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 5))\n    abort();\n\n\n  if (a[i] != (i + 5))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 7))\n    abort();\n\n\n  if (a[i] != (i + 7))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n  c += 1;\n\n", "pragma": "omp parallel for private(i) reduction(+:c)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1; i++)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i <= 0; i++)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (j = (-0x7fffffff) - 1; j < (-0x7fffffff); j++)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (j = (-0x7fffffff) - 1; j <= ((-0x7fffffff) - 1); j++)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = (2U * 0x7fffffff) + 1; i > (2U * 0x7fffffff); i--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = (2U * 0x7fffffff) + 1; i >= ((2U * 0x7fffffff) + 1); i--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (j = 0x7fffffff; j > (0x7fffffff - 1); j--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (j = 0x7fffffff; j >= 0x7fffffff; j--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = lb; i < ub; i += stride)\n  work(i);\n\nvoid work(int k)\n{\n  printf(\" %d\\n\", k);\n}\n\n\n", "pragma": "omp parallel for ordered schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < n; j++)\n  for (int k = 0; k < n; k++)\n  c[i][j] += a[i][k] * b[k][j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  arg[i].id = i;\n  arg[i].ProcessNum = n;\n  arg[i].dim = 50;\n  arg[i].a = &a;\n  arg[i].b = &b;\n  arg[i].c = &c;\n  pthread_create(&threads[i], &pthread_custom_attr, Worker, (void *) (arg + i));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n  pthread_join(threads[i], 0);\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 50; i++)\n  for (int j = 0; j < 50; j++)\n{\n  a[i][j] = i * j;\n  b[i][j] = i * j;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int x = 12; x > 0; x--)\n{\n  timesec = MatMult(x);\n  ((((cout << \"# of threads: \") << x) << \" Time: \") << (timesec / 1000.0)) << \" Seconds \\n\";\n}\n\ndouble MatMult(int n)\n{\n  int ProcessNum;\n  int ThreadNum;\n  double t1;\n  double t2;\n  pthread_t *threads;\n  pthread_attr_t pthread_custom_attr;\n  parm *arg;\n  threads = (pthread_t *) malloc(n * (sizeof(pthread_t)));\n  if (threads == 0)\n  {\n    puts(\"Threads malloc failed\");\n    puts(strerror(errno));\n  }\n  else\n  {\n    pthread_attr_init(&pthread_custom_attr);\n    arg = (parm *) malloc((sizeof(parm)) * n);\n    if (arg == 0)\n    {\n      puts(\"arg malloc failed\");\n      puts(strerror(errno));\n    }\n    else\n    {\n      gettimeofday(&start, 0);\n      for (int i = 0; i < n; i++)\n      {\n        arg[i].id = i;\n        arg[i].ProcessNum = n;\n        arg[i].dim = 50;\n        arg[i].a = &a;\n        arg[i].b = &b;\n        arg[i].c = &c;\n        pthread_create(&threads[i], &pthread_custom_attr, Worker, (void *) (arg + i));\n      }\n\n      for (int i = 0; i < n; i++)\n        pthread_join(threads[i], 0);\n\n      gettimeofday(&end, 0);\n    }\n\n    free(arg);\n  }\n\n  return (((end.tv_sec - start.tv_sec) * 1000) + ((end.tv_usec - start.tv_usec) / 1000.0)) + 0.5;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  for (j = 0; j < 5000000; j++)\n  A[i] += j;\n\n\n", "pragma": "omp parallel for schedule(runtime) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numthreads; i++)\n{\n  f1_layer[i] = (f1_neuron *) malloc(numf1s * (sizeof(f1_neuron)));\n  if (f1_layer[i] == 0)\n  {\n    fprintf(stderr, \"malloc error in init_net\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < numthreads; j++)\n{\n  for (i = 0; i < numf1s; i++)\n  {\n    f1_layer[j][i].I = (double *) malloc(2 * (sizeof(double)));\n    if (f1_layer[j][i].I == 0)\n    {\n      fprintf(stderr, \"malloc error in init_net\\n\");\n      exit(1);\n    }\n\n    f1_layer[j][i].W = 0.0;\n    f1_layer[j][i].X = 0.0;\n    f1_layer[j][i].V = 0.0;\n    f1_layer[j][i].U = 0.0;\n    f1_layer[j][i].P = 0.0;\n    f1_layer[j][i].Q = 0.0;\n    f1_layer[j][i].R = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numthreads; i++)\n{\n  Y[i] = (xyz *) malloc(numf2s * (sizeof(xyz)));\n  if (Y[i] == 0)\n  {\n    fprintf(stderr, \"malloc error in init_net\\n\");\n  }\n\n  Y[i][0].y = 0.0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf2s; i++)\n  if (Y[o][i].y > Y[o][winner[o][0]].y)\n  winner[o][0] = i;\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < varNumF1; j++)\n{\n  norm += f1_layer[o][j].P * f1_layer[o][j].P;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < varNumF1; j++)\n{\n  temp_sum = f1_layer[o][j].U * f1_layer[o][j].U;\n  norm += temp_sum;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < varNumF1; j++)\n{\n  f1_layer[o][j].R = (f1_layer[o][j].U + (cc * f1_layer[o][j].P)) / sum;\n  norm += f1_layer[o][j].R * f1_layer[o][j].R;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < numf1s; j++)\n{\n  su += f1_layer[o][j].U;\n  sp += f1_layer[o][j].P;\n  su2 += f1_layer[o][j].U * f1_layer[o][j].U;\n  sp2 += f1_layer[o][j].P * f1_layer[o][j].P;\n  sup += f1_layer[o][j].U * f1_layer[o][j].P;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < 1; k++)\n{\n  resonant = 0;\n  for (j = 0; j < numf1s; j++)\n  {\n    temp = tds[j][i];\n    tds[j][i] += (g(i) * (f1_layer[o][j].P - tds[j][i])) * delta_t;\n    if (fabs(temp - tds[j][i]) <= er)\n      resonant = 1;\n\n  }\n\n  for (j = 0; j < numf1s; j++)\n  {\n    temp = bus[j][i];\n    bus[j][i] += (g(i) * (f1_layer[o][j].P - bus[j][i])) * delta_t;\n    if ((fabs(temp - bus[j][i]) <= er) && resonant)\n    {\n      resonant = 1;\n    }\n    else\n    {\n      resonant = 0;\n    }\n\n  }\n\n}\n\ndouble g(int i)\n{\n  double result;\n  if (i != winner[o][0])\n    result = 0;\n  else\n    if (Y[o][i].y > 0)\n    result = d;\n  else\n    result = 0;\n\n\n  return result;\n}\n\n\ndouble g(int i)\n{\n  double result;\n  if (i != winner[o][0])\n    result = 0;\n  else\n    if (Y[o][i].y > 0)\n    result = d;\n  else\n    result = 0;\n\n\n  return result;\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numthreads; i++)\n{\n  winner[i] = (int *) malloc(4 * (sizeof(int)));\n  if (winner[i] == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  winner[i][0] = 0;\n  cp[i] = (int *) malloc(4 * (sizeof(int)));\n  if (cp[i] == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  cp[i][0] = 0;\n  highx[i] = (int *) malloc(4 * (sizeof(int)));\n  if (highx[i] == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  highx[i][0] = 0;\n  highy[i] = (int *) malloc(4 * (sizeof(int)));\n  if (highy[i] == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  highy[i][0] = 0;\n  highest_confidence[i] = (double *) malloc(4 * (sizeof(double)));\n  if (highest_confidence == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  highest_confidence[i][0] = 0.0;\n  set_high[i] = (int *) malloc(4 * (sizeof(int)));\n  if (set_high == 0)\n  {\n    printf(\"malloc error\\n\");\n    exit(1);\n  }\n\n  set_high[i][0] = 0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  if ((i % 5) == 0)\n    printf(\"\\n\");\n\n  printf(\" %8.5f \", f1_layer[o][i].I[cp[o][0]]);\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < varNumF1; i++)\n{\n  f1_layer[o][i].W = 0.0;\n  f1_layer[o][i].X = 0.0;\n  f1_layer[o][i].V = 0.0;\n  f1_layer[o][i].U = 0.0;\n  f1_layer[o][i].P = 0.0;\n  f1_layer[o][i].Q = 0.0;\n  f1_layer[o][i].R = 0.0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf2s; i++)\n{\n  Y[o][i].y = 0.0;\n  Y[o][i].reset = 0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < varNumF1; i++)\n{\n  f1_layer[o][i].W = 0.0;\n  f1_layer[o][i].X = 0.0;\n  f1_layer[o][i].V = 0.0;\n  f1_layer[o][i].U = 0.0;\n  f1_layer[o][i].P = 0.0;\n  f1_layer[o][i].Q = 0.0;\n  f1_layer[o][i].R = 0.0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf2s; i++)\n  Y[o][i].y = 0.0;\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = 0; j < numf2s; j++)\n  if (j == (numf2s - 1))\n  printf(\" %8.16f\\n\", tds[i][j]);\nelse\n  printf(\" %8.16f \", tds[i][j]);\n\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = 0; j < numf2s; j++)\n  if (j == (numf2s - 1))\n  printf(\" %8.16f\\n\", bus[i][j]);\nelse\n  printf(\" %8.16f \", bus[i][j]);\n\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < numf2s; j += 10)\n  printf(\" j = %i  Y= %9.7f\\n\", j, Y[o][j].y);\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = numpatterns; i < numf2s; i++)\n  Y[o][i].reset = 1;\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].W = f1_layer[o][ti].I[varNumCp] + (varNumA * f1_layer[o][ti].U);\n  tnorm += f1_layer[o][ti].W * f1_layer[o][ti].W;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].X = f1_layer[o][ti].W / oldTnorm;\n  if (f1_layer[o][ti].X < varNumTheta)\n    xr = 0;\n  else\n    xr = f1_layer[o][ti].X;\n\n  if (f1_layer[o][ti].Q < varNumTheta)\n    qr = 0;\n  else\n    qr = f1_layer[o][ti].Q;\n\n  f1_layer[o][ti].V = xr + (varNumB * qr);\n  tnorm += f1_layer[o][ti].V * f1_layer[o][ti].V;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].U = f1_layer[o][ti].V / oldTnorm;\n  tsum = 0;\n  ttemp = f1_layer[o][ti].P;\n  for (tj = *spot; tj < numpatterns; tj++)\n  {\n    if ((tj == winner[o][0]) && (Y[o][tj].y > 0))\n      tsum += tds[ti][tj] * varNumD;\n\n  }\n\n  f1_layer[o][ti].P = f1_layer[o][ti].U + tsum;\n  tnorm += f1_layer[o][ti].P * f1_layer[o][ti].P;\n  if (fabs(ttemp - f1_layer[o][ti].P) < 0.000001)\n    tresult = 0;\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (tj = 0; tj < varNumF1; tj++)\n  f1_layer[o][tj].Q = f1_layer[o][tj].P;\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (tj = *spot; tj < numpatterns; tj++)\n{\n  Y[o][tj].y = 0;\n  if (!Y[o][tj].reset)\n    for (ti = 0; ti < varNumF1; ti++)\n    Y[o][tj].y += f1_layer[o][ti].P * bus[ti][tj];\n\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = *spot; ti < numpatterns; ti++)\n{\n  if (Y[o][ti].y > Y[o][winner[o][0]].y)\n    winner[o][0] = ti;\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].W = f1_layer[o][ti].I[varNumCp] + (varNumA * f1_layer[o][ti].U);\n  tnorm += f1_layer[o][ti].W * f1_layer[o][ti].W;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].X = f1_layer[o][ti].W / oldTnorm;\n  if (f1_layer[o][ti].X < varNumTheta)\n    xr = 0;\n  else\n    xr = f1_layer[o][ti].X;\n\n  if (f1_layer[o][ti].Q < varNumTheta)\n    qr = 0;\n  else\n    qr = f1_layer[o][ti].Q;\n\n  f1_layer[o][ti].V = xr + (varNumB * qr);\n  tnorm += f1_layer[o][ti].V * f1_layer[o][ti].V;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].U = f1_layer[o][ti].V / oldTnorm;\n  tsum = 0;\n  ttemp = f1_layer[o][ti].P;\n  for (tj = *spot; tj < varNumF2; tj++)\n  {\n    if ((tj == winner[o][0]) && (Y[o][tj].y > 0))\n      tsum += tds[ti][tj] * varNumD;\n\n  }\n\n  f1_layer[o][ti].P = f1_layer[o][ti].U + tsum;\n  tnorm += f1_layer[o][ti].P * f1_layer[o][ti].P;\n  if (fabs(ttemp - f1_layer[o][ti].P) < 0.000001)\n    tresult = 0;\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (tj = 0; tj < varNumF1; tj++)\n  f1_layer[o][tj].Q = f1_layer[o][tj].P;\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (tj = *spot; tj < varNumF2; tj++)\n{\n  Y[o][tj].y = 0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  for (tj = *spot; tj < varNumF2; tj++)\n    if (!Y[o][tj].reset)\n    Y[o][tj].y += f1_layer[o][ti].P * busp[ti][tj];\n\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ti = *spot; ti < varNumF2; ti++)\n{\n  if (Y[o][ti].y > Y[o][winner[o][0]].y)\n    winner[o][0] = ti;\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; (j < 9) && (!f1res); j++)\n{\n  compute_train_match(o, &f1res, &spot);\n}\n\nvoid compute_train_match(int o, int *f1res, int *spot)\n{\n  int varNumF1;\n  int varNumF2;\n  int varNumCp;\n  double varNumA;\n  double varNumB;\n  double varNumD;\n  double varNumTheta;\n  double oldTnorm;\n  int ti;\n  int tj;\n  int tresult;\n  double tnorm;\n  double xr;\n  double qr;\n  double tsum;\n  double ttemp;\n  varNumF1 = numf1s;\n  varNumF2 = numf2s;\n  varNumCp = cp[o][0];\n  varNumA = a;\n  varNumB = b;\n  varNumD = d;\n  varNumTheta = theta;\n  tnorm = 0;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].W = f1_layer[o][ti].I[varNumCp] + (varNumA * f1_layer[o][ti].U);\n    tnorm += f1_layer[o][ti].W * f1_layer[o][ti].W;\n  }\n\n  tnorm = sqrt((double) tnorm);\n  oldTnorm = tnorm;\n  tnorm = 0;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].X = f1_layer[o][ti].W / oldTnorm;\n    if (f1_layer[o][ti].X < varNumTheta)\n      xr = 0;\n    else\n      xr = f1_layer[o][ti].X;\n\n    if (f1_layer[o][ti].Q < varNumTheta)\n      qr = 0;\n    else\n      qr = f1_layer[o][ti].Q;\n\n    f1_layer[o][ti].V = xr + (varNumB * qr);\n    tnorm += f1_layer[o][ti].V * f1_layer[o][ti].V;\n  }\n\n  tnorm = sqrt((double) tnorm);\n  oldTnorm = tnorm;\n  tnorm = 0;\n  tsum = 0;\n  tresult = 1;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].U = f1_layer[o][ti].V / oldTnorm;\n    tsum = 0;\n    ttemp = f1_layer[o][ti].P;\n    for (tj = *spot; tj < numpatterns; tj++)\n    {\n      if ((tj == winner[o][0]) && (Y[o][tj].y > 0))\n        tsum += tds[ti][tj] * varNumD;\n\n    }\n\n    f1_layer[o][ti].P = f1_layer[o][ti].U + tsum;\n    tnorm += f1_layer[o][ti].P * f1_layer[o][ti].P;\n    if (fabs(ttemp - f1_layer[o][ti].P) < 0.000001)\n      tresult = 0;\n\n  }\n\n  *f1res = tresult;\n  tnorm = sqrt((double) tnorm);\n  for (tj = 0; tj < varNumF1; tj++)\n    f1_layer[o][tj].Q = f1_layer[o][tj].P;\n\n  for (tj = *spot; tj < numpatterns; tj++)\n  {\n    Y[o][tj].y = 0;\n    if (!Y[o][tj].reset)\n      for (ti = 0; ti < varNumF1; ti++)\n      Y[o][tj].y += f1_layer[o][ti].P * bus[ti][tj];\n\n\n  }\n\n  winner[o][0] = 0;\n  for (ti = *spot; ti < numpatterns; ti++)\n  {\n    if (Y[o][ti].y > Y[o][winner[o][0]].y)\n      winner[o][0] = ti;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mt = spot; mt < numf2s; mt++)\n  if (Y[o][mt].reset == 0)\n  matchtest = 1;\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; (j < 9) && (!f1res); j++)\n{\n  compute_values_match(o, &f1res, &spot, busp);\n}\n\nvoid compute_values_match(int o, int *f1res, int *spot, double **busp)\n{\n  int varNumF1;\n  int varNumF2;\n  int varNumCp;\n  double varNumA;\n  double varNumB;\n  double varNumD;\n  double varNumTheta;\n  double oldTnorm;\n  int ti;\n  int tj;\n  int tresult;\n  double tnorm;\n  double xr;\n  double qr;\n  double tsum;\n  double ttemp;\n  varNumF1 = numf1s;\n  varNumF2 = numf2s;\n  varNumCp = cp[o][0];\n  varNumA = a;\n  varNumB = b;\n  varNumD = d;\n  varNumTheta = theta;\n  tnorm = 0;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].W = f1_layer[o][ti].I[varNumCp] + (varNumA * f1_layer[o][ti].U);\n    tnorm += f1_layer[o][ti].W * f1_layer[o][ti].W;\n  }\n\n  tnorm = sqrt((double) tnorm);\n  oldTnorm = tnorm;\n  tnorm = 0;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].X = f1_layer[o][ti].W / oldTnorm;\n    if (f1_layer[o][ti].X < varNumTheta)\n      xr = 0;\n    else\n      xr = f1_layer[o][ti].X;\n\n    if (f1_layer[o][ti].Q < varNumTheta)\n      qr = 0;\n    else\n      qr = f1_layer[o][ti].Q;\n\n    f1_layer[o][ti].V = xr + (varNumB * qr);\n    tnorm += f1_layer[o][ti].V * f1_layer[o][ti].V;\n  }\n\n  tnorm = sqrt((double) tnorm);\n  oldTnorm = tnorm;\n  tnorm = 0;\n  tsum = 0;\n  tresult = 1;\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    f1_layer[o][ti].U = f1_layer[o][ti].V / oldTnorm;\n    tsum = 0;\n    ttemp = f1_layer[o][ti].P;\n    for (tj = *spot; tj < varNumF2; tj++)\n    {\n      if ((tj == winner[o][0]) && (Y[o][tj].y > 0))\n        tsum += tds[ti][tj] * varNumD;\n\n    }\n\n    f1_layer[o][ti].P = f1_layer[o][ti].U + tsum;\n    tnorm += f1_layer[o][ti].P * f1_layer[o][ti].P;\n    if (fabs(ttemp - f1_layer[o][ti].P) < 0.000001)\n      tresult = 0;\n\n  }\n\n  *f1res = tresult;\n  tnorm = sqrt((double) tnorm);\n  for (tj = 0; tj < varNumF1; tj++)\n    f1_layer[o][tj].Q = f1_layer[o][tj].P;\n\n  for (tj = *spot; tj < varNumF2; tj++)\n  {\n    Y[o][tj].y = 0;\n  }\n\n  for (ti = 0; ti < varNumF1; ti++)\n  {\n    for (tj = *spot; tj < varNumF2; tj++)\n      if (!Y[o][tj].reset)\n      Y[o][tj].y += f1_layer[o][ti].P * busp[ti][tj];\n\n\n  }\n\n  winner[o][0] = 0;\n  for (ti = *spot; ti < varNumF2; ti++)\n  {\n    if (Y[o][ti].y > Y[o][winner[o][0]].y)\n      winner[o][0] = ti;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mt = 0; mt < numf2s; mt++)\n  if (Y[o][mt].reset == 0)\n  matchtest = 1;\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  width = ((width * 10) + buffer[i]) - '0';\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  height = ((height * 10) + buffer[i]) - '0';\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cimgheight; i++)\n{\n  cimage[i] = (unsigned char *) malloc(cimgwidth * (sizeof(unsigned char)));\n  if (cimage[i] == 0)\n  {\n    fprintf(stderr, \"Problems with malloc in loadimage()\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cimgheight; i += height)\n{\n  for (j = 0; j < cimgwidth; j += width)\n  {\n    for (r = 0; r < height; r++)\n    {\n      for (c = 0; c < width; c++)\n      {\n        cimage[i + r][j + c] = superbuffer[(r * width) + c];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  fscanf(inp, \"%le\", &a);\n  bus[i][j] = (tds[i][j] = a);\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  bus[i] = (double *) malloc(numf2s * (sizeof(double)));\n  tds[i] = (double *) malloc(numf2s * (sizeof(double)));\n  if ((bus[i] == 0) || (tds[i] == 0))\n  {\n    fprintf(stderr, \"Malloc problem in load_weights, i=%d\\n\", i);\n    exit(1);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = start; j < numf2s; j++)\n  tds[i][j] = 0.0;\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = start; j < numf2s; j++)\n  bus[i][j] = (1 / (1.0 - d)) / sqrt((double) numf1s);\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  lwidth = ((lwidth * 10) + buffer[i]) - '0';\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  lheight = ((lheight * 10) + buffer[i]) - '0';\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (lheight * lwidth); i++)\n{\n  t = superbuffer[i];\n  f1_layer[o][i].I[spot] = (double) t;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = low; i < varHigh; i++)\n{\n  for (j = 0; j < varNumF1; j++)\n  {\n    if (i % low)\n    {\n      tds[j][i] = tds[j][0];\n      tds[j][i] = bus[j][0];\n    }\n    else\n    {\n      tds[j][i] = tds[j][1];\n      tds[j][i] = bus[j][1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = low; i < varHigh; i++)\n{\n  for (j = 0; j < varNumF1; j++)\n  {\n    noise1 = rand() & 0xffff;\n    noise2 = ((double) noise1) / ((double) 0xffff);\n    tds[j][i] -= noise2;\n    bus[j][i] -= noise2;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  for (j = spot; j < numf2s; j++)\n  {\n    tds[i][j] = (bus[i][j] = (1.0 / sqrt((double) numf1s)) / (1 - d));\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < numf1s; i++)\n{\n  busp[i] = busp[i - 1] + numf2s;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  for (j = 0; j < numf2s; j++)\n  {\n    busp[i][j] = bus[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ij = 0; ij < ijmx; ij++)\n{\n  j = ((ij / inum) * gStride) + gStartY;\n  i = ((ij % inum) * gStride) + gStartX;\n  k = 0;\n  for (m = j; m < (gLheight + j); m++)\n    for (n = i; n < (gLwidth + i); n++)\n    f1_layer[o][k++].I[0] = cimage[m][n];\n\n\n  gPassFlag = 0;\n  gPassFlag = match(o, i, j, &mat_con[ij], busp);\n  if (gPassFlag == 1)\n  {\n    if (set_high[o][0] == 1)\n    {\n      highx[o][0] = i;\n      highy[o][0] = j;\n      set_high[o][0] = 0;\n    }\n\n    if (set_high[o][1] == 1)\n    {\n      highx[o][1] = i;\n      highy[o][1] = j;\n      set_high[o][1] = 0;\n    }\n\n  }\n\n}\n\nint match(int o, int xcoor, int ycoor, double *mcp, double **busp)\n{\n  int j;\n  int matched;\n  int f1res;\n  int mt;\n  long c;\n  char matchtest;\n  double match_confidence;\n  int spot;\n  int ret;\n  int mprint;\n  c = 0;\n  ret = 0;\n  f1res = 0;\n  spot = 0;\n  cp[o][0] = 0;\n  reset_nodes();\n  matched = 0;\n  mprint = 1;\n  while (!matched)\n  {\n    if ((c++) > 3)\n      break;\n\n    reset_nodes2();\n    f1res = 0;\n    for (j = 0; (j < 9) && (!f1res); j++)\n    {\n      compute_values_match(o, &f1res, &spot, busp);\n    }\n\n    match_confidence = simtest2(o);\n    if (mprint == 1)\n    {\n      *mcp = match_confidence;\n      mprint = 0;\n    }\n\n    if (match_confidence > rho)\n    {\n      if (winner[o][0] != (numf2s - 1))\n      {\n        pass_flag[o] = 1;\n        ret = 1;\n        if (match_confidence >= 0.99)\n        {\n          add_list_item(winner[o][0], match_confidence, xcoor, ycoor);\n        }\n\n        if (match_confidence > highest_confidence[o][winner[o][0]])\n        {\n          highest_confidence[o][winner[o][0]] = match_confidence;\n          set_high[o][winner[o][0]] = 1;\n        }\n\n      }\n\n      matched = 1;\n    }\n    else\n    {\n      Y[o][winner[o][0]].y = 0;\n      Y[o][winner[o][0]].reset = 1;\n      matchtest = 0;\n      for (mt = 0; mt < numf2s; mt++)\n        if (Y[o][mt].reset == 0)\n        matchtest = 1;\n\n\n      if (matchtest)\n        find_match(o);\n      else\n        matched = 1;\n\n    }\n\n  }\n\n  return ret;\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ij = 0; ij < ijmx; ij++)\n{\n  j = ((ij / inum) * gStride) + gStartY;\n  i = ((ij % inum) * gStride) + gStartX;\n  printf(\"x = %i, y = %i, match confidence = %9.7f \\n\", i, j, mat_con[ij]);\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numthreads; i++)\n{\n  highest_confidence[i][0] = 0.0;\n  highest_confidence[i][1] = 0.0;\n  highx[i][0] = 0;\n  highx[i][1] = 0;\n  highy[i][0] = 0;\n  highy[i][1] = 0;\n  set_high[i][0] = 0;\n  set_high[i][1] = 0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (j = 0; j < Mdim; j++)\n  {\n    tmp = 0.0;\n    for (k = 0; k < Pdim; k++)\n    {\n      tmp += (*(A + ((i * Ndim) + k))) * (*(B + ((k * Pdim) + j)));\n    }\n\n    *(C + ((i * Ndim) + j)) = tmp;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n  for (j = 0; j < Pdim; j++)\n  *(A + ((i * Ndim) + j)) = 3.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Pdim; i++)\n  for (j = 0; j < Mdim; j++)\n  *(B + ((i * Pdim) + j)) = 5.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n  for (j = 0; j < Mdim; j++)\n  *(C + ((i * Ndim) + j)) = 0.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (j = 0; j < Mdim; j++)\n  {\n    err = (*((C + (i * Ndim)) + j)) - cval;\n    errsq += err * err;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  comp(i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  test();\n}\n\nvoid test()\n{\n  int i;\n  for (i = 0; i < (1 << 20); i++)\n  {\n    comp(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < (1 << 20); j++)\n{\n  test();\n}\n\nvoid test()\n{\n  int i;\n  for (i = 0; i < (1 << 20); i++)\n  {\n    comp(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  a[i] = work(i);\n\nfloat work(x)\n{\n  int i;\n  float y = 0;\n  for (i = 0; i < 20000; i++)\n    y += i;\n\n  return y;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20000; i++)\n  y += i;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20000; i++)\n  y += i;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  colidx[n + i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= n; j++)\n{\n  rowstr[j] = 0;\n  mark[j] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  x[i] = 0.0;\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    colidx[k] = (colidx[k] - firstcol) + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= (1400 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (it = 1; it <= 1; it++)\n{\n  conj_grad(colidx, rowstr, x, z, a, p, q, r, w, &rnorm);\n  {\n    norm_temp11 = 0.0;\n    norm_temp12 = 0.0;\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    norm_temp11 = norm_temp11 + (x[j] * z[j]);\n    norm_temp12 = norm_temp12 + (z[j] * z[j]);\n  }\n\n  norm_temp12 = 1.0 / sqrt(norm_temp12);\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    x[j] = norm_temp12 * z[j];\n  }\n\n}\n\nstatic void conj_grad(int colidx[], int rowstr[], double x[], double z[], double a[], double p[], double q[], double r[], double w[], double *rnorm)\n{\n  static double d;\n  static double sum;\n  static double rho;\n  static double rho0;\n  static double alpha;\n  static double beta;\n  int i;\n  int j;\n  int k;\n  int cgit;\n  int cgitmax = 25;\n  rho = 0.0;\n  for (j = 1; j <= (naa + 1); j++)\n  {\n    q[j] = 0.0;\n    z[j] = 0.0;\n    r[j] = x[j];\n    p[j] = r[j];\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (x[j] * x[j]);\n  }\n\n  for (cgit = 1; cgit <= cgitmax; cgit++)\n  {\n    {\n      rho0 = rho;\n      d = 0.0;\n      rho = 0.0;\n    }\n    for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n    {\n      sum = 0.0;\n      for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n      {\n        sum = sum + (a[k] * p[colidx[k]]);\n      }\n\n      w[j] = sum;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      q[j] = w[j];\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      w[j] = 0.0;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      d = d + (p[j] * q[j]);\n    }\n\n    alpha = rho0 / d;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      z[j] = z[j] + (alpha * p[j]);\n      r[j] = r[j] - (alpha * q[j]);\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      rho = rho + (r[j] * r[j]);\n    }\n\n    beta = rho / rho0;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      p[j] = r[j] + (beta * p[j]);\n    }\n\n  }\n\n  sum = 0.0;\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    d = 0.0;\n    for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n    {\n      d = d + (a[k] * z[colidx[k]]);\n    }\n\n    w[j] = d;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    r[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = x[j] - r[j];\n    sum = sum + (d * d);\n  }\n\n  {\n    *rnorm = sqrt(sum);\n  }\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= (1400 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (it = 1; it <= 15; it++)\n{\n  conj_grad(colidx, rowstr, x, z, a, p, q, r, w, &rnorm);\n  {\n    norm_temp11 = 0.0;\n    norm_temp12 = 0.0;\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    norm_temp11 = norm_temp11 + (x[j] * z[j]);\n    norm_temp12 = norm_temp12 + (z[j] * z[j]);\n  }\n\n  {\n    norm_temp12 = 1.0 / sqrt(norm_temp12);\n    zeta = 10.0 + (1.0 / norm_temp11);\n  }\n  {\n    if (it == 1)\n    {\n      printf(\"   iteration           ||r||                 zeta\\n\");\n    }\n\n    printf(\"    %5d       %20.14e%20.13e\\n\", it, rnorm, zeta);\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    x[j] = norm_temp12 * z[j];\n  }\n\n}\n\nstatic void conj_grad(int colidx[], int rowstr[], double x[], double z[], double a[], double p[], double q[], double r[], double w[], double *rnorm)\n{\n  static double d;\n  static double sum;\n  static double rho;\n  static double rho0;\n  static double alpha;\n  static double beta;\n  int i;\n  int j;\n  int k;\n  int cgit;\n  int cgitmax = 25;\n  rho = 0.0;\n  for (j = 1; j <= (naa + 1); j++)\n  {\n    q[j] = 0.0;\n    z[j] = 0.0;\n    r[j] = x[j];\n    p[j] = r[j];\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (x[j] * x[j]);\n  }\n\n  for (cgit = 1; cgit <= cgitmax; cgit++)\n  {\n    {\n      rho0 = rho;\n      d = 0.0;\n      rho = 0.0;\n    }\n    for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n    {\n      sum = 0.0;\n      for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n      {\n        sum = sum + (a[k] * p[colidx[k]]);\n      }\n\n      w[j] = sum;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      q[j] = w[j];\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      w[j] = 0.0;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      d = d + (p[j] * q[j]);\n    }\n\n    alpha = rho0 / d;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      z[j] = z[j] + (alpha * p[j]);\n      r[j] = r[j] - (alpha * q[j]);\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      rho = rho + (r[j] * r[j]);\n    }\n\n    beta = rho / rho0;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      p[j] = r[j] + (beta * p[j]);\n    }\n\n  }\n\n  sum = 0.0;\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    d = 0.0;\n    for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n    {\n      d = d + (a[k] * z[colidx[k]]);\n    }\n\n    w[j] = d;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    r[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = x[j] - r[j];\n    sum = sum + (d * d);\n  }\n\n  {\n    *rnorm = sqrt(sum);\n  }\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= (naa + 1); j++)\n{\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = x[j];\n  p[j] = r[j];\n  w[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  rho = rho + (x[j] * x[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (cgit = 1; cgit <= cgitmax; cgit++)\n{\n  {\n    rho0 = rho;\n    d = 0.0;\n    rho = 0.0;\n  }\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    sum = 0.0;\n    for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n    {\n      sum = sum + (a[k] * p[colidx[k]]);\n    }\n\n    w[j] = sum;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    q[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = d + (p[j] * q[j]);\n  }\n\n  alpha = rho0 / d;\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    z[j] = z[j] + (alpha * p[j]);\n    r[j] = r[j] - (alpha * q[j]);\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (r[j] * r[j]);\n  }\n\n  beta = rho / rho0;\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    p[j] = r[j] + (beta * p[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  w[j] = d;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  r[j] = w[j];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  d = x[j] - r[j];\n  sum = sum + (d * d);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  sprnvc(n, nzv, v, iv, &colidx[0], &colidx[n]);\n  vecset(n, v, iv, &nzv, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    if ((jcol >= firstcol) && (jcol <= lastcol))\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        if ((irow >= firstrow) && (irow <= lastrow))\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\nstatic void sprnvc(int n, int nz, double v[], int iv[], int nzloc[], int mark[])\n{\n  int nn1;\n  int nzrow;\n  int nzv;\n  int ii;\n  int i;\n  double vecelt;\n  double vecloc;\n  nzv = 0;\n  nzrow = 0;\n  nn1 = 1;\n  do\n  {\n    nn1 = 2 * nn1;\n  }\n  while (nn1 < n);\n  while (nzv < nz)\n  {\n    vecelt = randlc(&tran, amult);\n    vecloc = randlc(&tran, amult);\n    i = icnvrt(vecloc, nn1) + 1;\n    if (i > n)\n      continue;\n\n    if (mark[i] == 0)\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n      nzv = nzv + 1;\n      v[nzv] = vecelt;\n      iv[nzv] = i;\n    }\n\n  }\n\n  for (ii = 1; ii <= nzrow; ii++)\n  {\n    i = nzloc[ii];\n    mark[i] = 0;\n  }\n\n}\n\n\nstatic void vecset(int n, double v[], int iv[], int *nzv, int i, double val)\n{\n  int k;\n  boolean set;\n  set = 0;\n  for (k = 1; k <= (*nzv); k++)\n  {\n    if (iv[k] == i)\n    {\n      v[k] = val;\n      set = 1;\n    }\n\n  }\n\n  if (set == 0)\n  {\n    *nzv = (*nzv) + 1;\n    v[*nzv] = val;\n    iv[*nzv] = i;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = firstrow; i <= lastrow; i++)\n{\n  if ((i >= firstcol) && (i <= lastcol))\n  {\n    iouter = n + i;\n    nnza = nnza + 1;\n    if (nnza > nz)\n    {\n      printf(\"Space for matrix elements exceeded in makea\\n\");\n      printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n      printf(\"iouter = %d\\n\", iouter);\n      exit(1);\n    }\n\n    acol[nnza] = i;\n    arow[nnza] = i;\n    aelt[nnza] = rcond - shift;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = ((arow[nza] - firstrow) + 1) + 1;\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 2; j <= (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = (arow[nza] - firstrow) + 1;\n  k = rowstr[j];\n  a[k] = aelt[nza];\n  colidx[k] = acol[nza];\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = nrows; j >= 1; j--)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= nrows; j++)\n{\n  nzrow = 0;\n  for (k = jajp1; k < rowstr[j + 1]; k++)\n  {\n    i = colidx[k];\n    x[i] = x[i] + a[k];\n    if ((mark[i] == 0) && (x[i] != 0.0))\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n    }\n\n  }\n\n  for (k = 1; k <= nzrow; k++)\n  {\n    i = nzloc[k];\n    mark[i] = 0;\n    xi = x[i];\n    x[i] = 0.0;\n    if (xi != 0.0)\n    {\n      nza = nza + 1;\n      a[nza] = xi;\n      colidx[nza] = i;\n    }\n\n  }\n\n  jajp1 = rowstr[j + 1];\n  rowstr[j + 1] = nza + rowstr[1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 1; ii <= nzrow; ii++)\n{\n  i = nzloc[ii];\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= (*nzv); k++)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  colidx[n + i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= n; j++)\n{\n  rowstr[j] = 0;\n  mark[j] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  x[i] = 0.0;\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  sprnvc(n, nzv, v, iv, &colidx[0], &colidx[n]);\n  vecset(n, v, iv, &nzv, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    if ((jcol >= firstcol) && (jcol <= lastcol))\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        if ((irow >= firstrow) && (irow <= lastrow))\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\nstatic void sprnvc(int n, int nz, double v[], int iv[], int nzloc[], int mark[])\n{\n  int nn1;\n  int nzrow;\n  int nzv;\n  int ii;\n  int i;\n  double vecelt;\n  double vecloc;\n  nzv = 0;\n  nzrow = 0;\n  nn1 = 1;\n  do\n  {\n    nn1 = 2 * nn1;\n  }\n  while (nn1 < n);\n  while (nzv < nz)\n  {\n    vecelt = randlc(&tran, amult);\n    vecloc = randlc(&tran, amult);\n    i = icnvrt(vecloc, nn1) + 1;\n    if (i > n)\n      continue;\n\n    if (mark[i] == 0)\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n      nzv = nzv + 1;\n      v[nzv] = vecelt;\n      iv[nzv] = i;\n    }\n\n  }\n\n  for (ii = 1; ii <= nzrow; ii++)\n  {\n    i = nzloc[ii];\n    mark[i] = 0;\n  }\n\n}\n\n\nstatic void vecset(int n, double v[], int iv[], int *nzv, int i, double val)\n{\n  int k;\n  boolean set;\n  set = 0;\n  for (k = 1; k <= (*nzv); k++)\n  {\n    if (iv[k] == i)\n    {\n      v[k] = val;\n      set = 1;\n    }\n\n  }\n\n  if (set == 0)\n  {\n    *nzv = (*nzv) + 1;\n    v[*nzv] = val;\n    iv[*nzv] = i;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = firstrow; i <= lastrow; i++)\n{\n  if ((i >= firstcol) && (i <= lastcol))\n  {\n    iouter = n + i;\n    nnza = nnza + 1;\n    if (nnza > nz)\n    {\n      printf(\"Space for matrix elements exceeded in makea\\n\");\n      printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n      printf(\"iouter = %d\\n\", iouter);\n      exit(1);\n    }\n\n    acol[nnza] = i;\n    arow[nnza] = i;\n    aelt[nnza] = rcond - shift;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = ((arow[nza] - firstrow) + 1) + 1;\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 2; j <= (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = (arow[nza] - firstrow) + 1;\n  k = rowstr[j];\n  a[k] = aelt[nza];\n  colidx[k] = acol[nza];\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = nrows; j >= 1; j--)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= nrows; j++)\n{\n  nzrow = 0;\n  for (k = jajp1; k < rowstr[j + 1]; k++)\n  {\n    i = colidx[k];\n    x[i] = x[i] + a[k];\n    if ((mark[i] == 0) && (x[i] != 0.0))\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n    }\n\n  }\n\n  for (k = 1; k <= nzrow; k++)\n  {\n    i = nzloc[k];\n    mark[i] = 0;\n    xi = x[i];\n    x[i] = 0.0;\n    if (xi != 0.0)\n    {\n      nza = nza + 1;\n      a[nza] = xi;\n      colidx[nza] = i;\n    }\n\n  }\n\n  jajp1 = rowstr[j + 1];\n  rowstr[j + 1] = nza + rowstr[1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 1; ii <= nzrow; ii++)\n{\n  i = nzloc[ii];\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= (*nzv); k++)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  a += i;\n}\n\n", "pragma": "omp parallel for private(a)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (a = 0; a < n; a++)\n{\n}\n\n", "pragma": "omp parallel for private(a)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  x = w * (i - 0.5);\n  sum = sum + f(x);\n}\n\nlong double f(long double y)\n{\n  return 4.0 / (1.0 + (y * y));\n}\n\n\n", "pragma": "omp parallel for private(x) shared(w) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n{\n  hypre__nx = i;\n  hypre__ny = j;\n  a[i][j] = hypre__nx + hypre__ny;\n}\n\n\n", "pragma": "omp parallel for private (HYPRE_SMP_PRIVATE)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + (i + i2);\n}\n\n", "pragma": "omp parallel for firstprivate(i2) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + (i + i2);\n}\n\n", "pragma": "omp parallel for private(i2) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + i;\n  i0 = i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) lastprivate(i0)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + i;\n  i0 = i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) private(i0)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i < 100; i++)\n{\n  {\n    is_larger = check_i_islarger2(i) && is_larger;\n    sum = sum + i;\n  }\n}\n\nstatic int check_i_islarger2(int i)\n{\n  int islarger;\n  islarger = i > last_i;\n  last_i = i;\n  return islarger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1) ordered", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < 100; i++)\n{\n  {\n    is_larger = check_i_islarger2(i) && is_larger;\n    sum = sum + i;\n  }\n}\n\nstatic int check_i_islarger2(int i)\n{\n  int islarger;\n  islarger = i > last_i;\n  last_i = i;\n  return islarger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  i2 = i;\n  do_some_work2();\n  sum = sum + i2;\n}\n\nstatic void do_some_work2()\n{\n  int i;\n  double sum = 0;\n  for (i = 0; i < 1000; i++)\n  {\n    sum += sqrt(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) private(i2) schedule(static,1)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  i2 = i;\n  do_some_work2();\n  sum = sum + i2;\n}\n\nstatic void do_some_work2()\n{\n  int i;\n  double sum = 0;\n  for (i = 0; i < 1000; i++)\n  {\n    sum += sqrt(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  sum += sqrt(i);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(-:diff)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(+:dsum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(-:ddiff)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(*:product)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(&&:logic_and)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(&&:logic_and)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(||:logic_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(||:logic_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(&:bit_and)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(&:bit_and)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(|:bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(|:bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 10000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (int) ((-1.0) + (dx * (i - 1)));\n  yy = (int) ((-1.0) + (dy * (j - 1)));\n  u[i][j] = 0.0;\n  f[i][j] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (-1.0) + (dx * (i - 1));\n  yy = (-1.0) + (dy * (j - 1));\n  temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n  error = error + (temp * temp);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n  uold[i][j] = u[i][j];\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (n - 1); i++)\n  for (j = 1; j < (m - 1); j++)\n{\n  resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n  u[i][j] = uold[i][j] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= num_steps; i++)\n{\n  x = (i - 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction (+:sum) private (x)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 100; i++)\n  colidx[i] = 0;\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 100; i++)\n  for (j = 1; j <= 100; j++)\n  colidx[i][j] = 0;\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  for (k = 0; k < 50; k++)\n  colidx[i][j][k] = 0;\n\n\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 100; i++)\n  colidx[i] = 0;\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  colidx[n + i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= n; j++)\n{\n  rowstr[j] = 0;\n  mark[j] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= n; i++)\n{\n  x[i] = 0.0;\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    colidx[k] = (colidx[k] - firstcol) + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= (1400 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (it = 1; it <= 1; it++)\n{\n  conj_grad(colidx, rowstr, x, z, a, p, q, r, w, &rnorm);\n  {\n    norm_temp11 = 0.0;\n    norm_temp12 = 0.0;\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    norm_temp11 = norm_temp11 + (x[j] * z[j]);\n    norm_temp12 = norm_temp12 + (z[j] * z[j]);\n  }\n\n  norm_temp12 = 1.0 / sqrt(norm_temp12);\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    x[j] = norm_temp12 * z[j];\n  }\n\n}\n\nstatic void conj_grad(int colidx[], int rowstr[], double x[], double z[], double a[], double p[], double q[], double r[], double w[], double *rnorm)\n{\n  static double d;\n  static double sum;\n  static double rho;\n  static double rho0;\n  static double alpha;\n  static double beta;\n  int i;\n  int j;\n  int k;\n  int cgit;\n  int cgitmax = 25;\n  rho = 0.0;\n  for (j = 1; j <= (naa + 1); j++)\n  {\n    q[j] = 0.0;\n    z[j] = 0.0;\n    r[j] = x[j];\n    p[j] = r[j];\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (x[j] * x[j]);\n  }\n\n  for (cgit = 1; cgit <= cgitmax; cgit++)\n  {\n    {\n      rho0 = rho;\n      d = 0.0;\n      rho = 0.0;\n    }\n    for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n    {\n      sum = 0.0;\n      for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n      {\n        sum = sum + (a[k] * p[colidx[k]]);\n      }\n\n      w[j] = sum;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      q[j] = w[j];\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      w[j] = 0.0;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      d = d + (p[j] * q[j]);\n    }\n\n    alpha = rho0 / d;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      z[j] = z[j] + (alpha * p[j]);\n      r[j] = r[j] - (alpha * q[j]);\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      rho = rho + (r[j] * r[j]);\n    }\n\n    beta = rho / rho0;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      p[j] = r[j] + (beta * p[j]);\n    }\n\n  }\n\n  sum = 0.0;\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    d = 0.0;\n    for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n    {\n      d = d + (a[k] * z[colidx[k]]);\n    }\n\n    w[j] = d;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    r[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = x[j] - r[j];\n    sum = sum + (d * d);\n  }\n\n  {\n    *rnorm = sqrt(sum);\n  }\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= (1400 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (it = 1; it <= 15; it++)\n{\n  conj_grad(colidx, rowstr, x, z, a, p, q, r, w, &rnorm);\n  {\n    norm_temp11 = 0.0;\n    norm_temp12 = 0.0;\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    norm_temp11 = norm_temp11 + (x[j] * z[j]);\n    norm_temp12 = norm_temp12 + (z[j] * z[j]);\n  }\n\n  {\n    norm_temp12 = 1.0 / sqrt(norm_temp12);\n    zeta = 10.0 + (1.0 / norm_temp11);\n  }\n  {\n    if (it == 1)\n    {\n      printf(\"   iteration           ||r||                 zeta\\n\");\n    }\n\n    printf(\"    %5d       %20.14e%20.13e\\n\", it, rnorm, zeta);\n  }\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    x[j] = norm_temp12 * z[j];\n  }\n\n}\n\nstatic void conj_grad(int colidx[], int rowstr[], double x[], double z[], double a[], double p[], double q[], double r[], double w[], double *rnorm)\n{\n  static double d;\n  static double sum;\n  static double rho;\n  static double rho0;\n  static double alpha;\n  static double beta;\n  int i;\n  int j;\n  int k;\n  int cgit;\n  int cgitmax = 25;\n  rho = 0.0;\n  for (j = 1; j <= (naa + 1); j++)\n  {\n    q[j] = 0.0;\n    z[j] = 0.0;\n    r[j] = x[j];\n    p[j] = r[j];\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (x[j] * x[j]);\n  }\n\n  for (cgit = 1; cgit <= cgitmax; cgit++)\n  {\n    {\n      rho0 = rho;\n      d = 0.0;\n      rho = 0.0;\n    }\n    for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n    {\n      sum = 0.0;\n      for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n      {\n        sum = sum + (a[k] * p[colidx[k]]);\n      }\n\n      w[j] = sum;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      q[j] = w[j];\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      w[j] = 0.0;\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      d = d + (p[j] * q[j]);\n    }\n\n    alpha = rho0 / d;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      z[j] = z[j] + (alpha * p[j]);\n      r[j] = r[j] - (alpha * q[j]);\n    }\n\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      rho = rho + (r[j] * r[j]);\n    }\n\n    beta = rho / rho0;\n    for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n    {\n      p[j] = r[j] + (beta * p[j]);\n    }\n\n  }\n\n  sum = 0.0;\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    d = 0.0;\n    for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n    {\n      d = d + (a[k] * z[colidx[k]]);\n    }\n\n    w[j] = d;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    r[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = x[j] - r[j];\n    sum = sum + (d * d);\n  }\n\n  {\n    *rnorm = sqrt(sum);\n  }\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= (naa + 1); j++)\n{\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = x[j];\n  p[j] = r[j];\n  w[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  rho = rho + (x[j] * x[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (cgit = 1; cgit <= cgitmax; cgit++)\n{\n  {\n    rho0 = rho;\n    d = 0.0;\n    rho = 0.0;\n  }\n  for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n  {\n    sum = 0.0;\n    for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n    {\n      sum = sum + (a[k] * p[colidx[k]]);\n    }\n\n    w[j] = sum;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    q[j] = w[j];\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    w[j] = 0.0;\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    d = d + (p[j] * q[j]);\n  }\n\n  alpha = rho0 / d;\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    z[j] = z[j] + (alpha * p[j]);\n    r[j] = r[j] - (alpha * q[j]);\n  }\n\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    rho = rho + (r[j] * r[j]);\n  }\n\n  beta = rho / rho0;\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    p[j] = r[j] + (beta * p[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  w[j] = d;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  r[j] = w[j];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  d = x[j] - r[j];\n  sum = sum + (d * d);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  sprnvc(n, nzv, v, iv, &colidx[0], &colidx[n]);\n  vecset(n, v, iv, &nzv, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    if ((jcol >= firstcol) && (jcol <= lastcol))\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        if ((irow >= firstrow) && (irow <= lastrow))\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\nstatic void sprnvc(int n, int nz, double v[], int iv[], int nzloc[], int mark[])\n{\n  int nn1;\n  int nzrow;\n  int nzv;\n  int ii;\n  int i;\n  double vecelt;\n  double vecloc;\n  nzv = 0;\n  nzrow = 0;\n  nn1 = 1;\n  do\n  {\n    nn1 = 2 * nn1;\n  }\n  while (nn1 < n);\n  while (nzv < nz)\n  {\n    vecelt = randlc(&tran, amult);\n    vecloc = randlc(&tran, amult);\n    i = icnvrt(vecloc, nn1) + 1;\n    if (i > n)\n      continue;\n\n    if (mark[i] == 0)\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n      nzv = nzv + 1;\n      v[nzv] = vecelt;\n      iv[nzv] = i;\n    }\n\n  }\n\n  for (ii = 1; ii <= nzrow; ii++)\n  {\n    i = nzloc[ii];\n    mark[i] = 0;\n  }\n\n}\n\n\nstatic void vecset(int n, double v[], int iv[], int *nzv, int i, double val)\n{\n  int k;\n  boolean set;\n  set = 0;\n  for (k = 1; k <= (*nzv); k++)\n  {\n    if (iv[k] == i)\n    {\n      v[k] = val;\n      set = 1;\n    }\n\n  }\n\n  if (set == 0)\n  {\n    *nzv = (*nzv) + 1;\n    v[*nzv] = val;\n    iv[*nzv] = i;\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = firstrow; i <= lastrow; i++)\n{\n  if ((i >= firstcol) && (i <= lastcol))\n  {\n    iouter = n + i;\n    nnza = nnza + 1;\n    if (nnza > nz)\n    {\n      printf(\"Space for matrix elements exceeded in makea\\n\");\n      printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n      printf(\"iouter = %d\\n\", iouter);\n      exit(1);\n    }\n\n    acol[nnza] = i;\n    arow[nnza] = i;\n    aelt[nnza] = rcond - shift;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = ((arow[nza] - firstrow) + 1) + 1;\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 2; j <= (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (nza = 1; nza <= nnza; nza++)\n{\n  j = (arow[nza] - firstrow) + 1;\n  k = rowstr[j];\n  a[k] = aelt[nza];\n  colidx[k] = acol[nza];\n  rowstr[j] = rowstr[j] + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = nrows; j >= 1; j--)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= nrows; j++)\n{\n  nzrow = 0;\n  for (k = jajp1; k < rowstr[j + 1]; k++)\n  {\n    i = colidx[k];\n    x[i] = x[i] + a[k];\n    if ((mark[i] == 0) && (x[i] != 0.0))\n    {\n      mark[i] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n    }\n\n  }\n\n  for (k = 1; k <= nzrow; k++)\n  {\n    i = nzloc[k];\n    mark[i] = 0;\n    xi = x[i];\n    x[i] = 0.0;\n    if (xi != 0.0)\n    {\n      nza = nza + 1;\n      a[nza] = xi;\n      colidx[nza] = i;\n    }\n\n  }\n\n  jajp1 = rowstr[j + 1];\n  rowstr[j + 1] = nza + rowstr[1];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 1; ii <= nzrow; ii++)\n{\n  i = nzloc[ii];\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= (*nzv); k++)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (int) ((-1.0) + (dx * (i - 1)));\n  yy = (int) ((-1.0) + (dy * (j - 1)));\n  u[i][j] = 0.0;\n  f[i][j] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,j,i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (-1.0) + (dx * (i - 1));\n  yy = (-1.0) + (dy * (j - 1));\n  temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n  error = error + (temp * temp);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n  uold[i][j] = u[i][j];\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (n - 1); i++)\n  for (j = 1; j < (m - 1); j++)\n{\n  resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n  u[i][j] = uold[i][j] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (jj = 0; jj < 9; jj++)\n  {\n    for (kkk = 0; kkk < 8; kkk++)\n    {\n      a[i][jj][kkk] = 9.9;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 100; i++)\n{\n  j = j + 1;\n  a[i] = a[i] + j;\n}\n\n", "pragma": "omp parallel for lastprivate(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n{\n  u[i][j] = 0.0;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= 100; k++)\n  for (j = 1; j <= 100; j++)\n{\n  jlast = j;\n  klast = k;\n}\n\n\n", "pragma": "omp parallel for private(j,k), collapse(2), lastprivate (jlast, klast)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= num_steps; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for firstprivate (sum) lastprivate (sum)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < 1000; k++)\n{\n  i = (k == 0) ? (0) : (key_buff_ptr_global[k - 1]);\n  while (i < key_buff_ptr_global[k])\n    key_array[i++] = k;\n\n}\n\n", "pragma": "omp parallel for private(i,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < 1000; i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "omp parallel for private(i) reduction(+:j)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  printf(\"%2d,Hello,world.!\\n\", i);\n}\n\n", "pragma": "omp parallel for ordered schedule (static,5)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (int) ((-1.0) + (dx * (i - 1)));\n  yy = (int) ((-1.0) + (dy * (j - 1)));\n  u[i][j] = 0.0;\n  f[i][j] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,j,i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (-1.0) + (dx * (i - 1));\n  yy = (-1.0) + (dy * (j - 1));\n  temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n  error = error + (temp * temp);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n  uold[i][j] = u[i][j];\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (n - 1); i++)\n  for (j = 1; j < (m - 1); j++)\n{\n  resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n  u[i][j] = uold[i][j] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,temp,j,i) reduction(+:error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[i] = i * 2;\n  sum += i;\n}\n\n", "pragma": "omp parallel for if(1) ordered reduction(+:sum) schedule(dynamic, 5)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for private(is)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for firstprivate(is)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for lastprivate(is)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for schedule(static,30) firstprivate(is) lastprivate(is)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 90; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for schedule(static,30) firstprivate(is) lastprivate(is)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n{\n  hypre__nx = i;\n  hypre__ny = j;\n  a[i][j] = hypre__nx + hypre__ny;\n}\n\n\n", "pragma": "omp parallel for private (HYPRE_SMP_PRIVATE)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 100; i++)\n{\n  myval = i * i;\n  {\n    printf(\"%d %d\\n\", i, myval);\n  }\n}\n\n", "pragma": "omp parallel for private(myval) ordered", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n{\n  t_id = omp_get_thread_num();\n  {\n    printf(\"I am i=%d in thread %d\\n\", i, t_id);\n  }\n}\n\n", "pragma": "omp parallel for ordered private (t_id)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100000; i++)\n  a[i] = 2 * i;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  a[i][j] = 999;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  if (a[i][j] != 999)\n  printf(\"a[%d][%d]!=999\\n\", i, j);\n\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= upper; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i <= total; i++)\n{\n  res = res + i;\n  res = res - (2 * i);\n  yy *= 1;\n  zz *= 1;\n}\n\n", "pragma": "omp parallel for reduction(+:res) reduction(*:yy,zz)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  counter++;\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n  counter++;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n  counter += 3;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < N; j++)\n{\n  b[j] = c[j];\n}\n\n", "pragma": "omp parallel for shared(b) firstprivate(c)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < N; j++)\n{\n  b[j] = c[j];\n}\n\n", "pragma": "omp parallel for shared(b) firstprivate(c)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n{\n  hypre__nx = i;\n  hypre__ny = j;\n  a[i][j] = hypre__nx + hypre__ny;\n}\n\n\n", "pragma": "omp parallel for private ( HYPRE_SMP_PRIVATE )", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; ++i)\n{\n  printf(\"+++ pdo %d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (row = 2; row < (height - 2); row++)\n  for (col = 2, indx = (row * u) + col; col < (width - 2); col++, indx++)\n{\n  r1 = (((((((image[indx - 1][0] + image[indx + 1][0]) + image[indx - u][0]) + image[indx + u][0]) + image[(indx - u) - 1][0]) + image[(indx + u) + 1][0]) + image[(indx - u) + 1][0]) + image[(indx + u) - 1][0]) / 8.0;\n  g1 = (((((((image[indx - 1][1] + image[indx + 1][1]) + image[indx - u][1]) + image[indx + u][1]) + image[(indx - u) - 1][1]) + image[(indx + u) + 1][1]) + image[(indx - u) + 1][1]) + image[(indx + u) - 1][1]) / 8.0;\n  b1 = (((((((image[indx - 1][2] + image[indx + 1][2]) + image[indx - u][2]) + image[indx + u][2]) + image[(indx - u) - 1][2]) + image[(indx + u) + 1][2]) + image[(indx - u) + 1][2]) + image[(indx + u) - 1][2]) / 8.0;\n  image[indx][0] = CLIP(r1 + (image[indx][1] - g1));\n  image[indx][2] = CLIP(b1 + (image[indx][1] - g1));\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, indx, g1, r1, b1)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (indx = 0; indx < (height * width); indx++)\n{\n  image2[indx][0] = image[indx][0];\n  image2[indx][2] = image[indx][2];\n}\n\n", "pragma": "omp parallel for schedule(static) private(indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (indx = 0; indx < (height * width); indx++)\n{\n  image[indx][0] = image2[indx][0];\n  image[indx][2] = image2[indx][2];\n}\n\n", "pragma": "omp parallel for schedule(static) private(indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 2; row < (height - 2); row++)\n{\n  for (col = 2, indx = (row * width) + col; col < (width - 2); col++, indx++)\n  {\n    c = fc(row, col);\n    if (c != 1)\n    {\n      image[indx][1] = CLIP(((((image[indx + u][1] + image[indx - u][1]) + image[indx - 1][1]) + image[indx + 1][1]) / 4.0) + ((image[indx][c] - ((((image[indx + v][c] + image[indx - v][c]) + image[indx - 2][c]) + image[indx + 2][c]) / 4.0)) / 2.0));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 4; row < (height - 4); row++)\n{\n  for (col = 4, indx = (row * width) + col; col < (width - 4); col++, indx++)\n  {\n    c = fc(row, col);\n    if (c != 1)\n    {\n      image[indx][1] = CLIP((((((image[indx + v][1] + image[indx - v][1]) + image[indx - 2][1]) + image[indx + 2][1]) / 4.0) + image[indx][c]) - ((((image[indx + v][c] + image[indx - v][c]) + image[indx - 2][c]) + image[indx + 2][c]) / 4.0));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 1; row < (height - 1); row++)\n  for (col = 1 + (FC(row, 1) & 1), indx = (row * width) + col, c = 2 - FC(row, col); col < (u - 1); col += 2, indx += 2)\n{\n  image[indx][c] = CLIP((((((((((4 * image[indx][1]) - image[(indx + u) + 1][1]) - image[(indx + u) - 1][1]) - image[(indx - u) + 1][1]) - image[(indx - u) - 1][1]) + image[(indx + u) + 1][c]) + image[(indx + u) - 1][c]) + image[(indx - u) + 1][c]) + image[(indx - u) - 1][c]) / 4.0);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 1; row < (height - 1); row++)\n  for (col = 1 + (FC(row, 2) & 1), indx = (row * width) + col, c = FC(row, col + 1), d = 2 - c; col < (width - 1); col += 2, indx += 2)\n{\n  image[indx][c] = CLIP((((((2 * image[indx][1]) - image[indx + 1][1]) - image[indx - 1][1]) + image[indx + 1][c]) + image[indx - 1][c]) / 2.0);\n  image[indx][d] = CLIP((((((2 * image[indx][1]) - image[indx + u][1]) - image[indx - u][1]) + image[indx + u][d]) + image[indx - u][d]) / 2.0);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, d, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 1; row < (height - 1); row++)\n  for (col = 1 + (FC(row, 1) & 1), indx = (row * width) + col, c = FC(row, col), d = c / 2; col < (u - 1); col += 2, indx += 2)\n  chroma[indx][d] = image[indx][c] - image[indx][1];\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, d)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 3; row < (height - 3); row++)\n  for (col = 3 + (FC(row, 1) & 1), indx = (row * width) + col, c = 1 - (FC(row, col) / 2), d = 1 - c; col < (u - 3); col += 2, indx += 2)\n{\n  f[0] = 1.0 / ((float) (((1.0 + fabs(chroma[(indx - u) - 1][c] - chroma[(indx + u) + 1][c])) + fabs(chroma[(indx - u) - 1][c] - chroma[(indx - w) - 3][c])) + fabs(chroma[(indx + u) + 1][c] - chroma[(indx - w) - 3][c])));\n  f[1] = 1.0 / ((float) (((1.0 + fabs(chroma[(indx - u) + 1][c] - chroma[(indx + u) - 1][c])) + fabs(chroma[(indx - u) + 1][c] - chroma[(indx - w) + 3][c])) + fabs(chroma[(indx + u) - 1][c] - chroma[(indx - w) + 3][c])));\n  f[2] = 1.0 / ((float) (((1.0 + fabs(chroma[(indx + u) - 1][c] - chroma[(indx - u) + 1][c])) + fabs(chroma[(indx + u) - 1][c] - chroma[(indx + w) + 3][c])) + fabs(chroma[(indx - u) + 1][c] - chroma[(indx + w) - 3][c])));\n  f[3] = 1.0 / ((float) (((1.0 + fabs(chroma[(indx + u) + 1][c] - chroma[(indx - u) - 1][c])) + fabs(chroma[(indx + u) + 1][c] - chroma[(indx + w) - 3][c])) + fabs(chroma[(indx - u) - 1][c] - chroma[(indx + w) + 3][c])));\n  g[0] = (((1.325 * chroma[(indx - u) - 1][c]) - (0.175 * chroma[(indx - w) - 3][c])) - (0.075 * chroma[(indx - w) - 1][c])) - (0.075 * chroma[(indx - u) - 3][c]);\n  g[1] = (((1.325 * chroma[(indx - u) + 1][c]) - (0.175 * chroma[(indx - w) + 3][c])) - (0.075 * chroma[(indx - w) + 1][c])) - (0.075 * chroma[(indx - u) + 3][c]);\n  g[2] = (((1.325 * chroma[(indx + u) - 1][c]) - (0.175 * chroma[(indx + w) - 3][c])) - (0.075 * chroma[(indx + w) - 1][c])) - (0.075 * chroma[(indx + u) - 3][c]);\n  g[3] = (((1.325 * chroma[(indx + u) + 1][c]) - (0.175 * chroma[(indx + w) + 3][c])) - (0.075 * chroma[(indx + w) + 1][c])) - (0.075 * chroma[(indx + u) + 3][c]);\n  chroma[indx][c] = ((((f[0] * g[0]) + (f[1] * g[1])) + (f[2] * g[2])) + (f[3] * g[3])) / (((f[0] + f[1]) + f[2]) + f[3]);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, d, indx, f, g)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 3; row < (height - 3); row++)\n  for (col = 3 + (FC(row, 2) & 1), indx = (row * width) + col, c = FC(row, col + 1) / 2; col < (u - 3); col += 2, indx += 2)\n  for (d = 0; d <= 1; c = 1 - c, d++)\n{\n  f[0] = 1.0 / ((float) (((1.0 + fabs(chroma[indx - u][c] - chroma[indx + u][c])) + fabs(chroma[indx - u][c] - chroma[indx - w][c])) + fabs(chroma[indx + u][c] - chroma[indx - w][c])));\n  f[1] = 1.0 / ((float) (((1.0 + fabs(chroma[indx + 1][c] - chroma[indx - 1][c])) + fabs(chroma[indx + 1][c] - chroma[indx + 3][c])) + fabs(chroma[indx - 1][c] - chroma[indx + 3][c])));\n  f[2] = 1.0 / ((float) (((1.0 + fabs(chroma[indx - 1][c] - chroma[indx + 1][c])) + fabs(chroma[indx - 1][c] - chroma[indx - 3][c])) + fabs(chroma[indx + 1][c] - chroma[indx - 3][c])));\n  f[3] = 1.0 / ((float) (((1.0 + fabs(chroma[indx + u][c] - chroma[indx - u][c])) + fabs(chroma[indx + u][c] - chroma[indx + w][c])) + fabs(chroma[indx - u][c] - chroma[indx + w][c])));\n  g[0] = (0.875 * chroma[indx - u][c]) + (0.125 * chroma[indx - w][c]);\n  g[1] = (0.875 * chroma[indx + 1][c]) + (0.125 * chroma[indx + 3][c]);\n  g[2] = (0.875 * chroma[indx - 1][c]) + (0.125 * chroma[indx - 3][c]);\n  g[3] = (0.875 * chroma[indx + u][c]) + (0.125 * chroma[indx + w][c]);\n  chroma[indx][c] = ((((f[0] * g[0]) + (f[1] * g[1])) + (f[2] * g[2])) + (f[3] * g[3])) / (((f[0] + f[1]) + f[2]) + f[3]);\n}\n\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, d, indx, f, g)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 3; row < (height - 3); row++)\n  for (col = 3, indx = (row * width) + col; col < (width - 3); col++, indx++)\n{\n  image[indx][0] = CLIP(chroma[indx][0] + image[indx][1]);\n  image[indx][2] = CLIP(chroma[indx][1] + image[indx][1]);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 2; row < (height - 2); row++)\n{\n  for (col = 2, indx = (row * width) + col; col < (width - 2); col++, indx++)\n  {\n    if (image[indx][1] > ((((image[indx - 1][1] + image[indx + 1][1]) + image[indx - u][1]) + image[indx + u][1]) / 4.0))\n      image[indx][3] = ((MIN(image[indx - 1][1], image[indx + 1][1]) + image[indx - 1][1]) + image[indx + 1][1]) < ((MIN(image[indx - u][1], image[indx + u][1]) + image[indx - u][1]) + image[indx + u][1]);\n    else\n      image[indx][3] = ((MAX(image[indx - 1][1], image[indx + 1][1]) + image[indx - 1][1]) + image[indx + 1][1]) > ((MAX(image[indx - u][1], image[indx + u][1]) + image[indx - u][1]) + image[indx + u][1]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 4; row < (height - 4); row++)\n{\n  for (col = 4, indx = (row * width) + col; col < (width - 4); col++, indx++)\n  {\n    c = FC(row, col);\n    if (c != 1)\n    {\n      current = (((((4 * image[indx][3]) + (2 * (((image[indx + u][3] + image[indx - u][3]) + image[indx + 1][3]) + image[indx - 1][3]))) + image[indx + v][3]) + image[indx - v][3]) + image[indx + 2][3]) + image[indx - 2][3];\n      image[indx][1] = ((((16 - current) * (image[indx - 1][1] + image[indx + 1][1])) / 2.0) + ((current * (image[indx - u][1] + image[indx + u][1])) / 2.0)) / 16.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, current)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 4; row < (height - 4); row++)\n{\n  for (col = 4, indx = (row * width) + col; col < (width - 4); col++, indx++)\n  {\n    c = FC(row, col);\n    if (c != 1)\n    {\n      current = (((((4 * image[indx][3]) + (2 * (((image[indx + u][3] + image[indx - u][3]) + image[indx + 1][3]) + image[indx - 1][3]))) + image[indx + v][3]) + image[indx - v][3]) + image[indx + 2][3]) + image[indx - 2][3];\n      image[indx][1] = CLIP((((16 - current) * ((((image[indx - 1][1] + image[indx + 1][1]) / 2.0) + image[indx][c]) - ((image[indx + 2][c] + image[indx - 2][c]) / 2.0))) + (current * ((((image[indx - u][1] + image[indx + u][1]) / 2.0) + image[indx][c]) - ((image[indx + v][c] + image[indx - v][c]) / 2.0)))) / 16.0);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, current)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 5; row < (height - 5); row++)\n  for (col = 5 + (FC(row, 1) & 1), indx = (row * width) + col, c = FC(row, col); col < (u - 5); col += 2, indx += 2)\n{\n  f[0] = 1.0 / ((1.0 + abs(image[indx - u][c] - image[indx][c])) + abs(image[indx - u][1] - image[indx][1]));\n  f[1] = 1.0 / ((1.0 + abs(image[indx + 1][c] - image[indx][c])) + abs(image[indx + 1][1] - image[indx][1]));\n  f[2] = 1.0 / ((1.0 + abs(image[indx - 1][c] - image[indx][c])) + abs(image[indx - 1][1] - image[indx][1]));\n  f[3] = 1.0 / ((1.0 + abs(image[indx + u][c] - image[indx][c])) + abs(image[indx + u][1] - image[indx][1]));\n  g[0] = CLIP((image[indx - u][1] + (0.5 * (image[indx][c] - image[indx - u][c]))) + (0.25 * (image[indx][c] - image[indx - v][c])));\n  g[1] = CLIP((image[indx + 1][1] + (0.5 * (image[indx][c] - image[indx + 1][c]))) + (0.25 * (image[indx][c] - image[indx + 2][c])));\n  g[2] = CLIP((image[indx - 1][1] + (0.5 * (image[indx][c] - image[indx - 1][c]))) + (0.25 * (image[indx][c] - image[indx - 2][c])));\n  g[3] = CLIP((image[indx + u][1] + (0.5 * (image[indx][c] - image[indx + u][c]))) + (0.25 * (image[indx][c] - image[indx + v][c])));\n  image[indx][1] = CLIP(((((f[0] * g[0]) + (f[1] * g[1])) + (f[2] * g[2])) + (f[3] * g[3])) / (((f[0] + f[1]) + f[2]) + f[3]));\n  min = MIN(image[(indx + 1) + u][1], MIN(image[(indx + 1) - u][1], MIN(image[(indx - 1) + u][1], MIN(image[(indx - 1) - u][1], MIN(image[indx - 1][1], MIN(image[indx + 1][1], MIN(image[indx - u][1], image[indx + u][1])))))));\n  max = MAX(image[(indx + 1) + u][1], MAX(image[(indx + 1) - u][1], MAX(image[(indx - 1) + u][1], MAX(image[(indx - 1) - u][1], MAX(image[indx - 1][1], MAX(image[indx + 1][1], MAX(image[indx - u][1], image[indx + u][1])))))));\n  image[indx][1] = ULIM(image[indx][1], max, min);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, min, max, f, g)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (indx = 0; indx < (height * width); indx++)\n{\n  image3[indx][0] = (image[indx][0] + image[indx][1]) + image[indx][2];\n  image3[indx][1] = 1.732050808 * (image[indx][0] - image[indx][1]);\n  image3[indx][2] = ((2.0 * image[indx][2]) - image[indx][0]) - image[indx][1];\n}\n\n", "pragma": "omp parallel for schedule(static) private(indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (indx = 0; indx < (height * width); indx++)\n{\n  image[indx][0] = CLIP(((image3[indx][0] / 3.0) - (image3[indx][2] / 6.0)) + (image3[indx][1] / 3.464101615));\n  image[indx][1] = CLIP(((image3[indx][0] / 3.0) - (image3[indx][2] / 6.0)) - (image3[indx][1] / 3.464101615));\n  image[indx][2] = CLIP((image3[indx][0] / 3.0) + (image3[indx][2] / 3.0));\n}\n\n", "pragma": "omp parallel for schedule(static) private(indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 4; row < (height - 4); row++)\n{\n  for (col = 4, indx = (row * width) + col; col < (width - 4); col++, indx++)\n  {\n    c = fc(row, col);\n    if (c != 1)\n    {\n      current = image[indx][c] - ((((image[indx + v][c] + image[indx - v][c]) + image[indx - 2][c]) + image[indx + 2][c]) / 4.0);\n      g2 = (((image[indx + u][1] + image[indx - u][1]) + image[indx - 1][1]) + image[indx + 1][1]) / 4.0;\n      g1 = (((image[indx + w][1] + image[indx - w][1]) + image[indx - 3][1]) + image[indx + 3][1]) / 4.0;\n      image[indx][1] = CLIP(((g2 + g1) / 2.0) + current);\n      min = MIN(image[indx - 1][1], MIN(image[indx + 1][1], MIN(image[indx - u][1], image[indx + u][1])));\n      max = MAX(image[indx - 1][1], MAX(image[indx + 1][1], MAX(image[indx - u][1], image[indx + u][1])));\n      image[indx][1] = ULIM(image[indx][1], max, min);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, current, min, max, g1, g2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 2; row < (height - 2); row++)\n{\n  for (col = 2, indx = (row * width) + col; col < (width - 2); col++, indx++)\n  {\n    c = fc(row, col);\n    image[indx][c] = ULIM(image[indx][c], MAX(image[indx - 1][c], MAX(image[indx + 1][c], MAX(image[indx - u][c], image[indx + u][c]))), MIN(image[indx - 1][c], MIN(image[indx + 1][c], MIN(image[indx - u][c], image[indx + u][c]))));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (indx = 2 + v; indx < ((height * width) - (2 + v)); indx++)\n{\n  if ((image3[indx][1] * image3[indx][2]) != 0)\n  {\n    Co = (((((image3[indx + v][1] + image3[indx - v][1]) + image3[indx - 2][1]) + image3[indx + 2][1]) - MAX(image3[indx - 2][1], MAX(image3[indx + 2][1], MAX(image3[indx - v][1], image3[indx + v][1])))) - MIN(image3[indx - 2][1], MIN(image3[indx + 2][1], MIN(image3[indx - v][1], image3[indx + v][1])))) / 2.0;\n    Ho = (((((image3[indx + v][2] + image3[indx - v][2]) + image3[indx - 2][2]) + image3[indx + 2][2]) - MAX(image3[indx - 2][2], MAX(image3[indx + 2][2], MAX(image3[indx - v][2], image3[indx + v][2])))) - MIN(image3[indx - 2][2], MIN(image3[indx + 2][2], MIN(image3[indx - v][2], image3[indx + v][2])))) / 2.0;\n    ratio = sqrt(((Co * Co) + (Ho * Ho)) / ((image3[indx][1] * image3[indx][1]) + (image3[indx][2] * image3[indx][2])));\n    if (ratio < 0.85)\n    {\n      image3[indx][1] = Co;\n      image3[indx][2] = Ho;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(indx, Co, Ho, ratio)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 5; row < (height - 5); row++)\n  for (col = 5 + (FC(row, 1) & 1), indx = (row * width) + col, c = FC(row, col); col < (u - 5); col += 2, indx += 2)\n{\n  f[0] = 1.0 / ((1.0 + abs(image[indx - u][1] - image[indx - w][1])) + abs(image[indx - w][1] - image[indx + y][1]));\n  f[1] = 1.0 / ((1.0 + abs(image[indx + 1][1] - image[indx + 3][1])) + abs(image[indx + 3][1] - image[indx - 5][1]));\n  f[2] = 1.0 / ((1.0 + abs(image[indx - 1][1] - image[indx - 3][1])) + abs(image[indx - 3][1] - image[indx + 5][1]));\n  f[3] = 1.0 / ((1.0 + abs(image[indx + u][1] - image[indx + w][1])) + abs(image[indx + w][1] - image[indx - y][1]));\n  g[0] = CLIP((((((23 * image[indx - u][1]) + (23 * image[indx - w][1])) + (2 * image[indx - y][1])) + (8 * (image[indx - v][c] - image[indx - x][c]))) + (40 * (image[indx][c] - image[indx - v][c]))) / 48.0);\n  g[1] = CLIP((((((23 * image[indx + 1][1]) + (23 * image[indx + 3][1])) + (2 * image[indx + 5][1])) + (8 * (image[indx + 2][c] - image[indx + 4][c]))) + (40 * (image[indx][c] - image[indx + 2][c]))) / 48.0);\n  g[2] = CLIP((((((23 * image[indx - 1][1]) + (23 * image[indx - 3][1])) + (2 * image[indx - 5][1])) + (8 * (image[indx - 2][c] - image[indx - 4][c]))) + (40 * (image[indx][c] - image[indx - 2][c]))) / 48.0);\n  g[3] = CLIP((((((23 * image[indx + u][1]) + (23 * image[indx + w][1])) + (2 * image[indx + y][1])) + (8 * (image[indx + v][c] - image[indx + x][c]))) + (40 * (image[indx][c] - image[indx + v][c]))) / 48.0);\n  image[indx][1] = CLIP(((((f[0] * g[0]) + (f[1] * g[1])) + (f[2] * g[2])) + (f[3] * g[3])) / (((f[0] + f[1]) + f[2]) + f[3]));\n  min = MIN(image[(indx + 1) + u][1], MIN(image[(indx + 1) - u][1], MIN(image[(indx - 1) + u][1], MIN(image[(indx - 1) - u][1], MIN(image[indx - 1][1], MIN(image[indx + 1][1], MIN(image[indx - u][1], image[indx + u][1])))))));\n  max = MAX(image[(indx + 1) + u][1], MAX(image[(indx + 1) - u][1], MAX(image[(indx - 1) + u][1], MAX(image[(indx - 1) - u][1], MAX(image[indx - 1][1], MAX(image[indx + 1][1], MAX(image[indx - u][1], image[indx + u][1])))))));\n  image[indx][1] = ULIM(image[indx][1], max, min);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, min, max, f, g)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (row = 2; row < (height - 2); row++)\n  for (col = 2 + (FC(row, 2) & 1), indx = (row * width) + col, c = FC(row, col), d = c / 2; col < (u - 2); col += 2, indx += 2)\n  chroma[indx][d] = image[indx][c] - image[indx][1];\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, min, max, f, g)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (row = 3; row < (height - 3); row++)\n  for (col = 3 + (FC(row, 1) & 1), indx = (row * width) + col, d = 1 - (FC(row, col) / 2), c = 2 * d; col < (u - 3); col += 2, indx += 2)\n{\n  f[0] = 1.0 / (((1.0 + abs(chroma[(indx - u) - 1][d] - chroma[(indx + u) + 1][d])) + abs(chroma[(indx - u) - 1][d] - chroma[(indx - w) - 3][d])) + abs(chroma[(indx + u) + 1][d] - chroma[(indx - w) - 3][d]));\n  f[1] = 1.0 / (((1.0 + abs(chroma[(indx - u) + 1][d] - chroma[(indx + u) - 1][d])) + abs(chroma[(indx - u) + 1][d] - chroma[(indx - w) + 3][d])) + abs(chroma[(indx + u) - 1][d] - chroma[(indx - w) + 3][d]));\n  f[2] = 1.0 / (((1.0 + abs(chroma[(indx + u) - 1][d] - chroma[(indx - u) + 1][d])) + abs(chroma[(indx + u) - 1][d] - chroma[(indx + w) + 3][d])) + abs(chroma[(indx - u) + 1][d] - chroma[(indx + w) - 3][d]));\n  f[3] = 1.0 / (((1.0 + abs(chroma[(indx + u) + 1][d] - chroma[(indx - u) - 1][d])) + abs(chroma[(indx + u) + 1][d] - chroma[(indx + w) - 3][d])) + abs(chroma[(indx - u) - 1][d] - chroma[(indx + w) + 3][d]));\n  chroma[indx][d] = ((((f[0] * chroma[(indx - u) - 1][d]) + (f[1] * chroma[(indx - u) + 1][d])) + (f[2] * chroma[(indx + u) - 1][d])) + (f[3] * chroma[(indx + u) + 1][d])) / (((f[0] + f[1]) + f[2]) + f[3]);\n  image[indx][c] = CLIP(chroma[indx][d] + image[indx][1]);\n}\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, min, max, f, g)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (row = 3; row < (height - 3); row++)\n  for (col = 3 + (FC(row, 2) & 1), indx = (row * width) + col; col < (u - 3); col += 2, indx += 2)\n  for (c = (d = 0); d <= 1; c += 2, d++)\n{\n  f[0] = 1.0 / (((1.0 + abs(chroma[indx - u][d] - chroma[indx + u][d])) + abs(chroma[indx - u][d] - chroma[indx - w][d])) + abs(chroma[indx + u][d] - chroma[indx - w][d]));\n  f[1] = 1.0 / (((1.0 + abs(chroma[indx + 1][d] - chroma[indx - 1][d])) + abs(chroma[indx + 1][d] - chroma[indx + 3][d])) + abs(chroma[indx - 1][d] - chroma[indx + 3][d]));\n  f[2] = 1.0 / (((1.0 + abs(chroma[indx - 1][d] - chroma[indx + 1][d])) + abs(chroma[indx - 1][d] - chroma[indx - 3][d])) + abs(chroma[indx + 1][d] - chroma[indx - 3][d]));\n  f[3] = 1.0 / (((1.0 + abs(chroma[indx + u][d] - chroma[indx - u][d])) + abs(chroma[indx + u][d] - chroma[indx + w][d])) + abs(chroma[indx - u][d] - chroma[indx + w][d]));\n  image[indx][c] = CLIP((((((f[0] * chroma[indx - u][d]) + (f[1] * chroma[indx + 1][d])) + (f[2] * chroma[indx - 1][d])) + (f[3] * chroma[indx + u][d])) / (((f[0] + f[1]) + f[2]) + f[3])) + image[indx][1]);\n}\n\n\n\n", "pragma": "omp parallel for schedule(static) private(row, col, c, indx, min, max, f, g)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  tid = omp_get_thread_num();\n  printf(\"%d : thread %d\\n\", i, tid);\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i) schedule(static,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i) schedule(static,chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (a[i] * b[i]);\n  tid = omp_get_thread_num();\n  printf(\"%d %d : %f\\n\", i, tid, result);\n}\n\n", "pragma": "omp parallel for default(shared) private(i,tid) schedule(static,chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < nRowsA; i++)\n{\n  for (j = 0; j < nColumnsB; j++)\n  {\n    C[j + (i * nColumnsB)] = 0.0;\n    for (k = 0; k < n; k++)\n    {\n      C[j + (i * nColumnsB)] += A[k + (i * n)] * B[j + (k * nColumnsB)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i * 1.0;\n  b[i] = i * 2.0;\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 4; j++)\n{\n  for (i = 0; i < 1536; i++)\n  {\n    pixels[i + (j * 1536)] = computePoint(i, j + (myJobStart / 1536));\n  }\n\n}\n\nint computePoint(int _x, int _y)\n{\n  int iteration;\n  int color;\n  double xtemp;\n  double x0;\n  double y0;\n  double x;\n  double y;\n  x0 = (((double) _x) - 1024) / (((double) 1024) / ((double) 2));\n  y0 = (((double) _y) - 512) / (((double) 1024) / ((double) 2));\n  iteration = 0;\n  x = 0;\n  y = 0;\n  while ((((x * x) + (y * y)) < 4) && (iteration < 1000))\n  {\n    xtemp = ((x * x) - (y * y)) + x0;\n    y = ((2 * x) * y) + y0;\n    x = xtemp;\n    iteration++;\n  }\n\n  color = 1000 - iteration;\n  return color;\n}\n\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1024; j++)\n{\n  for (i = 0; i < 1536; i++)\n  {\n    fprintf(fp, \"%d \", pixels[i + (j * 1536)]);\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (loopCount = 0; loopCount < (((256 * 2) + nproc) - 1); loopCount++)\n{\n  MPI_Recv(myRecvArr, 1, (MPI_Datatype) 0x4c000405, -2, 0, (MPI_Comm) 0x44000000, &status);\n  if (myRecvArr[0] == (-1))\n  {\n    if (numJobs > 0)\n    {\n      mySendArr[0] = jobCount * 1536;\n      jobCount++;\n      MPI_Send(mySendArr, 1, (MPI_Datatype) 0x4c000405, status.MPI_SOURCE, 0, (MPI_Comm) 0x44000000);\n      numJobs--;\n    }\n    else\n    {\n      mySendArr[0] = -1;\n      MPI_Send(mySendArr, 1, (MPI_Datatype) 0x4c000405, status.MPI_SOURCE, 0, (MPI_Comm) 0x44000000);\n    }\n\n  }\n  else\n    if (myRecvArr[0] == (-2))\n  {\n    MPI_Recv(myRecvArr, (1536 * 4) + 1, (MPI_Datatype) 0x4c000405, status.MPI_SOURCE, 0, (MPI_Comm) 0x44000000, &status);\n    jobStart = myRecvArr[0];\n    for (i = 1; i < ((1536 * 4) + 1); i++)\n    {\n      pixels[(i - 1) + jobStart] = myRecvArr[i];\n    }\n\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < ((1536 * 4) + 1); i++)\n{\n  mySendArr[i] = pixels[i - 1];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nMatrices; i++)\n{\n  nTotalColumns += Cii[i]->columns;\n  assert((nRows == Cii[i]->rows) && \"The number of rows in each matrix must be the same!\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nMatrices; i++)\n{\n  for (j = 0; j < Cii[i]->columns; j++)\n  {\n    C->nNoneZero[k + j] = Cii[i]->nNoneZero[j];\n    C->NoneZero[k + j] = Cii[i]->NoneZero[j];\n    C->nZero[k + j] = Cii[i]->nZero[j];\n    C->Zero[k + j] = Cii[i]->Zero[j];\n  }\n\n  k += j;\n  assert((k <= nTotalColumns) && \"Too many columns!\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < rows; i++)\n{\n  printf(\"[ \");\n  for (j = 0; j < columns; j++)\n  {\n    printf(\"%3.1f \", M[j + (i * columns)]);\n  }\n\n  printf(\" ]\\n\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  Z[i] = &tmp[i * (2 * cM->columns)];\n  NZ[i] = &tmp2[i * cM->columns];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < cM->columns; j++)\n{\n  for (i = 0; i < cM->rows; i++)\n  {\n    if (M[j + (i * cM->columns)] == 0.0)\n    {\n      start = i;\n      end = i + 1;\n      while ((end < cM->rows) && (M[j + (end * cM->columns)] == 0.0))\n        end++;\n\n      Z[j][(cM->nZero[j] * 2) + 0] = start;\n      Z[j][(cM->nZero[j] * 2) + 1] = end;\n      cM->nZero[j]++;\n      i = end - 1;\n    }\n    else\n    {\n      NZ[j][cM->nNoneZero[j]] = M[j + (i * cM->columns)];\n      cM->nNoneZero[j]++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  nTotalZeros += cM->nZero[i];\n  nTotalNoneZeros += cM->nNoneZero[i];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  cM->Zero[i] = &t[pos];\n  pos += cM->nZero[i] * 2;\n  memcpy(cM->Zero[i], Z[i], ((sizeof(int)) * 2) * cM->nZero[i]);\n  cM->NoneZero[i] = &t2[pos2];\n  pos2 += cM->nNoneZero[i];\n  memcpy(cM->NoneZero[i], NZ[i], (sizeof(double)) * cM->nNoneZero[i]);\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < cM->columns; j++)\n{\n  nNZ = 0;\n  rowPos = 0;\n  k = 0;\n  for (i = 0; i < cM->nZero[j]; i++)\n  {\n    while (rowPos < cM->Zero[j][(i * 2) + 0])\n    {\n      M[j + (rowPos * cM->columns)] = cM->NoneZero[j][nNZ];\n      nNZ++;\n      rowPos++;\n    }\n\n    while (rowPos < cM->Zero[j][(i * 2) + 1])\n    {\n      M[j + (rowPos * cM->columns)] = 0.0;\n      rowPos++;\n    }\n\n  }\n\n  assert((nNZ <= cM->nNoneZero[j]) && \"Too many NZ values!\");\n  while (nNZ < cM->nNoneZero[j])\n  {\n    M[j + (rowPos * cM->columns)] = cM->NoneZero[j][nNZ];\n    rowPos++;\n    nNZ++;\n  }\n\n  assert((rowPos == cM->rows) && \"Not correct row Position!\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  printf(\"C[%d] nNZ[%d] NZ[\", i, cM->nNoneZero[i]);\n  for (j = 0; j < cM->nNoneZero[i]; j++)\n  {\n    printf(\"%3.1f \", cM->NoneZero[i][j]);\n  }\n\n  printf(\"] nZ[%d] Z[\", cM->nZero[i]);\n  for (j = 0; j < cM->nZero[i]; j++)\n  {\n    printf(\"(%d,%d) \", cM->Zero[i][j * 2], cM->Zero[i][(j * 2) + 1]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = startColumn; i < endColumn; i++)\n{\n  nTotalNoneZero += cM->nNoneZero[i];\n  nTotalZero += cM->nZero[i];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nColumns; i++)\n{\n  nTotalNoneZero += cM->nNoneZero[i];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  cM->NoneZero[i] = &b2[nTotalNoneZero];\n  nTotalNoneZero += cM->nNoneZero[i];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nColumns; i++)\n{\n  nTotalZero += cM->nZero[i];\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  cM->Zero[i] = &b3[nTotalZero];\n  nTotalZero += cM->nZero[i] * 2;\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  work(&alocal, &blocal);\n  x += alocal;\n  y += blocal;\n}\n\nvoid work(ip, jp)\nint *ip;\nint *jp;\n{\n  *ip = 1;\n  *jp = -1;\n}\n\n\n", "pragma": "omp parallel for private(i, alocal, blocal) shared(n) reduction(+: x, y)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < np; i++)\n{\n  work(i);\n}\n\nvoid work(i)\nint i;\n{\n  x[i] = i;\n}\n\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n{\n  x[i] = -1;\n  y[i] = -1;\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < thds; i++)\n{\n  if (x[i] != i)\n  {\n    errors++;\n    printf(\"omp_get_thread_num 015 - expected x[%d] = %d, observed %d\\n\", i, i, x[i]);\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; i < 1024; i++)\n{\n  if (x[i] != (-1))\n  {\n    errors++;\n    printf(\"omp_get_thread_num 015 - expected x[%d] = %d, observed %d\\n\", i, -1, x[i]);\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (thds = 0; thds < 1024; thds++)\n{\n  if (y[thds] != thds)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = thds; i < 1024; i++)\n{\n  if (y[i] != (-1))\n  {\n    errors++;\n    printf(\"omp_get_thread_num 015 - expected y[%d] = %d, observed %d\\n\", i, -1, y[i]);\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n{\n  work(i, j);\n}\n\nvoid work(i, j)\nint i;\nint j;\n{\n  iw[i][j] = i + (j * 117);\n}\n\n\n", "pragma": "omp parallel for shared(i, n)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n{\n  work(i, j);\n}\n\nvoid work(i, j)\nint i;\nint j;\n{\n  iw[i][j] = i + (j * 117);\n}\n\n\n", "pragma": "omp parallel for shared(i, n)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p_i = 0; p_i < cur_alloc_query; ++p_i)\n{\n  double **G;\n  unsigned int **H;\n  unsigned int j;\n  G = (double **) malloc((n + 1) * (sizeof(double *)));\n  G[0] = (double *) calloc((n + 1) * (m + 1), sizeof(double));\n  for (j = 1; j < (n + 1); ++j)\n    G[j] = ((void *) G[0]) + ((j * (m + 1)) * (sizeof(double)));\n\n  H = (unsigned int **) malloc((n + 1) * (sizeof(unsigned int *)));\n  H[0] = (unsigned int *) calloc((n + 1) * (m + 1), sizeof(unsigned int));\n  for (j = 1; j < (n + 1); ++j)\n    H[j] = ((void *) H[0]) + ((j * (m + 1)) * (sizeof(unsigned int)));\n\n  unsigned int start = 0;\n  unsigned int gap_pos = 0;\n  unsigned int where = 0;\n  unsigned int MINgap = 0;\n  double MAXscore = 0;\n  unsigned int o_i = (t_i * cur_alloc_query) + p_i;\n  dp_algorithm(G, H, t[t_i].data, n, p[p_i].data, m, scoring_matrix, MAXgap);\n  opt_solution(G, n, m, MAXgap, gap_open_pen, gap_extend_pen, &MAXscore, &MINgap, &where, &start);\n  if (MINgap > 0)\n    backtracing(H, m, n, start, where, &gap_pos);\n  else\n    gap_pos = 0;\n\n  out[o_i].max_score = MAXscore;\n  out[o_i].min_gap = MINgap;\n  out[o_i].where = where;\n  out[o_i].gap_pos = gap_pos;\n  free(G[0]);\n  free(H[0]);\n  free(G);\n  free(H);\n}\n\n", "pragma": "omp parallel for private ( p_i )", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  printf(\"%f\\t\", A[(ii * N) + jj]);\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  for (int i = 0; i < 5; i++)\n  {\n    double start = omp_get_wtime();\n    cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, A, N, B, N, 1.0, C, N);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n  }\n\n}\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid clearMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = 0.0;\n\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[(ii * N) + kk];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[(ii * N) + jj] += r * B[(kk * N) + jj];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n{\n  if (A[(ii * N) + jj] != B[(ii * N) + jj])\n    err++;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n{\n  printf(\"\\n\");\n  for (int jj = 0; jj < N; jj++)\n    printf(\"%f\\t\", A[(ii * N) + jj]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  median += array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  flag &= fabs(array[i] - median) <= (0.02 * median);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  if (array[i] > tmp)\n  {\n    tmp = array[i];\n    pos = i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = n;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[(ii * N) + kk];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[(ii * N) + jj] += r * B[(kk * N) + jj];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[ii + (N * kk)];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[ii + (N * jj)] += r * B[kk + (N * jj)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n{\n  diff = fabs(A[(ii * N) + jj] - B[(ii * N) + jj]);\n  if (diff > 1.0)\n    err++;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n{\n  printf(\"\\n\");\n  for (int jj = 0; jj < N; jj++)\n    printf(\"%f\\t\", A[(ii * N) + jj]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  median += array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  flag &= fabs(array[i] - median) <= (0.02 * median);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  if (array[i] > tmp)\n  {\n    tmp = array[i];\n    pos = i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = n;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[(ii * N) + kk];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[(ii * N) + jj] += r * B[(kk * N) + jj];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n{\n  if (A[(ii * N) + jj] != B[(ii * N) + jj])\n    err++;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n{\n  printf(\"\\n\");\n  for (int jj = 0; jj < N; jj++)\n    printf(\"%f\\t\", A[(ii * N) + jj]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  median += array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  flag &= fabs(array[i] - median) <= (0.02 * median);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  if (array[i] > tmp)\n  {\n    tmp = array[i];\n    pos = i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[(ii * N) + kk];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[(ii * N) + jj] += r * B[(kk * N) + jj];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  printf(\"%f\\t\", A[(ii * N) + jj]);\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (long j = 0; j < length; j++)\n{\n  if (debug)\n    fprintf(stderr, \"sorting #%d (size %d)\\n\", j, vlengths[j]);\n\n  msort(vector[j], vlengths[j]);\n}\n\nvoid msort(int *v, long l)\n{\n  int *tmpbuf = malloc(l * (sizeof(int)));\n  TopDownSplitMerge(v, 0, l, tmpbuf, 0);\n  free(tmpbuf);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  median += array[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  flag &= fabs(array[i] - median) <= (0.05 * median);\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  if (array[i] > tmp)\n  {\n    tmp = array[i];\n    pos = i;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  int attempt = 0;\n  double ktests[3];\n  int domoretests = 1;\n  while (domoretests)\n  {\n    double start = omp_get_wtime();\n    thrMM(A, B, C);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n    if (attempt < 3)\n    {\n      ktests[attempt] = elapsed;\n    }\n    else\n    {\n      insertTest(elapsed, ktests);\n    }\n\n    if (attempt == 20)\n      domoretests = 0;\n\n    if ((attempt >= 5) && withinTol(ktests))\n      domoretests = 0;\n\n    attempt++;\n  }\n\n  for (int i = 0; i < 3; i++)\n    printf(\"# %f\\n\", ktests[i]);\n\n  printf(\"# attempts: %d\\n\", attempt);\n}\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid clearMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = 0.0;\n\n\n}\n\n\nvoid thrMM(float *A, float *B, float *C)\n{\n  for (int ii = 0; ii < N; ++ii)\n  {\n    for (int kk = 0; kk < N; ++kk)\n    {\n      float r = A[(ii * N) + kk];\n      for (int jj = 0; jj < N; ++jj)\n      {\n        C[(ii * N) + jj] += r * B[(kk * N) + jj];\n      }\n\n    }\n\n  }\n\n}\n\n\nvoid insertTest(double time, double *array)\n{\n  int pos = 0;\n  double tmp = DBL_MIN;\n  for (int i = 0; i < 3; i++)\n  {\n    if (array[i] > tmp)\n    {\n      tmp = array[i];\n      pos = i;\n    }\n\n  }\n\n  if (time < tmp)\n    array[pos] = time;\n\n}\n\n\nint withinTol(double *array)\n{\n  int flag = 1;\n  double median = 0;\n  for (int i = 0; i < 3; i++)\n  {\n    median += array[i];\n  }\n\n  median = median / 3;\n  for (int i = 0; i < 3; i++)\n  {\n    flag &= fabs(array[i] - median) <= (0.05 * median);\n  }\n\n  return flag;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii += Nb)\n{\n  for (int kk = 0; kk < N; kk += Nb)\n  {\n    for (int jj = 0; jj < N; jj += Nb)\n    {\n      for (int i = ii; i < min(ii + Nb, N); i++)\n      {\n        for (int k = kk; k < min(kk + Nb, N); k++)\n        {\n          float r = A[(i * N) + k];\n          for (int j = jj; j < min(jj + Nb, N); j++)\n          {\n            C[(i * N) + j] += r * B[(k * N) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\ninline int min(int a, int b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n\ninline int min(int a, int b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n\ninline int min(int a, int b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < N; jj = jj + Nb)\n  for (int kk = 0; kk < N; kk = kk + Nb)\n  for (int i = 0; i < N; i++)\n  for (int j = jj; j < min(jj + Nb, N); ++j)\n{\n  float r = 0;\n  for (int k = kk; k < min(kk + Nb, N); k++)\n    r += A[(i * N) + k] * B[(k * N) + j];\n\n  C[(i * N) + j] += r;\n}\n\n\n\n\ninline int min(int a, int b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n\ninline int min(int a, int b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  printf(\"%f\\t\", A[(ii * N) + jj]);\n\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n{\n  if (ii == jj)\n    printf(\"!!!%f vs %f \\n\", A[(ii * N) + jj], B[(ii * N) + jj]);\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  median += array[i];\n}\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  flag &= fabs(array[i] - median) <= (0.05 * median);\n}\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 3; i++)\n{\n  if (array[i] > tmp)\n  {\n    tmp = array[i];\n    pos = i;\n  }\n\n}\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  clearMatrix(D);\n  int attempt = 0;\n  double ktests[3];\n  int domoretests = 1;\n  while (domoretests)\n  {\n    double start = omp_get_wtime();\n    thrMMB(A, B, D);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n    if (attempt < 3)\n    {\n      ktests[attempt] = elapsed;\n    }\n    else\n    {\n      insertTest(elapsed, ktests);\n    }\n\n    if (attempt == 20)\n      domoretests = 0;\n\n    if ((attempt >= 5) && withinTol(ktests))\n      domoretests = 0;\n\n    attempt++;\n  }\n\n  for (int i = 0; i < 3; i++)\n    printf(\"# %f\\n\", ktests[i]);\n\n  printf(\"# attempts: %d\\n\", attempt);\n}\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid initMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = ((float) rand()) / ((float) 32767);\n\n\n}\n\n\nvoid clearMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = 0.0;\n\n\n}\n\n\nvoid clearMatrix(float *A)\n{\n  for (int ii = 0; ii < N; ii++)\n    for (int jj = 0; jj < N; jj++)\n    A[(ii * N) + jj] = 0.0;\n\n\n}\n\n\nvoid thrMMB(float *A, float *B, float *C)\n{\n  for (int ii = 0; ii < N; ii += Nb)\n  {\n    for (int kk = 0; kk < N; kk += Nb)\n    {\n      for (int jj = 0; jj < N; jj += Nb)\n      {\n        for (int i = ii; i < min(ii + Nb, N); i++)\n        {\n          for (int k = kk; k < min(kk + Nb, N); k++)\n          {\n            float r = A[(i * N) + k];\n            for (int j = jj; j < min(jj + Nb, N); j++)\n            {\n              C[(i * N) + j] += r * B[(k * N) + j];\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n\nvoid insertTest(double time, double *array)\n{\n  int pos = 0;\n  double tmp = DBL_MIN;\n  for (int i = 0; i < 3; i++)\n  {\n    if (array[i] > tmp)\n    {\n      tmp = array[i];\n      pos = i;\n    }\n\n  }\n\n  if (time < tmp)\n    array[pos] = time;\n\n}\n\n\nint withinTol(double *array)\n{\n  int flag = 1;\n  double median = 0;\n  for (int i = 0; i < 3; i++)\n  {\n    median += array[i];\n  }\n\n  median = median / 3;\n  for (int i = 0; i < 3; i++)\n  {\n    flag &= fabs(array[i] - median) <= (0.05 * median);\n  }\n\n  return flag;\n}\n\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t col = 1; col < (pOutMatrix->width - 1); col++)\n{\n  pOutMatrix->data[col] = pOutMatrix->data[pOutMatrix->width + 1];\n  uint32_t startBeforeLastRow = pOutMatrix->width * (pOutMatrix->height - 2);\n  uint32_t startLastRow = pOutMatrix->width * (pOutMatrix->height - 1);\n  pOutMatrix->data[startLastRow + col] = pOutMatrix->data[startBeforeLastRow + col];\n}\n\n", "pragma": "omp parallel for shared(pOutMatrix)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t startRow = 0; startRow < pOutMatrix->height; startRow += pOutMatrix->width)\n{\n  pOutMatrix->data[startRow] = pOutMatrix->data[startRow + 1];\n  pOutMatrix->data[(startRow + pOutMatrix->width) - 1] = pOutMatrix->data[(startRow + pOutMatrix->width) - 2];\n}\n\n", "pragma": "omp parallel for shared(pOutMatrix)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t px = 0; px < (pMat->width * pMat->height); px++)\n{\n  pImg->data[px] = (unsigned char) ((pMat->data[px] * 255) / maxGrad);\n}\n\n", "pragma": "omp parallel for shared(pImg)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t px = 0; px < (pOutImage->width * pOutImage->height); px++)\n{\n  unNormalizedGradient.data[px] = norm2(pInMatrixX->data[px], pInMatrixY->data[px]);\n}\n\ninline static int16_t norm2(int16_t x, int16_t y)\n{\n  return sqrt((x * x) + (y * y));\n}\n\n\n", "pragma": "omp parallel for shared(unNormalizedGradient)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t i = 0; i < (width * height); i++)\n{\n  uint32_t greyVal = pGSImage->data[i];\n  pRGBAImage->data[4 * i] = greyVal;\n  pRGBAImage->data[(4 * i) + 1] = greyVal;\n  pRGBAImage->data[(4 * i) + 2] = greyVal;\n  pRGBAImage->data[(4 * i) + 3] = 255;\n}\n\n", "pragma": "omp parallel for shared(pRGBAImage)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t i = 0; i < (width * height); i++)\n{\n  unsigned char R;\n  unsigned char G;\n  unsigned char B;\n  unsigned char greyVal;\n  R = pRGBAImage->data[4 * i];\n  G = pRGBAImage->data[(4 * i) + 1];\n  B = pRGBAImage->data[(4 * i) + 2];\n  greyVal = ((R + G) + B) / 3;\n  pGSImage->data[i] = greyVal;\n}\n\n", "pragma": "omp parallel for shared(pGSImage)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint32_t row = 1; row < (pInImage->height - 1); row++)\n{\n  for (uint32_t col = 1; col < (pInImage->width - 1); col++)\n  {\n    int16_t gradX;\n    int16_t gradY;\n    convolution_3_by_3(pInImage, kernelX, row, col, &gradX);\n    convolution_3_by_3(pInImage, kernelY, row, col, &gradY);\n    int16_t norm = norm2(gradX, gradY);\n    pOutMatrix->data[(row * pOutMatrix->width) + col] = norm;\n    if (norm > locMax)\n    {\n      locMax = norm;\n    }\n\n  }\n\n}\n\ninline static void convolution_3_by_3(struct image * const pInImage, kernel_t kernel, uint32_t row, uint32_t col, int16_t * restrict pPixel)\n{\n  uint32_t w = pInImage->width;\n  int16_t acc = 0;\n  acc += kernel[0][0] * pInImage->data[(((row + 1) * w) + col) + 1];\n  acc += kernel[0][1] * pInImage->data[((row + 1) * w) + col];\n  acc += kernel[0][2] * pInImage->data[(((row + 1) * w) + col) - 1];\n  acc += kernel[1][0] * pInImage->data[((row * w) + col) + 1];\n  acc += kernel[1][1] * pInImage->data[(row * w) + col];\n  acc += kernel[1][2] * pInImage->data[((row * w) + col) - 1];\n  acc += kernel[2][0] * pInImage->data[(((row - 1) * w) + col) + 1];\n  acc += kernel[2][1] * pInImage->data[((row - 1) * w) + col];\n  acc += kernel[2][2] * pInImage->data[(((row - 1) * w) + col) - 1];\n  *pPixel = acc;\n}\n\n\ninline static void convolution_3_by_3(struct image * const pInImage, kernel_t kernel, uint32_t row, uint32_t col, int16_t * restrict pPixel)\n{\n  uint32_t w = pInImage->width;\n  int16_t acc = 0;\n  acc += kernel[0][0] * pInImage->data[(((row + 1) * w) + col) + 1];\n  acc += kernel[0][1] * pInImage->data[((row + 1) * w) + col];\n  acc += kernel[0][2] * pInImage->data[(((row + 1) * w) + col) - 1];\n  acc += kernel[1][0] * pInImage->data[((row * w) + col) + 1];\n  acc += kernel[1][1] * pInImage->data[(row * w) + col];\n  acc += kernel[1][2] * pInImage->data[((row * w) + col) - 1];\n  acc += kernel[2][0] * pInImage->data[(((row - 1) * w) + col) + 1];\n  acc += kernel[2][1] * pInImage->data[((row - 1) * w) + col];\n  acc += kernel[2][2] * pInImage->data[(((row - 1) * w) + col) - 1];\n  *pPixel = acc;\n}\n\n\ninline static int16_t norm2(int16_t x, int16_t y)\n{\n  return sqrt((x * x) + (y * y));\n}\n\n\n", "pragma": "omp parallel for shared(pGSImage)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < order; j++)\n  for (i = 0; i < order; i++)\n{\n  A[i + (order * j)] = (B[i + (order * j)] = (double) j);\n  C[i + (order * j)] = 0.0;\n}\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  {\n    dgemm_time = wtime();\n  }\n  if (block > 0)\n  {\n    for (jj = 0; jj < order; jj += block)\n    {\n      for (kk = 0; kk < order; kk += block)\n      {\n        for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n          BB[j + ((block + 12) * k)] = B[kg + (order * jg)];\n\n\n        for (ii = 0; ii < order; ii += block)\n        {\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            AA[i + ((block + 12) * k)] = A[ig + (order * kg)];\n\n\n          for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            CC[i + ((block + 12) * j)] = 0.0;\n\n\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n            for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            CC[i + ((block + 12) * j)] += AA[i + ((block + 12) * k)] * BB[j + ((block + 12) * k)];\n\n\n\n          for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            C[ig + (order * jg)] += CC[i + ((block + 12) * j)];\n\n\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    for (jg = 0; jg < order; jg++)\n      for (kg = 0; kg < order; kg++)\n      for (ig = 0; ig < order; ig++)\n      C[ig + (order * jg)] += A[ig + (order * kg)] * B[kg + (order * jg)];\n\n\n\n  }\n\n  {\n    dgemm_time = wtime() - dgemm_time;\n    if ((iter > 0) || (iterations == 1))\n    {\n      avgtime = avgtime + dgemm_time;\n      mintime = (mintime < dgemm_time) ? (mintime) : (dgemm_time);\n      maxtime = (maxtime > dgemm_time) ? (maxtime) : (dgemm_time);\n    }\n\n  }\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (checksum = 0.0, j = 0; j < order; j++)\n  for (i = 0; i < order; i++)\n  checksum += C[i + (order * j)];\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < order; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    diff = (*((trans + (i * order)) + j)) - ((1000.00 * i) + (0.001 * j));\n    errsq += diff * diff;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,diff) reduction(+:errsq)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < order; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    *((A + (i * order)) + j) = (1000.00 * j) + (0.001 * i);\n    *((B + (i * order)) + j) = -1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,diff) reduction(+:errsq)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  {\n    trans_time = wtime();\n  }\n  if (tile_size < order)\n  {\n    for (i = 0; i < order; i += tile_size)\n    {\n      for (j = 0; j < order; j += tile_size)\n      {\n        for (it = i; it < ((order < (i + tile_size)) ? (order) : (i + tile_size)); it++)\n        {\n          for (jt = j; jt < ((order < (j + tile_size)) ? (order) : (j + tile_size)); jt++)\n          {\n            B[it + (order * jt)] = A[jt + (order * it)];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < order; i++)\n    {\n      for (j = 0; j < order; j++)\n      {\n        B[i + (order * j)] = A[j + (order * i)];\n      }\n\n    }\n\n  }\n\n  {\n    trans_time = wtime() - trans_time;\n    if ((iter > 0) || (iterations == 1))\n    {\n      avgtime = avgtime + trans_time;\n      mintime = (mintime < trans_time) ? (mintime) : (trans_time);\n      maxtime = (maxtime > trans_time) ? (maxtime) : (trans_time);\n    }\n\n  }\n  errsq += test_results(order, B);\n}\n\ndouble test_results(int order, double *trans)\n{\n  double diff;\n  double errsq = 0.0;\n  int i;\n  int j;\n  for (i = 0; i < order; i++)\n  {\n    for (j = 0; j < order; j++)\n    {\n      diff = (*((trans + (i * order)) + j)) - ((1000.00 * i) + (0.001 * j));\n      errsq += diff * diff;\n    }\n\n  }\n\n  return errsq;\n}\n\n\n", "pragma": "omp parallel for private(j,diff) reduction(+:errsq)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < (npart * 3); i += 3)\n{\n  double fxi = 0.0;\n  double fyi = 0.0;\n  double fzi = 0.0;\n  for (int j = i + 3; j < (npart * 3); j += 3)\n  {\n    double xx = x[i] - x[j];\n    double yy = x[i + 1] - x[j + 1];\n    double zz = x[i + 2] - x[j + 2];\n    if (xx < ((-0.5) * side))\n      xx += side;\n\n    if (xx > (0.5 * side))\n      xx -= side;\n\n    if (yy < ((-0.5) * side))\n      yy += side;\n\n    if (yy > (0.5 * side))\n      yy -= side;\n\n    if (zz < ((-0.5) * side))\n      zz += side;\n\n    if (zz > (0.5 * side))\n      zz -= side;\n\n    double rd = ((xx * xx) + (yy * yy)) + (zz * zz);\n    if (rd <= (rcoff * rcoff))\n    {\n      double fcomp = pot(rd);\n      fxi += xx * fcomp;\n      fyi += yy * fcomp;\n      fzi += zz * fcomp;\n      f[j] -= xx * fcomp;\n      f[j + 1] -= yy * fcomp;\n      f[j + 2] -= zz * fcomp;\n    }\n\n  }\n\n  f[i] += fxi;\n  f[i + 1] += fyi;\n  f[i + 2] += fzi;\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 100; i++)\n{\n  hist[i] = 0;\n  omp_init_lock(&hist_lcks[i]);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  x = drandom();\n  long ival = ((long) (x - xlow)) / bin_width;\n  omp_set_lock(&hist_lcks[ival]);\n  hist[ival]++;\n  omp_unset_lock(&hist_lcks[ival]);\n}\n\n", "pragma": "omp parallel for schedule(static) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 100; i++)\n{\n  sumh += (double) hist[i];\n  sumhsq += ((double) hist[i]) * hist[i];\n  omp_destroy_lock(&hist_lcks[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:sumh,sumhsq)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  c[i] += a[i] * b[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  c[i] += a[i] * b[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  c[i] += a[i] * b[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  d[i] += a[i] + c[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < M; j++)\n  MFUNC(i, j, (A + (i * M)) + j);\n\n\n", "pragma": "omp parallel for num_threads(4) collapse(2) if(N*M>100)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5f) * step;\n  sum += 4.0f / (1.0f + (x * x));\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  c[i] += a[i] * b[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  d[i] += a[i] + c[i];\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,j) firstprivate(eps)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int j = 0; j < 1000; j++)\n  tmp += j;\n\n", "pragma": "omp parallel for private(tmp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint();\n  }\n\n}\n\nvoid testpoint(void)\n{\n  struct d_complex z;\n  int iter;\n  double temp;\n  z = c;\n  for (iter = 0; iter < 1000; iter++)\n  {\n    temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n    z.i = ((z.r * z.i) * 2) + c.i;\n    z.r = temp;\n    if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n    {\n      numoutside++;\n      break;\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(c,eps)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < 1000; iter++)\n{\n  temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n  z.i = ((z.r * z.i) * 2) + c.i;\n  z.r = temp;\n  if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n  {\n    numoutside++;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,eps)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint();\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,eps)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n  procWork(&parr[i]);\n\nvoid procWork(struct node *p)\n{\n  int n = p->data;\n  p->procResult = work(n);\n}\n\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  parr[i] = *p;\n  p = p->next;\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  xnew[i] = (double) 0.0;\n  for (j = 0; j < Ndim; j++)\n  {\n    xnew[i] += (A[(i * Ndim) + j] * xold[j]) * (i != j);\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp parallel for private(tmp) reduction(+:conv)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  x1[i] = (double) 0.0;\n  x2[i] = (double) 0.0;\n  b[i] = ((double) (rand() % 51)) / 100.0;\n}\n\n", "pragma": "omp parallel for private(tmp) reduction(+:conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  for (j = 0; j < Ndim; j++)\n    xold[i] += A[(i * Ndim) + j] * xnew[j];\n\n  tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "omp parallel for private(tmp) reduction(+:conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (k = 0; k < Pdim; k++)\n  {\n    for (j = 0; j < Mdim; j++)\n    {\n      *(C + ((i * Mdim) + j)) += (*(A + ((i * Pdim) + k))) * (*(B + ((k * Mdim) + j)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (j = 0; j < Mdim; j++)\n  {\n    tmp = 0.0;\n    for (k = 0; k < Pdim; k++)\n    {\n      tmp += (*(A + ((i * Ndim) + k))) * (*(B + ((k * Pdim) + j)));\n    }\n\n    *(C + ((i * Ndim) + j)) = tmp;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n  for (j = 0; j < Pdim; j++)\n  *(A + ((i * Ndim) + j)) = 3.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Pdim; i++)\n  for (j = 0; j < Mdim; j++)\n  *(B + ((i * Pdim) + j)) = 5.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n  for (j = 0; j < Mdim; j++)\n  *(C + ((i * Ndim) + j)) = 0.0;\n\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (j = 0; j < Mdim; j++)\n  {\n    err = (*((C + (i * Ndim)) + j)) - cval;\n    errsq += err * err;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, i, j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n  for (i = 0; i < n; i++)\n  in[i + (j * n)] = (1.0 * i) + (1.0 * j);\n\n\n", "pragma": "omp parallel for collapse(2) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 8; j < (n - 8); j++)\n  for (i = 8; i < (n - 8); i++)\n  out[i + (j * n)] = 0.0;\n\n\n", "pragma": "omp parallel for collapse(2) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 8; j < (n - 8); j++)\n{\n  for (i = 8; i < (n - 8); i++)\n  {\n    for (jj = -8; jj <= 8; jj++)\n      for (ii = -8; ii <= 8; ii++)\n      out[i + (j * n)] += weight[ii + 8][jj + 8] * in[(i + ii) + ((j + jj) * n)];\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(ii,jj,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n  for (i = 0; i < n; i++)\n  in[i + (j * n)] += 1.0;\n\n\n", "pragma": "omp parallel for collapse(2) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (jj = -8; jj <= 8; jj++)\n  for (ii = -8; ii <= 8; ii++)\n  weight[ii + 8][jj + 8] = 0.0;\n\n\n", "pragma": "omp parallel for collapse(2) private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jj = 1; jj <= 8; jj++)\n{\n  for (ii = (-jj) + 1; ii < jj; ii++)\n  {\n    weight[ii + 8][jj + 8] = (double) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * 8));\n    weight[ii + 8][(-jj) + 8] = -((double) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * 8)));\n    weight[jj + 8][ii + 8] = (double) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * 8));\n    weight[(-jj) + 8][ii + 8] = -((double) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * 8)));\n  }\n\n  weight[jj + 8][jj + 8] = (double) (1.0 / ((4.0 * jj) * 8));\n  weight[(-jj) + 8][(-jj) + 8] = -((double) (1.0 / ((4.0 * jj) * 8)));\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint();\n  }\n\n}\n\nvoid testpoint(void)\n{\n  struct d_complex z;\n  int iter;\n  double temp;\n  z = c;\n  for (iter = 0; iter < 1000; iter++)\n  {\n    temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n    z.i = ((z.r * z.i) * 2) + c.i;\n    z.r = temp;\n    if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n    {\n      numoutside++;\n      break;\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(c,eps)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < 1000; iter++)\n{\n  temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n  z.i = ((z.r * z.i) * 2) + c.i;\n  z.r = temp;\n  if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n  {\n    numoutside++;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,eps)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  c[j] = a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  b[j] = scalar * c[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  c[j] = a[j] + b[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  c[j] = a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  b[j] = scalar * c[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  c[j] = a[j] + b[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 10000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  long ival = ((long) (x[i] - xlow)) / bucket_width;\n  omp_set_lock(&hist_lcks[ival]);\n  hist[ival]++;\n  omp_unset_lock(&hist_lcks[ival]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  long ival = ((long) (x[i] - xlow)) / bucket_width;\n  hist[ival]++;\n}\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < 50; i++)\n  hist[i] = 0;\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 50; i++)\n{\n  sumh += (double) hist[i];\n  sumhsq += ((double) hist[i]) * hist[i];\n}\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  omp_init_lock(&hist_lcks[i]);\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n  x[i] = drandom();\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  long ival = ((long) (x[i] - xlow)) / bucket_width;\n  hist[ival]++;\n}\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  long ival = ((long) (x[i] - xlow)) / bucket_width;\n  hist[ival]++;\n}\n\n", "pragma": "omp parallel for reduction(+:hist[0:num_buckets])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    numoutside += testpoint(c);\n  }\n\n}\n\nint testpoint(struct d_complex c)\n{\n  struct d_complex z;\n  int iter;\n  double temp;\n  int outside = 0;\n  z = c;\n  for (iter = 0; iter < 1000; iter++)\n  {\n    temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n    z.i = ((z.r * z.i) * 2) + c.i;\n    z.r = temp;\n    if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n    {\n      outside++;\n      break;\n    }\n\n  }\n\n  return outside;\n}\n\n\n", "pragma": "omp parallel for private(c,j) firstprivate(eps) reduction(+:numoutside)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (iter = 0; iter < 1000; iter++)\n{\n  temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n  z.i = ((z.r * z.i) * 2) + c.i;\n  z.r = temp;\n  if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n  {\n    outside++;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,j) firstprivate(eps) reduction(+:numoutside)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= num_steps; i++)\n{\n  x = (i - 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= num_steps; i++)\n{\n  x = x0 + (((float) i) * step);\n  sum = sum + (4.0f / (1.0f + (x * x)));\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  sum = 0.0;\n  for (i = 1; i <= num_steps; i++)\n  {\n    x = (i - 0.5) * step;\n    sum = sum + (4.0 / (1.0 + (x * x)));\n  }\n\n  pi = step * sum;\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  sum = 0.0f;\n  for (i = 1; i <= num_steps; i++)\n  {\n    x = (i - 0.5f) * step;\n    sum = sum + (4.0f / (1.0f + (x * x)));\n  }\n\n  pi = step * sum;\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  sum = 0.0;\n  for (i = 1; i <= num_steps; i = i + 4)\n  {\n    x0 = (i - 0.5f) * step;\n    x1 = (i + 0.5f) * step;\n    x2 = (i + 1.5f) * step;\n    x3 = (i + 2.5f) * step;\n    sum = sum + (4.0f * ((((1.0f / (1.0f + (x0 * x0))) + (1.0f / (1.0f + (x1 * x1)))) + (1.0f / (1.0f + (x2 * x2)))) + (1.0f / (1.0f + (x3 * x3)))));\n  }\n\n  pi = step * sum;\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  int ramp = _mm_setr_ps(0.5, 1.5, 2.5, 3.5);\n  int one = _mm_load1_ps(&scalar_one);\n  int four = _mm_load1_ps(&scalar_four);\n  int vstep = _mm_load1_ps(&step);\n  int sum = _mm_load1_ps(&scalar_zero);\n  int xvec;\n  int denom;\n  int eye;\n  for (i = 0; i < num_steps; i = i + 4)\n  {\n    ival = (float) i;\n    eye = _mm_load1_ps(&ival);\n    xvec = _mm_mul_ps(_mm_add_ps(eye, ramp), vstep);\n    denom = _mm_add_ps(_mm_mul_ps(xvec, xvec), one);\n    sum = _mm_add_ps(_mm_div_ps(four, denom), sum);\n  }\n\n  _mm_store_ps(&vsum[0], sum);\n  pi = step * (((vsum[0] + vsum[1]) + vsum[2]) + vsum[3]);\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  pi = 0.0f;\n  for (k = 0; k < 4; k++)\n    local_sum[k] = 0.0;\n\n  {\n    int i;\n    int ID = omp_get_thread_num();\n    float scalar_one = 1.0;\n    float scalar_zero = 0.0;\n    float ival;\n    float scalar_four = 4.0;\n    float vsum[4];\n    int ramp = _mm_setr_ps(0.5, 1.5, 2.5, 3.5);\n    int one = _mm_load1_ps(&scalar_one);\n    int four = _mm_load1_ps(&scalar_four);\n    int vstep = _mm_load1_ps(&step);\n    int sum = _mm_load1_ps(&scalar_zero);\n    int xvec;\n    int denom;\n    int eye;\n    for (i = 0; i < num_steps; i = i + 4)\n    {\n      ival = (float) i;\n      eye = _mm_load1_ps(&ival);\n      xvec = _mm_mul_ps(_mm_add_ps(eye, ramp), vstep);\n      denom = _mm_add_ps(_mm_mul_ps(xvec, xvec), one);\n      sum = _mm_add_ps(_mm_div_ps(four, denom), sum);\n    }\n\n    _mm_store_ps(&vsum[0], sum);\n    local_sum[ID] = step * (((vsum[0] + vsum[1]) + vsum[2]) + vsum[3]);\n  }\n  for (k = 0; k < 4; k++)\n    pi += local_sum[k];\n\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  sum = 0.0f;\n  x0 = (-0.5) * step;\n  for (i = 1; i <= num_steps; i++)\n  {\n    x = x0 + (((float) i) * step);\n    sum = sum + (4.0f / (1.0f + (x * x)));\n  }\n\n  pi = step * sum;\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "omp parallel for simd private(x) reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < n; ++j)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    u_tmp[i + (j * n)] = ((((r2 * u[i + (j * n)]) + (r * ((i < (n - 1)) ? (u[(i + 1) + (j * n)]) : (0.0)))) + (r * ((i > 0) ? (u[(i - 1) + (j * n)]) : (0.0)))) + (r * ((j < (n - 1)) ? (u[i + ((j + 1) * n)]) : (0.0)))) + (r * ((j > 0) ? (u[i + ((j - 1) * n)]) : (0.0)));\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for simd collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int t = 0; t < nsteps; ++t)\n{\n  solve(n, alpha, dx, dt, u, u_tmp);\n  tmp = u;\n  u = u_tmp;\n  u_tmp = tmp;\n}\n\nvoid solve(const int n, const double alpha, const double dx, const double dt, const double * restrict u, double * restrict u_tmp)\n{\n  const double r = (alpha * dt) / (dx * dx);\n  const double r2 = 1.0 - (4.0 * r);\n  for (int j = 0; j < n; ++j)\n  {\n    for (int i = 0; i < n; ++i)\n    {\n      u_tmp[i + (j * n)] = ((((r2 * u[i + (j * n)]) + (r * ((i < (n - 1)) ? (u[(i + 1) + (j * n)]) : (0.0)))) + (r * ((i > 0) ? (u[(i - 1) + (j * n)]) : (0.0)))) + (r * ((j < (n - 1)) ? (u[i + ((j + 1) * n)]) : (0.0)))) + (r * ((j > 0) ? (u[i + ((j - 1) * n)]) : (0.0)));\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp target teams distribute parallel for simd collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < n; ++j)\n{\n  double x = dx;\n  for (int i = 0; i < n; ++i)\n  {\n    u[i + (j * n)] = sin((acos(-1.0) * x) / length) * sin((acos(-1.0) * y) / length);\n    x += dx;\n  }\n\n  y += dx;\n}\n\n", "pragma": "omp target teams distribute parallel for simd collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < n; ++j)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    u[i + (j * n)] = 0.0;\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for simd collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < n; ++j)\n{\n  double x = dx;\n  for (int i = 0; i < n; ++i)\n  {\n    double answer = solution(time, x, y, alpha, length);\n    l2norm += (u[i + (j * n)] - answer) * (u[i + (j * n)] - answer);\n    x += dx;\n  }\n\n  y += dx;\n}\n\ndouble solution(const double t, const double x, const double y, const double alpha, const double length)\n{\n  return (exp((((((-2.0) * alpha) * acos(-1.0)) * acos(-1.0)) * t) / (length * length)) * sin((acos(-1.0) * x) / length)) * sin((acos(-1.0) * y) / length);\n}\n\n\n", "pragma": "omp target teams distribute parallel for simd collapse(2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    xnew[i] += (A[(j * Ndim) + i] * xold[j]) * ((double) (i != j));\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  double tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  xnew[i] = (double) 0.0;\n  b[i] = ((double) (rand() % 51)) / 100.0;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(j * Ndim) + i] * xnew[j];\n\n  double tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    xnew[i] += (A[(i * Ndim) + j] * xold[j]) * ((double) (i != j));\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  double tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  xnew[i] = (double) 0.0;\n  b[i] = ((double) (rand() % 51)) / 100.0;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(i * Ndim) + j] * xnew[j];\n\n  double tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    if (i != j)\n      xnew[i] += A[(i * Ndim) + j] * xold[j];\n\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  double tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  xnew[i] = (double) 0.0;\n  b[i] = ((double) (rand() % 51)) / 100.0;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(i * Ndim) + j] * xnew[j];\n\n  double tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    if (i != j)\n      xnew[i] += A[(i * Ndim) + j] * xold[j];\n\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  double tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  xnew[i] = (double) 0.0;\n  b[i] = ((double) (rand() % 51)) / 100.0;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (double) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(i * Ndim) + j] * xnew[j];\n\n  double tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = ii + 1; i <= (((ii + block_size) < num_steps) ? (ii + block_size) : (num_steps)); i++)\n{\n  x = (i - 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= num_steps; i++)\n{\n  x = (i - 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp teams distribute parallel for simd private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  a[i] = (float) i;\n  b[i] = 2.0 * ((float) i);\n  c[i] = 0.0;\n  res[i] = i + (2 * i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  float val = c[i] - res[i];\n  val = val * val;\n  if (val > 0.0000001)\n    err++;\n\n}\n\n", "pragma": "omp parallel for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  ix = (int) x[i];\n  if ((ix % 2) == 0)\n  {\n    omp_set_lock(&even_lck);\n    even_count++;\n    omp_unset_lock(&even_lck);\n  }\n  else\n  {\n    omp_set_lock(&odd_lck);\n    odd_count++;\n    omp_unset_lock(&odd_lck);\n  }\n\n}\n\n", "pragma": "omp parallel for private(ix)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n  x[i] = drandom();\n\n", "pragma": "omp parallel for private(ix)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  x = drandom();\n  y = drandom();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "omp parallel for private(x,y,test) reduction(+:Ncirc)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n{\n  ix = (int) x[i];\n  if ((ix % 2) == 0)\n  {\n    omp_set_lock(&even_lck);\n    even_count++;\n    omp_unset_lock(&even_lck);\n  }\n  else\n  {\n    omp_set_lock(&odd_lck);\n    odd_count++;\n    omp_unset_lock(&odd_lck);\n  }\n\n}\n\n", "pragma": "omp parallel for private(ix)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000; i++)\n  x[i] = drandom();\n\n", "pragma": "omp parallel for private(ix)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  h_A[i] = 0.0;\n  h_B[i] = 2.0;\n  h_C[i] = 2.0;\n}\n\n", "pragma": "omp parallel for simd schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  asum += fabs(h_A[i]);\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int iter = 0; iter <= iterations; iter++)\n{\n  if (iter == 1)\n    nstream_time = omp_get_wtime();\n\n  for (size_t i = 0; i < length; i++)\n  {\n    d_A[i] += d_B[i] + (scalar * d_C[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i <= iterations; i++)\n{\n  ar += br + (scalar * cr);\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  A[i] = 0.0;\n  B[i] = 2.0;\n  C[i] = 2.0;\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  A[i] += B[i] + (scalar * C[i]);\n}\n\n", "pragma": "omp target teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  asum += fabs(A[i]);\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  A[i] = 0.0;\n  B[i] = 2.0;\n  C[i] = 2.0;\n}\n\n", "pragma": "omp parallel for simd schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (size_t i = 0; i < length; i++)\n{\n  asum += fabs(A[i]);\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int iter = 0; iter <= iterations; iter++)\n{\n  if (iter == 1)\n    nstream_time = prk_wtime();\n\n  for (size_t i = 0; i < length; i++)\n  {\n    A[i] += B[i] + (scalar * C[i]);\n  }\n\n}\n\ninline static double prk_wtime(void)\n{\n  return omp_get_wtime();\n}\n\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i <= iterations; i++)\n{\n  ar += br + (scalar * cr);\n}\n\n", "pragma": "omp parallel for reduction(+:asum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < length; j++)\n{\n  a[j] = 0.0;\n  b[j] = 2.0;\n  c[j] = 2.0;\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < length; j++)\n  a[j] += b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < length; j++)\n  asum += a[j];\n\n", "pragma": "omp parallel for simd reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (j = jstart; j <= jend; j++)\n  for (i = istart; i <= iend; i++)\n{\n  in[((i - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))] = (1.0f * i) + (1.0f * j);\n  out[(i - istart) + ((j - jstart) * width)] = (float) 0.0;\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = (jstart > RADIUS) ? (jstart) : (RADIUS); j <= ((((n - RADIUS) - 1) < jend) ? ((n - RADIUS) - 1) : (jend)); j++)\n{\n  for (i = (istart > RADIUS) ? (istart) : (RADIUS); i <= ((((n - RADIUS) - 1) < iend) ? ((n - RADIUS) - 1) : (iend)); i++)\n  {\n    for (jj = -RADIUS; jj <= RADIUS; jj++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[0 + RADIUS][jj + RADIUS] * in[((i - istart) + RADIUS) + (((long) (((j + jj) - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n    for (ii = -RADIUS; ii < 0; ii++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[ii + RADIUS][0 + RADIUS] * in[(((i + ii) - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n    for (ii = 1; ii <= RADIUS; ii++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[ii + RADIUS][0 + RADIUS] * in[(((i + ii) - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i, j, ii, jj)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = jstart; j <= jend; j++)\n  for (i = istart; i <= iend; i++)\n  in[((i - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))] += 1.0;\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = (jstart > RADIUS) ? (jstart) : (RADIUS); j <= ((((n - RADIUS) - 1) < jend) ? ((n - RADIUS) - 1) : (jend)); j++)\n{\n  for (i = (istart > RADIUS) ? (istart) : (RADIUS); i <= ((((n - RADIUS) - 1) < iend) ? ((n - RADIUS) - 1) : (iend)); i++)\n  {\n    local_norm += (float) ((out[(i - istart) + ((j - jstart) * width)] >= 0) ? (out[(i - istart) + ((j - jstart) * width)]) : (-out[(i - istart) + ((j - jstart) * width)]));\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:local_norm) private (i)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int j = begin; j < end; ++j)\n{\n  if ((i0 < middle) && ((i1 >= end) || (src[i0] <= src[i1])))\n  {\n    dest[j] = src[i0++];\n  }\n  else\n  {\n    dest[j] = src[i1++];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:local_norm) private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jj = -RADIUS; jj <= RADIUS; jj++)\n  for (ii = -RADIUS; ii <= RADIUS; ii++)\n  weight[ii + RADIUS][jj + RADIUS] = (float) 0.0;\n\n\n", "pragma": "omp parallel for reduction(+:local_norm) private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (ii = 1; ii <= RADIUS; ii++)\n{\n  weight[0 + RADIUS][ii + RADIUS] = (weight[ii + RADIUS][0 + RADIUS] = (float) (1.0 / ((2.0 * ii) * RADIUS)));\n  weight[0 + RADIUS][(-ii) + RADIUS] = (weight[(-ii) + RADIUS][0 + RADIUS] = -((float) (1.0 / ((2.0 * ii) * RADIUS))));\n}\n\n", "pragma": "omp parallel for reduction(+:local_norm) private (i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < Block_order; j += Tile_order)\n  for (i = 0; i < order; i += Tile_order)\n  for (jt = j; jt < ((Block_order < (j + Tile_order)) ? (Block_order) : (j + Tile_order)); jt++)\n  for (it = i; it < ((order < (i + Tile_order)) ? (order) : (i + Tile_order)); it++)\n{\n  A_p[(it + istart) + (order * jt)] = (double) ((order * (jt + colstart)) + it);\n  B_p[(it + istart) + (order * jt)] = 0.0;\n}\n\n\n\n\n", "pragma": "omp parallel for private (i,it,jt)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < Block_order; j++)\n  for (i = 0; i < order; i++)\n{\n  A_p[(i + istart) + (order * j)] = (double) ((order * (j + colstart)) + i);\n  B_p[(i + istart) + (order * j)] = 0.0;\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Block_order; i++)\n  for (j = 0; j < Block_order; j++)\n{\n  B_p[(j + istart) + (order * i)] += A_p[(i + istart) + (order * j)];\n  A_p[(i + istart) + (order * j)] += 1.0;\n}\n\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Block_order; i += Tile_order)\n  for (j = 0; j < Block_order; j += Tile_order)\n  for (it = i; it < ((Block_order < (i + Tile_order)) ? (Block_order) : (i + Tile_order)); it++)\n  for (jt = j; jt < ((Block_order < (j + Tile_order)) ? (Block_order) : (j + Tile_order)); jt++)\n{\n  B_p[(jt + istart) + (order * it)] += A_p[(it + istart) + (order * jt)];\n  A_p[(it + istart) + (order * jt)] += 1.0;\n}\n\n\n\n\n", "pragma": "omp parallel for private (j,it,jt)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Block_order; i++)\n  for (j = 0; j < Block_order; j++)\n{\n  Work_out_p[j + (Block_order * i)] = A_p[(i + istart) + (order * j)];\n  A_p[(i + istart) + (order * j)] += 1.0;\n}\n\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Block_order; i += Tile_order)\n  for (j = 0; j < Block_order; j += Tile_order)\n  for (it = i; it < ((Block_order < (i + Tile_order)) ? (Block_order) : (i + Tile_order)); it++)\n  for (jt = j; jt < ((Block_order < (j + Tile_order)) ? (Block_order) : (j + Tile_order)); jt++)\n{\n  Work_out_p[jt + (Block_order * it)] = A_p[(it + istart) + (order * jt)];\n  A_p[(it + istart) + (order * jt)] += 1.0;\n}\n\n\n\n\n", "pragma": "omp parallel for private (j,it,jt)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < Block_order; j++)\n  for (i = 0; i < Block_order; i++)\n  B_p[(i + istart) + (order * j)] += Work_in_p[i + (Block_order * j)];\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < Block_order; j++)\n  for (i = 0; i < order; i++)\n{\n  abserr += ((B_p[(i + istart) + (order * j)] - ((double) (((((order * i) + j) + colstart) * (iterations + 1)) + addit))) >= 0) ? (B_p[(i + istart) + (order * j)] - ((double) (((((order * i) + j) + colstart) * (iterations + 1)) + addit))) : (-(B_p[(i + istart) + (order * j)] - ((double) (((((order * i) + j) + colstart) * (iterations + 1)) + addit))));\n}\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < order; j++)\n  for (i = 0; i < order; i++)\n{\n  A[i + (order * j)] = (B[i + (order * j)] = (double) j);\n  C[i + (order * j)] = 0.0;\n}\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter <= iterations; iter++)\n{\n  if (iter == 1)\n  {\n    {\n      dgemm_time = wtime();\n    }\n  }\n\n  if (block > 0)\n  {\n    for (jj = 0; jj < order; jj += block)\n    {\n      for (kk = 0; kk < order; kk += block)\n      {\n        for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n          BB[j + ((block + BOFFSET) * k)] = B[kg + (order * jg)];\n\n\n        for (ii = 0; ii < order; ii += block)\n        {\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            AA[i + ((block + BOFFSET) * k)] = A[ig + (order * kg)];\n\n\n          for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            CC[i + ((block + BOFFSET) * j)] = 0.0;\n\n\n          for (kg = kk, k = 0; kg < (((kk + block) < order) ? (kk + block) : (order)); k++, kg++)\n            for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            CC[i + ((block + BOFFSET) * j)] += AA[i + ((block + BOFFSET) * k)] * BB[j + ((block + BOFFSET) * k)];\n\n\n\n          for (jg = jj, j = 0; jg < (((jj + block) < order) ? (jj + block) : (order)); j++, jg++)\n            for (ig = ii, i = 0; ig < (((ii + block) < order) ? (ii + block) : (order)); i++, ig++)\n            C[ig + (order * jg)] += CC[i + ((block + BOFFSET) * j)];\n\n\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    for (jg = 0; jg < order; jg++)\n      for (kg = 0; kg < order; kg++)\n      for (ig = 0; ig < order; ig++)\n      C[ig + (order * jg)] += A[ig + (order * kg)] * B[kg + (order * jg)];\n\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (checksum = 0.0, j = 0; j < order; j++)\n  for (i = 0; i < order; i++)\n  checksum += C[i + (order * j)];\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  p = particles;\n  fx = 0.0;\n  fy = 0.0;\n  computeTotalForce(p[i], L, Qgrid, &fx, &fy);\n  ax = fx * 1.0;\n  ay = fy * 1.0;\n  p[i].x = fmod(((p[i].x + (p[i].v_x * 1.0)) + (((0.5 * ax) * 1.0) * 1.0)) + L, L);\n  p[i].y = fmod(((p[i].y + (p[i].v_y * 1.0)) + (((0.5 * ay) * 1.0) * 1.0)) + L, L);\n  p[i].v_x += ax * 1.0;\n  p[i].v_y += ay * 1.0;\n}\n\nvoid computeTotalForce(particle_t p, uint64_t L, double *Qgrid, double *fx, double *fy)\n{\n  uint64_t y;\n  uint64_t x;\n  double tmp_fx;\n  double tmp_fy;\n  double rel_y;\n  double rel_x;\n  double tmp_res_x = 0.0;\n  double tmp_res_y = 0.0;\n  y = (uint64_t) floor(p.y);\n  x = (uint64_t) floor(p.x);\n  rel_x = p.x - x;\n  rel_y = p.y - y;\n  computeCoulomb(rel_x, rel_y, p.q, Qgrid[(x * (L + 1)) + y], &tmp_fx, &tmp_fy);\n  tmp_res_x += tmp_fx;\n  tmp_res_y += tmp_fy;\n  computeCoulomb(rel_x, 1.0 - rel_y, p.q, Qgrid[((x * (L + 1)) + y) + 1], &tmp_fx, &tmp_fy);\n  tmp_res_x += tmp_fx;\n  tmp_res_y -= tmp_fy;\n  computeCoulomb(1.0 - rel_x, rel_y, p.q, Qgrid[((x + 1) * (L + 1)) + y], &tmp_fx, &tmp_fy);\n  tmp_res_x -= tmp_fx;\n  tmp_res_y += tmp_fy;\n  computeCoulomb(1.0 - rel_x, 1.0 - rel_y, p.q, Qgrid[(((x + 1) * (L + 1)) + y) + 1], &tmp_fx, &tmp_fy);\n  tmp_res_x -= tmp_fx;\n  tmp_res_y -= tmp_fy;\n  *fx = tmp_res_x;\n  *fy = tmp_res_y;\n}\n\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (x = 0; x <= L; x++)\n{\n  for (y = 0; y <= L; y++)\n  {\n    Qgrid[(x * (L + 1)) + y] = ((x % 2) == 0) ? (1.0) : (-1.0);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pi = 0; pi < n; pi++)\n{\n  x_coord = p[pi].x;\n  y_coord = p[pi].y;\n  rel_x = fmod(x_coord, 1.0);\n  rel_y = fmod(y_coord, 1.0);\n  x = (uint64_t) x_coord;\n  r1_sq = (rel_y * rel_y) + (rel_x * rel_x);\n  r2_sq = (rel_y * rel_y) + ((1.0 - rel_x) * (1.0 - rel_x));\n  cos_theta = rel_x / sqrt(r1_sq);\n  cos_phi = (1.0 - rel_x) / sqrt(r2_sq);\n  base_charge = 1.0 / (((1.0 * 1.0) * 1.0) * ((cos_theta / r1_sq) + (cos_phi / r2_sq)));\n  p[pi].v_x = 0.0;\n  p[pi].v_y = ((double) p[pi].m) / 1.0;\n  p[pi].q = ((x % 2) == 0) ? (((2 * p[pi].k) + 1) * base_charge) : (((-1.0) * ((2 * p[pi].k) + 1)) * base_charge);\n  p[pi].x0 = x_coord;\n  p[pi].y0 = y_coord;\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw(A * pow(rho, x), parm);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pi = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw(A * pow(rho, x), parm);\n    for (p = 0; p < actual_particles; p++, pi++)\n    {\n      particles[pi].x = x + 0.5;\n      particles[pi].y = y + 0.5;\n      particles[pi].k = k;\n      particles[pi].m = m;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw((((2.0 * cos(x * step)) * cos(x * step)) * n_input) / (L * L), parm);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pi = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw((((2.0 * cos(x * step)) * cos(x * step)) * n_input) / (L * L), parm);\n    for (p = 0; p < actual_particles; p++, pi++)\n    {\n      particles[pi].x = x + 0.5;\n      particles[pi].y = y + 0.5;\n      particles[pi].k = k;\n      particles[pi].m = m;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  current_weight = beta - ((alpha * step) * ((double) x));\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw((n_input * (current_weight / total_weight)) / L, parm);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pi = 0, x = 0; x < L; x++)\n{\n  current_weight = beta - ((alpha * step) * ((double) x));\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw((n_input * (current_weight / total_weight)) / L, parm);\n    for (p = 0; p < actual_particles; p++, pi++)\n    {\n      particles[pi].x = x + 0.5;\n      particles[pi].y = y + 0.5;\n      particles[pi].k = k;\n      particles[pi].m = m;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw(particles_per_cell, parm);\n    if ((((x < patch.left) || (x > patch.right)) || (y < patch.bottom)) || (y > patch.top))\n      actual_particles = 0;\n\n    *n_placed += actual_particles;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (pi = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw(particles_per_cell, parm);\n    if ((((x < patch.left) || (x > patch.right)) || (y < patch.bottom)) || (y > patch.top))\n      actual_particles = 0;\n\n    for (p = 0; p < actual_particles; p++, pi++)\n    {\n      particles[pi].x = x + 0.5;\n      particles[pi].y = y + 0.5;\n      particles[pi].k = k;\n      particles[pi].m = m;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, p, fx, fy, ax, ay)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int I = 0; I < 2; ++I)\n{\n  MaxThreadsL2 = omp_get_max_threads();\n}\n\n", "pragma": "omp target parallel for reduction(unique : MaxThreadsL2)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int I = 0; I < 2; ++I)\n{\n  ThreadLimitL1 = omp_get_thread_limit();\n  {\n    ThreadLimitL2 = omp_get_thread_limit();\n  }\n}\n\n", "pragma": "omp target parallel for reduction(unique32 : ThreadLimitL1, ThreadLimitL2) num_threads(32)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int j = 0; j < N; j++)\n{\n  num_threads[j] = omp_get_num_threads();\n  num_teams[j] = omp_get_num_teams();\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < N; j++)\n{\n  num_threads[j] = omp_get_num_threads();\n  num_teams[j] = omp_get_num_teams();\n}\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  d_A[i] = (d_B[i] + d_C[i]) + 1;\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1024; i++)\n  A[i] = (B[i] + C[i]) + 1;\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1024; ++i)\n{\n  A[i] = 0;\n  B[i] = 1;\n  C[i] = i;\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1024; ++i)\n{\n  if (A[i] != (i + 2))\n    fail++;\n\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1024; ++i)\n{\n  if (A[i] != (i + 2))\n    fail++;\n\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < i16; i++)\n{\n  r += (((((((((((((((i + i1) + i2) + i3) + i4) + i5) + i6) + i7) + i8) + i9) + i10) + i11) + i12) + i13) + i14) + i15) + i16;\n}\n\n", "pragma": "omp parallel for firstprivate(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16) reduction(+:r)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:diff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:dsum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:ddiff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(*:product)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_reduction())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_reduction()\n{\n  int sum;\n  int known_sum;\n  double dsum;\n  double dknown_sum;\n  double dt = 0.5;\n  double rounding_error = 1.E-9;\n  int diff;\n  double ddiff;\n  int product;\n  int known_product;\n  int logic_and;\n  int logic_or;\n  int bit_and;\n  int bit_or;\n  int exclusiv_bit_or;\n  int logics[1000];\n  int i;\n  double dpt;\n  int result;\n  sum = 0;\n  dsum = 0;\n  product = 1;\n  logic_and = 1;\n  logic_or = 0;\n  bit_and = 1;\n  bit_or = 0;\n  exclusiv_bit_or = 0;\n  result = 0;\n  dt = 1. / 3.;\n  known_sum = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n  }\n\n  if (known_sum != sum)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with integers: Result was %d instead of %d\\n\", sum, known_sum);\n  }\n\n  diff = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; ++i)\n  {\n    diff = diff - i;\n  }\n\n  if (diff != 0)\n  {\n    result++;\n    fprintf(stderr, \"Error in difference with integers: Result was %d instead of 0.\\n\", diff);\n  }\n\n  dsum = 0;\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  dknown_sum = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    dsum += pow(dt, i);\n  }\n\n  if (fabs(dsum - dknown_sum) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\", dsum, dknown_sum, dsum - dknown_sum);\n  }\n\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  fprintf(stderr, \"\\n\");\n  ddiff = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    ddiff -= pow(dt, i);\n  }\n\n  if (fabs(ddiff) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in Difference with doubles: Result was %E instead of 0.0\\n\", ddiff);\n  }\n\n  for (i = 1; i <= 10; i++)\n  {\n    product *= i;\n  }\n\n  known_product = 3628800;\n  if (known_product != product)\n  {\n    result++;\n    fprintf(stderr, \"Error in Product with integers: Result was %d instead of %d\\n\\n\", product, known_product);\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (!logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 1.\\n\");\n  }\n\n  logic_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 1.\\n\");\n  }\n\n  logic_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (!logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (!bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 1.\\n\");\n  }\n\n  bit_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 1\\n\");\n  }\n\n  bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (!bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 2\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 1\\n\");\n  }\n\n  exclusiv_bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (!exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 2\\n\");\n  }\n\n  return result == 0;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; i++)\n  (void) 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1024; ++i)\n  (void) 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + (i + i2);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(i) firstprivate(i2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_firstprivate())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_firstprivate()\n{\n  int sum;\n  int i2;\n  int i;\n  int known_sum;\n  sum = 0;\n  i2 = 3;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + (i + i2);\n  }\n\n  known_sum = ((1000 * (1000 + 1)) / 2) + (i2 * 1000);\n  return known_sum == sum;\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) private(i) firstprivate(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= 1000; i++)\n{\n  num_threads = omp_get_num_threads();\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for private(i) if (control==1)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_if())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_if()\n{\n  int known_sum;\n  int num_threads;\n  int sum;\n  int sum2;\n  int i;\n  int control;\n  control = 0;\n  num_threads = 0;\n  sum = 0;\n  sum2 = 0;\n  for (i = 0; i <= 1000; i++)\n  {\n    num_threads = omp_get_num_threads();\n    sum = sum + i;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  fprintf(stderr, \"Number of threads determined by omp_get_num_threads: %d\\n\", num_threads);\n  return (known_sum == sum) && (num_threads == 1);\n}\n\n\n", "pragma": "omp parallel for private(i) if (control==1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n  i0 = i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) private(i) lastprivate(i0)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_lastprivate())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_lastprivate()\n{\n  int sum;\n  int i;\n  int i0;\n  int known_sum;\n  sum = 0;\n  i0 = -1;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n    i0 = i;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  return (known_sum == sum) && (i0 == 1000);\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) private(i) lastprivate(i0)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < 100; i++)\n{\n  ii = i;\n  {\n    is_larger = check_i_islarger2(ii) && is_larger;\n    sum = sum + ii;\n  }\n}\n\nstatic int check_i_islarger2(int i)\n{\n  int islarger;\n  islarger = i > last_i;\n  last_i = i;\n  return islarger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1) private(i) ordered", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_ordered())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_ordered()\n{\n  int sum;\n  int is_larger;\n  int known_sum;\n  int i;\n  sum = 0;\n  is_larger = 1;\n  last_i = 0;\n  for (i = 1; i < 100; i++)\n  {\n    ii = i;\n    {\n      is_larger = check_i_islarger2(ii) && is_larger;\n      sum = sum + ii;\n    }\n  }\n\n  known_sum = (99 * 100) / 2;\n  fprintf(stderr, \" known_sum = %d , sum = %d \\n\", known_sum, sum);\n  fprintf(stderr, \" is_larger = %d\\n\", is_larger);\n  return (known_sum == sum) && is_larger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1) private(i) ordered", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  i2 = i;\n  do_some_work();\n  sum = sum + i2;\n}\n\nstatic void do_some_work(void)\n{\n  int i;\n  double sum = 0;\n  for (i = 0; i < 1000; i++)\n  {\n    sum += sqrt(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  sum += sqrt(i);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_private())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_private()\n{\n  int sum;\n  int i;\n  int i2;\n  int known_sum;\n  sum = 0;\n  i2 = 0;\n  for (i = 1; i <= 1000; i++)\n  {\n    i2 = i;\n    do_some_work();\n    sum = sum + i2;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  return known_sum == sum;\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:diff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:dsum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:ddiff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(*:product)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (h = pos0; h < pos1; h++)\n  for (j = 0; j < n; j++)\n  nodes[inode].conP[(h * n) + j] *= PMat[(j * n) + com.z[ison][h]];\n\n\n", "pragma": "omp parallel for default(none) shared(inode, ison, pos0, pos1, nodes, PMat, com, n) private(h, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_reduction())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_reduction()\n{\n  int sum;\n  int known_sum;\n  double dsum;\n  double dknown_sum;\n  double dt = 0.5;\n  double rounding_error = 1.E-9;\n  int diff;\n  double ddiff;\n  int product;\n  int known_product;\n  int logic_and;\n  int logic_or;\n  int bit_and;\n  int bit_or;\n  int exclusiv_bit_or;\n  int logics[1000];\n  int i;\n  double dpt;\n  int result;\n  sum = 0;\n  dsum = 0;\n  dt = 1. / 3.;\n  result = 0;\n  product = 1;\n  logic_and = 1;\n  logic_or = 0;\n  bit_and = 1;\n  bit_or = 0;\n  exclusiv_bit_or = 0;\n  known_sum = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n  }\n\n  if (known_sum != sum)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with integers: Result was %d instead of %d\\n\", sum, known_sum);\n  }\n\n  diff = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; ++i)\n  {\n    diff = diff - i;\n  }\n\n  if (diff != 0)\n  {\n    result++;\n    fprintf(stderr, \"Error in difference with integers: Result was %d instead of 0.\\n\", diff);\n  }\n\n  dsum = 0;\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  dknown_sum = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    dsum += pow(dt, i);\n  }\n\n  if (fabs(dsum - dknown_sum) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\", dsum, dknown_sum, dsum - dknown_sum);\n  }\n\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  fprintf(stderr, \"\\n\");\n  ddiff = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    ddiff -= pow(dt, i);\n  }\n\n  if (fabs(ddiff) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in Difference with doubles: Result was %E instead of 0.0\\n\", ddiff);\n  }\n\n  for (i = 1; i <= 10; i++)\n  {\n    product *= i;\n  }\n\n  known_product = 3628800;\n  if (known_product != product)\n  {\n    result++;\n    fprintf(stderr, \"Error in Product with integers: Result was %d instead of %d\\n\\n\", product, known_product);\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (!logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 1.\\n\");\n  }\n\n  logic_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 1.\\n\");\n  }\n\n  logic_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (!logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (!bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 1.\\n\");\n  }\n\n  bit_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 1\\n\");\n  }\n\n  bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (!bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 2\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 1\\n\");\n  }\n\n  exclusiv_bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (!exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 2\\n\");\n  }\n\n  return result == 0;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (h = pos0; h < pos1; h++)\n  for (j = 0; j < n; j++)\n{\n  for (k = 0, t = 0; k < nChara[com.z[ison][h]]; k++)\n    t += PMat[(j * n) + CharaMap[com.z[ison][h]][k]];\n\n  nodes[inode].conP[(h * n) + j] *= t;\n}\n\n\n", "pragma": "omp parallel for default(none) shared(nodes, inode, ison, pos0, pos1, PMat, com, n, t, nChara, CharaMap) private(h, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (h = pos0; h < pos1; h++)\n  for (j = 0; j < n; j++)\n{\n  for (k = 0, t = 0; k < n; k++)\n    t += PMat[(j * n) + k] * nodes[ison].conP[(h * n) + k];\n\n  nodes[inode].conP[(h * n) + j] *= t;\n}\n\n\n", "pragma": "omp parallel for default(none) shared(nodes, inode, pos0, pos1, ison, PMat, com, n, t) private(h, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  for (k = 1, pij = Cijk[(((i * n) * nr) + (j * nr)) + 0]; k < nr; k++)\n    pij += Cijk[(((i * n) * nr) + (j * nr)) + k] * expt[k];\n\n  P[(i * n) + j] = (pij > 0) ? (pij) : (0);\n}\n\n\n", "pragma": "omp parallel for default(none) shared(Cijk, pij, P, expt, n, nr) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n{\n  res += x[i] * y[i];\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, DDOT_OMP_CHUNK_SIZE) reduction(+:res)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int64_t r = 0; r < m_local; ++r)\n{\n  mat->values[r] = calloc(n_local, sizeof(double));\n  if (!mat->values[r])\n    return FAILURE;\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, DDOT_OMP_CHUNK_SIZE) reduction(+:res)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int64_t r = 0; r < mat->m; ++r)\n{\n  if (mat->values[r])\n    free(mat->values[r]);\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, DDOT_OMP_CHUNK_SIZE) reduction(+:res)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 1; i < argc; ++i)\n{\n  for (int pi = 0; pi < n_params; ++pi)\n  {\n    if (starts_with(argv[i], params[pi]))\n    {\n      if ((sscanf(argv[i] + strlen(params[pi]), \"%d\", iparams + pi) != 1) || (iparams[pi] < 1))\n      {\n        iparams[pi] = defaultv;\n      }\n\n    }\n\n  }\n\n}\n\nstatic bool starts_with(char *s, char *prefix)\n{\n  size_t n = strlen(prefix);\n  if (strncmp(s, prefix, n))\n    return 0;\n\n  return 1;\n}\n\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, DDOT_OMP_CHUNK_SIZE) reduction(+:res)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int64_t r = 0; r < nrow; ++r)\n{\n  y[r] = comp_ddot(A[r], x, ncol);\n}\n\nstatic double comp_ddot(const double * restrict x, const double * restrict y, int64_t n)\n{\n  double res = 0.0;\n  int64_t i = 0;\n  for (i = 0; i < n; ++i)\n  {\n    res += x[i] * y[i];\n  }\n\n  return res;\n}\n\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, DDOT_OMP_CHUNK_SIZE) reduction(+:res)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iy = 0; iy <= (5000 - 1); iy++)\n{\n  for (ix = 0; ix <= (5000 - 1); ix++)\n  {\n    cy = ymin + ((iy * (ymax - ymin)) / ((double) (5000 - 1)));\n    iter = 0;\n    i = 0;\n    x = 0.0;\n    y = 0.0;\n    x2 = 0.0;\n    y2 = 0.0;\n    temp = 0.0;\n    xder = 0.0;\n    yder = 0.0;\n    dist = 0.0;\n    cx = xmin + ((ix * (xmax - xmin)) / ((double) (5000 - 1)));\n    for (iter = 0; iter <= maxiter; iter++)\n    {\n      temp = (x2 - y2) + cx;\n      y = ((2.0 * x) * y) + cy;\n      x = temp;\n      x2 = x * x;\n      y2 = y * y;\n      xorbit[iter + 1] = x;\n      yorbit[iter + 1] = y;\n      if ((x2 + y2) > huge)\n        break;\n\n    }\n\n    if ((x2 + y2) >= huge)\n    {\n      xder = 0;\n      yder = 0;\n      i = 0;\n      flag = 0;\n      for (i = 0; (i <= iter) && (flag == 0); i++)\n      {\n        temp = (2.0 * ((xorbit[i] * xder) - (yorbit[i] * yder))) + 1;\n        yder = 2.0 * ((yorbit[i] * xder) + (xorbit[i] * yder));\n        xder = temp;\n        flag = fmax(fabs(xder), fabs(yder)) > overflow;\n      }\n\n      if (flag == 0)\n      {\n        dist = (log(x2 + y2) * sqrt(x2 + y2)) / sqrt((xder * xder) + (yder * yder));\n      }\n\n    }\n\n    if (dist < delta)\n      MSet[(iy * 5000) + ix] = 1;\n    else\n      MSet[(iy * 5000) + ix] = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(cy,ix,iter,i,x,y,x2,y2,temp,xder,yder,dist,cx,xorbit,yorbit) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10000000; i++)\n  z[i] = x[i] + y[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n  array[i] = rand() % 10000;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10000000; i++)\n  z_oracle[i] = x[i] + y[i];\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10000000; i++)\n  if (z_oracle[i] != z_v_add[i])\n  return 0;\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 1; i <= num_threads; i++)\n{\n  omp_set_num_threads(i);\n  start_time = omp_get_wtime();\n  for (int j = 0; j < 100; j++)\n    v_add(x, y, z);\n\n  run_time = omp_get_wtime() - start_time;\n  printf(\" %d thread(s) took %f seconds\\n\", i, run_time);\n}\n\nvoid v_add(double *x, double *y, double *z)\n{\n  for (int i = 0; i < 10000000; i++)\n    z[i] = x[i] + y[i];\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jz = 1; jz < ((50 + (2 * 1)) - 1); jz++)\n{\n  #pragma acc loop independent vector(8)\n  for (jy = 1; jy < ((64 + (2 * 1)) - 1); jy++)\n  {\n    #pragma acc loop independent vector(32)\n    for (jx = 1; jx < ((64 + (2 * 1)) - 1); jx++)\n    {\n      fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + jx] = ((((((cc * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + jx]) + (ce * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + (jx + 1)])) + (cw * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + (jx - 1)])) + (cn * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * (jy + 1))) + jx])) + (cs * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * (jy - 1))) + jx])) + (ct * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * (jz + 1)) + ((64 + (2 * 1)) * jy)) + jx])) + (cb * f[((((64 + (2 * 1)) * (64 + (2 * 1))) * (jz - 1)) + ((64 + (2 * 1)) * jy)) + jx]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jz = 1; jz < ((50 + (2 * 1)) - 1); jz++)\n{\n  #pragma acc loop independent\n  for (jy = 1; jy < ((64 + (2 * 1)) - 1); jy++)\n  {\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + 0] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + 1];\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + ((64 + (2 * 1)) - 1)] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * jy)) + ((64 + (2 * 1)) - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jz = 1; jz < ((50 + (2 * 1)) - 1); jz++)\n{\n  #pragma acc loop independent\n  for (jx = 1; jx < ((64 + (2 * 1)) - 1); jx++)\n  {\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * 0)) + jx] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * 1)) + jx];\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * ((64 + (2 * 1)) - 1))) + jx] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * jz) + ((64 + (2 * 1)) * ((64 + (2 * 1)) - 2))) + jx];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jy = 1; jy < ((64 + (2 * 1)) - 1); jy++)\n{\n  #pragma acc loop independent\n  for (jx = 1; jx < ((64 + (2 * 1)) - 1); jx++)\n  {\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * 0) + ((64 + (2 * 1)) * jy)) + jx] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * 1) + ((64 + (2 * 1)) * jy)) + jx];\n    fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * ((50 + (2 * 1)) - 1)) + ((64 + (2 * 1)) * jy)) + jx] = fn[((((64 + (2 * 1)) * (64 + (2 * 1))) * ((50 + (2 * 1)) - 2)) + ((64 + (2 * 1)) * jy)) + jx];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n  c[j] = a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n  b[j] = scalar * c[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n  c[j] = a[j] + b[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 40000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < xDim; i++)\n{\n  for (j = 1; j < xDim; j++)\n  {\n    matrix1[i][j] = (((matrix[i - 1][j] + matrix[i + 1][j]) + matrix[i][j - 1]) + matrix[i][j + 1]) / 4.0;\n    tempDiff = matrix1[i][j] - matrix[i][j];\n    totalDiff = totalDiff + (tempDiff * tempDiff);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:totalDiff) private(j,tempDiff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i < xDim; i++)\n{\n  memcpy(matrix[i], matrix1[i], (sizeof(double)) * xDim);\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= xDim; i++)\n{\n  matrix[i] = (double *) malloc((sizeof(double)) * (xDim + 1));\n  matrix1[i] = (double *) malloc((sizeof(double)) * (xDim + 1));\n  for (j = 0; j <= xDim; j++)\n  {\n    if (y == 0.0)\n    {\n      matrix[i][j] = sin(x * 3.14159265);\n      matrix1[i][j] = sin(x * 3.14159265);\n    }\n    else\n      if (y >= 1.0)\n    {\n      matrix[i][j] = sin(x * 3.14159265) * exp;\n      matrix1[i][j] = sin(x * 3.14159265) * exp;\n    }\n    else\n      if ((x == 0.0) || (x >= 1.0))\n    {\n      matrix[i][j] = 0;\n      matrix[i][j] = 0;\n    }\n    else\n    {\n      matrix[i][j] = 0.0;\n      matrix1[i][j] = 0.0;\n    }\n\n\n\n    x = x + ((float) input);\n    if (x >= 1.0)\n      x = 1.0;\n\n  }\n\n  x = 0;\n  y = y + ((float) input);\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= xDim; i++)\n{\n  free(matrix[i]);\n  free(matrix1[i]);\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 250; j++)\n  {\n    for (k = 0; k < 250; k++)\n      C[(i * 250) + j] += A[(i * 250) + k] * B[(k * 250) + j];\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  array[i] = 0;\n\n", "pragma": "omp parallel for schedule(static, chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n  array[i] = rand() % 10000;\n\n", "pragma": "omp parallel for schedule(static, chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < row; i++)\n{\n  for (j = 0; j < column; j++)\n  {\n    printf(\"%d \", matrice[(i * row) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for schedule(static, chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    left_snd_buffer[index - 1] = field[((((x_max + 4) + x_inc) * (k - (y_min - 2))) + (((x_min + x_inc) - 1) + j)) - (x_min - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    field[((((x_max + 4) + x_inc) * (k - (y_min - 2))) + (x_min - j)) - (x_min - 2)] = left_rcv_buffer[index - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    right_snd_buffer[index - 1] = field[((((x_max + 4) + x_inc) * (k - (y_min - 2))) + ((x_max + 1) - j)) - (x_min - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    field[((((x_max + 4) + x_inc) * (k - (y_min - 2))) + ((x_max + x_inc) + j)) - (x_min - 2)] = right_rcv_buffer[index - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (buffer_offset + k) + (((j + depth) - 1) * depth);\n  top_snd_buffer[index - 1] = field[((((x_max + 4) + x_inc) * (((y_max + 1) - k) - (y_min - 2))) + j) - (x_min - 2)];\n}\n\n", "pragma": "omp parallel for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (buffer_offset + k) + (((j + depth) - 1) * depth);\n  bottom_snd_buffer[index - 1] = field[((((x_max + 4) + x_inc) * ((((y_min + y_inc) - 1) + k) - (y_min - 2))) + j) - (x_min - 2)];\n}\n\n", "pragma": "omp parallel for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (buffer_offset + k) + (((j + depth) - 1) * depth);\n  field[((((x_max + 4) + x_inc) * ((y_min - k) - (y_min - 2))) + j) - (x_min - 2)] = bottom_rcv_buffer[index - 1];\n}\n\n", "pragma": "omp parallel for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (buffer_offset + k) + (((j + depth) - 1) * depth);\n  field[((((x_max + 4) + x_inc) * (((y_max + y_inc) + k) - (y_min - 2))) + j) - (x_min - 2)] = top_rcv_buffer[index - 1];\n}\n\n", "pragma": "omp parallel for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < _chunk.y; ++jj)\n{\n  for (int kk = 0; kk < _chunk.x; ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    p[index] = 0.0;\n    r[index] = 0.0;\n    u[index] = energy[index] * density[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 1; jj < (_chunk.y - 1); ++jj)\n{\n  for (int kk = 1; kk < (_chunk.x - 1); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    w[index] = ((*coefficient) == 1) ? (density[index]) : (1.0 / density[index]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 1); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 1); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    kx[index] = ((*rx) * (w[index - 1] + w[index])) / ((2.0 * w[index - 1]) * w[index]);\n    ky[index] = ((*ry) * (w[index - _chunk.x] + w[index])) / ((2.0 * w[index - _chunk.x]) * w[index]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * u[index]) - ((kx[index + 1] * u[index + 1]) + (kx[index] * u[index - 1]))) - ((ky[index + _chunk.x] * u[index + _chunk.x]) + (ky[index] * u[index - _chunk.x]));\n    ;\n    w[index] = smvp;\n    r[index] = u[index] - w[index];\n    p[index] = r[index];\n    rroTemp += r[index] * p[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:rroTemp)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * p[index]) - ((kx[index + 1] * p[index + 1]) + (kx[index] * p[index - 1]))) - ((ky[index + _chunk.x] * p[index + _chunk.x]) + (ky[index] * p[index - _chunk.x]));\n    ;\n    w[index] = smvp;\n    pwTemp += w[index] * p[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:pwTemp)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    u[index] += (*alpha) * p[index];\n    r[index] -= (*alpha) * w[index];\n    rrnTemp += r[index] * r[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:rrnTemp)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    p[index] = ((*beta) * p[index]) + r[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    u[index] += p[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * u[index]) - ((kx[index + 1] * u[index + 1]) + (kx[index] * u[index - 1]))) - ((ky[index + _chunk.x] * u[index + _chunk.x]) + (ky[index] * u[index - _chunk.x]));\n    ;\n    w[index] = smvp;\n    r[index] = u0[index] - w[index];\n    p[index] = r[index] / (*theta);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * u[index]) - ((kx[index + 1] * u[index + 1]) + (kx[index] * u[index - 1]))) - ((ky[index + _chunk.x] * u[index + _chunk.x]) + (ky[index] * u[index - _chunk.x]));\n    ;\n    w[index] = smvp;\n    r[index] = u0[index] - w[index];\n    p[index] = (alpha * p[index]) + (beta * r[index]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    double cellVol = volume[index];\n    double cellMass = cellVol * density[index];\n    vol += cellVol;\n    mass += cellMass;\n    ie += cellMass * energy0[index];\n    temp += cellMass * u[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:vol,ie,temp,mass)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 1; jj < (_chunk.y - 1); ++jj)\n{\n  for (int kk = 1; kk < (_chunk.x - 1); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    double temp = energy[index] * density[index];\n    u0[index] = temp;\n    u[index] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 1); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 1); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    double densityCentre = ((*coefficient) == 1) ? (density[index]) : (1.0 / density[index]);\n    double densityLeft = ((*coefficient) == 1) ? (density[index - 1]) : (1.0 / density[index - 1]);\n    double densityDown = ((*coefficient) == 1) ? (density[index - _chunk.x]) : (1.0 / density[index - _chunk.x]);\n    kx[index] = ((*rx) * (densityLeft + densityCentre)) / ((2.0 * densityLeft) * densityCentre);\n    ky[index] = ((*ry) * (densityDown + densityCentre)) / ((2.0 * densityDown) * densityCentre);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < _chunk.y; ++jj)\n{\n  for (int kk = 0; kk < _chunk.x; ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    r[index] = u[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (long i = 0; i < l; i++)\n{\n  if ((i != 0) && ((i % 10) == 0))\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\"%d \", v[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    u[index] = ((u0[index] + ((kx[index + 1] * r[index + 1]) + (kx[index] * r[index - 1]))) + ((ky[index + _chunk.x] * r[index + _chunk.x]) + (ky[index] * r[index - _chunk.x]))) / ((1.0 + (kx[index] + kx[index + 1])) + (ky[index] + ky[index + _chunk.x]));\n    err += fabs(u[index] - r[index]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (yMax - 2); ++jj)\n{\n  for (int kk = 2; kk < (2 + depth); ++kk)\n  {\n    int bufIndex = (kk - 2) + ((jj - 2) * depth);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (yMax - 2); ++jj)\n{\n  for (int kk = (xMax - 2) - depth; kk < (xMax - 2); ++kk)\n  {\n    int bufIndex = (kk - ((xMax - 2) - depth)) + ((jj - 2) * depth);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = (yMax - 2) - depth; jj < (yMax - 2); ++jj)\n{\n  for (int kk = 2; kk < (xMax - 2); ++kk)\n  {\n    int bufIndex = (kk - 2) + ((jj - ((yMax - 2) - depth)) * _chunk.innerX);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (2 + depth); ++jj)\n{\n  for (int kk = 2; kk < (xMax - 2); ++kk)\n  {\n    int bufIndex = (kk - 2) + ((jj - 2) * _chunk.innerX);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (yMax - 2); ++jj)\n{\n  for (int kk = 2 - depth; kk < 2; ++kk)\n  {\n    int bufIndex = (kk - (2 - depth)) + ((jj - 2) * depth);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (yMax - 2); ++jj)\n{\n  for (int kk = xMax - 2; kk < ((xMax - 2) + depth); ++kk)\n  {\n    int bufIndex = (kk - (xMax - 2)) + ((jj - 2) * depth);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = yMax - 2; jj < ((yMax - 2) + depth); ++jj)\n{\n  for (int kk = 2; kk < (xMax - 2); ++kk)\n  {\n    int bufIndex = (kk - 2) + ((jj - (yMax - 2)) * _chunk.innerX);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2 - depth; jj < 2; ++jj)\n{\n  for (int kk = 2; kk < (xMax - 2); ++kk)\n  {\n    int bufIndex = (kk - 2) + ((jj - (2 - depth)) * _chunk.innerX);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii != 6; ++ii)\n{\n  exchanges += fields[ii];\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int ii = 0; ii < 6; ++ii)\n{\n  if (fields[ii])\n  {\n    double *deviceField = 0;\n    switch (ii + 1)\n    {\n      case 1:\n        deviceField = density;\n        break;\n\n      case 2:\n        deviceField = energy0;\n        break;\n\n      case 3:\n        deviceField = energy;\n        break;\n\n      case 4:\n        deviceField = u;\n        break;\n\n      case 5:\n        deviceField = p;\n        break;\n\n      case 6:\n        deviceField = sd;\n        break;\n\n      default:\n        panic(265, \"/home/reemh/CLPP/github-clone-all/repos_final/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel.c\", \"Incorrect field provided: %d.\\n\", ii + 1);\n\n    }\n\n    kernel(_chunk.x, _chunk.y, deviceField, buffer + offsets[ii], depth, offload);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    sd[index] = r[index] / (*theta);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * sd[index]) - ((kx[index + 1] * sd[index + 1]) + (kx[index] * sd[index - 1]))) - ((ky[index + _chunk.x] * sd[index + _chunk.x]) + (ky[index] * sd[index - _chunk.x]));\n    ;\n    r[index] -= smvp;\n    u[index] += sd[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    sd[index] = (alpha * sd[index]) + (beta * r[index]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < _chunk.y; ++jj)\n{\n  for (int kk = 0; kk < _chunk.x; ++kk)\n  {\n    double val = buffer[kk + (jj * _chunk.x)];\n    fprintf(fp, \"%d %d %.12E\\n\", kk, jj, val);\n    bSum += val;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:bSum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    u0[index] = u[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    const double smvp = ((((1.0 + (kx[index + 1] + kx[index])) + (ky[index + _chunk.x] + ky[index])) * u[index]) - ((kx[index + 1] * u[index + 1]) + (kx[index] * u[index - 1]))) - ((ky[index + _chunk.x] * u[index + _chunk.x]) + (ky[index] * u[index - _chunk.x]));\n    ;\n    r[index] = u0[index] - smvp;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    normTemp += buffer[index] * buffer[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:normTemp)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    energy[index] = u[index] / density[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 0; kk < depth; ++kk)\n  {\n    int base = jj * _chunk.x;\n    buffer[base + ((2 - kk) - 1)] = buffer[base + (2 + kk)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 2; jj < (_chunk.y - 2); ++jj)\n{\n  for (int kk = 0; kk < depth; ++kk)\n  {\n    int base = jj * _chunk.x;\n    buffer[base + ((_chunk.x - 2) + kk)] = buffer[base + (((_chunk.x - 2) - 1) - kk)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < depth; ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int base = kk;\n    buffer[base + (((_chunk.y - 2) + jj) * _chunk.x)] = buffer[base + ((((_chunk.y - 2) - 1) - jj) * _chunk.x)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int jj = 0; jj < depth; ++jj)\n{\n  for (int kk = 2; kk < (_chunk.x - 2); ++kk)\n  {\n    int base = kk;\n    buffer[base + (((2 - jj) - 1) * _chunk.x)] = buffer[base + ((2 + jj) * _chunk.x)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  int i0 = (i * N) + j;\n  int i1 = (i * N) + k;\n  int i2 = (k * N) + j;\n  if ((mat[i1] != (-1)) && (mat[i2] != (-1)))\n    mat[i0] = ((mat[i0] != (-1)) && (mat[i0] < (mat[i1] + mat[i2]))) ? (mat[i0]) : (mat[i1] + mat[i2]);\n\n}\n\n\n", "pragma": "omp parallel for private(j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < (N * N); i++)\n  mat[i] = (rand() % 32) - 1;\n\n", "pragma": "omp parallel for private(j) schedule(static)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < eleNum; i++)\n  if (l[i] != r[i])\n{\n  printf(\"ERROR: l[%d] = %d, r[%d] = %d\\n\", i, l[i], i, r[i]);\n  return 0;\n}\n\n\n", "pragma": "omp parallel for private(j) schedule(static)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int k = 0; k < N; k++)\n  for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n{\n  int i0 = (i * N) + j;\n  int i1 = (i * N) + k;\n  int i2 = (k * N) + j;\n  if ((mat[i1] != (-1)) && (mat[i2] != (-1)))\n    mat[i0] = ((mat[i0] != (-1)) && (mat[i0] < (mat[i1] + mat[i2]))) ? (mat[i0]) : (mat[i1] + mat[i2]);\n\n}\n\n\n\n", "pragma": "omp parallel for private(j) schedule(static)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (unsigned i = 1; i <= n_cells; i++)\n  for (unsigned j = 1; j <= n_cells; j++)\n  T_new[(i * n_cells) + j] = 0.25 * (((T[((i + 1) * n_cells) + j] + T[((i - 1) * n_cells) + j]) + T[(i * n_cells) + (j + 1)]) + T[(i * n_cells) + (j - 1)]);\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (unsigned int i = 1; i <= n_cells; i++)\n{\n  for (unsigned int j = 1; j <= n_cells; j++)\n  {\n    residual = (fabs(T_new[(i * n_cells) + j] - T[(i * n_cells) + j]) > residual) ? (fabs(T_new[(i * n_cells) + j] - T[(i * n_cells) + j])) : (residual);\n    T[(i * n_cells) + j] = T_new[(i * n_cells) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(max : residual) collapse(2)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (unsigned i = 1; i < n_cells; i++)\n{\n  for (unsigned j = 1; j < n_cells; ++j)\n  {\n    double error = fabs((T[(i * n_cells) + j] - T_results[(i * n_cells) + j]) / T_results[(i * n_cells) + j]);\n    max_error = (error > max_error) ? (error) : (max_error);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) reduction(max : max_error)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (unsigned i = 0; i <= (n_cells + 1); i++)\n{\n  for (unsigned j = 0; j <= (n_cells + 1); j++)\n  {\n    T[(i * n_cells) + j] = ((double) rand()) / ((double) 32767);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) reduction(max : max_error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (unsigned i = 1; i <= n_cells; i++)\n  for (unsigned j = 1; j <= n_cells; j++)\n  T_new[(i * n_cells) + j] = 0.25 * (((T[((i + 1) * n_cells) + j] + T[((i - 1) * n_cells) + j]) + T[(i * n_cells) + (j + 1)]) + T[(i * n_cells) + (j - 1)]);\n\n\n", "pragma": "omp parallel for collapse(2) reduction(max : max_error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (unsigned int i = 1; i <= n_cells; i++)\n{\n  for (unsigned int j = 1; j <= n_cells; j++)\n  {\n    residual = (fabs(T_new[(i * n_cells) + j] - T[(i * n_cells) + j]) > residual) ? (fabs(T_new[(i * n_cells) + j] - T[(i * n_cells) + j])) : (residual);\n    T[(i * n_cells) + j] = T_new[(i * n_cells) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) reduction(max : max_error)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; i++)\n{\n  int k;\n  if (is_black_gen)\n  {\n    k = ((i % 2) == 0) ? (1) : (0);\n  }\n  else\n  {\n    k = ((i % 2) == 0) ? (0) : (1);\n  }\n\n  for (j = k; j < world_size; j = j + 2)\n  {\n    exodus(i, j);\n  }\n\n}\n\nvoid exodus(int x, int y)\n{\n  position *actual = (position *) calloc(1, sizeof(position));\n  actual->x = x;\n  actual->y = y;\n  actual->cell = &world_indexer_read[x][y];\n  int type = actual->cell->type;\n  if (((1 == type) || (5 == type)) || (2 == type))\n  {\n    if ((actual->cell->starvation == 0) && (2 == type))\n    {\n      die(actual);\n      return;\n    }\n\n    if (actual->cell->breeding == 0)\n    {\n      actual->is_breeding = 1;\n    }\n\n    go(actual);\n  }\n\n  free(actual);\n}\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    int type = world_indexer[i][j].type;\n    if (type == 2)\n    {\n      if (world_indexer[i][j].starvation > 0)\n        world_indexer[i][j].starvation--;\n\n      if (world_indexer[i][j].breeding > 0)\n        world_indexer[i][j].breeding--;\n\n    }\n    else\n      if ((type == 1) || (type == 5))\n    {\n      if (world_indexer[i][j].breeding > 0)\n        world_indexer[i][j].breeding--;\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; ++i)\n{\n  world_indexer_read[i] = &world_array_read[i * world_size];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; ++i)\n{\n  world_indexer_read[i] = &world_array_read[i * world_size];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    switch (world_indexer[i][j].type)\n    {\n      case 1:\n        printf(\"%d %d %c\\n\", i, j, 's');\n        break;\n\n      case 2:\n        printf(\"%d %d %c\\n\", i, j, 'w');\n        break;\n\n      case 3:\n        printf(\"%d %d %c\\n\", i, j, 't');\n        break;\n\n      case 4:\n        printf(\"%d %d %c\\n\", i, j, 'i');\n        break;\n\n      case 5:\n        printf(\"%d %d %c\\n\", i, j, '$');\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = -1; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    if (i == (-1))\n    {\n      printf(\"|%d\", j % 10);\n    }\n    else\n    {\n      printf(\"%c\", '|');\n      switch (world_indexer[i][j].type)\n      {\n        case 1:\n          printf(\"%c\", 's');\n          break;\n\n        case 2:\n          printf(\"%c\", 'w');\n          break;\n\n        case 3:\n          printf(\"%c\", 't');\n          break;\n\n        case 4:\n          printf(\"%c\", 'i');\n          break;\n\n        case 5:\n          printf(\"%c\", '$');\n          break;\n\n        default:\n          printf(\"%c\", ' ');\n          break;\n\n      }\n\n    }\n\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = -1; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    if (i == (-1))\n    {\n      printf(\"|%d\", j % 10);\n    }\n    else\n    {\n      printf(\"%c\", '|');\n      switch (world_indexer_read[i][j].type)\n      {\n        case 1:\n          printf(\"%c\", 's');\n          break;\n\n        case 2:\n          printf(\"%c\", 'w');\n          break;\n\n        case 3:\n          printf(\"%c\", 't');\n          break;\n\n        case 4:\n          printf(\"%c\", 'i');\n          break;\n\n        case 5:\n          printf(\"%c\", '$');\n          break;\n\n        default:\n          printf(\"%c\", ' ');\n          break;\n\n      }\n\n    }\n\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < world_size; ++i)\n{\n  world_indexer[i] = &world_array[i * world_size];\n  world_indexer_read[i] = &world_array_read[i * world_size];\n  omp_init_lock(&lock[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 4; i++)\n{\n  counter += (free_positions[i]) ? (1) : (0);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (direction = 0; direction < 4; direction++)\n{\n  if (possible_positions[direction])\n  {\n    next--;\n  }\n\n  if (next == (-1))\n  {\n    return direction;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_generation; i++)\n{\n  sub_generation(0);\n  duplicate();\n  sub_generation(1);\n  update_generation();\n}\n\nvoid sub_generation(int is_black_gen)\n{\n  int i;\n  int j;\n  for (i = 0; i < world_size; i++)\n  {\n    int k;\n    if (is_black_gen)\n    {\n      k = ((i % 2) == 0) ? (1) : (0);\n    }\n    else\n    {\n      k = ((i % 2) == 0) ? (0) : (1);\n    }\n\n    for (j = k; j < world_size; j = j + 2)\n    {\n      exodus(i, j);\n    }\n\n  }\n\n}\n\n\nvoid duplicate()\n{\n  memcpy(world_array_read, world_array, (world_size * world_size) * (sizeof(cell)));\n  int i;\n  for (i = 0; i < world_size; ++i)\n  {\n    world_indexer_read[i] = &world_array_read[i * world_size];\n  }\n\n}\n\n\nvoid sub_generation(int is_black_gen)\n{\n  int i;\n  int j;\n  for (i = 0; i < world_size; i++)\n  {\n    int k;\n    if (is_black_gen)\n    {\n      k = ((i % 2) == 0) ? (1) : (0);\n    }\n    else\n    {\n      k = ((i % 2) == 0) ? (0) : (1);\n    }\n\n    for (j = k; j < world_size; j = j + 2)\n    {\n      exodus(i, j);\n    }\n\n  }\n\n}\n\n\nvoid update_generation()\n{\n  int i;\n  int j;\n  for (i = 0; i < world_size; i++)\n  {\n    for (j = 0; j < world_size; j++)\n    {\n      int type = world_indexer[i][j].type;\n      if (type == 2)\n      {\n        if (world_indexer[i][j].starvation > 0)\n          world_indexer[i][j].starvation--;\n\n        if (world_indexer[i][j].breeding > 0)\n          world_indexer[i][j].breeding--;\n\n      }\n      else\n        if ((type == 1) || (type == 5))\n      {\n        if (world_indexer[i][j].breeding > 0)\n          world_indexer[i][j].breeding--;\n\n      }\n\n\n    }\n\n  }\n\n  memcpy(world_array_read, world_array, (world_size * world_size) * (sizeof(cell)));\n  for (i = 0; i < world_size; ++i)\n  {\n    world_indexer_read[i] = &world_array_read[i * world_size];\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < vec_len; i++)\n{\n  dot_prod += x[i] * y[i];\n  result = dot_prod;\n}\n\n", "pragma": "omp parallel for reduction(+: dot_prod,result)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < vec_len; i++)\n{\n  x[i] = 1.;\n  y[i] = 1.;\n}\n\n", "pragma": "omp parallel for reduction(+: dot_prod,result)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50000000; j++)\n  c[j] = a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 50000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nx; ++i)\n{\n  for (j = 0; j < ny; ++j)\n  {\n    p[i + (j * nx)] += ((dt / f.u.dx) * (u[(i + 1) + (j * (nx + 1))] - u[i + (j * (nx + 1))])) + ((dt / f.v.dy) * (v[i + ((j + 1) * nx)] - v[i + (j * nx)]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < nx; ++i)\n{\n  for (j = 0; j < ny; ++j)\n  {\n    u[i + (j * (nx + 1))] += (dt / f.p.dx) * (p[i + (j * nx)] - p[(i - 1) + (j * nx)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nx; ++i)\n  for (j = 1; j < ny; ++j)\n  v[i + (j * nx)] += (dt / f.p.dy) * (p[i + (j * nx)] - p[i + ((j - 1) * nx)]);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i += 1)\n  for (j = 0; j < n; j += 1)\n{\n  min = 32000;\n  for (i1 = 0; i1 < n; i1 += 1)\n    for (j1 = 0; j1 < n; j1 += 1)\n  {\n    dist = Manhattan(i, j, i1, j1);\n    if ((year[y].P[i1][j1] + dist) < min)\n    {\n      if (type == 1)\n      {\n        if (year[y].Res[i1][j1] == (1 - year[y].Res[i][j]))\n        {\n          min = year[y].P[i1][j1] + dist;\n        }\n\n      }\n      else\n        if (type == 0)\n      {\n        if (year[y].Res[i1][j1] == year[y].Res[i][j])\n        {\n          min = year[y].P[i1][j1] + dist;\n        }\n\n      }\n\n\n    }\n\n  }\n\n\n  if (type == 1)\n  {\n    year[y].CostC[i][j] = min;\n  }\n  else\n    if (type == 0)\n  {\n    year[y].Cost[i][j] = min;\n  }\n\n\n}\n\n\nint Manhattan(int i, int j, int i1, int j1)\n{\n  return abs(i - i1) + abs(j - j1);\n}\n\n\n", "pragma": "omp parallel for private(i, j, i1, j1, min) shared(year) schedule(runtime)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (mm = 0; mm < g->sizeX; mm++)\n{\n  if (mm < 100)\n  {\n    g->ceze[mm] = 1.0;\n    g->cezh[mm] = imp0;\n  }\n  else\n  {\n    g->ceze[mm] = 1.0;\n    g->cezh[mm] = imp0 / 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mm = 0; mm < (g->sizeX - 1); mm++)\n{\n  g->chyh[mm] = 1.0;\n  g->chye[mm] = 1.0 / imp0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mm = 0; mm < g->sizeX; mm++)\n{\n  if (mm < 100)\n  {\n    g->ceze[mm] = 1.0;\n    g->cezh[mm] = imp0;\n  }\n  else\n    if (mm < 180)\n  {\n    g->ceze[mm] = 1.0;\n    g->cezh[mm] = imp0 / 4.0;\n  }\n  else\n  {\n    g->ceze[mm] = (1.0 - 0.0253146) / (1.0 + 0.0253146);\n    g->cezh[mm] = (imp0 / 4.0) / (1.0 + 0.0253146);\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mm = 0; mm < (g->sizeX - 1); mm++)\n{\n  if (mm < 180)\n  {\n    g->chyh[mm] = 1.0;\n    g->chye[mm] = 1.0 * imp0_inv;\n  }\n  else\n  {\n    g->chyh[mm] = (1.0 - 0.0253146) / (1.0 + 0.0253146);\n    g->chye[mm] = (1.0 * imp0_inv) / (1.0 + 0.0253146);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mm = 0; mm < (g->sizeX - 1); mm++)\n{\n  g->hy[mm] = (g->chyh[mm] * g->hy[mm]) + (g->chye[mm] * (g->ez[mm + 1] - g->ez[mm]));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (mm = 1; mm < g->sizeX; mm++)\n{\n  g->ez[mm] = (g->ceze[mm] * g->ez[mm]) + (g->cezh[mm] * (g->hy[mm] - g->hy[mm - 1]));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 2; i++)\n{\n  sleep(1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m; ++i)\n{\n  for (j = 0; j < n; ++j)\n    b[(i * n) + j] = i;\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m, n, b) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; ++i)\n  c[i] = 2.0;\n\n", "pragma": "omp parallel for default(none) shared(m, n, b) private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m; ++i)\n{\n  printf(\"%d, %d\\n\", i, omp_get_thread_num());\n  a[i] = 0;\n  for (j = 0; j < n; ++j)\n    a[i] += b[(i * n) + j] * c[j];\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m, n, b) private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 2; i <= sqN; ++i)\n{\n  if (A[i] != 1)\n    continue;\n\n  for (j = 2; (i * j) < N; ++j)\n  {\n    A[i * j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) shared(A, sqN, N) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; ++i)\n  A[i] = 1;\n\n", "pragma": "omp parallel for schedule(dynamic) shared(A, sqN, N) private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; ++i)\n  count += A[i];\n\n", "pragma": "omp parallel for schedule(dynamic) shared(A, sqN, N) private(i, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (f_set = F->data, i = 0; i < F->count; f_set += F->wsize, i++)\n{\n  for (r_set = R->data, j = 0; j < R->count; r_set += R->wsize, j++)\n  {\n    Pair_Count++;\n    if (output_is_intersective(f_set, r_set))\n    {\n      Intercount++;\n      QuickFly_Remove_ASP(SPM, f_set, r_set);\n      if (setp_empty(Set_SPM))\n      {\n        goto Over;\n      }\n\n      cnt_thr = 0;\n    }\n    else\n    {\n      cnt_thr++;\n    }\n\n  }\n\n}\n\nvoid QuickFly_Remove_ASP(pset_family F, pset a, pset b)\n{\n  register pset p;\n  register pset q;\n  register pset r;\n  register int m;\n  register int n;\n  register int k;\n  register int x;\n  register int second;\n  register unsigned v1;\n  register unsigned v2;\n  int first;\n  upFlag = 0;\n  p = set_clear((unsigned int *) malloc((sizeof(unsigned int)) * ((cube.size <= 32) ? (2) : ((((cube.size - 1) >> 5) + 1) + 1))), cube.size);\n  m = Xcnt_Set_Xor(p, a, b);\n  if (m > 2)\n  {\n    if (p)\n    {\n      (void) free((char *) p);\n      p = 0;\n    }\n\n    ;\n    return;\n  }\n\n  q = set_clear((unsigned int *) malloc((sizeof(unsigned int)) * ((cube.size <= 32) ? (2) : ((((cube.size - 1) >> 5) + 1) + 1))), cube.size);\n  n = Xcnt_Set_Or(q, a, b);\n  if (n == 1)\n  {\n    if (p)\n    {\n      (void) free((char *) p);\n      p = 0;\n    }\n\n    ;\n    if (q)\n    {\n      (void) free((char *) q);\n      q = 0;\n    }\n\n    ;\n    return;\n  }\n\n  if (m == 2)\n  {\n    first = -1;\n    second = Second_X(p, &first);\n    if (Set_SPM[(first >> 5) + 1] & (1 << (first & (32 - 1))))\n    {\n      if (second > 0)\n      {\n        Pcount++;\n        ++count3;\n        upFlag = 1;\n        v1 = var_get(a, first);\n        v2 = var_get(a, second);\n        if (v1 == v2)\n        {\n          Remove_ASP_in_SPM(F, first, second, 0x1);\n        }\n        else\n        {\n          Remove_ASP_in_SPM(F, first, second, 0x0);\n        }\n\n        Update_Set_SPM(F, first);\n        Update_Set_SPM(F, second);\n      }\n\n    }\n\n  }\n  else\n  {\n    x = First_X(p);\n    if (Set_SPM[(x >> 5) + 1] & (1 << (x & (32 - 1))))\n    {\n      Pcount++;\n      upFlag = 1;\n      QuickFly_Remove_ASP_Step(F, a, p, x);\n    }\n\n  }\n\n  if (p)\n  {\n    (void) free((char *) p);\n    p = 0;\n  }\n\n  ;\n  if (q)\n  {\n    (void) free((char *) q);\n    q = 0;\n  }\n\n  ;\n  return;\n}\n\n\n", "pragma": "omp parallel for nowait collapse(2) shared(SPM) private(f_set, r_set)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (; j < i; j++, ++p, ++a, xspm++)\n{\n  tmpspm = *xspm;\n  if (!tmpspm)\n  {\n    index += num;\n    continue;\n  }\n\n  tmpp = *p;\n  tmpa = *a;\n  V3 = 3;\n  V2 = 2;\n  V1 = 1;\n  for (k = 0; k < num; k++, ++index, V1 <<= 2, V2 <<= 2, V3 <<= 2)\n  {\n    if (vspm = tmpspm & 0x3)\n    {\n      vp = tmpp & 0x3;\n      va = tmpa & 0x3;\n      switch (vp)\n      {\n        case 0x0:\n          if (va == 0x3)\n        {\n          count2++;\n          *xspm &= ~V3;\n          var_remove(F->data + (F->wsize * index), x);\n          Update_Set_SPM(F, index);\n        }\n\n          break;\n\n        case 0x1:\n\n        case 0x2:\n          count1++;\n          cmp_val = (va < 3) ? (va) : (vp);\n          if (ax_val == cmp_val)\n        {\n          *xspm &= ~V2;\n          (F->data + (F->wsize * index))[((y + 1) >> 5) + 1] &= ~(1 << ((y + 1) & (32 - 1)));\n          Update_Set_SPM(F, index);\n        }\n        else\n        {\n          *xspm &= ~V1;\n          (F->data + (F->wsize * index))[(y >> 5) + 1] &= ~(1 << (y & (32 - 1)));\n          Update_Set_SPM(F, index);\n        }\n\n          break;\n\n        case 0x3:\n\n        default:\n          break;\n\n      }\n\n    }\n\n    tmpa >>= 2;\n    tmpp >>= 2;\n    tmpspm >>= 2;\n    if (!tmpspm)\n    {\n      break;\n    }\n\n  }\n\n  index += num - k;\n}\n\n", "pragma": "omp parallel for nowait collapse(2) shared(SPM) private(f_set, r_set)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (; index < NIN; ++index, V1 <<= 2, V2 <<= 2, V3 <<= 2)\n{\n  if (tmpspm & 0x3)\n  {\n    vp = tmpp & 0x3;\n    va = tmpa & 0x3;\n    switch (vp)\n    {\n      case 0x0:\n        if (va == 0x3)\n      {\n        count2++;\n        *xspm &= ~V3;\n        var_remove(F->data + (F->wsize * index), x);\n        Update_Set_SPM(F, index);\n      }\n\n        break;\n\n      case 0x1:\n\n      case 0x2:\n        count1++;\n        cmp_val = (va < 3) ? (va) : (vp);\n        if (ax_val == cmp_val)\n      {\n        *xspm &= ~V2;\n        (F->data + (F->wsize * index))[((y + 1) >> 5) + 1] &= ~(1 << ((y + 1) & (32 - 1)));\n        Update_Set_SPM(F, index);\n      }\n      else\n      {\n        *xspm &= ~V1;\n        (F->data + (F->wsize * index))[(y >> 5) + 1] &= ~(1 << (y & (32 - 1)));\n        Update_Set_SPM(F, index);\n      }\n\n        break;\n\n      case 0x3:\n\n      default:\n        break;\n\n    }\n\n  }\n\n  tmpa >>= 2;\n  tmpp >>= 2;\n  tmpspm >>= 2;\n  if (!tmpspm)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for nowait collapse(2) shared(SPM) private(f_set, r_set)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  a[i + (N * j)] = x[i] * y[j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < N; k++)\n  for (j = k + 1; j < N; j++)\n{\n  T = M[(k * N) + j];\n  M[(k * N) + j] = M[(j * N) + k];\n  M[(j * N) + k] = T;\n}\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < N; j++)\n  M[j] = 0.5 + (((double) rand()) / 32767);\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j < padding; j++)\n  M[N + j] = 0.0;\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < N; k++)\n{\n  for (j = 0; j < N; j++)\n    M[(k * N) + j] = 0.5 + (((double) rand()) / 32767);\n\n  for (j = N; j < (N + padding); j++)\n    M[(k * N) + j] = 0.0;\n\n}\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = N; k < (N + padding); k++)\n  for (j = 0; j < (N + padding); j++)\n  M[(k * N) + j] = 0.0;\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < N; k++)\n  for (j = 0; j < N; j++)\n  M[(k * N) + j] = 0.0;\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  S += c[i];\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  S += c[(i * N) + j];\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  a[(i * N) + j] = x[i] * y[j];\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  x[i] = x[i] / r;\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N2; i += CLS / (sizeof(double)))\n  for (j = 0; j < N; j += CLS / (sizeof(double)))\n  for (k = 0; k < N; k += CLS / (sizeof(double)))\n  for (i2 = 0, c2 = &c[(i * N) + j], a2 = &a[(i * N) + k]; i2 < (CLS / (sizeof(double))); ++i2, c2 += N, a2 += N)\n{\n  _mm_prefetch(&a2[8], _MM_HINT_NTA);\n  for (k2 = 0, b2 = &b[(k * N) + j]; k2 < (CLS / (sizeof(double))); ++k2, b2 += N)\n  {\n    int m1d = _mm_load_sd(&a2[k2]);\n    m1d = _mm_unpacklo_pd(m1d, m1d);\n    for (j2 = 0; j2 < (CLS / (sizeof(double))); j2 += 2)\n    {\n      int m2 = _mm_load_pd(&b2[j2]);\n      int r2 = _mm_load_pd(&c2[j2]);\n      _mm_store_pd(&c2[j2], _mm_add_pd(_mm_mul_pd(m2, m1d), r2));\n    }\n\n  }\n\n}\n\n\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < N; j += CLS / (sizeof(double)))\n  for (k = 0; k < N; k += CLS / (sizeof(double)))\n  for (i2 = 0, c2 = &c[(i * N) + j], a2 = &a[(i * N) + k]; i2 < (CLS / (sizeof(double))); ++i2, c2 += N, a2 += N)\n{\n  _mm_prefetch(&a2[8], _MM_HINT_NTA);\n  for (k2 = 0, b2 = &b[(k * N) + j]; k2 < (CLS / (sizeof(double))); ++k2, b2 += N)\n  {\n    int m1d = _mm_load_sd(&a2[k2]);\n    m1d = _mm_unpacklo_pd(m1d, m1d);\n    for (j2 = 0; j2 < (CLS / (sizeof(double))); j2 += 2)\n    {\n      int m2;\n      int r2;\n      if ((((i * N) + j) + j2) < (N * N))\n      {\n        m2 = _mm_load_pd(&b2[j2]);\n        r2 = _mm_load_pd(&c2[j2]);\n        _mm_store_pd(&c2[j2], _mm_add_pd(_mm_mul_pd(m2, m1d), r2));\n      }\n\n    }\n\n  }\n\n}\n\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < size; j++)\n{\n  if (val > a[j])\n    cnt++;\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared (size,a,b,val) reduction(+:cnt)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < size; i++)\n  a[i] = (-((i & 2) - 1)) * i;\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared (size,a,b,val) reduction(+:cnt)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  cnt = 0;\n  val = a[i];\n  for (j = 0; j < size; j++)\n  {\n    if (val > a[j])\n      cnt++;\n\n  }\n\n  b[cnt] = val;\n}\n\n", "pragma": "omp parallel for num_threads (thread_count) default(none) private(j,cnt,val) shared(size,a,b)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n  a[i] = (-((i & 2) - 1)) * i;\n\n", "pragma": "omp parallel for num_threads (thread_count) default(none) private(j,cnt,val) shared(size,a,b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m; i++)\n{\n  a[i] = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    a[i] += b[(i * n) + j] * c[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m,n,a,b,c) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m; i++)\n{\n  a[i] = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    a[i] += b[(i * n) + j] * c[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m,n,a,b,c) private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    b[(i * n) + j] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m,n,a,b,c) private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < n; j++)\n{\n  c[j] = 2.0;\n}\n\n", "pragma": "omp parallel for default(none) shared(m,n,a,b,c) private(i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter <= (NUMOUT - 1); iter++)\n{\n  for (jter = 0; jter < initn; jter++)\n  {\n    init_scratch[jter] = init_array[iter][jter];\n  }\n\n  for (jter = 0; jter < param_n; jter++)\n  {\n    param_scratch[jter] = param[iter][jter];\n  }\n\n  if (err_test == 0)\n  {\n    err_temp = call_cvode(param_scratch, init_scratch, RTOL, atol_array, tstep_array, tout_array, NOUT, y_scratch);\n    err_test = err_test + err_temp;\n    for (jter = 0; jter < NOUT; jter++)\n    {\n      for (kter = 0; kter < NEQ; kter++)\n      {\n        y_out[jter][kter][iter] = y_scratch[jter][kter];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (jter = 0; jter < param_m; jter++)\n{\n  for (kter = 0; kter < param_n; kter++)\n  {\n    param[jter][kter] = pPTR[(kter * param_m) + jter];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (jter = 0; jter < initm; jter++)\n{\n  for (kter = 0; kter < initn; kter++)\n  {\n    init_array[jter][kter] = initPTR[(kter * initm) + jter];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < numsteps; iter++)\n{\n  tstep_array[iter] = stepPTR[iter];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < time_n; iter++)\n{\n  tout_array[iter] = outPTR[iter];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < atoln; iter++)\n{\n  atol_array[iter] = atolPTR[iter];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < NEQ; iter++)\n{\n  atol_array[iter] = 1.0e-8;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (iter = 0; iter < NUMOUT; iter++)\n{\n  for (jter = 0; jter < NEQ; jter++)\n  {\n    for (kter = 0; kter < NOUT; kter++)\n    {\n      output[(((iter * NEQ) * NOUT) + (jter * NOUT)) + kter] = yPTR[(iter + (jter * NUMOUT)) + ((kter * NEQ) * NUMOUT)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) shared(y_out,param,init_array,RTOL, atol_array,tstep_array,tout_array,NOUT,abort) private(iter,param_scratch,init_scratch,y_scratch,jter,kter,err_temp) reduction(+:err_test)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 0; k < nz; k++)\n  for (j = 0; j < ny; j++)\n  for (i = 0; i < nx; i++)\n  u[(i + (j * nx)) + ((k * nx) * ny)] = 0.0;\n\n\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, u) private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    istart = 2;\n    if ('r' == rb[(1 + (j * nx)) + ((k * nx) * ny)])\n      istart = 1;\n\n    for (i = istart; i < (nx - 1); i += 2)\n    {\n      rem = u[(i + (j * nx)) + ((k * nx) * ny)];\n      u[(i + (j * nx)) + ((k * nx) * ny)] = ((omega * (f[(i + (j * nx)) + ((k * nx) * ny)] - (((ax * (u[((i - 1) + (j * nx)) + ((k * nx) * ny)] + u[((i + 1) + (j * nx)) + ((k * nx) * ny)])) + (ay * (u[(i + ((j - 1) * nx)) + ((k * nx) * ny)] + u[(i + ((j + 1) * nx)) + ((k * nx) * ny)]))) + (az * (u[(i + (j * nx)) + (((k - 1) * nx) * ny)] + u[(i + (j * nx)) + (((k + 1) * nx) * ny)]))))) / d) - ((omega - 1.0) * u[(i + (j * nx)) + ((k * nx) * ny)]);\n      diff = u[(i + (j * nx)) + ((k * nx) * ny)] - rem;\n      update_norm += diff * diff;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, omega, d, rb, u, f, ax, ay, az) private(i, j, k, rem, diff, istart) reduction(+:update_norm)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    istart = 2;\n    if ('b' == rb[(1 + (j * nx)) + ((k * nx) * ny)])\n      istart = 1;\n\n    for (i = istart; i < (nx - 1); i += 2)\n    {\n      rem = u[(i + (j * nx)) + ((k * nx) * ny)];\n      u[(i + (j * nx)) + ((k * nx) * ny)] = ((omega * (f[(i + (j * nx)) + ((k * nx) * ny)] - (((ax * (u[((i - 1) + (j * nx)) + ((k * nx) * ny)] + u[((i + 1) + (j * nx)) + ((k * nx) * ny)])) + (ay * (u[(i + ((j - 1) * nx)) + ((k * nx) * ny)] + u[(i + ((j + 1) * nx)) + ((k * nx) * ny)]))) + (az * (u[(i + (j * nx)) + (((k - 1) * nx) * ny)] + u[(i + (j * nx)) + (((k + 1) * nx) * ny)]))))) / d) - ((omega - 1.0) * u[(i + (j * nx)) + ((k * nx) * ny)]);\n      diff = u[(i + (j * nx)) + ((k * nx) * ny)] - rem;\n      update_norm += diff * diff;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, omega, d, rb, u, f, ax, ay, az) private(i, j, k, rem, diff, istart) reduction(+:update_norm)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (k = 0; k < nz; k++)\n{\n  z = zlo + (k * dz);\n  for (j = 0; j < ny; j++)\n  {\n    y = ylo + (j * dy);\n    for (i = 0; i < nx; i++)\n    {\n      x = xlo + (i * dx);\n      f[(i + (j * nx)) + ((k * nx) * ny)] = (uxx_exact(x, y, z) + uyy_exact(x, y, z)) + uzz_exact(x, y, z);\n    }\n\n  }\n\n}\n\ndouble uxx_exact(double x, double y, double z)\n{\n  double pi = 4. * atan(1.0);\n  return ((((-2.0) * (1.0 + y)) * (1.0 - y)) * (1.0 - z)) * (1.0 + z);\n}\n\n\ndouble uyy_exact(double x, double y, double z)\n{\n  double pi = 4. * atan(1.0);\n  return ((((-2.0) * (1.0 + x)) * (1.0 - x)) * (1.0 - z)) * (1.0 + z);\n}\n\n\ndouble uzz_exact(double x, double y, double z)\n{\n  double pi = 4. * atan(1.0);\n  return ((((-2.0) * (1.0 + x)) * (1.0 - x)) * (1.0 - y)) * (1.0 + y);\n}\n\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < trials; ++i)\n  test_sizes[i] = (i + 1) * 20;\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < argc; ++i)\n{\n  test_sizes[i - 1] = atoi(argv[i]);\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < trials; ++i)\n{\n  myargs[0] = (myargs[1] = (myargs[2] = test_sizes[i]));\n  get_time(&start);\n  traxh = no_timing(argc, myargs);\n  get_time(&finish);\n  secs = timespec_diff(start, finish);\n  fprintf(fp, \"%u\\t%lg\\n\", myargs[0], secs);\n}\n\nint no_timing(int argc, int argv[3])\n{\n  int nx = -1;\n  int ny = -1;\n  int nz = -1;\n  double tol = 1.e-7;\n  long int it_max = 900000;\n  int io_interval = 100;\n  double xlo = -1.;\n  double ylo = -1.;\n  double zlo = -1;\n  double xhi = 1.;\n  double yhi = 1.;\n  double zhi = 1.;\n  get_prob_size(&nx, &ny, &nz, argc, argv);\n  driver(nx, ny, nz, it_max, tol, xlo, ylo, zlo, xhi, yhi, zhi, io_interval);\n  return 0;\n}\n\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((nx * ny) * nz); ++i)\n{\n  if (i % 1)\n  {\n    rb[i] = 'r';\n  }\n  else\n  {\n    rb[i] = 'b';\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((nx * ny) * nz); ++i)\n{\n  if ((i + activate) % 1)\n  {\n    rb[i] = 'r';\n  }\n  else\n  {\n    rb[i] = 'b';\n  }\n\n  if (0 == ((i + 1) % (nx * ny)))\n    ++activate;\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n{\n  tid = omp_get_thread_num();\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n{\n  sum = sum + (a[i] * b[i]);\n  printf(\"  tid= %d i=%d\\n\", tid, i);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 100; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_steps; i += 1)\n{\n  double x = (i - 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < MINI_MAXY; i++)\n{\n  xcur = xld;\n  ycur = yru - (i * ystep);\n  p = &previewBufferOriginal[i * MINI_MAXX];\n  for (j = 0; j < MINI_MAXX; j += 4)\n  {\n    CoreLoopDouble(xcur, ycur, xstep, &p);\n    xcur += 2 * xstep;\n    CoreLoopDouble(xcur, ycur, xstep, &p);\n    xcur += 2 * xstep;\n  }\n\n}\n\nvoid CoreLoopDouble(double xcur, double ycur, double xstep, unsigned char **p)\n{\n  double re[2];\n  double im[2];\n  unsigned k1[2];\n  double rez[2];\n  double imz[2];\n  double xold[2];\n  double yold[2];\n  double t1;\n  double t2;\n  double o1;\n  double o2;\n  int k = 0;\n  int period = 0;\n  re[0] = xcur;\n  re[1] = xcur + xstep;\n  im[0] = (im[1] = ycur);\n  memset(&rez, 0, sizeof(rez));\n  memset(&imz, 0, sizeof(imz));\n  memset(&xold, 0, sizeof(xold));\n  memset(&yold, 0, sizeof(yold));\n  memset(&k1, 0, sizeof(k1));\n  while (k < 2048)\n  {\n    if (!k1[0])\n    {\n      o1 = rez[0] * rez[0];\n      o2 = imz[0] * imz[0];\n      t2 = (2 * rez[0]) * imz[0];\n      t1 = o1 - o2;\n      rez[0] = t1 + re[0];\n      imz[0] = t2 + im[0];\n      if ((o1 + o2) > 4)\n        k1[0] = k;\n\n      if ((rez[0] == xold[0]) && (imz[0] == yold[0]))\n        k1[0] = 2048;\n\n    }\n\n    if (!k1[1])\n    {\n      o1 = rez[1] * rez[1];\n      o2 = imz[1] * imz[1];\n      t2 = (2 * rez[1]) * imz[1];\n      t1 = o1 - o2;\n      rez[1] = t1 + re[1];\n      imz[1] = t2 + im[1];\n      if ((o1 + o2) > 4)\n        k1[1] = k;\n\n      if ((rez[1] == xold[1]) && (imz[1] == yold[1]))\n        k1[1] = 2048;\n\n    }\n\n    if ((k1[0] * k1[1]) != 0)\n      break;\n\n    k++;\n    period = (period + 1) & 0xF;\n    if (period == 0xF)\n    {\n      xold[0] = rez[0];\n      xold[1] = rez[1];\n      ;\n      yold[0] = imz[0];\n      yold[1] = imz[1];\n      ;\n    }\n\n  }\n\n  if (!k1[0])\n    k1[0] = 2048;\n\n  *((*p)++) = (k1[0] == 2048) ? (128) : (k1[0] & 127);\n  if (!k1[1])\n    k1[1] = 2048;\n\n  *((*p)++) = (k1[1] == 2048) ? (128) : (k1[1] & 127);\n}\n\n\nvoid CoreLoopDouble(double xcur, double ycur, double xstep, unsigned char **p)\n{\n  double re[2];\n  double im[2];\n  unsigned k1[2];\n  double rez[2];\n  double imz[2];\n  double xold[2];\n  double yold[2];\n  double t1;\n  double t2;\n  double o1;\n  double o2;\n  int k = 0;\n  int period = 0;\n  re[0] = xcur;\n  re[1] = xcur + xstep;\n  im[0] = (im[1] = ycur);\n  memset(&rez, 0, sizeof(rez));\n  memset(&imz, 0, sizeof(imz));\n  memset(&xold, 0, sizeof(xold));\n  memset(&yold, 0, sizeof(yold));\n  memset(&k1, 0, sizeof(k1));\n  while (k < 2048)\n  {\n    if (!k1[0])\n    {\n      o1 = rez[0] * rez[0];\n      o2 = imz[0] * imz[0];\n      t2 = (2 * rez[0]) * imz[0];\n      t1 = o1 - o2;\n      rez[0] = t1 + re[0];\n      imz[0] = t2 + im[0];\n      if ((o1 + o2) > 4)\n        k1[0] = k;\n\n      if ((rez[0] == xold[0]) && (imz[0] == yold[0]))\n        k1[0] = 2048;\n\n    }\n\n    if (!k1[1])\n    {\n      o1 = rez[1] * rez[1];\n      o2 = imz[1] * imz[1];\n      t2 = (2 * rez[1]) * imz[1];\n      t1 = o1 - o2;\n      rez[1] = t1 + re[1];\n      imz[1] = t2 + im[1];\n      if ((o1 + o2) > 4)\n        k1[1] = k;\n\n      if ((rez[1] == xold[1]) && (imz[1] == yold[1]))\n        k1[1] = 2048;\n\n    }\n\n    if ((k1[0] * k1[1]) != 0)\n      break;\n\n    k++;\n    period = (period + 1) & 0xF;\n    if (period == 0xF)\n    {\n      xold[0] = rez[0];\n      xold[1] = rez[1];\n      ;\n      yold[0] = imz[0];\n      yold[1] = imz[1];\n      ;\n    }\n\n  }\n\n  if (!k1[0])\n    k1[0] = 2048;\n\n  *((*p)++) = (k1[0] == 2048) ? (128) : (k1[0] & 127);\n  if (!k1[1])\n    k1[1] = 2048;\n\n  *((*p)++) = (k1[1] == 2048) ? (128) : (k1[1] & 127);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,4) private(p,xcur,ycur,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXY; i++)\n{\n  int offset = (i >> 2) * (MAXX >> 2);\n  xcur = xld;\n  ycur = yru - (i * ystep);\n  p = &buffer[i * MAXX];\n  for (j = 0; j < MAXX; j += 4, offset++)\n  {\n    if (128 == previewBufferFiltered[offset])\n    {\n      *(p++) = 128;\n      *(p++) = 128;\n      *(p++) = 128;\n      *(p++) = 128;\n      xcur += 4 * xstep;\n      saved++;\n      continue;\n    }\n\n    CoreLoopFloat(xcur, ycur, xstep, &p);\n    xcur += 4 * xstep;\n  }\n\n}\n\nvoid CoreLoopFloat(double xcur, double ycur, double xstep, unsigned char **p)\n{\n  float re[4];\n  float im[4];\n  unsigned k1[4];\n  float rez[4];\n  float imz[4];\n  float xold[4];\n  float yold[4];\n  float t1;\n  float t2;\n  float o1;\n  float o2;\n  int k = 0;\n  int period = 0;\n  re[0] = (float) xcur;\n  re[1] = (float) (xcur + xstep);\n  re[2] = (float) (xcur + (2 * xstep));\n  re[3] = (float) (xcur + (3 * xstep));\n  im[0] = (im[1] = (im[2] = (im[3] = (float) ycur)));\n  memset(&rez, 0, sizeof(rez));\n  memset(&imz, 0, sizeof(imz));\n  memset(&xold, 0, sizeof(xold));\n  memset(&yold, 0, sizeof(yold));\n  memset(&k1, 0, sizeof(k1));\n  while (k < 2048)\n  {\n    if (!k1[0])\n    {\n      o1 = rez[0] * rez[0];\n      o2 = imz[0] * imz[0];\n      t2 = (2 * rez[0]) * imz[0];\n      t1 = o1 - o2;\n      rez[0] = t1 + re[0];\n      imz[0] = t2 + im[0];\n      if ((o1 + o2) > 4)\n        k1[0] = k;\n\n      if ((rez[0] == xold[0]) && (imz[0] == yold[0]))\n        k1[0] = 2048;\n\n    }\n\n    if (!k1[1])\n    {\n      o1 = rez[1] * rez[1];\n      o2 = imz[1] * imz[1];\n      t2 = (2 * rez[1]) * imz[1];\n      t1 = o1 - o2;\n      rez[1] = t1 + re[1];\n      imz[1] = t2 + im[1];\n      if ((o1 + o2) > 4)\n        k1[1] = k;\n\n      if ((rez[1] == xold[1]) && (imz[1] == yold[1]))\n        k1[1] = 2048;\n\n    }\n\n    if (!k1[2])\n    {\n      o1 = rez[2] * rez[2];\n      o2 = imz[2] * imz[2];\n      t2 = (2 * rez[2]) * imz[2];\n      t1 = o1 - o2;\n      rez[2] = t1 + re[2];\n      imz[2] = t2 + im[2];\n      if ((o1 + o2) > 4)\n        k1[2] = k;\n\n      if ((rez[2] == xold[2]) && (imz[2] == yold[2]))\n        k1[2] = 2048;\n\n    }\n\n    if (!k1[3])\n    {\n      o1 = rez[3] * rez[3];\n      o2 = imz[3] * imz[3];\n      t2 = (2 * rez[3]) * imz[3];\n      t1 = o1 - o2;\n      rez[3] = t1 + re[3];\n      imz[3] = t2 + im[3];\n      if ((o1 + o2) > 4)\n        k1[3] = k;\n\n      if ((rez[3] == xold[3]) && (imz[3] == yold[3]))\n        k1[3] = 2048;\n\n    }\n\n    if ((((k1[0] * k1[1]) * k1[2]) * k1[3]) != 0)\n      break;\n\n    k++;\n    period = (period + 1) & 0xF;\n    if (period == 0xF)\n    {\n      xold[0] = rez[0];\n      xold[1] = rez[1];\n      xold[2] = rez[2];\n      xold[3] = rez[3];\n      ;\n      yold[0] = imz[0];\n      yold[1] = imz[1];\n      yold[2] = imz[2];\n      yold[3] = imz[3];\n      ;\n    }\n\n  }\n\n  if (!k1[0])\n    k1[0] = 2048;\n\n  *((*p)++) = (k1[0] == 2048) ? (128) : (k1[0] & 127);\n  if (!k1[1])\n    k1[1] = 2048;\n\n  *((*p)++) = (k1[1] == 2048) ? (128) : (k1[1] & 127);\n  if (!k1[2])\n    k1[2] = 2048;\n\n  *((*p)++) = (k1[2] == 2048) ? (128) : (k1[2] & 127);\n  if (!k1[3])\n    k1[3] = 2048;\n\n  *((*p)++) = (k1[3] == 2048) ? (128) : (k1[3] & 127);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,4) private(p,xcur,ycur,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXY; i++)\n{\n  int offset = (i >> 2) * (MAXX >> 2);\n  xcur = xld;\n  ycur = yru - (i * ystep);\n  p = &buffer[i * MAXX];\n  for (j = 0; j < MAXX; j += 4, offset++)\n  {\n    if (128 == previewBufferFiltered[offset])\n    {\n      *(p++) = 128;\n      *(p++) = 128;\n      *(p++) = 128;\n      *(p++) = 128;\n      xcur += 4 * xstep;\n      saved++;\n      continue;\n    }\n\n    CoreLoopDouble(xcur, ycur, xstep, &p);\n    xcur += 2 * xstep;\n    CoreLoopDouble(xcur, ycur, xstep, &p);\n    xcur += 2 * xstep;\n  }\n\n}\n\nvoid CoreLoopDouble(double xcur, double ycur, double xstep, unsigned char **p)\n{\n  double re[2];\n  double im[2];\n  unsigned k1[2];\n  double rez[2];\n  double imz[2];\n  double xold[2];\n  double yold[2];\n  double t1;\n  double t2;\n  double o1;\n  double o2;\n  int k = 0;\n  int period = 0;\n  re[0] = xcur;\n  re[1] = xcur + xstep;\n  im[0] = (im[1] = ycur);\n  memset(&rez, 0, sizeof(rez));\n  memset(&imz, 0, sizeof(imz));\n  memset(&xold, 0, sizeof(xold));\n  memset(&yold, 0, sizeof(yold));\n  memset(&k1, 0, sizeof(k1));\n  while (k < 2048)\n  {\n    if (!k1[0])\n    {\n      o1 = rez[0] * rez[0];\n      o2 = imz[0] * imz[0];\n      t2 = (2 * rez[0]) * imz[0];\n      t1 = o1 - o2;\n      rez[0] = t1 + re[0];\n      imz[0] = t2 + im[0];\n      if ((o1 + o2) > 4)\n        k1[0] = k;\n\n      if ((rez[0] == xold[0]) && (imz[0] == yold[0]))\n        k1[0] = 2048;\n\n    }\n\n    if (!k1[1])\n    {\n      o1 = rez[1] * rez[1];\n      o2 = imz[1] * imz[1];\n      t2 = (2 * rez[1]) * imz[1];\n      t1 = o1 - o2;\n      rez[1] = t1 + re[1];\n      imz[1] = t2 + im[1];\n      if ((o1 + o2) > 4)\n        k1[1] = k;\n\n      if ((rez[1] == xold[1]) && (imz[1] == yold[1]))\n        k1[1] = 2048;\n\n    }\n\n    if ((k1[0] * k1[1]) != 0)\n      break;\n\n    k++;\n    period = (period + 1) & 0xF;\n    if (period == 0xF)\n    {\n      xold[0] = rez[0];\n      xold[1] = rez[1];\n      ;\n      yold[0] = imz[0];\n      yold[1] = imz[1];\n      ;\n    }\n\n  }\n\n  if (!k1[0])\n    k1[0] = 2048;\n\n  *((*p)++) = (k1[0] == 2048) ? (128) : (k1[0] & 127);\n  if (!k1[1])\n    k1[1] = 2048;\n\n  *((*p)++) = (k1[1] == 2048) ? (128) : (k1[1] & 127);\n}\n\n\nvoid CoreLoopDouble(double xcur, double ycur, double xstep, unsigned char **p)\n{\n  double re[2];\n  double im[2];\n  unsigned k1[2];\n  double rez[2];\n  double imz[2];\n  double xold[2];\n  double yold[2];\n  double t1;\n  double t2;\n  double o1;\n  double o2;\n  int k = 0;\n  int period = 0;\n  re[0] = xcur;\n  re[1] = xcur + xstep;\n  im[0] = (im[1] = ycur);\n  memset(&rez, 0, sizeof(rez));\n  memset(&imz, 0, sizeof(imz));\n  memset(&xold, 0, sizeof(xold));\n  memset(&yold, 0, sizeof(yold));\n  memset(&k1, 0, sizeof(k1));\n  while (k < 2048)\n  {\n    if (!k1[0])\n    {\n      o1 = rez[0] * rez[0];\n      o2 = imz[0] * imz[0];\n      t2 = (2 * rez[0]) * imz[0];\n      t1 = o1 - o2;\n      rez[0] = t1 + re[0];\n      imz[0] = t2 + im[0];\n      if ((o1 + o2) > 4)\n        k1[0] = k;\n\n      if ((rez[0] == xold[0]) && (imz[0] == yold[0]))\n        k1[0] = 2048;\n\n    }\n\n    if (!k1[1])\n    {\n      o1 = rez[1] * rez[1];\n      o2 = imz[1] * imz[1];\n      t2 = (2 * rez[1]) * imz[1];\n      t1 = o1 - o2;\n      rez[1] = t1 + re[1];\n      imz[1] = t2 + im[1];\n      if ((o1 + o2) > 4)\n        k1[1] = k;\n\n      if ((rez[1] == xold[1]) && (imz[1] == yold[1]))\n        k1[1] = 2048;\n\n    }\n\n    if ((k1[0] * k1[1]) != 0)\n      break;\n\n    k++;\n    period = (period + 1) & 0xF;\n    if (period == 0xF)\n    {\n      xold[0] = rez[0];\n      xold[1] = rez[1];\n      ;\n      yold[0] = imz[0];\n      yold[1] = imz[1];\n      ;\n    }\n\n  }\n\n  if (!k1[0])\n    k1[0] = 2048;\n\n  *((*p)++) = (k1[0] == 2048) ? (128) : (k1[0] & 127);\n  if (!k1[1])\n    k1[1] = 2048;\n\n  *((*p)++) = (k1[1] == 2048) ? (128) : (k1[1] & 127);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,4) private(p,xcur,ycur,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MINI_MAXY; i++)\n{\n  for (j = 0; j < MINI_MAXX; j++)\n  {\n    int up = 128;\n    int left = 128;\n    int down = 128;\n    int right = 128;\n    if (i > 0)\n      up = *(pSrc - MINI_MAXX);\n\n    if (i < (MINI_MAXY - 1))\n      down = *(pSrc + MINI_MAXX);\n\n    if (j > 0)\n      left = *(pSrc - 1);\n\n    if (j < (MINI_MAXX - 1))\n      right = *(pSrc + 1);\n\n    *(pDst++) = ((((*(pSrc++)) & up) & down) & left) & right;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,4) private(p,xcur,ycur,i,j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < MAXY; i++)\n{\n  double ycur = yru - (i * ystep);\n  unsigned char *p = &bufferMem[bufIdx][i * MAXX];\n  int yclose = ylookup[i];\n  xcur = xld;\n  for (j = 0; j < MAXX; j += 2)\n  {\n    int xclose = xlookup[j];\n    int xclose2 = xlookup[j + 1];\n    if (((xclose != (-1)) && (xclose2 != (-1))) && (yclose != (-1)))\n    {\n      *(p++) = bufferMem[bufIdx ^ 1][(yclose * MAXX) + xclose];\n      *(p++) = bufferMem[bufIdx ^ 1][(yclose * MAXX) + xclose2];\n    }\n    else\n    {\n      CoreLoopDouble(xcur, ycur, xstep, &p);\n    }\n\n    xcur += 2 * xstep;\n  }\n\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n{\n  xcoords[i] = malloc(MAXX * (sizeof(double)));\n  ycoords[i] = malloc(MAXY * (sizeof(double)));\n  if ((!xcoords[i]) || (!ycoords[i]))\n    panic(\"Out of memory\");\n\n  memset(xcoords[i], 0, MAXX * (sizeof(double)));\n  memset(ycoords[i], 0, MAXY * (sizeof(double)));\n  bufferMem[i] = malloc(MAXX * MAXY);\n  if (!bufferMem[i])\n    panic(\"Out of memory\");\n\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXX; i++)\n{\n  int idx_best = -1;\n  double diff = 1e10;\n  xcoords[bufIdx][i] = xcur;\n  for (j = i - 30; j < (i + 30); j++)\n  {\n    if (j < 0)\n      continue;\n\n    if (j > (MAXX - 1))\n      continue;\n\n    double ndiff = fabs(xcur - xcoords[bufIdx ^ 1][j]);\n    if (ndiff < diff)\n    {\n      diff = ndiff;\n      idx_best = j;\n    }\n\n  }\n\n  points[i].distance = diff;\n  points[i].idx_best = idx_best;\n  points[i].idx_original = i;\n  xcur += xstep;\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXX; i++)\n{\n  int orig_idx = points[i].idx_original;\n  int idx_best = points[i].idx_best;\n  if (bFirstFrameEver || (i < ((MAXX * percentageOfPixelsToRedraw) / 100)))\n    xlookup[orig_idx] = -1;\n  else\n  {\n    xlookup[orig_idx] = idx_best;\n    xcoords[bufIdx][orig_idx] = xcoords[bufIdx ^ 1][idx_best];\n  }\n\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXY; i++)\n{\n  int idx_best = -1;\n  double diff = 1e10;\n  ycoords[bufIdx][i] = ycur;\n  for (j = i - 30; j < (i + 30); j++)\n  {\n    if (j < 0)\n      continue;\n\n    if (j > (MAXY - 1))\n      continue;\n\n    double ndiff = fabs(ycur - ycoords[bufIdx ^ 1][j]);\n    if (ndiff < diff)\n    {\n      diff = ndiff;\n      idx_best = j;\n    }\n\n  }\n\n  points[i].distance = diff;\n  points[i].idx_best = idx_best;\n  points[i].idx_original = i;\n  ycur -= ystep;\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < MAXY; i++)\n{\n  int orig_idx = points[i].idx_original;\n  int idx_best = points[i].idx_best;\n  if (bFirstFrameEver || (i < ((MAXY * percentageOfPixelsToRedraw) / 100)))\n    ylookup[orig_idx] = -1;\n  else\n  {\n    ylookup[orig_idx] = idx_best;\n    ycoords[bufIdx][orig_idx] = ycoords[bufIdx ^ 1][idx_best];\n  }\n\n}\n\n", "pragma": "omp parallel for private(xcur, j)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  for (i = 0; i < wl_size; i++)\n  {\n    hash = hf[j](get_word(wl, i));\n    hash %= bv_size;\n    bv[hash] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(i,hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  hash = hf[j](word);\n  hash %= bv_size;\n  if (bv[hash] == 0)\n    misspelled = 1;\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  for (i = 0; i < wl_size; i++)\n  {\n    hash = hf[j](get_word(wl, i));\n    hash %= bv_size;\n    bv[hash] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(i, hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  hash = hf[j](word);\n  hash %= bv_size;\n  if (bv[hash] == 0)\n    misspelled = 1;\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(i, hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  for (i = 0; i < wl_size; i++)\n  {\n    hash = hf[j](get_word(wl, i));\n    hash %= bv_size;\n    bv[hash] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  hash = hf[j](word);\n  hash %= bv_size;\n  if (bv[hash] == 0)\n    misspelled = 1;\n\n}\n\n", "pragma": "omp parallel for private(hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  for (i = 0; i < wl_size; i++)\n  {\n    hash = hf[j](get_word(wl, i));\n    hash %= bv_size;\n    bv[hash] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,hash)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < num_hf; j++)\n{\n  hash = hf[j](word);\n  hash %= bv_size;\n  if (bv[hash] == 0)\n    misspelled = 1;\n\n}\n\n", "pragma": "omp parallel for private(i,hash)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:diff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:dsum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:ddiff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(*:product)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (long j = 0; j < length; j++)\n{\n  long vlength = (rand() % (maxlength - minlength)) + minlength;\n  vlengths[j] = vlength;\n  vector[j] = (int *) malloc(vlength * (sizeof(int)));\n  switch (order)\n  {\n    case ASCENDING:\n      for (long i = 0; i < vlength; i++)\n    {\n      vector[j][i] = (int) i;\n    }\n\n      break;\n\n    case DESCENDING:\n      for (long i = 0; i < vlength; i++)\n    {\n      vector[j][i] = (int) (vlength - i);\n    }\n\n      break;\n\n    case RANDOM:\n      for (long i = 0; i < vlength; i++)\n    {\n      vector[j][i] = rand();\n    }\n\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_reduction())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_reduction()\n{\n  int sum;\n  int known_sum;\n  double dsum;\n  double dknown_sum;\n  double dt = 0.5;\n  double rounding_error = 1.E-9;\n  int diff;\n  double ddiff;\n  int product;\n  int known_product;\n  int logic_and;\n  int logic_or;\n  int bit_and;\n  int bit_or;\n  int exclusiv_bit_or;\n  int logics[1000];\n  int i;\n  double dpt;\n  int result;\n  sum = 0;\n  dsum = 0;\n  product = 1;\n  logic_and = 1;\n  logic_or = 0;\n  bit_and = 1;\n  bit_or = 0;\n  exclusiv_bit_or = 0;\n  result = 0;\n  dt = 1. / 3.;\n  known_sum = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n  }\n\n  if (known_sum != sum)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with integers: Result was %d instead of %d\\n\", sum, known_sum);\n  }\n\n  diff = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; ++i)\n  {\n    diff = diff - i;\n  }\n\n  if (diff != 0)\n  {\n    result++;\n    fprintf(stderr, \"Error in difference with integers: Result was %d instead of 0.\\n\", diff);\n  }\n\n  dsum = 0;\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  dknown_sum = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    dsum += pow(dt, i);\n  }\n\n  if (fabs(dsum - dknown_sum) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\", dsum, dknown_sum, dsum - dknown_sum);\n  }\n\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  fprintf(stderr, \"\\n\");\n  ddiff = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    ddiff -= pow(dt, i);\n  }\n\n  if (fabs(ddiff) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in Difference with doubles: Result was %E instead of 0.0\\n\", ddiff);\n  }\n\n  for (i = 1; i <= 10; i++)\n  {\n    product *= i;\n  }\n\n  known_product = 3628800;\n  if (known_product != product)\n  {\n    result++;\n    fprintf(stderr, \"Error in Product with integers: Result was %d instead of %d\\n\\n\", product, known_product);\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (!logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 1.\\n\");\n  }\n\n  logic_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 1.\\n\");\n  }\n\n  logic_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (!logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (!bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 1.\\n\");\n  }\n\n  bit_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 1\\n\");\n  }\n\n  bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (!bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 2\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 1\\n\");\n  }\n\n  exclusiv_bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (!exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 2\\n\");\n  }\n\n  return result == 0;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + (i + i2);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(i) firstprivate(i2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_firstprivate())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_firstprivate()\n{\n  int sum;\n  int i2;\n  int i;\n  int known_sum;\n  sum = 0;\n  i2 = 3;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + (i + i2);\n  }\n\n  known_sum = ((1000 * (1000 + 1)) / 2) + (i2 * 1000);\n  return known_sum == sum;\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) private(i) firstprivate(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= 1000; i++)\n{\n  num_threads = omp_get_num_threads();\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for private(i) if (control==1)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_if())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_if()\n{\n  int known_sum;\n  int num_threads;\n  int sum;\n  int sum2;\n  int i;\n  int control;\n  control = 0;\n  num_threads = 0;\n  sum = 0;\n  sum2 = 0;\n  for (i = 0; i <= 1000; i++)\n  {\n    num_threads = omp_get_num_threads();\n    sum = sum + i;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  fprintf(stderr, \"Number of threads determined by omp_get_num_threads: %d\\n\", num_threads);\n  return (known_sum == sum) && (num_threads == 1);\n}\n\n\n", "pragma": "omp parallel for private(i) if (control==1)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n  i0 = i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) private(i) lastprivate(i0)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_lastprivate())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_lastprivate()\n{\n  int sum;\n  int i;\n  int i0;\n  int known_sum;\n  sum = 0;\n  i0 = -1;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n    i0 = i;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  return (known_sum == sum) && (i0 == 1000);\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,7) private(i) lastprivate(i0)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < 100; i++)\n{\n  ii = i;\n  {\n    is_larger = check_i_islarger2(ii) && is_larger;\n    sum = sum + ii;\n  }\n}\n\nstatic int check_i_islarger2(int i)\n{\n  int islarger;\n  islarger = i > last_i;\n  last_i = i;\n  return islarger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1) private(i) ordered", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_ordered())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_ordered()\n{\n  int sum;\n  int is_larger;\n  int known_sum;\n  int i;\n  sum = 0;\n  is_larger = 1;\n  last_i = 0;\n  for (i = 1; i < 100; i++)\n  {\n    ii = i;\n    {\n      is_larger = check_i_islarger2(ii) && is_larger;\n      sum = sum + ii;\n    }\n  }\n\n  known_sum = (99 * 100) / 2;\n  fprintf(stderr, \" known_sum = %d , sum = %d \\n\", known_sum, sum);\n  fprintf(stderr, \" is_larger = %d\\n\", is_larger);\n  return (known_sum == sum) && is_larger;\n}\n\n\n", "pragma": "omp parallel for schedule(static,1) private(i) ordered", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  i2 = i;\n  do_some_work();\n  sum = sum + i2;\n}\n\nstatic void do_some_work(void)\n{\n  int i;\n  double sum = 0;\n  for (i = 0; i < 1000; i++)\n  {\n    sum += sqrt(i);\n  }\n\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  sum += sqrt(i);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_private())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_private()\n{\n  int sum;\n  int i;\n  int i2;\n  int known_sum;\n  sum = 0;\n  i2 = 0;\n  for (i = 1; i <= 1000; i++)\n  {\n    i2 = i;\n    do_some_work();\n    sum = sum + i2;\n  }\n\n  known_sum = (1000 * (1000 + 1)) / 2;\n  return known_sum == sum;\n}\n\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static,1) private(i) private(i2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:diff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dsum += pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(+:dsum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  ddiff -= pow(dt, i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(-:ddiff)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i <= 10; i++)\n{\n  product *= i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(*:product)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_and = logic_and && logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&&:logic_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(||:logic_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(&:bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(|:bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logics[i] = 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_for_reduction())\n  {\n    num_failed++;\n  }\n\n}\n\nint test_omp_parallel_for_reduction()\n{\n  int sum;\n  int known_sum;\n  double dsum;\n  double dknown_sum;\n  double dt = 0.5;\n  double rounding_error = 1.E-9;\n  int diff;\n  double ddiff;\n  int product;\n  int known_product;\n  int logic_and;\n  int logic_or;\n  int bit_and;\n  int bit_or;\n  int exclusiv_bit_or;\n  int logics[1000];\n  int i;\n  double dpt;\n  int result;\n  sum = 0;\n  dsum = 0;\n  dt = 1. / 3.;\n  result = 0;\n  product = 1;\n  logic_and = 1;\n  logic_or = 0;\n  bit_and = 1;\n  bit_or = 0;\n  exclusiv_bit_or = 0;\n  known_sum = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; i++)\n  {\n    sum = sum + i;\n  }\n\n  if (known_sum != sum)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with integers: Result was %d instead of %d\\n\", sum, known_sum);\n  }\n\n  diff = (1000 * (1000 + 1)) / 2;\n  for (i = 1; i <= 1000; ++i)\n  {\n    diff = diff - i;\n  }\n\n  if (diff != 0)\n  {\n    result++;\n    fprintf(stderr, \"Error in difference with integers: Result was %d instead of 0.\\n\", diff);\n  }\n\n  dsum = 0;\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  dknown_sum = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    dsum += pow(dt, i);\n  }\n\n  if (fabs(dsum - dknown_sum) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in sum with doubles: Result was %f instead of %f (Difference: %E)\\n\", dsum, dknown_sum, dsum - dknown_sum);\n  }\n\n  dpt = 1;\n  for (i = 0; i < 20; ++i)\n  {\n    dpt *= dt;\n  }\n\n  fprintf(stderr, \"\\n\");\n  ddiff = (1 - dpt) / (1 - dt);\n  for (i = 0; i < 20; ++i)\n  {\n    ddiff -= pow(dt, i);\n  }\n\n  if (fabs(ddiff) > rounding_error)\n  {\n    result++;\n    fprintf(stderr, \"Error in Difference with doubles: Result was %E instead of 0.0\\n\", ddiff);\n  }\n\n  for (i = 1; i <= 10; i++)\n  {\n    product *= i;\n  }\n\n  known_product = 3628800;\n  if (known_product != product)\n  {\n    result++;\n    fprintf(stderr, \"Error in Product with integers: Result was %d instead of %d\\n\\n\", product, known_product);\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (!logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 1.\\n\");\n  }\n\n  logic_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_and = logic_and && logics[i];\n  }\n\n  if (logic_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 1.\\n\");\n  }\n\n  logic_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    logic_or = logic_or || logics[i];\n  }\n\n  if (!logic_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in logic OR part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    logics[i] = 1;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (!bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 1.\\n\");\n  }\n\n  bit_and = 1;\n  logics[1000 / 2] = 0;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_and = bit_and & logics[i];\n  }\n\n  if (bit_and)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT AND part 2.\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 1\\n\");\n  }\n\n  bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    bit_or = bit_or | logics[i];\n  }\n\n  if (!bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in BIT OR part 2\\n\");\n  }\n\n  for (i = 0; i < 1000; i++)\n  {\n    logics[i] = 0;\n  }\n\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 1\\n\");\n  }\n\n  exclusiv_bit_or = 0;\n  logics[1000 / 2] = 1;\n  for (i = 0; i < 1000; ++i)\n  {\n    exclusiv_bit_or = exclusiv_bit_or ^ logics[i];\n  }\n\n  if (!exclusiv_bit_or)\n  {\n    result++;\n    fprintf(stderr, \"Error in EXCLUSIV BIT OR part 2\\n\");\n  }\n\n  return result == 0;\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic,1) private(i) reduction(^:exclusiv_bit_or)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < i16; i++)\n{\n  r += (((((((((((((((i + i1) + i2) + i3) + i4) + i5) + i6) + i7) + i8) + i9) + i10) + i11) + i12) + i13) + i14) + i15) + i16;\n}\n\n", "pragma": "omp parallel for firstprivate(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16) reduction(+:r)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (j = 0; j < N; j++)\n{\n  sum += matrix[i][j];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    matrix[i][j] = rand() % 10;\n    printf(\"%d\\t \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 6; j++)\n{\n  for (i = 0; i < dimension; i++)\n  {\n    producto = producto + (vector1[i] * vector2[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:producto)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < dimension; i++)\n{\n  vector1[i] = rand() % 100;\n  vector2[i] = rand() % 100;\n}\n\n", "pragma": "omp parallel for reduction(+:producto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < dimension; i++)\n{\n  vector1[i] += vector2[i];\n}\n\n", "pragma": "omp parallel for reduction(+:producto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < totalIteraciones; i++)\n{\n  sum1 = sum1 + i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum1)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < (righeA * colonneA); i++)\n{\n  for (j = 0; j < (righeB * colonneB); j++)\n  {\n    k = cIndex(i, j, righeA, colonneA, righeB, colonneB);\n    C[k] = A[i] * B[j];\n  }\n\n}\n\nint cIndex(int a, int b, int righeA, int colonneA, int righeB, int colonneB)\n{\n  int rA;\n  int cA;\n  int rB;\n  int cB;\n  int rigaR;\n  int colonnaR;\n  rA = a / colonneA;\n  cA = a % colonneA;\n  rB = b / colonneB;\n  cB = b % colonneB;\n  rigaR = (righeB * rA) + rB;\n  colonnaR = (colonneB * cA) + cB;\n  return ((rigaR * colonneA) * colonneB) + colonnaR;\n}\n\n\n", "pragma": "omp parallel for shared(C)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (righeC * colonneC); i++)\n  printf(\"%f \", C[i]);\n\n", "pragma": "omp parallel for shared(C)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n  for (j = 0; j < 2; j++)\n  for (k = 0; k < 2; k++)\n  a[i][j][k] = (i + (j * 4)) + (k * 16);\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2; i++)\n  for (j = 0; j < 2; j++)\n  for (k = 0; k < 2; k++)\n  if (a[i][j][k] != ((i + (j * 4)) + (k * 16)))\n  l = 1;\n\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = -2; i < m1; i++)\n  for (j = m2; j < (-2); j++)\n{\n  for (k = 13; k < m3; k++)\n  {\n    if ((omp_get_num_threads() == 8) && (((((i + 2) * 12) + ((j + 5) * 4)) + (k - 13)) != ((omp_get_thread_num() * 9) + (f++))))\n      l++;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for num_threads (8) collapse(3) schedule(static, 9) reduction(+:l) firstprivate(f)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < 2; i++)\n  for (int j = 0; j < 2; j++)\n  for (int k = 0; k < 2; k++)\n  a[i][j][k] = (i + (j * 4)) + (k * 16);\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i2 = 0; i2 < 2; i2++)\n  for (int j = 0; j < 2; j++)\n  for (int k = 0; k < 2; k++)\n  if (a[i2][j][k] != ((i2 + (j * 4)) + (k * 16)))\n  l = 1;\n\n\n\n\n", "pragma": "omp parallel for collapse(4 - 1) schedule(static, 4)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; (&buf[54]) > p; p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[51]) > p; p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; (&buf[40]) >= p; p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; (&buf[9]) < p; --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; (&buf[3]) <= p; p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; (&buf[15]) < p; p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; (&buf[16]) <= p; p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (static, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[10]; p < (&buf[54]); p++)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p < (&buf[51]); p = 4 + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[16]; p <= (&buf[40]); p = p + 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[63]; p >= (&buf[3]); p -= 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[48]; p > (&buf[15]); p = (-4) + p)\n  p[2] = 7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = &buf[40]; p >= (&buf[16]); p = p - 4ULL)\n  p[2] = -7;\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (5 * ((i >= 10) && (i < 54))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (6 * ((i & 1) && (i <= 61))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != (7 * ((((i & 3) == 2) && (i >= 18)) && (i < 53))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  buf[i] = i;\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  buf[i] += i;\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 256; i++)\n  if (buf[i] != (2 * i))\n  abort();\n\n\n", "pragma": "omp parallel for schedule (auto)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (p = buf; p < (&buf[8]); p++)\n  for (q = &buf2[0]; q <= (buf2 + 7); q++)\n  sum += ((*p) - '0') + ((*q) - '0');\n\n\n", "pragma": "omp parallel for collapse (2) reduction (+:sum) lastprivate (p, q)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 50; i += 3)\n  ;\n\n", "pragma": "omp parallel for lastprivate (i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = -50; j < 70; j += 7)\n  ;\n\n", "pragma": "omp parallel for lastprivate (j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  a = a + i;\n\n", "pragma": "omp parallel for firstprivate (a) lastprivate (a) num_threads (2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  sum = sum + (a[i] * b[i]);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n{\n  if (first_time == 'y')\n  {\n    tid = omp_get_thread_num();\n    first_time = 'n';\n  }\n\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (static, 1) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (static, 1) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (runtime) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (runtime) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (dynamic) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (dynamic) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (guided) num_threads (4) if (0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1000; j++)\n{\n  check(j);\n}\n\nvoid check(int x)\n{\n  if ((cnt++) != x)\n    abort();\n\n}\n\n\n", "pragma": "omp parallel for ordered schedule (guided) num_threads (4) if (1)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; i++)\n{\n  if (n != 6)\n    ++x;\n\n  n = i;\n}\n\n", "pragma": "omp parallel for num_threads (16) firstprivate (n) lastprivate (n) schedule (static, 1) reduction (+: x)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static, 2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static, 2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = -12; i < 21; i += 3)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (dynamic, 3)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < j; i += 1)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < j; ++i)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < j; i++)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; i += 1)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; ++i)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 3;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for shared (n, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 5;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 7;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for shared (n, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 1))\n    abort();\n\n\n  if (a[i] != (i + 1))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 3))\n    abort();\n\n\n  if (a[i] != (i + 3))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 5))\n    abort();\n\n\n  if (a[i] != (i + 5))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 7))\n    abort();\n\n\n  if (a[i] != (i + 7))\n    abort();\n\n}\n\n", "pragma": "omp parallel for private (a, b)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 8; ++i)\n  c += 1;\n\n", "pragma": "omp parallel for private(i) reduction(+:c)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = lb; i < ub; i += stride)\n  work(i);\n\nvoid work(int k)\n{\n  printf(\" %d\\n\", k);\n}\n\n\n", "pragma": "omp parallel for ordered schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  {\n    int up;\n    int left;\n    int diag;\n    long long int index = (m * ai) + aj;\n    up = H[index - m] + gapScore;\n    left = H[index - 1] + gapScore;\n    int t_mms;\n    if (a[aj - 1] == b[ai - 1])\n      t_mms = matchScore;\n    else\n      t_mms = missmatchScore;\n\n    diag = H[(index - m) - 1] + t_mms;\n    int max = 0;\n    int pred = 0;\n    if (diag > max)\n    {\n      max = diag;\n      pred = 3;\n    }\n\n    if (up > max)\n    {\n      max = up;\n      pred = 1;\n    }\n\n    if (left > max)\n    {\n      max = left;\n      pred = 2;\n    }\n\n    H[index] = max;\n    P[index] = pred;\n    if (max > H[maxPos_ptr[0]])\n    {\n      maxPos_ptr[0] = index;\n    }\n\n  }\n}\n\n", "pragma": "omp parallel for default(none) private(j) shared (a,b, nEle, m, n, gapScore, matchScore, missmatchScore, si, sj, H, P, maxPos_ptr)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P, maxPos_ptr)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, maxPos_ptr);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P, maxPos_ptr)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P) num_threads(numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < nEle; ++j)\n{\n  long long int ai = si - j;\n  long long int aj = sj + j;\n  similarityScore(ai, aj, H, P, &maxPos);\n}\n\nvoid similarityScore(long long int i, long long int j, int *H, int *P, long long int *maxPos_ptr)\n{\n  int up;\n  int left;\n  int diag;\n  long long int index = (m * i) + j;\n  up = H[index - m] + gapScore;\n  left = H[index - 1] + gapScore;\n  int t_mms;\n  if (a[j - 1] == b[i - 1])\n    t_mms = matchScore;\n  else\n    t_mms = missmatchScore;\n\n  diag = H[(index - m) - 1] + t_mms;\n  int max = 0;\n  int pred = 0;\n  if (diag > max)\n  {\n    max = diag;\n    pred = 3;\n  }\n\n  if (up > max)\n  {\n    max = up;\n    pred = 1;\n  }\n\n  if (left > max)\n  {\n    max = left;\n    pred = 2;\n  }\n\n  H[index] = max;\n  P[index] = pred;\n  if (max > H[maxPos_ptr[0]])\n  {\n    maxPos_ptr[0] = index;\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared (nEle, si, sj, H, P)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < k; i++)\n{\n  counts[i] = 0;\n  tempC[i].x = 0;\n  tempC[i].y = 0;\n}\n\n", "pragma": "omp parallel for num_threads(p)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  minDist = FLT_MAX;\n  for (j = 0; j < k; j++)\n  {\n    dist = pow(data[i].x - centroids[j].x, 2) + pow(data[i].y - centroids[j].y, 2);\n    if (dist < minDist)\n    {\n      minDist = dist;\n      labels[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, dist, minDist) num_threads(p)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < k; i++)\n{\n  tempX = (counts[i]) ? (tempC[i].x / counts[i]) : (0);\n  tempY = (counts[i]) ? (tempC[i].y / counts[i]) : (0);\n  if ((centroids[i].x != tempX) || (centroids[i].y != tempY))\n  {\n    check += 1;\n    centroids[i].x = tempX;\n    centroids[i].y = tempY;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < count; i++)\n{\n  fscanf(pRead, \"%f %f\\n\", &data[i].x, &data[i].y);\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < k; i++)\n{\n  printf(\"%f %f\\n\", centroids[i].x, centroids[i].y);\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  ++counts[labels[i]];\n  tempC[labels[i]].x += data[i].x;\n  tempC[labels[i]].y += data[i].y;\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = (j = 0); i < k; i++)\n{\n  if (r)\n  {\n    c[i].x = (((float) (rand() % 1000)) / 1000) * 8;\n    c[i].y = (((float) (rand() % 1000)) / 1000) * 8;\n  }\n  else\n  {\n    j += size / k;\n    c[i].x = data[j].x;\n    c[i].y = data[j].y;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < k; i++)\n{\n  fprintf(pWrite, \"%f %f\\n\", c[i].x, c[i].y);\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  fprintf(pWrite, \"%d\\n\", labels[i]);\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < k; i++)\n{\n  fprintf(pWrite, \"%f %f\\n\", centroids[i].x, centroids[i].y);\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1024; j++)\n{\n  ran[j] = (6364136223846793005ULL * ran[j]) + 1;\n  Table[ran[j] >> (64 - logTableSize)] ^= ran[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (un = (u64Int) n; un; un >>= 1)\n{\n  if (un & 1)\n    ran = (mul_k * ran) + add_k;\n\n  add_k *= mul_k + 1;\n  mul_k *= mul_k;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1024; j++)\n  ran[j] = HPCC_starts_LCG(((4 * TableSize) / 1024) * j);\n\nu64Int HPCC_starts_LCG(s64Int n)\n{\n  u64Int mul_k;\n  u64Int add_k;\n  u64Int ran;\n  u64Int un;\n  mul_k = 6364136223846793005ULL;\n  add_k = 1;\n  ran = 1;\n  for (un = (u64Int) n; un; un >>= 1)\n  {\n    if (un & 1)\n      ran = (mul_k * ran) + add_k;\n\n    add_k *= mul_k + 1;\n    mul_k *= mul_k;\n  }\n\n  return ran;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < TableSize; i <<= 1)\n  logTableSize += 1;\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int row = 0; row < data->bN; row++)\n{\n  for (int col = 0; col < data->bN; col++)\n  {\n    board[row][col] = rand() % 3;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < data->bN; i++)\n{\n  free(board[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (r = rpos; r < (rpos + tileSize); r++)\n{\n  for (int c = cpos; c < (cpos + tileSize); c++)\n  {\n    if (board[r][c] == 1)\n      reds += 1.0;\n    else\n      if (board[r][c] == 2)\n      blues += 1.0;\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:reds,blues)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int r = 0; r < work->bN; r++)\n{\n  int moveRed = 0;\n  if ((board[r][work->bN - 1] == 1) && (board[r][0] == 0))\n  {\n    moveRed = 1;\n  }\n\n  for (int c = 0; c < (work->bN - 1); c++)\n  {\n    if ((board[r][c] == 1) && (board[r][c + 1] == 0))\n    {\n      board[r][c + 1] = 1;\n      board[r][c] = 0;\n      c++;\n    }\n\n  }\n\n  if (moveRed)\n  {\n    board[r][work->bN - 1] = 0;\n    board[r][0] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int r = 0; r < work->bN; r++)\n{\n  int moveBlue = 0;\n  if ((board[work->bN - 1][r] == 2) && (board[0][r] == 0))\n  {\n    moveBlue = 1;\n  }\n\n  for (int c = 0; c < (-1); c++)\n  {\n    if ((board[c][r] == 2) && (board[c + 1][r] == 0))\n    {\n      board[c + 1][r] = 2;\n      board[c][r] = 0;\n      c++;\n    }\n\n  }\n\n  if (moveBlue)\n  {\n    board[work->bN - 1][r] = 0;\n    board[0][r] = 2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 1; i < argc; i++)\n{\n  switch (argv[i][0])\n  {\n    case 'p':\n      data->pN = atoi(&argv[i][1]);\n      if (data->pN < 1)\n      return 4;\n\n      parseCount++;\n      break;\n\n    case 'b':\n      data->bN = atoi(&argv[i][1]);\n      if (data->bN < 2)\n      return 2;\n\n      parseCount++;\n      break;\n\n    case 'c':\n      data->cN = atoi(&argv[i][1]);\n      if ((data->cN > 100) || (data->cN <= 0))\n      return 3;\n\n      parseCount++;\n      break;\n\n    case 'm':\n      data->mN = atoi(&argv[i][1]);\n      parseCount++;\n      break;\n\n    case 's':\n      data->sN = atoi(&argv[i][1]);\n      break;\n\n    case 't':\n      data->tN = atoi(&argv[i][1]);\n      if (data->tN == 1)\n      return 1;\n\n      parseCount++;\n      break;\n\n    case 'i':\n      data->iN = 1;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < data->bN; i++)\n{\n  board[i] = (int *) malloc(data->bN * (sizeof(int)));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int row = 0; row < (boardSize / tileSize); row += tileSize)\n{\n  for (int column = 0; column < (boardSize / tileSize); column += tileSize)\n  {\n    retVal = doCheck(row, column, tileSize);\n    if (retVal >= targetRatio)\n      return retVal;\n\n  }\n\n}\n\ndouble doCheck(int rpos, int cpos, int tileSize)\n{\n  double reds = 0.0;\n  double blues = 0.0;\n  int r = 0;\n  for (r = rpos; r < (rpos + tileSize); r++)\n  {\n    for (int c = cpos; c < (cpos + tileSize); c++)\n    {\n      if (board[r][c] == 1)\n        reds += 1.0;\n      else\n        if (board[r][c] == 2)\n        blues += 1.0;\n\n\n    }\n\n  }\n\n  if ((((double) reds) / ((double) (tileSize * tileSize))) > (((double) blues) / ((double) (tileSize * tileSize))))\n    return ((double) reds) / ((double) (tileSize * tileSize));\n  else\n    return ((double) blues) / ((double) (tileSize * tileSize));\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int row = 0; row < data.bN; row++)\n{\n  for (int col = 0; col < data.bN; col++)\n  {\n    if (board[row][col] == 0)\n      fprintf(fp, \" \");\n    else\n      if (board[row][col] == 1)\n      fprintf(fp, \">\");\n    else\n      fprintf(fp, \"v\");\n\n\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int args = 1; args < argc; args++)\n{\n  fprintf(fp, \"%s \", argv[args]);\n  fprintf(stdout, \"%s \", argv[args]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int j = 0; j < 800; j++)\n{\n  int as = _mm256_set1_pd(x0s2 + (sgsub * j));\n  for (int k = 0; k < 800; k += 4)\n  {\n    int bs = _mm256_set_pd(y0s2 + (sgsub * (k + 3)), y0s2 + (sgsub * (k + 2)), y0s2 + (sgsub * (k + 1)), y0s2 + (sgsub * (k + 0)));\n    color256(as, bs, (pixels + (j * 800)) + k);\n  }\n\n}\n\nstatic void color256(const int a0s, const int b0s, uint32_t * const out)\n{\n  int as = a0s;\n  int bs = b0s;\n  int cs = _ITERi;\n  int asqr = _mm256_mul_pd(as, as);\n  int bsqr = _mm256_mul_pd(bs, bs);\n  for (uint64_t i = 0; i < 350; i++)\n  {\n    const int mask4 = _mm256_castpd_si256(_mm256_cmp_pd(_mm256_add_pd(asqr, bsqr), _4d, _CMP_GT_OQ));\n    const int maskITER = _mm256_cmpeq_epi64(cs, _ITERi);\n    const int mask = _mm256_and_si256(maskITER, mask4);\n    const int newcs = _mm256_set1_epi64x(i);\n    cs = _mm256_blendv_epi8(cs, newcs, mask);\n    if (_mm256_testz_si256(maskITER, maskITER))\n      break;\n\n    bs = _mm256_mul_pd(as, bs);\n    bs = _mm256_add_pd(_mm256_add_pd(bs, bs), b0s);\n    as = _mm256_add_pd(_mm256_sub_pd(asqr, bsqr), a0s);\n    asqr = _mm256_mul_pd(as, as);\n    bsqr = _mm256_mul_pd(bs, bs);\n  }\n\n  cs = _mm256_castpd_si256(_mm256_mul_pd(_mm256_castsi256_pd(cs), _mm256_set1_pd(ITERATIONS_TO_COLOR)));\n  cs = _mm256_add_epi64(cs, _mm256_add_epi64(_mm256_sllv_epi64(cs, _7i), _mm256_sllv_epi64(cs, _16i)));\n  out[0] = _mm256_extract_epi64(cs, 0);\n  out[1] = _mm256_extract_epi64(cs, 1);\n  out[2] = _mm256_extract_epi64(cs, 2);\n  out[3] = _mm256_extract_epi64(cs, 3);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (uint64_t i = 0; i < 350; i++)\n{\n  const int mask4 = _mm256_castpd_si256(_mm256_cmp_pd(_mm256_add_pd(asqr, bsqr), _4d, _CMP_GT_OQ));\n  const int maskITER = _mm256_cmpeq_epi64(cs, _ITERi);\n  const int mask = _mm256_and_si256(maskITER, mask4);\n  const int newcs = _mm256_set1_epi64x(i);\n  cs = _mm256_blendv_epi8(cs, newcs, mask);\n  if (_mm256_testz_si256(maskITER, maskITER))\n    break;\n\n  bs = _mm256_mul_pd(as, bs);\n  bs = _mm256_add_pd(_mm256_add_pd(bs, bs), b0s);\n  as = _mm256_add_pd(_mm256_sub_pd(asqr, bsqr), a0s);\n  asqr = _mm256_mul_pd(as, as);\n  bsqr = _mm256_mul_pd(bs, bs);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < strlen(seq1); i++)\n{\n  if ((seq1[i] >= 'a') && (seq1[i] <= 'z'))\n    seq1[i] = toupper(seq1[i]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < num_of_seq2; i++)\n{\n  buffer = (char *) malloc(2000 * (sizeof(char)));\n  fscanf(stdin, \"%s\", buffer);\n  for (j = 0; j < strlen(buffer); j++)\n  {\n    if ((buffer[j] >= 'a') && (buffer[j] <= 'z'))\n      buffer[j] = toupper(buffer[j]);\n\n  }\n\n  strcpy(seq2_all + (2000 * i), buffer);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 27; i++)\n{\n  for (j = 0; j < 27; j++)\n  {\n    mat[i + (size * j)] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < strlen(group[i]); j++)\n  {\n    c1 = group[i][j];\n    for (k = 0; k < strlen(group[i]); k++)\n    {\n      c2 = group[i][k];\n      mat[((c1 - 'A') + 1) + (27 * ((c2 - 'A') + 1))] = 1;\n      mat[((c2 - 'A') + 1) + (27 * ((c1 - 'A') + 1))] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (num_of_seq2 - remain_size); i++)\n{\n  printf(\"#%d: score: %d, n: %d, k: %d\\n\", i, arr_score[i], arr_offset[i], arr_mutant[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < remain_size; i++)\n{\n  if (strlen((seq2_all + ((num_procs * num_rows_each_proc) * 2000)) + (2000 * i)) > 0)\n    printf(\"#%d: score: %d, n: %d, k: %d\\n\", i + (num_procs * num_rows_each_proc), local_remain_score[i], local_remain_offset[i], local_remain_mutant[i]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += T[i];\n  me = omp_get_thread_num();\n  printf(\"Thread number %d: %d\", me, sum);\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  int rootIndex = (i * N) / n;\n  for (int j = 1; j < (N / n); j++)\n  {\n    T[rootIndex] += T[rootIndex + j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += T[i];\n}\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"%d \", T[i]);\n}\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n{\n  T[i] = i;\n}\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int nbSteps = 0; nbSteps < log2(N); nbSteps++)\n{\n  distToNext = pow((float) 2, nbSteps);\n  for (int i = 0; i < N; i += (int) pow(2, nbSteps + 1))\n  {\n    T[i] += T[i + distToNext];\n    int me = omp_get_thread_num();\n    printf(\"Thread number %d\", me);\n  }\n\n  printf(\"T after step %d: \", nbSteps);\n  printTab(T);\n  printf(\"\\n\");\n}\n\nvoid printTab(int *T)\n{\n  for (int i = 0; i < N; i++)\n  {\n    printf(\"%d \", T[i]);\n  }\n\n  printf(\"\\n\");\n}\n\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += T[i * (N / n)];\n}\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int k = 0; k < NB_WORDS; k++)\n{\n  char *c = array[k];\n  for (int i = 0; i < (sizeof(c)); i++)\n  {\n    for (int j = 0; j < 26; j++)\n    {\n      if (c[i] == alphanum[j])\n      {\n        count[j]++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 26; i++)\n{\n  sum += count[i];\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < len; ++i)\n{\n  s[i] = alphanum[rand() % ((sizeof(alphanum)) - 1)];\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_WORDS; i++)\n{\n  printf(\"%s\\n\", array[i]);\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 26; i++)\n{\n  printf(\"%d \", count[i]);\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 26; i++)\n{\n  count[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < (sizeof(c)); i++)\n{\n  for (int j = 0; j < 26; j++)\n  {\n    if (c[i] == alphanum[j])\n    {\n      count[j]++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 26; i++)\n{\n  count[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_WORDS; i++)\n{\n  int strSize = 1 + (rand() % STRING_MAX_SIZE);\n  array[i] = (char *) malloc(strSize * (sizeof(char)));\n  gen_random(array[i], strSize);\n}\n\nvoid gen_random(char *s, int len)\n{\n  static const char alphanum[] = \"abcdefghijklmnopqrstuvwxyz\";\n  for (int i = 0; i < len; ++i)\n  {\n    s[i] = alphanum[rand() % ((sizeof(alphanum)) - 1)];\n  }\n\n  s[len] = 0;\n}\n\n\n", "pragma": "omp parallel for shared(count) reduction(+: sum)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  if (cars[i].place == 2)\n  {\n    place2Cars[i] = 1;\n  }\n\n  if (cars[i].speed == 0)\n  {\n    stoppedCars[i] = 1;\n  }\n\n  if ((place2Cars[i] == 1) && (stoppedCars[i] == 1))\n  {\n    merged[i] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  stoppedCars[i] = (place2Cars[i] = (merged[i] = 0));\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  printf(\"Car #%d --- speed: %d, place: %d\\n\", cars[i].id, cars[i].speed, cars[i].place);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  printf(\"%d \", stoppedCars[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  printf(\"%d \", place2Cars[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  printf(\"%d \", merged[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  initCar(&cars[i], i);\n}\n\nvoid initCar(struct Car *c, int n)\n{\n  c->id = n;\n  c->speed = rand() % MAX_SPEED;\n  c->place = rand() % NB_PLACES;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (current_throw = 0; current_throw < total_throws; current_throw++)\n{\n  x_pos = ((((double) rand()) / 32767) * 2.0) - 1.0;\n  y_pos = ((((double) rand()) / 32767) * 2.0) - 1.0;\n  sum_of_squares = (x_pos * x_pos) + (y_pos * y_pos);\n  if (sum_of_squares <= 1)\n    throws_in_circle++;\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(total_throws) private(x_pos,y_pos, sum_of_squares,current_throw) reduction(+ : throws_in_circle)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (current_throw = 0; current_throw < total_throws; current_throw++)\n{\n  x_pos = ((((double) rand()) / 32767) * 2.0) - 1.0;\n  y_pos = ((((double) rand()) / 32767) * 2.0) - 1.0;\n  sum_of_squares = (x_pos * x_pos) + (y_pos * y_pos);\n  if (sum_of_squares <= 1)\n    throws_in_circle++;\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(total_throws) private(x_pos,y_pos, sum_of_squares,current_throw) reduction(+ : throws_in_circle)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 1; i <= (n - 1); i++)\n{\n  res += f(a + (i * h));\n}\n\ndouble f(double x)\n{\n  return x * x;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: res)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 1; i <= (n - 1); i++)\n{\n  res += f(a + (i * h));\n}\n\ndouble f(double x)\n{\n  return x * x;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: res)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 2; i < n; i++)\n  fibo[i] = fibo[i - 1] + fibo[i - 2];\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 2; i < n; i++)\n{\n  t = f2;\n  f2 = f1 + f2;\n  f1 = t;\n  printf(\"%lld \", f2);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 2; i < n; i++)\n  fibo[i] = fibo[i - 1] + fibo[i - 2];\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%lld \", fibo[i]);\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%lld \", fibo[i]);\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  factor = ((i % 2) == 0) ? (1.0) : (-1.0);\n  sum += factor / ((2 * i) + 1);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(n) private(factor, i) reduction(+ : sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 1; i < n; i += 2)\n  if (a[i - 1] > a[i])\n{\n  temp = a[i];\n  a[i] = a[i - 1];\n  a[i - 1] = temp;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(a, n) private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < (n - 1); i += 2)\n  if (a[i] > a[i + 1])\n{\n  temp = a[i];\n  a[i] = a[i + 1];\n  a[i + 1] = temp;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(a, n) private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n  a[i] = rand() % RMAX;\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(a, n) private(i, temp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%2d \", a[i]);\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(a, n) private(i, temp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%2d \", a[i]);\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(a, n) private(i, temp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += f(i);\n}\n\ndouble f(int i)\n{\n  int start = (i * (i + 1)) / 2;\n  int finish = start + i;\n  double return_val = 0.0;\n  for (int j = start; j <= finish; j++)\n  {\n    return_val += sin(j);\n  }\n\n  return return_val;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+ : sum) schedule(guided)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int j = start; j <= finish; j++)\n{\n  return_val += sin(j);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+ : sum) schedule(guided)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (video[i][j][k] < seuil)\n        videoseuil[i][j][k] = 0;\n      else\n        videoseuil[i][j][k] = 1;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < 1080; j++)\n{\n  for (k = 0; k < 1080; k++)\n  {\n    if (videoseuil[i][j][k] != videoseuilOld[j][k])\n      videoDiff[i][j][k] = 1;\n    else\n      videoDiff[i][j][k] = 0;\n\n    videoseuilOld[j][k] = videoseuil[i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (k == 0)\n      {\n        if ((videoDiff[i][j][1] == 1) && (videoDiff[i][j][0] == 1))\n          videoDiffErod[i][j][k] = 1;\n        else\n          videoDiffErod[i][j][k] = 0;\n\n      }\n      else\n        if (k == (1080 - 1))\n      {\n        if ((videoDiff[i][j][1080 - 1] == 1) && (videoDiff[i][j][1080 - 2] == 1))\n          videoDiffErod[i][j][1080 - 1] = 1;\n        else\n          videoDiffErod[i][j][1080 - 1] = 0;\n\n      }\n      else\n        if (((videoDiff[i][j][k - 1] == 1) && (videoDiff[i][j][k] == 1)) && (videoDiff[i][j][k + 1] == 1))\n        videoDiffErod[i][j][k] = 1;\n      else\n        videoDiffErod[i][j][k] = 0;\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    zoneDetect = 0;\n    for (k = 0; k < 1080; k++)\n    {\n      if (!zoneDetect)\n        if (videoDiffErod[i][j][k] == 1)\n      {\n        videoSil[i][j][k] = 1;\n        zoneDetect = 1;\n      }\n      else\n      {\n        videoSil[i][j][k] = 0;\n      }\n\n      else\n      {\n        if (videoDiffErod[i][j][k] == 0)\n        {\n          videoSil[i][j][k] = 1;\n          zoneDetect = 0;\n        }\n        else\n        {\n          videoSil[i][j][k] = 0;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k,zoneDetect)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < numel[0]; ++i)\n{\n  T3_eig(&H11_in[idx[i]], &H12_in[idx[i]], &H13_in[idx[i]], &H22_in[idx[i]], &H23_in[idx[i]], &H33_in[idx[i]], &El1[idx[i]], &El2[idx[i]], &El3[idx[i]], &Ev11[idx[i]], &Ev12[idx[i]], &Ev13[idx[i]], &Ev21[idx[i]], &Ev22[idx[i]], &Ev23[idx[i]], &Ev31[idx[i]], &Ev32[idx[i]], &Ev33[idx[i]]);\n  regOrthog(&Ev11[idx[i]], &Ev12[idx[i]], &Ev13[idx[i]], &Ev21[idx[i]], &Ev22[idx[i]], &Ev23[idx[i]], &Ev31[idx[i]], &Ev32[idx[i]], &Ev33[idx[i]]);\n  if ((((((((((((!((!rtIsInfF(El1[idx[i]])) && (!rtIsNaNF(El1[idx[i]])))) || (!((!rtIsInfF(El2[idx[i]])) && (!rtIsNaNF(El2[idx[i]]))))) || (!((!rtIsInfF(El3[idx[i]])) && (!rtIsNaNF(El3[idx[i]]))))) || (!((!rtIsInfF(Ev11[idx[i]])) && (!rtIsNaNF(Ev11[idx[i]]))))) || (!((!rtIsInfF(Ev12[idx[i]])) && (!rtIsNaNF(Ev12[idx[i]]))))) || (!((!rtIsInfF(Ev13[idx[i]])) && (!rtIsNaNF(Ev13[idx[i]]))))) || (!((!rtIsInfF(Ev21[idx[i]])) && (!rtIsNaNF(Ev21[idx[i]]))))) || (!((!rtIsInfF(Ev22[idx[i]])) && (!rtIsNaNF(Ev22[idx[i]]))))) || (!((!rtIsInfF(Ev23[idx[i]])) && (!rtIsNaNF(Ev23[idx[i]]))))) || (!((!rtIsInfF(Ev31[idx[i]])) && (!rtIsNaNF(Ev31[idx[i]]))))) || (!((!rtIsInfF(Ev32[idx[i]])) && (!rtIsNaNF(Ev32[idx[i]]))))) || (!((!rtIsInfF(Ev33[idx[i]])) && (!rtIsNaNF(Ev33[idx[i]])))))\n  {\n    El1[idx[i]] = 1.0F;\n    El2[idx[i]] = 1.0F;\n    El3[idx[i]] = 1.0F;\n    Ev11[idx[i]] = 1.0F;\n    Ev12[idx[i]] = 0.0F;\n    Ev13[idx[i]] = 0.0F;\n    Ev21[idx[i]] = 0.0F;\n    Ev22[idx[i]] = 1.0F;\n    Ev23[idx[i]] = 0.0F;\n    Ev31[idx[i]] = 0.0F;\n    Ev32[idx[i]] = 0.0F;\n    Ev33[idx[i]] = 1.0F;\n    mskValid[idx[i]] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j1 = 0; j1 < N; j1++)\n  v3[i] += m1[i][j1] * v2[j1];\n\n", "pragma": "omp parallel for reduction(+:v3[i])", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = start; i < (start + split_length); i++)\n  compare(i, i + split_length, direction);\n\nvoid compare(int i, int j, int direction)\n{\n  if ((arr[i] > arr[j]) == direction)\n  {\n    swap(&arr[i], &arr[j]);\n  }\n\n}\n\n\n", "pragma": "omp parallel for reduction(+:v3[i])", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < lin_c; i++)\n  for (j = 0; j < col_c; j++)\n{\n  C[(i * col_c) + j] = 0;\n  for (k = 0; k < col_a; k++)\n    C[(i * col_c) + j] = C[(i * col_c) + j] + (A[(i * col_a) + k] * B[(k * col_b) + j]);\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic) firstprivate(A,B) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (lin_a * col_a); i++)\n  A[i] = ((float) rand()) / ((float) 32767);\n\n", "pragma": "omp parallel for schedule(dynamic) firstprivate(A,B) private(i,j,k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (lin_b * col_b); i++)\n  B[i] = ((float) rand()) / ((float) 32767);\n\n", "pragma": "omp parallel for schedule(dynamic) firstprivate(A,B) private(i,j,k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  res[omp_get_thread_num() * 8] += x[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  t[omp_get_thread_num()] += x[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  y += x[i];\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = value;\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"%f \", a[i]);\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  y += x[i];\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (8 * 4); i += 4)\n{\n  y += res[i];\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 4; i++)\n{\n  y += t[i];\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int threadn = 0; threadn < 16; threadn++)\n{\n  int thread_row = threadn / sqrt_num_threads;\n  int thread_col = threadn % sqrt_num_threads;\n  struct Coord myThreadCoord = {thread_row, thread_col};\n  struct Coord blockPointerA;\n  blockPointerA.row = myThreadCoord.row;\n  blockPointerA.col = (myThreadCoord.col + myThreadCoord.row) % sqrt_num_threads;\n  struct Coord blockPointerB;\n  blockPointerB.row = (myThreadCoord.row + myThreadCoord.col) % sqrt_num_threads;\n  blockPointerB.col = myThreadCoord.col;\n  int i;\n  int j;\n  int k;\n  int l;\n  int crBegin = (myThreadCoord.row * LOCAL_ROWS) * ARRAY_COLS;\n  int ccBegin = myThreadCoord.col * LOCAL_COLS;\n  for (l = 0; l < sqrt_num_threads; l++)\n  {\n    int arBegin = (blockPointerA.row * LOCAL_ROWS) * ARRAY_COLS;\n    int acBegin = blockPointerA.col * LOCAL_COLS;\n    int brBegin = (blockPointerB.row * LOCAL_ROWS) * ARRAY_COLS;\n    int bcBegin = blockPointerB.col * LOCAL_COLS;\n    for (i = 0; i < LOCAL_ROWS; i++)\n    {\n      for (j = 0; j < LOCAL_COLS; j++)\n      {\n        double comp = 0;\n        for (k = 0; k < LOCAL_COLS; k++)\n        {\n          comp += (*((((a + arBegin) + acBegin) + (i * ARRAY_COLS)) + k)) * (*((((b + brBegin) + bcBegin) + (k * ARRAY_COLS)) + j));\n        }\n\n        *((((c + crBegin) + ccBegin) + (i * ARRAY_COLS)) + j) += comp;\n      }\n\n    }\n\n    blockPointerA.col = (blockPointerA.col + 1) % sqrt_num_threads;\n    blockPointerB.row = (blockPointerB.row + 1) % sqrt_num_threads;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a, b, c)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    printf(\"%.2f \", *((a + (i * cols)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for shared(a, b, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int r = 0; r < rows; r++)\n{\n  for (int c = 0; c < cols; c++)\n  {\n    int initialVal = (zero) ? ((r * cols) + c) : (0);\n    *((arr + (r * cols)) + c) = (double) initialVal;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a, b, c)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"omp par for -- i: %d, thread num: %d, nthreads: %d\\n\", i, omp_get_thread_num(), omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"for after par -- i: %d, thread num: %d, nthreads: %d\\n\", i, omp_get_thread_num(), omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"omp for in par -- i: %d, thread num: %d, nthreads: %d\\n\", i, omp_get_thread_num(), omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(static, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  wA[i] = ((rand() % 2) * i) / (n / 10);\n}\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i += 50)\n{\n  printf(\"w[%d] = %d, thread_num: %d\\n\", i, w[i], omp_get_thread_num());\n  doWork(w[i]);\n}\n\nvoid doWork(int t)\n{\n  usleep(t * 100000);\n}\n\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (16 / 2); i++)\n{\n  free(queues[i]);\n  free(hash_tables[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  int files = get_file_list(file_name_queue, files_dir);\n  if (files == (-1))\n  {\n    printf(\"Check input directory and rerun! Exiting!\\n\");\n    return 1;\n  }\n\n  file_count += files;\n}\n\nint get_file_list(struct Queue *file_name_queue, char *dirpath)\n{\n  DIR * dir;\n  struct dirent *in_file;\n  char dirname[50];\n  char directory_seperator[2] = \"/\\0\";\n  strcpy(dirname, dirpath);\n  int file_count = 0;\n  if ((dir = opendir(dirname)) == 0)\n  {\n    fprintf(stderr, \"Error : Failed to open input directory - %s\\n\", strerror(errno));\n    return -1;\n  }\n\n  while (in_file = readdir(dir))\n  {\n    if ((((!strcmp(in_file->d_name, \".\")) || (!strcmp(in_file->d_name, \"..\"))) || (!strcmp(in_file->d_name, \"./\"))) || (!strcmp(in_file->d_name, \"../\")))\n      continue;\n\n    char *file_name = (char *) malloc(((sizeof(char)) * 50) * 3);\n    strcpy(file_name, dirname);\n    strcat(file_name, directory_seperator);\n    strcat(file_name, in_file->d_name);\n    if (DEBUG_MODE)\n      printf(\"Queing file: %s\\n\", file_name);\n\n    {\n      enQueue(file_name_queue, file_name, strlen(file_name));\n      file_count++;\n    }\n  }\n\n  if (DEBUG_MODE)\n    printf(\"Done Queing all files\\n\\n\");\n\n  closedir(dir);\n  return file_count;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < (16 / 2); i++)\n{\n  omp_init_lock(&queuelock[i]);\n  queues[i] = createQueue();\n}\n\nstruct Queue *createQueue()\n{\n  struct Queue *q = (struct Queue *) malloc(sizeof(struct Queue));\n  q->front = (q->rear = 0);\n  q->finished = 0;\n  return q;\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int k = 0; k < (16 / 2); k++)\n{\n  omp_destroy_lock(&queuelock[k]);\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = start; i < end; i++)\n{\n  reduce(hash_tables, final_table, 16 / 2, i);\n}\n\nvoid reduce(struct hashtable **hash_tables, struct hashtable *final_table, int num_hashtables, int location)\n{\n  struct node *node = 0;\n  for (int i = 0; i < num_hashtables; i++)\n  {\n    if ((hash_tables[i] == 0) || (hash_tables[i]->table[location] == 0))\n    {\n      continue;\n    }\n\n    struct node *current = hash_tables[i]->table[location];\n    if (current == 0)\n      continue;\n\n    while (current != 0)\n    {\n      node = add(final_table, current->key, 0);\n      node->frequency += current->frequency;\n      current = current->next;\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i1 = 0; i1 < 16; ++i1)\n  for (int i2 = 0; i2 < 16; ++i2)\n  for (int i3 = 0; i3 < 16; ++i3)\n  for (int i4 = 0; i4 < 16; ++i4)\n  foo();\n\n\n\n\n", "pragma": "omp target parallel for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(4 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(4, , 4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(4, 8)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(2.5)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(foo())", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  for (int j = 0; j < 16; ++j)\n{\n  for (int k = 0; k < 16; ++k)\n    i += j;\n\n}\n\n\n", "pragma": "omp target parallel for collapse(-5)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(0)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(5 - 5)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for collapse(2) firstprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(,", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(, )", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private()", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(int)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n{\n  x = (y * i) + z;\n}\n\n", "pragma": "omp target parallel for private(0)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(x, y)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for private(x, y, z)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for lastprivate(", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for lastprivate(,", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for lastprivate(, )", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for lastprivate()", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for lastprivate(int)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for simd collapse(4, )", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp target parallel for simd collapse(4, )", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= (grid_rows - 1); i += 1)\n{\n  for (j = 0; j <= (grid_cols - 1); j += 1)\n  {\n    for (k = 0; k <= (layers - 1); k += 1)\n    {\n      sprintf(str, \"%d\\t%g\\n\", index, vect[((i * grid_cols) + j) + ((k * grid_rows) * grid_cols)]);\n      fputs(str, fp);\n      index++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp target parallel for simd collapse(4, )", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (z = 0; z <= (nz - 1); z += 1)\n{\n  for (y = 0; y <= (ny - 1); y += 1)\n  {\n    for (x = 0; x <= (nx - 1); x += 1)\n    {\n      c = (x + (y * nx)) + ((z * nx) * ny);\n      w = (x == 0) ? (c) : (c - 1);\n      e = (x == (nx - 1)) ? (c) : (c + 1);\n      n = (y == 0) ? (c) : (c - nx);\n      s = (y == (ny - 1)) ? (c) : (c + nx);\n      b = (z == 0) ? (c) : (c - (nx * ny));\n      t = (z == (nz - 1)) ? (c) : (c + (nx * ny));\n      tOut[c] = ((((((((tIn[c] * cc) + (tIn[n] * cn)) + (tIn[s] * cs)) + (tIn[e] * ce)) + (tIn[w] * cw)) + (tIn[t] * ct)) + (tIn[b] * cb)) + ((dt / Cap) * pIn[c])) + (ct * amb_temp);\n    }\n\n  }\n\n}\n\n", "pragma": "omp target parallel for simd collapse(4, )", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (z = 0; z <= (nz - 1); z += 1)\n{\n  int y;\n  for (y = 0; y <= (ny - 1); y += 1)\n  {\n    int x;\n    for (x = 0; x <= (nx - 1); x += 1)\n    {\n      int c;\n      int w;\n      int e;\n      int n;\n      int s;\n      int b;\n      int t;\n      c = (x + (y * nx)) + ((z * nx) * ny);\n      w = (x == 0) ? (c) : (c - 1);\n      e = (x == (nx - 1)) ? (c) : (c + 1);\n      n = (y == 0) ? (c) : (c - nx);\n      s = (y == (ny - 1)) ? (c) : (c + nx);\n      b = (z == 0) ? (c) : (c - (nx * ny));\n      t = (z == (nz - 1)) ? (c) : (c + (nx * ny));\n      tOut_t[c] = ((((((((cc * tIn_t[c]) + (cw * tIn_t[w])) + (ce * tIn_t[e])) + (cs * tIn_t[s])) + (cn * tIn_t[n])) + (cb * tIn_t[b])) + (ct * tIn_t[t])) + ((dt / Cap) * pIn[c])) + (ct * amb_temp);\n    }\n\n  }\n\n}\n\n", "pragma": "omp target parallel for simd collapse(4, )", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i] = a[i + 1] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i] = a[i + 1] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = b + (a[i] * 5);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    a[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < len; j += 1)\n{\n  a[i][j] += a[i + 1][j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    a[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < len; j += 1)\n{\n  a[i][j] += a[i + 1][j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 180; ++i)\n{\n  int idx = indexSet[i];\n  xa1[idx] += 1.0 + i;\n  xa2[idx] += 3.0 + i;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 180; ++i)\n{\n  int idx = indexSet[i];\n  xa1[idx] += 1.0;\n  xa2[idx] += 3.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 180; ++i)\n{\n  int idx = indexSet[i];\n  xa1[idx] += 1.0;\n  xa2[idx] += 3.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 180; ++i)\n{\n  int idx = indexSet[i];\n  xa1[idx] += 1.0;\n  xa2[idx] += 3.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 180; ++i)\n{\n  int idx = indexSet[i];\n  xa1[idx] += 1.0;\n  xa2[idx] += 3.0;\n}\n\n", "pragma": "omp parallel for", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  x = i;\n}\n\n", "pragma": "omp parallel for private(i) lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  x = i;\n}\n\n", "pragma": "omp parallel for private(i) lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  if ((i % 2) == 0)\n  {\n    x[i] = 5;\n  }\n  else\n  {\n    x[i] = -5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = numNodes - 1; i > (-1); --i)\n{\n  if (x[i] <= 0)\n  {\n    numNodes2--;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(+: numNodes2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  if ((i % 2) == 0)\n  {\n    x[i] = 5;\n  }\n  else\n  {\n    x[i] = -5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = numNodes - 1; i > (-1); --i)\n{\n  if (x[i] <= 0)\n  {\n    numNodes2--;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(+: numNodes2)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = b + (a[i] * 5);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < inLen; ++i)\n{\n  input[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < inLen; ++i)\n{\n  output[outLen++] = input[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < inLen; ++i)\n{\n  input[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < inLen; ++i)\n{\n  output[outLen++] = input[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for private(i, tmp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for private(i, tmp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    u[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j, temp)\n  #pragma loop name main#1#0\n  #pragma cetus reduction(+: sum)\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    temp = u[i][j];\n    sum = sum + (temp * temp);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, temp) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    u[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j, temp)\n  #pragma loop name main#1#0\n  #pragma cetus reduction(+: sum)\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    temp = u[i][j];\n    sum = sum + (temp * temp);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, temp) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n  b[i] = i + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  distanceA = a[i] - meanA;\n  distanceB = b[i] - meanB;\n  squareDistanceA += distanceA * distanceA;\n  squareDistanceB += distanceB * distanceB;\n  productOfDifferences += distanceA * distanceB;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i + 1] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"i=%d a[%d]=%d\\n\", i, i, a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n  b[i] = i + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i + 1] = a[i] * b[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"i=%d a[%d]=%d\\n\", i, i, a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i] = a[i + 1] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for private(i, tmp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i + 1] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len - 1); i++)\n{\n  a[i + 1] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < m; j++)\n  {\n    b[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 1; j < m; j++)\n{\n  b[i][j] = b[i - 1][j - 1];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < m; j++)\n  {\n    b[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (j = 1; j < m; j++)\n{\n  b[i][j] = b[i - 1][j - 1];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 2000; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[(2 * i) + 1] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (len / 2); i++)\n{\n  a[(2 * i) + 1] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  fprintf(stderr, \"%0.2lf \", X[i][j]);\n  if ((((i * 500) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (t = 0; t < tmax; t++)\n{\n  double **A = (double **) malloc((sizeof(double *)) * nl);\n  double *x = (double *) malloc((sizeof(double)) * nl);\n  double *temp = (double *) malloc((sizeof(double)) * nl);\n  double *temp2 = (double *) malloc((sizeof(double)) * nl);\n  for (i = 0; i < nl; i++)\n  {\n    A[i] = (double *) malloc((sizeof(double)) * nc);\n    for (j = 0; j < nc; j++)\n    {\n      A[i][j] = rand() % 10;\n    }\n\n    x[i] = rand() % 10;\n    temp[i] = 0;\n    temp2[i] = 0;\n  }\n\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      for (j = 0; j < nc; j++)\n      {\n        printf(\"A%d%d %f\\n\", i, j, A[i][j]);\n      }\n\n    }\n\n    for (i = 0; i < nl; i++)\n    {\n      printf(\"x%d %f\\n\", i, x[i]);\n    }\n\n  }\n\n  debut = omp_get_wtime();\n  ProdMatVect(nc, nl, A, x, temp);\n  SommVectVect(nl, temp, x, &temp2);\n  ProdMatVect(nc, nl, A, temp2, temp);\n  SommVectVect(nl, temp, x, &temp2);\n  fin = omp_get_wtime();\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      printf(\"resulat%d %f\\n\", i, temp2[i]);\n    }\n\n  }\n\n  printf(\"\\ntemps: %3.6f s\\n\", fin - debut);\n  fprintf(fichier, \"\\n%f;%d;%d;\", fin - debut, nl, nc);\n  for (i = 0; i < nl; i++)\n  {\n    free(A[i]);\n  }\n\n  free(A);\n  free(x);\n  free(temp);\n  free(temp2);\n  nc *= 2;\n  nl *= 2;\n}\n\nvoid ProdMatVect(int nc, int nl, double **A, double *x, double *y)\n{\n  int i;\n  int j;\n  double somme;\n  for (i = 0; i < nl; i++)\n  {\n    for (j = 0; j < nc; j++)\n    {\n      somme += A[i][j] * x[j];\n    }\n\n    y[i] = somme;\n  }\n\n}\n\n\nvoid SommVectVect(int n, double *a, double *b, double **c)\n{\n  int i;\n  for (i = 0; i < n; i++)\n  {\n    (*c)[i] = a[i] + b[i];\n  }\n\n}\n\n\nvoid ProdMatVect(int nc, int nl, double **A, double *x, double *y)\n{\n  int i;\n  int j;\n  double somme;\n  for (i = 0; i < nl; i++)\n  {\n    for (j = 0; j < nc; j++)\n    {\n      somme += A[i][j] * x[j];\n    }\n\n    y[i] = somme;\n  }\n\n}\n\n\nvoid SommVectVect(int n, double *a, double *b, double **c)\n{\n  int i;\n  for (i = 0; i < n; i++)\n  {\n    (*c)[i] = a[i] + b[i];\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= nt; i++)\n{\n  err = (sums[i].real - vdata_real_w[i]) / vdata_real_w[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_w[i]) / vdata_imag_w[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      xi = ((double) i) * dnxm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[m][i] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[m][i] = dtpp * dtemp[m];\n      }\n\n      cuf[i] = buf[1][i] * buf[1][i];\n      buf[0][i] = (cuf[i] + (buf[2][i] * buf[2][i])) + (buf[3][i] * buf[3][i]);\n      q[i] = 0.5 * (((buf[1][i] * ue[1][i]) + (buf[2][i] * ue[2][i])) + (buf[3][i] * ue[3][i]));\n    }\n\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      im1 = i - 1;\n      ip1 = i + 1;\n      forcing[0][i][j][k] = (forcing[0][i][j][k] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n      forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n      forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n      forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n      forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = 1;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][i]) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      i = 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][i - 1]) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (i = 3; i <= (grid_points[0] - 4); i++)\n      {\n        forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = grid_points[0] - 3;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])));\n      i = grid_points[0] - 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (5.0 * ue[m][i])));\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      eta = ((double) j) * dnym1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[m][j] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[m][j] = dtpp * dtemp[m];\n      }\n\n      cuf[j] = buf[2][j] * buf[2][j];\n      buf[0][j] = (cuf[j] + (buf[1][j] * buf[1][j])) + (buf[3][j] * buf[3][j]);\n      q[j] = 0.5 * (((buf[1][j] * ue[1][j]) + (buf[2][j] * ue[2][j])) + (buf[3][j] * ue[3][j]));\n    }\n\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      jm1 = j - 1;\n      jp1 = j + 1;\n      forcing[0][i][j][k] = (forcing[0][i][j][k] - (ty2 * (ue[2][jp1] - ue[2][jm1]))) + (dy1ty1 * ((ue[0][jp1] - (2.0 * ue[0][j])) + ue[0][jm1]));\n      forcing[1][i][j][k] = ((forcing[1][i][j][k] - (ty2 * ((ue[1][jp1] * buf[2][jp1]) - (ue[1][jm1] * buf[2][jm1])))) + (yycon2 * ((buf[1][jp1] - (2.0 * buf[1][j])) + buf[1][jm1]))) + (dy2ty1 * ((ue[1][jp1] - (2.0 * ue[1][j])) + ue[1][jm1]));\n      forcing[2][i][j][k] = ((forcing[2][i][j][k] - (ty2 * (((ue[2][jp1] * buf[2][jp1]) + (c2 * (ue[4][jp1] - q[jp1]))) - ((ue[2][jm1] * buf[2][jm1]) + (c2 * (ue[4][jm1] - q[jm1])))))) + (yycon1 * ((buf[2][jp1] - (2.0 * buf[2][j])) + buf[2][jm1]))) + (dy3ty1 * ((ue[2][jp1] - (2.0 * ue[2][j])) + ue[2][jm1]));\n      forcing[3][i][j][k] = ((forcing[3][i][j][k] - (ty2 * ((ue[3][jp1] * buf[2][jp1]) - (ue[3][jm1] * buf[2][jm1])))) + (yycon2 * ((buf[3][jp1] - (2.0 * buf[3][j])) + buf[3][jm1]))) + (dy4ty1 * ((ue[3][jp1] - (2.0 * ue[3][j])) + ue[3][jm1]));\n      forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (ty2 * ((buf[2][jp1] * ((c1 * ue[4][jp1]) - (c2 * q[jp1]))) - (buf[2][jm1] * ((c1 * ue[4][jm1]) - (c2 * q[jm1])))))) + ((0.5 * yycon3) * ((buf[0][jp1] - (2.0 * buf[0][j])) + buf[0][jm1]))) + (yycon4 * ((cuf[jp1] - (2.0 * cuf[j])) + cuf[jm1]))) + (yycon5 * ((buf[4][jp1] - (2.0 * buf[4][j])) + buf[4][jm1]))) + (dy5ty1 * ((ue[4][jp1] - (2.0 * ue[4][j])) + ue[4][jm1]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = 1;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][j]) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n      j = 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][j - 1]) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (j = 3; j <= (grid_points[1] - 4); j++)\n      {\n        forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = grid_points[1] - 3;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])));\n      j = grid_points[1] - 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (5.0 * ue[m][j])));\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  eta = ((double) j) * dnym1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[m][k] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[m][k] = dtpp * dtemp[m];\n      }\n\n      cuf[k] = buf[3][k] * buf[3][k];\n      buf[0][k] = (cuf[k] + (buf[1][k] * buf[1][k])) + (buf[2][k] * buf[2][k]);\n      q[k] = 0.5 * (((buf[1][k] * ue[1][k]) + (buf[2][k] * ue[2][k])) + (buf[3][k] * ue[3][k]));\n    }\n\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      km1 = k - 1;\n      kp1 = k + 1;\n      forcing[0][i][j][k] = (forcing[0][i][j][k] - (tz2 * (ue[3][kp1] - ue[3][km1]))) + (dz1tz1 * ((ue[0][kp1] - (2.0 * ue[0][k])) + ue[0][km1]));\n      forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tz2 * ((ue[1][kp1] * buf[3][kp1]) - (ue[1][km1] * buf[3][km1])))) + (zzcon2 * ((buf[1][kp1] - (2.0 * buf[1][k])) + buf[1][km1]))) + (dz2tz1 * ((ue[1][kp1] - (2.0 * ue[1][k])) + ue[1][km1]));\n      forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tz2 * ((ue[2][kp1] * buf[3][kp1]) - (ue[2][km1] * buf[3][km1])))) + (zzcon2 * ((buf[2][kp1] - (2.0 * buf[2][k])) + buf[2][km1]))) + (dz3tz1 * ((ue[2][kp1] - (2.0 * ue[2][k])) + ue[2][km1]));\n      forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tz2 * (((ue[3][kp1] * buf[3][kp1]) + (c2 * (ue[4][kp1] - q[kp1]))) - ((ue[3][km1] * buf[3][km1]) + (c2 * (ue[4][km1] - q[km1])))))) + (zzcon1 * ((buf[3][kp1] - (2.0 * buf[3][k])) + buf[3][km1]))) + (dz4tz1 * ((ue[3][kp1] - (2.0 * ue[3][k])) + ue[3][km1]));\n      forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tz2 * ((buf[3][kp1] * ((c1 * ue[4][kp1]) - (c2 * q[kp1]))) - (buf[3][km1] * ((c1 * ue[4][km1]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[0][kp1] - (2.0 * buf[0][k])) + buf[0][km1]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[4][kp1] - (2.0 * buf[4][k])) + buf[4][km1]))) + (dz5tz1 * ((ue[4][kp1] - (2.0 * ue[4][k])) + ue[4][km1]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = 1;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][k]) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n      k = 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][k - 1]) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (k = 3; k <= (grid_points[2] - 4); k++)\n      {\n        forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][k - 2] - (4.0 * ue[m][k - 1])) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = grid_points[2] - 3;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((ue[m][k - 2] - (4.0 * ue[m][k - 1])) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])));\n      k = grid_points[2] - 2;\n      forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((ue[m][k - 2] - (4.0 * ue[m][k - 1])) + (5.0 * ue[m][k])));\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        forcing[m][i][j][k] = (-1.0) * forcing[m][i][j][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (m = 0; m < 5; m++)\n{\n  dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= (PROBLEM_SIZE - 1); i++)\n{\n  for (j = 0; j <= (PROBLEM_SIZE - 1); j++)\n  {\n    for (k = 0; k <= (PROBLEM_SIZE - 1); k++)\n    {\n      u[0][i][j][k] = 1.0;\n      u[1][i][j][k] = 0.0;\n      u[2][i][j][k] = 0.0;\n      u[3][i][j][k] = 0.0;\n      u[4][i][j][k] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      for (ix = 0; ix < 2; ix++)\n      {\n        exact_solution((double) ix, eta, zeta, &Pface[ix][0][0]);\n      }\n\n      for (iy = 0; iy < 2; iy++)\n      {\n        exact_solution(xi, (double) iy, zeta, &Pface[iy][1][0]);\n      }\n\n      for (iz = 0; iz < 2; iz++)\n      {\n        exact_solution(xi, eta, (double) iz, &Pface[iz][2][0]);\n      }\n\n      for (m = 0; m < 5; m++)\n      {\n        Pxi = (xi * Pface[1][0][m]) + ((1.0 - xi) * Pface[0][0][m]);\n        Peta = (eta * Pface[1][1][m]) + ((1.0 - eta) * Pface[0][1][m]);\n        Pzeta = (zeta * Pface[1][2][m]) + ((1.0 - zeta) * Pface[0][2][m]);\n        u[m][i][j][k] = (((((Pxi + Peta) + Pzeta) - (Pxi * Peta)) - (Pxi * Pzeta)) - (Peta * Pzeta)) + ((Pxi * Peta) * Pzeta);\n      }\n\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  eta = ((double) j) * dnym1;\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    zeta = ((double) k) * dnzm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  eta = ((double) j) * dnym1;\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    zeta = ((double) k) * dnzm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    zeta = ((double) k) * dnzm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    zeta = ((double) k) * dnzm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    eta = ((double) j) * dnym1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    eta = ((double) j) * dnym1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[m][i][j][k] = temp[m];\n    }\n\n  }\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta, double dtemp[5])\n{\n  int m;\n  for (m = 0; m < 5; m++)\n  {\n    dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (n = 0; n < 15; n++)\n{\n  for (i = 0; i < grid_points[0]; i++)\n  {\n    for (j = 0; j < grid_points[1]; j++)\n    {\n      for (k = 0; k < grid_points[2]; k++)\n      {\n        lhs[n][i][j][k] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (isize = 0; isize < REFINE_MAX; isize++)\n{\n  temp = pow(2.0, (-isize) - 2);\n  dtemp = 1.0 / temp;\n  temp1 = (temp * temp) * temp;\n  temp2 = temp * temp;\n  for (k = 0; k < 5; k++)\n  {\n    for (j = 0; j < 5; j++)\n    {\n      for (i = 0; i < 5; i++)\n      {\n        xrm1_s[isize][k][j][i] = dtemp;\n        jacm1_s[isize][k][j][i] = temp1;\n        rxm1_s[isize][k][j][i] = temp2;\n        g1m1_s[isize][k][j][i] = w3m1[k][j][i] * temp;\n        bm1_s[isize][k][j][i] = w3m1[k][j][i] * temp1;\n        g4m1_s[isize][k][j][i] = g1m1_s[isize][k][j][i] / wxm1[i];\n        g5m1_s[isize][k][j][i] = g1m1_s[isize][k][j][i] / wxm1[j];\n        g6m1_s[isize][k][j][i] = g1m1_s[isize][k][j][i] / wxm1[k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(isize,temp,temp1,temp2, k,j,i,dtemp)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (x = 0; x < ((512 * 512) * 128); x++)\n{\n  input_array[x] = x % 2048;\n}\n\n", "pragma": "omp parallel for default(shared) private(isize,temp,temp1,temp2, k,j,i,dtemp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (y = 0; y < 1024; y++)\n{\n  filter_list[y] = y;\n}\n\n", "pragma": "omp parallel for default(shared) private(isize,temp,temp1,temp2, k,j,i,dtemp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int n_thread = 1; n_thread <= 16; n_thread *= 2)\n{\n  omp_set_num_threads(n_thread);\n  parallelFilterFirst((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelDataFirst((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n}\n\nvoid parallelFilterFirst(int data_len, unsigned int *input_array, unsigned int *output_array, int filter_len, unsigned int *filter_list)\n{\n  struct timeval ta;\n  struct timeval tb;\n  struct timeval tresult;\n  gettimeofday(&ta, 0);\n  for (int y = 0; y < filter_len; y++)\n  {\n    for (int x = 0; x < data_len; x++)\n    {\n      if (input_array[x] == filter_list[y])\n      {\n        output_array[x] = input_array[x];\n      }\n\n    }\n\n  }\n\n  gettimeofday(&tb, 0);\n  timeval_subtract(&tresult, &tb, &ta);\n  printf(\"Parallel filter first took %lu seconds and %lu microseconds.  Filter length = %d\\n\", tresult.tv_sec, tresult.tv_usec, filter_len);\n}\n\n\nvoid checkData(unsigned int *serialarray, unsigned int *parallelarray)\n{\n  for (int i = 0; i < ((512 * 512) * 128); i++)\n  {\n    if (serialarray[i] != parallelarray[i])\n    {\n      printf(\"Data check failed offset %d\\n\", i);\n      return;\n    }\n\n  }\n\n}\n\n\nvoid parallelDataFirst(int data_len, unsigned int *input_array, unsigned int *output_array, int filter_len, unsigned int *filter_list)\n{\n  struct timeval ta;\n  struct timeval tb;\n  struct timeval tresult;\n  gettimeofday(&ta, 0);\n  for (int x = 0; x < data_len; x++)\n  {\n    for (int y = 0; y < filter_len; y++)\n    {\n      if (input_array[x] == filter_list[y])\n      {\n        output_array[x] = input_array[x];\n      }\n\n    }\n\n  }\n\n  gettimeofday(&tb, 0);\n  timeval_subtract(&tresult, &tb, &ta);\n  printf(\"Parallel data first took %lu seconds and %lu microseconds.  Filter length = %d\\n\", tresult.tv_sec, tresult.tv_usec, filter_len);\n}\n\n\nvoid checkData(unsigned int *serialarray, unsigned int *parallelarray)\n{\n  for (int i = 0; i < ((512 * 512) * 128); i++)\n  {\n    if (serialarray[i] != parallelarray[i])\n    {\n      printf(\"Data check failed offset %d\\n\", i);\n      return;\n    }\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for default(shared) private(isize,temp,temp1,temp2, k,j,i,dtemp)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = k + 1; i < N; i++)\n{\n  l = A[i][k] / A[k][k];\n  for (j = k + 1; j < N; j++)\n  {\n    A[i][j] = A[i][j] - (l * A[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,l)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (count = 0; count < N; count++)\n  A[count] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "omp parallel for private(i,l)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (count = 0; count < N; count++)\n{\n  for (i = 0; i < N; i++)\n    A[count][i] = (rand() % 40) + 1;\n\n}\n\n", "pragma": "omp parallel for private(i,l)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = k + 1; i < N; i++)\n{\n  l = A[i][k] / A[k][k];\n  for (j = k + 1; j < N; j++)\n  {\n    A[i][j] = A[i][j] - (l * A[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,l)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (count = 0; count < N; count++)\n  A[count] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "omp parallel for private(i,l)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (count = 0; count < N; count++)\n{\n  for (i = 0; i < N; i++)\n    A[count][i] = (rand() % 40) + 1;\n\n}\n\n", "pragma": "omp parallel for private(i,l)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = k + 1; i < range; i++)\n{\n  mm_lower(l_inv, 0, 0, a, k * B, i * B, a, k * B, i * B, B, B, B);\n  mm_upper(a, i * B, k * B, u_inv, 0, 0, a, i * B, k * B, B, B, B);\n}\n\nvoid mm_lower(double **a1, int x_1, int y_1, double **a2, int x_2, int y_2, double **res, int x_3, int y_3, int M, int N, int P)\n{\n  int i;\n  int j;\n  int k;\n  double sum = 0;\n  for (i = 0; i < M; i++)\n    for (j = 0; j < P; j++)\n  {\n    for (k = 0; k <= i; k++)\n      sum = sum + (a1[i + x_1][k + y_1] * a2[k + x_2][j + y_2]);\n\n    low_res[i][(j + y_3) - P] = sum;\n    sum = 0;\n  }\n\n\n  for (i = 0; i < M; i++)\n    for (j = 0; j < P; j++)\n    res[i + x_3][j + y_3] = low_res[i][(j + y_3) - P];\n\n\n}\n\n\nvoid mm_upper(double **a1, int x_1, int y_1, double **a2, int x_2, int y_2, double **res, int x_3, int y_3, int M, int N, int P)\n{\n  int i;\n  int j;\n  int k;\n  double sum = 0;\n  for (i = 0; i < M; i++)\n    for (j = 0; j < P; j++)\n  {\n    for (k = 0; k <= j; k++)\n      sum = sum + (a1[i + x_1][k + y_1] * a2[k + x_2][j + y_2]);\n\n    up_res[(i + x_3) - M][j] = sum;\n    sum = 0;\n  }\n\n\n  for (i = 0; i < M; i++)\n    for (j = 0; j < P; j++)\n    res[i + x_3][j + y_3] = up_res[(i + x_3) - M][j];\n\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = k + 1; i < range; i++)\n{\n  for (j = k + 1; j < range; j++)\n    mm_update(a, i * B, k * B, a, k * B, j * B, a, i * B, j * B, B, B, B);\n\n}\n\nvoid mm_update(double **a1, int x_1, int y_1, double **a2, int x_2, int y_2, double **res, int x_3, int y_3, int M, int N, int P)\n{\n  int i;\n  int j;\n  int k;\n  double sum = 0;\n  for (i = 0; i < M; i++)\n    for (j = 0; j < P; j++)\n  {\n    for (k = 0; k < N; k++)\n      sum += a1[i + x_1][k + y_1] * a2[k + x_2][j + y_2];\n\n    res[i + x_3][j + y_3] -= sum;\n    sum = 0;\n  }\n\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nSteps; i++)\n{\n  x = (i + 0.5) * delta;\n  result += 4.0 / (1 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction (+:result)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < nSteps; i++)\n{\n  x = (i + 0.5) * delta;\n  result += 4.0 / (1 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction (+:result)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for shared(a,b,c,n) lastprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10; i++)\n  printf(\"Hello\\n\");\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < SIZE; i++)\n  result += a[i] * b[i];\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static,chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (n = 2; n <= num; ++n)\n  fac *= n;\n\n", "pragma": "omp parallel for reduction(*:fac)", "exist": 1, "private": 0, "reduction": 1, "path": ""}
{"code": "for (i = 0; i <= N; i++)\n  for (j = 0; j < 1000; j++)\n  factorial(j);\n\n\nint factorial(int num)\n{\n  int fac = 1;\n  int n;\n  for (n = 2; n <= num; ++n)\n    fac *= n;\n\n  return fac;\n}\n\n\n", "pragma": "omp parallel for reduction(*:fac)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < matrix_size; i++)\n{\n  padded_in[i] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(matrix_size)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int q = 0; q < data_size_Y; q++)\n{\n  for (int w = 0; w < data_size_X; w++)\n  {\n    *(padded_in + ((((q + 1) * (data_size_X + 2)) + w) + 1)) = *(in + ((q * data_size_X) + w));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(data_size_X, data_size_Y)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int y = 0; y < data_size_Y; y++)\n{\n  for (int x = 0; x <= ((16 * (data_size_X / 16)) - 16); x += 16)\n  {\n    int total_vector = _mm_setzero_ps();\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 0), _mm_loadu_ps(padded_in + (x + (y * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 1), _mm_loadu_ps(padded_in + ((x + 1) + (y * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 2), _mm_loadu_ps(padded_in + ((x + 2) + (y * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 3), _mm_loadu_ps(padded_in + (x + ((y + 1) * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 4), _mm_loadu_ps(padded_in + ((x + 1) + ((y + 1) * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 5), _mm_loadu_ps(padded_in + ((x + 2) + ((y + 1) * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 6), _mm_loadu_ps(padded_in + (x + ((y + 2) * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 7), _mm_loadu_ps(padded_in + ((x + 1) + ((y + 2) * padded_x_size)))));\n    total_vector = _mm_add_ps(total_vector, _mm_mul_ps(_mm_load1_ps(r_kernel + 8), _mm_loadu_ps(padded_in + ((x + 2) + ((y + 2) * padded_x_size)))));\n    int total_vector1 = _mm_setzero_ps();\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 0), _mm_loadu_ps(padded_in + ((x + 4) + (y * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 1), _mm_loadu_ps(padded_in + ((x + 5) + (y * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 2), _mm_loadu_ps(padded_in + ((x + 6) + (y * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 3), _mm_loadu_ps(padded_in + ((x + 4) + ((y + 1) * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 4), _mm_loadu_ps(padded_in + ((x + 5) + ((y + 1) * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 5), _mm_loadu_ps(padded_in + ((x + 6) + ((y + 1) * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 6), _mm_loadu_ps(padded_in + ((x + 4) + ((y + 2) * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 7), _mm_loadu_ps(padded_in + ((x + 5) + ((y + 2) * padded_x_size)))));\n    total_vector1 = _mm_add_ps(total_vector1, _mm_mul_ps(_mm_load1_ps(r_kernel + 8), _mm_loadu_ps(padded_in + ((x + 6) + ((y + 2) * padded_x_size)))));\n    int total_vector2 = _mm_setzero_ps();\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 0), _mm_loadu_ps(padded_in + ((x + 8) + (y * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 1), _mm_loadu_ps(padded_in + ((x + 9) + (y * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 2), _mm_loadu_ps(padded_in + ((x + 10) + (y * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 3), _mm_loadu_ps(padded_in + ((x + 8) + ((y + 1) * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 4), _mm_loadu_ps(padded_in + ((x + 9) + ((y + 1) * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 5), _mm_loadu_ps(padded_in + ((x + 10) + ((y + 1) * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 6), _mm_loadu_ps(padded_in + ((x + 8) + ((y + 2) * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 7), _mm_loadu_ps(padded_in + ((x + 9) + ((y + 2) * padded_x_size)))));\n    total_vector2 = _mm_add_ps(total_vector2, _mm_mul_ps(_mm_load1_ps(r_kernel + 8), _mm_loadu_ps(padded_in + ((x + 10) + ((y + 2) * padded_x_size)))));\n    int total_vector3 = _mm_setzero_ps();\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 0), _mm_loadu_ps(padded_in + ((x + 12) + (y * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 1), _mm_loadu_ps(padded_in + ((x + 13) + (y * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 2), _mm_loadu_ps(padded_in + ((x + 14) + (y * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 3), _mm_loadu_ps(padded_in + ((x + 12) + ((y + 1) * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 4), _mm_loadu_ps(padded_in + ((x + 13) + ((y + 1) * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 5), _mm_loadu_ps(padded_in + ((x + 14) + ((y + 1) * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 6), _mm_loadu_ps(padded_in + ((x + 12) + ((y + 2) * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 7), _mm_loadu_ps(padded_in + ((x + 13) + ((y + 2) * padded_x_size)))));\n    total_vector3 = _mm_add_ps(total_vector3, _mm_mul_ps(_mm_load1_ps(r_kernel + 8), _mm_loadu_ps(padded_in + ((x + 14) + ((y + 2) * padded_x_size)))));\n    _mm_storeu_ps(out + (x + (y * data_size_X)), total_vector);\n    _mm_storeu_ps(out + ((x + 4) + (y * data_size_X)), total_vector1);\n    _mm_storeu_ps(out + ((x + 8) + (y * data_size_X)), total_vector2);\n    _mm_storeu_ps(out + ((x + 12) + (y * data_size_X)), total_vector3);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(padded_x_size, r_kernel, out)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int y = 0; y < data_size_Y; y++)\n{\n  for (int x = 16 * (data_size_X / 16); x < data_size_X; x++)\n  {\n    out[x + (y * data_size_X)] += (*r_kernel) * (*(padded_in + ((((x + 1) + (0 % 3)) - kern_cent_X) + ((((y + 1) + (0 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 1)) * (*(padded_in + ((((x + 1) + (1 % 3)) - kern_cent_X) + ((((y + 1) + (1 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 2)) * (*(padded_in + ((((x + 1) + (2 % 3)) - kern_cent_X) + ((((y + 1) + (2 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 3)) * (*(padded_in + ((((x + 1) + (3 % 3)) - kern_cent_X) + ((((y + 1) + (3 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 4)) * (*(padded_in + ((((x + 1) + (4 % 3)) - kern_cent_X) + ((((y + 1) + (4 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 5)) * (*(padded_in + ((((x + 1) + (5 % 3)) - kern_cent_X) + ((((y + 1) + (5 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 6)) * (*(padded_in + ((((x + 1) + (6 % 3)) - kern_cent_X) + ((((y + 1) + (6 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 7)) * (*(padded_in + ((((x + 1) + (7 % 3)) - kern_cent_X) + ((((y + 1) + (7 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 8)) * (*(padded_in + ((((x + 1) + (8 % 3)) - kern_cent_X) + ((((y + 1) + (8 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(kern_cent_X, kern_cent_Y, data_size_X, r_kernel)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < length; i++)\n{\n  r_kernel[(length - 1) - i] = kernel[i];\n}\n\n", "pragma": "omp parallel for firstprivate(kern_cent_X, kern_cent_Y, data_size_X, r_kernel)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10000000; i++)\n{\n  a[i] = rand() % 100;\n  b[i] = rand() % 100;\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  cv[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 1; i < 4; i++)\n{\n  a[i] = a[i + 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    a[i][j] = 0;\n    #pragma ivdep\n    #pragma vector always\n    #pragma simd\n    for (int k = 0; k < 10; k++)\n    {\n      a[i][k] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    a[i][j] = 0;\n    #pragma ivdep\n    #pragma vector always\n    #pragma simd\n    for (int k = 0; k < 10; k++)\n    {\n      a[j][k] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (c1 = nj; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (c1 = (nj > nm) ? (nj) : (nm); c1 <= (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 1; i <= 99; i += 1)\n{\n  for (j = 1; j <= 99; j += 1)\n  {\n    a[i][j] = a[i][j - 1] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (c1 = (((ni > nj) ? (ni) : (nj)) > nk) ? ((ni > nj) ? (ni) : (nj)) : (nk); c1 <= (nm + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (int mu = 0; mu < 4; mu++)\n  for (int nu = 0; nu < 4; nu++)\n  gcon[mu][nu] = G->gcon[loc][mu][nu][j][i];\n\n\n", "pragma": "omp parallel for private(c2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((2048 * 2048) / maxThreads); i++)\n{\n  for (j = 0; j < maxThreads; j++)\n  {\n    sorted[(maxThreads * i) + j] = v[(subArraySize * j) + i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (2048 * 2048); i++)\n{\n  v[i] = rand();\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((2048 * 2048) - 1); i++)\n{\n  printf(\"%d, \", v[i]);\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < ((2048 * 2048) - 1); i++)\n{\n  printf(\"%d, \", sorted[i]);\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    sum = 0;\n    for (k = 0; k < m; k++)\n      sum = sum + ((*((a + (i * m)) + k)) * (*((b + (k * m)) + j)));\n\n    *((c + (i * m)) + j) = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) ordered schedule(runtime)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    *((a + (i * m)) + j) = 2;\n    *((b + (i * m)) + j) = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) ordered schedule(runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    sum = 0;\n    for (k = 0; k < m; k++)\n      sum = sum + ((*((a + (i * m)) + k)) * (*((b + (k * m)) + j)));\n\n    *((c + (i * m)) + j) = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) ordered schedule(runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    *((a + (i * m)) + j) = 2;\n    *((b + (i * m)) + j) = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) ordered schedule(runtime)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n{\n  if (first_time == 'y')\n  {\n    tid = omp_get_thread_num();\n    first_time = 'n';\n  }\n\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "omp parallel for shared(a,b,c,chunk) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v1[i] = ((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5));\n  v2[i] = ((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5));\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  result = result + (v1[i] * v2[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(v1, v2, size) private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v1[i] = (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5))) * 2.328306e-10;\n  v2[i] = (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5))) * 2.328306e-10;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  result = result + (v1[i] * v2[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(v1, v2, size) private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v1[i] = ((long) (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5)))) * 4.656613e-10;\n  v2[i] = ((long) (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5)))) * 4.656613e-10;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  result = result + (v1[i] * v2[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(v1, v2, size) private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = ((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5));\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = a * v[i];\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(a,v,size) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5))) * 2.328306e-10;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = a * v[i];\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(a,v,size) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = ((long) (((((z = (36969 * (z & 65535)) + (z >> 16)) << 16) + (w = (18000 * (w & 65535)) + (w >> 16))) ^ (jcong = (69069 * jcong) + 1234567)) + ((jsr ^= jsr << 17, jsr ^= jsr >> 13, jsr ^= jsr << 5)))) * 4.656613e-10;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 5; i++)\n{\n  int ID = omp_get_thread_num();\n  printf(\"Hello(%d) => %d\\n\", ID, i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < 2000000; i++)\n{\n  int id = omp_get_thread_num();\n  output[i] = fancy_comp(i);\n}\n\nfloat fancy_comp(int num)\n{\n  int square = num * num;\n  return sqrt(square + 1);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < NFFT; i++)\n{\n  printf(\"x[%d] = (%.2f + j %.2f)\\n\", i, X[(2 * i) + 1], X[(2 * i) + 2]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = lower; i <= upper; i++)\n{\n  result = result + getTotient(i);\n}\n\nlong getTotient(long number)\n{\n  long result = number;\n  if ((number % 2) == 0)\n  {\n    result -= result / 2;\n    do\n      number /= 2;\n    while ((number % 2) == 0);\n  }\n\n  long prime;\n  for (prime = 3; (prime * prime) <= number; prime += 2)\n  {\n    if ((number % prime) == 0)\n    {\n      result -= result / prime;\n      do\n        number /= prime;\n      while ((number % prime) == 0);\n    }\n\n  }\n\n  if (number > 1)\n    result -= result / number;\n\n  return result;\n}\n\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 1, "private": 1, "reduction": 1, "path": ""}
{"code": "for (row = 0; row < N; row++)\n{\n  for (col = 0; col < N; col++)\n  {\n    printf(\"%.1lf%s\", C[row][col], (col < (N - 1)) ? (\",\") : (\";\\n\\t\"));\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (m = 0; m < 5; m++)\n{\n  xcrdif[m] = fabs((xcr[m] - xcrref[m]) / xcrref[m]);\n  xcedif[m] = fabs((xce[m] - xceref[m]) / xceref[m]);\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*class) == 'U')\n  {\n    printf(\"          %2d%20.13e\\n\", m, xcr[m]);\n  }\n  else\n    if (xcrdif[m] > epsilon)\n  {\n    *verified = 0;\n    printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n  else\n  {\n    printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Nx->dim; i++)\n  Nx->ve[i] = Ys->ve[i] / sqrt((Xs->ve[i] * Xs->ve[i]) + (Ys->ve[i] * Ys->ve[i]));\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Ny->dim; i++)\n  Ny->ve[i] = ((-1.0) * Xs->ve[i]) / sqrt((Xs->ve[i] * Xs->ve[i]) + (Ys->ve[i] * Ys->ve[i]));\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < X1->dim; i++)\n  X1->ve[i] = X->ve[i] + (delta * Nx->ve[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Y1->dim; i++)\n  Y1->ve[i] = Y->ve[i] + (delta * Ny->ve[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < X2->dim; i++)\n  X2->ve[i] = X->ve[i] - (delta * Nx->ve[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Y2->dim; i++)\n  Y2->ve[i] = Y->ve[i] + (delta * Ny->ve[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < N; i++)\n  aindex[i] = i - 1;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < N; i++)\n  bindex[i] = i;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (N - 1); i++)\n  cindex[i] = i + 1;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < (N - 2); i++)\n  dindex[i] = i + 2;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Xs->dim; i++)\n  XY->ve[i] = Xs->ve[i] * Ys->ve[i];\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Xs->dim; i++)\n  XX->ve[i] = Xs->ve[i] * Xs->ve[i];\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Xs->dim; i++)\n  YY->ve[i] = Ys->ve[i] * Ys->ve[i];\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < Cx->m; i++)\n{\n  for (j = 0; j < ns; j++)\n  {\n    double s = ((double) j) / ((double) ns);\n    double A1;\n    double A2;\n    double A3;\n    double A4;\n    double B1;\n    double B2;\n    double B3;\n    double B4;\n    double D;\n    double D_3;\n    double Tx1;\n    double Tx2;\n    double Tx3;\n    double Tx4;\n    double Ty1;\n    double Ty2;\n    double Ty3;\n    double Ty4;\n    int k;\n    A1 = ((((-1.0) * (s - 1.0)) * (s - 1.0)) * (s - 1.0)) / 6.0;\n    A2 = (((((3.0 * s) * s) * s) - ((6.0 * s) * s)) + 4.0) / 6.0;\n    A3 = (((((((-3.0) * s) * s) * s) + ((3.0 * s) * s)) + (3.0 * s)) + 1.0) / 6.0;\n    A4 = ((s * s) * s) / 6.0;\n    B1 = (((((-3.0) * s) * s) + (6.0 * s)) - 3.0) / 6.0;\n    B2 = (((9.0 * s) * s) - (12.0 * s)) / 6.0;\n    B3 = (((((-9.0) * s) * s) + (6.0 * s)) + 3.0) / 6.0;\n    B4 = ((3.0 * s) * s) / 6.0;\n    k = (i * ns) + j;\n    D = sqrt((Xs->ve[k] * Xs->ve[k]) + (Ys->ve[k] * Ys->ve[k]));\n    D_3 = (D * D) * D;\n    Tx1 = A1 - (((delta * XY->ve[k]) * B1) / D_3);\n    Tx2 = ((-1.0) * delta) * ((B1 / D) - ((XX->ve[k] * B1) / D_3));\n    Tx3 = A1 + (((delta * XY->ve[k]) * B1) / D_3);\n    Tx4 = delta * ((B1 / D) - ((XX->ve[k] * B1) / D_3));\n    Ty1 = delta * ((B1 / D) - ((YY->ve[k] * B1) / D_3));\n    Ty2 = A1 + (((delta * XY->ve[k]) * B1) / D_3);\n    Ty3 = ((-1.0) * delta) * ((B1 / D) - ((YY->ve[k] * B1) / D_3));\n    Ty4 = A1 - (((delta * XY->ve[k]) * B1) / D_3);\n    dCx->ve[aindex[i]] = (((dCx->ve[aindex[i]] + (Tx1 * Ix1->ve[k])) + (Tx2 * Iy1->ve[k])) - (Tx3 * Ix2->ve[k])) - (Tx4 * Iy2->ve[k]);\n    dCy->ve[aindex[i]] = (((dCy->ve[aindex[i]] + (Ty1 * Ix1->ve[k])) + (Ty2 * Iy1->ve[k])) - (Ty3 * Ix2->ve[k])) - (Ty4 * Iy2->ve[k]);\n    Tx1 = A2 - (((delta * XY->ve[k]) * B2) / D_3);\n    Tx2 = ((-1.0) * delta) * ((B2 / D) - ((XX->ve[k] * B2) / D_3));\n    Tx3 = A2 + (((delta * XY->ve[k]) * B2) / D_3);\n    Tx4 = delta * ((B2 / D) - ((XX->ve[k] * B2) / D_3));\n    Ty1 = delta * ((B2 / D) - ((YY->ve[k] * B2) / D_3));\n    Ty2 = A2 + (((delta * XY->ve[k]) * B2) / D_3);\n    Ty3 = ((-1.0) * delta) * ((B2 / D) - ((YY->ve[k] * B2) / D_3));\n    Ty4 = A2 - (((delta * XY->ve[k]) * B2) / D_3);\n    dCx->ve[bindex[i]] = (((dCx->ve[bindex[i]] + (Tx1 * Ix1->ve[k])) + (Tx2 * Iy1->ve[k])) - (Tx3 * Ix2->ve[k])) - (Tx4 * Iy2->ve[k]);\n    dCy->ve[bindex[i]] = (((dCy->ve[bindex[i]] + (Ty1 * Ix1->ve[k])) + (Ty2 * Iy1->ve[k])) - (Ty3 * Ix2->ve[k])) - (Ty4 * Iy2->ve[k]);\n    Tx1 = A3 - (((delta * XY->ve[k]) * B3) / D_3);\n    Tx2 = ((-1.0) * delta) * ((B3 / D) - ((XX->ve[k] * B3) / D_3));\n    Tx3 = A3 + (((delta * XY->ve[k]) * B3) / D_3);\n    Tx4 = delta * ((B3 / D) - ((XX->ve[k] * B3) / D_3));\n    Ty1 = delta * ((B3 / D) - ((YY->ve[k] * B3) / D_3));\n    Ty2 = A3 + (((delta * XY->ve[k]) * B3) / D_3);\n    Ty3 = ((-1.0) * delta) * ((B3 / D) - ((YY->ve[k] * B3) / D_3));\n    Ty4 = A3 - (((delta * XY->ve[k]) * B3) / D_3);\n    dCx->ve[cindex[i]] = (((dCx->ve[cindex[i]] + (Tx1 * Ix1->ve[k])) + (Tx2 * Iy1->ve[k])) - (Tx3 * Ix2->ve[k])) - (Tx4 * Iy2->ve[k]);\n    dCy->ve[cindex[i]] = (((dCy->ve[cindex[i]] + (Ty1 * Ix1->ve[k])) + (Ty2 * Iy1->ve[k])) - (Ty3 * Ix2->ve[k])) - (Ty4 * Iy2->ve[k]);\n    Tx1 = A4 - (((delta * XY->ve[k]) * B4) / D_3);\n    Tx2 = ((-1.0) * delta) * ((B4 / D) - ((XX->ve[k] * B4) / D_3));\n    Tx3 = A4 + (((delta * XY->ve[k]) * B4) / D_3);\n    Tx4 = delta * ((B4 / D) - ((XX->ve[k] * B4) / D_3));\n    Ty1 = delta * ((B4 / D) - ((YY->ve[k] * B4) / D_3));\n    Ty2 = A4 + (((delta * XY->ve[k]) * B4) / D_3);\n    Ty3 = ((-1.0) * delta) * ((B4 / D) - ((YY->ve[k] * B4) / D_3));\n    Ty4 = A4 - (((delta * XY->ve[k]) * B4) / D_3);\n    dCx->ve[dindex[i]] = (((dCx->ve[dindex[i]] + (Tx1 * Ix1->ve[k])) + (Tx2 * Iy1->ve[k])) - (Tx3 * Ix2->ve[k])) - (Tx4 * Iy2->ve[k]);\n    dCy->ve[dindex[i]] = (((dCy->ve[dindex[i]] + (Ty1 * Ix1->ve[k])) + (Ty2 * Iy1->ve[k])) - (Ty3 * Ix2->ve[k])) - (Ty4 * Iy2->ve[k]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 1; i < N; i++)\n  aindex[i] = i - 1;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n    collen[rowind[j]]++;\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%d \", v[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (fabs(A[(i * N) + j] - B[(i * N) + j]) > 1e-9)\n      return 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (j2 = 0; j2 < 4; j2++)\n  for (i = jll; i < kll; i++)\n  for (k2 = 0; k2 < 5; k2 += 2)\n  l++;\n\n\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto) reduction(+:result) num_threads(10)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  for (j = 0; j < matrix_size; j++)\n  {\n    C[i][j] = 0;\n    for (k = 0; k < matrix_size; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < nrows; i++)\n{\n  maxtf = fabs(rowval[rowptr[i]]);\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    maxtf = (maxtf < fabs(rowval[j])) ? (fabs(rowval[j])) : (maxtf);\n  }\n\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    rowval[j] = .1 + ((.9 * rowval[j]) / maxtf);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k)", "exist": 0, "private": 0, "reduction": 0, "path": ""}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp parallel for collapse()", "exist": 1, "private": 0, "reduction": 0, "path": ""}
