{"code": "for (int i = 0; i < N; i++)\n  y[i] = alpha * (l[i] - r[i]);\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment6/mini_app/linalg/5"}
{"code": "for (unsigned long long i = 0; i < n; i++)\n{\n  sum += 4.0 / (1.0 + (((i + 0.5) * step) * ((i + 0.5) * step)));\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/pi/0"}
{"code": "for (int i = 0; i < sequencesA.size(); i++)\n{\n  running_sum += sequencesA[i].size();\n  offsetA_h[i] = running_sum;\n  if (i == (sequences_per_stream - 1))\n  {\n    half_length_A = running_sum;\n    running_sum = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erictang000/GPU-BSW-Work-Stealing/driver/2"}
{"code": "for (int i = 0; i < nvars; i++)\n{\n  printf(\"x[%3d] = %15.7le \\n\", i, best_pt[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iloudaros/Paralllelll/Code/1.OpenMP/multistart_hooke_omp/11"}
{"code": "for (int shot = 0; shot < n; shot++)\n{\n  double x = rnd(&seed);\n  double y = rnd(&seed);\n  if (((x * x) + (y * y)) <= 1)\n  {\n    hit += 1;\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:hit)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/PI/Random Shooting/Parallelization/main/0"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n  ((((app_log() << \"    Sample size for thread \") << ip) << \" = \") << samples_th[ip]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/DMC/DMCOMPOPT/4"}
{"code": "for (c1 = nj; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/36"}
{"code": "for (int node = 0; node < (Nx * Ny); ++node)\n{\n  U[node] += (mu1 * dU[node]) + solve_f1(U[node], V[node]);\n  V[node] += (mu2 * dV[node]) + solve_f2(U[node], V[node]);\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raihaan123/HPC/CPP/src/ReactionDiffusion/4"}
{"code": "for (i = 0; i < 20; i++)\n{\n  t1 = mysecond();\n  while (((t2 = mysecond()) - t1) < 1.0E-6)\n    ;\n\n  timesfound[i] = (t1 = t2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avr-aics-riken/PMlib/doc/src_advanced/sub_copy/5"}
{"code": "for (int i = 0; i < startSize; i++)\n  for (int j = 0; j < startSize; j++)\n  MA[(i * startSize) + j] = (double) 1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raulviana/FEUP-CPAR/Assigment2/matrixMul/openMP_multiplication/2"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < m; ++j)\n{\n  if (d[i][j] > b)\n    b = d[i][j];\n\n  if (d[i][j] < a)\n    a = d[i][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (mask1[index1][i] && mask2[index2][i])\n  {\n    double term1 = data1[index1][i];\n    double term2 = data2[index2][i];\n    double w = weight[i];\n    result += (w * term1) * term2;\n    denom1 += (w * term1) * term1;\n    denom2 += (w * term2) * term2;\n    flag = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/39"}
{"code": "for (i = 0; i < myProductsSize; i++)\n{\n  allProducts[i] = myProducts[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/8"}
{"code": "for (i = 0; i < p.N; i++)\n{\n  for (j = 0; j < p.N; j++)\n  {\n    fprintf(nfile, \"%i %i %f\\n\", i, j, res[0][i + (j * p.N)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/parallel_mg/10"}
{"code": "for (j = 0; j < N; j++)\n{\n  int tid = omp_get_thread_num();\n  if (randArray[j] > upper_threshold)\n  {\n    main_vector[tid].push_back(make_pair(j, randArray[j]));\n  }\n  else\n    if (randArray[j] < lower_threshold)\n  {\n    main_vector[tid].push_back(make_pair(j, randArray[j]));\n  }\n\n\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmarzzz/OpenMPTests/djm6267_hw3/part2/hw3_part2_omp_djm6267/0"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  int x;\n  int y;\n  myboard = *mcts.findNextMove(&myboard, player).getState()->getBoard();\n  ((cout << \"current state after chance \") << i) << endl;\n  myboard.display();\n  if (myboard.checkStatus() != 2)\n  {\n    break;\n  }\n\n  player = 1 - player;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/13"}
{"code": "for (j = 0; j < radix; j++)\n{\n  radixSortCountSortEdgesByRanks(&pageRanksFP, &pageRanksFPTemp, &labels, &labelsTemp, j, buckets, buckets_count, num_vertices);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/16"}
{"code": "for (x = 0; x < IszX; x++)\n{\n  for (y = 0; y < IszY; y++)\n  {\n    for (k = 0; k < Nfr; k++)\n    {\n      I[(((x * IszY) * Nfr) + (y * Nfr)) + k] = newMatrix[(((x * IszY) * Nfr) + (y * Nfr)) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/17"}
{"code": "for (j = 0; j < kxps; j++)\n{\n  jj = nyhd * j;\n  jk3 = (3 * nyv) * j;\n  for (k = 1; k < nyh; k++)\n  {\n    k1 = ny - k;\n    at1 = cimagf(ffc[k + jj]);\n    for (i = 0; i < 3; i++)\n    {\n      fxy[(i + (3 * k)) + jk3] += exy[(i + (3 * k)) + jk3] * at1;\n      fxy[(i + (3 * k1)) + jk3] += exy[(i + (3 * k1)) + jk3] * at1;\n    }\n\n  }\n\n  k1 = nyh;\n  at1 = cimagf(ffc[jj]);\n  for (i = 0; i < 3; i++)\n  {\n    fxy[i + jk3] += exy[i + jk3] * at1;\n    fxy[(i + (3 * k1)) + jk3] += exy[(i + (3 * k1)) + jk3] * at1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,k1,jj,jk3,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/15"}
{"code": "for (i = 0; i < (tam - 1); i++)\n{\n  if (vetor[i] > vetor[i + 1])\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tiaagosr/parallel-sorting-algorithms/bubble/3"}
{"code": "for (int i = 1; i < K; i++)\n  mid_array[i] += mid_array[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/5"}
{"code": "for (int j = 0; j < i; j++)\n{\n  b *= 2;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task13/1"}
{"code": "for (i = 0; i < info->N; i++)\n{\n  for (j = 0; j < info->K; j++)\n  {\n    fscanf(myFile, \"%f\", ((*pos) + (i * info->K)) + j);\n  }\n\n  for (j = 0; j < info->K; j++)\n  {\n    fscanf(myFile, \"%f\", ((*vel) + (i * info->K)) + j);\n  }\n\n  fscanf(myFile, \"%d\", (*group) + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/2"}
{"code": "for (int i = 1; i < nthreads; ++i)\n{\n  cs = crc64_combine(cs, thread_cs[i], thread_sz[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/crc64-omp/CRC64/8"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    if ((i == 0) || (j == 0))\n      K[i][j] = 0;\n    else\n      if (X[i - 1] == Y[j - 1])\n      K[i][j] = K[i - 1][j - 1] + 1;\n    else\n      K[i][j] = max(K[i - 1][j], K[i][j - 1]);\n\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarichandanaParimi/OPENMP_Advanced/lcs/lcs/0"}
{"code": "for (i = 10000 - 5; i <= 10000; i++)\n{\n  printf(\"[%d,%d]: %5.2f  \", i, i, Temperature[i][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bakitybacon/parallelprogramming/Exercises/OpenMP/laplace_10k/5"}
{"code": "for (i = 1; i < my_num_rows; i++)\n{\n  U_Curr[i] = U_Curr[i - 1] + ((int) floor(WIDTH / 1.0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/357r4bd/2d-heat/src/openmp-2dheat/3"}
{"code": "for (i = 1; i < NUM_BUCKETS; i++)\n{\n  bucket_ptrs[i] = bucket_ptrs[i - 1];\n  for (k = 0; k < myid; k++)\n    bucket_ptrs[i] += bucket_size[k][i];\n\n  for (k = myid; k < num_procs; k++)\n    bucket_ptrs[i] += bucket_size[k][i - 1];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  s_l[i] = 1;\n  flags[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/gauss/7"}
{"code": "for (j = 0; j < 50; j++)\n  b[j] = (c[j] = j);\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q6/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  scanf(\"%d\", &b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/vector_addition/2"}
{"code": "for (kk = 0; kk < en; kk += b)\n{\n  for (jj = 0; jj < en; jj += b)\n  {\n    for (i = 0; i < n; i++)\n    {\n      for (j = jj; j < (jj + b); j++)\n      {\n        sum = A[i][j];\n        for (k = kk; k < (kk + b); k++)\n        {\n          sum += B[i][k] * C[k][j];\n        }\n\n        A[i][j] = sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kothiga/Matrix-Matrix-Parallel/MatMultOpenMP/14"}
{"code": "for (i = 1; i < (k + 1); i++)\n{\n  j = (k + 1) - i;\n  u0 = u_mat(i, j);\n  u_mat(i, j) = 0.25 * ((((u_mat(i - 1, j) + u_mat(i + 1, j)) + u_mat(i, j - 1)) + u_mat(i, j + 1)) - ((h * h) * f_mat(i - 1, j - 1)));\n  d = fabs(u_mat(i, j) - u0);\n  if (d > mx[i])\n    mx[i] = d;\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(u_mat, k, mx) private(i, j, u0, d) schedule(static, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/second/functions/4"}
{"code": "for (int idy = 0; idy < h; idy++)\n  for (int idx = 0; idx < w; idx++)\n{\n  int id = (idy * w) + idx;\n  float I = in[id];\n  float res = 0;\n  float normalization = 0;\n  for (int i = -R; i <= R; i++)\n  {\n    for (int j = -R; j <= R; j++)\n    {\n      int idk = idx + i;\n      int idl = idy + j;\n      if (idk < 0)\n        idk = -idk;\n\n      if (idl < 0)\n        idl = -idl;\n\n      if (idk > (w - 1))\n        idk = (w - 1) - i;\n\n      if (idl > (h - 1))\n        idl = (h - 1) - j;\n\n      int id_w = (idl * w) + idk;\n      float I_w = in[id_w];\n      float range = ((-(I - I_w)) * (I - I_w)) / (2.f * variance_I);\n      float spatial = (-(((idk - idx) * (idk - idx)) + ((idl - idy) * (idl - idy)))) / (2.f * variance_spatial);\n      float weight = a_square * expf(spatial + range);\n      normalization += weight;\n      res += I_w * weight;\n    }\n\n  }\n\n  out[id] = res / normalization;\n}\n\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bilateral-omp/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  error = error + fabs(p_new[i] - p[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leankyr/Parallel_Pagerank/Final/Implementation_2/main2/9"}
{"code": "for (int j = 0; j < k; j++)\n{\n  float max = -1.0;\n  int arg_max = -1;\n  double curr_prob;\n  for (int q = 0; q < k; q++)\n  {\n    curr_prob = (dp1[q][i - 1] * A[q][j]) * B[j][Y[i]];\n    if (curr_prob > max)\n    {\n      max = curr_prob;\n      arg_max = q;\n    }\n\n  }\n\n  dp1[j][i] = max;\n  dp2[j][i] = arg_max;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_par/0"}
{"code": "for (i = 1; i <= n; i++)\n{\n  count = 0;\n  for (k = i - 1; k <= (i + 1); k++)\n  {\n    for (l = n - 1; l <= (n + 1); l++)\n    {\n      if ((k != i) || (l != n))\n      {\n        if (cur[k][l] == '1')\n        {\n          count++;\n        }\n\n      }\n\n    }\n\n  }\n\n  if ((count < 2) || (count > 3))\n  {\n    next[i][n] = '0';\n  }\n  else\n    if (count == 3)\n  {\n    next[i][n] = '1';\n  }\n  else\n    if (cur[i][n] == '1')\n  {\n    next[i][n] = '1';\n  }\n  else\n  {\n    next[i][n] = '0';\n  }\n\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dimitris-Mpou/Parallel-GOL/functions/2"}
{"code": "for (int r = size - 1; r > 0; r--)\n{\n  if (rank_load[r] < rank_load[rank_with_min_load])\n  {\n    rank_with_min_load = r;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing10/test/4"}
{"code": "for (int i = 0; i < buckets; i++)\n{\n  for (int j = 0; j < v.size(); j++)\n  {\n    if ((v[j] >= (i * bucket_interval)) && (v[j] <= ((i + 1) * bucket_interval)))\n    {\n      bs[0][i].push_back(v[j]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(bs, v, bucket_interval) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort2/0"}
{"code": "for (long int idxLoop = 0; idxLoop < NbLoops; ++idxLoop)\n{\n  scalarFibonnaci += Fibonacci(TestSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/fibonnaci/0"}
{"code": "for (int j = 0; j < x_points; j++)\n{\n  u_new[0][j] = 0;\n  u_new[y_points - 1][j] = 1.0;\n  v_new[0][j] = 0;\n  v_new[y_points - 1][j] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Cavity Flow/2-D_Cavity_Flow/main/3"}
{"code": "for (int i = 0; i < m; i++)\n{\n  multiply[i] = malloc(q * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiSoJi/Arqui2_Taller02/op_par/3"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    v = v + (a[i][j] * a[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/poisson/6"}
{"code": "for (int32_t i = 0; i < p_border.size(); i++)\n{\n  int32_t best_dist = 10000000;\n  for (int32_t j = 0; j < p_support.size(); j++)\n  {\n    int32_t du = p_border[i].u - p_support[j].u;\n    int32_t dv = p_border[i].v - p_support[j].v;\n    int32_t curr_dist = (du * du) + (dv * dv);\n    if (curr_dist < best_dist)\n    {\n      best_dist = curr_dist;\n      p_border[i].d = p_support[j].d;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/3"}
{"code": "for (i = 0; i < NrTowns; i++)\n{\n  for (j = 0; j < NrTowns; j++)\n  {\n    dx = towns[i].x - towns[j].x;\n    dy = towns[i].y - towns[j].y;\n    distance[i][j] = (int) sqrt((double) ((dx * dx) + (dy * dy)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP5/Fichiers/tsp-main/2"}
{"code": "for (int i = 0; i < num_threads; i++)\n  sum += local_sum[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raaavioli/OpenMP-Assignments-DD2356/Exercise-3/sum/3"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j - 1][k][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/48"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < FEATURES; j++)\n  {\n    normalized[(i * FEATURES) + j] = (dataset[(i * FEATURES) + j] - min[j]) / (max[j] - min[j]);\n  }\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/veersenjadhav/data-normalization-parallel/data_normalization_OpenMP/2"}
{"code": "for (int Ti = -1; Ti <= (R / 32); Ti = Ti + 1)\n{\n  float Iy[34][258];\n  float Ix[34][258];\n  for (int Tj = -1; Tj <= (C / 256); Tj = Tj + 1)\n  {\n    int _ct0 = (R < ((32 * Ti) + 33)) ? (R) : ((32 * Ti) + 33);\n    int _ct1 = (1 > (32 * Ti)) ? (1) : (32 * Ti);\n    int _ct2 = (C < ((256 * Tj) + 257)) ? (C) : ((256 * Tj) + 257);\n    int _ct3 = (1 > (256 * Tj)) ? (1) : (256 * Tj);\n    for (int _i0 = _ct1; _i0 <= _ct0; _i0 = _i0 + 1)\n    {\n      #pragma ivdep\n      for (int _i1 = _ct3; _i1 <= _ct2; _i1 = _i1 + 1)\n      {\n        Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] = (((((img[(((-1) + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f)) + (img[(((-1) + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f)) + (img[(_i0 * (C + 2)) + ((-1) + _i1)] * (-0.166666666667f))) + (img[(_i0 * (C + 2)) + (1 + _i1)] * 0.166666666667f)) + (img[((1 + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f))) + (img[((1 + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f);\n      }\n\n    }\n\n    for (int _i0 = _ct1; _i0 <= _ct0; _i0 = _i0 + 1)\n    {\n      #pragma ivdep\n      for (int _i1 = _ct3; _i1 <= _ct2; _i1 = _i1 + 1)\n      {\n        Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] = (((((img[(((-1) + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f)) + (img[((1 + _i0) * (C + 2)) + ((-1) + _i1)] * 0.0833333333333f)) + (img[(((-1) + _i0) * (C + 2)) + _i1] * (-0.166666666667f))) + (img[((1 + _i0) * (C + 2)) + _i1] * 0.166666666667f)) + (img[(((-1) + _i0) * (C + 2)) + (1 + _i1)] * (-0.0833333333333f))) + (img[((1 + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f);\n      }\n\n    }\n\n    int _ct8 = ((R - 1) < ((32 * Ti) + 32)) ? (R - 1) : ((32 * Ti) + 32);\n    int _ct9 = (2 > ((32 * Ti) + 1)) ? (2) : ((32 * Ti) + 1);\n    for (int _i0 = _ct9; _i0 <= _ct8; _i0 = _i0 + 1)\n    {\n      int _ct10 = ((C - 1) < ((256 * Tj) + 256)) ? (C - 1) : ((256 * Tj) + 256);\n      int _ct11 = (2 > ((256 * Tj) + 1)) ? (2) : ((256 * Tj) + 1);\n      #pragma ivdep\n      for (int _i1 = _ct11; _i1 <= _ct10; _i1 = _i1 + 1)\n      {\n        harris[(_i0 * (2 + C)) + _i1] = (((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) * (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)]))) - ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) * (((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])))) - ((0.04f * ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])))) * ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)]))));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage/0"}
{"code": "for (c = 0; c < m; c++)\n{\n  for (d = 0; d < q; d++)\n  {\n    printf(\"%d\\t\", pro[c][d]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javierchacon262/IntroPP2160044_1/omp_matrixMultiplication/5"}
{"code": "for (int y = height - 1; y >= 0; y--)\n{\n  for (size_t x = 0; x < width; x++)\n  {\n    const size_t i = ((y * width) + x) * 3;\n    fputc(data[i + 2], f);\n    fputc(data[i + 1], f);\n    fputc(data[i], f);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CanBoran/Julia-Set-OPENMP/julia_openmp/0"}
{"code": "for (int i = 0; i < num_partitions_; ++i)\n{\n  (*budget_usage)[i] = 0;\n  for (int j = 0; j < (subproblems_[i].envelope_points_.size() - 1); ++j)\n  {\n    if (subproblems_[i].envelope_points_[j].first >= critical_ratio)\n    {\n      (*budget_usage)[i] += subproblems_[i].budget_cutoffs_[j + 1] - subproblems_[i].budget_cutoffs_[j];\n    }\n\n  }\n\n  total_budget_usage += (*budget_usage)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dragosciocan/OpenMPSolver/LPsolver/LPsolver/global_problem/7"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    fprintf(MatrizB, \"%d \", matriz_B[i][j]);\n  }\n\n  fprintf(MatrizB, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SidSan97/OMP---Algebra-Linear/OMP - Algebra Linear/main/2"}
{"code": "for (i = 0; i < 16; i++)\n{\n  pthread_create(&thread_id[i], &attributes, chol_pthread, (void *) args[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/5"}
{"code": "for (i = 0; i < n; i++)\n  fprintf(f, \"%c\", fbase_as_char(s[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/frna-omp/frna/8"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1350[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/59"}
{"code": "for (int i = 0; i < size; i++)\n  B[i] = A[i] * alpha;\n\n", "pragma": "    #pragma omp parallel for schedule (dynamic, 64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/5"}
{"code": "for (i = 0; i < nrows; ++i)\n{\n  t = 0.0;\n  #pragma ivdep\n  for (j = rowPtr[i]; j < rowPtr[i + 1]; ++j)\n  {\n    t += (double) (A[j] * v[colInd[j]]);\n  }\n\n  r[i] = t;\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j, t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    wijk = ws[i][j][k];\n    wp1 = ws[i][j][k + 1];\n    wm1 = ws[i][j][k - 1];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,wijk ,wp1 ,wm1 ,tz2 ,dz1tz1 ,zzcon2 ,dz2tz1 ,dz3tz1 ,c2 ,dz4tz1 ,con43 ,c1 ,zzcon5 ,zzcon3 ,dz5tz1 ,zzcon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/113"}
{"code": "for (int i = 0; i < (n_isotopes * n_gridpoints); i++)\n{\n  double quarry = energy_grid[i].energy;\n  if (((1 && (mype == 0)) && (omp_get_thread_num() == 0)) && ((i % 200) == 0))\n    printf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", (100.0 * ((double) i)) / ((n_isotopes * n_gridpoints) / omp_get_num_threads()));\n\n  for (int j = 0; j < n_isotopes; j++)\n  {\n    energy_grid[i].xs_ptrs[j] = binary_search(nuclide_grids[j], quarry, n_gridpoints);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints, mype )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/XSBench/GridInit/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  printf(\" %g\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Oidlichtnwoada/ParallelMergesort/parmerge_tester/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n    y[i] += A[i][j] * x[i];\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j) reduction(+:y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/prodottoMatxVet/0"}
{"code": "for (int n = item.get_global_linear_id(); n < set_size; n += item.get_global_range()[0])\n{\n  get_min_dt_kernel_gpu(&arg0[n * 1], arg1_l);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/sycl/get_min_dt_kernel_kernel/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  double tmp = 0;\n  for (int j = 0; j < N; j++)\n  {\n    tmp += A[(i * N) + j] * prevSolution[j];\n  }\n\n  r[i] = b[i] - tmp;\n  z[i] = r[i];\n}\n\n", "pragma": "#pragma omp for schedule(TYPE, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_2/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  sum += left[i] * right[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(left, right, size) reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artme-uni/OpenMP/OpenMP_2/matrix/column/1"}
{"code": "for (int i = 0; i <= numcells; i++)\n{\n  UFLUX[i] = (UFLUX[i] + UFLUX2[i]) / 2;\n  FR[i] = (FR[i] + FR2[i]) / 2;\n  FRU[i] = (FRU[i] + FRU2[i]) / 2;\n  FRE[i] = (FRE[i] + FRE2[i]) / 2;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/7"}
{"code": "for (n = 0; n < nwin; n++)\n{\n  data1[n] = 0.0;\n  data2[n] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_COH/main/1"}
{"code": "for (int row = 0; row < model->rows; row++)\n{\n  for (int k = 0; k < model->no_clusters; k++)\n  {\n    if (model->data_clusters[row] == k)\n    {\n      cluster_count[k] = cluster_count[k] + 1;\n      for (int i = 0; i < model->columns; i++)\n      {\n        sum_cluster_columns[(k * model->columns) + i] += model->data[(row * model->columns) + i];\n      }\n\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads) reduction(+:cluster_count, sum_cluster_columns)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajshrestha86/kmeans-clusterize/openmp/kmeans_omp/0"}
{"code": "for (int jj = 0; jj < params.nx; jj++)\n{\n  {\n    if ((((!obstacles[(ii * params.nx) + jj]) && ((cells[(ii * params.nx) + jj].speeds[3] - w1) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[6] - w2) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[7] - w2) > 0.0))\n    {\n      {\n        {\n          cells[(ii * params.nx) + jj].speeds[1] += w1;\n          cells[(ii * params.nx) + jj].speeds[5] += w2;\n          cells[(ii * params.nx) + jj].speeds[8] += w2;\n        }\n        {\n          cells[(ii * params.nx) + jj].speeds[3] -= w1;\n          cells[(ii * params.nx) + jj].speeds[6] -= w2;\n          cells[(ii * params.nx) + jj].speeds[7] -= w2;\n        }\n      }\n    }\n\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk.pomp/6"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  myFunc(i);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/sample/hello-openmp/1"}
{"code": "for (i = r2; i < (sz + r2); i++)\n{\n  for (j = c2; j < sz; j++)\n  {\n    r[i][j] = p[(i - r2) + r1][(j - c2) + c1] - q[i - r2][j - c2];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LalitDhupar/Large-Matrix-Multiplication-Using-OpenMP/Large_Matrix_Multplication_OpenMP/5"}
{"code": "for (row = 0; row < 2048; row++)\n{\n  for (col = 0; col < 2048; col++)\n  {\n    mat1[row][col] = (rand() % 10) * 1.1;\n    ;\n    mat2[row][col] = (rand() % 10) * 1.1;\n    ;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatgirlprogrammer/matrix-multiplication-with-OpenMP/paralell_matrix_multiply/1"}
{"code": "for (i = 0; i < k; i += B)\n  FW(A, k, i, k, B);\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  omp_set_nest_lock(&lck);\n  nr_threads_in_single++;\n  nr_iterations++;\n  nr_threads_in_single--;\n  result = result + nr_threads_in_single;\n  omp_unset_nest_lock(&lck);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_nest_lock/0"}
{"code": "for (unsigned i = 1; i <= n_cells; i++)\n  for (unsigned j = 1; j <= n_cells; j++)\n  T_new[(i * n_cells) + j] = 0.25 * (((T[((i + 1) * n_cells) + j] + T[((i - 1) * n_cells) + j]) + T[(i * n_cells) + (j + 1)]) + T[(i * n_cells) + (j - 1)]);\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olcf/openmp-offload/C/1-openmp-cpu/jacobi/0"}
{"code": "for (int i = 0; i < count; ++i)\n  (cout << a[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kang235/OpenMP/MergeSort/1"}
{"code": "for (i = 0; i < elite_count; i++)\n{\n  next_individuals.push_back(this->current_individuals.back());\n  this->current_individuals.pop_back();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/10"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  for (int a = 0; a < N_a; a++)\n  {\n    r.nV[i] += p.nV[a] * l.nM[a][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/15"}
{"code": "for (i = 1; i < numOfProc; i++)\n  MPI_Send(&n, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorelShoshany/Perceptron-Algorithm/hw4/app/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  histo[i] = 0;\n  for (j = 0; j < num_thread; j++)\n    histo_thread[i][j] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_creative/3"}
{"code": "for (int j = 0; j < SIZE; j++)\n{\n  a[j] = rand() % SIZE;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/ompquicksort/0"}
{"code": "for (i = 0; i < n; ++i)\n  evec[i][j] /= tmp;\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/4"}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB071-targetparallelfor-orig-no/1"}
{"code": "for (unsigned i = 0; i < matSize; ++i)\n{\n  double resTmp = 0.;\n  for (unsigned j = 0; j < matSize; ++j)\n  {\n    resTmp += mat[(i * matSize) + j] * vec[j];\n  }\n\n  res[i] = resTmp;\n}\n\n", "pragma": "\t#pragma omp parallel for default (none) shared (matSize, mat,vec,res)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/MatrixVector/CDParallelism/utils/3"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  dist[i] = INT_MAX;\n  visit[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nickpei/EECS224-High-Performance-Computing/Dijkstra_omp_v4/3"}
{"code": "for (i = 1; i < 6; i++)\n{\n  psql(i, txt);\n}\n\n", "pragma": " #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Francis-Alex-Kuzhippallil/Parallel-Word-Search-Using-OpenMP/Optimized Parallel Execution with phpmyadmin/0"}
{"code": "for (int i = 0; i < POINTS_NUMBER; i++)\n{\n  pointSoA.x[i] = distribution(generator);\n  pointSoA.y[i] = distribution(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mb98-unifi/K-Means_OpenMP/mainSoA/0"}
{"code": "for (i = 0; i < (MK + 1); i++)\n{\n  t2 = randlc(&t1, t1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/EP/ep/1"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (4 * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 3; jj++)\n    {\n      t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n      t1 = f[(jj + (4 * j)) + joff] + t2;\n      t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n      f[(jj + (4 * j)) + joff] = t1 + t2;\n      f[(jj + (4 * (nxh - j))) + joff] = conjf(t1 - t2);\n    }\n\n  }\n\n  for (jj = 0; jj < 3; jj++)\n  {\n    f[(jj + (4 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (4 * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(4 * j1) + joff];\n      t2 = f[(1 + (4 * j1)) + joff];\n      t3 = f[(2 + (4 * j1)) + joff];\n      f[(4 * j1) + joff] = f[(4 * j) + joff];\n      f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n      f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n      f[(4 * j) + joff] = t1;\n      f[(1 + (4 * j)) + joff] = t2;\n      f[(2 + (4 * j)) + joff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = conjf(sct[kmr * j]);\n        t2 = t1 * f[((4 * j) + k2) + joff];\n        t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n        t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n        f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n        f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n        f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n        f[((4 * j) + k1) + joff] += t2;\n        f[((1 + (4 * j)) + k1) + joff] += t3;\n        f[((2 + (4 * j)) + k1) + joff] += t4;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    f[(3 + (4 * j)) + joff] = cimagf(f[(2 + (4 * j)) + joff]) + (cimagf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n    at1 = crealf(f[(2 + (4 * j)) + joff]);\n    f[(2 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (cimagf(f[(1 + (4 * j)) + joff]) * _Complex_I);\n    at2 = crealf(f[(1 + (4 * j)) + joff]);\n    f[(1 + (4 * j)) + joff] = at1 + (0.0 * _Complex_I);\n    f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,at1,at2,t1,t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/24"}
{"code": "for (int k = HALO.z; k < (SDMGeom->L_NodeZ() + HALO.z); k += sgt.z)\n{\n  yt = 0;\n  for (int j = HALO.y; j < (SDMGeom->L_NodeY() + HALO.y); j += sgt.y)\n  {\n    xt = 0;\n    for (int i = HALO.x; i < (SDMGeom->L_NodeX() + HALO.x); i += sgt.x)\n    {\n      idx = ((xt + (yt * nxt)) + ((zt * nyt) * nxt)) + (ktime * ((nxt * nyt) * nzt));\n      Hxx[idx] = Hyy_r[IJK(i, j, k)];\n      Hxy[idx] = Hxy_r[IJK(i, j, k)];\n      Hxz[idx] = -Hyz_r[IJK(i, j, k)];\n      Hyy[idx] = Hxx_r[IJK(i, j, k)];\n      Hyz[idx] = -Hxz_r[IJK(i, j, k)];\n      Hzz[idx] = Hzz_r[IJK(i, j, k)];\n      xt++;\n    }\n\n    yt++;\n  }\n\n  zt++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/37"}
{"code": "for (int i = 1; i < argc; i = i + 2)\n{\n  int firstIndex = atoi(argv[i]);\n  int secondIndex = atoi(argv[i + 1]);\n  if ((firstIndex < matrix_size) && (secondIndex < matrix_size))\n    (((((cout << \"\\nA[\") << firstIndex) << \"][\") << secondIndex) << \"]: \") << temp[firstIndex][secondIndex];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArlindHajdari/StencilCode/StencilCode/stencil/4"}
{"code": "for (i = 0; i < NBUCKETS; i++)\n  printf(\"[%d] = %d\\n\", i, hist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olia92/OpenMP_Mattson/Histogram/histogram_omp/2"}
{"code": "for (int i = 0; i < num; i++)\n{\n  printf(\"%d,\", iterstep[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VeVeBoi/mandelbrotOpenMP/mandel/4"}
{"code": "for (mm = 0; mm < rows; mm++)\n{\n  for (nn = 0; nn < cols; nn++)\n  {\n    send_buffer[(mm * cols) + nn] = C[(mm * cols) + nn];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/solvers/matmul/1"}
{"code": "for (int j = pow(2, p - i) - 1; j < finishposition; j++)\n{\n  if (destination->tab[(2 * j) + 1] < destination->tab[(2 * j) + 2])\n    destination->tab[j] = destination->tab[(2 * j) + 2];\n  else\n    destination->tab[j] = destination->tab[(2 * j) + 1];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/1"}
{"code": "for (i = 1; i < 1000; i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "omp parallel for private(i) reduction(+:j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/full_verify/1"}
{"code": "for (i = 0; i < size; i++)\n  printf(\"%10d%10d%10d\\n\", a[i], b[i], c[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcksber/CMU_15-418_hw3/examples/loop/3"}
{"code": "for (unsigned long int i = 0; i < MAX; i++)\n  A[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rtahmasbi/Parallel_Computing/OpenMP/ex4/2"}
{"code": "for (i = 0; i <= len1; i++)\n{\n  free(mat[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/5"}
{"code": "for (i = MM - 1; i >= 0; i--)\n{\n  best = 0.0;\n  if (best < ten[1][i1])\n  {\n    jg[1][i][0] = 0;\n    jg[1][i][1] = (is1 - 2) + j1[1][i1];\n    jg[1][i][2] = (is2 - 2) + j2[1][i1];\n    jg[1][i][3] = (is3 - 2) + j3[1][i1];\n    i1 = i1 - 1;\n  }\n  else\n  {\n    jg[1][i][0] = 0;\n    jg[1][i][1] = 0;\n    jg[1][i][2] = 0;\n    jg[1][i][3] = 0;\n  }\n\n  best = 1.0;\n  if (best > ten[0][i0])\n  {\n    jg[0][i][0] = 0;\n    jg[0][i][1] = (is1 - 2) + j1[0][i0];\n    jg[0][i][2] = (is2 - 2) + j2[0][i0];\n    jg[0][i][3] = (is3 - 2) + j3[0][i0];\n    i0 = i0 - 1;\n  }\n  else\n  {\n    jg[0][i][0] = 0;\n    jg[0][i][1] = 0;\n    jg[0][i][2] = 0;\n    jg[0][i][3] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/18"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = 0;\n  B[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/hip-openmp/aomp_hip_launch_test/hiplaunch/4"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  if ((val % div) == 0)\n    return div;\n\n  if (neg)\n  {\n    cntneg--;\n    div = cntneg;\n    neg = 0;\n  }\n  else\n  {\n    cntpos++;\n    div = cntpos;\n    neg = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nms-omp/main/0"}
{"code": "for (int64_t i = 0; i < num_local; i++)\n{\n  sum += f(h * ((((i * size64) + rank64) + 1) - 0.5));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum) schedule(static, 2000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndrewGaspar/estimate-pi-openmp/main/0"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g %.16g %.16g\\n\", m_pParticleData->m_vVelocityU[i], m_pParticleData->m_vVelocityV[i], m_pParticleData->m_vVelocityW[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/45"}
{"code": "for (int i = 0; i < localRows; i++)\n{\n  for (int j = 0; j < localColumns; j++)\n  {\n    image_array[i][j] = sharpenedImageArray[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiannisKalopisis/Parallel-image-filter-convolution/src/Project_Parallhla/10"}
{"code": "for (i = 0; i < topoinfo->numR; i++)\n{\n  if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 1)\n  {\n    tmprlt->paras[((3 * i) + 2) + (2 * topoinfo->numG)] = randfd(topoinfo->prsrandrange[0][((3 * i) + 2) + (2 * topoinfo->numG)], topoinfo->prsrandrange[1][((3 * i) + 2) + (2 * topoinfo->numG)], simu_opts->dist);\n  }\n  else\n    if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 2)\n  {\n    tmprlt->paras[((3 * i) + 2) + (2 * topoinfo->numG)] = 1.0 / randfd(topoinfo->prsrandrange[0][((3 * i) + 2) + (2 * topoinfo->numG)], topoinfo->prsrandrange[1][((3 * i) + 2) + (2 * topoinfo->numG)], simu_opts->dist);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/74"}
{"code": "for (unsigned ck = 0; ck < Nkeys; ck++)\n{\n  if (makeindex)\n  {\n    SortStepIndex(ck, PrevData64, Data64, PrevIndex, Index);\n    swap(PrevIndex, Index);\n  }\n  else\n    SortStep(ck, PrevData64, Data64);\n\n  swap(PrevData64, Data64);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/13"}
{"code": "for (long v = 0; v < NVer; v++)\n{\n  long adj1 = verPtr[v];\n  long adj2 = verPtr[v + 1];\n  for (long k = adj1; k < adj2; k++)\n  {\n    if (v == verInd[k].tail)\n      continue;\n\n    if (vtxColor[v] == vtxColor[verInd[k].tail])\n    {\n      __sync_fetch_and_add(&myConflicts, 1);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringDistanceOne/4"}
{"code": "for (size_t index = 0; index < SIZE; index++)\n{\n  long long sum = 0;\n  for (size_t i = 0; i < index; i++)\n    sum += i;\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dogganidhal/Parallel-processing/OpenMP/helloworld/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d \", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IvanOnJava/OpenMP_examples/OpenMP_example_SortMatrixColumns_one/2"}
{"code": "for (i = 0; i < FILTER_SIZE; i++)\n{\n  for (j = 0; j < FILTER_SIZE; j++)\n  {\n    int x = (FILTER_SIZE / 2) - j;\n    int y = (FILTER_SIZE / 2) - i;\n    if (((x * x) + (y * y)) < ((FILTER_SIZE / 2) * (FILTER_SIZE / 2)))\n    {\n      blurKernel[(i * FILTER_SIZE) + j] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(i) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/azdavis/parallel-portrait-mode/code/main-ispc/1"}
{"code": "for (int i = 0; i < (*tam); i++)\n{\n  vetorInvertido[i] = vet[((*tam) - i) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/13"}
{"code": "for (int s = 0; s < N; s++)\n{\n  A[s + (s * N)] = vec[s];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/goceee/jacobi-openmp/Parallellised/jacobi/3"}
{"code": "for (; height--; src += src_step, dstX += dst_step, dstY += dst_step)\n{\n  const float *src2 = src + src_step;\n  const float *src3 = src + (src_step * 2);\n  for (x = 0; x < src_width; x++)\n  {\n    float t0 = ((src3[x] + src[x]) * smooth_k[0]) + (src2[x] * smooth_k[1]);\n    float t1 = src3[x] - src[x];\n    buffer0[x] = t0;\n    buffer1[x] = t1;\n  }\n\n  for (x = 0; x < dst_width; x++)\n  {\n    float t0 = buffer0[x + 2] - buffer0[x];\n    float t1 = ((buffer1[x] + buffer1[x + 2]) * smooth_k[0]) + (buffer1[x + 1] * smooth_k[1]);\n    dstX[x] = t0;\n    dstY[x] = t1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/1"}
{"code": "for (int i = (8 * n) / 16; i < ((9 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/16"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < num_threads; j++)\n  {\n    new_clusters[i][0] += local_clusters[j][i][0];\n    new_clusters[i][0] = 2;\n    new_clusters[i][1] += local_clusters[j][i][1];\n    new_clusters[i][2] += local_clusters[j][i][2];\n    local_clusters[j][i][0] = (local_clusters[j][i][1] = (local_clusters[j][i][2] = 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbish/pc-means/par_kmeans/8"}
{"code": "for (i = 0; i < n; i++)\n  fprintf(fp, \"%d\\t%d\\n\", i, buffer[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/part1/1"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  if (is_result_vec)\n  {\n    vec[i] = 0;\n  }\n  else\n  {\n    vec[i] = (rand() % 100) + i;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/matrice_vector/src/main/1"}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = 0; j < numf2s; j++)\n  if (j == (numf2s - 1))\n  printf(\" %8.16f\\n\", bus[i][j]);\nelse\n  printf(\" %8.16f \", bus[i][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/16"}
{"code": "for (size_t i = 0; i < a.r; ++i)\n{\n  for (size_t k = 0; k < a.c; ++k)\n  {\n    int32_t r_elem = a(i, k);\n    if (r_elem != 0)\n    {\n      for (size_t j = 0; j < b.c; ++j)\n      {\n        int32_t c_elem = b(k, j);\n        if (c_elem != 0)\n        {\n          c(i, j) += r_elem * c_elem;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(c) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zambonin/lovelace/matrix-mult/smm/1"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if (choice)\n    printf(\"Thread #%d is doing row %d.\\n\", th_id, i);\n\n  for (j = 0; j < dim; j++)\n  {\n    *(result + (j + (i * dim))) = 0;\n    for (k = 0; k < dim; k++)\n      *(result + (j + (i * dim))) += (*(mat1 + (k + (i * dim)))) * (*(mat2 + (j + (k * dim))));\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided,part_rows)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anishmrao/MultithreadMatrixMul/mattry/0"}
{"code": "for (ie = 0; ie < nmor; ie++)\n{\n  tmor[ie] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/2"}
{"code": "for (int par = 0; par < threads; par++)\n{\n  unsigned long long istart = (n * par) / threads;\n  unsigned long long s = (actseed << 16) | 13070ull;\n  s = skiprnd_tz(s, istart);\n  unsigned short xsubi[3] = {(unsigned short) s, (unsigned short) (s >> 16), (unsigned short) (s >> 32)};\n  for (unsigned long long i = (n * par) / threads; i < ((n * (par + 1)) / threads); i++)\n  {\n    r += erand48(xsubi);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:r)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/0"}
{"code": "for (i = 0; i < (1 << 16); i++)\n{\n  double *_imopVarPre16;\n  double *_imopVarPre17;\n  double _imopVarPre18;\n  _imopVarPre16 = &a;\n  _imopVarPre17 = &seed;\n  _imopVarPre18 = randlc(_imopVarPre17, _imopVarPre16);\n  x = _imopVarPre18;\n  double *_imopVarPre21;\n  double *_imopVarPre22;\n  double _imopVarPre23;\n  _imopVarPre21 = &a;\n  _imopVarPre22 = &seed;\n  _imopVarPre23 = randlc(_imopVarPre22, _imopVarPre21);\n  x += _imopVarPre23;\n  double *_imopVarPre26;\n  double *_imopVarPre27;\n  double _imopVarPre28;\n  _imopVarPre26 = &a;\n  _imopVarPre27 = &seed;\n  _imopVarPre28 = randlc(_imopVarPre27, _imopVarPre26);\n  x += _imopVarPre28;\n  double *_imopVarPre31;\n  double *_imopVarPre32;\n  double _imopVarPre33;\n  _imopVarPre31 = &a;\n  _imopVarPre32 = &seed;\n  _imopVarPre33 = randlc(_imopVarPre32, _imopVarPre31);\n  x += _imopVarPre33;\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/2"}
{"code": "for (int i = 0; i <= m_nSubbasins; i++)\n{\n  m_surfqToCh[i] = 0.f;\n  m_sedToCh[i] = 0.f;\n  m_surNO3ToCh[i] = 0.f;\n  m_surNH4ToCh[i] = 0.f;\n  m_surSolPToCh[i] = 0.f;\n  m_surCodToCh[i] = 0.f;\n  m_sedOrgNToCh[i] = 0.f;\n  m_sedOrgPToCh[i] = 0.f;\n  m_sedMinPAToCh[i] = 0.f;\n  m_sedMinPSToCh[i] = 0.f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IMP_SWAT/pothole_SWAT/1"}
{"code": "for (int i = 1; i < (HEIGHT + 1); i++)\n{\n  for (int j = 1; j < (WIDTH + 1); j++)\n  {\n    if (mesh[i][j].isEmpty())\n    {\n      continue;\n    }\n\n    if (mesh[i][j].getStage() == HUMAN)\n    {\n      if (mesh[i][j].getGender() == MALE)\n      {\n        male += 1;\n      }\n      else\n      {\n        female += 1;\n      }\n\n    }\n\n    if (mesh[i][j].getAge() == YOUNG)\n    {\n      young += 1;\n    }\n    else\n      if (mesh[i][j].getAge() == ADULT)\n    {\n      adult += 1;\n    }\n    else\n    {\n      elderly += 1;\n    }\n\n\n    if (mesh[i][j].getStage() == HUMAN)\n    {\n      human += 1;\n    }\n    else\n      if (mesh[i][j].getStage() == INFECTED)\n    {\n      infected += 1;\n    }\n    else\n    {\n      zombie += 1;\n    }\n\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) collapse(2) shared(mesh) reduction(+:male,female,young,adult,elderly,human,infected,zombie) num_threads(nThreads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yang0228/zombieApocalypse-MPI-OPENMP/stage2/4"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  graph[i][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parthvshah/parallel-prims/src/par/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpozl1qqg9.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (i = 0; i < fftblock; i++)\n{\n  x[j][i].real = y[j][i].real;\n  x[j][i].imag = y[j][i].imag;\n}\n\n", "pragma": "omp parallel for firstprivate(fftblock ,y ,x ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/15"}
{"code": "for (unsigned int i = 0; i < write_destination->size(); i++)\n{\n  (*write_destination)[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  tmpi = dsecnd_();\n  dgemm_(&transa, &transb, &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc);\n  tmpi = dsecnd_() - tmpi;\n  if ((i == 0) || (tmpi < t1))\n    t1 = tmpi;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/5"}
{"code": "for (i = 0; i < n; i++)\n  scanf(\"%d\", &a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jskankurgarg/Multicore_OpenMP_CUDA/openMP/navanshu/1"}
{"code": "for (i = 0; i < out_loops; i++)\n{\n  for (int j = 0; j < in_loops; j++)\n    stock[j] = run_black_scholes_model(spot_price, time_steps, risk_rate, volatility);\n\n  avg_stock[i] = find_2d_mean(stock, in_loops, time_steps);\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RajdeepKonwar/stockast/stockast/4"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  tmp = tmp + (qbnew[0][0][i - 1] * tx[0][0][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/8"}
{"code": "for (my_current_person_id = 0; my_current_person_id <= (our_number_of_people - 1); my_current_person_id++)\n{\n  if (our_states[my_current_person_id] != DEAD)\n  {\n    my_x_move_direction = (random() % 3) - 1;\n    my_y_move_direction = (random() % 3) - 1;\n    if (((((our_x_locations[my_current_person_id] + my_x_move_direction) >= 0) && ((our_x_locations[my_current_person_id] + my_x_move_direction) < environment_width)) && ((our_y_locations[my_current_person_id] + my_y_move_direction) >= 0)) && ((our_y_locations[my_current_person_id] + my_y_move_direction) < environment_height))\n    {\n      our_x_locations[my_current_person_id] += my_x_move_direction;\n      our_y_locations[my_current_person_id] += my_y_move_direction;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(my_current_person_id, my_x_move_direction, my_y_move_direction)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/pandemic/pandemic/4"}
{"code": "for (i = 0; i < (width * height); i++)\n{\n  retval[i] = (uint8_t) out[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheTwoOfUs/video-canny-edge-detection/mpi-omp/mpi-omp/6"}
{"code": "for (int i = 1; i <= n1; ++i)\n{\n  for (int j = 1; j <= n2; ++j)\n  {\n    (file << w1[i][j]) << \" \";\n  }\n\n  file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/19"}
{"code": "for (j = 0; j < _PB_N; j++)\n  C[i][j] += 42;\n\n", "pragma": "omp parallel for firstprivate(j ,C ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/utilities/template-for-new-benchmark/3"}
{"code": "for (int i = 0; i < mSize; i++)\n{\n  printf(\"[\");\n  for (int j = 0; j < mSize; j++)\n    printf(\"%d, \", mat[i][j]);\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab4/lab4/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  int id_w = omp_get_thread_num();\n  for (j = 0; j < 10; j++)\n  {\n    suma_parallel += a[i][j];\n    printf(\"(%2d,%2d)-W(%1d,%1d) \", i, j, id_w, omp_get_thread_num());\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for ordered reduction(+:suma_parallel) default(none) shared(a) private(j) schedule(static,2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_9/openmp_petle/0"}
{"code": "for (int i = 0; i < n; i++)\n  arr[i] = rand() % 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/OpenMP_Tasks/bubbleSort/2"}
{"code": "for (int ci = 0; ci < NCELLS; ci++)\n{\n  for (int cj = ci + 1; cj < NCELLS; cj++)\n    setContact(ci, cj, 0);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/32"}
{"code": "for (int i = 0; i < edge_list_size; i++)\n{\n  fscanf(fp, \"%d\", &id);\n  fscanf(fp, \"%d\", &cost);\n  h_graph_edges[i] = id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/bfs/src/bfs-AI-AI/3"}
{"code": "for (int i = 0; i < nProcesses; i++)\n  for (int j = 0; j < 2; j++)\n  auxiliary_buffs[i][j] = (unsigned char *) malloc(dimensiune_line * (sizeof(unsigned char *)));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/15"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int rank_task_size = tasks[i].size();\n  int task_penalties[rank_task_size];\n  MPI_Recv(task_penalties, rank_task_size, MPI_INT, i, collect_results_tag2, comm, &status);\n  char buffer[sha512_strlen];\n  for (int j = 0; j < rank_task_size; j++)\n  {\n    int task_id = tasks[i].at(j).z;\n    penalties[task_id] = task_penalties[j];\n    MPI_Recv(buffer, 128, MPI_CHAR, i, collect_results_tag3, comm, &status);\n    answers_hash[task_id] = string(buffer, 128);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing5/test/1"}
{"code": "for (i = 0; i < rows; i++)\n  sumRow[i] = sum(&mat[i * columns], columns);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AdoniasAlcantara/project4-omp/src/parallel/8"}
{"code": "for (i = 0; i < city_num; i++)\n{\n  char buffer[1000];\n  char *num_ptr;\n  num_ptr = fgets(buffer, 1000, fp);\n  int offset = i * city_num;\n  for (j = 0; j < city_num; j++)\n  {\n    map[offset + j] = strtol(num_ptr, &num_ptr, 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/4"}
{"code": "for (size_t i = 0; i < compressor.image_height; i++)\n{\n  output_rows_buffer[i] = &output_buffer[i * output_image_row_length];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/grayscaler-openmp/main/4"}
{"code": "for (int YIdx = 0; YIdx < PixelsPerMCU; ++YIdx)\n  LoadY(&MCU[YIdx], &input(row, (InputComponentsPerMCU * MCUIdx) + YIdx));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/interpolators/Cr2sRawInterpolator/0"}
{"code": "for (i = 0; i < N; i++)\n  vec[i] = a[i] + b[i];\n\n", "pragma": "    #pragma omp parallel for shared(a, b, vec) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziminyuri/AMP-OpenMP/AMP/1"}
{"code": "for (int i = 0; i < tmp.height; i++)\n{\n  int maxIndex = i;\n  for (int j = i; j < tmp.height; j++)\n  {\n    if (abs(tmp.data[j][i]) > abs(tmp.data[maxIndex][i]))\n    {\n      maxIndex = j;\n    }\n\n  }\n\n  if (maxIndex != i)\n  {\n    float tmpFloat = 0;\n    for (int k = 0; k < tmp.width; k++)\n    {\n      tmpFloat = tmp.data[i][k];\n      tmp.data[i][k] = tmp.data[maxIndex][k];\n      tmp.data[maxIndex][k] = tmpFloat;\n    }\n\n  }\n\n  if (tmp.data[i][i] == 0)\n  {\n    index++;\n    *errors = true;\n    continue;\n  }\n\n  for (int j = i + 1; j < tmp.height; j++)\n  {\n    float tmpFloat = tmp.data[j][i];\n    for (int k = 0; k < tmp.width; k++)\n    {\n      tmp.data[j][k] = tmp.data[j][k] - ((tmpFloat * tmp.data[i][k]) / tmp.data[i][i]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PiotrMydlowski/Gauss-Elimination/main/1"}
{"code": "for (i = 0; i < m; ++i)\n{\n  cen[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/debug-info-openmp-array/0"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    v[i][j][k][m] = v[i][j][k][m] - (omega * (((((ldz[i][j][m][0] * v[i][j][k - 1][0]) + (ldz[i][j][m][1] * v[i][j][k - 1][1])) + (ldz[i][j][m][2] * v[i][j][k - 1][2])) + (ldz[i][j][m][3] * v[i][j][k - 1][3])) + (ldz[i][j][m][4] * v[i][j][k - 1][4])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/1"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      if (z[i3][i2][i1] > ten[0][1])\n      {\n        ten[0][1] = z[i3][i2][i1];\n        j1[0][1] = i1;\n        j2[0][1] = i2;\n        j3[0][1] = i3;\n        bubble(ten, j1, j2, j3, 10, 1);\n      }\n\n      if (z[i3][i2][i1] < ten[0][0])\n      {\n        ten[0][0] = z[i3][i2][i1];\n        j1[0][0] = i1;\n        j2[0][0] = i2;\n        j3[0][0] = i3;\n        bubble(ten, j1, j2, j3, 10, 0);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/23"}
{"code": "for (int i = 0; i < ((n - k) - 1); i++)\n{\n  utemp[i] = u[k][(i + k) + 1];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/7"}
{"code": "for (size_t k = 0; k < (m_height * m_width); ++k)\n{\n  wvprod[k] = prod(vsp, vind, vsz, codebook + (k * m_dim));\n  const double dst = squared_sum[k] - (2 * (wvprod[k] * w_coeff[k]));\n  if (dst < dStar)\n  {\n    idx = k;\n    dStar = dst;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/som/3"}
{"code": "for (i = 1; i < (sizeof(count)); i++)\n{\n  count[0] += count[i];\n  avP[0] += avP[i];\n  if (minP[0] > minP[i])\n    minP[0] = minP[i];\n\n  if (maxP[0] < maxP[i])\n    maxP[0] = maxP[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical2/simil7/1"}
{"code": "for (i = 1; i <= n2; i++)\n{\n  if (percentDiff(l2[i], l2_gpu[i]) > 0.00)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/backprop/src/backprop/0"}
{"code": "for (l = 0; l < 1024; l++)\n{\n  for (l1 = 0; l1 < 1024; l1++)\n  {\n    C[l][l1] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/1"}
{"code": "for (int i = 0; i < numThreads; i++)\n{\n  int *LQ = TQ[i];\n  int *lindx = &tindx[i];\n  if ((*lindx) > 0)\n  {\n    int start = __sync_fetch_and_add(&Qindx, *lindx);\n    int count = 0;\n    for (int k = start; k < (start + (*lindx)); k++)\n    {\n      Q2[k] = TQ[i][count];\n      count++;\n    }\n\n    *lindx = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/bSuitorD/3"}
{"code": "for (int32_t i = 0; i < 10; i++)\n  sum[i].x = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_09/0"}
{"code": "for (int i = binf; i < bsup; i++)\n{\n  x[i] += alpha * p[i];\n  r[i] -= alpha * q[i];\n  z[i] = r[i] / d[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP/cg/3"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      DxDxu[pp] = (((((-u[pp - 2]) + (16.0 * u[pp - 1])) - (30.0 * u[pp])) + (16.0 * u[pp + 1])) - u[pp + 2]) * idx_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/7"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 0;\n  for (int j = 0; j < N; j++)\n  {\n    a[i] += j;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/check_time/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  scanf(\"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment1/lab1_10/0"}
{"code": "for (j = first; j < (1000 - 1); j += 1)\n{\n  if (A[j] > A[j + 1])\n  {\n    swap(&A[j], &A[j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none),shared(A,first,N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anushaasaad/comparsion-of-sorting-algorithms-using-Pthreads-OpenMP/BubbleOpenMP/0"}
{"code": "for (j = 0; j < SIZE; j++)\n{\n  {\n    for (i = 0; i < SIZE; i++)\n    {\n      y[j] = y[j] + (A[j][i] * x[i]);\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jar-evans/Krylov_subspace_methods/c_openmp/libeig_pair/0"}
{"code": "for (i = kypi - 1; i < kypt; i++)\n{\n  joff = (2 * nxvh) * i;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 * j) + joff]);\n    f[(2 * j) + joff] = crealf(f[(2 * j) + joff]) + (crealf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n    f[(1 + (2 * j)) + joff] = at1 + (cimagf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(2 * j1) + joff];\n      t2 = f[(1 + (2 * j1)) + joff];\n      f[(2 * j1) + joff] = f[(2 * j) + joff];\n      f[(1 + (2 * j1)) + joff] = f[(1 + (2 * j)) + joff];\n      f[(2 * j) + joff] = t1;\n      f[(1 + (2 * j)) + joff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indx1; m++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = sct[kmr * j];\n        t1 = s * f[(2 * j2) + joff];\n        t2 = s * f[(1 + (2 * j2)) + joff];\n        f[(2 * j2) + joff] = f[(2 * j1) + joff] - t1;\n        f[(1 + (2 * j2)) + joff] = f[(1 + (2 * j1)) + joff] - t2;\n        f[(2 * j1) + joff] += t1;\n        f[(1 + (2 * j1)) + joff] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t1 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < 2; k++)\n    {\n      t = conjf(f[(k + (2 * (nxh - j))) + joff]);\n      s = f[(k + (2 * j)) + joff] + t;\n      t = (f[(k + (2 * j)) + joff] - t) * t1;\n      f[(k + (2 * j)) + joff] = ani * (s + t);\n      f[(k + (2 * (nxh - j))) + joff] = ani * conjf(s - t);\n    }\n\n  }\n\n  for (k = 0; k < 2; k++)\n  {\n    f[k + joff] = (2.0 * ani) * ((crealf(f[k + joff]) + cimagf(f[k + joff])) + ((crealf(f[k + joff]) - cimagf(f[k + joff])) * _Complex_I));\n    if (nxhh > 0)\n      f[(k + (2 * nxhh)) + joff] = (2.0 * ani) * conjf(f[(k + (2 * nxhh)) + joff]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,joff,at1,s,t,t1,t2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mppic2/mppush2/3"}
{"code": "for (i = 1; i < nOfLayers; i++)\n{\n  for (int j = 0; j < layers[i].nOfNeurons; j++)\n  {\n    for (int k = 0; k < (layers[i - 1].nOfNeurons + 1); k++)\n    {\n      if (layers[i].neurons[j].w != NULL)\n      {\n        layers[i].neurons[j].w[k] = randomDouble(-1, 1);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/0"}
{"code": "for (i = 0; i < iter_13; i++)\n{\n  if ((i % 2) == 0)\n  {\n    OFFLOAD_STATUS_INIT(offstat_13);\n    #pragma offload_transfer target(mic:0) mandatory status(offstat_13) if(i!=iter_13-1) in(in2_13 : length(cnt_13) alloc_if(0) free_if(0) ) signal(in2_13)\n    if (i != (iter_13 - 1))\n    {\n      off_num = (iter_13 * 30) + i;\n      chk_offstat13(offstat_13, off_num);\n    }\n\n    OFFLOAD_STATUS_INIT(offstat_13);\n    #pragma offload target(mic:0) mandatory status(offstat_13) nocopy(in1_13) out(res1_13 : length(cnt_13) alloc_if(0) free_if(0) ) wait(in1_13)\n    {\n      compute13(in1_13, res1_13);\n    }\n    off_num = (iter_13 * 40) + i;\n    chk_offstat13(offstat_13, off_num);\n    lsum = lsum + sum_array13(res1_13);\n  }\n  else\n  {\n    OFFLOAD_STATUS_INIT(offstat_13);\n    #pragma offload_transfer target(mic:0) mandatory status(offstat_13) if(i!=iter_13-1) in(in1_13 : length(cnt_13) alloc_if(0) free_if(0) ) signal(in1_13)\n    if (i != (iter_13 - 1))\n    {\n      off_num = (iter_13 * 50) + i;\n      chk_offstat13(offstat_13, off_num);\n    }\n\n    OFFLOAD_STATUS_INIT(offstat_13);\n    #pragma offload target(mic:0) mandatory status(offstat_13) nocopy(in2_13) out(res2_13 : length(cnt_13) alloc_if(0) free_if(0) ) wait(in2_13)\n    {\n      compute13(in2_13, res2_13);\n    }\n    off_num = (iter_13 * 60) + i;\n    chk_offstat13(offstat_13, off_num);\n    lsum = lsum + sum_array13(res2_13);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/samples_2016/en/compiler_c/psxe/mic_samples/intro_sampleC/src/sampleC13/2"}
{"code": "for (i = 0; i < 6; i++)\n{\n  printf(\"Thread %d: Adding %d * %d to sum \\n\", tid, nums[i], nums3[i]);\n  sum += nums[i] * nums3[i];\n}\n\n", "pragma": "\t\t#pragma omp for schedule(guided,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wibeck/c-edu/ParallelTest/ForExample/4"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_SHA1_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-sha1_fmt_plug/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  SPMaVecProNd(MX, q, p, n, i);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SPMaVecPro/0"}
{"code": "for (i = 0; i < topoinfo->numR; i++)\n{\n  tmprlt->paras[((3 * i) + 1) + (2 * topoinfo->numG)] = randd(topoinfo->prsrandrange[0][((3 * i) + 1) + (2 * topoinfo->numG)], topoinfo->prsrandrange[1][((3 * i) + 1) + (2 * topoinfo->numG)], simu_opts->dist);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/69"}
{"code": "for (int i = (M / STRIDE) * STRIDE; i <= (M - 4); i += 4)\n{\n  for (int j = 0; j <= (N - 4); j += 4)\n  {\n    double *Cij = (C + i) + (j * lda);\n    c_col_0 = _mm256_load_pd(Cij);\n    c_col_1 = _mm256_load_pd(Cij + lda);\n    c_col_2 = _mm256_load_pd(Cij + (2 * lda));\n    c_col_3 = _mm256_load_pd(Cij + (3 * lda));\n    int a_row_k_first_half;\n    for (int k = 0; k < K; ++k)\n    {\n      a_row_k_first_half = _mm256_load_pd(A + (((((i / STRIDE) * STRIDE) * lda) + (k * STRIDE)) + (i % STRIDE)));\n      b_k0 = _mm256_set1_pd(B[k + (j * lda)]);\n      b_k1 = _mm256_set1_pd(B[k + ((j + 1) * lda)]);\n      b_k2 = _mm256_set1_pd(B[k + ((j + 2) * lda)]);\n      b_k3 = _mm256_set1_pd(B[k + ((j + 3) * lda)]);\n      c_col_0 = _mm256_fmadd_pd(a_row_k_first_half, b_k0, c_col_0);\n      c_col_1 = _mm256_fmadd_pd(a_row_k_first_half, b_k1, c_col_1);\n      c_col_2 = _mm256_fmadd_pd(a_row_k_first_half, b_k2, c_col_2);\n      c_col_3 = _mm256_fmadd_pd(a_row_k_first_half, b_k3, c_col_3);\n    }\n\n    _mm256_store_pd(Cij, c_col_0);\n    _mm256_store_pd(Cij + lda, c_col_1);\n    _mm256_store_pd(Cij + (2 * lda), c_col_2);\n    _mm256_store_pd(Cij + (3 * lda), c_col_3);\n  }\n\n  for (int j = (N / 4) * 4; j < N; j++)\n  {\n    c_col_0 = _mm256_load_pd((C + i) + (j * lda));\n    int a_row_k_first_half;\n    for (int k = 0; k < K; k++)\n    {\n      a_row_k_first_half = _mm256_load_pd(A + ((i * lda) + (k * STRIDE)));\n      b_k0 = _mm256_broadcast_sd((B + k) + (j * lda));\n      c_col_0 = _mm256_fmadd_pd(a_row_k_first_half, b_k0, c_col_0);\n    }\n\n    _mm256_store_pd((C + i) + (j * lda), c_col_0);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-bad/8"}
{"code": "for (i = 0; i < (1 << 25); i++)\n  key_buff2[i] = 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/23"}
{"code": "for (i = 0; i < ARCHmatrixlen; i++)\n{\n  fscanf(packfile, \"%d\", &newrow);\n  fscanf(packfile, \"%d\", &ARCHmatrixcol[i]);\n  while (oldrow < newrow)\n  {\n    if ((oldrow + 1) >= (ARCHnodes + 1))\n    {\n      printf(\"quake: error: (1)idx buffer too small (%d >= %d)\\n\", oldrow + 1, ARCHnodes + 1);\n      arch_bail();\n    }\n\n    ARCHmatrixindex[++oldrow] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/28"}
{"code": "for (i = 0; i < 316; i++)\n{\n  for (j = 0; j < ((int) dof2n6); j++)\n  {\n    Kcell[i][j] = K0[count];\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/27"}
{"code": "for (i = 0; i < y; i++)\n{\n  for (j = 0; j < v; j++)\n  {\n    aux[(i * v) + j] = 0.0;\n    for (k = 0; k < w; k++)\n    {\n      aux[(i * v) + j] = aux[(i * v) + j] + (matrizA[(i * w) + k] * matrizB[(k * v) + j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EliseuPHP/PAD/OpenMP/src/exerc/0"}
{"code": "for (unsigned int i = 0; i < number; i++)\n  if (is_alive[i])\n  dump_position_to_old_single(i);\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/9"}
{"code": "for (int i = start_row; i < end_row; i++)\n{\n  int nnzpv = nnzcum;\n  Crow[ip++] = nnzcum;\n  if ((nnzcum + Bm) > (*Csize))\n  {\n    *Csize += (Bm > ((*Csize) / 4)) ? (Bm) : ((*Csize) / 4);\n    *Ccol = realloc(*Ccol, (*Csize) * (sizeof(int)));\n  }\n\n  for (int jj = Arow[i]; jj < Arow[i + 1]; jj++)\n  {\n    int j = Acol[jj];\n    for (int kp = Brow[j]; kp < Brow[j + 1]; kp++)\n    {\n      int k = Bcol[kp];\n      if (!xb[k])\n      {\n        xb[k] = 1;\n        (*Ccol)[nnzcum] = k;\n        nnzcum++;\n      }\n\n    }\n\n  }\n\n  if (nnzcum > nnzpv)\n  {\n    quickSort(*Ccol, nnzpv, nnzcum - 1);\n    for (int p = nnzpv; p < nnzcum; p++)\n    {\n      xb[(*Ccol)[p]] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/1"}
{"code": "for (j = 0; j < 100; j++)\n{\n  sum += a[i][j] * v[j];\n}\n\n", "pragma": "omp parallel for private(j) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB061-matrixvector1-orig-no/3"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  lhs[i][j][k][1][m][m] = 1.0;\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/51"}
{"code": "for (int i = 0; i < NUMTPS902; i++)\n{\n  TP902Ptr[i] = nullptr;\n  TP902_alreadyLaunched[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/10"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/69"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    Du[IDX(3, j, k)] = (((u[IDX(6, j, k)] - (3.0 * u[IDX(5, j, k)])) + (3.0 * u[IDX(4, j, k)])) - u[IDX(3, j, k)]) / smr3;\n    Du[IDX(4, j, k)] = ((((u[IDX(7, j, k)] - (6.0 * u[IDX(6, j, k)])) + (12.0 * u[IDX(5, j, k)])) - (10.0 * u[IDX(4, j, k)])) + (3.0 * u[IDX(3, j, k)])) / smr2;\n    Du[IDX(5, j, k)] = (((((u[IDX(8, j, k)] - (6.0 * u[IDX(7, j, k)])) + (15.0 * u[IDX(6, j, k)])) - (19.0 * u[IDX(5, j, k)])) + (12.0 * u[IDX(4, j, k)])) - (3.0 * u[IDX(3, j, k)])) / smr1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/38"}
{"code": "for (j = 0; j < nxh; j++)\n{\n  v_at1 = _mm_loadl_pi(v_zero, (__m64 *) (&ffc[j]));\n  v_at1 = _mm_movelh_ps(v_at1, v_at1);\n  v_at1 = _mm_shuffle_ps(v_at1, v_at1, 245);\n  v_zt1 = _mm_load_ps((float *) (&exy[4 * j]));\n  v_zt2 = _mm_load_ps((float *) (&fxy[4 * j]));\n  v_zt2 = _mm_add_ps(v_zt2, _mm_mul_ps(v_zt1, v_at1));\n  _mm_store_ps((float *) (&fxy[4 * j]), v_zt2);\n  v_zt1 = _mm_load_ps((float *) (&exy[2 + (4 * j)]));\n  v_zt2 = _mm_load_ps((float *) (&fxy[2 + (4 * j)]));\n  v_zt2 = _mm_add_ps(v_zt2, _mm_mul_ps(v_zt1, v_at1));\n  _mm_store_ps((float *) (&fxy[2 + (4 * j)]), v_zt2);\n  v_zt1 = _mm_load_ps((float *) (&exy[(4 * j) + k1]));\n  v_zt2 = _mm_load_ps((float *) (&fxy[(4 * j) + k1]));\n  v_zt2 = _mm_add_ps(v_zt2, _mm_mul_ps(v_zt1, v_at1));\n  _mm_store_ps((float *) (&fxy[(4 * j) + k1]), v_zt2);\n  v_zt1 = _mm_load_ps((float *) (&exy[(2 + (4 * j)) + k1]));\n  v_zt2 = _mm_load_ps((float *) (&fxy[(2 + (4 * j)) + k1]));\n  v_zt2 = _mm_add_ps(v_zt2, _mm_mul_ps(v_zt1, v_at1));\n  _mm_store_ps((float *) (&fxy[(2 + (4 * j)) + k1]), v_zt2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/36"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  if (!vis[i])\n    dfs1(i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/2"}
{"code": "for (i = 0; i < numFilas; i++)\n{\n  nMatriz->datos[i] = (float *) malloc((sizeof(float)) * numColumnas);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaelmanzanorivera/matrix-dot-prod-optimization-OpenMP/matricesOmp/0"}
{"code": "for (is = 0; is < ns; is++)\n{\n  mc = 1 + round((M - 2) * rand_distr_init(rand_gen));\n  mc = MIN(M - 2, mc);\n  nc = 1 + round((N - 2) * rand_distr_init(rand_gen));\n  nc = MIN(N - 2, nc);\n  ss = 1 + round(((MIN(M, N) / 20) - 1) * rand_distr_init(rand_gen));\n  ss2 = 1 + ((ss * ss) / 4);\n  for (n = MAX(0, nc - ss); n < MIN(N - 1, nc + ss); n++)\n  {\n    for (m = MAX(0, mc - ss); m < MIN(M - 1, mc + ss); m++)\n    {\n      if ((((m - mc) * (m - mc)) + ((n - nc) * (n - nc))) < ss2)\n      {\n        k = COL_MAJOR_INDEX_2D(M, N, m, n);\n        u[k] = us;\n        v[k] = vs;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcduta/programming/reaction-diffusion/src/solution/1"}
{"code": "for (i = 0; i < L; i++)\n{\n  bitmask = 1;\n  r = (mult * ipset->itpoint[i].r) % order;\n  s = (mult * ipset->itpoint[i].s) % order;\n  nitpset->itpoint[i] = EMPTY_POINT;\n  for (j = 0; j < nbits; j++)\n  {\n    if (r & bitmask)\n    {\n      nitpset->itpoint[i] = addpoints(nitpset->itpoint[i], Psums[j], a, p, 0);\n    }\n\n    if (s & bitmask)\n    {\n      nitpset->itpoint[i] = addpoints(nitpset->itpoint[i], Qsums[j], a, p, 0);\n    }\n\n    bitmask = bitmask << 1;\n  }\n\n  nitpset->itpoint[i].r = r;\n  nitpset->itpoint[i].s = s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bumbleblo/ppd-openmp/vow_with_hash/7"}
{"code": "for (int i = 0; i < NumberOfBodies; i++)\n{\n  (((((out << x[i][0]) << \" \") << x[i][1]) << \" \") << x[i][2]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnabycollins/PSCI/step-4/0"}
{"code": "for (i = 0; i < num_elements; i++)\n  for (j = 0; j < i; j++)\n  U[(i * num_elements) + j] = 0.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/9"}
{"code": "for (i = 1; i <= lm; i++)\n{\n  for (j = 1; j <= n; j++)\n  {\n    psi[i][j] = psitmp[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i,j) shared(psi,psitmp,lm,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yvonnezou/Hybrid_MPI-OpenMP/Hybrid programme in single style/cfd/0"}
{"code": "for (int i = 0; i < ITERATIONS; i++)\n{\n  for (int id_fake = 0; id_fake < ((mask_height * mask_width) * c); id_fake++)\n  {\n    int channel = id_fake / (mask_height * mask_width);\n    int y = ((id_fake % (mask_height * mask_width)) / mask_width) + boundBoxMinY;\n    int x = ((id_fake % (mask_height * mask_width)) % mask_width) + boundBoxMinX;\n    int id = (x + (y * w)) + ((channel * w) * h);\n    int idx_nextX = ((x + 1) + (w * y)) + ((w * h) * channel);\n    int idx_prevX = ((x - 1) + (w * y)) + ((w * h) * channel);\n    int idx_nextY = (x + (w * (y + 1))) + ((w * h) * channel);\n    int idx_prevY = (x + (w * (y - 1))) + ((w * h) * channel);\n    if (boundary_array[id] == INSIDE_MASK)\n    {\n      double neighbor_target = ((targetimg[idx_nextY] + targetimg[idx_nextX]) + targetimg[idx_prevX]) + targetimg[idx_prevY];\n      double neighbor_output = ((outimg[idx_nextY] + outimg[idx_nextX]) + outimg[idx_prevX]) + outimg[idx_prevY];\n      outimg[id] = 0.25 * (((4 * targetimg[id]) - neighbor_target) + neighbor_output);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/13"}
{"code": "for (int r = lr + 1; (r < 6) && (this->board[lr][lc] == player); ++r)\n{\n  down++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/4"}
{"code": "for (i = 0; i < H; i++)\n{\n  for (j = 0; j < W; j++)\n  {\n    ligne[H] = matrice[H][W] + ligne[H];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP4/addition/1"}
{"code": "for (ni = 0; ni < n; ni++)\n{\n  if ((x[ni] == 0) && (y[ni] == 0))\n  {\n    continue;\n  }\n\n  int i0;\n  int j0;\n  int q;\n  int qi;\n  int i;\n  int j;\n  double weight0 = 0;\n  double weight1 = 0;\n  double difx;\n  double dify;\n  double weightx;\n  double weighty;\n  double visc_termx;\n  double visc_termy;\n  double du;\n  double dv;\n  double dr0;\n  double dwr;\n  i0 = (rb - 1) - ((int) (y[ni] / Dy));\n  j0 = x[ni] / Dx;\n  for (int psi = 0; psi < stencil_size; psi++)\n  {\n    i = i0 + stencil_x[psi];\n    j = j0 + stencil_y[psi];\n    bool out_of_bounds = stencilBoundaryCheck(i, j);\n    if (out_of_bounds == 1)\n    {\n      continue;\n    }\n\n    for (int k = 0; k < ndeg[(i * cb) + j]; k++)\n    {\n      q = (((i * cb) + j) * d) + k;\n      qi = jaret[q];\n      if (q == qi)\n      {\n        continue;\n      }\n\n      difx = x[qi] - x[ni];\n      dify = y[qi] - y[ni];\n      bool in_circle = circleCheck(difx, dify, Dx);\n      if (in_circle == 1)\n      {\n        du = u[qi] - u[ni];\n        dv = v[qi] - v[ni];\n        dr0 = sqrt((difx * difx) + (dify * dify));\n        dwr = gradKernel(dr0);\n        weightx = (dwr * difx) / (dr0 + 10e-20);\n        weighty = (dwr * dify) / (dr0 + 10e-20);\n        double mui = mu;\n        double muj = mu;\n        visc_termx = viscTensor(du, dr0, mui, muj, rho[ni], rho[qi], dwr);\n        visc_termy = viscTensor(dv, dr0, mui, muj, rho[ni], rho[qi], dwr);\n        double sum_termx = mass * (((((p[ni] / rho[ni]) / rho[ni]) + ((p[qi] / rho[qi]) / rho[qi])) * weightx) + visc_termx);\n        double sum_termy = mass * (((((p[ni] / rho[ni]) / rho[ni]) + ((p[qi] / rho[qi]) / rho[qi])) * weighty) + visc_termy);\n        fx[ni] += sum_termx;\n        fy[ni] += sum_termy;\n        drho[ni] += mass * ((du * weightx) + (dv * weighty));\n        if (qi > n)\n        {\n          rho[qi] += (mass * ((du * weightx) + (dv * weighty))) * dt;\n        }\n\n        if ((iter_cnt % 10) == 0)\n        {\n          weight0 += kernel(dr0);\n          weight1 += kernel(dr0) / rho[qi];\n        }\n\n      }\n\n    }\n\n  }\n\n  if ((iter_cnt % 10) == 0)\n  {\n    rho[ni] = weight0 / weight1;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(THREAD_NUM) schedule(guided, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/16"}
{"code": "for (j = 1; j < (m - 1); j++)\n  for (k = 0; k < 3; k++)\n  Q[i + (n * (j + (m * k)))] = Q[i + (n * (j + (m * k)))] - ((dt / dx) * (nFx[k][j + 1] - nFx[k][j]));\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/2"}
{"code": "for (int i = 0; i < LEVEL[level].size(); i++)\n{\n  calculate_pgrank_SCC(LEVEL[level][i]);\n}\n\n", "pragma": "       #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/goyalnishant/Openmp_Google_Page_Rank_Team-11/code/parallel_pgrank_optimized/4"}
{"code": "for (i = 0; i <= (nx - 1); i += 1)\n{\n  iglob = i;\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    exact(iglob, ny0 - 1, k, &u[i][ny - 1][k][0]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/141"}
{"code": "for (wJ = 0; wJ < BIGN; wJ++)\n{\n  fprintf(stdout, \"%f\\n\", aVect[wJ]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vectb/9"}
{"code": "for (int i = 0; i < numSharks; i++)\n{\n  int previousX = sharkArray[i].getX();\n  int previousY = sharkArray[i].getY();\n  if (sharkArray[i].checkNeighbourhood(sea))\n  {\n    sea[sharkArray[i].getX()][sharkArray[i].getY()] = Grid(shark);\n    removeFishObj(fishArray, sharkArray[i].getX(), sharkArray[i].getY());\n    numFish = fishArray.size();\n    if (sharkArray[i].canSharkBreed())\n    {\n      newShark++;\n      sharkArray[i].resetEnergy();\n      sharkArray.resize(numSharks + newShark);\n      sharkArray[(numSharks + newShark) - 1] = Shark();\n      sharkArray[(numSharks + newShark) - 1].setX(previousX);\n      sharkArray[(numSharks + newShark) - 1].setY(previousY);\n    }\n    else\n    {\n      sea[previousX][previousY] = Grid();\n    }\n\n  }\n  else\n  {\n    (makeDecision() < 0) ? (sharkArray[i].moveX(makeDecision())) : (sharkArray[i].moveY(makeDecision()));\n    if (sea[sharkArray[i].getX()][sharkArray[i].getY()].symbol == water)\n    {\n      sea[previousX][previousY] = Grid();\n      sharkArray[i].gettingHungry();\n      if (sharkArray[i].hasStarved())\n      {\n        sharkArray.erase(sharkArray.begin() + i);\n        numSharks--;\n      }\n      else\n      {\n        sea[sharkArray[i].getX()][sharkArray[i].getY()] = Grid(shark);\n      }\n\n    }\n    else\n    {\n      blocked++;\n      sharkArray[i].setX(previousX);\n      sharkArray[i].setY(previousY);\n      if (blocked < 10)\n      {\n        sharkArray[i].gettingHungry();\n        continue;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eamonngaynor/CDDProject/Concurrent Implementation/Optimization/main/6"}
{"code": "for (j = 0; j < LX1; j++)\n{\n  for (i = 0; i < LX1; i++)\n  {\n    dxtm1[j][i] = dxm1[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/12"}
{"code": "for (size_t k = myrank; k < (1920 * 1080); k += nprocs)\n{\n  int i = k % 1920;\n  int j = k / 1920;\n  real_t p_r = (-0.74323348754012) + (((2.0 * 1.E-7) / ((1920 < 1080) ? (1920) : (1080))) * (i - (1920 / 2)));\n  real_t p_i = 0.13121889397412 - (((2.0 * 1.E-7) / ((1920 < 1080) ? (1920) : (1080))) * (j - (1080 / 2)));\n  int index = mandelbrot(p_r, p_i);\n  uint8_t r = colormap[(3 * index) + 0];\n  uint8_t g = colormap[(3 * index) + 1];\n  uint8_t b = colormap[(3 * index) + 2];\n  sketch[(3 * k) + 0] = r;\n  sketch[(3 * k) + 1] = g;\n  sketch[(3 * k) + 2] = b;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/misc/mandelbrot/1"}
{"code": "for (unsigned cx = 0; cx < Nx; cx++)\n  for (unsigned cz = 0; cz < Nz; cz++)\n  scsv << PrintStr(\"vx_x%u_z%u\", cx, cz);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOutGridData/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[(i * n) + j] = fabs(sin((double) rand()));\n    t1_A[(i * n) + j] = (a1_A[(i * n) + j] = 0.);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MickiFoerster/spl-transformer/test-suite/adjoint-test-wt-p-threads/2"}
{"code": "for (i = 0; i < SIZE; i++)\n  for (j = 0; j < SIZE; j++)\n  elem->board[i][j] = inp[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/20"}
{"code": "for (int i = 0; i < row; i++)\n{\n  A1[i] = A2 + (i * col);\n}\n\n", "pragma": "    #pragma omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fini4631/openMP-Uebung01/matmult/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"id = %d, a[%d][%d]=%d \\n\", omp_get_thread_num(), i, j, a[i][j] = getRand());\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic,1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/0"}
{"code": "for (i = 1; i <= nt; i++)\n{\n  err = (sums[i].real - vdata_real_s[i]) / vdata_real_s[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_s[i]) / vdata_imag_s[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/10"}
{"code": "for (i = 0; i < seqLength; ++i)\n{\n  nextHiddenState(input_t, h_tminus1, c_tminus1, hiddenSize, miniBatch);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_naive/7"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/GEMM/gemm/1"}
{"code": "for (int process_iter = 0; process_iter < processes_count; process_iter++)\n{\n  chunk_size[process_iter] = chunk;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/3"}
{"code": "for (int i = 0; i < offset; i++)\n{\n  for (int j = 0; j < offset; j++)\n  {\n    if ((i == 0) && ((j == 0) || (j == (offset - 1))))\n      nnz += 3;\n    else\n      if ((i == (offset - 1)) && ((j == 0) || (j == (offset - 1))))\n      nnz += 3;\n    else\n      if ((i == 0) || (i == (offset - 1)))\n      nnz += 4;\n    else\n      if ((j == 0) || (j == (offset - 1)))\n      nnz += 4;\n    else\n      nnz += 5;\n\n\n\n\n    rowA_temp[i_unknown + 1] = nnz;\n    i_unknown++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\" Request for resource %d : \", i + 1);\n  scanf(\"%d\", &rmat[0][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephloochunhoe/parallel-computing/A1/Parallel_Bankers_Algorithm/4"}
{"code": "for (int p = 0; p < 10000; p++)\n  for (int i = 0; i < 10; i++)\n{\n  if (i == ((int) TEST_DATA[p][0]))\n    TEST_GOLDEN_OUTPUTS[p][i] = 0.9;\n  else\n    TEST_GOLDEN_OUTPUTS[p][i] = 0.1;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn05/3"}
{"code": "for (int i = 0; i <= (n - 2); i++)\n{\n  if (a[i] != (-1))\n  {\n    (cout << a[i]) << \"\\t\";\n  }\n\n}\n\n", "pragma": " #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac1/SeiveOfEratosthenesBoth/3"}
{"code": "for (i = 0; i <= (grid_rows - 1); i += 1)\n{\n  for (j = 0; j <= (grid_cols - 1); j += 1)\n  {\n    for (k = 0; k <= (layers - 1); k += 1)\n    {\n      sprintf(str, \"%d\\t%g\\n\", index, vect[((i * grid_cols) + j) + ((k * grid_rows) * grid_cols)]);\n      fputs(str, fp);\n      index++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/hotspot3D/3D/2"}
{"code": "for (j = 0; j < nx; j++)\n{\n  fxyz[(4 * (j + (nxe * ny))) + (nnxye * nz)] = fxyz[4 * j];\n  fxyz[(1 + (4 * (j + (nxe * ny)))) + (nnxye * nz)] = fxyz[1 + (4 * j)];\n  fxyz[(2 + (4 * (j + (nxe * ny)))) + (nnxye * nz)] = fxyz[2 + (4 * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/52"}
{"code": "for (int j = 0; j < (n + 1); j++)\n{\n  prev_row[j] = DP[j];\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/hybrid/row_wise_v2/space_optimized/row_wise_v2/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  graph->traverseSequential();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/2"}
{"code": "for (i = 0; i < dim_n; i++)\n{\n  for (j = 0; j < dim_n; j++)\n  {\n    A[(i * dim_n) + j] = drand48();\n    A_test[(i * dim_n) + j] = A[(i * dim_n) + j];\n    if (i == j)\n      B[(i * dim_n) + j] = 1;\n    else\n      B[(i * dim_n) + j] = 0;\n\n    B_test[(i * dim_n) + j] = B[(i * dim_n) + j];\n    RR[(i * dim_n) + j] = 0;\n    result[(i * dim_n) + j] = drand48();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZhixinLai/Parallel-Computing/Gaussian elimination with partial pivoting by OpenMP/gaussian/8"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  C[i] = (double *) malloc((sizeof(double)) * 1000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/multiply/4"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char pkey[1][32];\n  int i;\n  for (i = 0; i < 1; i++)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 32, 10204, pkey[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; i++)\n  {\n    if (dashlane_verify(cur_salt, pkey[i]))\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dashlane_fmt_plug/0"}
{"code": "for (int i = 0; i < num_bootstraps; ++i)\n{\n  bootstrap();\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) default(none) shared(num_bootstraps)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huaminghuangtw/Parallel-Sudoku-Solver/src/SudokuSolver_ParallelBruteForce/1"}
{"code": "for (i = xadj[v]; i < xadj[v + 1]; i++)\n{\n  u = adjncy[i];\n  if (inqueue[u] == 2)\n  {\n    continue;\n  }\n\n  if ((sps[u] < 0) || ((sps[v] + adjwgt[i]) < sps[u]))\n  {\n    sps[u] = sps[v] + adjwgt[i];\n    if (inqueue[u])\n    {\n      gk_fpqUpdate(queue, u, -sps[u]);\n    }\n    else\n    {\n      gk_fpqInsert(queue, u, -sps[u]);\n      inqueue[u] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/14"}
{"code": "for (j = 1; j < (y - 1); j++)\n{\n  left = -1;\n  for (k = 1; k < (z - 1); k++)\n  {\n    if ((dom[i][j][k] == 1) && (soundemitter[i][j][k] == 0))\n    {\n      if (dom[i][j][k - 1] != 1)\n      {\n        local_pressure_left = pressure_on_solid[i][j][k - 1];\n        left = k - 1;\n      }\n\n      if ((dom[i][j][k + 1] != 1) && (left > 0))\n      {\n        local_pressure_right = pressure_on_solid[i][j][k + 1];\n        right = k + 1;\n        if (fabs(local_pressure_left) > fabs(local_pressure_right))\n        {\n          pre[i][j][right] += obstalce_absorption_coefficient * local_pressure_left;\n          pre[i][j][left] = pre_old[i][j][left] + (pressure_on_solid[i][j][left] * sound_reflexion);\n        }\n\n        if (fabs(local_pressure_left) < fabs(local_pressure_right))\n        {\n          pre[i][j][left] += obstalce_absorption_coefficient * local_pressure_right;\n          pre[i][j][right] = pre_old[i][j][right] + (pressure_on_solid[i][j][right] * sound_reflexion);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/noise_generator/3"}
{"code": "for (int i = 0; i < numThreads; i++)\n{\n  pi += step * sum[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnwest/OpenMPConsoleApplication/OpenMPConsoleApplication/OpenMPConsoleApplication/2"}
{"code": "for (int r = 0; r < bmp->height; r++)\n{\n  for (int c = 0; c < bmp->width; c++)\n  {\n    bmp->pixels[(r * bmp->width) + c] = bmp->copy_pixels[(((r * bmp->width) + bmp->width) - 1) - c];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Victohu1/ParallelImageProcessor/openmp_image_processor/3"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < SDMGeom->L_NodeY(); j++)\n  {\n    for (int i = 0; i < KHALO; i++)\n    {\n      indx = IJK(((SNodeX() - KHALO) - PML.x) + i, HALO.y + j, HALO.z + k);\n      indx1 = (i + (j * KHALO)) + ((k * KHALO) * SDMGeom->L_NodeY());\n      var[indx] = bn_rx[(((indx_var - 1) * size) + indx1) + ((time * size) * 9)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/30"}
{"code": "for (i = 0; i < VECTOR_LENGTH; i++)\n{\n  ((((cout << \"Result of \") << A[i]) << \"  % 5 is  \") << B[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelrahmanmostafa/OpenMP-assignment1/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (max < n)\n  {\n    max = n;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    n = ((m - 3) + 1) * 5;\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/182"}
{"code": "for (i = 1; i <= T_max; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/8"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n  for (int j = 0; j < 10; ++j)\n  {\n    if (a[i] > b[j])\n      break;\n\n  }\n\n  switch (i)\n  {\n    case 1:\n      b[i]++;\n      break;\n\n    default:\n      break;\n\n  }\n\n  if (c[i] > 10)\n    break;\n\n  if (c[i] > 11)\n    break;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/50"}
{"code": "for (int i = 2; i < (nBins - 2); i++)\n{\n  hist[i] = ((((tmpHist[i - 2] + tmpHist[i + 2]) * 1.0f) / 16.0f) + (((tmpHist[i - 1] + tmpHist[i + 1]) * 4.0f) / 16.0f)) + ((tmpHist[i] * 6.0f) / 16.0f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/12"}
{"code": "for (i = 0; i < n; ++i)\n{\n  x[i] = (rand() % 32) / 32.0f;\n  y[i] = (rand() % 32) / 32.0f;\n  yhost[i] = (a * x[i]) + y[i];\n  yaccl[i] = 0.0f;\n}\n\n", "pragma": "omp parallel for default(none) shared(a, x, y, yhost, yaccl, n) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/saxpy-ompt-cuda/saxpy/0"}
{"code": "for (Max *prev; max != 0; max = prev)\n{\n  prev = max->prev;\n  state_free(&max->state);\n  free(max);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/parallel_data/1"}
{"code": "for (i = 0; i < 20; i++)\n  printf(\"%d\\n\", c[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/courspolytech/Presentation-exemplesOMP/sources/parallelfor+/2"}
{"code": "for (int j = col_start[taskid]; j < col_end[taskid]; j++)\n  qsort((buffer_col + columnPrefixSum[j]) - columnPrefixSum[col_start[taskid]], col_count[j], 12, cmpfunc2);\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/19"}
{"code": "for (int i = 0; i < 10; i++)\n  quantidade[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeGiacomoSimoes/OpenMP/vector_parallel_print/4"}
{"code": "for (i = 0; i < (1 << 26); i++)\n{\n  key = inp[i];\n  omp_set_lock(&lock[key]);\n  hist[key]++;\n  omp_unset_lock(&lock[key]);\n}\n\n", "pragma": "omp parallel for private(key) num_threads(64)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/04_locks/0"}
{"code": "for (int i = 0; i < 1; i++)\n{\n  cfftz(a);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/tests/nonsmoke/functional/roseTests/astOutliningTests/ft_cfftz_omp2/0"}
{"code": "for (k = iBegin; k < iEnd; k++)\n  tablica[k] = t[k];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TomaszAugustyn/multicore-mergesort-with-openmp/OpenMP2/main/1"}
{"code": "for (i = 0; i < cnt_13; i++)\n{\n  in1_13[i] = (float) (i * .001);\n  in2_13[i] = (float) (i * .001);\n  res1_13[i] = 0;\n  res2_13[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/samples_2016/en/compiler_c/psxe/mic_samples/intro_sampleC/src/sampleC13/5"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  if (DomainName != rGeometry[i].GetValue(MODEL_PART_NAME))\n  {\n    samesbd++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%d \\n\", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPreductionClause/1"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (k == 0)\n      {\n        if ((videoDiff[i][j][1] == 1) && (videoDiff[i][j][0] == 1))\n          videoDiffErod[i][j][k] = 1;\n        else\n          videoDiffErod[i][j][k] = 0;\n\n      }\n      else\n        if (k == (1080 - 1))\n      {\n        if ((videoDiff[i][j][1080 - 1] == 1) && (videoDiff[i][j][1080 - 2] == 1))\n          videoDiffErod[i][j][1080 - 1] = 1;\n        else\n          videoDiffErod[i][j][1080 - 1] = 0;\n\n      }\n      else\n        if (((videoDiff[i][j][k - 1] == 1) && (videoDiff[i][j][k] == 1)) && (videoDiff[i][j][k + 1] == 1))\n        videoDiffErod[i][j][k] = 1;\n      else\n        videoDiffErod[i][j][k] = 0;\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/2"}
{"code": "for (int i = 0; i < dim; ++i)\n{\n  for (int j = 0; j < dim; ++j)\n  {\n    double dot_product = 0;\n    for (int k = 0; k < dim; ++k)\n    {\n      dot_product += matrix1[i][k] * transposed[j][k];\n    }\n\n    result[i][j] = dot_product;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OC-ComputerScience/matrix/matrix/0"}
{"code": "for (i = 0; i < (num_cols * num_vectors); i++)\n  y_data[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/7"}
{"code": "for (int t = 0; t < NT; t++)\n{\n  (((f << energy[t]) << \",\") << error[t]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omi14098/Parallel-PDE-solvers/1D/omp1DPDE/3"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (TYPE) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(j * Ndim) + i] * xnew[j];\n\n  TYPE tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_coal/3"}
{"code": "for (i = 0; i < (256 / 32); i++)\n  for (j = 0; j < 8; j++)\n  for (k = 0; k < 8; k++)\n  if (c[i][j][k] != (3 * ((j >= 2) && ((k & 1) == 0))))\n  abort();\n\n\n\n\n", "pragma": "omp for collapse(3) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-1/5"}
{"code": "for (i = 0; i < num; i++)\n{\n  bytes = cbytes;\n  SHA1_Init(&ctx);\n  for (j = 0; j < i; j++)\n  {\n    SHA1_Update(&ctx, &b, 1);\n  }\n\n  while (bytes > (slen + 16))\n  {\n    SHA1_Update(&ctx, salt, 16);\n    SHA1_Update(&ctx, password, slen);\n    bytes -= slen + 16;\n  }\n\n  if (bytes <= 16)\n  {\n    SHA1_Update(&ctx, salt, bytes);\n  }\n  else\n  {\n    SHA1_Update(&ctx, salt, 16);\n    SHA1_Update(&ctx, password, bytes - 16);\n  }\n\n  SHA1_Final(key + (i * SHA_DIGEST_LENGTH), &ctx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pgpwde_fmt_plug/1"}
{"code": "for (i = 0; i <= length; i++)\n{\n  if (i <= n_A)\n    seqmerge(i * a, AA[i]);\n\n  if (j <= n_B)\n    seqmerge(BB[j - 1], j * b);\n\n  j++;\n}\n\n", "pragma": "omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/B/ass2-openmp/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a [%d] suma=%d\\n\", omp_get_thread_num(), i, suma);\n  printf(\"Valor de la variable dyn-var: %d \\n\", omp_get_dynamic());\n  printf(\"Valor de la variable nthreads_var: %d\\n\", omp_get_max_threads());\n  printf(\"Valor de la variable thread_limit-var: %d\\n\", omp_get_thread_limit());\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma) schedule(dynamic,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/scheduled_clauseModificado/0"}
{"code": "for (i = 0; i < pdf->total_size; i++)\n  pdf->PDF[i] = 0.0f;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  xvel = us[i][j][k];\n  yvel = vs[i][j][k];\n  zvel = ws[i][j][k];\n  ac = speed[i][j][k];\n  acinv = ainv[i][j][k];\n  ac2u = ac * ac;\n  r1 = rhs[0][i][j][k];\n  r2 = rhs[1][i][j][k];\n  r3 = rhs[2][i][j][k];\n  r4 = rhs[3][i][j][k];\n  r5 = rhs[4][i][j][k];\n  uzik1 = u[0][i][j][k];\n  btuz = bt * uzik1;\n  t1 = (btuz * acinv) * (r4 + r5);\n  t2 = r3 + t1;\n  t3 = btuz * (r4 - r5);\n  rhs[0][i][j][k] = t2;\n  rhs[1][i][j][k] = ((-uzik1) * r2) + (xvel * t2);\n  rhs[2][i][j][k] = (uzik1 * r1) + (yvel * t2);\n  rhs[3][i][j][k] = (zvel * t2) + t3;\n  rhs[4][i][j][k] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[i][j][k] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,xvel ,yvel ,zvel ,ac ,acinv ,r1 ,r2 ,r3 ,r4 ,r5 ,uzik1 ,btuz ,t1 ,t2 ,t3 ,bt ,c2iv ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/159"}
{"code": "for (int i = 0; i < (NX + 2); i++)\n{\n  u_val[i][0] = BVAL_LOWER;\n  u_val[i][NY + 1] = BVAL_UPPER;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nmac-dev/parallel-2D-advection/src/advection2D/4"}
{"code": "for (j_imopVarPre78 = 2; j_imopVarPre78 <= (nrows + 1); j_imopVarPre78++)\n{\n  rowstr[j_imopVarPre78] = rowstr[j_imopVarPre78] + rowstr[j_imopVarPre78 - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/24"}
{"code": "for (int i = 0; i < nFiringEvents; i++)\n  firingEvents[i] = firingEventsParameter[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/breyerml/OpenMP_Offloading_to_SYCL_mwe/hodgkin_huxley_1952_gpu_fast_monodomain.0/3"}
{"code": "for (i = 0; i < numOfPoints; i++)\n{\n  for (j = 0; j < threads_num; j++)\n  {\n    distances[i][j] = distance(centroidX[j], centroidY[j], myPoints[i][0], myPoints[i][1]);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oshaesam1/K-means-Clustering-using-openMp-FCAI-/main/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  found_c1 = 0;\n  found_c2 = 0;\n  size_g = getSize1((char *) group[i]);\n  for (j = 0; j < size_g; j++)\n  {\n    if ((found_c1 == 0) && ((*c1) == group[i][j]))\n    {\n      found_c1 = c1;\n    }\n\n    if ((found_c2 == 0) && ((*c2) == group[i][j]))\n    {\n      found_c2 = c2;\n    }\n\n    if ((found_c1 != 0) && (found_c2 != 0))\n    {\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/4"}
{"code": "for (int i = 1; i < x_points; i++)\n{\n  *(u_new + i) = (*(u + i)) - (((c * del_t) / del_x) * ((*(u + i)) - (*((u + i) - 1))));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/1-D_Linear_Convection/1-D_Linear_Convection_Dynamic/main/1"}
{"code": "for (i = 0; i < 4000;)\n{\n  for (j = 0; j < NJ;)\n  {\n    B[i][j] = ((((double) i) * j) + 1) / NJ;\n    j++;\n  }\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdruix/OMP2MPI/trans/test/6"}
{"code": "for (i = (jump * curr) + curr; i < root_m; i += jump)\n{\n  mark[i] = 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA2/sieve4/0"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  x[i] = (((((double) rand()) / 32767) * (((double) rand()) / 32767)) * (((double) rand()) / 32767)) * 1000;\n  if (x[i] > realmaxval)\n  {\n    realmaxval = x[i];\n    realmaxloc = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-3/parallel/1"}
{"code": "for (int i = 0; i < resultImage.height; i++)\n{\n  for (int j = 0; j < resultImage.width; j++)\n  {\n    resultImage.pixels[(i * resultImage.width) + j] = 255 - resultImage.pixels[(i * resultImage.width) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/r0-8y/openmp/imageProcessing/1"}
{"code": "for (int row = 0; row < 8; row++)\n{\n  for (int col = 0; col < 3; col++)\n  {\n    printf(\" %d \", arr[row][col]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/coderboyisongithub/OpenMP-MP-search/openMP/0"}
{"code": "for (int r = k - 1; r < n; r++)\n{\n  for (int s = k - 1; s < n; s++)\n  {\n    if (abs(augmentedMatrix[r][s]) > max)\n    {\n      max = abs(augmentedMatrix[r][s]);\n      maxRow = r;\n      maxColumn = s;\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for shared(max, maxRow, maxColumn)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/gaussianElimination/gaussianEliminationTotalPivot/0"}
{"code": "for (i = Low_h / 2; i < (Low_h - 2); i++)\n{\n  for (j = Low_w / 2; j < ((Low_w / 4) * 3); j++)\n  {\n    bicubic_Y_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Y[(i * Low_w) + j])) + (bicubic2[1][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Y_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Y[(i * Low_w) + j])) + (bicubic2[0][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/7"}
{"code": "for (int i = 0; i < nc; ++i)\n{\n  check[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/42"}
{"code": "for (int j = i - 1; j > (-1); j--)\n{\n  double divider = ((double) matrix[j][i]) / matrix[i][i];\n  vec[j][0] -= vec[i][0] * divider;\n}\n\n", "pragma": "omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/610yilingliu/Gaussian_Elimination_OpenMPVersion/main/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  amt_a += a[i];\n  amt_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: amt_a) reduction(+: amt_b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw6/main/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < len; j++)\n  {\n    printf(\"%lf\\n\", a[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB004-antidep2-var-yes/1"}
{"code": "for (int y = 0; y < ROWS; y++)\n{\n  for (int x = 0; x < COLS; x++)\n  {\n    result[y] += matrix_d[y][x] * vector[x];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wildDoubt/parallel-programming/source/practice8_2/0"}
{"code": "for (int i = 1; i < n_local; i++)\n{\n  tmp += ptr_local[i] - prec;\n  prec = ptr_local[i];\n  ptr_local[i] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/13"}
{"code": "for (j = N - 2; j >= 0; j--)\n{\n  for (k = 0; k <= j; k++)\n    A[(k * (N + 1)) + N] = A[(k * (N + 1)) + N] - (A[(k * (N + 1)) + (j + 1)] * X[j + 1]);\n\n  X[j] = A[(j * (N + 1)) + N] / A[(j * (N + 1)) + j];\n}\n\n", "pragma": "omp parallel for shared(A) private(k,j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Volodimirich/GaussOpenMp/gaussOp/2"}
{"code": "for (i = 0; i < np; i++)\n{\n  if (i != rank)\n  {\n    fprintf(stderr, \"root receving from %d...\\n\", i);\n    MPI_Recv(&nbb, 1, (MPI_Datatype) 0x4c000405, i, -1, (MPI_Comm) 0x44000000, &status);\n    tag = status.MPI_TAG;\n    while (tag != 0)\n    {\n      if (tag == 73)\n      {\n        MPI_Recv(image + (((3 * w) * nbb) * nlines), (3 * w) * nlines, (MPI_Datatype) 0x4c00080b, i, 73, (MPI_Comm) 0x44000000, &status);\n      }\n\n      MPI_Recv(&nbb, 1, (MPI_Datatype) 0x4c000405, i, -1, (MPI_Comm) 0x44000000, &status);\n      tag = status.MPI_TAG;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(tag, status, nbb) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_mpi-omp/pathracer_mpi-omp/0"}
{"code": "for (int x = 0; x < 100; x++)\n  compute();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/parallel-processing/OpenMP-Nbody/nbody/0"}
{"code": "for (t = 0; t < 1600; t++)\n{\n  for (i = t * stripeSize; i < min((t * stripeSize) + stripeSize, 1600); i++)\n  {\n    for (j = 0; j < 1600; j++)\n    {\n      double comp = 0.;\n      for (k = 0; k < 1600; k++)\n      {\n        comp += (*((a + (i * 1600)) + k)) * (*((b + (k * 1600)) + j));\n      }\n\n      *((c + (i * 1600)) + j) = comp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i,j,k,t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/matrix-multiply/omp-mat-mul/omp-mat-mul/0"}
{"code": "for (int i = 0; i < NPOINTS; ++i)\n{\n  for (int j = 0; j < NPOINTS; ++j)\n  {\n    c.r = ((-2.0) + ((2.5 * i) / NPOINTS)) + eps;\n    c.i = ((1.125 * j) / NPOINTS) + eps;\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattEding/OpenMP-Practice/Exercises/Ex5-Mandelbrot/mandel_struct/0"}
{"code": "for (i = 0; i < dim; i++)\n  for (j = 0; j < dim; j++)\n  AT[(i * dim) + j] = A[(j * dim) + i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/Openmp/FastTr_omp/1"}
{"code": "for (norm = 0., i = 0; i < n; i++)\n{\n  for (j = i; j < n; j++)\n    norm += (h[i][j] >= 0.) ? (h[i][j]) : (-h[i][j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/18"}
{"code": "for (int i = 0; i < n; i++)\n{\n  ans += x1[i] * x2[i];\n}\n\n", "pragma": "omp parallel for reduction(+:ans)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/0"}
{"code": "for (i = 0; i < 500; i++)\n  if (arr[i] < min)\n  min = arr[i];\n\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Dept-Labs/Parallel-Computing/Lab5/smallest/0"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] = 0.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/13"}
{"code": "for (i = 0; i < num; ++i)\n{\n  T cur = arr[(int) ind2];\n  ind2 += L;\n  sum += cur;\n}\n\n", "pragma": "#pragma omp for linear(ind2:L)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_linear_messages/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  var[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB161-nolocksimd-orig-gpu-yes/1"}
{"code": "for (int i = 0; i < MATRIX_SIZE; i++)\n{\n  for (int j = 0; j < MATRIX_SIZE; j++)\n  {\n    for (int k = 0; k < MATRIX_SIZE; k++)\n    {\n      A->data[i][j][k] = rand() % 10;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW3/matmul3d/1"}
{"code": "for (i = 0; i < 256; i++)\n{\n  x[i] = i;\n  y_var[i] = histogram[i];\n  y_norm[sk_round[i]] = histogram[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sirmisscriesalot/openmp_term_projects/src/histogram_equalization/6"}
{"code": "for (int k = 0; k <= Size; k++)\n{\n  double pMatrixTemp = pMatrix[(i * Size) + k];\n  pMatrix[(i * Size) + k] = pMatrix[(j * Size) + k];\n  pMatrix[(j * Size) + k] = pMatrixTemp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmarotti/less-openmp/src/gaussian_elimination/3"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  printf(\"myArray[%d]: %d\\n\", i, myArray[i]);\n  if ((SIZE > 1) && (myArray[i] != (outer * VAL)))\n  {\n    printf(\"Error! myArray[%d] is %d and should be %d\\n\", i, myArray[i], outer * VAL);\n    errors++;\n  }\n\n  if ((SIZE == 1) && (myArray[0] != (outer * SIZE)))\n  {\n    printf(\"Error! myArray[0] is %d and should be %d\\n\", myArray[0], outer * SIZE);\n    errors++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_array_section/reduction_array_section/1"}
{"code": "for (int i = 3; i < 7; i++)\n{\n  timer += record[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zonghan0904/2020_Fall_PP/Final_Project/OpenMP/omp/2"}
{"code": "for (int ix = 1; ix < (N + 1); ix++)\n{\n  for (int ix_f = 0; ix_f < (N + 2); ix_f++)\n  {\n    if (ix == ix_f)\n      continue;\n\n    forces[ix] = forces[ix] + ((grid[ix_f] / pow((float) (ix - ix_f), 2)) * copysign(1.0, ix - ix_f));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WarwickRSE/OpenMPExamples/Solutions/Repulsion/1"}
{"code": "for (i = 0; i <= T; i += 1)\n{\n  year[i].Res = (int **) malloc(n * (sizeof(int *)));\n  if (!year[i].Res)\n  {\n    printf(\"Alocarea nu a reusit!\\n\");\n    return -1;\n  }\n\n  year[i].P = (int **) malloc(n * (sizeof(int *)));\n  if (!year[i].P)\n  {\n    printf(\"Alocarea nu a reusit!\\n\");\n    return -1;\n  }\n\n  year[i].Cost = (int **) malloc(n * (sizeof(int *)));\n  if (!year[i].Cost)\n  {\n    printf(\"Alocarea nu a reusit!\\n\");\n    return -1;\n  }\n\n  year[i].B = (int **) malloc(n * (sizeof(int *)));\n  if (!year[i].B)\n  {\n    printf(\"Alocarea nu a reusit!\\n\");\n    return -1;\n  }\n\n  year[i].CostC = (int **) malloc(n * (sizeof(int *)));\n  if (!year[i].CostC)\n  {\n    printf(\"Alocarea nu a reusit!\\n\");\n    return -1;\n  }\n\n  for (j = 0; j < n; j += 1)\n  {\n    year[i].Res[j] = (int *) malloc(n * (sizeof(int)));\n    year[i].P[j] = (int *) malloc(n * (sizeof(int)));\n    year[i].Cost[j] = (int *) malloc(n * (sizeof(int)));\n    year[i].B[j] = (int *) malloc(n * (sizeof(int)));\n    year[i].CostC[j] = (int *) malloc(n * (sizeof(int)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elf11/Parallel-Processing/OpenMP/paralel/1"}
{"code": "for (i = 0; i < map_sz; i++)\n{\n  pheromone[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/5"}
{"code": "for (size_t i = round(size / 4); i < (3 * round(size / 8)); i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  sum = sum + max_;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/5/5/Source/8"}
{"code": "for (iteration = 0; iteration < CLOMP_num_iterations; iteration++)\n{\n  for (subcycle = 0; subcycle < 10; subcycle++)\n  {\n    partArray[0]->update_count = 1;\n    partArray[0]->firstZone->value = calc_deposit();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/1"}
{"code": "for (y = featureHeight; y < (imageHeight - featureHeight); y++)\n{\n  for (x = featureWidth; x < (imageWidth - featureWidth); x++)\n  {\n    float minimumSquaredDifference = -1;\n    int minimumDy = 0;\n    int minimumDx = 0;\n    for (int dy = -maximumDisplacement; dy <= maximumDisplacement; dy++)\n    {\n      for (int dx = -maximumDisplacement; dx <= maximumDisplacement; dx++)\n      {\n        if ((((((y + dy) - featureHeight) < 0) || (((y + dy) + featureHeight) >= imageHeight)) || (((x + dx) - featureWidth) < 0)) || (((x + dx) + featureWidth) >= imageWidth))\n        {\n          continue;\n        }\n\n        float squaredDifference = 0;\n        int rowWidth = (featureWidth * 2) + 1;\n        int remain = rowWidth;\n        int rowdifference = _mm_setzero_ps();\n        int tempLeft;\n        int tempRight;\n        int diff;\n        if ((minimumSquaredDifference < squaredDifference) && (minimumSquaredDifference != (-1)))\n        {\n          continue;\n        }\n\n        if (remain > 4)\n        {\n          for (int i = 0; i < ((rowWidth / 4) * 4); i += 4)\n          {\n            for (int boxY = -featureHeight; boxY <= featureHeight; boxY++)\n            {\n              int leftY = y + boxY;\n              int rightY = (y + dy) + boxY;\n              int leftX = x - featureWidth;\n              int rightX = (x + dx) - featureWidth;\n              tempLeft = _mm_loadu_ps(((left + (leftY * imageWidth)) + leftX) + i);\n              tempRight = _mm_loadu_ps(((right + (rightY * imageWidth)) + rightX) + i);\n              diff = _mm_sub_ps(tempLeft, tempRight);\n              rowdifference = _mm_add_ps(_mm_mul_ps(diff, diff), rowdifference);\n            }\n\n          }\n\n          squaredDifference += ((rowdifference[0] + rowdifference[1]) + rowdifference[2]) + rowdifference[3];\n          remain = remain % 4;\n        }\n\n        if ((minimumSquaredDifference < squaredDifference) && (minimumSquaredDifference != (-1)))\n        {\n          continue;\n        }\n\n        for (int i = (rowWidth / 4) * 4; i < rowWidth; i++)\n        {\n          for (int boxY = -featureHeight; boxY <= featureHeight; boxY++)\n          {\n            int leftY = y + boxY;\n            int rightY = (y + dy) + boxY;\n            int leftX = x - featureWidth;\n            int rightX = (x + dx) - featureWidth;\n            squaredDifference += (left[((leftY * imageWidth) + leftX) + i] - right[((rightY * imageWidth) + rightX) + i]) * (left[((leftY * imageWidth) + leftX) + i] - right[((rightY * imageWidth) + rightX) + i]);\n          }\n\n        }\n\n        if (((minimumSquaredDifference == (-1)) || ((minimumSquaredDifference == squaredDifference) && (displacementNaive(dx, dy) < displacementNaive(minimumDx, minimumDy)))) || (minimumSquaredDifference > squaredDifference))\n        {\n          minimumSquaredDifference = squaredDifference;\n          minimumDx = dx;\n          minimumDy = dy;\n        }\n\n      }\n\n    }\n\n    if ((minimumSquaredDifference != (-1)) && (maximumDisplacement != 0))\n    {\n      depth[(y * imageWidth) + x] = displacementNaive(minimumDx, minimumDy);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaocongliu/openMP/calcDepthOptimized/0"}
{"code": "for (int freq = 0; freq < 5; freq++)\n{\n  double time = gemm_simd_unroll(size, a, b, c, unroll);\n  counts.push_back(time);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_simd_unroll/0"}
{"code": "for (int dest = 1; dest < numtasks; dest++)\n{\n  MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, dest, 0, 1);\n  offset += chunksize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP2/MPI+OMP/mandelbrot_openmpi+omp/1"}
{"code": "for (i = 0; i < (HIgh_h / 2); i++)\n{\n  for (j = Low_w / 2; j < ((Low_w / 4) * 3); j++)\n  {\n    bicubic_Y[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Y[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/11"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/dotp/0"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n  A[j][i] = A[j][i] + A[j][0];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/MPI_omp_AVX_row/2"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j][k - 1][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/120"}
{"code": "for (unsigned long row = 0; row < m.Rows(); ++row)\n{\n  for (unsigned long column = 0; column < m.Columns(); ++column)\n  {\n    ((cout << \"\\t\") << setprecision(5)) << m(row, column);\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShariqueMohd/Parallel-Image-Compression-using-PCA/DenseMatrix/6"}
{"code": "for (i = 0; i < 10; ++i)\n  continue;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/block-2/4"}
{"code": "for (i = 1; i < 1024; i += 1)\n{\n  B[i] = A[i] + B[i - 1];\n}\n\n", "pragma": "omp target parallel for map(to:A) map(from:B)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hal-lab-u-tokyo/CGRAOmp/share/samples/simple_memdep/simple_memdep/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  current_y[i] = y_a[i];\n  current_k1[i] = 0.;\n  current_k2[i] = 0.;\n  current_k3[i] = 0.;\n  current_k4[i] = 0.;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example3/main/0"}
{"code": "for (size_t i = 0; i < Nqd; i++)\n{\n  for (size_t j = 0; j < Nelt; j++)\n  {\n    Kprev(i, j) *= (0.25 * g.lengths(j)) * g.lengths(g.prev(j));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/22"}
{"code": "for (int y = 0; y < 512; y++)\n{\n  for (int x = 0; x < 512; x++)\n  {\n    max_error = max(max_error, abs(output_image[(y * 512) + x] - output_image_ref[(y * 512) + x]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/affine-omp/main/1"}
{"code": "for (i = n + 1; i < l; i++)\n  alpha[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/32"}
{"code": "for (i = 1; i < n; i++)\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n\n", "pragma": "omp for nowait linear(i,j) collapse(456) ordered(i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor10/0"}
{"code": "for (int fy = 0; fy < height; fy++)\n{\n  for (int fx = 0; fx < width; fx++)\n  {\n    nn_search_helper(first, second, curMap, height, width, half_patch, fy, fx);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, 8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/patchmatch/omp/patchmatch/3"}
{"code": "for (int i = 0; i < B; i++)\n{\n  shuffle = uvec > ((n, distr_param(0, n - 1)));\n  ynew = trans(y(shuffle));\n  D.zeros();\n  assignew = AssignB(data_proc, D, P, n, cov_num, strt_num, level_num, omega, shuffle, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  theta(i) = ((-sum(ynew % (assignew - 2))) / n1) - (sum(ynew % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/16"}
{"code": "for (v = 0; v < cache->numPropertyRegions; ++v)\n{\n  if ((addr >= cache->propertyRegions[v].hot_bound) && (addr < cache->propertyRegions[v].warm_bound))\n  {\n    result = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/17"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  omp_set_lock(&lock);\n  fprintf(stdout, \"i = %d, thread id: %d +\\n\", i, omp_get_thread_num());\n  fprintf(stdout, \"i = %d, thread id: %d -\\n\", i, omp_get_thread_num());\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < D; j++)\n  {\n    pos[j] = X[i][j];\n  }\n\n  kd_insert(kd, pos, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-kdtree/test/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,k ,m ,dt ,nz ,jst ,jend ,i ,istep )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/98"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  contadores[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raphael28/cp2018/Trabalho/Codigo/src/bucketSortPrl/0"}
{"code": "for (int i = 0; i < new_comp_list.size(); i++)\n{\n  comp_list[i] = new_comp_list[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/quick_3/3"}
{"code": "for (i = 0; i < n; ++i)\n  w[i] = u[i] + v[i];\n\n", "pragma": "omp parallel for schedule(runtime) default(none) shared(n,u,v,w) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex2-vector-addition-openmp-ws/0"}
{"code": "for (int i = 0; i < Max_Iterations; i++)\n{\n  double t = ((double) i) / Max_Iterations;\n  colors[i][0] = (unsigned char) (((((9 * (1 - t)) * t) * t) * t) * MAX_PIXEL_VAL);\n  colors[i][1] = (unsigned char) (((((15 * (1 - t)) * (1 - t)) * t) * t) * MAX_PIXEL_VAL);\n  colors[i][2] = (unsigned char) (((((8.5 * (1 - t)) * (1 - t)) * (1 - t)) * t) * MAX_PIXEL_VAL);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bprakashputta/Parallel-Mandlebrot-set/Mandlebrot/0"}
{"code": "for (i = 0; i < arraysize; i++)\n{\n  prod = prod * array_A[i];\n}\n\n", "pragma": "omp parallel for reduction(+ : prod)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPforClause/1"}
{"code": "for (i = 0; i < (((2048 / NODESX) + 2) / 2); i++)\n{\n  for (j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    whites[i][j].data = 0;\n    blacks[i][j].data = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/111"}
{"code": "for (int i = 0; i < N; i++)\n  positions[i] = 0;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/NQueen/main/0"}
{"code": "for (chunk = 0; chunk < num_chunks; chunk++)\n{\n  int32_t r_start = GSTEP * (chunk / chunks_in_col);\n  int32_t c_start = GSTEP * (chunk % chunks_in_row);\n  int32_t r_end = ((r_start + GSTEP) > h) ? (h) : (r_start + GSTEP);\n  int32_t c_end = ((c_start + GSTEP) > w) ? (w) : (c_start + GSTEP);\n  int32_t r;\n  int32_t c;\n  for (c = c_start; c < c_end; c += GSTEP)\n  {\n    for (r = r_start; r < r_end; r += GSTEP)\n    {\n      for (y = c_start; y < c_end; ++y)\n      {\n        for (x = r_start; x < r_end; ++x)\n        {\n          uint32_t alive = 0;\n          uint32_t undead = 0;\n          for (y1 = y - 1; y1 <= (y + 1); y1++)\n          {\n            for (x1 = x - 1; x1 <= (x + 1); x1++)\n            {\n              if ((((y1 >= 0) && (y1 < h)) && (x1 >= 0)) && (x1 < w))\n              {\n                alive += univ[y1][x1] == 1;\n                undead += univ[y1][x1] == 2;\n              }\n\n            }\n\n          }\n\n          if (univ[y][x] == 1)\n          {\n            if (undead > 1)\n            {\n              new[y][x] = 0;\n            }\n            else\n              if ((undead == 1) && (alive > 2))\n            {\n              new[y][x] = 1;\n            }\n            else\n              if ((undead == 1) && (alive <= 2))\n            {\n              new[y][x] = 2;\n            }\n            else\n              if (alive > 4)\n            {\n              new[y][x] = 0;\n            }\n            else\n            {\n              new[y][x] = 1;\n            }\n\n\n\n\n          }\n          else\n            if (univ[y][x] == 2)\n          {\n            if (alive > 3)\n            {\n              new[y][x] = 0;\n            }\n            else\n              if ((alive == 3) && (undead == 3))\n            {\n              new[y][x] = 2;\n            }\n            else\n              if (undead > 4)\n            {\n              new[y][x] = 0;\n            }\n            else\n            {\n              new[y][x] = 2;\n            }\n\n\n\n          }\n          else\n          {\n            if (alive == 3)\n            {\n              new[y][x] = 1;\n            }\n            else\n              if (undead > 2)\n            {\n              new[y][x] = 2;\n            }\n            else\n            {\n              new[y][x] = 0;\n            }\n\n\n          }\n\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(u, univ, new) firstprivate(w, h, num_chunks, chunks_in_row, chunks_in_col) private(x, x1, y, y1, chunk) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/0"}
{"code": "for (int n1 = 0; n1 < number_bands; n1++)\n  for (int ig = 0; ig < ncouls; ig++)\n{\n  aqsmtemp(n1, ig) = expr;\n  aqsntemp(n1, ig) = expr;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gpp-omp/main/0"}
{"code": "for (int i = 0; i < vertexCount; ++i)\n{\n  if ((visitedVertex[i] == 0) && (minEdge > distancesOfThisVertex[i]))\n  {\n    vertex = i;\n    minEdge = distancesOfThisVertex[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pancak3/Diameter-OpenMP/onePunch/3"}
{"code": "for (i = 0; i < (m - 1); i++)\n{\n  if (ten[ind][i] < ten[ind][i + 1])\n  {\n    temp = ten[ind][i + 1];\n    ten[ind][i + 1] = ten[ind][i];\n    ten[ind][i] = temp;\n    j_temp = j1[ind][i + 1];\n    j1[ind][i + 1] = j1[ind][i];\n    j1[ind][i] = j_temp;\n    j_temp = j2[ind][i + 1];\n    j2[ind][i + 1] = j2[ind][i];\n    j2[ind][i] = j_temp;\n    j_temp = j3[ind][i + 1];\n    j3[ind][i + 1] = j3[ind][i];\n    j3[ind][i] = j_temp;\n  }\n  else\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/4"}
{"code": "for (int i = 0; i < length; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"working %d of %d threads\\n\", omp_get_thread_num(), omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OlegShatin/openmp-homework/7/main/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      A[(i * 1000) + j] = 0;\n    }\n    else\n    {\n      A[(i * 1000) + j] = (((float) i) * j) / 1000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/2"}
{"code": "for (i = 0; i < 64; i += 4)\n{\n  c = c + (b != (7 + ((i / 4) * 3)));\n  b = b + 3;\n}\n\n", "pragma": "omp parallel for simd schedule (static, 4) linear(b:3) reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-14/1"}
{"code": "for (int i = 0; i < (nx + 2); i++)\n{\n  for (int j = 0; j < (ny + 2); j++)\n  {\n    hNetUpdates[i][j] = (float) 0;\n    huNetUpdates[i][j] = (float) 0;\n    hvNetUpdates[i][j] = (float) 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eubrunomiguel/actor_mpi/src/applications/pond/block/SWE_WaveAccumulationBlock/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  GaussEliNd1(MT, r, i);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/GaussEli/0"}
{"code": "for (i = iend; i >= ist; i--)\n{\n  for (j = jend; j >= jst; j--)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i + 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tx1) * dx1;\n    a[i][j][0][1] = dt * tx2;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = 0.0;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = ((dt * tx2) * (((-(u[i + 1][j][k][1] * tmp1)) * (u[i + 1][j][k][1] * tmp1)) + (((C2 * 0.50) * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i + 1][j][k][1]));\n    a[i][j][1][1] = (((dt * tx2) * ((2.0 - C2) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    a[i][j][1][2] = (dt * tx2) * ((-C2) * (u[i + 1][j][k][2] * tmp1));\n    a[i][j][1][3] = (dt * tx2) * ((-C2) * (u[i + 1][j][k][3] * tmp1));\n    a[i][j][1][4] = (dt * tx2) * C2;\n    a[i][j][2][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][2]));\n    a[i][j][2][1] = (dt * tx2) * (u[i + 1][j][k][2] * tmp1);\n    a[i][j][2][2] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    a[i][j][2][3] = 0.0;\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][3]));\n    a[i][j][3][1] = (dt * tx2) * (u[i + 1][j][k][3] * tmp1);\n    a[i][j][3][2] = 0.0;\n    a[i][j][3][3] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    a[i][j][3][4] = 0.0;\n    a[i][j][4][0] = ((dt * tx2) * ((((C2 * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2) - (C1 * (u[i + 1][j][k][4] * tmp1))) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i + 1][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i + 1][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i + 1][j][k][3]))) - ((c1345 * tmp2) * u[i + 1][j][k][4])));\n    a[i][j][4][1] = ((dt * tx2) * ((C1 * (u[i + 1][j][k][4] * tmp1)) - ((0.50 * C2) * (((((3.0 * u[i + 1][j][k][1]) * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i + 1][j][k][1]);\n    a[i][j][4][2] = ((dt * tx2) * (((-C2) * (u[i + 1][j][k][2] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][2]);\n    a[i][j][4][3] = ((dt * tx2) * (((-C2) * (u[i + 1][j][k][3] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][3]);\n    a[i][j][4][4] = (((dt * tx2) * (C1 * (u[i + 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n    tmp1 = 1.0 / u[i][j + 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = dt * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = ((dt * ty2) * ((-(u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][1]));\n    b[i][j][1][1] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = (dt * ty2) * (u[i][j + 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = ((dt * ty2) * (((-(u[i][j + 1][k][2] * tmp1)) * (u[i][j + 1][k][2] * tmp1)) + ((0.50 * C2) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j + 1][k][2]));\n    b[i][j][2][1] = (dt * ty2) * ((-C2) * (u[i][j + 1][k][1] * tmp1));\n    b[i][j][2][2] = (((dt * ty2) * ((2.0 - C2) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = (dt * ty2) * ((-C2) * (u[i][j + 1][k][3] * tmp1));\n    b[i][j][2][4] = (dt * ty2) * C2;\n    b[i][j][3][0] = ((dt * ty2) * ((-(u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = (dt * ty2) * (u[i][j + 1][k][3] * tmp1);\n    b[i][j][3][3] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = ((dt * ty2) * ((((C2 * (((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) * tmp2) - (C1 * (u[i][j + 1][k][4] * tmp1))) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j + 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j + 1][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j + 1][k][3]))) - ((c1345 * tmp2) * u[i][j + 1][k][4])));\n    b[i][j][4][1] = ((dt * ty2) * (((-C2) * (u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][1]);\n    b[i][j][4][2] = ((dt * ty2) * ((C1 * (u[i][j + 1][k][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + ((3.0 * u[i][j + 1][k][2]) * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j + 1][k][2]);\n    b[i][j][4][3] = ((dt * ty2) * (((-C2) * (u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][3]);\n    b[i][j][4][4] = (((dt * ty2) * (C1 * (u[i][j + 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i][j][k + 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tz1) * dz1;\n    c[i][j][0][1] = 0.0;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = dt * tz2;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = ((dt * tz2) * ((-(u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][1]));\n    c[i][j][1][1] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    c[i][j][1][2] = 0.0;\n    c[i][j][1][3] = (dt * tz2) * (u[i][j][k + 1][1] * tmp1);\n    c[i][j][1][4] = 0.0;\n    c[i][j][2][0] = ((dt * tz2) * ((-(u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][2]));\n    c[i][j][2][1] = 0.0;\n    c[i][j][2][2] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    c[i][j][2][3] = (dt * tz2) * (u[i][j][k + 1][2] * tmp1);\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = ((dt * tz2) * (((-(u[i][j][k + 1][3] * tmp1)) * (u[i][j][k + 1][3] * tmp1)) + ((0.50 * C2) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k + 1][3]));\n    c[i][j][3][1] = (dt * tz2) * ((-C2) * (u[i][j][k + 1][1] * tmp1));\n    c[i][j][3][2] = (dt * tz2) * ((-C2) * (u[i][j][k + 1][2] * tmp1));\n    c[i][j][3][3] = ((((dt * tz2) * (2.0 - C2)) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    c[i][j][3][4] = (dt * tz2) * C2;\n    c[i][j][4][0] = ((dt * tz2) * ((((C2 * (((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) * tmp2) - (C1 * (u[i][j][k + 1][4] * tmp1))) * (u[i][j][k + 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k + 1][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k + 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k + 1][3]))) - ((c1345 * tmp2) * u[i][j][k + 1][4])));\n    c[i][j][4][1] = ((dt * tz2) * (((-C2) * (u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][1]);\n    c[i][j][4][2] = ((dt * tz2) * (((-C2) * (u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][2]);\n    c[i][j][4][3] = ((dt * tz2) * ((C1 * (u[i][j][k + 1][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + ((3.0 * u[i][j][k + 1][3]) * u[i][j][k + 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k + 1][3]);\n    c[i][j][4][4] = (((dt * tz2) * (C1 * (u[i][j][k + 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/44"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    int converges = 0;\n    x = ((((double) (j - 1)) * x_max) + (((double) (rows - j)) * x_min)) / ((double) (rows - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (cols - i)) * y_min)) / ((double) (cols - 1));\n    count[i][j] = -1;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    int idx;\n    idx = (rows * i) + j;\n    PPMPixel *temp = output->data + idx;\n    color *c = getColour(count[i][j]);\n    temp->red = c->r;\n    temp->green = c->g;\n    temp->blue = c->b;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Unnati-P/Plotting-the-fractal-structure-Mandelbrot-Set/parallel_measurement/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  im1 = i - 1;\n  ip1 = i + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n}\n\n", "pragma": "omp parallel for private (ip1,im1,i) firstprivate (tx2,xxcon1,xxcon2,xxcon3,xxcon4,xxcon5,dx1tx1,dx2tx1,dx3tx1,dx4tx1,dx5tx1,c1,c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/12"}
{"code": "for (j = 0; j < (copys[n][nOfLayers - 1].nOfNeurons - 1); j++)\n{\n  copys[n][nOfLayers - 1].neurons[j].net = 0;\n  copys[n][nOfLayers - 1].neurons[j].net += copys[n][nOfLayers - 1].neurons[j].w[0];\n  for (int k = 1; k < (copys[n][nOfLayers - 2].nOfNeurons + 1); k++)\n  {\n    copys[n][nOfLayers - 1].neurons[j].net += copys[n][nOfLayers - 1].neurons[j].w[k] * copys[n][nOfLayers - 2].neurons[k - 1].out;\n  }\n\n  sumNet += exp(copys[n][nOfLayers - 1].neurons[j].net);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/10"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double err = C[i + (j * N)] - Crecur[i + (j * N)];\n    err2 += err * err;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/openmp/matmat_recur/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  per = (int) (100 * propArray[i]);\n  for (j = 0; j < N; j++)\n  {\n    if (i != j)\n    {\n      M[i][j] = propabilityFunction(per);\n      colSum[j] += M[i][j];\n    }\n    else\n    {\n      M[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/21"}
{"code": "for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  susxx[j][k] = 1.0;\n  susyx[j][k] = 0.0;\n  suszx[j][k] = 0.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/84"}
{"code": "for (i = 0; i < EMISSION_COLS; i++)\n{\n  for (j = 0; j < STATES; j++)\n  {\n    ab[i][j] = ((float) rand()) / RAND_MAX;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/13"}
{"code": "for (i = 0; i < len; i++)\n{\n  sum1 = sum1 + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB085-threadprivate-orig-no/1"}
{"code": "for (int i = 0; i < 100; i++)\n  ;\n\n", "pragma": "#pragma omp target parallel for simd is_device_ptr(k)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_parallel_for_simd_is_device_ptr_ast_print/0"}
{"code": "for (int i = max(1, i_start); i <= min(sizex - 2, i_end); i++)\n{\n  for (int j = 1; j <= (sizey - 2); j++)\n  {\n    utmp[(i * sizey) + j] = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n    diff = utmp[(i * sizey) + j] - u[(i * sizey) + j];\n    sum += diff * diff;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BlackMooth/OpenMP---Heat-diffusion-Equation-Solvers/solver-omp/1"}
{"code": "for (i = 0; i < (size - 1); ++i)\n{\n  MPI_Recv(&tmp, 1, (MPI_Datatype) 0x4c000405, -2, 0, (MPI_Comm) 0x44000000, 0);\n  num_points_circle += tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/huynguyen7/Distributed-Monte-Carlo-Pi/mpi_omp_pi/1"}
{"code": "for (int i = 0; i < NUM_POINTS_0; i++)\n{\n  eta[i] = Results[IndexT][i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/15"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    staggered[i][j].A = temp[i][(j + i) % n].A;\n    staggered[i][j].B = temp[(i + j) % l][j].B;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac4/MatrixMultiplication_OpenMP/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    a[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/MatrixMul/0"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    pressure[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = pressure[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/17"}
{"code": "for (j = 1; j <= jmax; j++)\n{\n  for (i = 1; i <= imax; i++)\n  {\n    residual[((j - 1) * imax) + (i - 1)] = (function_output[i - 1] - (((A[((j + 1) * m) + i] - (2 * A[(j * m) + i])) + A[((j - 1) * m) + i]) / meshsize_i2)) - (((A[(j * m) + (i + 1)] - (2 * A[(j * m) + i])) + A[(j * m) + (i - 1)]) / meshsize_j2);\n  }\n\n}\n\n", "pragma": "omp for private(j,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlessandroPiccolo/poisson-openmp-solver/source/poisson_parallel/7"}
{"code": "for (i = 0; i < 64; i++)\n{\n}\n\n", "pragma": "omp for ordered (1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/doacross-1/3"}
{"code": "for (unsigned int i = 1; i < (x_size - 1); i++)\n  b[i][0] = (a[i - 1][0] + a[i][0]) / 2;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/lib/1"}
{"code": "for (j = 0; j < 1000; ++j)\n{\n  thread_num = omp_get_thread_num();\n  for (i = 0; i < 1000; ++i)\n  {\n    c[i][j] = mul(a, b, i, j);\n  }\n\n}\n\n", "pragma": "omp for private(thread_num, i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/winAPI/openmp1/lab1/0"}
{"code": "for (int i = 0; i < nr_centroids; i++)\n{\n  for (int j = 0; j < nr_dimensions; j++)\n  {\n    coordinates_accumulator_thread[(i * nr_dimensions) + j] = 0.0;\n  }\n\n  points_accumulator_thread[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/9"}
{"code": "for (it = _sageTileSizeParameters.begin(); it != _sageTileSizeParameters.end(); ++it)\n  unionDecls.insert(*it);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/PolyOpt/polyopt/PastToSage/6"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp for reduction (+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDX-Math-HSAP/openmp_intro/example codes/impls/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = y[i] + i;\n  x[i + 1] = y[i] * 2;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpolob/mapcd-openmp/05/05/1"}
{"code": "for (int i = 0; i < count; ++i)\n  if ((err = sem_post(workerSemaphore)) != 0)\n{\n  fprintf(stderr, \"Error from sem_post: %s\\n\", strerror(err));\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/6"}
{"code": "for (int y = 1; y < (nrows - 1); y++)\n{\n  for (int x = 1; x < (ncolumns - 1); x++)\n  {\n    cell = grid[y][x];\n    nliving = countNeighbors(grid, y, x);\n    newCell = &newGrid[y][x];\n    if ((nliving == 3) || ((nliving == 2) && (cell == '#')))\n      *newCell = '#';\n    else\n      *newCell = '.';\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_mpi_openmp/3"}
{"code": "for (j = 0; j < height; j++)\n{\n  ret[i] += vec[j] * mat[i][j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:ret[i]) shared(i, vec, mat, height) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pyhro36/TD-1-OpenMP/matrice-vecteur/main_mat_vect/5"}
{"code": "for (i = 0; i < 800; i++)\n{\n  for (j = 0; j < 800; j++)\n  {\n    b[i][j] = i * j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/5"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  data[i] = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cniethammer/openmp_validation_suite/src/c/omp_parallel_for/0"}
{"code": "for (i = 0; i < num_lines; i++)\n{\n  j = ((i % 2) == 0) ? (1) : (0);\n  for (; j < num_lines; j += 2)\n  {\n    if (data[i][j] == 0)\n    {\n      double left;\n      double right;\n      double up;\n      double down;\n      double diff;\n      double prev;\n      left = ((i - 1) < 0) ? (0) : (result[i - 1][j]);\n      right = ((i + 1) >= num_lines) ? (0) : (result[i + 1][j]);\n      up = ((j - 1) < 0) ? (0) : (result[i][j - 1]);\n      down = ((j + 1) >= num_lines) ? (0) : (result[i][j + 1]);\n      prev = result[i][j];\n      result[i][j] = 0.25 * (((left + right) + up) + down);\n      diff = fabs(prev - result[i][j]);\n      if (diff > max_black)\n      {\n        max_black = diff;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(result) private(i, j) reduction(max:max_black)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaaasonwu/HeatDistribution/openmp_heat_distribution/1"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  vec[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JanetLau0310/Parallel_computing/OpenMP/SpMV/h5/1"}
{"code": "for (i = 2; i <= 32; i = i * 2)\n{\n  dist.clear();\n  dist.resize(n + 1);\n  for (u = 0; u <= n; u++)\n  {\n    dist[u].resize(n + 1);\n  }\n\n  double start_time = omp_get_wtime();\n  floydWarshall(i);\n  double end_time = omp_get_wtime() - start_time;\n  double wall_clock = end_time;\n  printf(\"%d %.10lf\\n\", i, wall_clock);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishal-2504/Parallelization-of-Floyd-Warshall-Algorithm/floyd_naive_dynamic_scheduling/4"}
{"code": "for (i = 0; i <= m; i++)\n{\n  dp[i][i] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel5/0"}
{"code": "for (int i = 0; i < N; i++)\n  if (visited[i] = false)\n  helper(i, visited);\n\n\n", "pragma": "   \t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pratapabhay/Parallel/dfs_parallel/2"}
{"code": "for (unsigned long long i = 0; i < edge_list_size; i++)\n{\n  h_graph_edges[i] = rand() % no_of_nodes;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_gpu/1"}
{"code": "for (int i = 0; i < V; i++)\n{\n  arrD[i] = infinity;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ryanmueller28/OpenMP-BellmanFord/bf/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    printf(\"%lf \", A[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Backward-Substitution/parallel/7"}
{"code": "for (int s = 0; s < nk; ++s)\n{\n  (bitset < 20) > (s.to_string() << endl);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen/3"}
{"code": "for (i = 1; i <= n; i++)\n{\n  x[i] = 0.0;\n  mark[i] = FALSE;\n}\n\n", "pragma": "\t#pragma omp parallel for    ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/24"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task8/0"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  getline(inputFileObject, inputStr);\n  sscanf(inputStr.c_str(), \"NVERT %d\", &nv);\n  for (d = 0; d < NDIM; d++)\n  {\n    cell(ci).setL(d, L.at(d));\n    cell(ci).setpbc(d, 1);\n  }\n\n  cell(ci).setNV(nv);\n  cell(ci).initializeVertices();\n  cell(ci).initializeCell();\n  getline(inputFileObject, inputStr);\n  sscanf(inputStr.c_str(), \"CELLP %*d %lf %lf %lf %lf %lf %*lf %*lf %*lf\", &x, &y, &l0tmp, &a0tmp, &deltmp);\n  cell(ci).setCPos(0, x);\n  cell(ci).setCPos(1, y);\n  cell(ci).seta0(a0tmp);\n  cell(ci).setl0(l0tmp);\n  cell(ci).setdel(deltmp);\n  (((((((cout << \"\t** on cell \") << ci) << \", NV = \") << nv) << \";\\t com at x = \") << x) << \", y = \") << y;\n  (((((((cout << \";\\t l0 = \") << l0tmp) << \", a0 = \") << a0tmp) << \", so calA0 = \") << setprecision(8)) << ((((nv * nv) * l0tmp) * l0tmp) / ((4.0 * PI) * a0tmp))) << endl;\n  getline(inputFileObject, inputStr);\n  ((cout << \"header check : \") << inputStr) << endl;\n  for (vi = 0; vi < nv; vi++)\n  {\n    getline(inputFileObject, inputStr);\n    sscanf(inputStr.c_str(), \"VERTP %*d %lf %lf %*lf %*lf %*lf %*lf\", &x, &y);\n    cell(ci).setVPos(vi, 0, x);\n    cell(ci).setVPos(vi, 1, y);\n    ((((((((cout << \"\t-- -- cell \") << ci) << \", vertex \") << vi) << \": x = \") << x) << \", y = \") << y) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    a[i][j] = rand() % 100;\n    (cout << a[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/greenmapc/OpenMP-MPI/OpenMP/Task10/0"}
{"code": "for (int i = MIN; i < MAX; i++)\n{\n  int sum = false;\n  for (int j = 0; j < maxThreadsCount; j++)\n  {\n    sum |= isNumberPrime[j][i];\n  }\n\n  if (!sum)\n  {\n    primeNumbers[i] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/macluczak/Primes-OpenMP/sito-domen/4"}
{"code": "for (int i = 0; i < size; i += 2)\n{\n  _mm_storeu_pd(&newVec[i], _mm_loadu_pd(&vec1[i]) + _mm_loadu_pd(&vec2[i]));\n}\n\n", "pragma": "#pragma omp parallel for shared(vec1, vec2, size, newVec, chunkSize) BASE_CLAUSE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_1_SSE/2"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    p[index] = ((*beta) * p[index]) + r[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_cg_kernel/6"}
{"code": "for (long i = 0; i < comb; i++)\n{\n  long mask = 1;\n  for (int j = 0; j < no_variables; j++)\n  {\n    if (((i & mask) >> j) == 1)\n    {\n      solution_space[i][j] = true;\n    }\n    else\n    {\n      solution_space[i][j] = false;\n    }\n\n    mask = mask << 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdkul22/satsolve/satool_omp/4"}
{"code": "for (j = jbeg; j <= jfin1; j += 1)\n{\n  frc1 = frc1 + (((((((phi1[i][j] + phi1[i + 1][j]) + phi1[i][j + 1]) + phi1[i + 1][j + 1]) + phi2[i][j]) + phi2[i + 1][j]) + phi2[i][j + 1]) + phi2[i + 1][j + 1]);\n}\n\n", "pragma": "omp parallel for private (j) reduction (+:frc1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/70"}
{"code": "for (i = 0; i < width; ++i)\n{\n  p(height + 1, i + 1) = recv_bottom[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/12"}
{"code": "for (i = 0; i < ORD; i++)\n{\n  zeros.push_back(0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/babreu-ncsa/IntroToOpenMP/Ex2_DataSharing/indexgame/cpp/solution/indexgame_omp/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  foo();\n}\n\n", "pragma": "#pragma omp for private(fl)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_reduction_messages/0"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  result[i] = 0;\n  for (int j = 0; j < size; ++j)\n  {\n    result[i] += matrix[i + (size * j)] * column[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(matrix, column, result, size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artme-uni/OpenMP/OpenMP_2/matrix/matrix/0"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dEo2[col] = dEo22[col] * dneto12[col];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/23"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (frontier_level[i] == level)\n  {\n    for (int j = index_into_adjacency_array[i]; j < index_into_adjacency_array[i + 1]; j++)\n    {\n      int frontier = adjacency_array[j];\n      if (frontier_level[frontier] == 0)\n      {\n        node_parent[frontier] = i;\n        frontier_level[frontier] = level + 1;\n        local_count++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : local_count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/14"}
{"code": "for (int k = 0; k < 100; k++)\n{\n  a[k] = k;\n  n = k;\n}\n\n", "pragma": "omp target parallel for simd map(tofrom: a[0:100], n) lastprivate(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-parallel-for-simd-clauses/test/2"}
{"code": "for (i = 0; i < m_sub; i++)\n{\n  for (sum = 0, j = 0; j < n; j++)\n    sum += submatrix[(i * n) + j] * vector[j];\n\n  subproduct[i] += sum;\n}\n\n", "pragma": "omp parallel for private(j) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geilerh/matrix-vector_product-MPI-and-OpenMP/main/0"}
{"code": "for (int i = 0; i < n; i++)\n  s[i] = false;\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/0"}
{"code": "for (loopnum = 0; loopnum < numOptions; ++loopnum)\n{\n  rv = fscanf(file, \"%f %f %f %f %f %f %c %f %f\", &data[loopnum].s, &data[loopnum].strike, &data[loopnum].r, &data[loopnum].divq, &data[loopnum].v, &data[loopnum].t, &data[loopnum].OptionType, &data[loopnum].divs, &data[loopnum].DGrefval);\n  if (rv != 9)\n  {\n    printf(\"ERROR: Unable to read from file `%s'.\\n\", inputFile);\n    fclose(file);\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/BlackScholes/blackscholes_for/1"}
{"code": "for (int t = 0; t < active_size; t++)\n  if (y[t] == (+1))\n{\n  if (!is_upper_bound(t))\n    if ((-G[t]) >= Gmaxp)\n  {\n    Gmaxp = -G[t];\n    Gmaxp_idx = t;\n  }\n\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/19"}
{"code": "for (i = 0; i < 8; i++)\n{\n  printf(\"loop: %d, thread: %lu, iteration: %d\\n\", loop_index, omp_get_thread_num(), i);\n  loop_2[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/2"}
{"code": "for (i = 0; i < arraySize; i++)\n{\n  threads = omp_get_num_threads();\n  count = 0;\n  for (j = 0; j < arraySize; j++)\n  {\n    if ((array[j] < array[i]) || ((array[j] == array[i]) && (j < i)))\n    {\n      count++;\n    }\n\n  }\n\n  temp[count] = array[i];\n}\n\n", "pragma": "omp parallel for shared(array, arraySize, temp) private(i, j, count)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcpablo/cefet-openmp/counting-sort/openmp/parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((((int) v[i]) % 2) == 0)\n    even.push_back((int) v[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xsovao/openmp/openmp/openmp/1"}
{"code": "for (int i = 0; i < ((m + n) + 1); i++)\n  switch (c[i])\n{\n  case '+':\n    c[i] = '-';\n    break;\n\n  case '-':\n    c[i] = '+';\n    break;\n\n}\n\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/0"}
{"code": "for (int j = 0; j < columns; j++)\n{\n  (cout << I2[j]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/1"}
{"code": "for (row = 0; row < n; row++)\n  x[row] = b[row];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Backward-Substitution/parallel/0"}
{"code": "for (size_t y = 1; y < (h - 1); ++y)\n{\n  for (size_t x = 1; x < (w - 1); ++x)\n  {\n    double w_local = c[(y * w) + x];\n    double restw = 1.0 - w_local;\n    dst[(y * w) + x] = ((w_local * src[(y * w) + x]) + ((((src[((y + 1) * w) + x] + src[((y - 1) * w) + x]) + src[((y * w) + x) + 1]) + src[((y * w) + x) - 1]) * (restw * c_cdir))) + ((((src[(((y - 1) * w) + x) - 1] + src[(((y - 1) * w) + x) + 1]) + src[(((y + 1) * w) + x) - 1]) + src[(((y + 1) * w) + x) + 1]) * (restw * c_cdiag));\n  }\n\n  dst[((y * w) + w) - 1] = dst[(y * w) + 1];\n  dst[(y * w) + 0] = dst[((y * w) + w) - 2];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/phi/compute/0"}
{"code": "for (int index = (width * height) - 1; index >= 0; --index)\n{\n  if (segmentation_map[index] > 0)\n  {\n    uint32_t indexHistoryBuffer = (3 * index) * numberOfTests;\n    for (int i = numberOfTests; i > 0; --i, indexHistoryBuffer += 3)\n    {\n      if (distance_is_close_8u_C3R(image_data[3 * index], image_data[(3 * index) + 1], image_data[(3 * index) + 2], historyBuffer[indexHistoryBuffer], historyBuffer[indexHistoryBuffer + 1], historyBuffer[indexHistoryBuffer + 2], matchingThreshold))\n      {\n        --segmentation_map[index];\n      }\n\n      uint8_t temp_r = swappingImageBuffer[3 * index];\n      uint8_t temp_g = swappingImageBuffer[(3 * index) + 1];\n      uint8_t temp_b = swappingImageBuffer[(3 * index) + 2];\n      swappingImageBuffer[3 * index] = historyBuffer[indexHistoryBuffer];\n      swappingImageBuffer[(3 * index) + 1] = historyBuffer[indexHistoryBuffer + 1];\n      swappingImageBuffer[(3 * index) + 2] = historyBuffer[indexHistoryBuffer + 2];\n      historyBuffer[indexHistoryBuffer] = temp_r;\n      historyBuffer[indexHistoryBuffer + 1] = temp_g;\n      historyBuffer[indexHistoryBuffer + 2] = temp_b;\n      if (segmentation_map[index] <= 0)\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/13"}
{"code": "for (i = 0; i < FIELD_GEN; i++)\n{\n  evolve(fa, fb, FIELD_SIZE);\n  tt = fb;\n  fb = fa;\n  fa = tt;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeBrizola/game-of-life-openMp/gameoflife/game_mp/4"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  Reduction1(A, 100);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Reduction/C/reduction/4"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  for (j = 0; j < dimension; j++)\n  {\n    data_points[i][j] = ((double) (rand() % 1024)) / rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/18"}
{"code": "for (int k = 0; k < cyl_geom->n_grid_z; k++)\n{\n  b = 2. * (1. - (((dr * dr) / (dz * dz)) * (cos((PI * (k + 1)) / (cyl_geom->n_grid_z + 1)) - 1)));\n  d = ((dr * dr) * t_charge_density[0][k]) / EPSILON0;\n  alpha[1] = 4. / (2. + b);\n  beta[1] = d / (2. + b);\n  for (int i = 1; i < (cyl_geom->n_grid_r - 1); i++)\n  {\n    a = 1. - (1. / (2. * i));\n    c = 1. + (1. / (2. * i));\n    d = ((dr * dr) * t_charge_density[i][k]) / EPSILON0;\n    alpha[i + 1] = c / (b - (alpha[i] * a));\n    beta[i + 1] = (d + (beta[i] * a)) / (b - (alpha[i] * a));\n  }\n\n  for (int i = cyl_geom->n_grid_r - 2; i >= 0; i--)\n    fi[i][k] = beta[i + 1] + (alpha[i + 1] * fi[i + 1][k]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/poissonDirichlet/2"}
{"code": "for (int j = 0; j < (indexGroup - 1); j++)\n{\n  explored += numsOfParts[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/4"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  suml = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    suml = suml + (a[k] * p[colidx[k]]);\n  }\n\n  q[j] = suml;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/7"}
{"code": "for (int ip = 0; ip < Ntot; ip++)\n{\n  pos_z[ip] += vel_z[ip] * dt;\n  pos_r[ip] += vel_r[ip] * dt;\n  pos_y_ip += vel_y[ip] * dt;\n  RotateToRZ(pos_r[ip], pos_y_ip, vel_r[ip], vel_y[ip], dr);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SmirnovVladimir95/CPP_RZ_PIC_Openmp/Particles/Pusher/3"}
{"code": "for (size_t i = 0; i < val.size(); i++)\n{\n  val[i] = value;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/utils/dense_constructor/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  qrdecompb_iter(a, b, m, n, u, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/19"}
{"code": "for (int ii = 0; ii < nb; ++ii)\n{\n  x[ii] = X_VAL;\n  y[ii] = Y_VAL;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-critical/test/0"}
{"code": "for (int i = 0; i < nIter; i++)\n  sgemm(\"N\", \"N\", &size, &size, &size, &alpha, (float *) At, &size, (float *) Bt, &size, &beta, (float *) Ct, &size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/weiwangudel/RCRdaemon-MIC/test_MICEnergyStat_OpenMPoffload_matrix/matrix/5"}
{"code": "for (int i = 0; i < psize; i++)\n{\n  row_cnt[i] = m / psize;\n  row_disp[i] = (i * m) / psize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicolaslesimple/Hybrid-MPI-OpenMP-Conjugate-Gradient-Algorithm/conj_grad_solve/1"}
{"code": "for (int i = 0; i < n; i++)\n  e(i) = S(i, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/JacobiAsync/3"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (i <= argc)\n  {\n    if (!strcmp(argv[i], \"--ptvs\"))\n    {\n      for (int j = 0; j < 9; j++)\n      {\n        prim[j] = strtod(argv[(i + j) + 1], &pend);\n      }\n\n      i += 9;\n    }\n\n    if (!strcmp(argv[i], \"--target\"))\n    {\n      target = strtol(argv[i + 1], &pend, 10);\n      i++;\n    }\n\n    if (!strcmp(argv[i], \"--verbose\"))\n    {\n      verbose = 1;\n    }\n\n    if (!strcmp(argv[i], \"--maxentry\"))\n    {\n      maxentry = strtol(argv[i + 1], &pend, 10);\n      i++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCTools/getSupercell/3"}
{"code": "for (int t = 0; t < N; t++)\n  a[t] = t + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satyatejachikatla/OpenMP-examples/02-Reduction/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  yt = h * ak[i];\n  ytemp2[i] += (9.0 / 40.0) * yt;\n  ytemp3[i] -= 0.9 * yt;\n  ytemp4[i] += 2.5 * yt;\n  ytemp5[i] += (175.0 / 512.0) * yt;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/grrt-omp/kernels/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (a[i] * b[i]);\n  printf(\"Final result=%f\\ta[%d]=%f\\tb[%d]=%f\\ttid=%d\\n\", result, i, a[i], i, b[i], omp_get_thread_num());\n}\n\n", "pragma": "omp paralllel for default(shared) private(i) scheduled(static,chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/default2/0"}
{"code": "for (int j = 0; j < (nx * ny); j++)\n{\n  sum_r = sum_r + (res[j] * res[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akjain90/OpenMP-parallized-RBGS-solver/matrix/8"}
{"code": "for (long i = 0; i < 3; i++)\n{\n  for (int u = 0; u < 100000000; u++)\n  {\n    result++;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_loop_nowait/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  tid = omp_get_thread_num();\n  nthreads = omp_get_num_threads();\n  printf(\"nthreads = %d, id = %d, i = %d\\n\", nthreads, tid, i);\n}\n\n", "pragma": "omp parallel for private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter5/fss/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner < rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner < theta_max))\n  {\n    block_cnt += 1;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(num_thread) reduction(+:block_cnt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/0"}
{"code": "for (long i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  double subsum = 4.0 / (1.0 + (x * x));\n  sum += subsum;\n}\n\n", "pragma": "\t#pragma omp target teams distribute parallel for simd reduction (+:sum) map(tofrom:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex4_1B_pi_parallel-for-reduction__GPU/0"}
{"code": "for (int i = 0; i < argc; i++)\n{\n  ((((cout << \"argv :  \") << i) << \" : \") << argv[i]) << endl;\n  if ((i + 1) != argc)\n    if (str1.compare(argv[i]) == 0)\n  {\n    inputFileName = argv[i + 1];\n    myFileName = argv[i + 1];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soumitraj/OpenMP-MPI/Task1/task1/0"}
{"code": "for (int ii = HALO_PAD; ii < (HALO_PAD + depth); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX)) + (((ii - HALO_PAD) * _chunk.innerX) * _chunk.innerY);\n      buffer[bufIndex] = field[(((ii * y) * x) + (jj * x)) + kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/5"}
{"code": "for (int y = 0; y < height; y++)\n  for (int x = 0; x < width; x++)\n  convolution(image, result, x, y);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/gaussian/gaussian2/1"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 1; j < 20; j++)\n  A[i][j] = A[i - 1][j - 1];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/1.race1/0"}
{"code": "for (k = 3; k <= (grid_points[2] - 4); k++)\n{\n  lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n  lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n  lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n  lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n  lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,comz1 ,comz4 ,comz6 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/76"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  start = _rdtsc();\n  mult_mat_vector_tri_inf4(M, v1, v2);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/triangular_matrix/11"}
{"code": "for (int z = 0; z < nz; z++)\n{\n  for (int y = 0; y < ny; y++)\n  {\n    for (int x = 0; x < nx; x++)\n    {\n      int this_offset = POINT_OFFSET(x, y, z, dimy, dimx, radius);\n      TYPE temp = (2.0f * curr[this_offset]) - next[this_offset];\n      TYPE div = c_coeff[0] * curr[this_offset];\n      for (int d = 1; d <= radius; d++)\n      {\n        int z_pos_offset = POINT_OFFSET(x, y, z + d, dimy, dimx, radius);\n        int z_neg_offset = POINT_OFFSET(x, y, z - d, dimy, dimx, radius);\n        int y_pos_offset = POINT_OFFSET(x, y + d, z, dimy, dimx, radius);\n        int y_neg_offset = POINT_OFFSET(x, y - d, z, dimy, dimx, radius);\n        int x_pos_offset = POINT_OFFSET(x + d, y, z, dimy, dimx, radius);\n        int x_neg_offset = POINT_OFFSET(x - d, y, z, dimy, dimx, radius);\n        div += c_coeff[d] * (((((curr[z_pos_offset] + curr[z_neg_offset]) + curr[y_pos_offset]) + curr[y_neg_offset]) + curr[x_pos_offset]) + curr[x_neg_offset]);\n      }\n\n      next[this_offset] = temp + (div * vsq[this_offset]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ijpq/15418/utils/opencv/CodeSamples/lectures_code/iso/src/iso3d/0"}
{"code": "for (int i = 0; i < (nov - 1); i++)\n{\n  double csum = 0;\n  int colIndex = txadj[i];\n  for (; colIndex < txadj[i + 1]; colIndex++)\n  {\n    csum += rv[tadj[colIndex]];\n  }\n\n  if (csum != 0)\n  {\n    cv[i] = 1.0 / csum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kayagokalp/Sinkhorn-Knopp-Parallel-OpenMP/scalesk_hw1/1"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testErand48(800000000, i);\n  printf(\"testErand48 | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc() * 100., stop() * 100., stopt() / 8e8);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/7"}
{"code": "for (int j1 = 0; j1 <= twojmax; j1++)\n  for (int j2 = 0; j2 <= j1; j2++)\n  for (int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2)\n  for (int mb = 0; (2 * mb) <= j; mb++)\n  for (int ma = 0; ma <= j; ma++)\n  idxz_count++;\n\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/testSNAP-omp/main/8"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += result[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jm3zhang/Programming-for-Performance/Compute the Riemann zeta function using OpenMP/zeta_omp/2"}
{"code": "for (int i = lower; i < upper; i++)\n{\n  entity += m->SquareMatrix[row][i] * m->SquareMatrix[i][column];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/Parallel_1.0/9"}
{"code": "for (i = 0; i < buckets; i++)\n{\n  buckets_count[(t_id * buckets) + i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/12"}
{"code": "for (i = currow; i < nsize; i++)\n{\n  {\n    double tmp;\n    tmp = matrix[irow][i];\n    matrix[irow][i] = matrix[currow][i];\n    matrix[currow][i] = tmp;\n  }\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaowei-su/ParallelGaussianElimination/gaussOPENMP/4"}
{"code": "for (int i = 1; i <= cities_cnt; ++i)\n{\n  dist += graph[route.cities[i % cities_cnt]][route.cities[i - 1]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/0"}
{"code": "for (int i = 0; i < sizeN; i++)\n{\n  PrintArray(arr[i], sizeN);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/ShearSort_Comprehension/C++_Code/Main/1"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  if (jouer_coup(cs, &newPos, pos, 0, i))\n  {\n    const int val = valeur_minimaxAB(cs, &newPos, 1, alpha, beta, pmax - 1, gagne);\n    if (val > alpha)\n    {\n      alpha = val;\n      coup = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/18"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  result[i] = vec1[i] - vec2[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dross0/Parallel-Programming-Labs/Lab2/var1/0"}
{"code": "for (size_t i = color_offsets.size() - 1; i > 0; i--)\n  gauss_seidel(Ap, Aj, indices, Ax, x, b, color_offsets[i - 1], color_offsets[i], 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/symgs/omp_target/1"}
{"code": "for (n = 0; n < posiciones; n++)\n{\n  a[n] = n;\n  b[n] = n;\n  c[n] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanecaradonna/openMP/Ejercicio5/ejercicio5/0"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_cell_kernel_c/5"}
{"code": "for (int y = 0; y < j; y++)\n{\n  for (int x = 0; x < i; x++)\n    printf(\"%f \", matrix[x + (y * i)]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mukundc/Image-Processing-and-Optimization/part2/4"}
{"code": "for (; (i + 15) < n; i += 16)\n{\n  xv[0] = _mm256_load_ps(&x[i + 0]);\n  xv[1] = _mm256_load_ps(&x[i + 8]);\n  _mm256_store_ps(&y[i + 0], xv[0]);\n  _mm256_store_ps(&y[i + 8], xv[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/12"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < M; ++j)\n  x_[counter++] = x(i, j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/USCbiostats/r-parallel-benchmark/norm/2"}
{"code": "for (int i = 0; i < MATRIX_SIZE; i++)\n{\n  for (int j = 0; j < MATRIX_SIZE; j++)\n  {\n    for (int k = 0; k < MATRIX_SIZE; k++)\n    {\n      for (int p = 0; p < MATRIX_SIZE; p++)\n      {\n        C->data[i][j][k] += A->data[i][j][p] * B->data[i][p][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW3/matmul3d/4"}
{"code": "for (int ii = 0; ii < N; ii++)\n  S += array[ii];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/00_array_sum_with_race/0"}
{"code": "for (i = 0; i < (numThreads * dataSize); i++)\n{\n  tempBuf[i] = globalIDarray[myThreadID];\n}\n\n", "pragma": "omp for schedule(static,dataSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/collective_reduction/0"}
{"code": "for (int s = 1; s < mpi_size; ++s)\n{\n  SendRecvRing(VA, VB, mpi_rank, right_rank, left_rank, array_size);\n  swap(VA, VB);\n  Accumulate(VA, VC, array_size, device_id);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/argonne-lcf/HPC-Patterns/aurora.mpich.miniapps/src/allreduce/mpi-omp-offload/allreduce-map-mpi-omp-offload/2"}
{"code": "for (long i = 0; i < 65536; i++)\n{\n  sum = sum + num[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arunabellgutteramesh/ConcurrentProgrammingWithOpenMPandOpenCL/OpenMP/OpenMP_NormalAlgorithm/0"}
{"code": "for (int i = 0; i < (C + 2); i++)\n  printf(\"-\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arcmarqs/EcosystemSim/src/util/5"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n  lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttx2 * speed[i - 1][j][k]);\n  lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n  lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttx2 * speed[i + 1][j][k]);\n  lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n  lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n  lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttx2 * speed[i - 1][j][k]);\n  lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n  lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttx2 * speed[i + 1][j][k]);\n  lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dttx2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/60"}
{"code": "for (uint32_t i = 0; i < conf->nboids; i++)\n{\n  uint32_t nb_neigh = 0;\n  float avg_posx = 0.0f;\n  float avg_posy = 0.0f;\n  float avg_velx = 0.0f;\n  float avg_vely = 0.0f;\n  float sepx = 0.0f;\n  float sepy = 0.0f;\n  float edgex = 0.0f;\n  float edgey = 0.0f;\n  float mx = 0.0f;\n  float my = 0.0f;\n  for (uint32_t j = 0; j < conf->nboids; j++)\n  {\n    float dist = distance(i, j, boids->xpos, boids->ypos);\n    if (dist < conf->range)\n    {\n      if (j == i)\n        continue;\n\n      nb_neigh++;\n      avg_posx += boids->xpos[j];\n      avg_posy += boids->ypos[j];\n      avg_velx += boids->xvel[j];\n      avg_vely += boids->yvel[j];\n      sepx += boids->xpos[j] - boids->xpos[i];\n      sepy += boids->ypos[j] - boids->ypos[i];\n    }\n\n    if (boids->xpos[i] < conf->range)\n      edgex = conf->range - boids->xpos[i];\n    else\n      if (boids->xpos[i] > (xmax - conf->range))\n      edgex = (xmax - conf->range) - boids->xpos[i];\n\n\n    if (boids->ypos[i] < conf->range)\n      edgey = conf->range - boids->ypos[i];\n    else\n      if (boids->ypos[i] > (ymax - conf->range))\n      edgey = (ymax - conf->range) - boids->ypos[i];\n\n\n    if (((((mousex > 0) && (mousex < ((int32_t) xmax))) && (mousey > 0)) && (mousey < ((int32_t) ymax))) && (distancexy(mousex, mousey, boids->xpos[i], boids->ypos[i]) < conf->mouserange))\n    {\n      mx = mousex - boids->xpos[i];\n      my = mousey - boids->ypos[i];\n    }\n\n  }\n\n  if (nb_neigh > 0)\n  {\n    avg_posx /= (float) nb_neigh;\n    avg_posy /= (float) nb_neigh;\n    avg_posx = avg_posx - boids->xpos[i];\n    avg_posy = avg_posy - boids->ypos[i];\n    normalize(&avg_posx, &avg_posy);\n    avg_velx /= (float) nb_neigh;\n    avg_vely /= (float) nb_neigh;\n    normalize(&avg_velx, &avg_vely);\n    sepx /= ((float) nb_neigh) * (-1.0f);\n    sepy /= ((float) nb_neigh) * (-1.0f);\n    normalize(&sepx, &sepy);\n  }\n\n  normalize(&edgex, &edgey);\n  mx *= -1.0f;\n  my *= -1.0f;\n  normalize(&mx, &my);\n  boids->next_xvel[i] = ((((boids->xvel[i] + (conf->mouse * mx)) + (conf->edge * edgex)) + (conf->sep * sepx)) + (conf->align * avg_velx)) + (conf->coh * avg_posx);\n  boids->next_yvel[i] = ((((boids->yvel[i] + (conf->mouse * my)) + (conf->edge * edgey)) + (conf->sep * sepy)) + (conf->align * avg_vely)) + (conf->coh * avg_posy);\n  normalize(boids->next_xvel + i, boids->next_yvel + i);\n  boids->next_xpos[i] = boids->xpos[i] + ((delta_t * conf->speed) * boids->next_xvel[i]);\n  boids->next_ypos[i] = boids->ypos[i] + ((delta_t * conf->speed) * boids->next_yvel[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gaetanbahl/flocking_opencl_openmp/src/boid/1"}
{"code": "for (j = 0; j < active_size; j++)\n  if (is_free(j))\n  nr_free++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/3"}
{"code": "for (i = 0; i < 24; i++)\n  if (p[i] != (i + 1))\n  __builtin_abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/target-8/2"}
{"code": "for (i = 0; i < order; i++)\n{\n  for (j = 0; j < rrank; j++)\n  {\n    for (k = 0; k < rrank; k++)\n    {\n      int pos1 = (i * mult) + j;\n      int pos2 = (i * mult) + k;\n      int now = (((i * rrank) * rrank) + (j * rrank)) + k;\n      pre_check[now] = 0;\n      for (l = 0; l < dim[i]; l++)\n      {\n        pre_check[now] += FactorM[pos1 + (l * rrank)] * FactorM[pos2 + (l * rrank)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/11"}
{"code": "for (size_t i = 1; i <= (featureTypes.size() - 1); ++i)\n{\n  candiColocCounter += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/2"}
{"code": "for (k = 0; k < argc; ++k)\n{\n  i = k;\n  v += i;\n}\n\n", "pragma": "    #pragma omp distribute parallel for simd linear(k:i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/distribute_parallel_for_simd_linear_messages/0"}
{"code": "for (int var = 0; var < selectProc.size(); var++)\n{\n  (cout << selectProc[var]) << \", \";\n  for (int var2 = 0; var2 < processors.size(); var2++)\n  {\n    if (processors[var2].getId() == selectProc[var])\n    {\n      selectedProcessors.push_back(processors[var2]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/6"}
{"code": "for (index = 0; index < count; index++)\n{\n  uint64_t u[8];\n  unsigned char static_privkey[64];\n  int j;\n  int success;\n  memcpy(u, host_crack[index].hash, 64);\n  for (j = 0; j < 8; j++)\n    u[j] = JOHNSWAP64(u[j]);\n\n  memcpy(static_privkey, u, 64);\n  success = diskcryptor_decrypt_data(static_privkey, cur_salt);\n  if (success)\n  {\n    cracked[index] = 1;\n    any_cracked |= 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/opencl_diskcryptor_fmt_plug/2"}
{"code": "for (int i = 0; i < argc; ++i)\n  a = (foo(&i) + foo(&a)) + foo(&argc);\n\n", "pragma": "#pragma omp target teams distribute parallel for map(tofrom:a) if(target:argc) schedule(static, a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/nvptx_target_teams_distribute_parallel_for_generic_mode_codegen/0"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * 1), stat[i].e2 / ((((double) (L * L)) * (L * L)) * 1), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * 1), stat[i].m / 1, stat[i].m2 / 1, stat[i].m4 / 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/29"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->Draw(I);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(Params.NumThreads) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/11"}
{"code": "for (int i = t0; i < Nt; i += 2)\n{\n  for (int j = t1; j < Ns; j += 2)\n  {\n    rho = 1.0;\n    del = Randint();\n    x[0] = i;\n    x[1] = j;\n    shiftx(x2, x, 1, 1);\n    shiftx(x1, x, 1, 0);\n    shiftx(x12, x2, 1, 0);\n    if (del > 0)\n    {\n      if (k[x[0]][x[1]][1] >= 0)\n        rho *= 1.0 / ((k[x[0]][x[1]][1] + 1) + a[x[0]][x[1]][1]);\n      else\n        rho *= abs(k[x[0]][x[1]][1]) + a[x[0]][x[1]][1];\n\n      if (k[x2[0]][x2[1]][0] >= 0)\n        rho *= 1.0 / ((k[x2[0]][x2[1]][0] + 1) + a[x2[0]][x2[1]][0]);\n      else\n        rho *= abs(k[x2[0]][x2[1]][0]) + a[x2[0]][x2[1]][0];\n\n      if (k[x[0]][x[1]][0] > 0)\n        rho *= k[x[0]][x[1]][0] + a[x[0]][x[1]][0];\n      else\n        rho *= 1.0 / ((abs(k[x[0]][x[1]][0]) + 1) + a[x[0]][x[1]][0]);\n\n      if (k[x1[0]][x1[1]][1] > 0)\n        rho *= k[x1[0]][x1[1]][1] + a[x1[0]][x1[1]][1];\n      else\n        rho *= 1.0 / ((abs(k[x1[0]][x1[1]][1]) + 1) + a[x1[0]][x1[1]][1]);\n\n      if ((k[x[0]][x[1]][1] >= 0) && (k[x[0]][x[1]][0] <= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][1] < 0) && (k[x[0]][x[1]][0] > 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n      if ((k[x2[0]][x2[1]][0] >= 0) && (k[x1[0]][x1[1]][1] <= 0))\n        rho *= I_val[sx(x12, k, a) + 2] / I_val[sx(x12, k, a)];\n      else\n        if ((k[x2[0]][x2[1]][0] < 0) && (k[x1[0]][x1[1]][1] > 0))\n        rho *= I_val[sx(x12, k, a) - 2] / I_val[sx(x12, k, a)];\n\n\n      if ((k[x2[0]][x2[1]][0] >= 0) && (k[x[0]][x[1]][1] >= 0))\n        rho *= I_val[sx(x2, k, a) + 2] / I_val[sx(x2, k, a)];\n      else\n        if ((k[x2[0]][x2[1]][0] < 0) && (k[x[0]][x[1]][1] < 0))\n        rho *= I_val[sx(x2, k, a) - 2] / I_val[sx(x2, k, a)];\n\n\n      if ((k[x1[0]][x1[1]][1] <= 0) && (k[x[0]][x[1]][0] <= 0))\n        rho *= I_val[sx(x1, k, a) + 2] / I_val[sx(x1, k, a)];\n      else\n        if ((k[x1[0]][x1[1]][1] > 0) && (k[x[0]][x[1]][0] > 0))\n        rho *= I_val[sx(x1, k, a) - 2] / I_val[sx(x1, k, a)];\n\n\n    }\n    else\n    {\n      if (k[x[0]][x[1]][1] <= 0)\n        rho *= 1.0 / ((abs(k[x[0]][x[1]][1]) + 1) + a[x[0]][x[1]][1]);\n      else\n        rho *= k[x[0]][x[1]][1] + a[x[0]][x[1]][1];\n\n      if (k[x2[0]][x2[1]][0] <= 0)\n        rho *= 1.0 / ((abs(k[x2[0]][x2[1]][0]) + 1) + a[x2[0]][x2[1]][0]);\n      else\n        rho *= k[x2[0]][x2[1]][0] + a[x2[0]][x2[1]][0];\n\n      if (k[x[0]][x[1]][0] < 0)\n        rho *= abs(k[x[0]][x[1]][0]) + a[x[0]][x[1]][0];\n      else\n        rho *= 1.0 / ((k[x[0]][x[1]][0] + 1) + a[x[0]][x[1]][0]);\n\n      if (k[x1[0]][x1[1]][1] < 0)\n        rho *= abs(k[x1[0]][x1[1]][1]) + a[x1[0]][x1[1]][1];\n      else\n        rho *= 1.0 / ((k[x1[0]][x1[1]][1] + 1) + a[x1[0]][x1[1]][1]);\n\n      if ((k[x[0]][x[1]][1] <= 0) && (k[x[0]][x[1]][0] >= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][1] > 0) && (k[x[0]][x[1]][0] < 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n      if ((k[x2[0]][x2[1]][0] <= 0) && (k[x1[0]][x1[1]][1] >= 0))\n        rho *= I_val[sx(x12, k, a) + 2] / I_val[sx(x12, k, a)];\n      else\n        if ((k[x2[0]][x2[1]][0] > 0) && (k[x1[0]][x1[1]][1] < 0))\n        rho *= I_val[sx(x12, k, a) - 2] / I_val[sx(x12, k, a)];\n\n\n      if ((k[x2[0]][x2[1]][0] <= 0) && (k[x[0]][x[1]][1] <= 0))\n        rho *= I_val[sx(x2, k, a) + 2] / I_val[sx(x2, k, a)];\n      else\n        if ((k[x2[0]][x2[1]][0] > 0) && (k[x[0]][x[1]][1] > 0))\n        rho *= I_val[sx(x2, k, a) - 2] / I_val[sx(x2, k, a)];\n\n\n      if ((k[x1[0]][x1[1]][1] >= 0) && (k[x[0]][x[1]][0] >= 0))\n        rho *= I_val[sx(x1, k, a) + 2] / I_val[sx(x1, k, a)];\n      else\n        if ((k[x1[0]][x1[1]][1] < 0) && (k[x[0]][x[1]][0] < 0))\n        rho *= I_val[sx(x1, k, a) - 2] / I_val[sx(x1, k, a)];\n\n\n    }\n\n    if (Rand() < rho)\n    {\n      k[x[0]][x[1]][1] += del;\n      k[x2[0]][x2[1]][0] += del;\n      k[x1[0]][x1[1]][1] -= del;\n      k[x[0]][x[1]][0] -= del;\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for private(x, x1, x2, x12, rho, del) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/7"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpiajxzg7e.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sx-aurora-dev/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (long int i = 0; i < snpCount; i++)\n{\n  configure[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/11"}
{"code": "for (i = 0; i < numPropertyRegions; i++)\n{\n  cache->propertyRegions[i].upper_bound = 0;\n  cache->propertyRegions[i].hot_bound = 0;\n  cache->propertyRegions[i].warm_bound = 0;\n  cache->propertyRegions[i].lower_bound = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/2"}
{"code": "for (int ix = 0; ix < DATAXSIZE; ix++)\n{\n  for (int iy = 0; iy < DATAYSIZE; iy++)\n  {\n    for (int iz = 0; iz < DATAZSIZE; iz++)\n    {\n      double r = sqrt((SQ(ix - (0.5 * DATAXSIZE)) + SQ(iy - (0.5 * DATAYSIZE))) + SQ(iz - (0.5 * DATAZSIZE)));\n      if (r < r0)\n      {\n        phi[ix][iy][iz] = 1.0;\n      }\n      else\n      {\n        phi[ix][iy][iz] = -1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-omp/main/6"}
{"code": "for (i = 0; i < section; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    temp = matrix[(i * n) + k] + kRow[j];\n    if (temp < matrix[(i * n) + j])\n    {\n      matrix[(i * n) + j] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads) shared(matrix, kRow, section, n) private(i, j, k, temp) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/hybrid/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"  %8d  %14.6g\\n\", i, x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/jacobi/6"}
{"code": "for (int i = pow(2, l); i < max; i++)\n{\n  descente->current[i] = descente->current[i] + montee->current[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  wcoefs[i] = xcoefs[i];\n}\n\n", "pragma": "      \t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gadube/simple_openmp_examples/cg-solve/cgsolve_omp/3"}
{"code": "for (size_t i = 0; i < (1 << 10); ++i)\n{\n  tmp += sum[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/practicos/practico3/overhead/2"}
{"code": "for (int l = 0; l < n; ++l)\n{\n  delete(a[l]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task9/6"}
{"code": "for (i = 0; i < 16; i++)\n  b[i] = i;\n\n", "pragma": "omp parallel for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/9"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    for (int k = 0; k < N; ++k)\n    {\n      C1[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Napier-JP/LearnC/C++/matrix_product/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < ((size - i) - 1); j++)\n  {\n    if (T[j + 1] < T[j])\n    {\n      tmp = T[j + 1];\n      T[j + 1] = T[j];\n      T[j] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/1"}
{"code": "for (long i = 0; i < SIZE; i++)\n{\n  if (p[i])\n  {\n    tid = omp_get_thread_num();\n    p_n[tid].push_back(i);\n  }\n\n}\n\n", "pragma": "        #pragma omp  for private(tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/prime/prime/2"}
{"code": "for (i = 1; i <= num_interval; i++)\n{\n  id = omp_get_thread_num();\n  x = (i - 0.5) * deltax;\n  pi = pi + ((4.0 / (1.0 + (x * x))) * deltax);\n}\n\n", "pragma": "omp for reduction (+:pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/pi_reduction/0"}
{"code": "for (s = 0; s < sz; s++)\n{\n  klabels[s] = -1;\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/13"}
{"code": "for (task = 0; task < 10; task++)\n{\n  qsort(bag_of_tasks[task], 100000, sizeof(int), cmpfunc);\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_omp/0"}
{"code": "for (int k = 0; k < 10; ++k)\n{\n  for (int x = 0; x < 10; ++x)\n    foo();\n\n}\n\n", "pragma": "  #pragma omp for lastprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/simd_private_messages/3"}
{"code": "for (i = 0; i <= 9; i += 1)\n{\n  printf(\"%3d %15.0f\\n\", i, q[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/EP/ep/8"}
{"code": "for (int x = 0; x < N; x++)\n{\n  for (int y = 0; y < N; y++)\n  {\n    matA[x][y] = rand();\n    matB[x][y] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/5"}
{"code": "for (size_t i = 0; i < C_len; i++)\n{\n  for (size_t j = 0; j < C[i]; j++)\n  {\n    A[k++] = i + min;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pepealessio/countingsort_openmp/source/counting_sort/5"}
{"code": "for (i = size; i < (8 * (1 * (1024 * 1024))); i++)\n  b[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-large-array/test/2"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  vx1 = _mm_load_ps((float *) (&xx[i]));\n  vx2 = _mm_load_ps((float *) (&xx[i + 2]));\n  vy1 = _mm_load_ps((float *) (&yy[i]));\n  vy2 = _mm_load_ps((float *) (&yy[i + 2]));\n  xre = _mm_shuffle_ps(vx1, vx2, 0x88);\n  xim = _mm_shuffle_ps(vx1, vx2, 0xDD);\n  yre = _mm_shuffle_ps(vy1, vy2, 0x88);\n  yim = _mm_shuffle_ps(vy1, vy2, 0xDD);\n  tmp1 = _mm_mul_ps(xre, yre);\n  tmp2 = _mm_mul_ps(xim, yim);\n  resre = _mm_add_ps(tmp1, tmp2);\n  tmp1 = _mm_mul_ps(xre, yim);\n  tmp2 = _mm_mul_ps(xim, yre);\n  resim = _mm_sub_ps(tmp1, tmp2);\n  _mm_store_ps(tmp, resre);\n  re += ((tmp[0] + tmp[1]) + tmp[2]) + tmp[3];\n  _mm_store_ps(tmp, resim);\n  im += ((tmp[0] + tmp[1]) + tmp[2]) + tmp[3];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+ : re) reduction(+ : im) reduction (+:tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/dotc/2"}
{"code": "for (i = oldI; i < N_gas; i++)\n{\n  if (P[i].Ti_endstep == All.Ti_Current)\n  {\n    for (j = 0; j < NTask; j++)\n    {\n      if (Exportflag2[(i * NTask) + j])\n      {\n        for (k = 0; k < 3; k++)\n        {\n          HydroDataIn[nexport].Pos[k] = P[i].Pos[k];\n          HydroDataIn[nexport].Vel[k] = SphP[i].VelPred[k];\n        }\n\n        HydroDataIn[nexport].Hsml = SphP[i].Hsml;\n        HydroDataIn[nexport].Mass = P[i].Mass;\n        HydroDataIn[nexport].DhsmlDensityFactor = SphP[i].DhsmlDensityFactor;\n        HydroDataIn[nexport].Density = SphP[i].Density;\n        HydroDataIn[nexport].Pressure = SphP[i].Pressure;\n        HydroDataIn[nexport].Timestep = P[i].Ti_endstep - P[i].Ti_begstep;\n        soundspeed_i = sqrt((GAMMA * SphP[i].Pressure) / SphP[i].Density);\n        HydroDataIn[nexport].F1 = fabs(SphP[i].DivVel) / ((fabs(SphP[i].DivVel) + SphP[i].CurlVel) + (((0.0001 * soundspeed_i) / SphP[i].Hsml) / fac_mu));\n        HydroDataIn[nexport].Index = i;\n        HydroDataIn[nexport].Task = j;\n        nexport++;\n        nsend_local[j]++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/hydra/3"}
{"code": "for (int i = 0; i < k; i++)\n  b[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task9/1"}
{"code": "for (int v_i = 0; v_i < num_vertices; v_i++)\n{\n  for (int neighbor_ind = row_ptr[v_i]; neighbor_ind < row_ptr[v_i + 1]; neighbor_ind++)\n  {\n    const int neighbor = col_ind[neighbor_ind];\n    if (colors[neighbor] == colors[v_i])\n    {\n      false_colored++;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:false_colored)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/4"}
{"code": "for (unsigned i = 0; i < num_h_neurons; ++i)\n{\n  avg_h += m.Hs[i];\n  avg_bh += m.biasH[i];\n  s += ((-m.Hp[i]) * log(m.Hp[i])) + ((1 - m.Hp[i]) * log(1 - m.Hp[i]));\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:s,avg_h)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/19"}
{"code": "for (int i = j_start; i < j_end; i++)\n{\n  for (j = 0; j < ncols; j++)\n  {\n    modif |= calcul_Wij(W, Wprec, m, i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(|:modif) default(none) private(j) shared(nrows,rank, j_start, j_end, ncols, W, Wprec, m)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/darboux/2"}
{"code": "for (i = 0; i < order; i++)\n{\n  for (j = 0; j < X.dimension[i]; j++)\n  {\n    CountX[(i * max_dim) + j] = (tempX[(i * max_dim) + j] = 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/7"}
{"code": "for (int i = 0; i < max_iterations; i++)\n{\n  start_time = omp_get_wtime();\n  assign_pixels(data, centers, labels, distances, &have_clusters_changed, n_pixels, n_channels, n_clusters);\n  assign_pixels_time += omp_get_wtime() - start_time;\n  if (!have_clusters_changed)\n  {\n    break;\n  }\n\n  start_time = omp_get_wtime();\n  update_centers(data, centers, labels, distances, n_pixels, n_channels, n_clusters);\n  update_centers_time += omp_get_wtime() - start_time;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blarc/image-compression-k-means/src/compression_omp/4"}
{"code": "for (int SngValN = 0; SngValN < SngValV.Len(); SngValN++)\n{\n  if (SngValV[SngValN] < 0.0)\n  {\n    printf(\"bad sng val: %d %g\\n\", SngValN, SngValV[SngValN]());\n    SngValV[SngValN] = 0;\n  }\n\n  SngValV[SngValN] = sqrt(SngValV[SngValN].Val);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/87"}
{"code": "for (i1 = 0; i1 < number_of_words; i1++)\n{\n  for (i2 = i1 + 1; i2 < number_of_words;)\n  {\n    if (strcmp(words[i2], words[i1]) == 0)\n    {\n      for (k = i2; k < number_of_words; k++)\n        words[k] = words[k + 1];\n\n      number_of_words--;\n    }\n    else\n      i2++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/docfreq2/4"}
{"code": "for (int i = 0; i < N; ++i)\n  hst_ptr[i] -= 1;\n\n", "pragma": "omp target teams distribute parallel for device(device) map(tofrom:hst_ptr[0 : N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/test/api/omp_host_pinned_memory/0"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  divideImageDataWithParam(src.data(), width, dst.data(), width, size, PARAM);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  mean = mean + A[i];\n}\n\n", "pragma": "\t#pragma omp for private(i) reduction(+:mean) ", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FrankYufeiYang/OpenMP/Part1/abc123_threadSd/sd_thread/0"}
{"code": "for (i = 0; i < histogram_size; i++)\n{\n  for (j = 0; j < num_threads; j++)\n  {\n    histogram[i] += this_histogram[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mklobukov/Parallel-Programming/Parallelized Programs/GaussianOpenMP/Assignment2_Mark_Klobukov/histogram/2"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < p; ++j)\n  {\n    (cout << \" \") << multi[i][j];\n    if (j == (p - 1))\n      cout << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task1(a+b)/5"}
{"code": "for (int i = 0; i < un.size(); ++i)\n{\n  if (!res)\n    continue;\n\n  if (!contains(set_3, un[i]))\n  {\n    res = false;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kiiitG/homework4_openmp/main/5"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"ADD %d\\n\", a + i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/no_wait/0"}
{"code": "for (int f = m - 2; f >= 0; f--)\n{\n  double sum = 0;\n  for (int i = m - 1; i > f; i--)\n  {\n    sum += matriz[f][i] * resul[i];\n  }\n\n  resul[f] = (matriz[f][m] - sum) / matriz[f][f];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejovanihh191197/MetodoGaussOpenMP/gauss/3"}
{"code": "for (int i = 0; i < num_linhas; i++)\n{\n  for (int j = 0; j < num_colunas; j++)\n  {\n    for (int k = 0; k < 3; k++)\n    {\n      (((((((((cout << \"Peso \") << k) << \" do neur\u00f4nio de indices: \") << i) << \"\") << j) << \" \") << \": \") << grid_de_neuronios[i][j].get_vetor_de_pesos()[k]) << endl;\n    }\n\n    cout << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruteee/Kohhonen/Rede/8"}
{"code": "for (i = 0; i < len; ++i)\n  sum += A[i];\n\n", "pragma": "    #pragma omp parallel for default(none) shared(len,A) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex5-norm-mean-stddev-openmp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int foundNodes = 0;\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      continue;\n    }\n\n    if (array[(i * n) + j])\n    {\n      graph->nodes[i]->degree++;\n      graph->nodes[i]->neighbours[foundNodes] = graph->nodes[j];\n      foundNodes++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z3y50n/ReverseCuthillMcKee/src/functions/3"}
{"code": "for (i = 0; i < 4; i++)\n{\n  value = value + 1;\n  printf(\"value=%d increased by thread=%d\\n\", value, omp_get_thread_num());\n}\n\n", "pragma": "omp for firstprivate(value) lastprivate(value)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp3/lastprivate/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp8ct8vklu.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/runtime/test/affinity/format/affinity_values/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"%d \", row_sum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Matrices/matrix_row_sum/1"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  if (p[i] != 0)\n  {\n    minV = p[i];\n    maxV = p[i];\n    for (j = 0; j < topoinfo->numR; j++)\n    {\n      if (topoinfo->TargetG[j] == i)\n      {\n        if (topoinfo->TypeR[j] == 1)\n        {\n          minV = minV * (1.0 / p[topoinfo->ParasPos[j] + 2]);\n        }\n        else\n          if (topoinfo->TypeR[j] == 2)\n        {\n          minV = minV * p[topoinfo->ParasPos[j] + 2];\n        }\n\n\n      }\n\n    }\n\n    minV = minV / p[topoinfo->numG + i];\n    maxV = maxV / p[topoinfo->numG + i];\n    y[i] = exp2(randu(log2(minV), log2(maxV)));\n  }\n  else\n  {\n    y[i] = 0.0;\n    ytmp[i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/85"}
{"code": "for (int i = 0; i <= RowCount; i++)\n{\n  for (int j = 0; j <= ColCount; j++)\n  {\n    ((cout << setw(10)) << left) << getElementAt(i, j);\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/inirion/MpiIndexowanie/Source/5"}
{"code": "for (size_t i = 0; i < row_size; ++i)\n{\n  getline(ss, value, ',');\n  if (i == idIdx)\n  {\n    if (labelIdx == (-1))\n    {\n      ids.push_back(strtol(value.c_str(), nullptr, 10));\n    }\n    else\n    {\n      ids.push_back(row);\n    }\n\n  }\n  else\n    if (i == labelIdx)\n  {\n    y.push_back(strtol(value.c_str(), nullptr, 10));\n  }\n  else\n  {\n    temp[col] = strtod(value.c_str(), nullptr);\n    col++;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joyeecheung/parallel-random-forest/src/RandomForest/4"}
{"code": "for (int i = 0; i < max; ++i)\n{\n  res += 1;\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PamplemousseMR/OPENMPNGINE/For/main/0"}
{"code": "for (i = 0; i < ((nx * ny) * nz); ++i)\n{\n  if (i % 1)\n  {\n    rb[i] = 'r';\n  }\n  else\n  {\n    rb[i] = 'b';\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilmerhenao/Poisson-OpenMP/serial_hw2/7"}
{"code": "for (int i = 0; i < m; i++)\n  x[i] = h_x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/spmv/omp_simd/3"}
{"code": "for (i = 0; i < 30; i++)\n{\n  for (j = 0; j < 30; j++)\n  {\n    int thread = calc_thread(30, 30, i, j);\n    printf(\"%d L: %p\\n\", thread, &w[i][j]);\n    printf(\"%d S: %p\\n\", thread, &u[i][j]);\n    u[i][j] = w[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/7"}
{"code": "for (int k = 1; k <= nk; ++k)\n{\n  for (int j = 1; j <= nj; ++j)\n  {\n    for (int i = 1; i <= ni; ++i)\n    {\n      Pdqdx_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n      Pdqdy_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n      Pdqdz_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/12"}
{"code": "for (k = 0; k < omp_get_max_threads(); k++)\n{\n  dtemp_t[k] = 0.0;\n  istart[k] = ib * k;\n  iend[k] = (k + 1) * ib;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Reduction/C/reduction/5"}
{"code": "for (j = 0; j < interpolation_order; j++)\n{\n  if (m != j)\n  {\n    num *= x - (1 - ((2 * ((double) j)) / ((double) (interpolation_order - 1))));\n    denom *= ((-2) * (((double) m) - ((double) j))) / ((double) (interpolation_order - 1));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/26"}
{"code": "for (i = numpatterns; i < numf2s; i++)\n  Y[o][i].reset = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/18"}
{"code": "for (i_p = 0; i_p < parameters->n_particles; i_p++)\n{\n  rn_skip((((i_b * parameters->n_generations) + i_g) * parameters->n_particles) + i_p);\n  get_particle(&p, &source_bank->p[i_p]);\n  transport(parameters, geometry, material, source_bank, fission_bank, tally, &p);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wangsnowyin/monte-carlo/eigenvalue/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 2)\n    {\n      int pp = IDX(i, j, k);\n      if (betay[pp] > 0.0)\n      {\n        Dyu[pp] = ((((((-3.0) * u[pp - nx]) - (10.0 * u[pp])) + (18.0 * u[pp + nx])) - (6.0 * u[pp + (2 * nx)])) + u[pp + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp] = (((((-u[pp - (3 * nx)]) + (6.0 * u[pp - (2 * nx)])) - (18.0 * u[pp - nx])) + (10.0 * u[pp])) + (3.0 * u[pp + nx])) * idy_by_12;\n      }\n\n      if (betay[pp + 1] > 0.0)\n      {\n        Dyu[pp + 1] = ((((((-3.0) * u[(pp + 1) - nx]) - (10.0 * u[pp + 1])) + (18.0 * u[(pp + 1) + nx])) - (6.0 * u[(pp + 1) + (2 * nx)])) + u[(pp + 1) + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp + 1] = (((((-u[(pp + 1) - (3 * nx)]) + (6.0 * u[(pp + 1) - (2 * nx)])) - (18.0 * u[(pp + 1) - nx])) + (10.0 * u[pp + 1])) + (3.0 * u[(pp + 1) + nx])) * idy_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/14"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if ((strcmp(argv[i], \"-time\") == 0) || (strcmp(argv[i], \"-t\") == 0))\n  {\n    char *totalTimeStr = argv[i + 1];\n    totalItter = (atoi(totalTimeStr) * 60) / DELTA_TIME;\n  }\n  else\n    if ((strcmp(argv[i], \"-logfreq\") == 0) || (strcmp(argv[i], \"-lf\") == 0))\n  {\n    char *str = argv[i + 1];\n    secondBetweenOutputLog = atoi(str);\n  }\n  else\n    if ((strcmp(argv[i], \"-in\") == 0) || (strcmp(argv[i], \"-i\") == 0))\n  {\n    inputFileName = argv[i + 1];\n  }\n  else\n    if ((strcmp(argv[i], \"-threads\") == 0) || (strcmp(argv[i], \"-n\") == 0))\n  {\n    char *numThreadsStr = argv[i + 1];\n    numThreads = atoi(numThreadsStr);\n    printf(\"numThreads = %d\\n\", numThreads);\n  }\n  else\n    if (((strcmp(argv[i], \"-help\") == 0) || (strcmp(argv[i], \"-h\") == 0)) || (strcmp(argv[i], \"--help\") == 0))\n  {\n    printf(\"\\n%s\\n\\n\", helpString);\n    return 0;\n  }\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KeelyHill/Parallel-Sat-Swarm/main/0"}
{"code": "for (count = 1; count < (rows - 1); count++)\n{\n  mindistance = 9999;\n  for (i = 0; i < rows; i++)\n    if ((distance[i] < mindistance) && (!visited[i]))\n  {\n    mindistance = distance[i];\n    nextnode = i;\n  }\n\n\n  visited[nextnode] = 1;\n  for (i = 0; i < rows; i++)\n    if (!visited[i])\n    if ((mindistance + cost[nextnode][i]) < distance[i])\n  {\n    distance[i] = mindistance + cost[nextnode][i];\n    pred[i] = nextnode;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chander2207/Dijkstra-openmp/omp_dijkstra/15"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  MPI_Recv(&ans, 1, (MPI_Datatype) 0x4c00080b, -2, -1, 1, &status);\n  sender = status.MPI_SOURCE;\n  anstype = status.MPI_TAG;\n  c[anstype - 1] = ans;\n  if (numsent < nrows)\n  {\n    for (j = 0; j < ncols; j++)\n    {\n      buffer[j] = aa[(numsent * ncols) + j];\n    }\n\n    MPI_Send(buffer, ncols, (MPI_Datatype) 0x4c00080b, sender, numsent + 1, 1);\n    numsent++;\n  }\n  else\n  {\n    MPI_Send((void *) 0, 0, (MPI_Datatype) 0x4c00080b, sender, 0, 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/albertjbelardino/OpenMpMatrix/mxv_omp_mpi/3"}
{"code": "for (j = 0; j < cM->columns; j++)\n{\n  nNZ = 0;\n  rowPos = 0;\n  k = 0;\n  for (i = 0; i < cM->nZero[j]; i++)\n  {\n    while (rowPos < cM->Zero[j][(i * 2) + 0])\n    {\n      M[j + (rowPos * cM->columns)] = cM->NoneZero[j][nNZ];\n      nNZ++;\n      rowPos++;\n    }\n\n    while (rowPos < cM->Zero[j][(i * 2) + 1])\n    {\n      M[j + (rowPos * cM->columns)] = 0.0;\n      rowPos++;\n    }\n\n  }\n\n  assert((nNZ <= cM->nNoneZero[j]) && \"Too many NZ values!\");\n  while (nNZ < cM->nNoneZero[j])\n  {\n    M[j + (rowPos * cM->columns)] = cM->NoneZero[j][nNZ];\n    rowPos++;\n    nNZ++;\n  }\n\n  assert((rowPos == cM->rows) && \"Not correct row Position!\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mapa17/teacup/teacup_tools/8"}
{"code": "for (size_t j = 2; j <= word_len; j++)\n{\n  for (size_t i = 1; i <= ((word_len - j) + 1); i++)\n  {\n    for (size_t k = 1; k <= (j - 1); k++)\n    {\n      for (size_t ruleIdx = 0; ruleIdx < pGrammar->grammar_size; ruleIdx++)\n      {\n        grammar_entry_t *pRule = pGrammar->grammar_entries + ruleIdx;\n        if (pRule->single_char)\n        {\n          continue;\n        }\n\n        alpha_t c1;\n        alpha_t c2;\n        c1 = pRule->pTerminals[0];\n        c2 = pRule->pTerminals[1];\n        if (table_char_exists(pTable[(k - 1) + ((i - 1) * word_len)], c1) && table_char_exists(pTable[((j - k) - 1) + (((i + k) - 1) * word_len)], c2))\n        {\n          table_push_back(pTable, (j - 1) + ((i - 1) * word_len), pRule->non_terminal);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(4) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/an9080/Parallel-Processing-OpenMP/CYK/1"}
{"code": "for (int i = 0; i < N; i++)\n  scanf(\"%s\", &board[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/NQueen/main/4"}
{"code": "for (unsigned long long int i = 0; i <= n; i++)\n{\n  sum += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidWallacedot/openMP/parallel_sum/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    a[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lakhanjhawar/Parallel_Programming-Multithreading-Openmp-MPI-/Openmp/matrix1loop/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  tid = omp_get_thread_num();\n  for (j = 0; j < P; j++)\n  {\n    val = 0;\n    for (k = 0; k < M; k++)\n    {\n      val = val + (A[i][k] * B[k][j]);\n    }\n\n    C[i][j] = val;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(val,tid,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Achyut2404/parMatMult/src/ompMatFuncs/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (press[i] < 0)\n    press[i] = 0.0;\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/52"}
{"code": "for (int i = 0; i < (2 * n); ++i)\n  F[i] += Ft[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project2/nbody/nbomp/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  control++;\n  if (((m[i] != 0) && (i != (n - 1))) && (m[i + 1] == 0))\n  {\n    total++;\n    if (m[i] > maior)\n      maior = m[i];\n\n    if (m[i] < menor)\n      menor = m[i];\n\n  }\n\n  if ((i == (n - 1)) && (m[i] != 0))\n  {\n    total++;\n    if (m[i] > maior)\n      maior = m[i];\n\n    if (m[i] < menor)\n      menor = m[i];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule(static,chunk) reduction(+:total) reduction(max:maior) reduction(min:menor)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/9"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n{\n  sum += c[i][j];\n  sum2 += c2[i][j];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/matrixmultiply/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/1"}
{"code": "for (int i = 0; i < block_size; ++i)\n{\n  for (unsigned j = 0; j < kratos_connectivities.size2(); ++j)\n  {\n    const int kratos_id = kratos_connectivities(i, j);\n    xdmf_connectivities(i, j) = mKratosToXdmfIdMap.at(kratos_id);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/HDF5Application/custom_processes/hdf5_xdmf_connectivities_writer_process/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double t = sqrt((inpB[2 * i] * inpB[2 * i]) + (inpB[(2 * i) + 1] * inpB[(2 * i) + 1]));\n  double delB = maxB - minB;\n  if (t != 0)\n    freq->imageData[(3 * i) + 2] = (char) ((255 * (log(t) - minB)) / delB);\n  else\n    freq->imageData[(3 * i) + 2] = 0;\n\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/15. filter (mkl)/filter/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(fp, \"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/med/4"}
{"code": "for (int i = 0; i < m_threads; ++i)\n{\n  media = media + best_sol[i];\n  if (i == 0)\n  {\n    best = best_sol[i];\n  }\n  else\n    if (best_sol[i] < best)\n  {\n    best = best_sol[i];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leandrosfj/OpenMP_CSA/C\u00f3digos/OMP_CSA/3"}
{"code": "for (i = 0; i < xsize; i++)\n{\n  for (j = 0; j < ysize; j++)\n  {\n    image[(j * xsize) + i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/rendermodule/6"}
{"code": "for (int i = 0; i < len; i++)\n{\n  int pos = find(ux.begin(), ux.end(), x[i]) - ux.begin();\n  if (pos <= j)\n  {\n    if (y(i, 1) == 1.0)\n    {\n      sumTrtleft = sumTrtleft + (y(i, 0) / y(i, 2));\n      sumTrtWtleft = sumTrtWtleft + (1 / y(i, 2));\n    }\n    else\n    {\n      sumUntrtleft = sumUntrtleft + (y(i, 0) / (1 - y(i, 2)));\n      sumUntrtWtleft = sumUntrtWtleft + (1 / (1 - y(i, 2)));\n    }\n\n  }\n  else\n  {\n    if (y(i, 1) == 1)\n    {\n      sumTrtright = sumTrtright + (y(i, 0) / y(i, 2));\n      sumTrtWtright = sumTrtWtright + (1 / y(i, 2));\n    }\n    else\n    {\n      sumUntrtright = sumUntrtright + (y(i, 0) / (1 - y(i, 2)));\n      sumUntrtWtright = sumUntrtWtright + (1 / (1 - y(i, 2)));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjnsteven/wb_openmp/splitc/5"}
{"code": "for (uint32_t i = 0; i != m_vVertexOrder.size(); ++i)\n{\n  if ((i == 0) || (m_vCompId[m_vVertexOrder[i - 1]] != m_vCompId[m_vVertexOrder[i]]))\n    m_vBookmark[m_vCompId[m_vVertexOrder[i]]] = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (i == j)\n    {\n      A[i][j] = ((double) (rand() % maxnum)) + 5.0;\n    }\n    else\n    {\n      A[i][j] = ((double) (rand() % maxnum)) + 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/GuassianElimination_Parallell/1"}
{"code": "for (i = 1; i < 10; i++)\n{\n  if (a[i] > max_val)\n    max_val = a[i];\n\n  if (min_val > a[i])\n    min_val = a[i];\n\n}\n\n", "pragma": "omp parallel for ordered schedule(static,chunksize) reduction(max:max_val) reduction(min:min_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_7/Ejercicio_3/minMaxVector_openmp/1"}
{"code": "for (i = 0; i < nr_centroids; i++)\n{\n  for (j = 0; j < (dimensions - 1); j++)\n  {\n    fprintf(f_out, \"%lf, \", centroids[(i * dimensions) + j]);\n  }\n\n  fprintf(f_out, \"%lf\\n\", centroids[((i * dimensions) + dimensions) - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/12"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n      fprintf(stderr, \"OK\\n\");\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(stderr, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(stderr, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(stderr, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static/8"}
{"code": "for (j = 0; j < 64; j++)\n  if ((ran >> j) & 1)\n  temp ^= m2[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/randomAccess-omp/main/1"}
{"code": "for (int k = 0; k < num; ++k)\n{\n  y[k] = (a * x[k]) + y[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vksmgr/OpenMp/src/openmp/run/2"}
{"code": "for (p = 0; p < Np; p++)\n{\n  X_p = memory_to_matrix__MatrixLib__(Ndim, 1, MPM_Mesh.Phi.x_GC.nM[p]);\n  lambda_p = memory_to_matrix__MatrixLib__(Ndim, 1, MPM_Mesh.lambda.nM[p]);\n  DF_p = memory_to_matrix__MatrixLib__(Ndim, Ndim, MPM_Mesh.Phi.DF.nM[p]);\n  Beta_p = memory_to_matrix__MatrixLib__(Ndim, Ndim, MPM_Mesh.Beta.nM[p]);\n  Cut_off_Ellipsoid_p = memory_to_matrix__MatrixLib__(Ndim, Ndim, MPM_Mesh.Cut_off_Ellipsoid.nM[p]);\n  update_beta__aLME__(Beta_p, DF_p);\n  update_cut_off_ellipsoid__aLME__(Cut_off_Ellipsoid_p, DF_p);\n  free__SetLib__(&MPM_Mesh.ListNodes[p]);\n  MPM_Mesh.ListNodes[p] = 0;\n  MPM_Mesh.ListNodes[p] = tributary__aLME__(p, X_p, Cut_off_Ellipsoid_p, MPM_Mesh.I0[p], FEM_Mesh);\n  MPM_Mesh.NumberNodes[p] = lenght__SetLib__(MPM_Mesh.ListNodes[p]);\n  Delta_Xip = compute_distance__MeshTools__(MPM_Mesh.ListNodes[p], X_p, FEM_Mesh.Coordinates);\n  update_lambda_Newton_Rapson__aLME__(p, Delta_Xip, lambda_p, Beta_p);\n  free__MatrixLib__(Delta_Xip);\n  free(Cut_off_Ellipsoid_p.nM);\n  free(Beta_p.nM);\n  free(DF_p.nM);\n}\n\n", "pragma": "omp for private(p, X_p, Delta_Xip, lambda_p, DF_p, Beta_p, Cut_off_Ellipsoid_p)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/3"}
{"code": "for (i = 0; i < count; i++)\n  processwork(parr[i]);\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_omp25/0"}
{"code": "for (h = 0; h < 1024; ++h)\n  C[h] = malloc(1024 * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial_double/4"}
{"code": "for (k = 0; k < 1000; k++)\n  sum = a[x][k] * b[k][y];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh2496/OpenMP-Programming-Problems/P4/p4/2"}
{"code": "for (int i = 0; i < ((int) data.size()); i++)\n{\n  center_counts[assignments[i]]++;\n  for (int j = 0; j < ((int) centers[assignments[i]].size()); j++)\n  {\n    centers[assignments[i]][j] += data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par1/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < (n - 1); j++)\n  {\n    if (strcmp(files[i].hash, \"1B2M2Y8AsgTpgAmY7PhCfg\") == 0)\n      continue;\n\n    if (strcmp(files[j].hash, \"1B2M2Y8AsgTpgAmY7PhCfg\") == 0)\n      continue;\n\n    if ((i != j) && (strcmp(files[i].hash, files[j].hash) == 0))\n    {\n      printf(\"\\nDuplicate File at %s\", files[j].name);\n      getch();\n      remove(files[j].name);\n      files[j] = nul;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purugoyal96/Distinctive-CLI-Parallel/legit/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (n = 0; n <= 4; n += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i][j][k + 1][n]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/148"}
{"code": "for (ix = start; ix < (start + len); ix++)\n{\n  REAL *temp_u = &u[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n  REAL *temp_uold = &uold[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n  for (iy = 0; iy < m; iy++)\n  {\n    for (iz = 0; iz < k; iz++)\n    {\n      REAL result = temp_uold[0] * coeff[0];\n      for (ir = 1; ir <= radius; ir++)\n      {\n        result += coeff[ir] * temp_uold[ir];\n        result += coeff[-ir] * temp_uold[-ir];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimZ];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimZ];\n      }\n\n      *temp_u = result / count;\n      temp_u++;\n      temp_uold++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/stencil3d/kernel_launcher/1"}
{"code": "for (j = 0; j < gt_n; j++)\n{\n  a[((p + lt_n) + j) + 1] = gt[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/docfreq2/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/haalon-old/mpi-openmp/omp/2"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  neighbor[v] = 0;\n}\n\n", "pragma": "omp parallel for default(none) private(v) shared(graph,neighbor)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/7"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    Dxu[IDX(ie - 2, j, k)] = ((-u[IDX(ie - 3, j, k)]) + u[IDX(ie - 1, j, k)]) * idx_by_2;\n    Dxu[IDX(ie - 1, j, k)] = ((u[IDX(ie - 3, j, k)] - (4.0 * u[IDX(ie - 2, j, k)])) + (3.0 * u[IDX(ie - 1, j, k)])) * idx_by_2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/3"}
{"code": "for (j = 0; j < k; j++)\n  a[j + 112] = j + 112;\n\n", "pragma": "omp for schedule (monotonic: runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/7"}
{"code": "for (int ii = 0; ii < N; ii++)\n{\n  for (int jj = 0; jj < N; jj++)\n  {\n    printf(\"array3d[%d][%d][%d] = %f.\\n\", ii, jj, index, evaluate_array3d(array3d, N, ii, jj, index));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/array3d/2"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    *((u + (i * x_points)) + j) = 1.0;\n    *((v + (i * x_points)) + j) = 1.0;\n    *((u_new + (i * x_points)) + j) = 1.0;\n    *((v_new + (i * x_points)) + j) = 1.0;\n    if (((((*(x + j)) > 0.5) && ((*(x + j)) < 1.0)) && ((*(y + i)) > 0.5)) && ((*(y + i)) < 1.0))\n    {\n      *((u + (i * x_points)) + j) = 2.0;\n      *((v + (i * x_points)) + j) = 2.0;\n      *((u_new + (i * x_points)) + j) = 2.0;\n      *((v_new + (i * x_points)) + j) = 2.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/2-D_NonLinear_Convection/2-D_Nonlinear_Convection_Dynamic/main/1"}
{"code": "for (i = 0; i < (1 << TOTAL_KEYS_LOG_2); i++)\n{\n  key_buff2[i] = key_array[i];\n  prv_buff1[key_buff2[i]]++;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/49"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    m[i][j] = rnd(5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/igrishaev/vsu-prp/matrix_fox_omp/1"}
{"code": "for (iteration = 0; iteration < CLOMP_num_iterations; iteration++)\n{\n  dynamic_omp_cycle();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if ((h[0][i][j] >= 0.0) && (h[0][i][j] <= 5.0))\n    {\n      XSetForeground(display, gc, (long) blue);\n    }\n\n    if ((h[0][i][j] > 5.0) && (h[0][i][j] <= 10.0))\n    {\n      XSetForeground(display, gc, (long) cyan_blue);\n    }\n    else\n      if ((h[0][i][j] > 10.0) && (h[0][i][j] <= 20.0))\n    {\n      XSetForeground(display, gc, (long) cyan);\n    }\n    else\n      if ((h[0][i][j] > 20.0) && (h[0][i][j] <= 30.0))\n    {\n      XSetForeground(display, gc, (long) green_cyan);\n    }\n    else\n      if ((h[0][i][j] > 30.0) && (h[0][i][j] <= 40.0))\n    {\n      XSetForeground(display, gc, (long) green);\n    }\n    else\n      if ((h[0][i][j] > 40.0) && (h[0][i][j] <= 50.0))\n    {\n      XSetForeground(display, gc, (long) yellow_green);\n    }\n    else\n      if ((h[0][i][j] > 50.0) && (h[0][i][j] <= 60.0))\n    {\n      XSetForeground(display, gc, (long) yellow);\n    }\n    else\n      if ((h[0][i][j] > 60.0) && (h[0][i][j] <= 70.0))\n    {\n      XSetForeground(display, gc, (long) yellow_orange);\n    }\n    else\n      if ((h[0][i][j] > 70.0) && (h[0][i][j] <= 80.0))\n    {\n      XSetForeground(display, gc, (long) orange);\n    }\n    else\n      if ((h[0][i][j] > 80.0) && (h[0][i][j] <= 90.0))\n    {\n      XSetForeground(display, gc, (long) orange);\n    }\n    else\n      if ((h[0][i][j] > 90.0) && (h[0][i][j] <= 100.0))\n    {\n      XSetForeground(display, gc, (long) red);\n    }\n\n\n\n\n\n\n\n\n\n\n    XFillArc(display, win, gc, x_counter, y_counter, 5, 5, 0, 23040);\n    x_counter += 10;\n  }\n\n  x_counter = 0;\n  y_counter += 10;\n}\n\n", "pragma": "omp for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/parallelx/1"}
{"code": "for (unsigned i = 0; i < size; ++i)\n{\n  (out << rand()) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_1/parallel_1/0"}
{"code": "for (int c = 0; c < 2; c++)\n{\n  for (int ii = 0; ii < nx; ii++)\n  {\n    jj = (c == 0) ? (1) : (ny);\n    int y_n = jj + 1;\n    int x_e = (ii + 1) % nx;\n    int y_s = jj - 1;\n    int x_w = (ii == 0) ? ((ii + nx) - 1) : (ii - 1);\n    float tmpSpeed0 = speed0[ii + (jj * nx)];\n    float tmpSpeed1 = speed1[x_w + (jj * nx)];\n    float tmpSpeed2 = speed2[ii + (y_s * nx)];\n    float tmpSpeed3 = speed3[x_e + (jj * nx)];\n    float tmpSpeed4 = speed4[ii + (y_n * nx)];\n    float tmpSpeed5 = speed5[x_w + (y_s * nx)];\n    float tmpSpeed6 = speed6[x_e + (y_s * nx)];\n    float tmpSpeed7 = speed7[x_e + (y_n * nx)];\n    float tmpSpeed8 = speed8[x_w + (y_n * nx)];\n    float local_density = 0.f;\n    local_density += tmpSpeed0;\n    local_density += tmpSpeed1;\n    local_density += tmpSpeed2;\n    local_density += tmpSpeed3;\n    local_density += tmpSpeed4;\n    local_density += tmpSpeed5;\n    local_density += tmpSpeed6;\n    local_density += tmpSpeed7;\n    local_density += tmpSpeed8;\n    float u_x = (((tmpSpeed1 + tmpSpeed5) + tmpSpeed8) - ((tmpSpeed3 + tmpSpeed6) + tmpSpeed7)) / local_density;\n    float u_y = (((tmpSpeed2 + tmpSpeed5) + tmpSpeed6) - ((tmpSpeed4 + tmpSpeed7) + tmpSpeed8)) / local_density;\n    u_sq = (u_x * u_x) + (u_y * u_y);\n    reduction_buffer[0] += (!obstacles[ii + (jj * nx)]) ? (sqrtf(u_sq)) : (0);\n    float u[9];\n    u[1] = u_x;\n    u[2] = u_y;\n    u[3] = -u_x;\n    u[4] = -u_y;\n    u[5] = u_x + u_y;\n    u[6] = (-u_x) + u_y;\n    u[7] = (-u_x) - u_y;\n    u[8] = u_x - u_y;\n    float d_equ[9];\n    d_equ[0] = (w0 * local_density) * (1.f - (u_sq / (2.f * c_sq)));\n    d_equ[1] = (w1 * local_density) * (((1.f + (u[1] / c_sq)) + ((u[1] * u[1]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[2] = (w1 * local_density) * (((1.f + (u[2] / c_sq)) + ((u[2] * u[2]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[3] = (w1 * local_density) * (((1.f + (u[3] / c_sq)) + ((u[3] * u[3]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[4] = (w1 * local_density) * (((1.f + (u[4] / c_sq)) + ((u[4] * u[4]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[5] = (w2 * local_density) * (((1.f + (u[5] / c_sq)) + ((u[5] * u[5]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[6] = (w2 * local_density) * (((1.f + (u[6] / c_sq)) + ((u[6] * u[6]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[7] = (w2 * local_density) * (((1.f + (u[7] / c_sq)) + ((u[7] * u[7]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[8] = (w2 * local_density) * (((1.f + (u[8] / c_sq)) + ((u[8] * u[8]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    tmp_speed0[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed0 + (omega * (d_equ[0] - tmpSpeed0))) : (tmpSpeed0);\n    tmp_speed1[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed1 + (omega * (d_equ[1] - tmpSpeed1))) : (tmpSpeed3);\n    tmp_speed2[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed2 + (omega * (d_equ[2] - tmpSpeed2))) : (tmpSpeed4);\n    tmp_speed3[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed3 + (omega * (d_equ[3] - tmpSpeed3))) : (tmpSpeed1);\n    tmp_speed4[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed4 + (omega * (d_equ[4] - tmpSpeed4))) : (tmpSpeed2);\n    tmp_speed5[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed5 + (omega * (d_equ[5] - tmpSpeed5))) : (tmpSpeed7);\n    tmp_speed6[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed6 + (omega * (d_equ[6] - tmpSpeed6))) : (tmpSpeed8);\n    tmp_speed7[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed7 + (omega * (d_equ[7] - tmpSpeed7))) : (tmpSpeed5);\n    tmp_speed8[ii + (jj * nx)] = (!obstacles[ii + (jj * nx)]) ? (tmpSpeed8 + (omega * (d_equ[8] - tmpSpeed8))) : (tmpSpeed6);\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for reduction(+:reduction_buffer[0]) collapse(2) schedule(static, 1) private(y_n, x_e, y_s, x_w, local_density, u_x, u_y, u_sq, tmpSpeed0, tmpSpeed1, tmpSpeed2, tmpSpeed3, tmpSpeed4, tmpSpeed5, tmpSpeed6, tmpSpeed7, tmpSpeed8)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bkazi/lattice-boltzmann/d2q9-bgk/1"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < M; ++j)\n  {\n    int element = d[i][j];\n    if (element > loc_max)\n    {\n      loc_max = element;\n    }\n\n    if (element < loc_min)\n    {\n      loc_min = element;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/9th/9th/1"}
{"code": "for (i = 0; i < s1; i++)\n{\n  for (j = 0; j < s2; j++)\n  {\n    value = idata[(i * s2) + j];\n    if (value < rmin)\n      value = rmin;\n\n    if (value > rmax)\n      value = rmax;\n\n    vp = (int) ((((double) (value - rmin)) * ((double) 255.0)) / ((double) (rmax - rmin)));\n    vs++;\n    fprintf(ouni, \" %3.3d %3.3d %3.3d\", cm[0][vp], cm[1][vp], cm[2][vp]);\n    if (vs >= 10)\n    {\n      fprintf(ouni, \" \\n\");\n      vs = 0;\n    }\n\n  }\n\n  fprintf(ouni, \" \");\n  vs = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/11"}
{"code": "for (j = 0; j < m; j++)\n{\n  for (k = 0; k < m; k++)\n    sum = Q[j][k] - Z[j][k];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/5"}
{"code": "for (uint64_t i = size - (size % 4); i < size; i++)\n{\n  hist[data[i] >> tail]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/12"}
{"code": "for (i0 = 0; i0 < num; i0++)\n{\n  for (j0 = 0; j0 < num; j0++)\n  {\n    for (k0 = 0; k0 < num; k0++)\n    {\n      for (i1 = tile_size * i0; i1 < ((tile_size * i0) + tile_size); i1++)\n      {\n        for (j1 = tile_size * j0; j1 < ((tile_size * j0) + tile_size); j1++)\n        {\n          for (k1 = tile_size * k0; k1 < ((tile_size * k0) + tile_size); k1++)\n          {\n            C[i1][j1] += A[i1][k1] * B[j1][k1];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amineremache/matrix_mult/matrix_mul_openmp/9"}
{"code": "for (i = rb; i < re; i++)\n  p_zw[i] = p_zw[i] + (beta * p_w[iter - (qn(iter) * n)][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/30"}
{"code": "for (int i = 0; i < nrow; ++i)\n{\n  int k = row_offset[i];\n  int j = this->mat_.row_offset[i];\n  for (; j < this->mat_.row_offset[i + 1]; ++j)\n  {\n    if (this->mat_.col[j] < idx)\n    {\n      col[k] = this->mat_.col[j];\n      val[k] = this->mat_.val[j];\n      ++k;\n    }\n    else\n    {\n      break;\n    }\n\n  }\n\n  if (cast_vec->vec_[i] != ((static_cast < ValueType) > 0))\n  {\n    col[k] = idx;\n    val[k] = cast_vec->vec_[i];\n    ++k;\n    ++j;\n  }\n\n  for (; j < this->mat_.row_offset[i + 1]; ++j)\n  {\n    if (this->mat_.col[j] > idx)\n    {\n      col[k] = this->mat_.col[j];\n      val[k] = this->mat_.val[j];\n      ++k;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/122"}
{"code": "for (int i = 0; i < (listsize / 4); i++)\n  d_resultList[i] = sortElem(d_origList[i]);\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/hybridsort-omp/mergesort/0"}
{"code": "for (row = 0; row < N; row++)\n{\n  if (testPassed)\n  {\n    sum = 0.0;\n    for (i = 0; i < N; i++)\n      sum += *((a + (row * N)) + i);\n\n    sum -= fabs(*((a + (row * N)) + row));\n    testPassed = fabs(*((a + (row * N)) + row)) > sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannahGulle/Baby_BLAS/OMPSolvers/openmp/dls/7"}
{"code": "for (int i = 0; i < N; ++i)\n  B[i] = omp_get_thread_num();\n\n", "pragma": "        #pragma omp target teams distribute parallel for thread_limit(512) num_teams(120*10) schedule(static,1) if(target:execution_space_gpu)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/vasp1/vasp1/2"}
{"code": "for (i = 0; i < 10; ++i)\n  foo();\n\n", "pragma": "  #pragma omp for reduction ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_reduction_messages/0"}
{"code": "for (i = 0; i < 20000; i++)\n  for (j = 0; j < 20000; j++)\n  graph[i][j] = rand() % 10;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Parth-31/Parallel-Prims-Algorithm-using-OpenMP/Code/primspar/4"}
{"code": "for (int p = 1; p < pcount; p++)\n{\n  int start = (N * p) / pcount;\n  int end = (N * (p + 1)) / pcount;\n  readSubmatrix(buf, end - start, N, fin);\n  MPI_Send(buf, N * (end - start), MPI_DOUBLE, p, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olegharacidi/superprak4/floyd/3"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  flux[i][j][k][0] = u[i][j][k][1];\n  u21 = u[i][j][k][1] / u[i][j][k][0];\n  q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n  flux[i][j][k][1] = (u[i][j][k][1] * u21) + (0.40e+00 * (u[i][j][k][4] - q));\n  flux[i][j][k][2] = u[i][j][k][2] * u21;\n  flux[i][j][k][3] = u[i][j][k][3] * u21;\n  flux[i][j][k][4] = ((1.40e+00 * u[i][j][k][4]) - (0.40e+00 * q)) * u21;\n}\n\n", "pragma": "omp parallel for private (q,u21,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/89"}
{"code": "for (size_t i = 0; i < W.size(); i++)\n{\n  g[i] = (mu * g[i]) + (((1 - mu) * dW[i]) * dW[i]);\n  W[i] -= (alpha * dW[i]) / sqrt(g[i] + eps);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/optimizer/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  r[i] = vector[i] * escalar;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/als-movie-recommender/main/14"}
{"code": "for (int i = 0; i < input.lookups; i++)\n  validation_hash += verification[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-offload/simulation/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 0;\n  for (j = 0; j < n; j++)\n    b[i] += A[(i * n) + j] * x[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhaseeb123/omp_gaussian_elimination/src/GaussianElimination/2"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%d\\t\", omp_get_thread_num());\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_5c/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  floatpng[i] = (float *) malloc((sizeof(float *)) * width);\n  for (int j = 0; j < width; j++)\n    floatpng[i][j] = bytepng[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmaeilkeshavarz/Edge-detection-with-C-using-OpenMp/phase2/2"}
{"code": "for (int i = 0; i < (Q_len + 1); i++)\n{\n  free(ScoreTable[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skalogerakis/TUC_Parallel_Computer_Architecture/Smith-Waterman/OpenMP_FineGrained/main/7"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  x[i] = i * del_x;\n  if ((x[i] > 0.5) && (x[i] < 1.0))\n  {\n    u[i] = 2.0;\n    u_new[i] = 2.0;\n  }\n  else\n  {\n    u[i] = 1.0;\n    u_new[i] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Diffusion/1-D_Diffusion/main/0"}
{"code": "for (int k = 0; k < K; k++)\n{\n  rand_point_i = rand() % MAX_POINTS;\n  for (int j = 0; j < DIM; j++)\n  {\n    centroids[k][j] = points[rand_point_i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(rand_point_i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Plutone11011/ParallelKMEANS/kmeans/1"}
{"code": "for (i = 0; i < (V * V); i++)\n{\n  (cout << h_graph[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/22"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  float tmp1 = 0.0;\n  for (k = 0; k < 1024; k++)\n    tmp1 += Pfun(i, k);\n\n  tmp += tmp1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.5/2"}
{"code": "for (i = 0; i <= 524287; i += 1)\n{\n  key_buff1[i] = 0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (thread_num[i] != (i % THREAD_LIMIT))\n    recordError(&errors, \"THREAD NUMBER\", i, thread_num, 0);\n\n  if ((i % THREAD_LIMIT) == 0)\n  {\n    correctTeamNum++;\n    if (isAMDGPU)\n      correctTeamNum = correctTeamNum % MAX_TEAMS;\n\n  }\n\n  if (team_num[i] != correctTeamNum)\n    recordError(&errors, \"TEAM NUMBER\", i, team_num, 0);\n\n  if (default_dev[i] != 0)\n    recordError(&errors, \"DEVICE NUMBER\", i, default_dev, 0);\n\n  if (warp_id[i] != 0)\n    recordError(&errors, \"WARP NUMBER\", i, warp_id, 0);\n\n  if (lane_id[i] != (i % THREAD_LIMIT))\n    recordError(&errors, \"LANE NUMBER\", i, lane_id, 0);\n\n  if (master_thread_id[i] != 0)\n    recordError(&errors, \"MASTER THREAD NUMBER\", i, master_thread_id, 0);\n\n  if (is_spmd_mode[i] != SPMD)\n    recordError(&errors, \"SPMD NUMBER\", i, is_spmd_mode, 0);\n\n  if (num_threads[i] != THREAD_LIMIT)\n    recordError(&errors, \"NUM THREADS\", i, num_threads, 0);\n\n  if ((N % THREAD_LIMIT) != 0)\n    correctNumTeams = (N + num_threads[i]) / num_threads[i];\n  else\n    correctNumTeams = N / THREAD_LIMIT;\n\n  if ((correctNumTeams > MAX_TEAMS) && isAMDGPU)\n    correctNumTeams = MAX_TEAMS;\n\n  if (num_teams[i] != correctNumTeams)\n    recordError(&errors, \"NUM TEAMS\", i, num_teams, 0);\n\n  mask = 0;\n  if ((N % THREAD_LIMIT) != 0)\n  {\n    remainder = N % THREAD_LIMIT;\n    for (int j = 0; j < remainder; j++)\n    {\n      mask = mask << 1;\n      mask = mask + 1;\n    }\n\n  }\n\n  if (i < (N - remainder))\n  {\n    mask = 0xf;\n  }\n\n  if (active_mask[i] != mask)\n    recordError(&errors, \"ACTIVE MASK\", i, 0, active_mask);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/aomp_mappings/aomp_mappings/4"}
{"code": "for (int process_id = 1; process_id < process_count; process_id++)\n{\n  MPI_Send((void *) 0, 0, (MPI_Datatype) 0x4c000405, process_id, 3, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/25"}
{"code": "for (i = 0; i < batch; i++)\n{\n  for (c = 0; c < channels_col; c++)\n  {\n    w_offset = c % ksize;\n    h_offset = (c / ksize) % ksize;\n    c_im = (c / ksize) / ksize;\n    for (h = 0; h < height_col; h++)\n    {\n      for (w = 0; w < width_col; w++)\n      {\n        row = h_offset + (h * stride);\n        col = w_offset + (w * stride);\n        out_index = (((((i * channels) * height) * width) + ((c_im * height) * width)) + (row * width)) + col;\n        col_index = (((c * height_col) * width_col) + (h * width_col)) + w;\n        row -= pad;\n        col -= pad;\n        if ((((row < 0) || (col < 0)) || (row >= height)) || (col >= width))\n        {\n          conv_tensor[col_index] = 0.0;\n        }\n        else\n        {\n          conv_tensor[col_index] = input[out_index];\n        }\n\n      }\n\n    }\n\n  }\n\n  for (p = 0; p < M; p++)\n  {\n    for (q = 0; q < K; q++)\n    {\n      a_part = weights[(p * K) + q];\n      for (j = 0; j < N; j++)\n      {\n        output[(((i * M) * N) + (p * N)) + j] += a_part * conv_tensor[(q * N) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-cpu/0"}
{"code": "for (v = 0; v < currentNodeOutdegree; v++)\n{\n  start_edge = gr->first_edge[currentNode];\n  edge = start_edge + v;\n  dest = gr->destination[edge];\n  weight = gr->weight[edge];\n  if (dijkstra[dest].flag == 0)\n  {\n    if (dijkstra[dest].cost == 4294967295U)\n    {\n      dijkstra[dest].cost = dijkstra[currentNode].cost + weight;\n      dijkstra[dest].prev = currentNode;\n    }\n    else\n    {\n      if ((dijkstra[currentNode].cost + weight) < dijkstra[dest].cost)\n      {\n        dijkstra[dest].cost = dijkstra[currentNode].cost + weight;\n        dijkstra[dest].prev = currentNode;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(start_edge, edge, dest, weight) num_threads(THREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris21gr/Boruvka_and_Dijkstra_Parallel/openMP_dijkstra/openMP_dijkstra/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  A[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB049-fprintf-orig-no/0"}
{"code": "for (i = 1; i <= n; i++)\n{\n  if (oldroad[i] == 1)\n  {\n    if (oldroad[i + 1] == 1)\n    {\n      newroad[i] = 1;\n    }\n    else\n    {\n      newroad[i] = 0;\n      nmove++;\n    }\n\n  }\n  else\n  {\n    if (oldroad[i - 1] == 1)\n    {\n      newroad[i] = 1;\n    }\n    else\n    {\n      newroad[i] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), schedule(static), shared(oldroad, newroad, n), private(i), reduction(+:nmove)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bbw7561135/OpenMP-Workshop/traffic/trafficlib/0"}
{"code": "for (i = 1; i < (22 - 1); ++i)\n{\n  ch = ciphertext[i];\n  if (((!isalnum(ch)) && (ch != '+')) && (ch != '/'))\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC_fmt_plug/1"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  sum2 = 0.0;\n  aij = ai;\n  jx = kx;\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = head_x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    x_elem = tail_x[jx];\n    prod = a_elem * x_elem;\n    sum2 = sum2 + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  sum = sum + sum2;\n  y_elem = y[iy];\n  tmp1 = y_elem * beta_i;\n  tmp2 = sum + tmp1;\n  y[iy] = tmp2;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum,sum2) shared(a_i,head_x_i,tail_x_i,y_i) private(i,aij,jx,a_elem,prod,x_elem,j,ai,iy,tmp1,tmp2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/2"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  count[arr[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gomathi18/parallel-counting-sort/main/1"}
{"code": "for (i = 0; i < g.nvertices; ++i)\n  g.edges[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cathy272272272/Dijkstra/OpenMP/5"}
{"code": "for (uint32_t i = 0; i != m_mAdjVertex.size(); i++)\n{\n  if (m_in_DG[i] == false)\n  {\n    mplAssertMsg(!(m_db->use_stitch() && (m_StitchRelation[i].size() != 0)), \"BUG FOUND %u\", i);\n  }\n\n  jsonFile << \"\\n\";\n  jsonFile << \"\\t{\\n\";\n  ((jsonFile << \"\\t\\t\\\"id\\\": \") << i) << \",\\n\";\n  ((jsonFile << \"\\t\\t\\\"color\\\": \") << ((int) m_db->vPatternBbox[i]->color())) << \",\\n\";\n  ((jsonFile << \"\\t\\t\\\"conflict_degree\\\":\") << m_mAdjVertex[i].size()) << \",\\n\";\n  if (m_db->use_stitch())\n  {\n    ((jsonFile << \"\\t\\t\\\"stitch_degree\\\":\") << m_StitchRelation[i].size()) << \",\\n\";\n  }\n\n  if (m_mAdjVertex[i].size() == 0)\n  {\n    jsonFile << \"\\t\\t\\\"conflict\\\": []\";\n  }\n  else\n  {\n    jsonFile << \"\\t\\t\\\"conflict\\\": [\\n\";\n    for (uint32_t j = 0; j != (m_mAdjVertex[i].size() - 1); j++)\n    {\n      ((jsonFile << \"\\t\\t\\t{\\\"id\\\": \") << m_mAdjVertex[i][j]) << \"},\\n\";\n    }\n\n    ((jsonFile << \"\\t\\t\\t{\\\"id\\\": \") << m_mAdjVertex[i][m_mAdjVertex[i].size() - 1]) << \"}\\n\";\n    jsonFile << \"\\t\\t]\";\n  }\n\n  if (m_db->use_stitch())\n  {\n    jsonFile << \",\\n\";\n    if (m_StitchRelation[i].size() == 0)\n    {\n      jsonFile << \"\\t\\t\\\"stitch\\\": []\\n\";\n    }\n    else\n    {\n      jsonFile << \"\\t\\t\\\"stitch\\\": [\\n\";\n      for (uint32_t j = 0; j != (m_StitchRelation[i].size() - 1); j++)\n      {\n        ((jsonFile << \"\\t\\t\\t{\\\"id\\\": \") << m_StitchRelation[i][j]) << \"},\\n\";\n      }\n\n      ((jsonFile << \"\\t\\t\\t{\\\"id\\\": \") << m_StitchRelation[i][m_StitchRelation[i].size() - 1]) << \"}\\n\";\n      jsonFile << \"\\t\\t]\\n\";\n    }\n\n  }\n  else\n  {\n    jsonFile << \"\\n\";\n  }\n\n  jsonFile << \"\\t},\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/0"}
{"code": "for (i = id, sum[id] = 0.0; i < num_steps; i += nthrds)\n{\n  x = (i + 0.5) * step;\n  sum[id] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dragonfly9113/introduction_to_OpenMP/OpenMPApplication/OpenMPApplication/Ex_2_calculate_pi/3"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  k += i;\n  printf(\"k = %d, thread id = %d\\n\", k, omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp parallel for firstprivate(k) lastprivate(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest04/simple_test_04/0"}
{"code": "for (int i = 0, last = 0; i < n; i++)\n{\n  int temp = col[i];\n  col[i] = last;\n  last = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v4/v4_omp/5"}
{"code": "for (size = 3; size < matSize; size += stride)\n{\n  (invoke < MatrixVectorWrapper) > ((this, vec, mat, res, size, 4, 12, &resu));\n  for (j = 0; j < repets; j++)\n  {\n    (invoke < MatrixVectorWrapper) > ((this, vec, mat, res, size, 4, 12, &resu));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/MatrixVector/TPParallelism/utils/2"}
{"code": "for (int i = 0; i < clustersNumber; i++)\n{\n  clusters.emplace_back(Cluster(distribution(generator), distribution(generator)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mb98-unifi/K-Means_OpenMP/main/0"}
{"code": "for (size_t p = 0; p < p3Dnpts; p++)\n{\n  for (size_t q = 0; q < nmo; q++)\n  {\n    if (q < nocc)\n    {\n      m_o[(p * nocc) + q] = mcgto[(p * nmo) + q];\n    }\n    else\n    {\n      pos = q - nocc;\n      m_v[(p * nvirt) + pos] = mcgto[(p * nmo) + q];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/methods/do_qmp2_mpi/0"}
{"code": "for (index = 0; index < vector_size; index++)\n{\n  vector_resultado[index] = vector_a[index] + vector_b[index];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FedeVerges/SistemasDistribuidos_MemoriaCompartida_OpenMP/OpenMP/Ejercicio5/Ejercicio5/0"}
{"code": "for (int j = 0; j < total_values; j++)\n{\n  num += p1.values[j] * p2.values[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/1"}
{"code": "for (double i = 0; i < A.size(); i++)\n{\n  A[i] = range3(e);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tonyz0x0/parallel-computing/matrix-multiplication-openmp/3"}
{"code": "for (i = i; i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/3"}
{"code": "for (i = 0; i < 6; i++)\n{\n  printf(\"%i, %i\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1415E2/1/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < 3; j++)\n  {\n    if (i != j)\n      sum += m[i][j] * x[j];\n\n  }\n\n  x[i] = (b[i] - sum) / m[i][i];\n}\n\n", "pragma": "omp for firstprivate(x),lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/p-burgess/TCP-and-parallel/openMP/jacobi-pi/0"}
{"code": "for (i = 0; i <= m; i++, j++)\n  f[i] = (j < 0) ? (zero) : ((double) ipio2[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/8"}
{"code": "for (i = 7; i >= 0; i--)\n  printf(\"%lf \", x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/vec_nbody/1"}
{"code": "for (k = 0; k < (*nzv); k++)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/28"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x = my_random();\n  y = my_random();\n  if (((x * x) + (y * y)) <= (r * r))\n  {\n    cir[id][0] += 1;\n  }\n\n}\n\n", "pragma": "#pragma omp  for private(x,y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/pi/pi_randomMethod/1"}
{"code": "for (i = 1; i <= n; i++)\n  if (visited[i])\n  count_vis++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BhagyaSri22/openmp/bfs_openmp/3"}
{"code": "for (i = kypi - 1; i < kypt; i++)\n{\n  joff = (ndim * nxvh) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t1 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < ndim; k++)\n    {\n      t = conjf(f[(k + (ndim * (nxh - j))) + joff]);\n      s = f[(k + (ndim * j)) + joff] + t;\n      t = (f[(k + (ndim * j)) + joff] - t) * t1;\n      f[(k + (ndim * j)) + joff] = s + t;\n      f[(k + (ndim * (nxh - j))) + joff] = conjf(s - t);\n    }\n\n  }\n\n  for (k = 0; k < ndim; k++)\n  {\n    f[k + joff] = (crealf(f[k + joff]) + cimagf(f[k + joff])) + ((crealf(f[k + joff]) - cimagf(f[k + joff])) * _Complex_I);\n    if (nxhh > 0)\n      f[(k + (ndim * nxhh)) + joff] = 2.0 * conjf(f[(k + (ndim * nxhh)) + joff]);\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (jj = 0; jj < ndim; jj++)\n      {\n        t1 = f[(jj + (ndim * j1)) + joff];\n        f[(jj + (ndim * j1)) + joff] = f[(jj + (ndim * j)) + joff];\n        f[(jj + (ndim * j)) + joff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indx1; m++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = conjf(sct[kmr * j]);\n        for (jj = 0; jj < ndim; jj++)\n        {\n          t1 = s * f[(jj + (ndim * j2)) + joff];\n          f[(jj + (ndim * j2)) + joff] = f[(jj + (ndim * j1)) + joff] - t1;\n          f[(jj + (ndim * j1)) + joff] += t1;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,jj,j1,j2,joff,s,t,t1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpdpic2/mpdpush2/11"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_out, 0);\n    gettimeofday(&s_bck_hid, 0);\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_hid, 0);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/16"}
{"code": "for (i = 0; i < (*num_ph); i++)\n{\n  if ((((*ph_orig)[i].weight != 0) && (((*ph_orig)[i].type == COMPTONIZED_PHOTON) || ((*ph_orig)[i].type == UNABSORBED_CS_PHOTON))) && ((*ph_orig)[i].p0 > 0))\n  {\n    ph_r = sqrt((((*ph_orig)[i].r0 * (*ph_orig)[i].r0) + ((*ph_orig)[i].r1 * (*ph_orig)[i].r1)) + ((*ph_orig)[i].r2 * (*ph_orig)[i].r2));\n    ph_theta = acos((*ph_orig)[i].r2 / ph_r);\n    gsl_histogram2d_increment(h_energy_theta, log10((*ph_orig)[i].p0), ph_theta);\n    ph_phi = fmod(((atan((*ph_orig)[i].r1 / (*ph_orig)[i].r0) * 180) / M_PI) + 360.0, 360.0);\n    gsl_histogram2d_increment(h_energy_phi, log10((*ph_orig)[i].p0), ph_phi);\n    gsl_histogram2d_increment(h_theta_phi, ph_theta, ph_phi);\n    count_weight += (*ph_orig)[i].weight;\n  }\n\n  if (((*ph_orig)[i].type == CS_POOL_PHOTON) && ((*ph_orig)[i].weight != 0))\n  {\n    (synch_ph + count)->p0 = (*ph_orig)[i].p0;\n    (synch_ph + count)->p1 = (*ph_orig)[i].p1;\n    (synch_ph + count)->p2 = (*ph_orig)[i].p2;\n    (synch_ph + count)->p3 = (*ph_orig)[i].p3;\n    (synch_ph + count)->comv_p0 = (*ph_orig)[i].comv_p0;\n    (synch_ph + count)->comv_p1 = (*ph_orig)[i].comv_p1;\n    (synch_ph + count)->comv_p2 = (*ph_orig)[i].comv_p2;\n    (synch_ph + count)->comv_p3 = (*ph_orig)[i].comv_p3;\n    (synch_ph + count)->r0 = (*ph_orig)[i].r0;\n    (synch_ph + count)->r1 = (*ph_orig)[i].r1;\n    (synch_ph + count)->r2 = (*ph_orig)[i].r2;\n    (synch_ph + count)->s0 = (*ph_orig)[i].s0;\n    (synch_ph + count)->s1 = (*ph_orig)[i].s1;\n    (synch_ph + count)->s2 = (*ph_orig)[i].s2;\n    (synch_ph + count)->s3 = (*ph_orig)[i].s3;\n    (synch_ph + count)->num_scatt = (*ph_orig)[i].num_scatt;\n    (synch_ph + count)->weight = (*ph_orig)[i].weight;\n    (synch_ph + count)->nearest_block_index = (*ph_orig)[i].nearest_block_index;\n    synch_photon_idx[count] = i;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/4"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    scanf(\"%d\", &a[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lakshmipooja/OpenMP/mat_mul/1"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  jsum = 0;\n  for (j = 0; j < numParticles; j++)\n  {\n    if (i == j)\n      continue;\n\n    jsum += calcDistance(p[i], p[j]);\n  }\n\n  isum += jsum / (numParticles - 1);\n}\n\n", "pragma": "omp for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/6"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  this->mat_.val[DENSE_IND(i, idx, this->nrow_, this->ncol_)] = cast_vec->vec_[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/10"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[k][m] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m <= 4; m++)\n      {\n        buf[k][m] = dtpp * dtemp[m];\n      }\n\n      cuf[k] = buf[k][3] * buf[k][3];\n      buf[k][0] = (cuf[k] + (buf[k][1] * buf[k][1])) + (buf[k][2] * buf[k][2]);\n      q[k] = 0.5 * (((buf[k][1] * ue[k][1]) + (buf[k][2] * ue[k][2])) + (buf[k][3] * ue[k][3]));\n    }\n\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      km1 = k - 1;\n      kp1 = k + 1;\n      forcing[i][j][k][0] = (forcing[i][j][k][0] - (tz2 * (ue[kp1][3] - ue[km1][3]))) + (dz1tz1 * ((ue[kp1][0] - (2.0 * ue[k][0])) + ue[km1][0]));\n      forcing[i][j][k][1] = ((forcing[i][j][k][1] - (tz2 * ((ue[kp1][1] * buf[kp1][3]) - (ue[km1][1] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][1] - (2.0 * buf[k][1])) + buf[km1][1]))) + (dz2tz1 * ((ue[kp1][1] - (2.0 * ue[k][1])) + ue[km1][1]));\n      forcing[i][j][k][2] = ((forcing[i][j][k][2] - (tz2 * ((ue[kp1][2] * buf[kp1][3]) - (ue[km1][2] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][2] - (2.0 * buf[k][2])) + buf[km1][2]))) + (dz3tz1 * ((ue[kp1][2] - (2.0 * ue[k][2])) + ue[km1][2]));\n      forcing[i][j][k][3] = ((forcing[i][j][k][3] - (tz2 * (((ue[kp1][3] * buf[kp1][3]) + (c2 * (ue[kp1][4] - q[kp1]))) - ((ue[km1][3] * buf[km1][3]) + (c2 * (ue[km1][4] - q[km1])))))) + (zzcon1 * ((buf[kp1][3] - (2.0 * buf[k][3])) + buf[km1][3]))) + (dz4tz1 * ((ue[kp1][3] - (2.0 * ue[k][3])) + ue[km1][3]));\n      forcing[i][j][k][4] = ((((forcing[i][j][k][4] - (tz2 * ((buf[kp1][3] * ((c1 * ue[kp1][4]) - (c2 * q[kp1]))) - (buf[km1][3] * ((c1 * ue[km1][4]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[kp1][0] - (2.0 * buf[k][0])) + buf[km1][0]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[kp1][4] - (2.0 * buf[k][4])) + buf[km1][4]))) + (dz5tz1 * ((ue[kp1][4] - (2.0 * ue[k][4])) + ue[km1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = 1;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[k][m]) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      k = 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[k - 1][m]) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (k = 1 * 3; k <= ((grid_points[2] - (3 * 1)) - 1); k++)\n      {\n        forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = grid_points[2] - 3;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])));\n      k = grid_points[2] - 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (5.0 * ue[k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/4"}
{"code": "for (int32_t t = 0; t < num_triangles; ++t)\n{\n  need_update[triangle_buf[t].edge_a] = 1;\n  need_update[triangle_buf[t].edge_b] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/12"}
{"code": "for (int i = 1; i <= V; i++)\n  dist[i] = INT_MAX;\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspTopologyDriven/2"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  c[i] = 0;\n  for (int j = 0; j < 5; j++)\n  {\n    if ((a[i] > a[j]) || ((i < j) && (a[i] == a[j])))\n      c[i] += 1;\n    else\n      c[i] += 0;\n\n  }\n\n  b[c[i]] = a[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Srinidi-V/openmp/enumeration/0"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  myId = omp_get_thread_num();\n  printf(\"Doing work at %d\\n\", myId);\n}\n\n", "pragma": "\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/thread_control/0"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->vertices[i] == NOT_FRONTIER_MARKER)\n  {\n    int start_edge = g->incoming_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->incoming_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int neighbor_node = g->incoming_edges[neighbor];\n      if (frontier->vertices[neighbor_node] == frontier_id)\n      {\n        distances[i] = distances[neighbor_node] + 1;\n        frontier->vertices[i] = frontier_id + 1;\n        next_frontier_cnt++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for reduction(+:next_frontier_cnt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zonghan0904/2020_Fall_PP/HW3/part2/breadth_first_search/bfs/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    a[i][j] = (long) (rand() % 5);\n    printf(\" %d \", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Magiera/P-M-D/openMP/matrix/6"}
{"code": "for (unsigned i = 0; i < n_vertices; i++)\n{\n  free(vertices[i].successors);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/linked-list/linked-list/8"}
{"code": "for (int k = 0; k < N; k++)\n{\n  float32x4_t v1 = vmovq_n_f32(A[k][k]);\n  float32x4_t v0;\n  int i;\n  for (i = k + 1; i <= (N - 4); i += 4)\n  {\n    v0 = vld1q_f32(A[k] + i);\n    v0 = vdivq_f32(v0, v1);\n    vst1q_f32(A[k] + i, v0);\n  }\n\n  for (i = i - 4; i < N; i++)\n    A[k][i] = A[k][i] / A[k][k];\n\n  A[k][k] = 1.0;\n  for (int i = k + 1; i < N; i++)\n  {\n    v1 = vmovq_n_f32(A[i][k]);\n    float32x4_t v2;\n    int j;\n    for (j = k + 1; j <= (N - 4); j += 4)\n    {\n      v2 = vld1q_f32(A[k] + j);\n      v0 = vld1q_f32(A[i] + j);\n      v2 = vmulq_f32(v1, v2);\n      v0 = vsubq_f32(v0, v2);\n      vst1q_f32(A[i] + j, v0);\n    }\n\n    for (j = j - 4; j < N; j++)\n      A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n\n    A[i][k] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/4"}
{"code": "for (int j = 0; j < width; ++j)\n{\n  out.emplace_back();\n  out[j].reserve(height);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muji-4ok/pixel-sort-qt5/sorter/4"}
{"code": "for (size_t j = 0; j < n; ++j)\n{\n  for (size_t i = 0; i < n; ++i)\n  {\n    c[i][j] = a[i][j] * b[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment3/Task2/Hadamard/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n    {\n      for (i = 1; i < (grid_points[0] - 1); i++)\n      {\n        rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/30"}
{"code": "for (i.integer = 0; i.integer < (size / 2); i.integer++)\n{\n  j.byte[0] = rev[i.byte[3]];\n  j.byte[1] = rev[i.byte[2]];\n  j.byte[2] = rev[i.byte[1]];\n  j.byte[3] = rev[i.byte[0]];\n  j.integer = j.integer >> (32 - m);\n  _outputSignal[2 * i.integer] = _inputSignal[2 * j.integer];\n  _outputSignal[(2 * i.integer) + 1] = _inputSignal[(2 * j.integer) + 1];\n  _outputSignal[(2 * i.integer) + size] = _inputSignal[(2 * j.integer) + 2];\n  _outputSignal[((2 * i.integer) + size) + 1] = _inputSignal[((2 * j.integer) + 2) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/11. filter (parallel)/fft/1"}
{"code": "for (int i = 0; i < N; i++)\n  d2 += a[i] * b[i];\n\n", "pragma": "\t#pragma omp parallel for simd reduction(+:d2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daseibert2/OpenMP_Exercises/simd_reduction1/3"}
{"code": "for (i = 0; i < rows; i++)\n{\n  if (!fread(&dest[i][0], sizeof(double), cols, file))\n  {\n    printf(\"Unable to read Matrix from file!\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/7"}
{"code": "for (int i = 0; i < m; i++)\n{\n  if (fabs(a[i] - aRef[i]) > 1.0e-3)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultVector/0"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < KHALO; j++)\n  {\n    for (int i = 0; i < SDMGeom->L_NodeX(); i++)\n    {\n      indx = IJK(HALO.x + i, PML.y + j, HALO.z + k);\n      indx1 = (i + (j * SDMGeom->L_NodeX())) + ((k * KHALO) * SDMGeom->L_NodeX());\n      bn_ly[(((indx_var - 1) * size) + indx1) + ((time * size) * 9)] = var[indx];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/31"}
{"code": "for (i = 0; i < (series->count - window); i++)\n{\n  MA_data[i + window] = var_mean(series->data, i, i + window);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/9"}
{"code": "for (int i = 0; i < nsockets; i++)\n{\n  {\n    printf(\"thread %2d: place %d, nplaces %d, nprocs %d, npplaces %d | procs here are: \", me, place, nsockets, nprocs, npplaces);\n    for (int p = 0; p < nprocs; p++)\n      printf(\"%d \", proc_ids[p]);\n\n    printf(\"\\n\");\n    for (int p = 0; p < nbuffers; p++)\n    {\n      printf(\"%s\", buffer[p]);\n      free(buffer[p]);\n    }\n\n  }\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/threads_affinity/03_where_I_am_nested/0"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  int start = g_graph_nodes[vid].starting;\n  int no_of_edges = g_graph_nodes[vid].no_of_edges;\n  int end = start + no_of_edges;\n  int my_cost = g_cost[vid];\n  for (int i = start; i < end; i++)\n  {\n    int weight = g_graph_weights[i];\n    int new_cost = my_cost + weight;\n    int id = g_graph_edges[i];\n    if (stale_mode == 0)\n    {\n      if (atomicMin(g_cost + id, new_cost))\n      {\n        *g_over = true;\n      }\n\n    }\n    else\n    {\n      int neighbor_cost = g_cost_ind[i];\n      if (neighbor_cost > new_cost)\n      {\n        atomicMin(g_cost + id, new_cost);\n        *g_over = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/SSSP/kernel/1"}
{"code": "for (index = 0; index < (intervals - 1); index++)\n{\n  if (temp <= endpoints[index])\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skitiz/Histograms/OMP Histogram/omphistogram/2"}
{"code": "for (i = 0; i < numEdges; i++)\n{\n  edges[i] = edges_sorted[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(numEdges, edges_sorted, edges) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JasonNCSU/openMP/src/sort/1"}
{"code": "for (unsigned int g = 0; g < ng; g++)\n{\n  for (unsigned int k = 0; k < nz; k++)\n  {\n    for (unsigned int j = 0; j < ny; j++)\n    {\n      for (unsigned int i = 0; i < nx; i++)\n      {\n        out_scalar[((i + (nx * j)) + ((nx * ny) * k)) + (((nx * ny) * nz) * g)] = scalar_flux[((g + (ng * i)) + ((ng * nx) * j)) + (((ng * nx) * ny) * k)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_core/1"}
{"code": "for (int i = 0; i < ((int) nel); i++)\n{\n  img2pgm((*img_names)[i].c_str());\n  pgm2key(ext_pgm((*img_names)[i].c_str()));\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(omp_get_num_procs()) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/img2key/0"}
{"code": "for (int i = 0; i < graph->size; i++)\n{\n  qsort(graph->nodes[i]->neighbours, graph->nodes[i]->degree, sizeof(Node *), compare);\n}\n\n", "pragma": "omp parallel for num_threads(threads) if (graph->size > 2000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z3y50n/ReverseCuthillMcKee/src/functions/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (5.0 * u[m][i][j][k])));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/149"}
{"code": "for (int j = 0; j < N; j++)\n{\n  for (int i = 0; i < N; i++)\n  {\n    for (int n = 0; n < N; n++)\n    {\n      C[i][j] += A[i][n] * B[n][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elyaishere/sk_high_performance_computing/openmp/MatMul/1"}
{"code": "for (i = strlen(ciphertext); ciphertext[i] != '#'; i--)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/hmacSHA256_fmt_plug/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) MEU[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/111"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  m_fMaxSoundSpeed = max(m_fMaxSoundSpeed, soundSpeed[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/65"}
{"code": "for (i = 0; i <= ((len - 1) - 1); i += 1)\n{\n  a[i + 1] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB024-simdtruedep-orig-yes/1"}
{"code": "for (int i = ((li * nthr) / nofth[j]) + 1; i < ((li * (nthr + 1)) / nofth[j]); i++)\n{\n  if (isprime(i) == 1)\n  {\n    sum1 += 1;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yousefmaw/OpenMP_Avx/openmp_prime/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if ((a[i] == 0) && (res1 < 0))\n    res1 = i;\n\n}\n\n", "pragma": "omp parallel for firstprivate(res1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DanielMChaves/CAR_OpenMP/sesion_1/src/ejemplo3_while_for/while_for/0"}
{"code": "for (int k = 0; k < num_threads; ++k)\n{\n  if (res > x[m[k]])\n    res = x[m[k]];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/33"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n  if (lOut[rowcol] > 0)\n  lOut[rowcol] = 10 * lOut[rowcol];\n\n\n", "pragma": "omp parallel for default(none) private (rowcol) shared (N, lOut, a, b)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ALB/alb/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float x = a + ((i + .5) * ((b - a) / n));\n  switch (functionid)\n  {\n    case 1:\n      res += f1(x, intensity);\n      break;\n\n    case 2:\n      res += f2(x, intensity);\n      break;\n\n    case 3:\n      res += f3(x, intensity);\n      break;\n\n    case 4:\n      res += f4(x, intensity);\n      break;\n\n    default:\n      cout << \"\\nWrong functionid\";\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for reduction (+ : res) schedule (runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgupta180496/OpenMP-Loop/numint/numint/0"}
{"code": "for (int i = 0; i < h; i++)\n{\n  for (int j = 0; j < w; j++)\n    srt[omp_get_thread_num()][pixels[i][j]]++;\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(kind, chunk_size) shared(srt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MONICgh/OpenMP/lab04/9"}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  foo();\n  for (j = 0; j < (1 << 20); j++)\n  {\n    test();\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkourt/gcc-ompinfo/for-test/2"}
{"code": "for (int j = 255; j >= 0; j--)\n{\n  if ((k <= need_k) && ((k + count[j]) > need_k))\n  {\n    break;\n  }\n  else\n  {\n    k += count[j];\n    max = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/4"}
{"code": "for (int i = 0; i < z.size(); i++)\n{\n  z[i] = (alpha * x[i]) + y[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/axpyz/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  int plen = strlen(saved_key[index]);\n  unsigned char key[64];\n  unsigned char out[64];\n  if (cur_salt->type == 1)\n  {\n    SHA_CTX ctx;\n    if (plen < SHA_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, SHA_DIGEST_LENGTH - plen);\n    }\n    else\n      if (plen == SHA_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], SHA_DIGEST_LENGTH);\n    }\n    else\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, saved_key[index], plen);\n      SHA1_Final(key, &ctx);\n    }\n\n\n    hmac_sha1(key, 20, cur_salt->salt, cur_salt->salt_length + SHA_DIGEST_LENGTH, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    SHA256_CTX ctx;\n    if (plen < 32)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 32 - plen);\n    }\n    else\n      if (plen == 32)\n    {\n      memcpy(key, saved_key[index], 32);\n    }\n    else\n    {\n      SHA256_Init(&ctx);\n      SHA256_Update(&ctx, saved_key[index], plen);\n      SHA256_Final(key, &ctx);\n    }\n\n\n    hmac_sha256(key, 32, cur_salt->salt, cur_salt->salt_length + 32, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    SHA512_CTX ctx;\n    if (plen < 48)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 48 - plen);\n    }\n    else\n      if (plen == 48)\n    {\n      memcpy(key, saved_key[index], 48);\n    }\n    else\n    {\n      SHA384_Init(&ctx);\n      SHA384_Update(&ctx, saved_key[index], plen);\n      SHA384_Final(key, &ctx);\n    }\n\n\n    hmac_sha384(key, 48, cur_salt->salt, cur_salt->salt_length + 48, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 4)\n  {\n    SHA512_CTX ctx;\n    if (plen < 64)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 64 - plen);\n    }\n    else\n      if (plen == 64)\n    {\n      memcpy(key, saved_key[index], 64);\n    }\n    else\n    {\n      SHA512_Init(&ctx);\n      SHA512_Update(&ctx, saved_key[index], plen);\n      SHA512_Final(key, &ctx);\n    }\n\n\n    hmac_sha512(key, 64, cur_salt->salt, cur_salt->salt_length + 64, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ospf_fmt_plug/4"}
{"code": "for (it = 0; it < num_its; it++)\n{\n  int ix;\n  int iy;\n  int ir;\n  for (ix = 0; ix < n; ix++)\n  {\n    for (iy = 0; iy < m; iy++)\n    {\n      REAL *temp_u = &u[(((ix + radius) * u_dimY) + radius) + iy];\n      REAL *temp_uold = &uold[(((ix + radius) * u_dimY) + radius) + iy];\n      REAL result = temp_uold[0] * coeff[0];\n      for (ir = 1; ir <= radius; ir++)\n      {\n        result += coeff[ir] * temp_uold[ir];\n        result += coeff[-ir] * temp_uold[-ir];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n      }\n\n      *temp_u = result / count;\n    }\n\n  }\n\n  REAL *tmp = uold;\n  uold = u;\n  u = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/benchmarks/stencil2d/stencil2d/2"}
{"code": "for (int i = 0; i < count; i++)\n{\n  segmentByDistance(in_cloud_ptr[i], cloud_size[i], &out_cloud_ptr[i], &out_boundingbox_array[i], &out_centroids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/14"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    cont++;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/paralelo5/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a = omp_get_thread_num();\n  (rand() % 11) + 10;\n  printf(\"Thread %d a=%d\\n\", omp_get_thread_num(), a);\n}\n\n", "pragma": "omp parallel for lastprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  if ((AllAlphas[i] != 0) && (minAlpha == 0))\n  {\n    minAlpha = AllAlphas[i];\n    minIndex = i;\n  }\n\n  if (AllAlphas[i] < minAlpha)\n  {\n    minAlpha = AllAlphas[i];\n    minIndex = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      mul[i][j] = mul[i][j] - 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thesaurabhkumar/ParallelInverseUpperTriangleMatrixOpenMP/inverse/11"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (fabs(A[(i * N) + j] - B[(i * N) + j]) > 1e-9)\n      return 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/06matmul_omp/6"}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == crypt_key[index][0])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/citrix_ns_fmt_plug/2"}
{"code": "for (i1 = 0; i1 < number_of_words; i1++)\n{\n  for (i2 = i1 + 1; i2 < number_of_words;)\n  {\n    if (strcmp(search_words[i2], search_words[i1]) == 0)\n    {\n      for (k = i2; k < number_of_words; k++)\n        search_words[k] = search_words[k + 1];\n\n      number_of_words--;\n    }\n    else\n      i2++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/fff/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = (long *) malloc(N * (sizeof(long)));\n  b[i] = (long *) malloc(N * (sizeof(long)));\n  c[i] = (long *) malloc(N * (sizeof(long)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnx4015/CompParaleDist/Code/OpenMP/multParalleli/0"}
{"code": "for (int i = (12 * n) / 16; i < ((13 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/20"}
{"code": "for (int i = 1; i <= (N - 1); i++)\n{\n  double x = a + (i * h);\n  integral_priv = integral_priv + f(x);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialFull/Trapezoid/parallel/trapezoid/0"}
{"code": "for (ix = 0; ix < n; ix++)\n{\n  REAL *temp_u = &u[((ix + radius) * u_dimY) + radius];\n  REAL *temp_uold = &uold[((ix + radius) * u_dimY) + radius];\n  for (iy = 0; iy < m; iy++)\n  {\n    for (iz = 0; iz < k; iz++)\n    {\n      REAL result = temp_uold[0] * coeff[0];\n      for (ir = 1; ir <= radius; ir++)\n      {\n        result += coeff[ir] * temp_uold[ir];\n        result += coeff[-ir] * temp_uold[-ir];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimZ];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimZ];\n      }\n\n      *temp_u = result / count;\n      temp_u++;\n      temp_uold++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/stencil3d/stencil3d_mdev.c/1"}
{"code": "for (layer14_index = 0; layer14_index < Layer_CH_Num; layer14_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data15[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data15[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data15[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv15[(((((layer15_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer14_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data15[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/58"}
{"code": "for (i = 0; i < local_n0; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n{\n  const int z = ((((i * N) + j) * 2) * Nf) + k;\n  Fx[z] = 0.01;\n  Fy[z] = 0.001;\n  Fz[z] = 0.0001;\n}\n\n\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/2"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  index = arr[i];\n  omp_set_lock(&writelock);\n  hTable[index] = hTable[index] + 1;\n  omp_unset_lock(&writelock);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rnikhori/OpenMP/histogram/1"}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  for (j = 0; j < 10000; ++j)\n  {\n    dist[i][j] = -1;\n  }\n\n  dist[i][i] = 0;\n}\n\n", "pragma": "omp parallel for shared(dist)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jackson211/Floyd-Warshall-OpenMP/fw2/0"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  double r = x[i];\n  s1_np1_res[i] = 0;\n  s2_np1_res[i] = 0;\n  V_np1_res[i] = ((((V_np1[i + 1] - V_np1[i - 1]) / (r * dr)) + (((V_np1[i + 1] - (2 * V_np1[i])) + V_np1[i - 1]) / (dr * dr))) - (s1_np1[i] * s1_np1[i])) - (s2_np1[i] * s2_np1[i]);\n  s1_n_res[i] = 0;\n  s2_n_res[i] = 0;\n  V_n_res[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/18"}
{"code": "for (; i < N; i++)\n{\n  if ((i != k) && (i != (k + 1)))\n    res2 += ((u[i] * u[i]) * (d[i] - d[k + 1])) / pow(d[i] - lambda_j, 3);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Secular_Equation_Solvers_In_OpenMP/gragg/12"}
{"code": "for (c1 = (ni > nm) ? (ni) : (nm); c1 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/19"}
{"code": "for (i = 0; i < 7; i++)\n{\n  snprintf(hydrofile, sizeof(hydrofile), \"%s%s%d%s\", hydro_prefix, \"grid0\", i, \"-x1.data\");\n  hydroPtr = fopen(hydrofile, \"r\");\n  j = 0;\n  while (j < 1260)\n  {\n    switch (i)\n    {\n      case 0:\n        fscanf(hydroPtr, \"%lf\", r_unprc_0 + j);\n\n      case 1:\n        fscanf(hydroPtr, \"%lf\", r_unprc_1 + j);\n\n      case 2:\n        fscanf(hydroPtr, \"%lf\", r_unprc_2 + j);\n\n      case 3:\n        fscanf(hydroPtr, \"%lf\", r_unprc_3 + j);\n\n      case 4:\n        fscanf(hydroPtr, \"%lf\", r_unprc_4 + j);\n\n      case 5:\n        fscanf(hydroPtr, \"%lf\", r_unprc_5 + j);\n\n      case 6:\n        fscanf(hydroPtr, \"%lf\", r_unprc_6 + j);\n\n    }\n\n    fgets(buf, 3, hydroPtr);\n    j++;\n  }\n\n  fclose(hydroPtr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib_3d/7"}
{"code": "for (int i = 1; i <= n; ++i)\n{\n  double l = leftIndex + ((i - 1) * h);\n  double r = leftIndex + (i * h);\n  area += (f1(l) + f1(r)) / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/parallelFor/0"}
{"code": "for (int i = 0; i < system_size; i++)\n  if (!isEqual(validation_matrix[i], variable_value_prev_t[i]))\n{\n  system_is_valid = false;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.1/system_solver/3"}
{"code": "for (int i = 0; i < rows; i++)\n  for (int j = 0; j < cols; j++)\n  infile >> anaMatrixPtr[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daniMusli/paralelImageFilter/paralel3/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << TOTAL_KEYS_LOG_2) - 1)))\n    switch ('A')\n  {\n    case 'S':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'W':\n      if (i < 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'A':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'B':\n      if (((i == 1) || (i == 2)) || (i == 4))\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'C':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/IS/is_single/3"}
{"code": "for (int t = times; t > 0; t /= 2)\n{\n  if ((t % 2) == 1)\n    ret *= tmp;\n\n  tmp = tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/0"}
{"code": "for (i = 0; i <= count; ++i)\n{\n  ch = message[i];\n  if ((ch >= 'a') && (ch <= 180))\n  {\n    ch = ch - key1;\n    if (ch < 'a')\n    {\n      ch = ((ch + 'z') - 'a') + 1;\n    }\n\n    message[i] = ch;\n  }\n  else\n    if ((ch >= 'A') && (ch <= 'Z'))\n  {\n    ch = ch - key1;\n    if (ch < 'A')\n    {\n      ch = ((ch + 'Z') - 'A') + 1;\n    }\n\n    message[i] = ch;\n  }\n\n\n}\n\n", "pragma": "    #pragma omp parallel for ordered num_threads(9)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranavshah029/Parallelizing-Decryption-Alogirthm/parallel_decryption/0"}
{"code": "for (int i = 0; i < len; i++)\n{\n  if (mapper[omp_get_thread_num()].find(arr[i]) != mapper[omp_get_thread_num()].end())\n  {\n    mapper[omp_get_thread_num()][arr[i]] = 1;\n  }\n  else\n  {\n    mapper[omp_get_thread_num()][arr[i]] += 1;\n  }\n\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piyush7gupta/Mapreduce-using-MPI-OPENMP-Wordcount/wordcountopenmp/1"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/19"}
{"code": "for (int i = domain_localRowMin; i < domain_localRowMax; i++)\n{\n  for (int j = 0; j < xmatrix->iia[i]; j++)\n  {\n    xmatrix->val[i][j] *= scalar;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMath/3"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    printf(\" %f  \", mat[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/2L2CU/ParallelComputing/main/1"}
{"code": "for (int ix = 0; ix < DATAXSIZE; ix++)\n{\n  for (int iy = 0; iy < DATAYSIZE; iy++)\n  {\n    for (int iz = 0; iz < DATAZSIZE; iz++)\n    {\n      double tmp = cnew[ix][iy][iz];\n      cnew[ix][iy][iz] = cold[ix][iy][iz];\n      cold[ix][iy][iz] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-omp/main/5"}
{"code": "for (unsigned long int i = 0; i < 1024; ++i)\n  newArray[i] = arr[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivaneduardomv/OpenMPTest/ompArrayCopy/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  I(i, i) = 1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/13"}
{"code": "for (long long j = 0; j < sizeList; j++)\n{\n  counter += checkStr(decipherText, plaintextList[j], tempStr);\n  if ((counter == 3) && (keyFound == 0))\n  {\n    printf(\"Key found is: %s\\n\", pKey);\n    printf(\"Decipher text:\\n%s\\n\", decipherText);\n    keyFound = 1;\n    j = sizeList;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NaorFahima/Parallel-And-Distributed-Computing/Project/func/0"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n{\n  wPerNode[ip + 1] = wPerNode[ip] + wClones[ip]->getActiveWalkers();\n  (app_log() << wClones[ip]->getActiveWalkers()) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/7"}
{"code": "for (col = 0; col < MAXCOL; col++)\n{\n  int nei = 0;\n  int c;\n  int r;\n  for (r = row - 1; r <= (row + 1); r++)\n    for (c = col - 1; c <= (col + 1); c++)\n  {\n    if ((c < 0) || (c >= MAXCOL))\n      continue;\n\n    if (map[(r * MAXCOL) + c] == ALIVE)\n      nei++;\n\n  }\n\n\n  if (map[(row * MAXCOL) + col] == ALIVE)\n    nei--;\n\n  switch (nei)\n  {\n    case 0:\n\n    case 1:\n\n    case 4:\n\n    case 5:\n\n    case 6:\n\n    case 7:\n\n    case 8:\n      newmap[(row * MAXCOL) + col] = DEAD;\n      break;\n\n    case 2:\n      newmap[(row * MAXCOL) + col] = map[(row * MAXCOL) + col];\n      break;\n\n    case 3:\n      newmap[(row * MAXCOL) + col] = ALIVE;\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"GOL\" with OMP and MPI/3"}
{"code": "for (i = 0; i < numprocs; ++i)\n{\n  if ((allResults[i * 2] < consts->qc) || (allResults[(i * 2) + 1] > (consts->alphaMax - consts->alpha0)))\n  {\n    *minAlphaId = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roteml8/binary_classification/BinaryClassifier/2"}
{"code": "for (i = 2; i < 4; i++)\n{\n  for (j = 2; j < (depth + 2); j++)\n  {\n    for (k = 1; k < (height + 1); k++)\n    {\n      data[offset(i, j, k)] = (((((((((((4 * data[offset(i, j, k)]) + data[offset(i - 1, j, k)]) + data[offset(i, j - 1, k)]) + data[offset(i - 2, j, k)]) + data[offset(i, j - 2, k)]) + data[offset(i + 1, j, k)]) + data[offset(i, j + 1, k)]) + data[offset(i + 2, j, k)]) + data[offset(i, j + 2, k)]) + data[offset(i, j, k - 1)]) + data[offset(i, j, k + 1)]) / 14;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petrosgk/Atmospheric-Model-Simulation/AtmModelMPI/2"}
{"code": "for (int64_t r = 0; r < mat->m; ++r)\n{\n  if (mat->values[r])\n    free(mat->values[r]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lanl/libquo/demos/mpi-openmp/dgemv/2"}
{"code": "for (i = 0; i < N; i++)\n  matriz[i] = (int *) malloc((N - i) * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio7/0"}
{"code": "for (i = 0; i < nt; ++i)\n{\n  counter += counters[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/TestParallelFor/1"}
{"code": "for (idx = 0; idx < count; idx += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[23 + 64];\n  unsigned char *cp = &tmp[len];\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_plain[idx], len);\n  SHA512_Update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 64;\n  SHA512_Final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, tmp, len);\n    SHA512_Final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/13"}
{"code": "for (int i = 0; i < corr3.size(); i++)\n{\n  (((((((output << latent_minu_template.m_minutiae[(get < 1) > corr3[i]].x) << \",\") << latent_minu_template.m_minutiae[(get < 1) > corr3[i]].y) << \",\") << rolled_minu_template.m_minutiae[(get < 2) > corr3[i]].x) << \",\") << rolled_minu_template.m_minutiae[(get < 2) > corr3[i]].y) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/8"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  int *vetSeq;\n  vetSeq = (int *) malloc(tam * (sizeof(int)));\n  preenche_vetor_em_sequencia(vetSeq, &tam);\n  vetSeq = inverte_vetor(vetSeq, &tam);\n  printf(\"Vetor desordenado: \");\n  imprimirVetor(vetSeq, &tam);\n  start = omp_get_wtime();\n  sequencial(vetSeq, &tam);\n  end = omp_get_wtime();\n  printf(\"Sequencial com vetor invertido = %f\\n\", end - start);\n  printf(\"Vetor ordenado: \");\n  imprimirVetor(vetSeq, &tam);\n  free(vetSeq);\n  printf(\"-----------------------------------------------\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/5"}
{"code": "for (int i = 2; i < row; i++)\n{\n  for (int j = max(1, (i - n) - 1); j < min(col, i); j++)\n  {\n    int left_up_x = i - 2;\n    int left_up_y = j - 1;\n    if (x[(i - j) - 1] == y[j - 1])\n    {\n      dp[i][j] = dp[left_up_x][left_up_y];\n    }\n    else\n    {\n      dp[i][j] = min3(dp[left_up_x][left_up_y] + pxy, dp[i - 1][j - 1] + pgap, dp[i - 1][j] + pgap);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel6/1"}
{"code": "for (int i = 0; i < tmp.size(); i++)\n{\n  for (int j = 0; j < tmp[i].size(); j++)\n  {\n    kp_vec.push_back(tmp[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zon5566/SIFT-on-OpenMP/sift/6"}
{"code": "for (unsigned long i = 0; i < size; ++i)\n  I(i, i) = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShariqueMohd/Parallel-Image-Compression-using-PCA/DenseMatrix/4"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    (cout << result1[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_4/4/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int rank = 0;\n  for (int j = 0; j < size; j++)\n  {\n    if ((arr[i] > arr[j]) || ((i > j) && (arr[i] == arr[j])))\n      rank++;\n\n  }\n\n  temp[rank] = arr[i];\n}\n\n", "pragma": "omp parallel for shared(arr, temp) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tanghyd/CITS5507Project01/enumeration_sort/0"}
{"code": "for (size_t idx = 0, idx2 = 0; idx < npoints; ++idx)\n{\n  if (deletedPoint[idx])\n    continue;\n\n  m_cloud2[idx2] = m_cloud[idx];\n  m_norms2[idx2] = m_norms[idx];\n  ++idx2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/4"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 10; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Dynamic/main/0"}
{"code": "for (int thread = 0; thread < (nb_threads - 1); thread++)\n{\n  share = make_pair(added, added + portion);\n  shares.emplace_back(share);\n  added += portion;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/mpi+openmp/src/nbody_mpi+openmp/4"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/164"}
{"code": "for (uint64_t i = n - k; i < n; i++)\n{\n  m += (uint64_t) ((buffer[i] >> NthB) & 1);\n  for (uint64_t j = 0; j < (n - i); j++)\n  {\n    rk[j] += (uint64_t) (((buffer[i] & buffer[i + j]) >> NthB) & 1);\n  }\n\n}\n\n", "pragma": "omp for reduction(+:m), reduction(+:rk[:k])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/3"}
{"code": "for (i = 1; i < 23; i++)\n{\n  allocMem[i] = allocMem[i - 1] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmemspd/memSpeedOMP/9"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/54"}
{"code": "for (i = 0; i < 11; i++)\n{\n  for (j = 0; j < 11; j++)\n  {\n    a[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/collapse_2/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    xvel = us[i][j][k];\n    yvel = vs[i][j][k];\n    zvel = ws[i][j][k];\n    ac = speed[i][j][k];\n    acinv = ainv[i][j][k];\n    ac2u = ac * ac;\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    uzik1 = u[0][i][j][k];\n    btuz = bt * uzik1;\n    t1 = (btuz * acinv) * (r4 + r5);\n    t2 = r3 + t1;\n    t3 = btuz * (r4 - r5);\n    rhs[0][i][j][k] = t2;\n    rhs[1][i][j][k] = ((-uzik1) * r2) + (xvel * t2);\n    rhs[2][i][j][k] = (uzik1 * r1) + (yvel * t2);\n    rhs[3][i][j][k] = (zvel * t2) + t3;\n    rhs[4][i][j][k] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[i][j][k] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n  }\n\n}\n\n", "pragma": "omp parallel for private (t1,t2,t3,ac,xvel,yvel,zvel,r1,r2,r3,r4,r5,btuz,acinv,ac2u,uzik1,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/159"}
{"code": "for (i = 1; i <= t_last; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/ssor/4"}
{"code": "for (phase = 0; phase < n; phase++)\n{\n  if ((phase & 1) == 0)\n  {\n    for (i = 1; i < n; i += 2)\n      if (arr[i - 1] > arr[i])\n    {\n      temp = arr[i];\n      arr[i] = arr[i - 1];\n      arr[i - 1] = temp;\n    }\n\n\n  }\n  else\n  {\n    for (i = 1; i < (n - 1); i += 2)\n      if (arr[i] > arr[i + 1])\n    {\n      temp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = temp;\n    }\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(phase)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/OddEvenSorting/3"}
{"code": "for (i = 0; i < (*size); i++)\n  scanf(\"%lf\", &numbers[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ozamzaleg/Parallel_Computation_MPI_OpenMP/functions/1"}
{"code": "for (i = 0; i < NGROUPS; i++)\n  for (j = 0; j < (NFEAT + 1); j++)\n  additions[i][j] = 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (i == 0)\n  {\n    teams3 = omp_get_num_teams();\n    threads3 = omp_get_num_threads();\n    if (DEBUG)\n      printf(\"  num teams %d, num thread %d\\n\", teams3, threads3);\n\n  }\n\n  A[i] += 2 * i;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(teams3, threads3) num_teams(teamLimit3) thread_limit(threadLimit3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/xt-nums-in-teams-par-for-default/test/2"}
{"code": "for (int i = 0; i < p; i++)\n{\n  M2[i] = &bspace[i * m];\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/MultiplicationMatricielle/MultiplicationMatricielle/1"}
{"code": "for (i = 0; i < 9; i++)\n{\n  temp = window[i];\n  for (j = i - 1; (j >= 0) && (temp < window[j]); j--)\n  {\n    window[j + 1] = window[j];\n  }\n\n  window[j + 1] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhilashjain755/ParallelProg_NoiseFilter/Mediun Filter/Median_filter/0"}
{"code": "for (int i = 0; i < nThreads; ++i)\n{\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setstacksize(&attr, (2 * 1024) * 1024);\n  int threadID = minid + i;\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(threadID, &cpuset);\n  int ret = pthread_attr_setaffinity_np(&attr, sizeof(cpuset), &cpuset);\n  int err = pthread_create(&thread[i], &attr, &_threadFct, this);\n  ++numThreadsRunning;\n  if (err != 0)\n  {\n    fprintf(stderr, \"Error creating pthread %d: %s\\n\", i, strerror(err));\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/9"}
{"code": "for (unsigned j = 0; j < I; ++j)\n{\n  unsigned r1 = 0;\n  for (unsigned r = 0; r < P1; ++r)\n    r1 += R1[r];\n\n  unsigned R2[P2];\n  for (unsigned r = 0; r < P2; ++r)\n    R2[r] = (ii + r) + 7;\n\n  Arr(A, i, j, 0) += r1;\n  Arr(B, i, j, 0) += r1;\n  for (unsigned k = 0; k < I; ++k)\n  {\n    unsigned r2 = 0;\n    for (unsigned r = 0; r < P2; ++r)\n      r2 += R2[r];\n\n    Arr(A, i, j, k) += r2;\n    Arr(B, i, j, k) += r2;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-data-sharing-many-teams/test/5"}
{"code": "for (i = 0; i < (dimensionSize + 1); i++)\n{\n  AllWeights[myrank][i] = weights[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/7"}
{"code": "for (m_imopVarPre78 = 0; m_imopVarPre78 < 5; m_imopVarPre78++)\n{\n  sum[m_imopVarPre78] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/23"}
{"code": "for (ii = 0; ii < NUM_THREADS; ii++)\n{\n  int start;\n  int end;\n  int px_idx;\n  int px_x;\n  int px_y;\n  int px_value;\n  start = part * ii;\n  end = start + part;\n  if (ii == (NUM_THREADS - 1))\n    end = total_px;\n\n  for (px_idx = 0; px_idx < end; px_idx++)\n  {\n    px_x = px_idx / im_width;\n    px_y = px_idx - ((px_x * im_width) + 1);\n    px_value = image(px_x, px_y);\n    result_mat(ii, px_value) = result_mat(ii, px_value) + 1;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static, NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thanhphamvan/histogram_octave/hist_omp/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  k = 1 << kk[i];\n  sum = 0;\n  for (int j = 0; j < k; ++j)\n    sum += a[j];\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(a, kk) private(k, sum) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pchenik/OpenMP_Tasks/Task11/main/1"}
{"code": "for (unsigned long long t = 1; t < input_time; t++)\n{\n  for (i = 0; i < (grid_rows * grid_cols); i++)\n  {\n    temp[((t * grid_rows) * grid_cols) + i] = temp[i];\n    power[((t * grid_rows) * grid_cols) + i] = power[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/hotspot/hotspot_openmp/3"}
{"code": "for (unsigned long long int j = i * i; j <= n; j += i)\n{\n  a[j] = 0;\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(a,i) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Parply/prime-sieve/sieve/0"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (k = 0; k < nz; k++)\n    {\n      utmp[k][0] = u[k][j][i][0];\n      utmp[k][1] = u[k][j][i][1];\n      utmp[k][2] = u[k][j][i][2];\n      utmp[k][3] = u[k][j][i][3];\n      utmp[k][4] = u[k][j][i][4];\n      utmp[k][5] = rho_i[k][j][i];\n    }\n\n    for (k = 0; k < nz; k++)\n    {\n      flux[k][0] = utmp[k][3];\n      u41 = utmp[k][3] * utmp[k][5];\n      q = qs[k][j][i];\n      flux[k][1] = utmp[k][1] * u41;\n      flux[k][2] = utmp[k][2] * u41;\n      flux[k][3] = (utmp[k][3] * u41) + (C2 * (utmp[k][4] - q));\n      flux[k][4] = ((C1 * utmp[k][4]) - (C2 * q)) * u41;\n    }\n\n    for (k = 1; k < (nz - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rtmp[k][m] = rsd[k][j][i][m] - (tz2 * (flux[k + 1][m] - flux[k - 1][m]));\n      }\n\n    }\n\n    for (k = 1; k < nz; k++)\n    {\n      tmp = utmp[k][5];\n      u21k = tmp * utmp[k][1];\n      u31k = tmp * utmp[k][2];\n      u41k = tmp * utmp[k][3];\n      u51k = tmp * utmp[k][4];\n      tmp = utmp[k - 1][5];\n      u21km1 = tmp * utmp[k - 1][1];\n      u31km1 = tmp * utmp[k - 1][2];\n      u41km1 = tmp * utmp[k - 1][3];\n      u51km1 = tmp * utmp[k - 1][4];\n      flux[k][1] = tz3 * (u21k - u21km1);\n      flux[k][2] = tz3 * (u31k - u31km1);\n      flux[k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n    }\n\n    for (k = 1; k < (nz - 1); k++)\n    {\n      rtmp[k][0] = rtmp[k][0] + ((dz1 * tz1) * ((utmp[k - 1][0] - (2.0 * utmp[k][0])) + utmp[k + 1][0]));\n      rtmp[k][1] = (rtmp[k][1] + (((tz3 * C3) * C4) * (flux[k + 1][1] - flux[k][1]))) + ((dz2 * tz1) * ((utmp[k - 1][1] - (2.0 * utmp[k][1])) + utmp[k + 1][1]));\n      rtmp[k][2] = (rtmp[k][2] + (((tz3 * C3) * C4) * (flux[k + 1][2] - flux[k][2]))) + ((dz3 * tz1) * ((utmp[k - 1][2] - (2.0 * utmp[k][2])) + utmp[k + 1][2]));\n      rtmp[k][3] = (rtmp[k][3] + (((tz3 * C3) * C4) * (flux[k + 1][3] - flux[k][3]))) + ((dz4 * tz1) * ((utmp[k - 1][3] - (2.0 * utmp[k][3])) + utmp[k + 1][3]));\n      rtmp[k][4] = (rtmp[k][4] + (((tz3 * C3) * C4) * (flux[k + 1][4] - flux[k][4]))) + ((dz5 * tz1) * ((utmp[k - 1][4] - (2.0 * utmp[k][4])) + utmp[k + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[1][j][i][m] = rtmp[1][m] - (dssp * ((((+5.0) * utmp[1][m]) - (4.0 * utmp[2][m])) + utmp[3][m]));\n      rsd[2][j][i][m] = rtmp[2][m] - (dssp * (((((-4.0) * utmp[1][m]) + (6.0 * utmp[2][m])) - (4.0 * utmp[3][m])) + utmp[4][m]));\n    }\n\n    for (k = 3; k < (nz - 3); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rtmp[k][m] - (dssp * ((((utmp[k - 2][m] - (4.0 * utmp[k - 1][m])) + (6.0 * utmp[k][m])) - (4.0 * utmp[k + 1][m])) + utmp[k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[nz - 3][j][i][m] = rtmp[nz - 3][m] - (dssp * (((utmp[nz - 5][m] - (4.0 * utmp[nz - 4][m])) + (6.0 * utmp[nz - 3][m])) - (4.0 * utmp[nz - 2][m])));\n      rsd[nz - 2][j][i][m] = rtmp[nz - 2][m] - (dssp * ((utmp[nz - 4][m] - (4.0 * utmp[nz - 3][m])) + (5.0 * utmp[nz - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/31"}
{"code": "for (unsigned i = 0; i < magnitude_images_creation_locks.size(); ++i)\n  omp_destroy_lock(&magnitude_images_creation_locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/12"}
{"code": "for (i = 0; i < 800; i++)\n{\n  c[i] = (double *) malloc((sizeof(double)) * 800);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/3"}
{"code": "for (int i = 0; i < m->row; i++)\n{\n  for (int j = 0; j < m->col; j++)\n  {\n    if (m->tab[i][j] != 0)\n    {\n      fprintf(*path_matr, \"%i %i %lf\\n\", i + 1, j + 1, m->tab[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/4"}
{"code": "for (int i = 0; i < nnodes; i++)\n{\n  iterator it = it_begin + i;\n  for (unsigned int i = 0; i < rControlFlags.size(); i++)\n  {\n    if (it->Is(rControlFlags[i]))\n    {\n      for (unsigned int i = 0; i < rAssignFlags.size(); i++)\n        it->Set(rAssignFlags[i]);\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/0"}
{"code": "for (size_t x = 1; x < (w - 1); ++x)\n{\n  g1[(0 * w) + x] = (g2[(0 * w) + x] = g1[(1 * w) + x]);\n  g1[((h - 1) * w) + x] = (g2[((h - 1) * w) + x] = g1[((h - 2) * w) + x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/compute/3"}
{"code": "for (int c = 0; c < num_clusters; c++)\n  for (int i = 0; i < num_attributes; i++)\n  if (nums[c] != 0)\n  clusters[c].centroid.attributes[i] = sums[c][i] / nums[c];\nelse\n  clusters[c].centroid.attributes[i] = 0;\n\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leoli51/Parallel-K-means-Clustering/KMeansMPClustering/1"}
{"code": "for (i = 0; i < id; i++)\n{\n  x += temp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/himanshudhawale/PrefixSum-OpenMP-Loop/prefixsum/0"}
{"code": "for (int i = 0; i < num_edges; ++i)\n  in_array[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/7"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  i = 1;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[i][m]) - (4.0 * ue[i + 1][m])) + ue[i + 2][m]));\n  i = 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[i - 1][m]) + (6.0 * ue[i][m])) - (4.0 * ue[i + 1][m])) + ue[i + 2][m]));\n}\n\n", "pragma": "omp parallel for private (i,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/14"}
{"code": "for (; (last_i + 7) < n; last_i += 8)\n{\n  _mm256_store_pd(&y[last_i + 0], _mm256_load_pd(&x[last_i + 0]));\n  _mm256_store_pd(&y[last_i + 4], _mm256_load_pd(&x[last_i + 4]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/32"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  for (size_t j = 0; j < i; j++)\n  {\n    temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/6"}
{"code": "for (i = 0; i < Y1->dim; i++)\n  v_set_val(Y1, i, v_get_val(Y, i) + (delta * v_get_val(Ny, i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/24"}
{"code": "for (int i = 0; i < numIndividuals; i++)\n{\n  allocate_memory_ind(&inds[i]);\n  indexes[i] = values[currPos];\n  currPos++;\n  mpi_desrialize_ind_from_master(&inds[i], values, currPos);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/9"}
{"code": "for (int i = 1; i < size_N; ++i)\n  result[i] = (a * result[i - 1]) + b;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArtTikidji/Study_openMP_AVX/main/2"}
{"code": "force[i] = 0\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/SoaSimulator/0"}
{"code": "for (int i = 0; i < size; i++)\n  (vector_output << right[i]) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaempunk/linear-equations-solution-openmp/linear_equations/2"}
{"code": "for (int w = 1; w <= 18; w++)\n{\n  for (int q = 1; q <= 20; q++)\n  {\n    filename = ((to_string(w) + \".\") + to_string(q)) + \".txt\";\n    int **image = read_pgm_file(filename, num_rows, num_cols);\n    int **img = alloc_2d_matrix(num_rows + 2, num_cols + 2);\n    for (int i = 0; i < (num_rows + 2); i++)\n    {\n      for (int j = 0; j < (num_cols + 2); j++)\n      {\n        img[i][j] = 0;\n      }\n\n    }\n\n    for (int i = 1; i <= num_rows; i++)\n    {\n      for (int j = 1; j <= num_cols; j++)\n      {\n        img[i][j] = image[i - 1][j - 1];\n      }\n\n    }\n\n    create_histogram(training_set[w - 1][q - 1], img, num_rows, num_cols);\n    dealloc_2d_matrix(image, num_rows, num_cols);\n    dealloc_2d_matrix(img, num_rows + 2, num_cols + 2);\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/5"}
{"code": "for (uint32_t l = 0; l < nnz; l++)\n{\n  uint32_t col_l;\n  col_l = col_coo[l] - isOneBased;\n  uint32_t dst = col[col_l];\n  row[dst] = row_coo[l] - isOneBased;\n  col[col_l]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v3/v3_omp/5"}
{"code": "for (k = 0; k < argc; ++k)\n  ++k;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/distribute_simd_misc_messages/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    for (int k = 0; k < N; ++k)\n    {\n      C[i + (j * N)] += A[k + (i * N)] * B[j + (k * N)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/openmp/matmat_omp/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  a[i] = i * i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rookiehpc/rookiehpc.github.io/openmp/exercises/exercise_2/solution/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  ax = 0;\n  for (j = 0; j < cols; j++)\n    if (i != j)\n    ax = ax + (A[i][j] * x_0[j]);\n\n\n  x_[i] = ((-ax) + b[i]) / A[i][i];\n}\n\n", "pragma": "omp for private(i, j, ax)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zajaczek/Solving-linear-equations-using-the-Jacobi-method/parallel_linear_equation_solving/openmp/jacobi_openmp/0"}
{"code": "for (i = 0; i < 768; i++)\n  for (j = 0; j < 768; j++)\n{\n  int end = 0;\n  while (!end)\n  {\n    V[i][j] += 0.00004;\n    if (V[i][j] > 1.0)\n      end = 1;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(guided, 16) collapse(2) shared(V) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab4_OpenMP/Test1_Schedules/ejemplo1/0"}
{"code": "for (int i = 0; i < n; i++)\n  row[i] = rand() % 10;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Documents/TrabajoDeCursada/Matrix Multiplication/mm/3"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  SHA256_CTX ctx;\n  if (B_LEN == (256 / 8))\n  {\n    if (new_keys)\n    {\n      SHA256_Init(&ipad_ctx[index]);\n      SHA256_Update(&ipad_ctx[index], ipad[index], 64);\n      SHA256_Init(&opad_ctx[index]);\n      SHA256_Update(&opad_ctx[index], opad[index], 64);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    SHA256_Update(&ctx, cur_salt, strlen((char *) cur_salt));\n    SHA256_Final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    SHA256_Update(&ctx, crypt_key[index], B_LEN);\n    SHA256_Final((unsigned char *) crypt_key[index], &ctx);\n  }\n  else\n  {\n    if (new_keys)\n    {\n      SHA224_Init(&ipad_ctx[index]);\n      SHA224_Update(&ipad_ctx[index], ipad[index], 64);\n      SHA224_Init(&opad_ctx[index]);\n      SHA224_Update(&opad_ctx[index], opad[index], 64);\n    }\n\n    memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n    SHA224_Update(&ctx, cur_salt, strlen((char *) cur_salt));\n    SHA224_Final((unsigned char *) crypt_key[index], &ctx);\n    memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n    SHA224_Update(&ctx, crypt_key[index], B_LEN);\n    SHA224_Final((unsigned char *) crypt_key[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/hmacSHA256_fmt_plug/0"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  double *variable = &data0[5 * n_op];\n  const int *up_scratch = &data1[1 * n_op];\n  double avg = ((*up_scratch) == 0) ? (1.0) : (1.0 / ((double) (*up_scratch)));\n  variable[VAR_DENSITY] *= avg;\n  variable[VAR_MOMENTUM + 0] *= avg;\n  variable[VAR_MOMENTUM + 1] *= avg;\n  variable[VAR_MOMENTUM + 2] *= avg;\n  variable[VAR_DENSITY_ENERGY] *= avg;\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/up_post_kernel_omp4kernel_func/0"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"Thread ID: %d, index: %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/parallel12/0"}
{"code": "for (i = 0; i < length; i++)\n{\n  for (j = i + 1; j < length; j++)\n  {\n    if ((((j - i) < (LOOP_MIN + 1)) || (!isupper(s[i]))) || (!isupper(s[j])))\n    {\n      base_cp[((j * (j - 1)) / 2) + i] = 0;\n    }\n    else\n    {\n      base_cp[upper_triangle_index(i, j)] = is_canonical_pair(seq[i], seq[j]) && ((((i > 0) && (j < (length - 1))) && is_canonical_pair(seq[i - 1], seq[j + 1])) || (((j - i) >= (LOOP_MIN + 3)) && is_canonical_pair(seq[i + 1], seq[j - 1])));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/prna-omp/prna/9"}
{"code": "for (int i = 0; i < imgSize; ++i)\n{\n  int current_thread = omp_get_thread_num();\n  for (int j = 0; j < imgSize; ++j)\n  {\n    hist_thread[(current_thread * 256) + img[(i * imgSize) + j]]++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/histograma/src/main/4"}
{"code": "for (ii = 0; ii < 10; (ii) ? (++ii) : (++jj))\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/30"}
{"code": "for (int i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (int i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    double r1[M];\n    double r2[M];\n    if (n1 < 8)\n      for (int i1 = 0; i1 < n1; i1++)\n    {\n      r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n      r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n    }\n\n    else\n    {\n      for (int i1 = 0; i1 < n1; i1++)\n        r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n\n      for (int i1 = 0; i1 < n1; i1++)\n        r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n\n    }\n\n    double c0 = c[0];\n    double c1 = c[1];\n    double c2 = c[2];\n    for (int i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      u[i3][i2][i1] += ((c0 * r[i3][i2][i1]) + (c1 * ((r[i3][i2][i1 - 1] + r[i3][i2][i1 + 1]) + r1[i1]))) + (c2 * ((r2[i1] + r1[i1 - 1]) + r1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment10/real/real/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  result[i] = 0;\n  vect[i] = (rand() % 50) + 1;\n  for (int j = 0; j < N; j++)\n  {\n    mat[i][j] = (rand() % 50) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_multiplication/Q4/0"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n    debug_assignment(&dataset[n], closest_cluster, &centroids[closest_cluster], min_distance);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/4"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    *((C + (i * P)) + j) = 0;\n    *((Cp + (i * P)) + j) = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/matmul-test/matmul/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int seq_num = i / seq_len;\n  int swapped_ele = -1;\n  int h_len = seq_len / 2;\n  if (i < ((seq_len * seq_num) + h_len))\n    swapped_ele = i + h_len;\n\n  int odd = seq_num / two_power;\n  bool increasing = (odd % 2) == 0;\n  if (swapped_ele != (-1))\n  {\n    if (((data_gpu[i] > data_gpu[swapped_ele]) && increasing) || ((data_gpu[i] < data_gpu[swapped_ele]) && (!increasing)))\n    {\n      int temp = data_gpu[i];\n      data_gpu[i] = data_gpu[swapped_ele];\n      data_gpu[swapped_ele] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bitonic-sort-omp/main/0"}
{"code": "for (i = 0; i < ((1 << 11) - 1); i++)\n{\n  prv_buff1[i + 1] += prv_buff1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/7"}
{"code": "for (x = 0; x < L; x++)\n  for (y = 0; y < L; y++)\n{\n  residue = ((res[x + (y * L)] / p.scale[lev]) - (phi[x + (y * L)] / p.scale[lev])) + (((phi[((x + 1) % L) + (y * L)] + phi[(((x - 1) + L) % L) + (y * L)]) + phi[x + (((y + 1) % L) * L)]) + phi[x + ((((y - 1) + L) % L) * L)]);\n  ResRoot += residue * residue;\n}\n\n\n", "pragma": "omp parallel for private(y,x,residue) shared(p, L) reduction(+:ResRoot)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/6"}
{"code": "for (i = 1; i <= m; i++)\n{\n  for (j = 1; j <= n; j++)\n  {\n    tnew[i][j] = (((t[i - 1][j] + t[i + 1][j]) + t[i][j - 1]) + t[i][j + 1]) / 4.0;\n    diff = fabs(tnew[i][j] - t[i][j]);\n    if (diff > difmax)\n    {\n      priv_difmax = diff;\n    }\n\n    t[i][j] = tnew[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkerthegeek/ParallelProgramming-OpenMP/1iteration_parallel_gauss2d/2"}
{"code": "for (int jj = 0; jj < (N + 2); jj++)\n{\n  for (int kk = 0; kk < (N + 2); kk++)\n  {\n    printf(\"array3d[%d][%d][%d] = %f.\\n\", index, jj, kk, evaluate_array3d(array3d, N, index, jj, kk));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/11"}
{"code": "for (i = jz; i >= 0; i--)\n{\n  fv = fv + fq[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/18"}
{"code": "for (int i = 0; i < (2 * RADIUS); i++)\n{\n  int s = 0;\n  for (int j = i; j <= (i + (2 * RADIUS)); j++)\n    s += (j < RADIUS) ? (0) : (a[j] - RADIUS);\n\n  if (s != b[i])\n  {\n    printf(\"Error at %d: %d (host) != %d (device)\\n\", i, s, b[i]);\n    ok = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/stencil1d-omp/stencil_1d/3"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src;\n  uint32_t dest = v;\n  float weight = 0.0001f;\n  Nodes = graph->vertices[dest].outNodes;\n  degree = graph->vertices[dest].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    src = Nodes->edges_array_dest[j];\n    stats->vector_output[dest] += weight * stats->vector_input[src];\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/14"}
{"code": "for (i = 0; i < cs.ctlen; i++)\n  cs.ciphertext[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/andotp_fmt_plug/1"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    viscosity[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = viscosity[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/21"}
{"code": "for (unsigned int u = 0; u < m_uNumberOfGridPoints1D; ++u)\n{\n  for (unsigned int v = 0; v < m_uNumberOfGridPoints1D; ++v)\n  {\n    m_gridHeat[u][v] = getHeatAnalytical(u * m_dGridPointSpacing, v * m_dGridPointSpacing, p_dCurrentTime);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/2"}
{"code": "for (i = 1; i <= 16; i++)\n{\n  r48 = 0;\n  xOR48 = 0;\n  s32 = 0;\n  p32 = 0;\n  parteE = parteDA;\n  r48 = permuta(parteDA, e, 48, 32);\n  xOR48 = r48 ^ subKeys[i];\n  for (j = 0; j < 8; j++)\n  {\n    linhas = ((xOR48 >> ((47 - (6 * j)) - 1)) & 2) | ((xOR48 >> ((47 - (6 * j)) - 5)) & 1);\n    colunas = (xOR48 >> ((47 - (6 * j)) - 4)) & 0xF;\n    s32 |= s[j][linhas][colunas];\n    if (j != 7)\n      s32 = s32 << 4;\n\n  }\n\n  p32 = permuta(s32, p, 32, 32);\n  parteD = parteEA ^ p32;\n  parteDA = parteD;\n  parteEA = parteE;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/DES/DES/2"}
{"code": "for (int y = 1; y < (rows - 1); y++)\n{\n  for (int x = 1; x < (columns - 1); x++)\n  {\n    if ((((double) rand()) / 32767) <= density)\n      grid[y][x] = '#';\n    else\n      grid[y][x] = '.';\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp/1"}
{"code": "for (int i = 0; i < (N * N); i++)\n{\n  A[i] = dist(generator);\n  B[i] = dist(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/7"}
{"code": "for (int j = 0; j < rows; ++j)\n{\n  L += array[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p1c/1"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv12_data[(((layer12_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv12_data[(((layer12_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv12[layer12_index];\n    if (conv12_data[(((layer12_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv12_data[(((layer12_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/50"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j += 1)\n{\n  sum = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k += 1)\n  {\n    sum = sum + (a[k] * p[colidx[k]]);\n  }\n\n  q[j] = sum;\n}\n\n", "pragma": "omp parallel for private (sum,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/7"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  r[j] = w[j];\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/14"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"thread %d put in c[] value %d\\n\", omp_get_thread_num(), c[i]);\n}\n\n", "pragma": "        #pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leaferm/OMP/main/9"}
{"code": "for (int i = 0; i < W; i++)\n{\n  output1[i] = (int *) malloc((sizeof(int)) * H);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anw10/FRecogRPI/cameraci_control/1"}
{"code": "for (i = 0; i < 10; ++i)\n  bar(i);\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr34610/0"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  free(ptr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/1"}
{"code": "for (digit = 0; digit < (d + 11); ++digit)\n{\n  digits[digit] = 0;\n  for (th = 0; th < num_threads; ++th)\n  {\n    aux[th][digit] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonardocreatus/Progama-oParalela-OpenMP/reduce/0"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n    debug_assignment(&dataset[n], closest_cluster, &centroids[closest_cluster], min_distance);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) reduction(+:cluster_changes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp2_impl/2"}
{"code": "for (i = 0; i < size; i++)\n  for (j = 0; j < size; j++)\n  u[i][j] = a_p[i][j];\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/inverse/8"}
{"code": "for (int i = 3, last = (int) ((double) sqrt(number)); i <= last; i += 2)\n{\n  if ((number % i) == 0)\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Katherine506/C-OpenMP-MPI/CI0117-2020-S2/Laboratorios/7/count_primes_cyclic/count_primes_cyclic/0"}
{"code": "for (i = 1; i < k; i++)\n  score = score + scoringMatrix[i][i + n];\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/calculations/0"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + .5) * step;\n  sum = sum + (4.0 / (1. + (x * x)));\n}\n\n", "pragma": "#pragma omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hoyajigi/openmp/LAB1/pi/solution/pi_omp/0"}
{"code": "for (unsigned int k = 2; k < baseaddresses.size(); ++k)\n{\n  baseaddresses[k] = baseaddresses[k - 1] + numnodes[k - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/octree/4"}
{"code": "for (int i = 0; i < SHARED_PARAMS_SIZE; i++)\n{\n  recv_params += to_string(shared_params[i]) + ' ';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/11"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  for (j = 0; j < 3000; j++)\n    if (j == 0)\n    fprintf(fp, \"%d\", result_image[i][j]);\n  else\n    fprintf(fp, \" %d\", result_image[i][j]);\n\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/3"}
{"code": "for (i = 0; i < number_bodies; i++)\n{\n  R[i][0] += V[i][0] * delta_t;\n  R[i][1] += V[i][1] * delta_t;\n  R[i][2] += V[i][2] * delta_t;\n  if ((R[i][0] >= breadth) || (R[i][0] <= 0))\n  {\n    R[i][0] = (R[i][0] <= 0) ? (-R[i][0]) : ((2 * breadth) - R[i][0]);\n    V[i][0] = -V[i][0];\n  }\n\n  if ((R[i][1] >= length) || (R[i][1] <= 0))\n  {\n    R[i][1] = (R[i][1] <= 0) ? (-R[i][1]) : ((2 * length) - R[i][1]);\n    V[i][1] = -V[i][1];\n  }\n\n  if ((R[i][2] >= height) || (R[i][2] <= 0))\n  {\n    R[i][2] = (R[i][2] <= 0) ? (-R[i][2]) : ((2 * height) - R[i][2]);\n    V[i][2] = -V[i][2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/5"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  ne = npp + npoff;\n  if (ne > nop)\n    ierr = (ierr > (ne - nop)) ? (ierr) : (ne - nop);\n\n  if (ierr > 0)\n    npp = 0;\n\n  for (j = 0; j < npp; j++)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      part[i + (idimp * (j + npoff))] = ppart[i + (idimp * (j + (nppmx * k)))];\n    }\n\n  }\n\n  npoff += npp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/25"}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/69"}
{"code": "for (igraph = 0; igraph < Ngraphs; igraph++)\n{\n  Ncon = (long *) malloc(Nvert * (sizeof(long)));\n  if (Ncon == 0)\n  {\n    printf(\"Error allocating Ncon array\\n\");\n    exit(1);\n  }\n\n  Lcon = (long *) malloc((Nvert * Maxcon) * (sizeof(long)));\n  if (Lcon == 0)\n  {\n    printf(\"Error allocating Lcon array\\n\");\n    exit(1);\n  }\n\n  for (i = 0; i < Nvert; i++)\n  {\n    Ncon[i] = 0;\n  }\n\n  for (i = 0; i < (Nvert * Maxcon); i++)\n  {\n    Lcon[i] = -1;\n  }\n\n  for (i = 0; i < Nvert; i++)\n  {\n    for (j = i + 1; j < Nvert; j++)\n    {\n      xi = genrand();\n      if (xi < Pcon)\n      {\n        Ncon[i] = Ncon[i] + 1;\n        Ncon[j] = Ncon[j] + 1;\n        if ((Ncon[i] > (Maxcon - 1)) || (Ncon[j] > (Maxcon - 1)))\n        {\n          printf(\"Error generating random graph.\\n\");\n          printf(\"Maximum number of edges per vertex exceeded!\\n\");\n          exit(1);\n        }\n\n        Lcon[((Maxcon * i) + Ncon[i]) - 1] = j;\n        Lcon[((Maxcon * j) + Ncon[j]) - 1] = i;\n      }\n\n    }\n\n  }\n\n  find_clusters_eqclass(Nvert, Maxcon, Ncon, Lcon, &lclus, &nclus);\n  avlclus += (double) lclus;\n  avnclus += (double) nclus;\n  free(Lcon);\n  free(Ncon);\n}\n\n", "pragma": "omp parallel for private(igraph,i,j,xi,Ncon,Lcon) shared(nclus, lclus) reduction(+: avlclus, avnclus)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/1602077/UniProjects/parallel_computing/percolation3/0"}
{"code": "for (i = 0; i < 17; i++)\n{\n  if (input[i] != (-i))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_17_epilog_killer_parallel/9"}
{"code": "for (int k = 1; k < (m_iMaxDepth + 1); ++k)\n{\n  int count = 1;\n  for (int i = 1; i < m_iTotalNumberOfParticles; ++i)\n  {\n    if ((m_vParticleKeyIndex[i].key & bitmasks[k]) != (m_vParticleKeyIndex[i - 1].key & bitmasks[k]))\n    {\n      ++count;\n    }\n\n  }\n\n  numnodes[k] = count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/octree/2"}
{"code": "for (int i = 0; i < n; i++)\n  p[i] = z[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/omp/cg/3"}
{"code": "for (p = 0; p < Np; p++)\n{\n  X_p = memory_to_matrix__MatrixLib__(Ndim, 1, MPM_Mesh.Phi.x_GC.nM[p]);\n  dis_p = memory_to_matrix__MatrixLib__(Ndim, 1, MPM_Mesh.Phi.dis.nM[p]);\n  if (norm__MatrixLib__(dis_p, 2) > 0)\n  {\n    Locality_I0 = FEM_Mesh.NodalLocality_0[MPM_Mesh.I0[p]];\n    MPM_Mesh.I0[p] = get_closest_node__MeshTools__(X_p, Locality_I0, FEM_Mesh.Coordinates);\n    MPM_Mesh.Element_p[p] = search_particle_in_surrounding_elements__Particles__(p, X_p, FEM_Mesh.NodeNeighbour[MPM_Mesh.I0[p]], FEM_Mesh);\n    if (MPM_Mesh.Element_p[p] == (-999))\n    {\n      fprintf(stderr, \"hello Error in hellohellosearch_particle_in_surrounding_elements__Particles__(%i,,) hello \\n\", p);\n      STATUS = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(p, X_p, dis_p, Locality_I0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/2"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  x++;\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB110-ordered-orig-no/0"}
{"code": "for (int i = 0; i < strok; i++)\n{\n  cout << endl;\n  for (int j = 0; j < stolb; j++)\n  {\n    a[i][j] = 1 + (rand() % 100);\n    (cout << a[i][j]) << \" \";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task1/0"}
{"code": "for (i = 0; i < 5; i++)\n  ((((cout << \"a[\") << i) << \"] = \") << a[i]) << \"\\n\";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/g1stavo/parallel-distributed/lab-2/master/1"}
{"code": "for (i = 0; i < 25; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio5/ejercicio5/0"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 0; j <= (m - 1); j += 1)\n  {\n    printf(\"%lf\\n\", b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB032-truedepfirstdimension-var-yes/0"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  for (j = 0; j < topoinfo->numR; j++)\n  {\n    if (topoinfo->TargetG[j] == i)\n    {\n      fprintf(f_paras, \"Trd_of_%sTo%s\\t%f\\t%f\\t%d\\n\", topoinfo->Gname[topoinfo->SourceG[j]], topoinfo->Gname[topoinfo->TargetG[j]], meanT[topoinfo->SourceG[j]] * amplifyfold[topoinfo->SourceG[j]], stdT[topoinfo->SourceG[j]] * amplifyfold[topoinfo->SourceG[j]], 0);\n      fprintf(f_paras, \"Num_of_%sTo%s\\t%f\\t%f\\t%d\\n\", topoinfo->Gname[topoinfo->SourceG[j]], topoinfo->Gname[topoinfo->TargetG[j]], minN_d, maxN_d, 0);\n      if (topoinfo->TypeR[j] == 1)\n      {\n        fprintf(f_paras, \"Act_of_%sTo%s\\t%f\\t%f\\t%d\\n\", topoinfo->Gname[topoinfo->SourceG[j]], topoinfo->Gname[topoinfo->TargetG[j]], meanF, stdF, topoinfo->TypeR[j]);\n      }\n      else\n        if (topoinfo->TypeR[j] == 2)\n      {\n        fprintf(f_paras, \"Inh_of_%sTo%s\\t%f\\t%f\\t%d\\n\", topoinfo->Gname[topoinfo->SourceG[j]], topoinfo->Gname[topoinfo->TargetG[j]], meanF, stdF, topoinfo->TypeR[j]);\n      }\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/31"}
{"code": "for (i = rb; i < re; i++)\n  norm += p_r[i] * p_r[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/13"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/5"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      xvel = us[k][j][i];\n      yvel = vs[k][j][i];\n      zvel = ws[k][j][i];\n      ac = speed[k][j][i];\n      ac2u = ac * ac;\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      uzik1 = u[k][j][i][0];\n      btuz = bt * uzik1;\n      t1 = (btuz / ac) * (r4 + r5);\n      t2 = r3 + t1;\n      t3 = btuz * (r4 - r5);\n      rhs[k][j][i][0] = t2;\n      rhs[k][j][i][1] = ((-uzik1) * r2) + (xvel * t2);\n      rhs[k][j][i][2] = (uzik1 * r1) + (yvel * t2);\n      rhs[k][j][i][3] = (zvel * t2) + t3;\n      rhs[k][j][i][4] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[k][j][i] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,t1,t2,t3,ac,xvel,yvel,zvel,r1,r2,r3,r4,r5,btuz,ac2u,uzik1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/tzetar/0"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c3 = 16 * c1; c3 <= ((((16 * c1) + 15) < (n + (-1))) ? ((16 * c1) + 15) : (n + (-1))); c3++)\n  {\n    for (c4 = 16 * c2; c4 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c4++)\n    {\n      X[c3][c4] = ((((double) c3) * (c4 + 1)) + 1) / n;\n      A[c3][c4] = ((((double) c3) * (c4 + 2)) + 2) / n;\n      B[c3][c4] = ((((double) c3) * (c4 + 3)) + 3) / n;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2 ,c4 ,c3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/1"}
{"code": "for (int i = 0; i < max; ++i)\n{\n  index[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jb25/openmp-mpi/cracker_final/3"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  grid[i][cols - 1] = recvRightColumn[i];\n  grid[i][0] = recvLeftColumn[i];\n}\n\n", "pragma": "omp parallel for shared(rows, cols, grid, recvRightColumn, recvLeftColumn) private(i) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_mpi_openmp/1"}
{"code": "for (int k = 1; k < N; k += 2)\n{\n  sum += factor / ((2 * k) + 1);\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilev4ik/openmp/main/2"}
{"code": "for (i = 2; i < n; i++)\n{\n  t = f2;\n  f2 = f1 + f2;\n  f1 = t;\n  printf(\"%lld \", f2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sotosgeo/OpenMP/Examples/3-fibo1/0"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  tmp[j] += j;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for map(tofrom : tmp)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/offloading/parallel_offloading_map/1"}
{"code": "for (; i < (N * 2); i += incX + 2)\n{\n  temp->REEL = temp->REEL + (((*(XP + i)) * (*(YP + i))) - ((0 - (*((XP + i) + 1))) * (*((YP + i) + 1))));\n  temp->IMAG = temp->IMAG + (((*(XP + i)) * (*((YP + i) + 1))) + ((0 - (*((XP + i) + 1))) * (*(YP + i))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/dot/10"}
{"code": "for (int i = first; i < end; i++)\n{\n  for (int j = 0; j < 800; j++)\n  {\n    neuron[0][i].charge += start[i][j] * input[j];\n  }\n\n  neuron[0][i].active = tanh(neuron[0][i].charge);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_mpi_omp/0"}
{"code": "for (int currentRow = 0; currentRow < totalRows; ++currentRow)\n{\n  for (int currentColumn = 0; currentColumn < totalColumns; ++currentColumn)\n  {\n    printf(\"%.1f\\t\", grid[currentRow][currentColumn]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"fib(%d) = %llu\\n\", i, fib(i));\n}\n\n", "pragma": "omp for ordered schedule(static,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_8/Ejercicio_1/fibonacci_openmp/0"}
{"code": "for (i = 0; i < array_length; i++)\n{\n  if (((((*(r + i)) > (r_inj - (C_LIGHT / fps))) && ((*(r + i)) < (r_inj + (C_LIGHT / fps)))) && ((*(theta + i)) < theta_max)) && ((*(theta + i)) > theta_min))\n  {\n    block_cnt++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/7"}
{"code": "for (int i = 500051; i < 500060; i++)\n{\n  (cout << C1[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nghialuffy/OpenMP-Exercises/Bai5/Bai5/2"}
{"code": "for (unsigned int i = 0; i < (pi.num_total_phys_cores * num_iterations); ++i)\n{\n  bench_code();\n}\n\n", "pragma": "  #pragma omp parallel for num_threads(pi.num_total_phys_cores) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/12"}
{"code": "for (int i = 0; i < points.size(); i++)\n{\n  if ((i % 1000) == 0)\n    ((cout << \"** \") << i) << \" \";\n\n  adjPoints[i] = tree.neighborhood_indices(points[i], eps);\n}\n\n", "pragma": "          #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1998/parallel-DBSCAN/src/rangeSearch/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/argha072k/openmp/array1/0"}
{"code": "for (i = 0; i < 16; i = j + i)\n  for (j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/33"}
{"code": "for (j = 1; j <= imax; j++)\n{\n  A[j] = A[m + j];\n  A[((n - 1) * m) + j] = A[((n - 2) * m) + j];\n}\n\n", "pragma": "omp for nowait private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlessandroPiccolo/poisson-openmp-solver/source/poisson_parallel/3"}
{"code": "for (i = 1; i < nr_class; i++)\n  start[i] = start[i - 1] + count[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/50"}
{"code": "for (int i = 1; i < (HEIGHT - 1); i++)\n{\n  for (int j = 1; j < (WIDTH - 1); j++)\n  {\n    field_backup[i][j] = (((field[i + 1][j] + field[i - 1][j]) + field[i][j + 1]) + field[i][j - 1]) * ((float) 0.25);\n  }\n\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/0"}
{"code": "for (size_t i = 5 * round(size / 8); i < (6 * round(size / 8)); i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  sum = sum + max_;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/5/5/Source/11"}
{"code": "for (i = sqrt_of_proc; i < comm_sz; i++)\n{\n  if ((comm_sz % i) == 0)\n  {\n    dim_size[0] = i;\n    dim_size[1] = comm_sz / i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TeodStm/Parallel-Prog-Mpi-OpenMP/mpi_omp_hybrid/3"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    frct[i][j][k][m] = frct[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/46"}
{"code": "for (; i < 1000000; i++)\n{\n  arr[i] = randLim();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio8/ejercicio8Paralelo/5"}
{"code": "for (int i = 0; i < listacentroidi.size(); ++i)\n{\n  for (int j = 0; j < punti.at(0).getCoordinate()->size(); ++j)\n  {\n    int count = 0;\n    float sum = 0.0;\n    for (int l = 0; l < punti.size(); ++l)\n    {\n      if (punti.at(l).getClusterAppartenenza() == i)\n      {\n        sum = sum + punti.at(l).getCoordinate()->at(j);\n        count = count + 1;\n      }\n\n    }\n\n    newlistacentroidi.at(i).getCoordinate()->at(j) = sum / count;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/francescobongini/Kmeans/Kmeans/Kmeans/3"}
{"code": "for (size_t i = network.size() - 2; i != (-1); i--)\n{\n  network[i].grad += (error * network[i].act_val.transpose()) / _data_quantity;\n  error = ((network[i].theta.transpose() * error).tail(network[i].z.size()).array() * network[i].sigmoid_derivative().array()).matrix().eval();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatheusNBDG/Neural-Network/network/1"}
{"code": "for (r = 0; r < nr; r++)\n{\n  for (c = 0; c < nc; c++)\n  {\n    MATRIX_RECT(second, r, c) = MATRIX_RECT(first, r, c);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/life/0"}
{"code": "for (int i = baz(&i); i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/44"}
{"code": "for (int ii = 0; ii < (params.nx * params.ny); ii++)\n  if (!obstacles[ii])\n  ++tot_cells;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/openmp/d2q9-bgk/4"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < q; j++)\n  {\n    sum = 0;\n    for (k = 0; k < p; k++)\n      sum += first[i][k] * second[k][j];\n\n    product[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,sum) shared(first,second,product)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/husainhz7/Parallel-OpenMP-PrefixScan-MatrixMult/parallel_matrix/0"}
{"code": "for (i = 0; i < (x + y); i = i + 2)\n{\n  if (c[i] != (2 * i))\n    abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_for_03/3"}
{"code": "for (j = 1; j < 512; j++)\n  A[i][j] = A[i - 1][j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab5_OpenMP/Test2_WaveFront_Macropipeline/bucles/0"}
{"code": "for (k = 0; k < ny; k++)\n{\n  for (j = 0; j < nxs; j += 4)\n  {\n    _mm512_mask_store_ps(&fxyz[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)], _mm512_int2mask(30583), _mm512_load_ps(&fxyz[(4 * j) + ((4 * nxe) * k)]));\n  }\n\n  for (j = nxs; j < nx; j++)\n  {\n    fxyz[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[(4 * j) + ((4 * nxe) * k)];\n    fxyz[((1 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[(1 + (4 * j)) + ((4 * nxe) * k)];\n    fxyz[((2 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[(2 + (4 * j)) + ((4 * nxe) * k)];\n  }\n\n  fxyz[((4 * nx) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[(4 * nxe) * k];\n  fxyz[((1 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[1 + ((4 * nxe) * k)];\n  fxyz[((2 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)] = fxyz[2 + ((4 * nxe) * k)];\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/10"}
{"code": "for (i = 0; i < tamanho; i++)\n  bucket[(vetor[i] / exp) % 10]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/radixsort/8"}
{"code": "for (i = 1; i < (Nx - 1); ++i)\n  for (j = 1; j < (Ny - 1); ++j)\n  un[i][j] = (((u[i][j] + ((((dt * x[i]) * (Lx - x[i])) * y[j]) * (Ly - y[j]))) + ((0.5 * cx2) * ((u[i - 1][j] - (2 * u[i][j])) + u[i + 1][j]))) + ((0.5 * cy2) * ((u[i][j - 1] - (2 * u[i][j])) + u[i][j + 1]))) + ((((((0.5 * dt2) * 2) * c) * c) * (1 + (t / 2))) * ((y[j] * (Ly - y[j])) + (x[i] * (Lx - x[i]))));\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/set/2020/exercise2/5"}
{"code": "for (i = 0; i < size; i++)\n  distance += (point1[i] - point2[i]) * (point1[i] - point2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/KmeansParallel/2"}
{"code": "for (i = high - 1; i > low; i--)\n{\n  j = perm[i];\n  for (k = i + 1; k <= high; k++)\n    h[k][i] = mat[k][i - 1];\n\n  if (i != j)\n  {\n    for (k = i; k <= high; k++)\n    {\n      h[i][k] = h[j][k];\n      h[j][k] = 0.;\n    }\n\n    h[j][i] = 1.;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/14"}
{"code": "for (j = 0; j < LOOPCOUNT; ++j)\n{\n  logic_and = logic_and && logics[j];\n}\n\n", "pragma": "omp for schedule(dynamic, 1) reduction(&& : logic_and)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_for_reduction/2"}
{"code": "for (size_t i = 0; i < t_val_size; ++i)\n{\n  temporary_layers_values[i].resize(weights_layout[i]);\n}\n\n", "pragma": "  #pragma omp parallel for if (t_val_size > 100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Networks/MLP/0"}
{"code": "for (size_t j = 0; j < array_count; j++)\n  printf(\"%zu, \", steps[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Python-for-HPC/numbaWithOpenmp/numba/np/ufunc/omppool/1"}
{"code": "for (int i = 0; i < processors.size(); i++)\n{\n  ((cout << \"Proc \") << processors[i].toString()) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/5"}
{"code": "for (chunk = 0; chunk < strLen; chunk += chunkSize)\n{\n  for (size_t patt = 0; patt < pattCnt; patt++)\n  {\n    uint8_t *pattern = (uint8_t *) patterns[patt].c_str();\n    size_t pattLen = patterns[patt].length();\n    size_t chunkEnd = min(chunkSize + pattLen, strLen - chunk);\n    const uint8_t *textChunked = text + chunk;\n    computeShifts(pattern, pattLen, shifts);\n    int shift = 0;\n    for (size_t index = 0; index <= chunkEnd; index++)\n    {\n      while ((shift > (-1)) && (pattern[shift] != textChunked[index]))\n      {\n        shift = shifts[shift];\n        INS(2);\n      }\n\n      shift++;\n      INS(3);\n      if (shift >= pattLen)\n      {\n        shift = shifts[pattLen];\n        cnt++;\n        INS(2);\n        KMP_RES((index - pattLen) + 1);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/holoubekm/BI-EIA/semestral_work/parallel/new_chunked_parallel/1"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n    }\n\n  }\n\n  L2 = ny - 1;\n  for (j = jst; j <= L2; j++)\n  {\n    tmp = 1.0 / u[i][j][k][0];\n    u21j = tmp * u[i][j][k][1];\n    u31j = tmp * u[i][j][k][2];\n    u41j = tmp * u[i][j][k][3];\n    u51j = tmp * u[i][j][k][4];\n    tmp = 1.0 / u[i][j - 1][k][0];\n    u21jm1 = tmp * u[i][j - 1][k][1];\n    u31jm1 = tmp * u[i][j - 1][k][2];\n    u41jm1 = tmp * u[i][j - 1][k][3];\n    u51jm1 = tmp * u[i][j - 1][k][4];\n    flux[i][j][k][1] = ty3 * (u21j - u21jm1);\n    flux[i][j][k][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n    flux[i][j][k][3] = ty3 * (u41j - u41jm1);\n    flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * (((pow2(u21j) + pow2(u31j)) + pow2(u41j)) - ((pow2(u21jm1) + pow2(u31jm1)) + pow2(u41jm1)))) + (((1.0 / 6.0) * ty3) * (pow2(u31j) - pow2(u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n  }\n\n  for (j = jst; j <= jend; j++)\n  {\n    rsd[i][j][k][0] = rsd[i][j][k][0] + ((dy1 * ty1) * ((u[i][j - 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j + 1][k][0]));\n    rsd[i][j][k][1] = (rsd[i][j][k][1] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][1] - flux[i][j][k][1]))) + ((dy2 * ty1) * ((u[i][j - 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j + 1][k][1]));\n    rsd[i][j][k][2] = (rsd[i][j][k][2] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][2] - flux[i][j][k][2]))) + ((dy3 * ty1) * ((u[i][j - 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j + 1][k][2]));\n    rsd[i][j][k][3] = (rsd[i][j][k][3] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][3] - flux[i][j][k][3]))) + ((dy4 * ty1) * ((u[i][j - 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j + 1][k][3]));\n    rsd[i][j][k][4] = (rsd[i][j][k][4] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][4] - flux[i][j][k][4]))) + ((dy5 * ty1) * ((u[i][j - 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j + 1][k][4]));\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][1][k][m] = rsd[i][1][k][m] - (dssp * ((((+5.0) * u[i][1][k][m]) - (4.0 * u[i][2][k][m])) + u[i][3][k][m]));\n    rsd[i][2][k][m] = rsd[i][2][k][m] - (dssp * (((((-4.0) * u[i][1][k][m]) + (6.0 * u[i][2][k][m])) - (4.0 * u[i][3][k][m])) + u[i][4][k][m]));\n  }\n\n  jst1 = 3;\n  jend1 = ny - 4;\n  for (j = jst1; j <= jend1; j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n    }\n\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][ny - 3][k][m] = rsd[i][ny - 3][k][m] - (dssp * (((u[i][ny - 5][k][m] - (4.0 * u[i][ny - 4][k][m])) + (6.0 * u[i][ny - 3][k][m])) - (4.0 * u[i][ny - 2][k][m])));\n    rsd[i][ny - 2][k][m] = rsd[i][ny - 2][k][m] - (dssp * ((u[i][ny - 4][k][m] - (4.0 * u[i][ny - 3][k][m])) + (5.0 * u[i][ny - 2][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,m ,j ,ist ,k ,u21j ,u31j ,u41j ,u51j ,tmp ,u21jm1 ,u31jm1 ,u41jm1 ,u51jm1 ,ty2 ,jst ,jend ,ty3 ,L2 ,ty1 ,dy1 ,dy2 ,dy3 ,dy4 ,dy5 ,dssp ,ny ,nz ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/78"}
{"code": "for (unsigned int i = 0; i < ids_to_remove.size(); ++i)\n{\n  mOriginInletSubmodelPartIndexes.erase(ids_to_remove[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/inlet/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = -1;\n  b[i] = i;\n  c[i] = 2 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/3"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if ((halosize != 0) && (i == haloposition))\n    *position = ftell(*fp);\n\n  fscanf(*fp, \"%d %d %d \", &img->R[i], &img->G[i], &img->B[i]);\n  k++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/malerax213/OpenMP-Project/convolution/1"}
{"code": "for (int i = 1; i <= Matrix->nb_rows; i++)\n{\n  for (int j = 1; j <= Matrix->nb_cols; j++)\n  {\n    printf(\"%d\", getElemFromMatrix(i, j, Matrix));\n    if (j <= (Matrix->nb_cols - 1))\n    {\n      printf(\" \");\n    }\n\n  }\n\n  if (i != Matrix->nb_rows)\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/11"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm512_set1_epi32(noff);\n  v_moff = _mm512_set1_epi32(moff);\n  v_loff = _mm512_set1_epi32(loff);\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  v_edgelx = _mm512_set1_ps(edgelx);\n  v_edgely = _mm512_set1_ps(edgely);\n  v_edgelz = _mm512_set1_ps(edgelz);\n  v_edgerx = _mm512_set1_ps(edgerx);\n  v_edgery = _mm512_set1_ps(edgery);\n  v_edgerz = _mm512_set1_ps(edgerz);\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  nps = 4 * (nn / 4);\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &fxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &fxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sfxyz[m], v_at);\n        _mm512_packstorehi_ps(&sfxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &bxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &bxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sbxyz[m], v_at);\n        _mm512_packstorehi_ps(&sbxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  memset((void *) (&ncl[26 * l]), 0, 26 * (sizeof(int)));\n  nps = 16 * (npp / 16);\n  sum1 = 0.0;\n  v_sum1 = _mm512_set1_pd(0.0);\n  for (j = 0; j < nps; j += 16)\n  {\n    v_x = _mm512_load_ps(&ppart[j + npoff]);\n    v_y = _mm512_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_z = _mm512_load_ps(&ppart[(j + (2 * nppmx)) + npoff]);\n    v_nn = _mm512_cvtfxpnt_round_adjustps_epi32(v_x, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_mm = _mm512_cvtfxpnt_round_adjustps_epi32(v_y, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_ll = _mm512_cvtfxpnt_round_adjustps_epi32(v_z, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_nn, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_sub_ps(v_x, v_dxp);\n    v_dyp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_mm, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dyp = _mm512_sub_ps(v_y, v_dyp);\n    v_dzp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_ll, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dzp = _mm512_sub_ps(v_z, v_dzp);\n    v_nn = _mm512_sub_epi32(v_nn, v_noff);\n    v_mm = _mm512_sub_epi32(v_mm, v_moff);\n    v_ll = _mm512_sub_epi32(v_ll, v_loff);\n    v_it = _mm512_mullo_epi32(v_mxyv4, v_ll);\n    v_it = _mm512_add_epi32(v_it, _mm512_mullo_epi32(v_mxv4, v_mm));\n    v_nm = _mm512_add_epi32(_mm512_slli_epi32(v_nn, 2), v_it);\n    v_amx = _mm512_sub_ps(v_one, v_dxp);\n    v_amy = _mm512_sub_ps(v_one, v_dyp);\n    v_amz = _mm512_sub_ps(v_one, v_dzp);\n    v_dx1 = _mm512_mul_ps(v_dxp, v_dyp);\n    v_dyp = _mm512_mul_ps(v_amx, v_dyp);\n    v_amx = _mm512_mul_ps(v_amx, v_amy);\n    v_amy = _mm512_mul_ps(v_dxp, v_amy);\n    _mm512_store_epi32(kk, v_nm);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_mul_ps(v_amx, a);\n    v_dx = _mm512_fmadd_ps(v_amy, p, v_dx);\n    v_dy = _mm512_mul_ps(v_amx, b);\n    v_dy = _mm512_fmadd_ps(v_amy, q, v_dy);\n    v_dz = _mm512_mul_ps(v_amx, c);\n    v_dz = _mm512_fmadd_ps(v_amy, r, v_dz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_fmadd_ps(v_dyp, a, v_dx);\n    v_dx = _mm512_fmadd_ps(v_dx1, p, v_dx);\n    v_dx = _mm512_mul_ps(v_amz, v_dx);\n    v_dy = _mm512_fmadd_ps(v_dyp, b, v_dy);\n    v_dy = _mm512_fmadd_ps(v_dx1, q, v_dy);\n    v_dy = _mm512_mul_ps(v_amz, v_dy);\n    v_dz = _mm512_fmadd_ps(v_dyp, c, v_dz);\n    v_dz = _mm512_fmadd_ps(v_dx1, r, v_dz);\n    v_dz = _mm512_mul_ps(v_amz, v_dz);\n    v_nn = _mm512_add_epi32(v_nm, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_dx = _mm512_fmadd_ps(v_dzp, v_vx, v_dx);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_dy = _mm512_fmadd_ps(v_dzp, v_vy, v_dy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_dz = _mm512_fmadd_ps(v_dzp, v_vz, v_dz);\n    _mm512_store_epi32(kk, v_nm);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_ox = _mm512_mul_ps(v_amx, a);\n    v_ox = _mm512_fmadd_ps(v_amy, p, v_ox);\n    v_oy = _mm512_mul_ps(v_amx, b);\n    v_oy = _mm512_fmadd_ps(v_amy, q, v_oy);\n    v_oz = _mm512_mul_ps(v_amx, c);\n    v_oz = _mm512_fmadd_ps(v_amy, r, v_oz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_ox = _mm512_fmadd_ps(v_dyp, a, v_ox);\n    v_ox = _mm512_fmadd_ps(v_dx1, p, v_ox);\n    v_ox = _mm512_mul_ps(v_amz, v_ox);\n    v_oy = _mm512_fmadd_ps(v_dyp, b, v_oy);\n    v_oy = _mm512_fmadd_ps(v_dx1, q, v_oy);\n    v_oy = _mm512_mul_ps(v_amz, v_oy);\n    v_oz = _mm512_fmadd_ps(v_dyp, c, v_oz);\n    v_oz = _mm512_fmadd_ps(v_dx1, r, v_oz);\n    v_oz = _mm512_mul_ps(v_amz, v_oz);\n    v_nn = _mm512_add_epi32(v_nm, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_ox = _mm512_fmadd_ps(v_dzp, v_vx, v_ox);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_oy = _mm512_fmadd_ps(v_dzp, v_vy, v_oy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_oz = _mm512_fmadd_ps(v_dzp, v_vz, v_oz);\n    v_dx = _mm512_mul_ps(v_dx, v_qtmh);\n    v_dy = _mm512_mul_ps(v_dy, v_qtmh);\n    v_dz = _mm512_mul_ps(v_dz, v_qtmh);\n    a = _mm512_add_ps(v_dx, _mm512_load_ps(&ppart[(j + (3 * nppmx)) + npoff]));\n    b = _mm512_add_ps(v_dy, _mm512_load_ps(&ppart[(j + (4 * nppmx)) + npoff]));\n    c = _mm512_add_ps(v_dz, _mm512_load_ps(&ppart[(j + (5 * nppmx)) + npoff]));\n    v_at = _mm512_fmadd_ps(b, b, _mm512_mul_ps(a, a));\n    v_at = _mm512_fmadd_ps(c, c, v_at);\n    v_sum1 = _mm512_add_pd(v_sum1, _mm512_cvtpslo_pd(v_at));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_at, 78));\n    v_sum1 = _mm512_add_pd(v_sum1, v_d);\n    e = _mm512_mul_ps(v_qtmh, v_ox);\n    f = _mm512_mul_ps(v_qtmh, v_oy);\n    g = _mm512_mul_ps(v_qtmh, v_oz);\n    v_vx = _mm512_mul_ps(e, e);\n    v_vy = _mm512_mul_ps(f, f);\n    v_vz = _mm512_mul_ps(g, g);\n    v_at = _mm512_add_ps(_mm512_add_ps(v_vx, v_vy), v_vz);\n    d = _mm512_div_ps(v_two, _mm512_add_ps(v_one, v_at));\n    h = _mm512_mul_ps(v_half, _mm512_sub_ps(v_one, v_at));\n    v_vx = _mm512_mul_ps(_mm512_add_ps(h, v_vx), a);\n    v_vy = _mm512_mul_ps(_mm512_add_ps(h, v_vy), b);\n    v_vz = _mm512_mul_ps(_mm512_add_ps(h, v_vz), c);\n    h = _mm512_mul_ps(e, f);\n    v_vx = _mm512_fmadd_ps(_mm512_add_ps(h, g), b, v_vx);\n    v_vy = _mm512_fmadd_ps(_mm512_sub_ps(h, g), a, v_vy);\n    h = _mm512_mul_ps(e, g);\n    v_vx = _mm512_fmadd_ps(_mm512_sub_ps(h, f), c, v_vx);\n    v_vz = _mm512_fmadd_ps(_mm512_add_ps(h, f), a, v_vz);\n    h = _mm512_mul_ps(f, g);\n    v_vy = _mm512_fmadd_ps(_mm512_add_ps(h, e), c, v_vy);\n    v_vz = _mm512_fmadd_ps(_mm512_sub_ps(h, e), b, v_vz);\n    v_vx = _mm512_fmadd_ps(v_vx, d, v_dx);\n    v_vy = _mm512_fmadd_ps(v_vy, d, v_dy);\n    v_vz = _mm512_fmadd_ps(v_vz, d, v_dz);\n    v_dx = _mm512_fmadd_ps(v_vx, v_dtc, v_x);\n    v_dy = _mm512_fmadd_ps(v_vy, v_dtc, v_y);\n    v_dz = _mm512_fmadd_ps(v_vz, v_dtc, v_z);\n    v_mm = _mm512_setzero_epi32();\n    msk1 = _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dx;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_1, v_1);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dx, v_anx, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dx, v_anx);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_1);\n        msk2 = _mm512_cmp_ps_mask(v_dx, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dx, v_anx);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anx, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dy;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_3, v_3);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dy, v_any, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dy, v_any);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_3);\n        msk2 = _mm512_cmp_ps_mask(v_dy, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dy, v_any);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_any, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dz;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_9, v_9);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dz, v_anz, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dz, v_anz);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_9);\n        msk2 = _mm512_cmp_ps_mask(v_dz, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dz, v_anz);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anz, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n    }\n\n    _mm512_store_ps(&ppart[j + npoff], v_dx);\n    _mm512_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm512_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_dz);\n    _mm512_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vx);\n    _mm512_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vy);\n    _mm512_store_ps(&ppart[(j + (5 * nppmx)) + npoff], v_vz);\n    _mm512_store_epi32(kk, v_mm);\n    for (i = 0; i < 16; i++)\n    {\n      mm = kk[i];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + i) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = dx + ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm);\n    vy = dy + ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm);\n    vz = dz + ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm);\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    dz = z + (vz * dtc);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  _mm512_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,ii,noff,moff,loff,npp,npoff,nps,nn,mm,ll,nm,ih,nh,x, y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz, omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, edgelx,edgely,edgelz,edgerx,edgery,edgerz,sum1,v_noff,v_moff,v_loff, v_nn,v_mm,v_ll,v_nm,v_it,v_x,v_y,v_z,v_dxp,v_dyp,v_dzp,v_amx,v_amy, v_amz,v_dx1,v_dx,v_dy,v_dz,v_vx,v_vy,v_vz,v_ox,v_oy,v_oz,v_at,v_edgelx, v_edgely,v_edgelz,v_edgerx,v_edgery,v_edgerz,v_d,v_sum1,a,b,c,d,e,f,g, h,p,q,r,s,msk1,msk2,kk,dd,sfxyz,sbxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/1"}
{"code": "for (int i = 0; i < N; i++)\n  fscanf(in, \"%d\", &xvals[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/leader_elect_dp/4"}
{"code": "for (int i = 0; i < nrOfIds; i++)\n{\n  dealloc_2d_matrix(training_set[i], nrOfPhotosPerId, 256);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/7"}
{"code": "for (int row = 0; row < dim_y; row++)\n{\n  for (int col = 0; col < dim_x; col++)\n  {\n    fprintf(outputCost, \"%d \", costs->board[(row * dim_y) + col].val);\n  }\n\n  fprintf(outputCost, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/9"}
{"code": "for (int i = 0; i < ROWS_A; i++)\n  for (int k = 0; k < COLUMNS_A; k++)\n  for (int j = 0; j < COLUMNS_B; j++)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/p3732/HybridModelsOnClusters/MM_OpenMp/1"}
{"code": "for (int i = 0; i < (img->x * img->y); i++)\n{\n  float newColor = ((img->data[i].red * 0.21) + (img->data[i].green * 0.72)) + (img->data[i].blue * 0.07);\n  img->data[i].red = newColor;\n  img->data[i].green = newColor;\n  img->data[i].blue = newColor;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YKakdas/Sobel-Filter-Serial-and-OpenMP-Parallel/SobelFilter/0"}
{"code": "for (i = 1; i < n_clusters; i++)\n  clusters[i] = clusters[i - 1] + n_coords;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreP-git/Kmeans-OpenMP/kmeans/3"}
{"code": "for (int x = 0; x < Lx; x++)\n  for (int y = 0; y < Ly; y++)\n  if (norm[(x * Ly) + y] != 0)\n  img[(x * Ly) + y] /= norm[(x * Ly) + y];\n\n\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/asmooth-omp/main/1"}
{"code": "for (int c_out = last_chunk_idx + 1; c_out < node->num_classes; ++c_out)\n{\n  float tmp_logit = node->hidden[c_in] * weight_2[(c_in * node->num_classes) + c_out];\n  node->tmp_logits[c_out] += tmp_logit;\n  chunk_tmp_logits[((n - start) * node->num_classes) + c_out] += tmp_logit;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_hybrid-simd/5"}
{"code": "for (int chunk = 0; chunk < actual_num_workers; chunk++)\n{\n  for (uint64_t i = 0; i < BUCKET_WIDTH; ++i)\n  {\n    bucket_size_test += my_local_key_counts[chunk][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/17"}
{"code": "for (; j > 16; j--)\n{\n  t0 = block0[(p0 - x[0].c) - 16] ^ lotus_magic_table[j + t0];\n  t1 = block1[(p1 - x[1].c) - 16] ^ lotus_magic_table[j + t1];\n  t2 = block2[(p2 - x[2].c) - 16] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/8"}
{"code": "for (i = 2; i < limit; i++)\n  z += primes[i];\n\n", "pragma": "omp parallel for reduction (+ : z)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/criba-paralela/3"}
{"code": "for (long i = 0; i < n; i++)\n{\n  a[i] = rand() % 10;\n  b[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/agdhruv/omp-parallel/addition/1"}
{"code": "for (int k = 0; k < nthreads; ++k)\n{\n  resultLongestIndex[k] = 0;\n  resultMaxLength[k] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/robert-preissl/palindrome-substring-omp/src/omp/PalindromeSubstring_omp/0"}
{"code": "for (int i = 0; i < to_recv; ++i)\n{\n  rc = lodepng_decode32((*images) + i, &(*widths)[i], &(*heights)[i], encoded_images[i], encoded_images_sz[i]);\n  if (rc)\n  {\n    printf(\"decode error: %s\\n\", lodepng_error_text(rc));\n  }\n\n}\n\n", "pragma": "omp parallel for shared(encoded_images, encoded_images_sz, images, widths, heights, number_of_images) private(rc)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/0"}
{"code": "for (i = 2; i < (7 - 2); i++)\n{\n  s = s + exps[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/bubble/1"}
{"code": "for (k = 0; k < N; k++)\n{\n  for (i = start_i; i <= end_i; i++)\n  {\n    for (j = 0; j < N; j++)\n    {\n      int sum = (*dist)[i][k] + (*dist)[k][j];\n      (*dist)[i][j] = (sum < (*dist)[i][j]) ? (sum) : ((*dist)[i][j]);\n    }\n\n  }\n\n  pthread_barrier_wait(&bar);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/6"}
{"code": "for (i = 0; i < size; i++)\n  a[i] = (float) (i + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw3/swap/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int m = 0; m < 256; ++m)\n  {\n    mean[i].elements[m] = tep[i].elements[m] / (count1[i] * 100000);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+kmeans/1"}
{"code": "for (int i = 0; i < num; i++)\n  myabs_and_input_list.push_back(make_pair(fabs(temp_input[i] - mean), temp_input[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/1"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if ((l3[rowcol] == 0) || (l3[rowcol] == 1))\n    lOut[rowcol] = l2[rowcol];\n  else\n    if (l2[rowcol] == (-3000))\n    lOut[rowcol] = -28768;\n  else\n    lOut[rowcol] = -28768;\n\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol) shared (N, l2, l3, lOut)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_NDVI/ndvi/0"}
{"code": "for (j = 0; j < A->cols; ++j)\n{\n  for (i = 0; i < A->rows; ++i)\n  {\n    switch (op)\n    {\n      case '+':\n        A->data[midx(A, i, j)] += get(B, i, j);\n        break;\n\n      case '-':\n        A->data[midx(A, i, j)] -= get(B, i, j);\n        break;\n\n      case '*':\n        A->data[midx(A, i, j)] *= get(B, i, j);\n        break;\n\n      case '/':\n        A->data[midx(A, i, j)] /= get(B, i, j) + 1e-6;\n        break;\n\n      default:\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vuvko/nmf_mpi/common/matrix/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  int plen = strlen(saved_key[index]);\n  unsigned char key[64];\n  unsigned char out[64];\n  if (cur_salt->type == 1)\n  {\n    SHA_CTX ctx;\n    if (plen < 20)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 20 - plen);\n    }\n    else\n      if (plen == 20)\n    {\n      memcpy(key, saved_key[index], 20);\n    }\n    else\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, saved_key[index], plen);\n      SHA1_Final(key, &ctx);\n    }\n\n\n    hmac_sha1(key, 20, cur_salt->salt, cur_salt->salt_length + 20, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    SHA256_CTX ctx;\n    if (plen < 32)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 32 - plen);\n    }\n    else\n      if (plen == 32)\n    {\n      memcpy(key, saved_key[index], 32);\n    }\n    else\n    {\n      SHA256_Init(&ctx);\n      SHA256_Update(&ctx, saved_key[index], plen);\n      SHA256_Final(key, &ctx);\n    }\n\n\n    hmac_sha256(key, 32, cur_salt->salt, cur_salt->salt_length + 32, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    SHA512_CTX ctx;\n    if (plen < 48)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 48 - plen);\n    }\n    else\n      if (plen == 48)\n    {\n      memcpy(key, saved_key[index], 48);\n    }\n    else\n    {\n      SHA384_Init(&ctx);\n      SHA384_Update(&ctx, saved_key[index], plen);\n      SHA384_Final(key, &ctx);\n    }\n\n\n    hmac_sha384(key, 48, cur_salt->salt, cur_salt->salt_length + 48, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 4)\n  {\n    SHA512_CTX ctx;\n    if (plen < 64)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 64 - plen);\n    }\n    else\n      if (plen == 64)\n    {\n      memcpy(key, saved_key[index], 64);\n    }\n    else\n    {\n      SHA512_Init(&ctx);\n      SHA512_Update(&ctx, saved_key[index], plen);\n      SHA512_Final(key, &ctx);\n    }\n\n\n    hmac_sha512(key, 64, cur_salt->salt, cur_salt->salt_length + 64, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ospf_fmt_plug/0"}
{"code": "for (; (last_i + 7) < n; last_i += 8)\n{\n  _mm256_store_ps(&y[last_i + 0], _mm256_load_ps(&x[last_i + 0]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/17"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  qa = mod11A1a(l3[rowcol]);\n  if ((qa == 0) || (qa == 1))\n    lOut[rowcol] = (l2[rowcol] * 0.02) + (0.00627 * l1[rowcol]);\n  else\n    lOut[rowcol] = -28768;\n\n}\n\n", "pragma": "omp parallel for default (none) private (rowcol, qa) shared (N, l1, l2, l3, lOut)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_T0Dem/t0dem/0"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  for (j = 0; j < 10; ++j)\n  {\n    int pos = (i * 10) + j;\n    printf(\"[%d,%d] = %d\\t\", i, j, S[pos]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_multi_matrices/main/2"}
{"code": "for (int iBox = 0; iBox < s->boxes->nLocalBoxes; ++iBox)\n{\n  for (int iOff = MAXATOMS * iBox, ii = 0; ii < s->boxes->nAtoms[iBox]; ++ii, ++iOff)\n  {\n    int iSpecies = s->atoms->iSpecies[iOff];\n    real_t mass = s->species[iSpecies].mass;\n    s->atoms->p[iOff][0] += mass * vShift[0];\n    s->atoms->p[iOff][1] += mass * vShift[1];\n    s->atoms->p[iOff][2] += mass * vShift[2];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/initAtoms/0"}
{"code": "for (int f = 0; f < iters; ++f)\n{\n  for (int j = 0; j < thread_per_bitbucket; ++j)\n  {\n    joffset = j * stop;\n    for (i = 0; i < stop; ++i)\n    {\n      if (j == 0)\n        vertex_count[f][i] = vertex_count_tmp[f][i];\n      else\n        vertex_count[f][i] += vertex_count_tmp[f][i + joffset];\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(vertex_count, vertex_count_tmp) private(joffset, i) schedule(static) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/2"}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = 0.0;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_BLAS/1"}
{"code": "for (uint b = 0; b < count; ++b)\n{\n  if (bondExist[b])\n  {\n    energy += forcefield.bonds.Calc(molKind.bondList.kinds[b], vecs.Get(b).Length());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/7"}
{"code": "for (i = ((-0x7fffffff) - 1) + 6; i == ((-0x7fffffff) - 1); i--)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-2/1"}
{"code": "for (i = 0; i < ARRAY_SIZE; i++)\n{\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_array_reduction_01/1"}
{"code": "for (i = 0; i < (n * n); ++i)\n  A[i] = (B[i] = i % 100);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex4-matrix-multi-openmp/1"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  my_scratch[0] += i + 1;\n}\n\n", "pragma": "#pragma omp for reduction(+ : my_scratch [0:1])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rgayatri23/OpenMPTargetTestCases/Reduction/TestRedn/0"}
{"code": "for (int i = 0; i < (query_word_num - 1); i++)\n{\n  for (int j = i + 1; j < query_word_num; j++)\n  {\n    if (queried_posting_list[sorted_index[i]].len > queried_posting_list[sorted_index[j]].len)\n    {\n      int temp = sorted_index[i];\n      sorted_index[i] = sorted_index[j];\n      sorted_index[j] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lunaticsky-tql/openMP/openMP_parallel/openMP_block_task/1"}
{"code": "for (int i = 0 + ((for_param.thread_id_ * (bar - 0)) / for_param.num_threads_); i < (0 + (((for_param.thread_id_ + 1) * (bar - 0)) / for_param.num_threads_)); i++)\n{\n  sleep(1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/thesis_test/omp_test_transformed/0"}
{"code": "for (i = 0; i < SIZE; i++)\n  for (j = 0; j < SIZE; j++)\n  u[i][j] = a_p[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/Matrix-inverse-LUP/inverse_non_parallelized/9"}
{"code": "for (int i = 0; i < 3; i++)\n  result[i] = (double *) malloc(n * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/swag2198/Parallel-Programming/OpenMP/Rotation about arbitrary axis/16EE10056_16EE10063/7"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    averageR = 0;\n    averageG = 0;\n    averageB = 0;\n    for (int itImageX = i - (maskDimensions / 2), itMaskX = 0; (itImageX <= (i + (maskDimensions / 2))) && (itMaskX < maskDimensions); itImageX++, itMaskX++)\n    {\n      if ((itImageX >= 0) && (itImageX <= height))\n      {\n        int row = row_pointers[itImageX];\n        for (int itImageY = j - (maskDimensions / 2), itMaskY = 0; (itImageY <= (j + (maskDimensions / 2))) && (itMaskY < maskDimensions); itImageY++, itMaskY++)\n        {\n          int px = &row[itImageY * 4];\n          if ((((itImageX >= 0) && (itImageX < height)) && (itImageY >= 0)) && (itImageY < width))\n          {\n            averageR += px[0] * maskMatrix[itMaskX][itMaskY];\n            averageG += px[1] * maskMatrix[itMaskX][itMaskY];\n            averageB += px[2] * maskMatrix[itMaskX][itMaskY];\n          }\n\n        }\n\n      }\n\n    }\n\n    if ((averageR / maskD) > 255)\n      averageR = 255 * maskD;\n    else\n      if ((averageR / maskD) < 0)\n      averageR = 0;\n\n\n    maskedImageR[(i * width) + j] = averageR / maskD;\n    if ((averageG / maskD) > 255)\n      averageG = 255 * maskD;\n    else\n      if ((averageG / maskD) < 0)\n      averageG = 0;\n\n\n    maskedImageG[(i * width) + j] = averageG / maskD;\n    if ((averageB / maskD) > 255)\n      averageB = 255 * maskD;\n    else\n      if ((averageB / maskD) < 0)\n      averageB = 0;\n\n\n    maskedImageB[(i * width) + j] = averageB / maskD;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/BlurImageParallel/4"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n{\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n    for (int k = 1; k < (grid->getNZC() - 1); k++)\n  {\n    const double q = q_factor * EMf->getRHOcs(i, j, k, ns);\n    for (int ii = 0; ii < npcelx; ii++)\n      for (int jj = 0; jj < npcely; jj++)\n      for (int kk = 0; kk < npcelz; kk++)\n    {\n      double u;\n      double v;\n      double w;\n      sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n      const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n      const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n      const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n      create_new_particle(u, v, w, q, x, y, z);\n    }\n\n\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/6"}
{"code": "for (i = 0; i < 180; i++)\n  for (j = 0; j < 180; j++)\n  solution[i][j] = (sinh(((double) j) * h) * sin(((double) i) * h)) / sinh(M_PI);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_jacobi/safe_sor_jacobi_par/2"}
{"code": "for (int i = 0; i < particles.size(); ++i)\n{\n  sumForces += particles[i].force;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JuliusMbaziira/CPP-Numerical-Computing-Samples/OpenMPBenchmarksForSchedulingForceCalculations/forces_prep/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    m1[i][j] = rand() % 100;\n    m2[i][j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mahmoud-elzorkany/Open_Mp/Matrix Multiplication/Matrix Multiplication/1"}
{"code": "for (i = 0; i < used_matrix_size; i++)\n{\n  for (j = 0; j < used_matrix_size; j++)\n  {\n    matB_trans[j][i] = matB[(i * used_matrix_size) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abodh/Parallel_matrix_mutiplication/mat_mat_parallel/3"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  psum += a[i];\n  pprod = pprod * a[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Locks_critical_sections_omp-atomic/multiple_critical_sections/0"}
{"code": "for (; myxl < myxr; myxl += c_inc)\n  xticks[me].push_back(myxl);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/hw2/p2/0"}
{"code": "for (i = 0; i <= size; i++)\n{\n  if (hist[i] > 0)\n    printf(\" %d:%d\\n\", i, hist[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IdoZada/Parallel_Programs/cFunctions/5"}
{"code": "for (j = 0; j < 1; ++j)\n{\n  for (i = 0; i < 10000; ++i)\n  {\n    updatePhysics(i * 100);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MatheusDonizete/n-body-openmp/main/3"}
{"code": "for (int i = 0; i < buckets; i++)\n{\n  result.insert(result.end(), bs[0][i].begin(), bs[0][i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort2/2"}
{"code": "for (int ii = b_i; ii < GET_MIN(b_i + block_size, mat_size); ii++)\n{\n  for (int jj = b_j; jj < GET_MIN(b_j + block_size, mat_size); jj++)\n  {\n    psum = 0.0;\n    for (int kk = b_k; kk < GET_MIN(b_k + block_size, mat_size); kk++)\n    {\n      psum += A[ii][kk] * B[kk][jj];\n    }\n\n    C[ii][jj] += psum;\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/medasuryatej/advanced_parallel_computation/strassen_matmul_omp/strassen_omp_tasks/4"}
{"code": "for (int i = 0; i < result.size(); i++)\n{\n  result[i] = generateVector(cols, from, to);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/overloadedmethod/Concurrent-Viterbi-Algorithm-in-MPI-and-OpenMP/FileUtilities/5"}
{"code": "for (int i = 0; i < control; ++i)\n{\n  int *p = control_knn[i];\n  for (int j = 0; j < K; ++j)\n  {\n    p[j] = knns[i][j].key;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyandai/nndes/fvecsnndes/2"}
{"code": "for (j = eme - 2; j > 1; j--)\n{\n  z = ((((((-(h * h)) * g(x[1], y[j])) + fa(a, y[j])) + (lambda * omega[1][j + 1])) + (lambda * omega[1][j - 1])) + omega[2][j]) * mi;\n  if (fabs(omega[1][j] - z) > (*Norma))\n    *Norma = fabs(omega[1][j] - z);\n\n  omega[1][j] = z;\n  for (i = 2; i <= (ene - 2); i++)\n  {\n    z = ((((((-(h * h)) * g(x[i], y[j])) + omega[i - 1][j]) + (lambda * omega[i][j + 1])) + omega[i + 1][j]) + (lambda * omega[i][j - 1])) * mi;\n    if (fabs(omega[i][j] - z) > (*Norma))\n      *Norma = fabs(omega[i][j] - z);\n\n    omega[i][j] = z;\n  }\n\n  z = ((((((-(h * h)) * g(x[760 - 1], y[j])) + fb(b, y[j])) + omega[760 - 2][j]) + (lambda * omega[760 - 1][j + 1])) + (lambda * omega[760 - 1][j - 1])) * mi;\n  if (fabs(omega[760 - 1][j] - z) > (*Norma))\n    *Norma = fabs(omega[760 - 1][j] - z);\n\n  omega[760 - 1][j] = z;\n}\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/0"}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    lhs[n][i][j][k] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/17"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1422[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/76"}
{"code": "for (i = 0; i < 6; ++i)\n  displacements[i] -= base;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  scanf(\"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OpenMPCriticalClause/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/test30/0"}
{"code": "for (i = middle_filter; i < core_matrix; i++)\n{\n  for (j = middle_filter; j < core_matrix; j++)\n  {\n    sum = 0;\n    for (p = 0; p < s_filter; p++)\n    {\n      for (q = 0; q < s_filter; q++)\n      {\n        sum += filter[p][q] * matrix_o[(i - middle_filter) + p][(j - middle_filter) + q];\n      }\n\n    }\n\n    matrix_d[i][j] = sum / complete_filter;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ichaparroc/convolution-matrix-filter-openmp/convolution-2/0"}
{"code": "for (int n_threads = 1; n_threads <= 32; n_threads = (n_threads <= 8) ? (2 * n_threads) : (n_threads + 4))\n{\n  omp_set_num_threads(n_threads);\n  for (int i = 0; i < n_runs; ++i)\n  {\n    start_time = omp_get_wtime();\n    total_sum = omp_local_sum(x, size, n_threads);\n    times[i] = omp_get_wtime() - start_time;\n    if (abs(total_sum - warmup_sum) > 0.001)\n      printf(\"Different results in omp_local_sum with %2d threads: %f\\n\", n_threads, total_sum);\n\n  }\n\n  double avg;\n  double std_dev;\n  compute_statistics(times, n_runs, &avg, &std_dev);\n  printf(\"omp local sum (%2d threads) - Average: %fs - Std. deviation: %fs - Sum value: %f\\n\", n_threads, avg, std_dev, total_sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/9"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    fill_array3d(buffer, N, ii, 0, kk, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/smoother7p/1"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  printf(\"%d \", cityTaken[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex5/tsp5/2"}
{"code": "for (int i = 0; i < currentMatrixSize; i++)\n{\n  for (int j = 0; j < currentMatrixSize; j++)\n  {\n    B_g[(i * currentMatrixSize) + j] = B[(globalVertices[i] * originalMatrixSize) + globalVertices[j]];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/subgraph_modularity_matrix/sgmm_benchmarking/3"}
{"code": "for_environment.load_environment(for_statement)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/simd/tl-omp-simd-visitor/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  mat2[i][j] = ((rand() % 50) + (rand() % 40)) % 20;\n  printf(\"%d\\t\", mat2[i][j]);\n  if (j == (n - 1))\n    printf(\"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohit-gupta3/Parallel_and_DistributiveComputing-PDC-/Matrix_Operations/Matrix_Multiplication_OpenMp/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  nodes[i].px += nodes[i].vx * timestep;\n  nodes[i].py += nodes[i].vy * timestep;\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/parallel-processing/OpenMP-Nbody/nbody/3"}
{"code": "for (i = 1; i < Np; i++)\n{\n  double x_i = v_get_val(x, i);\n  if (x_i < min_x)\n    min_x = x_i;\n  else\n    if (x_i > max_x)\n    max_x = x_i;\n\n\n  double y_i = v_get_val(y, i);\n  if (y_i < min_y)\n    min_y = y_i;\n  else\n    if (y_i > max_y)\n    max_y = y_i;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/16"}
{"code": "for (i = 0; i < my_num_init_infected; i++)\n{\n  my_states[i] = INFECTED;\n  my_num_infected++;\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:my_num_infected)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum += arr[i];\n  prefixArray[i + 1] = sum;\n}\n\n", "pragma": "#pragma omp for schedule(static)  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhavya2711/Prefix_Sum_OpenMP/prefixsum/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrix2[i][j] = rand() % 1000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pyhro36/TD-1-OpenMP/matrice-matrice/main_mat/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src = v;\n  uint32_t dest;\n  struct AdjLinkedListNode *Nodes_out = graph->vertices[v].outNodes;\n  uint32_t degree_out = graph->vertices[v].out_degree;\n  for (j = 0; j < degree_out; j++)\n  {\n    dest = Nodes_out->dest;\n    Nodes_out = Nodes_out->next;\n    if (atomicMin(&stats->components[dest], stats->components[src]))\n    {\n      setBitAtomic(bitmapNext, dest);\n    }\n\n    if (atomicMin(&stats->components[src], stats->components[dest]))\n    {\n      setBitAtomic(bitmapNext, src);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) schedule(dynamic, 512)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/19"}
{"code": "for (i = 0; i < seqLength; ++i)\n{\n  nextHiddenState(input_t, h_tminus1, c_tminus1, hiddenSize, miniBatch, W_i_trans, W_f_trans, W_o_trans, W_g_trans, R_i_trans, R_f_trans, R_o_trans, R_g_trans);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_4_final/7"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (((((abs(PS_par[i].m - PS_seq[i].m) > 0.01) || (abs(PS_par[i].s[0] - PS_seq[i].s[0]) > 0.01)) || (abs(PS_par[i].s[1] - PS_seq[i].s[1]) > 0.01)) || (abs(PS_par[i].v[0] - PS_seq[i].v[0]) > 0.01)) || (abs(PS_par[i].v[1] - PS_seq[i].v[1]) > 0.01))\n    ok = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/n_body/1"}
{"code": "for (int i = NGHOST; i < (NX1 + NGHOST); ++i)\n{\n  for (int j = NGHOST; j < (NX2 + NGHOST); ++j)\n  {\n    RHS_RE = (((-dt) * alpha) * dummy1.LaplacianIm(idx, idy, i, j)) + ((dt * V(i, j, NX1, NX2, dx, dy, beta)) * dummy1.GetIm(i, j));\n    RHS_IM = ((dt * alpha) * dummy1.LaplacianRe(idx, idy, i, j)) - ((dt * V(i, j, NX1, NX2, dx, dy, beta)) * dummy1.GetRe(i, j));\n    dummy2.SetRe(i, j, SF.GetRe(i, j) + (0.5 * RHS_RE));\n    dummy2.SetIm(i, j, SF.GetIm(i, j) + (0.5 * RHS_IM));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rc634/Schr-OpenMP-dinger/ErwinSchrodinger/3"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  int i;\n  memcpy(BF_current.S, BF_init_state.S, sizeof(BF_current.S));\n  memcpy(BF_current.P, BF_init_key[index], sizeof(BF_current.P));\n  L0 = (R0 = 0);\n  for (i = 0; i < (16 + 2); i += 2)\n  {\n    L0 ^= salt->salt[i & 2];\n    R0 ^= salt->salt[(i & 2) + 1];\n    L0 ^= BF_current.P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current.P[16 + 1];\n    ;\n    BF_current.P[i] = L0;\n    BF_current.P[i + 1] = R0;\n  }\n\n  ptr = BF_current.S[0];\n  do\n  {\n    ptr += 4;\n    L0 ^= salt->salt[(16 + 2) & 3];\n    R0 ^= salt->salt[(16 + 3) & 3];\n    L0 ^= BF_current.P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current.P[16 + 1];\n    ;\n    *(ptr - 4) = L0;\n    *(ptr - 3) = R0;\n    L0 ^= salt->salt[(16 + 4) & 3];\n    R0 ^= salt->salt[(16 + 5) & 3];\n    L0 ^= BF_current.P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current.P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current.P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current.P[16 + 1];\n    ;\n    *(ptr - 2) = L0;\n    *(ptr - 1) = R0;\n  }\n  while (ptr < (&BF_current.S[3][0xFF]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/18"}
{"code": "for (int j = 0; j < trees; ++j)\n{\n  ProjColX.pb(tp);\n  ProjSignX.pb(tp);\n  ProjColY.pb(tp);\n  ProjSignY.pb(tp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_parallel_large/2"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  array[i] = (double) (rand() / ((double) 32767));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice9/0"}
{"code": "for (int i = M / 2; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    C[(i * N) + j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ajs7270/snu_shpc21/hw4/mat_mul/mat_mul/0"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 1); k++)\n  {\n    rho_inv = 1.0 / u[0][i][j][k];\n    rho_i[i][j][k] = rho_inv;\n    us[i][j][k] = u[1][i][j][k] * rho_inv;\n    vs[i][j][k] = u[2][i][j][k] * rho_inv;\n    ws[i][j][k] = u[3][i][j][k] * rho_inv;\n    square[i][j][k] = (0.5 * (((u[1][i][j][k] * u[1][i][j][k]) + (u[2][i][j][k] * u[2][i][j][k])) + (u[3][i][j][k] * u[3][i][j][k]))) * rho_inv;\n    qs[i][j][k] = square[i][j][k] * rho_inv;\n    aux = (c1c2 * rho_inv) * (u[4][i][j][k] - square[i][j][k]);\n    aux = sqrt(aux);\n    speed[i][j][k] = aux;\n    ainv[i][j][k] = 1.0 / aux;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,rho_inv ,aux ,c1c2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/89"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testDrand48(80000000000, i);\n  printf(\"testDrand48 | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc(), stop(), stopt() / 8e10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/3"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c[i][j] = 0.0;\n    for (k = 0; k < 1000; k++)\n    {\n      c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pavi532/Paralle-Matrix-Multiplication/Matrix_Mul_OpenMP/0"}
{"code": "for (int i = 0; i < nlevs; ++i)\n{\n  rtpop[i] = tpop[i] - ltpop[i];\n}\n\n", "pragma": "                        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ctiely/gbdt/tree/ClassificationTree/2"}
{"code": "for (int ck = 1; ck <= k; ++ck)\n{\n  cC[ck] = pC[ck - 1] + pC[ck];\n  cC[ck] %= modref;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/nCk/nCk2_par1/1"}
{"code": "for (int j = x_min - 2; j <= (x_max + 2); j++)\n{\n  cellx[FTNREF1D(j, x_min - 2)] = 0.5 * (vertexx[FTNREF1D(j, x_min - 2)] + vertexx[FTNREF1D(j + 1, x_min - 2)]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/4"}
{"code": "for (m = 0; m < 10; i++)\n  baz(m);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-11/3"}
{"code": "for (i = 2; i <= n; i++)\n{\n  int count = 0;\n  for (k = 1; k <= i; k++)\n  {\n    if ((i % k) == 0)\n    {\n      count++;\n    }\n\n  }\n\n  if (count == 2)\n  {\n    printf(\"%d  \", i);\n    temp++;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/prime/0"}
{"code": "for (int i = 0; i < (size * size); i++)\n{\n  fscanf(fp, \"%1d\", &arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/8"}
{"code": "for (int k = cont_rig; k < (factorBase.size() + 1); k++)\n{\n  if (listExponentOk_mod2[j][k] == 1)\n  {\n    for (int cc = 0; cc < contRelationOk; cc++)\n    {\n      listExponentOk_mod2[cc][k] = (listExponentOk_mod2[cc][k] + listExponentOk_mod2[cc][cont_rig - 1]) % 2;\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_gmp/3"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    rgb[i][j].rgbRed = getc(pFile);\n    rgb[i][j].rgbGreen = getc(pFile);\n    rgb[i][j].rgbBlue = getc(pFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/2/1"}
{"code": "for (int i = 0; i < array_size; ++i)\n  (cout << a[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bitonic-sort-omp/main/3"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; j++)\n  {\n    mat[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task4(a+b)/0"}
{"code": "for (int row = 0; row < rows; row++)\n{\n  for (int column = 0; column < columns; column++)\n  {\n    if (matrix[row][column] > maximum)\n    {\n      maximum = matrix[row][column];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) reduction(max:maximum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dargmuesli/parallel-processing/part-1_openmp/a_numbers/0"}
{"code": "for (ptrdiff_t i = 0; i < from.i_size_; ++i)\n{\n  for (ptrdiff_t j = 0; j < from.j_size_; ++j)\n  {\n    *((data + (i * j_cap)) + j) = from(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/23"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int state = -2;\n  int row_start = this->mat_.row_offset[i];\n  int row_end = this->mat_.row_offset[i + 1];\n  for (int j = row_start; j < row_end; j++)\n  {\n    if (cast_conn->vec_[j] == 1)\n    {\n      state = 0;\n      break;\n    }\n\n  }\n\n  unsigned int hash = i;\n  hash = ((hash >> 16) ^ hash) * 0x45d9f3b;\n  hash = ((hash >> 16) ^ hash) * 0x45d9f3b;\n  hash = (hash >> 16) ^ hash;\n  tuples[i].s = state;\n  tuples[i].v = hash;\n  tuples[i].i = i;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 1024)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/87"}
{"code": "for (i = 0; i < N; i++)\n{\n  if ((((((mat1[i] == (-28768)) || ((mat1[i] * 0.02) <= 250.0)) || ((mat1[i] * 0.02) > 365.0)) || (mat5[i] <= (-10000.0))) || (mat5[i] >= 10000.0)) || (mat5[i] == 0.0))\n  {\n    ndvi_median[i] = 99999.99;\n  }\n  else\n    if (mat5[i] < 0.0)\n  {\n    ndvi_median[i] = 99999.99;\n  }\n\n\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(N, mat1, mat5, ndvi_median)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBS/gdal_sebs_eta/1"}
{"code": "for (int i = 2; i < (number + 1); i++)\n{\n  A[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/2"}
{"code": "for (c1 = nm; c1 <= (nj + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/91"}
{"code": "for (i = id, sum[id] = 0.0; i < num_steps; i += nthrds)\n{\n  x = (i + .5) * step;\n  if ((input_x == 5) && (input_n == 0))\n    sum[id] += input_n * 1;\n  else\n    if (input_n != 0)\n  {\n    if (input_x == 1)\n      sum[id] += input_n * x;\n    else\n      if (input_x == 2)\n      sum[id] += 1 / (input_n + x);\n    else\n      if (input_x == 3)\n      sum[id] += 1 / (x - input_n);\n    else\n      if (input_x == 4)\n      sum[id] += 1 / (input_n - x);\n    else\n      if (input_x == 5)\n      sum[id] += pow(x, input_n);\n\n\n\n\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dab2013/OpenMP/OpenMP/IntroductionToOMP/0"}
{"code": "for (int i = 0; i < _num_formulas; i++)\n{\n  double value = evaluate_exptree(_formulas[i].root, &((struct measurement){.event_names = _event_names, .values = values, .time = time}));\n  if (((values == _region_values) || (values == _total_values)) && (!strncasecmp(_formulas[i].metric, \"frequency\", strlen(\"frequency\"))))\n  {\n    value /= omp_get_max_threads();\n  }\n\n  fprintf(_opt.output, \"%45s : %15.4lf [%s]\\n\", _formulas[i].metric, value, _formulas[i].unit);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/breiters/papi_omp_util/src/papi_util/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  sum += A[i] * x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/power_iteration/eigenvector_benchmarking/0"}
{"code": "for (long v = 0; v < NV; v++)\n{\n  long adj1 = vtxPtr[v];\n  long adj2 = vtxPtr[v + 1];\n  long sPosition = vtxPtr[v] + v;\n  pastCommAss[v] = v;\n  long numUniqueClusters = 0;\n  double selfLoop = 0;\n  clusterLocalMap[sPosition].cid = v;\n  clusterLocalMap[sPosition].Counter = 0;\n  numUniqueClusters++;\n  for (long j = adj1; j < adj2; j++)\n  {\n    if (vtxInd[j].tail == v)\n    {\n      selfLoop += (long) vtxInd[j].weight;\n      clusterLocalMap[sPosition].Counter = vtxInd[j].weight;\n      continue;\n    }\n\n    clusterLocalMap[sPosition + numUniqueClusters].cid = vtxInd[j].tail;\n    clusterLocalMap[sPosition + numUniqueClusters].Counter = vtxInd[j].weight;\n    numUniqueClusters++;\n  }\n\n  long maxIndex = v;\n  double curGain = 0;\n  double maxGain = 0;\n  double eix = clusterLocalMap[sPosition].Counter - selfLoop;\n  double ax = cInfo[v].degree - vDegree[v];\n  double eiy = 0;\n  double ay = 0;\n  for (long k = 0; k < numUniqueClusters; k++)\n  {\n    if (v != clusterLocalMap[sPosition + k].cid)\n    {\n      ay = cInfo[clusterLocalMap[sPosition + k].cid].degree;\n      eiy = clusterLocalMap[sPosition + k].Counter;\n      curGain = (2 * (eiy - eix)) - (((2 * vDegree[v]) * (ay - ax)) * constant);\n      if ((curGain > maxGain) || (((curGain == maxGain) && (curGain != 0)) && (clusterLocalMap[sPosition + k].cid < maxIndex)))\n      {\n        maxGain = curGain;\n        maxIndex = clusterLocalMap[sPosition + k].cid;\n      }\n\n    }\n\n  }\n\n  if (((cInfo[maxIndex].size == 1) && (cInfo[v].size == 1)) && (maxIndex > v))\n  {\n    maxIndex = v;\n  }\n\n  currCommAss[v] = maxIndex;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusteringFunctions/3"}
{"code": "for (uint32_t i = 0; i < this->rows; ++i)\n{\n  for (uint32_t j = 0; j < this->cols; ++j)\n  {\n    this->operator()(i, j) *= rhs;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/11"}
{"code": "for (c2 = 0; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/17"}
{"code": "for (i = 0; i < NV; i++)\n{\n  for (j = 0; j < NV; j++)\n  {\n    if (i == j)\n    {\n      ohd[i][i] = 0;\n    }\n    else\n    {\n      int flip = (rand() % 3) + 1;\n      if ((flip % 2) == 0)\n      {\n        ohd[i][j] = i4_huge;\n      }\n      else\n      {\n        ohd[i][j] = (rand() % 500) + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/3"}
{"code": "for (i = 0; i < ((int) distributed_particles); i++)\n{\n  if (gBestFitness == pBestFitness[i])\n    min = i;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/mpiomp/4"}
{"code": "for (int i = 0; i < arr_size; i++)\n{\n  arr[i].x = ((RAND_START + rand()) % RAND_STOP) * PRECISION;\n  arr[i].y = ((RAND_START + rand()) % RAND_STOP) * PRECISION;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ/main/0"}
{"code": "for (u = 6; u == 0; u--)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-2/5"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  a[i] = rand();\n  srand(a[i] + omp_get_thread_num());\n  b[i] = rand();\n  srand(a[i] + b[i]);\n}\n\n", "pragma": "#pragma omp for schedule(static,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task7/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  out_degree = vertices->out_degree[v];\n  if (stats->parents[v] < 0)\n  {\n    edge_idx = vertices->edges_idx[v];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      u = EXTRACT_VALUE(sorted_edges_array[j]);\n      if (getBit(bitmapCurr, u))\n      {\n        stats->parents[v] = u;\n        stats->distances[v] = stats->distances[u] + 1;\n        setBitAtomic(bitmapNext, v);\n        nf++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(j,u,v,out_degree,edge_idx) shared(stats,bitmapCurr,bitmapNext,graph,vertices,sorted_edges_array) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmph2f8og28.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/affinity/format/affinity_values/8"}
{"code": "for (n = 0; n < 500; n++)\n{\n  sum_q = 0;\n  sum_i = 0;\n  for (j = 0; j < mxg; j++)\n  {\n    fread(&aux, sizeof(float), 1, binfile);\n    sum_i += aux;\n    fread(&aux2, sizeof(float), 1, binfile);\n    sum_q += aux2;\n    g++;\n  }\n\n  sum_i = sum_i / mxg;\n  sum_q = sum_q / mxg;\n  pulso = sum_i + (sum_q * I);\n  V[n][pulsos] += pulso;\n  sum_i = 0;\n  sum_q = 0;\n  pulso = 0 + (0 * I);\n  if (g == (mxg * 500))\n  {\n    for (p = 0; p < overflow; p++)\n    {\n      fread(&aux2, sizeof(float), 1, binfile);\n      fread(&aux, sizeof(float), 1, binfile);\n      t++;\n    }\n\n    g = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FrancoRivero/Comunicacion-de-procesos-en-computacion-paralela/Multiprocesador/SO2_TP2_multiprocesador_FrancoRivero/2"}
{"code": "for (int i = 1; i < image_height; i++)\n{\n  if (current_task != order[i])\n  {\n    current_task = order[i];\n    printf(\"Task %d \u00ad-> Processing Chunk starting at Row %d\\n\", current_task, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/ImplementationA/1"}
{"code": "for (i = 0x7fffffff - 6; i <= (0x7fffffff - 1); i += 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/16"}
{"code": "for (i = 0; i < (channels * overlapLength); i += 4)\n{\n  corr += ((mixingPos[i] * compare[i]) + (mixingPos[i + 1] * compare[i + 1])) >> overlapDividerBits;\n  corr += ((mixingPos[i + 2] * compare[i + 2]) + (mixingPos[i + 3] * compare[i + 3])) >> overlapDividerBits;\n  lnorm += ((mixingPos[i] * mixingPos[i]) + (mixingPos[i + 1] * mixingPos[i + 1])) >> overlapDividerBits;\n  lnorm += ((mixingPos[i + 2] * mixingPos[i + 2]) + (mixingPos[i + 3] * mixingPos[i + 3])) >> overlapDividerBits;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/tags/1.25.01.00/include/soundtouch/source/SoundTouch/TDStretch/1"}
{"code": "for (unsigned long long it = 2000; it >= 600; it -= 400)\n{\n  *(g_ptr++) = 0.0;\n  a[it + lin]++;\n}\n\n", "pragma": "  #pragma omp for simd linear(lin : get_val()), linear(g_ptr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/2"}
{"code": "for (int i = 1; i < 4194304; i++)\n{\n  result[i] = (((a_const * 0.00000476837158203125) * 0.00000476837158203125) * (((((((Y[i + 1] * Y[i + 1]) * Y[i + 1]) - Y[i + 1]) - (((26 * Y[i]) * Y[i]) * Y[i])) + (2 * Y[i])) + ((Y[i - 1] * Y[i - 1]) * Y[i - 1])) - Y[i - 1])) / 12;\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task10/main/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    c[i][j] = 0.0;\n    for (int k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huxiaotaostasy/OpenMP/code_OpenMP/main/2"}
{"code": "for (j = 0; j < N; j += 4)\n{\n  int ztmp;\n  int zsqr;\n  int zr;\n  int ztmp2;\n  int zsqr2;\n  int zr2;\n  int ztmp3;\n  int zsqr3;\n  int zr3;\n  int ztmp4;\n  int zsqr4;\n  int zr4;\n  __mmask8 k1;\n  __mmask8 k2;\n  __mmask8 k3;\n  __mmask8 k4;\n  int zxj;\n  int zyj;\n  int zzj;\n  int zxj2;\n  int zyj2;\n  int zzj2;\n  int zxj3;\n  int zyj3;\n  int zzj3;\n  int zxj4;\n  int zyj4;\n  int zzj4;\n  int zrx;\n  int zry;\n  int zrz;\n  int zrx2;\n  int zry2;\n  int zrz2;\n  int zrx3;\n  int zry3;\n  int zrz3;\n  int zrx4;\n  int zry4;\n  int zrz4;\n  int zm;\n  int zm2;\n  int zm3;\n  int zm4;\n  int denom;\n  int numer;\n  int fixed;\n  int denom2;\n  int numer2;\n  int fixed2;\n  int denom3;\n  int numer3;\n  int fixed3;\n  int denom4;\n  int numer4;\n  int fixed4;\n  int tmp11;\n  int tmp21;\n  int tmp31;\n  int tmp12;\n  int tmp22;\n  int tmp32;\n  int tmp13;\n  int tmp23;\n  int tmp33;\n  int tmp14;\n  int tmp24;\n  int tmp34;\n  if (unlikely((i <= j) && (j < (i + 8))))\n  {\n    zxj = _mm512_set1_pd(xi[j]);\n    zyj = _mm512_set1_pd(yi[j]);\n    zzj = _mm512_set1_pd(zi[j]);\n    zxj2 = _mm512_set1_pd(xi[j + 1]);\n    zyj2 = _mm512_set1_pd(yi[j + 1]);\n    zzj2 = _mm512_set1_pd(zi[j + 1]);\n    zxj3 = _mm512_set1_pd(xi[j + 2]);\n    zyj3 = _mm512_set1_pd(yi[j + 2]);\n    zzj3 = _mm512_set1_pd(zi[j + 2]);\n    zxj4 = _mm512_set1_pd(xi[j + 3]);\n    zyj4 = _mm512_set1_pd(yi[j + 3]);\n    zzj4 = _mm512_set1_pd(zi[j + 3]);\n    zrx = _mm512_sub_pd(zxi, zxj);\n    zry = _mm512_sub_pd(zyi, zyj);\n    zrz = _mm512_sub_pd(zzi, zzj);\n    zrx2 = _mm512_sub_pd(zxi, zxj2);\n    zry2 = _mm512_sub_pd(zyi, zyj2);\n    zrz2 = _mm512_sub_pd(zzi, zzj2);\n    zrx3 = _mm512_sub_pd(zxi, zxj3);\n    zry3 = _mm512_sub_pd(zyi, zyj3);\n    zrz3 = _mm512_sub_pd(zzi, zzj3);\n    zrx4 = _mm512_sub_pd(zxi, zxj4);\n    zry4 = _mm512_sub_pd(zyi, zyj4);\n    zrz4 = _mm512_sub_pd(zzi, zzj4);\n    tmp11 = _mm512_mul_pd(zrx, zrx);\n    tmp21 = _mm512_mul_pd(zry, zry);\n    tmp31 = _mm512_mul_pd(zrz, zrz);\n    tmp12 = _mm512_mul_pd(zrx2, zrx2);\n    tmp22 = _mm512_mul_pd(zry2, zry2);\n    tmp32 = _mm512_mul_pd(zrz2, zrz2);\n    tmp13 = _mm512_mul_pd(zrx3, zrx3);\n    tmp23 = _mm512_mul_pd(zry3, zry3);\n    tmp33 = _mm512_mul_pd(zrz3, zrz3);\n    tmp14 = _mm512_mul_pd(zrx4, zrx4);\n    tmp24 = _mm512_mul_pd(zry4, zry4);\n    tmp34 = _mm512_mul_pd(zrz4, zrz4);\n    tmp11 = _mm512_add_pd(tmp11, tmp21);\n    tmp12 = _mm512_add_pd(tmp12, tmp22);\n    tmp13 = _mm512_add_pd(tmp13, tmp23);\n    tmp14 = _mm512_add_pd(tmp14, tmp24);\n    ztmp = _mm512_add_pd(tmp11, tmp31);\n    ztmp2 = _mm512_add_pd(tmp12, tmp32);\n    ztmp3 = _mm512_add_pd(tmp13, tmp33);\n    ztmp4 = _mm512_add_pd(tmp14, tmp34);\n    k1 = _mm512_cmpeq_pd_mask(zero, ztmp);\n    k2 = _mm512_cmpeq_pd_mask(zero, ztmp2);\n    ztmp = _mm512_mask_mov_pd(ztmp, k1, one);\n    ztmp2 = _mm512_mask_mov_pd(ztmp2, k2, one);\n    zm = _mm512_mask_mov_pd(zm, k1, zero);\n    zm2 = _mm512_mask_mov_pd(zm2, k2, zero);\n    k3 = _mm512_cmpeq_pd_mask(zero, ztmp3);\n    k4 = _mm512_cmpeq_pd_mask(zero, ztmp4);\n    ztmp3 = _mm512_mask_mov_pd(ztmp3, k3, one);\n    ztmp4 = _mm512_mask_mov_pd(ztmp4, k4, one);\n    zm3 = _mm512_mask_mov_pd(zm3, k3, zero);\n    zm4 = _mm512_mask_mov_pd(zm4, k4, zero);\n    zsqr = _mm512_rsqrt28_pd(ztmp);\n    zsqr2 = _mm512_rsqrt28_pd(ztmp2);\n    zsqr3 = _mm512_rsqrt28_pd(ztmp3);\n    zsqr4 = _mm512_rsqrt28_pd(ztmp4);\n    zr = _mm512_rcp28_pd(ztmp);\n    zr2 = _mm512_rcp28_pd(ztmp2);\n    zr3 = _mm512_rcp28_pd(ztmp3);\n    zr4 = _mm512_rcp28_pd(ztmp4);\n    zm = _mm512_set1_pd(m[j]);\n    zm2 = _mm512_set1_pd(m[j + 1]);\n    zm3 = _mm512_set1_pd(m[j + 2]);\n    zm4 = _mm512_set1_pd(m[j + 3]);\n    denom = _mm512_mul_pd(zr, zsqr);\n    numer = _mm512_mul_pd(zG, zm);\n    fixed = _mm512_mul_pd(denom, numer);\n    denom2 = _mm512_mul_pd(zr2, zsqr2);\n    numer2 = _mm512_mul_pd(zG, zm2);\n    fixed2 = _mm512_mul_pd(denom2, numer2);\n    denom3 = _mm512_mul_pd(zr3, zsqr3);\n    numer3 = _mm512_mul_pd(zG, zm3);\n    fixed3 = _mm512_mul_pd(denom3, numer3);\n    denom4 = _mm512_mul_pd(zr4, zsqr4);\n    numer4 = _mm512_mul_pd(zG, zm4);\n    fixed4 = _mm512_mul_pd(denom4, numer4);\n    tmp11 = _mm512_mul_pd(fixed, zrx);\n    tmp21 = _mm512_mul_pd(fixed, zry);\n    tmp31 = _mm512_mul_pd(fixed, zrz);\n    tmp12 = _mm512_mul_pd(fixed2, zrx2);\n    tmp22 = _mm512_mul_pd(fixed2, zry2);\n    tmp32 = _mm512_mul_pd(fixed2, zrz2);\n    tmp13 = _mm512_mul_pd(fixed3, zrx3);\n    tmp23 = _mm512_mul_pd(fixed3, zry3);\n    tmp33 = _mm512_mul_pd(fixed3, zrz3);\n    tmp14 = _mm512_mul_pd(fixed4, zrx4);\n    tmp24 = _mm512_mul_pd(fixed4, zry4);\n    tmp34 = _mm512_mul_pd(fixed4, zrz4);\n    zax = _mm512_add_pd(tmp11, zax);\n    zax = _mm512_add_pd(tmp12, zax);\n    zax = _mm512_add_pd(tmp13, zax);\n    zax = _mm512_add_pd(tmp14, zax);\n    zay = _mm512_add_pd(tmp21, zay);\n    zay = _mm512_add_pd(tmp22, zay);\n    zay = _mm512_add_pd(tmp23, zay);\n    zay = _mm512_add_pd(tmp24, zay);\n    zaz = _mm512_add_pd(tmp31, zaz);\n    zaz = _mm512_add_pd(tmp32, zaz);\n    zaz = _mm512_add_pd(tmp33, zaz);\n    zaz = _mm512_add_pd(tmp34, zaz);\n    _mm512_store_pd(ax, zax);\n    _mm512_store_pd(ay, zay);\n    _mm512_store_pd(az, zaz);\n  }\n  else\n  {\n    zxj = _mm512_set1_pd(xi[j]);\n    zyj = _mm512_set1_pd(yi[j]);\n    zzj = _mm512_set1_pd(zi[j]);\n    zxj2 = _mm512_set1_pd(xi[j + 1]);\n    zyj2 = _mm512_set1_pd(yi[j + 1]);\n    zzj2 = _mm512_set1_pd(zi[j + 1]);\n    zxj3 = _mm512_set1_pd(xi[j + 2]);\n    zyj3 = _mm512_set1_pd(yi[j + 2]);\n    zzj3 = _mm512_set1_pd(zi[j + 2]);\n    zxj4 = _mm512_set1_pd(xi[j + 3]);\n    zyj4 = _mm512_set1_pd(yi[j + 3]);\n    zzj4 = _mm512_set1_pd(zi[j + 3]);\n    zrx = _mm512_sub_pd(zxi, zxj);\n    zry = _mm512_sub_pd(zyi, zyj);\n    zrz = _mm512_sub_pd(zzi, zzj);\n    zrx2 = _mm512_sub_pd(zxi, zxj2);\n    zry2 = _mm512_sub_pd(zyi, zyj2);\n    zrz2 = _mm512_sub_pd(zzi, zzj2);\n    zrx3 = _mm512_sub_pd(zxi, zxj3);\n    zry3 = _mm512_sub_pd(zyi, zyj3);\n    zrz3 = _mm512_sub_pd(zzi, zzj3);\n    zrx4 = _mm512_sub_pd(zxi, zxj4);\n    zry4 = _mm512_sub_pd(zyi, zyj4);\n    zrz4 = _mm512_sub_pd(zzi, zzj4);\n    tmp11 = _mm512_mul_pd(zrx, zrx);\n    tmp21 = _mm512_mul_pd(zry, zry);\n    tmp31 = _mm512_mul_pd(zrz, zrz);\n    tmp12 = _mm512_mul_pd(zrx2, zrx2);\n    tmp22 = _mm512_mul_pd(zry2, zry2);\n    tmp32 = _mm512_mul_pd(zrz2, zrz2);\n    tmp13 = _mm512_mul_pd(zrx3, zrx3);\n    tmp23 = _mm512_mul_pd(zry3, zry3);\n    tmp33 = _mm512_mul_pd(zrz3, zrz3);\n    tmp14 = _mm512_mul_pd(zrx4, zrx4);\n    tmp24 = _mm512_mul_pd(zry4, zry4);\n    tmp34 = _mm512_mul_pd(zrz4, zrz4);\n    tmp11 = _mm512_add_pd(tmp11, tmp21);\n    tmp12 = _mm512_add_pd(tmp12, tmp22);\n    tmp13 = _mm512_add_pd(tmp13, tmp23);\n    tmp14 = _mm512_add_pd(tmp14, tmp24);\n    ztmp = _mm512_add_pd(tmp11, tmp31);\n    ztmp2 = _mm512_add_pd(tmp12, tmp32);\n    ztmp3 = _mm512_add_pd(tmp13, tmp33);\n    ztmp4 = _mm512_add_pd(tmp14, tmp34);\n    zsqr = _mm512_rsqrt28_pd(ztmp);\n    zsqr2 = _mm512_rsqrt28_pd(ztmp2);\n    zsqr3 = _mm512_rsqrt28_pd(ztmp3);\n    zsqr4 = _mm512_rsqrt28_pd(ztmp4);\n    zr = _mm512_rcp28_pd(ztmp);\n    zr2 = _mm512_rcp28_pd(ztmp2);\n    zr3 = _mm512_rcp28_pd(ztmp3);\n    zr4 = _mm512_rcp28_pd(ztmp4);\n    zm = _mm512_set1_pd(m[j]);\n    zm2 = _mm512_set1_pd(m[j + 1]);\n    zm3 = _mm512_set1_pd(m[j + 2]);\n    zm4 = _mm512_set1_pd(m[j + 3]);\n    denom = _mm512_mul_pd(zr, zsqr);\n    numer = _mm512_mul_pd(zG, zm);\n    fixed = _mm512_mul_pd(denom, numer);\n    denom2 = _mm512_mul_pd(zr2, zsqr2);\n    numer2 = _mm512_mul_pd(zG, zm2);\n    fixed2 = _mm512_mul_pd(denom2, numer2);\n    denom3 = _mm512_mul_pd(zr3, zsqr3);\n    numer3 = _mm512_mul_pd(zG, zm3);\n    fixed3 = _mm512_mul_pd(denom3, numer3);\n    denom4 = _mm512_mul_pd(zr4, zsqr4);\n    numer4 = _mm512_mul_pd(zG, zm4);\n    fixed4 = _mm512_mul_pd(denom4, numer4);\n    tmp11 = _mm512_mul_pd(fixed, zrx);\n    tmp21 = _mm512_mul_pd(fixed, zry);\n    tmp31 = _mm512_mul_pd(fixed, zrz);\n    tmp12 = _mm512_mul_pd(fixed2, zrx2);\n    tmp22 = _mm512_mul_pd(fixed2, zry2);\n    tmp32 = _mm512_mul_pd(fixed2, zrz2);\n    tmp13 = _mm512_mul_pd(fixed3, zrx3);\n    tmp23 = _mm512_mul_pd(fixed3, zry3);\n    tmp33 = _mm512_mul_pd(fixed3, zrz3);\n    tmp14 = _mm512_mul_pd(fixed4, zrx4);\n    tmp24 = _mm512_mul_pd(fixed4, zry4);\n    tmp34 = _mm512_mul_pd(fixed4, zrz4);\n    zax = _mm512_add_pd(tmp11, zax);\n    zax = _mm512_add_pd(tmp12, zax);\n    zax = _mm512_add_pd(tmp13, zax);\n    zax = _mm512_add_pd(tmp14, zax);\n    zay = _mm512_add_pd(tmp21, zay);\n    zay = _mm512_add_pd(tmp22, zay);\n    zay = _mm512_add_pd(tmp23, zay);\n    zay = _mm512_add_pd(tmp24, zay);\n    zaz = _mm512_add_pd(tmp31, zaz);\n    zaz = _mm512_add_pd(tmp32, zaz);\n    zaz = _mm512_add_pd(tmp33, zaz);\n    zaz = _mm512_add_pd(tmp34, zaz);\n    _mm512_store_pd(ax, zax);\n    _mm512_store_pd(ay, zay);\n    _mm512_store_pd(az, zaz);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,zxi,zyi,zzi,zax,zay,zaz) reduction(+:ax,ay,az)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/vec_nbody/0"}
{"code": "for (size_t row = step + 1; row < n; ++row)\n{\n  const float coeff = (-matrix_copy[row][step]) / matrix_copy[step][step];\n  for (size_t col = step; col != n; ++col)\n  {\n    matrix_copy[row][col] += matrix_copy[step][col] * coeff;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Depyden/OpenMP/Lab7_2/calculations/0"}
{"code": "for (int i = 0; i < rescale.size(); i++)\n{\n  for (int j = 0; j < rescale[0].size(); j++)\n  {\n    rescale[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/0"}
{"code": "for (int g = 0; g < I.n_egroups; g++)\n{\n  float y1 = QSR->fine_source[fine_id][g];\n  float y2 = QSR->fine_source[fine_id + 1][g];\n  float y3 = QSR->fine_source[fine_id + 2][g];\n  float c0 = y2;\n  float c1 = (y1 - y3) / (2.f * dz);\n  float c2 = ((y1 - (2.f * y2)) + y3) / ((2.f * dz) * dz);\n  q0[g] = (c0 + (c1 * zin)) + ((c2 * zin) * zin);\n  q1[g] = c1 + ((2.f * c2) * zin);\n  q2[g] = c2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/5"}
{"code": "for (int s = 1; s <= threadY; s *= 2)\n{\n  int spot = ty - s;\n  double val = 0;\n  if (spot >= 0)\n  {\n    val = d_img[(((pz * nPixY) * nPixX) + ((offsetY + spot) * nPixY)) + px];\n  }\n\n  if (spot >= 0)\n  {\n    d_img[(((pz * nPixY) * nPixX) + (py * nPixY)) + px] += val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (i != (size - 1))\n    fprintf(f, \"O[%d]-%d-> \", i, arr[i]);\n  else\n    fprintf(f, \"O[%d]-%d\", i, arr[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/Project/Project/main/1"}
{"code": "for (j = lt - 1; j >= 1; j--)\n{\n  ir[j] = ir[j + 1] + (((ONE * m1[j + 1]) * m2[j + 1]) * m3[j + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/13"}
{"code": "for (i = 1; i < sp->len; i++)\n{\n  vp = vp->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/1"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < cols; j++)\n  matrix[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gustavopergola/ParalelMatrixMultiplier/OpenMP/main/4"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[i] = i * 2;\n  sum += i;\n}\n\n", "pragma": "omp parallel for if(1) ordered reduction(+:sum) schedule(dynamic, 5)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/parallelfor/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  double a = i + 1;\n  double b = 1 / (j + 1);\n  mas[i][0] = pow(a, b) * cos(i + j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/8"}
{"code": "for (j_imopVarPre78 = nrows; j_imopVarPre78 >= 1; j_imopVarPre78--)\n{\n  rowstr[j_imopVarPre78 + 1] = rowstr[j_imopVarPre78];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/26"}
{"code": "for (i = 0; i < n; i++)\n{\n  xxexp = exp((*dx) * (i - 1));\n  for (j = 0; j < n; j++)\n  {\n    yy = (*dy) * (j - 1);\n    u[i][j] = 0.0;\n    f[i][j] = xxexp * yy;\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j, xxexp, yy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thiagowfx/coc-472-CAD/T2/ex1/jacobi/2"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t k;\n  uint32_t src;\n  uint32_t dest;\n  struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n  for (k = 0; k < partition->num_edges; ++k)\n  {\n    src = partition->edgeList->edges_array_src[k];\n    dest = partition->edgeList->edges_array_dest[k];\n    pageRanksNext[dest] += riDividedOnDiClause[src];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/3"}
{"code": "for (int j = 0; j < ((int) pJ->GetY()); j++)\n{\n  is_node = 0;\n  for (int i = 0; i < ((int) pJ->GetX()); i++)\n  {\n    if (((((pJ->GetValue(i, j).isCond2D(CT_WALL_LAW_2D) || pJ->GetValue(i, j).isCond2D(CT_WALL_NO_SLIP_2D)) && (i >= ((int) (((x0 / FlowNode2D) < FP, dx))))) && (i <= ((int) ((((x0 + dx) / FlowNode2D) < FP, dx))))) && (j >= ((int) (((y0 / FlowNode2D) < FP, dy))))) && (j <= ((int) ((((y0 + dy) / FlowNode2D) < FP, dy)))))\n    {\n      is_node = 1;\n    }\n\n  }\n\n  if (is_node)\n  {\n    if (FlowNode2D < FP, FT == FT_FLAT)\n    {\n      Fmid += FlowNode2D < FP, dy;\n    }\n    else\n    {\n      Fmid += (((2 * M_PI) * (j + 0.5)) * FlowNode2D) < FP, (dy * FlowNode2D) < FP, dy;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:Fmid)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libOutCFD/out_cfd_param/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanTrofimov/parallel-programming/code/iterable/0"}
{"code": "for (int j = 0; j < nj; j++)\n{\n  for (int i = 0; i < ni; i++)\n  {\n    double x = ((((double) (nj - j)) * (-a)) + (((double) (j - 1)) * a)) / ((double) (nj - 1));\n    double y = ((((double) (ni - i)) * (-b)) + (((double) (i - 1)) * b)) / ((double) (ni - 1));\n    double dx;\n    double dy;\n    double us;\n    double ut;\n    double vh;\n    double vs;\n    double x1;\n    double x2;\n    double w;\n    double w_exact;\n    double we;\n    double wt;\n    int steps;\n    double chk = pow(x / a, 2.0) + pow(y / b, 2.0);\n    if (1.0 < chk)\n    {\n      w_exact = 1.0;\n      wt = 1.0;\n    }\n    else\n    {\n      n_inside++;\n      w_exact = exp((pow(x / a, 2.0) + pow(y / b, 2.0)) - 1.0);\n      wt = 0.0;\n      steps = 0;\n      for (int k = 0; k < N; k++)\n      {\n        x1 = x;\n        x2 = y;\n        w = 1.0;\n        chk = 0.0;\n        while (chk < 1.0)\n        {\n          ut = r8_uniform_01(&seed);\n          if (ut < (1.0 / 2.0))\n          {\n            us = r8_uniform_01(&seed) - 0.5;\n            if (us < 0.0)\n              dx = -rth;\n            else\n              dx = rth;\n\n          }\n          else\n          {\n            dx = 0.0;\n          }\n\n          ut = r8_uniform_01(&seed);\n          if (ut < (1.0 / 2.0))\n          {\n            us = r8_uniform_01(&seed) - 0.5;\n            if (us < 0.0)\n              dy = -rth;\n            else\n              dy = rth;\n\n          }\n          else\n          {\n            dy = 0.0;\n          }\n\n          vs = potential(a, b, x1, x2);\n          x1 = x1 + dx;\n          x2 = x2 + dy;\n          steps++;\n          vh = potential(a, b, x1, x2);\n          we = (1.0 - (h * vs)) * w;\n          w = w - ((0.5 * h) * ((vh * we) + (vs * w)));\n          chk = pow(x1 / a, 2.0) + pow(x2 / b, 2.0);\n        }\n\n        wt += w;\n      }\n\n      wt /= (double) N;\n      err += pow(w_exact - wt, 2.0);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for collapse(2) thread_limit(256) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/feynman-kac-omp/main/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    expected_x += a[j];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n  expected_x = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/scan/test_scan/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    m3[i][j] = 0;\n    for (int k = 0; k < N; k++)\n    {\n      m3[i][j] += m1[i][k] * m2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/realsanya/parallel-programming/sem-2/ConsoleApplication2/1"}
{"code": "for (int i = 0; i < sim->LANES; i++)\n{\n  for (int j = 0; j < sim->L; j++)\n  {\n    grid[(sim->L * i) + j] = -1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/6"}
{"code": "for (int i = (N / 8) * 7; i < N; i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n  {\n    total *= sp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/15"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (a[i] != (i + 1))\n    printf(\"%d: error %d != %d, error %d\\n\", i, a[i], i + 1, ++error);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-enter-nowait/test/7"}
{"code": "for (int ii = 2; ii < params.ly; ++ii)\n{\n  for (int jj = 1; jj < (params.lx + 1); jj += params.lx - 1)\n  {\n    if (!obstacles[((ii - 1) * params.lx) + (jj - 1)])\n    {\n      float tmp_speeds[9];\n      tmp_speeds[0] = cells[(ii * params.nx) + jj].speeds[0];\n      tmp_speeds[1] = cells[(ii * params.nx) + jj].speeds[3];\n      tmp_speeds[2] = cells[(ii * params.nx) + jj].speeds[4];\n      tmp_speeds[3] = cells[(ii * params.nx) + jj].speeds[1];\n      tmp_speeds[4] = cells[(ii * params.nx) + jj].speeds[2];\n      tmp_speeds[5] = cells[(ii * params.nx) + jj].speeds[7];\n      tmp_speeds[6] = cells[(ii * params.nx) + jj].speeds[8];\n      tmp_speeds[7] = cells[(ii * params.nx) + jj].speeds[5];\n      tmp_speeds[8] = cells[(ii * params.nx) + jj].speeds[6];\n      float local_density = 0.0f;\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        local_density += tmp_speeds[kk];\n      }\n\n      float u_x = ((((((+tmp_speeds[1]) + tmp_speeds[5]) + tmp_speeds[8]) - tmp_speeds[3]) - tmp_speeds[6]) - tmp_speeds[7]) / local_density;\n      float u_y = ((((((+tmp_speeds[2]) + tmp_speeds[5]) + tmp_speeds[6]) - tmp_speeds[4]) - tmp_speeds[7]) - tmp_speeds[8]) / local_density;\n      float u_sq = (u_x * u_x) + (u_y * u_y);\n      float d_equ[9];\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        float u_kk = (u[kk][0] * u_x) + (u[kk][1] * u_y);\n        d_equ[kk] = ((w[kk] * params.omega) * local_density) * (((1.0f + (3.0f * u_kk)) + ((4.5f * u_kk) * u_kk)) - (1.5f * u_sq));\n      }\n\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        cells[(ii * params.nx) + jj].speeds[kk] = ((1.0f - params.omega) * tmp_speeds[kk]) + d_equ[kk];\n      }\n\n      tot_u += sqrtf((u_x * u_x) + (u_y * u_y));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/33"}
{"code": "for (int i = width - 1; i > (-1); i--)\n{\n  a[i] = rand() % 2;\n  control_sum += control_power * a[i];\n  inv_powers[i] = control_power;\n  control_power * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OlegShatin/openmp-homework/13/main/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  MPI_Recv(&new_item, 1, tuple_type, src, VECTOR_BROADCAST_TAG, MPI_COMM_WORLD, &status);\n  vector_to_recv.push_back(new_item);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramachav/Map-Reduce-Multi-Threaded/Map_Reduce_Code/map_reduce/10"}
{"code": "for (j = 0; j < 4; j++)\n  num_rows[j] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/0"}
{"code": "for (i = 0; i < L; i++)\n  for (k = 0; k < N; k++)\n  C[(i * N) + k] = ((-((float) L)) * M) * N;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/21"}
{"code": "for (int i = 0; i < sub_tree_root.size(); i++)\n{\n  minE[i] = minPMA(sub_tree_root[i]);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramesh-chandra-saini/Parallel_Prims_Algorithms/src/prim_minPMA/1"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  c[i][j] = c_flat[(i * n) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/mat_mul/7"}
{"code": "for (int i = 0; i < args->numinputs; i++)\n{\n  sprintf(buffer, \"Buffer %d has checksum \", i);\n  fwrite(buffer, sizeof(char), strlen(buffer) + 1, stdout);\n  for (int j = 0; j < (DIGEST_SIZE * 2); j += 2)\n  {\n    sprintf(buffer + j, \"%x\", args->out[(DIGEST_SIZE * i) + (j / 2)] & 0xf);\n    sprintf((buffer + j) + 1, \"%x\", args->out[(DIGEST_SIZE * i) + (j / 2)] & 0xf0);\n  }\n\n  buffer[32] = '\\0';\n  printf(\"%s \", buffer);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task6/md5_bmark_parallel/5"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    scanfReturn = fscanf(myFile, \"%d%*c\", &myvar2);\n    if (scanfReturn == 1)\n    {\n    }\n    else\n    {\n      printf(\"error in %d,%d. \\n\", i, j);\n      return 1;\n    }\n\n    if ((i >= start) && (i <= end))\n    {\n      if (pointPerkNN[i - start][j] != myvar2)\n      {\n        errors++;\n      }\n\n    }\n\n    if (i > end)\n    {\n      goto stop2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/5"}
{"code": "for (i = 0; i < size; i++)\n  if (scanf(\"%d\", &b[i]) != 1)\n{\n  printf(\"Fail to scan vector b\\n\");\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcksber/CMU_15-418_hw3/examples/loop/2"}
{"code": "for (i = 1; i < nthreads; i++)\n  local_newClusterSize[i] = local_newClusterSize[i - 1] + numClusters;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/11"}
{"code": "for (int i = 0; i < (this->mat_.nrowb + 1); ++i)\n{\n  this->mat_.row_offset[i] = cast_mat->mat_.row_offset[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_bcsr/0"}
{"code": "for (p1 = 0; p1 < 20; p1++)\n{\n  for (p2 = 0; p2 < p1; p2++)\n  {\n    temp = A[p1][p2];\n    A[p1][p2] = A[p2][p1];\n    A[p2][p1] = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/6.norace1/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    printf(\"%d \", grid[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patricia-souza/JogoVidaOpenMP/Critical/5"}
{"code": "for (lev = 0; lev < (p.Lmax + 1); lev++)\n{\n  phi[lev] = (double *) malloc((p.size[lev] * p.size[lev]) * (sizeof(double)));\n  res[lev] = (double *) malloc((p.size[lev] * p.size[lev]) * (sizeof(double)));\n  for (i = 0; i < (p.size[lev] * p.size[lev]); i++)\n  {\n    phi[lev][i] = 0.0;\n    res[lev][i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/parallel_mg/8"}
{"code": "for (j = 0; j < 32; j++)\n  err += bar(3, i, j);\n\n", "pragma": "omp parallel for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/target-35/2"}
{"code": "for (int i = orig_ncols; i < m.cols(); i++)\n{\n  m.col(i).setZero();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/4"}
{"code": "for (j = 0; j < 100; j++)\n  thread_seeds[j] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/celidos/mcs_in_diht2017/lab1/monte_best/1"}
{"code": "for (int i = 0; i < var.N; ++i)\n  check += var.p[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_07/4"}
{"code": "for (k = 1; k <= (n - 1); k++)\n{\n  sum += f(a + (k * h));\n}\n\n", "pragma": "#pragma omp parallel for private(k) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/Trap/0"}
{"code": "for (int k = 0; k < VERTICES; k++)\n{\n  graph[k] = (int *) malloc(VERTICES * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JFcoZC/PrimMSTParallelOpenMP/PrimSTPOpenMP/0"}
{"code": "for (int i = 0; i < nnz; i++)\n  Aj[i] = h_Aj[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/spmv/omp_simd/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  w[i + 1] -= (a * sign) * p[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/12"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  int startInd = (N / 8) * i;\n  int buf = (N / 8) * (i + 1);\n  int endInd = (buf > N) ? (N) : (buf);\n  threads[i] = thread(worker, startInd, endInd);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brelok-the-pok/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = (double *) malloc(n * (sizeof(double)));\n  b[i] = (double *) calloc(n, sizeof(double));\n  c[i] = (double *) calloc(n, sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_3/Block/parallel/1"}
{"code": "for (int i = 0; i < test.size(); i++)\n  printf(\" %d\", test[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle0/9"}
{"code": "for (uint ix = 2; ix < (nx - 2); ++ix)\n{\n  for (uint iz = 2; iz < (nz - 2); ++iz)\n  {\n    txx[ix][iz] = taper[ix][iz] * (txx[ix][iz] + (dt * (((lm[ix][iz] * ((coeff1 * (vx[ix + 1][iz] - vx[ix][iz])) + (coeff2 * (vx[ix - 1][iz] - vx[ix + 2][iz])))) / dx) + ((la[ix][iz] * ((coeff1 * (vz[ix][iz] - vz[ix][iz - 1])) + (coeff2 * (vz[ix][iz - 2] - vz[ix][iz + 1])))) / dz))));\n    tzz[ix][iz] = taper[ix][iz] * (tzz[ix][iz] + (dt * (((la[ix][iz] * ((coeff1 * (vx[ix + 1][iz] - vx[ix][iz])) + (coeff2 * (vx[ix - 1][iz] - vx[ix + 2][iz])))) / dx) + ((lm[ix][iz] * ((coeff1 * (vz[ix][iz] - vz[ix][iz - 1])) + (coeff2 * (vz[ix][iz - 2] - vz[ix][iz + 1])))) / dz))));\n    txz[ix][iz] = taper[ix][iz] * (txz[ix][iz] + ((dt * mu[ix][iz]) * ((((coeff1 * (vx[ix][iz + 1] - vx[ix][iz])) + (coeff2 * (vx[ix][iz - 1] - vx[ix][iz + 2]))) / dz) + (((coeff1 * (vz[ix][iz] - vz[ix - 1][iz])) + (coeff2 * (vz[ix - 2][iz] - vz[ix + 1][iz]))) / dx))));\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/larsgeb/fd-wave-modelling-gpu/main/2"}
{"code": "for (j = 0; j < IMAX; j++)\n{\n  for (k = 0; k < IMAX; k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      u[i][j][k][m] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/13"}
{"code": "for (i = 2; i <= 131072; i++)\n{\n  if (prime_is(i))\n  {\n    printf(\"Prime: %d\\t Time: %f\\n\", i, omp_get_wtime() - wtime);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(16) shared(i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/workout_1/openmp/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    m_set_val(IMGVF, i, j, m_get_val(I, i, j));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/6"}
{"code": "for (i = 0; i <= n1; i++)\n{\n  for (j = 0; j <= n2; j++)\n  {\n    dvalue = w[i][j];\n    {\n      register char *_to;\n      register char *_from;\n      register int _i;\n      register int _l;\n      _to = (char *) (&mem[memcnt]);\n      _from = (char *) (&dvalue);\n      _l = sizeof(float);\n      for (_i = 0; _i < _l; _i++)\n        *(_to++) = *(_from++);\n\n    }\n    ;\n    memcnt += sizeof(float);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_backprop/backprop/10"}
{"code": "for (int i = 0; i < 100; ++i)\n  a = a + i;\n\n", "pragma": "    #pragma omp parallel for reduction(my_add: a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_01/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (omp_get_thread_num() == 0)\n    printf(\"Thread %d is doing iteration %d.\\n\", omp_get_thread_num(), i);\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muatik/openmp-examples/scheduling/main/0"}
{"code": "for (int pixel = 0; pixel < n_pixels; pixel++)\n{\n  if (distances[pixel] > max_distance)\n  {\n    max_distance_local = distances[pixel];\n    farthest_pixel_local = pixel;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blarc/image-compression-k-means/src/compression_omp/2"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  diplacement_vector[i] = r1[i] - r2[i];\n  norme_dipalcement = norme_dipalcement + (diplacement_vector[i] * diplacement_vector[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPC-Project/openMp/openmp/4"}
{"code": "for (num = start; num <= end; num++)\n{\n  if ((num % comm_sz) != my_rank)\n    continue;\n\n  temp = num;\n  reverse_num = 0;\n  while (temp)\n  {\n    rem = temp % 10;\n    temp = temp / 10;\n    reverse_num = (reverse_num * 10) + rem;\n  }\n\n  if (num == reverse_num)\n    printf(\"%d \", num);\n\n}\n\n", "pragma": "omp parallel for shared(num,end,revers_num) private(rem,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vthanos/Parallel-Computing/hybrid/palindrome/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      v[i][j][k][m] = v[i][j][k][m] - (omega * ((((((((((ldy[i][j][m][0] * v[i][j - 1][k][0]) + (ldx[i][j][m][0] * v[i - 1][j][k][0])) + (ldy[i][j][m][1] * v[i][j - 1][k][1])) + (ldx[i][j][m][1] * v[i - 1][j][k][1])) + (ldy[i][j][m][2] * v[i][j - 1][k][2])) + (ldx[i][j][m][2] * v[i - 1][j][k][2])) + (ldy[i][j][m][3] * v[i][j - 1][k][3])) + (ldx[i][j][m][3] * v[i - 1][j][k][3])) + (ldy[i][j][m][4] * v[i][j - 1][k][4])) + (ldx[i][j][m][4] * v[i - 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    v[i][j][k][1] = v[i][j][k][1] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][3] * tmp);\n    v[i][j][k][4] = v[i][j][k][4] / tmat[4][4];\n    v[i][j][k][3] = v[i][j][k][3] - (tmat[3][4] * v[i][j][k][4]);\n    v[i][j][k][3] = v[i][j][k][3] / tmat[3][3];\n    v[i][j][k][2] = (v[i][j][k][2] - (tmat[2][3] * v[i][j][k][3])) - (tmat[2][4] * v[i][j][k][4]);\n    v[i][j][k][2] = v[i][j][k][2] / tmat[2][2];\n    v[i][j][k][1] = ((v[i][j][k][1] - (tmat[1][2] * v[i][j][k][2])) - (tmat[1][3] * v[i][j][k][3])) - (tmat[1][4] * v[i][j][k][4]);\n    v[i][j][k][1] = v[i][j][k][1] / tmat[1][1];\n    v[i][j][k][0] = (((v[i][j][k][0] - (tmat[0][1] * v[i][j][k][1])) - (tmat[0][2] * v[i][j][k][2])) - (tmat[0][3] * v[i][j][k][3])) - (tmat[0][4] * v[i][j][k][4]);\n    v[i][j][k][0] = v[i][j][k][0] / tmat[0][0];\n  }\n\n  if (i != ist)\n    flag[i - 1] = 0;\n\n  if (i != iend)\n    flag[i] = 1;\n\n}\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/51"}
{"code": "for (i = 0; i < 100000; i++)\n  arr[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/public_loop_openmp/1"}
{"code": "for (int i = 0; i < MESH_SIZE; ++i)\n{\n  #pragma ivdep\n  for (int j = 0; j < MESH_SIZE; ++j)\n  {\n    const int y = i + 1;\n    const int x = j + 1;\n    const float t_l = input[y][x - 1];\n    const float t_r = input[y][x + 1];\n    const float t_t = input[y - 1][x];\n    const float t_b = input[y + 1][x];\n    const float k = 1.f;\n    const float d_x = 1.f;\n    const float q = 0.f;\n    const float newTemperature = ((((t_l + t_r) + t_b) + t_t) + (((q * d_x) * d_x) / k)) / 4;\n    output[y][x] = newTemperature;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomix86/cuda-hybrid-heat-distrib/OptymalizacjaCUDA/main/1"}
{"code": "for (int j = 0; j < population; ++j)\n{\n  this->comparisonResults[j].index = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/4"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (argv[i][0] == '-')\n  {\n    flag = argv[i][1];\n    switch (flag)\n    {\n      case 'r':\n        i++;\n        *r = atoi(argv[i]);\n        break;\n\n      case 'l':\n        if (argv[i][2] == 'a')\n      {\n        *lat = atof(argv[i + 1]);\n      }\n      else\n      {\n        *lng = atof(argv[i + 1]);\n      }\n\n        i++;\n        break;\n\n      case 'h':\n        return 1;\n        break;\n\n      case 'q':\n        *q = 1;\n        break;\n\n      case 't':\n        *t = 1;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nn-omp/nearestNeighbor/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  ((((((fout << \"[\") << i) << \"]\") << \" = \") << vector[i]) << \"; \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serhii1savchenko/openmpVectorSmoothing/Lab3_OpenMP/1"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (jj = 0; jj <= (d[1] - fftblock); jj += fftblock)\n  {\n    for (j = 0; j < fftblock; j++)\n    {\n      for (i = 0; i < d[0]; i++)\n      {\n        y0[i][j].real = x[k][j + jj][i].real;\n        y0[i][j].imag = x[k][j + jj][i].imag;\n      }\n\n    }\n\n    int _imopVarPre247;\n    int _imopVarPre248;\n    _imopVarPre247 = d[0];\n    _imopVarPre248 = logd[0];\n    cfftz(is, _imopVarPre248, _imopVarPre247, y0, y1);\n    for (j = 0; j < fftblock; j++)\n    {\n      for (i = 0; i < d[0]; i++)\n      {\n        xout[k][j + jj][i].real = y0[i][j].real;\n        xout[k][j + jj][i].imag = y0[i][j].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/1"}
{"code": "for (int row = array_size - 1; row >= 0; row--)\n{\n  sub[row] = result_array[row];\n  for (int col = array_size - 1; col > row; col--)\n  {\n    sub[row] -= gauss_array[row][col] * sub[col];\n  }\n\n  sub[row] /= gauss_array[row][row];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/batpawe/OpenMPI-MPI-cpp-PROJECTS/Eliminacja_Gaussa_OpenMP/gauss_elim/2"}
{"code": "for (int i = 0; i < src_seq_length_max; i++)\n{\n  for (int j = 0; j < (batch * feature_size); j++)\n    alignment_model_ptr[((i * batch) * feature_size) + j] = tanhf(weighted_src_layer.data()[j] + weighted_annotations[((i * batch) * feature_size) + j]);\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rgr19/MKL-DNN_Eigen_Boost_OpenMPI_GoogleTests_Examples/src/bin/mkl-dnn/simple_rnn/0"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  allClusters[i].virutalCenter.coordinates = (double *) calloc(sizeof(double), allClusters[i].virutalCenter.dimensions);\n  MPI_Recv(allClusters[i].virutalCenter.coordinates, allClusters[i].virutalCenter.dimensions, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/7"}
{"code": "for (j = 0; j < N; j++)\n{\n  sum = 0.0;\n  for (k = 0; k < N; k++)\n  {\n    sum = sum + (A[i][k] * B[k][j]);\n  }\n\n  Result[i][j] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vidya-vidz/OpenMpi/dgemm_seq/1"}
{"code": "for (k = 0; k < dimk; k++)\n{\n  for (j = 0; j < dimj; j++)\n  {\n    alpha = -b[k + (j * stride)];\n    daxpy(&c[j * stride], &a[k * stride], dimi, alpha);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/0"}
{"code": "for (int i = 0; i < strings->len; i++)\n{\n  for (int j = 0; j < packets->len; j++)\n  {\n    counter += KMPSearch(strings->array[i], packets->array[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) num_threads(thread_count) reduction(+: counter)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Greendor1234/ParallelStringMatcher/src/kmp/0"}
{"code": "for (int i = 1; i <= m; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    tnew[i][j] = (((t[i - 1][j] + t[i + 1][j]) + t[i][j - 1]) + t[i][j + 1]) / 4.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CodLiver/Parallel-Programming-v2/jacobi2d_2/0"}
{"code": "for (i = 0; i < length; i++)\n{\n  if (i == 0)\n  {\n    data[i] = rand();\n  }\n  else\n  {\n    data[i] = (((data[i - 1] + 1) * i) * 104723L) % N;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab4/multisort-omp/0"}
{"code": "for (int i = 0; i < to_solve->n; i++)\n{\n  for (int j = 0; j < to_solve->n; j++)\n  {\n    if (to_solve->grid[i][j] == 0)\n    {\n      to_solve->empty_sq[iter]->row = i;\n      to_solve->empty_sq[iter]->col = j;\n      to_solve->empty_sq[iter]->box = ((i / to_solve->box_size) * to_solve->box_size) + (j / to_solve->box_size);\n      iter++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/bin/sudoku-omp_bfsv1/9"}
{"code": "for (int i = 0; i < m1; i++)\n{\n  matrix2[i] = (int *) malloc((sizeof(int)) * m2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/matrix/matrix/3"}
{"code": "for (int i = 0; i <= p.in_size_i; i++)\n{\n  for (int j = 0; j <= p.in_size_j; j++)\n  {\n    in[(i * (p.in_size_j + 1)) + j].x = v[k].x;\n    in[(i * (p.in_size_j + 1)) + j].y = v[k].y;\n    in[(i * (p.in_size_j + 1)) + j].z = v[k].z;\n    k = (k + 1) % 16;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bezier-surface-omp/main/0"}
{"code": "for (row = 0; row < height; ++row)\n{\n  for (col = 0; col < width; col++)\n  {\n    XSetForeground(display, gc, matrix[row][col]);\n    XDrawPoint(display, win, gc, col, row);\n    XFlush(display);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NEGU93/Parallel-Image-FIltering/mandelbrot/mandelbrot/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  idx[i] = i;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/gpr/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  for (int j = i + 1; j < 10000; j++)\n  {\n    Distances[i][j] = Distances[j][i];\n    T[i][j] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/TSP/ants_parallel/5"}
{"code": "for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  Bxc[i][j][k] = ((-B0x) * cos(((2. * M_PI) * grid->getXC(i, j, k)) / Lx)) * sin(((2. * M_PI) * grid->getYC(i, j, k)) / Ly);\n  Byc[i][j][k] = (B0x * cos(((2. * M_PI) * grid->getYC(i, j, k)) / Ly)) * (((-2.) * sin(((2. * M_PI) * grid->getZC(i, j, k)) / Lz)) + sin(((2. * M_PI) * grid->getXC(i, j, k)) / Lx));\n  Bzc[i][j][k] = ((2. * B0x) * cos(((2. * M_PI) * grid->getZC(i, j, k)) / Lz)) * sin(((2. * M_PI) * grid->getYC(i, j, k)) / Ly);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/64"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  ist = kpic[k];\n  npx = (npx > ist) ? (npx) : (ist);\n  isum += ist;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/30"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    lhs[1][i][j + 1][k] = lhs[1][i][j + 1][k] - comz4;\n    lhs[2][i][j + 1][k] = lhs[2][i][j + 1][k] + comz6;\n    lhs[3][i][j + 1][k] = lhs[3][i][j + 1][k] - comz4;\n    lhs[4][i][j + 1][k] = lhs[4][i][j + 1][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/11"}
{"code": "for (i = 0; i < sizeOfTableOutput; ++i)\n{\n  if (i == vectorOutput[raw])\n  {\n    out[i] = 1.0;\n  }\n  else\n  {\n    out[i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/18"}
{"code": "for (int j = 0; j < 10; ++j)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/29"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n  for (int k = 0; k < N; k++)\n  for (int l = 0; l < N; l++)\n{\n  positions[0] = i;\n  positions[1] = j;\n  positions[2] = k;\n  positions[3] = l;\n  if (((isValid(0, i, positions) && isValid(1, j, positions)) && isValid(2, k, positions)) && isValid(3, l, positions))\n    ans += dfsQueen(4, N, positions);\n\n}\n\n\n\n\n", "pragma": "omp for private(positions) schedule(dynamic, 16) reduction(+:ans) collapse(4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/NQueen/main/1"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/185"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if (arr[i] < min_val)\n  {\n    min_val = arr[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(min : min_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aryanchandrakar/Parallel_Distributed_Computing/open_mp/max_min_arrray/1"}
{"code": "for (unsigned int i = 0; i < SIZE; i++)\n{\n  x[i] = distribution(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Armagetron/omp-demo/examp3/0"}
{"code": "for (int i = 1; i <= Nnode; ++i)\n{\n  NIA[i] += NIA[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lovgager/parallel-methods/FirstTask/FirstTask/3"}
{"code": "for (int i = 0; i < row; i++)\n{\n  if (queens[i] == col)\n  {\n    return;\n  }\n\n  if (abs(queens[i] - col) == (row - i))\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment7/Task2/NQueensParallel/1"}
{"code": "for (i = 0; i < N; ++i)\n  A[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uprasad/omp/sieve_prime_parallel/1"}
{"code": "for (int i = 0; i < (matrix_size / block_size); i++)\n{\n  for (int j = 0; j < (matrix_size / block_size); j++)\n  {\n    for (int k = 0; k < (matrix_size / block_size); k++)\n    {\n      for (int l = block_size * i; l < (block_size * (i + 1)); l++)\n        for (int m = block_size * j; m < (block_size * (j + 1)); m++)\n      {\n        for (int n = block_size * k; n < (block_size * (k + 1)); n++)\n          C[l][m] += A[l][n] * B[n][m];\n\n      }\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AYaddaden/matrix-multiplication/main/9"}
{"code": "for (k = ki1; k <= ki2; k++)\n{\n  phi1[i][k] = C2 * (u[i][jbeg][k][4] - ((0.50 * ((pow2(u[i][jbeg][k][1]) + pow2(u[i][jbeg][k][2])) + pow2(u[i][jbeg][k][3]))) / u[i][jbeg][k][0]));\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin ,k ,jbeg ,ki1 ,ki2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/56"}
{"code": "for (i = 0; i < Size; i++)\n{\n  fscanf(fp, \"%f\", &Array[i]);\n  Array[i + Size] = Array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AbhishekRamamurthy/OpenMP-Cuda/AutoCo_OpenMP/1"}
{"code": "for (i = 0; i < rho_mat->size1; ++i)\n{\n  for (j = 0; j < rho_mat->size2; ++j)\n  {\n    gsl_matrix_set(rho_mat, i, j, rho_fun(gsl_vector_get(M_r, j), gsl_matrix_get(ltb->R_mat, i, j), gsl_matrix_get(R_r, i, j)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/3"}
{"code": "for (int64_t e = 0; e < nedges; ++e)\n{\n  supports[e] += 2;\n  max_ktruss = gk_max(max_ktruss, supports[e]);\n}\n\n", "pragma": "omp parallel for reduction(max: max_ktruss)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/5"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (tx2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/93"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  d = opendir(test_dir[i]);\n  while (((dir = readdir(d)) != NULL) && (count < (img_n + img_m)))\n  {\n    if ((strcmp(dir->d_name, \"..\") != 0) && (strcmp(dir->d_name, \".\") != 0))\n    {\n      strcpy(img_files[count], test_dir[i]);\n      strcat(img_files[count], dir->d_name);\n      for (int j = 0; j < n_classes; j++)\n      {\n        if (j == i)\n        {\n          y->vals[(count * n_classes) + j] = 1;\n        }\n        else\n        {\n          y->vals[(count * n_classes) + j] = 0;\n        }\n\n      }\n\n      count++;\n    }\n\n  }\n\n  closedir(d);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/11"}
{"code": "for (int i = 0; i < kernel_size; i++)\n{\n  for (int j = 0; j < kernel_size; j++)\n  {\n    kernel[(i * kernel_size) + j] = 1.0 / ((double) (kernel_size * kernel_size));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/6"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (m - 1); j++)\n  {\n    resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n    u[i][j] = uold[i][j] - (omega * resid);\n    error = error + (resid * resid);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j ,resid ) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB058-jacobikernel-orig-no/2"}
{"code": "for (int i = 0; i < B; i++)\n{\n  scanf(\"%d%d%d%d\", &attacks[i].X, &attacks[i].Y, &attacks[i].R, &attacks[i].P);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CI4822-EneMar2020/BombingField/src/9"}
{"code": "for (i = 0; i < size; i++)\n{\n  ii = i * size;\n  for (k = 0; k < size; k++)\n  {\n    for (j = 0; j < size; j++)\n    {\n      C[ii + j] += A[ii + k] * B[(k * size) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimmyv9/parallel-matrix/lab2/2"}
{"code": "for (int i = 0; i < spheres.size(); i++)\n{\n  if (spheres[i].motionblur)\n    centre = v->add(spheres[i].centre, v->multiply(v->subtract(spheres[i].centre2, spheres[i].centre), time));\n  else\n    centre = spheres[i].centre;\n\n  tmp = v->subtract(origin, centre);\n  c = v->dot(tmp, tmp) - (spheres[i].radius * spheres[i].radius);\n  b = v->dot(v->multiply(tmp, 2.0), ray);\n  det = (b * b) - ((4 * a) * c);\n  if (det > 0)\n  {\n    t = min((((-1) * b) + sqrt(det)) / (2 * a), (((-1) * b) - sqrt(det)) / (2 * a));\n    if (t > 0)\n    {\n      p = v->add(origin, v->multiply(ray, t));\n      dist = v->magnitude(v->subtract(p, ray));\n      if (dist < sphere_intersection_point.dist)\n        sphere_intersection_point.fill(dist, p, spheres[i].dc, spheres[i].ac, spheres[i].sc, spheres[i].ka, spheres[i].kd, spheres[i].ks, spheres[i].pc, spheres[i].ID, spheres[i].mirror, v->normalize(v->subtract(p, centre)));\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmrHMorsy/Raytracer/src/Scene/4"}
{"code": "for (int k = 0; k < no_counter; k++)\n{\n  buffer_score += solution[no_outgoing_nodes[k]];\n}\n\n", "pragma": "          #pragma omp for reduction(+:buffer_score)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank - C\u00f3pia/page_rank/2"}
{"code": "for (int x = 0; x < MAP_SIZE; ++x)\n{\n  for (int y = 0; y < MAP_SIZE; ++y)\n  {\n    overlayAtPoint(frame, opacityOffset, opacityScale, getOverlay, getAlpha, x, y);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/VideoOutput/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  dcomplexe cc = v[i];\n  printf(\"(%f, %f) \", cc.REEL, cc.IMAG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/axpy/4"}
{"code": "for (int i = 0; i < layers[nOfLayers - 1].nOfNeurons; i++)\n{\n  error += target[i] * log(layers[nOfLayers - 1].neurons[i].out);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/12"}
{"code": "for (j = i - 1; j >= 0; --j)\n{\n  if (list[j] > max.val)\n  {\n    max.val = list[j];\n    max.index = j;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(maximum:max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_7/programme/selection_sort_omp/0"}
{"code": "for (int x = 0; x < BOID_SEGMENTS_PER_DIM; x++)\n{\n  for (int y = 0; y < BOID_SEGMENTS_PER_DIM; y++)\n  {\n    for (int z = 0; z < BOID_SEGMENTS_PER_DIM; z++)\n    {\n      ComputeBoidsSteering(ivec3(x, y, z));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(3) schedule(nonmonotonic:dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/4"}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (j + depth) + ((k - 1) * ((x_max + x_inc) + (2 * depth)));\n  field[FTNREF2D(j, y_min - k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = bottom_rcv_buffer[FTNREF1D(index, 1)];\n}\n\n", "pragma": "omp for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/pack_kernel_c/6"}
{"code": "for (i = 0; i < dimensions; i++)\n{\n  distance += (p1->coordinates[i] - p2->coordinates[i]) * (p1->coordinates[i] - p2->coordinates[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/12"}
{"code": "for (i = 0; i < heigth; i++)\n{\n  matrix[i] = (float *) malloc((sizeof(float)) * width);\n  if (matrix[i] == 0)\n  {\n    printf(\"No se pudo asignar memoria\\n\");\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NicolasRomeroF/mandelbrot_openmp/mandelbrotp/1"}
{"code": "for (int process_id = MASTER + 1; process_id < mpi_num_processes; process_id++)\n{\n  if (ended[process_id] == true)\n    continue;\n\n  if (MPI_Recv(&result_length, 1, MPI_INT, process_id, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)\n    ERR(\"MPI_Recv@get_results\");\n\n  if (MPI_Recv(result, result_length, MPI_CHAR, process_id, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)\n    ERR(\"MPI_Recv@get_results\");\n\n  if (strcmp(result, END) == 0)\n  {\n    num_processes_ended++;\n    ended[process_id] = true;\n  }\n  else\n  {\n    result_string = string(result);\n    escape_pos = result_string.find_last_of(ESCAPE_CHAR);\n    itemset = result_string.substr(0, escape_pos);\n    support = stoi(result_string.substr(escape_pos + 1));\n    if (results.find(itemset) == results.end())\n      results[itemset] = support;\n    else\n      results[itemset] += support;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paoloiannino/PFP-Growth/src/pfp_growth/1"}
{"code": "for (int i = 0; i < tmp; i++)\n{\n  int arrNum = node->localPrimeList[i];\n  if (arrNum == 0)\n    continue;\n  else\n    if ((num % arrNum) == 0)\n  {\n    isPrime = 0;\n    break;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Osmanyasal/openmpExamples/5-primeNumbers/parallelPrime/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"%d\\t%g\\n\", omp_get_thread_num(), rannum());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialFull/Rannum/parallel/rannum/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  particles[j].part_id = j;\n  particles[j].vx = 0.0;\n  particles[j].vy = 0.0;\n  particles[j].fx = 0.0;\n  particles[j].fy = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkmandke/nbody/src/barnes_openmp/0"}
{"code": "for (i = 0; i < ng; i++)\n{\n  for (j = 0; j < ng; j++)\n  {\n    copy_to_fft_array(i, j, -1, f, fft_data_local);\n    if (flag == 0)\n      gsl_fft_complex_radix2_inverse(fft_data_local, 1, ng);\n\n    if (flag == 1)\n      gsl_fft_complex_radix2_forward(fft_data_local, 1, ng);\n\n    copy_from_fft_array(i, j, -1, f, fft_data_local);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/Gpower/fft/3"}
{"code": "for (i = 0; i < 100; i++)\n  printf(\"A[%d]:%d\\n\", i, A[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLSTS/ThreadProgramming/OpenMP_ArrayCountGE500/2"}
{"code": "for (int i = 0; i < K; i++)\n  while (true)\n{\n  int randIndex = rand() % dataset.size();\n  if (find(clusterIndices.begin(), clusterIndices.end(), randIndex) == clusterIndices.end())\n  {\n    clusterIndices.push_back(randIndex);\n    clusters.push_back(dataset[clusterIndices[i]]);\n    break;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/7"}
{"code": "for (i = 0; i < 1048576; i++)\n{\n  fprintf(stdout, \"Thread [%02d]: h_c[%07d]: %f\\n\", omp_get_thread_num(), i, h_c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-omp-parallel-for-combined-schedule-dynamic-chunk-value/2"}
{"code": "for (i = 1; i < (10000 + 1); i++)\n{\n  for (j = 1; j < (10000 + 1); j++)\n  {\n    x = x + log(pow(2.71828, pow(sin(pow(1.1, 1.1)), 1.1) + 1.0) + 1.0);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter7/tt/0"}
{"code": "for (i = 0; i < (length_n - start_n); i++)\n{\n  y[i] = (x[i] * a) + y[i];\n}\n\n", "pragma": "omp parallel for simd private(i) num_threads(num_cores)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/axpy/axpy_itlmic_kernel/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src;\n  uint32_t dest = v;\n  uint64_t weight = DoubleToFixed64(0.0001f);\n  Nodes = graph->vertices[dest].outNodes;\n  degree = graph->vertices[dest].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    src = Nodes->dest;\n    Nodes = Nodes->next;\n    vector_output[dest] += MULFixed64V1(weight, vector_input[src]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/17"}
{"code": "for (int i = 0; i < s2->Time.size(); i++)\n  Time.push_back(s2->Time[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/118"}
{"code": "for (int i = 0; i < N; i++)\n{\n  (cout << c[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/ForChunk/ForChunk/Source/2"}
{"code": "for (j = 0; j < THEME_COUNT; j++)\n{\n  if (strcmp(theme[j].name, optarg) == 0)\n  {\n    t = j;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/beejjorgensen/goatbrot/goatbrot/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/3"}
{"code": "for (int e = 0; e < gr->E; e++)\n{\n  int u = (get < 0) > gr->edge_array[e];\n  int v = (get < 1) > gr->edge_array[e];\n  gr->weights[e] = (gr->weights[e] + h[u]) - h[v];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/7"}
{"code": "for (int i = 0; i < B_row; i++)\n{\n  for (int j = 0; j < B_col; j++)\n  {\n    fscanf(input, \"%d\", &B[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coherent17/Matrix-Multiplication-optimize-by-OpenMP/Parallel_Matrix_Multiplication_With_Openmp/ijk_optimize/4"}
{"code": "for (j = 0; j < K; j++)\n{\n  fprintf(fout, \"Cluster: %d\\n\", j);\n  for (i = 0; i < num_points; i++)\n  {\n    if (cluster[i] == j)\n    {\n      fprintf(fout, \"(%f,%f) \\n\", DataList[i].x, DataList[i].y);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bahaa29/k_mean-with-openmp/main/6"}
{"code": "for (i = 0; i <= m; i++)\n{\n  w[i] = 0.1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/3"}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == output[index][0])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/krb5pa-md5_fmt_plug/5"}
{"code": "for (int i = 0; i < totalNucleotides; i++)\n{\n  if (allDNA.at(i) == 'N')\n  {\n    countN++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BinnyDaBin/DNA-Frequency/dna_freq/5"}
{"code": "for (i = 0; i < 50; i++)\n  c[i] = i;\n\n", "pragma": "omp parallel for shared (c, chunk) schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/sharing-3/0"}
{"code": "for (i = 0; i < (dimensions - 1); i++)\n{\n  if (!fscanf(fp, \"%lf, \", &dataset[index + i]))\n    return -1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/2"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  for (wJ = 0; wJ < BIGN_MATR; wJ++)\n  {\n    aMatr3[wI][wJ] = 0;\n    for (wK = 0; wK < BIGN_MATR; wK += 2)\n    {\n      wTemp[0] = aMatr2[wK][wJ];\n      wTemp[1] = aMatr2[wK + 1][wJ];\n      wTemp[2] = aMatr2[wK + 2][wJ];\n      wTemp[3] = aMatr2[wK + 3][wJ];\n      wV1 = _mm_load_pd(&aMatr1[wI][wK]);\n      wV2 = _mm_load_pd(wTemp);\n      wV3 = _mm_dp_pd(wV1, wV2, 0xFF);\n      _mm_store_pd(wTemp, wV3);\n      aMatr3[wI][wJ] += wTemp[0];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/6"}
{"code": "for (i = 1; i <= NODESX; i++)\n  TOPO[i][0] = TOPO[i][NODESY];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/130"}
{"code": "for (i = 0; i < i_end; i++)\n{\n  Csr2_row_ptr[i] = row_ptr[i] / mtx_width;\n}\n\n", "pragma": "                #pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/CSR2/CSR2_SPMV/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/65"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  if (jouer_coup(cs, &newPos, pos, joueur, i))\n  {\n    const int val = valeur_minimaxAB(cs, &newPos, !joueur, alpha, beta, pmax - 1, gagne);\n    if (val < beta)\n    {\n      beta = val;\n    }\n\n    if (beta <= alpha)\n    {\n      return beta;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/17"}
{"code": "for (i = 0; i < MAXDIM; i++)\n{\n  for (j = 0; j <= i; j++)\n  {\n    PTUpdateEntry(arr, i, j, (((j == 0) || (i == 0)) || (i == j)) ? (1) : (arr[i - 1][j] + arr[i - 1][j - 1]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sendevour/openmp-samples/fpt/0"}
{"code": "for (i = 0; i != 10; i++)\n  ++i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/8"}
{"code": "for (j = 1; j <= 1000; j++)\n{\n  diff = diff - j;\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(-:diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_reduction/1"}
{"code": "for (index = 0; index < count; index += 3)\n{\n  struct \n  {\n    union \n    {\n      unsigned char m[64];\n      unsigned char m4[4][16];\n      ARCH_WORD m4w[4][16 / ARCH_SIZE];\n    } u;\n  } ctx[3];\n  int password_length;\n  memset(ctx[0].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index]);\n  memset(ctx[0].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[0].u.m4[1], saved_key[index], password_length);\n  memcpy(ctx[0].u.m4[2], ctx[0].u.m4[1], 16);\n  memset(ctx[1].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index + 1]);\n  memset(ctx[1].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[1].u.m4[1], saved_key[index + 1], password_length);\n  memcpy(ctx[1].u.m4[2], ctx[1].u.m4[1], 16);\n  memset(ctx[2].u.m4[0], 0, 16);\n  password_length = strlen(saved_key[index + 2]);\n  memset(ctx[2].u.m4[1], 16 - password_length, 16);\n  memcpy(ctx[2].u.m4[1], saved_key[index + 2], password_length);\n  memcpy(ctx[2].u.m4[2], ctx[2].u.m4[1], 16);\n  lotus_transform_password(ctx[0].u.m4[1], ctx[0].u.m4[3], ctx[1].u.m4[1], ctx[1].u.m4[3], ctx[2].u.m4[1], ctx[2].u.m4[3]);\n  lotus_mix(ctx[0].u.m, ctx[1].u.m, ctx[2].u.m);\n  memcpy(ctx[0].u.m4[1], ctx[0].u.m4[3], 16);\n  memcpy(ctx[1].u.m4[1], ctx[1].u.m4[3], 16);\n  memcpy(ctx[2].u.m4[1], ctx[2].u.m4[3], 16);\n  {\n    int i;\n    for (i = 0; i < (16 / ARCH_SIZE); i++)\n    {\n      ctx[0].u.m4w[2][i] = ctx[0].u.m4w[0][i] ^ ctx[0].u.m4w[1][i];\n      ctx[1].u.m4w[2][i] = ctx[1].u.m4w[0][i] ^ ctx[1].u.m4w[1][i];\n      ctx[2].u.m4w[2][i] = ctx[2].u.m4w[0][i] ^ ctx[2].u.m4w[1][i];\n    }\n\n  }\n  lotus_mix(ctx[0].u.m, ctx[1].u.m, ctx[2].u.m);\n  memcpy(crypt_key[index], ctx[0].u.m4[0], 16);\n  memcpy(crypt_key[index + 1], ctx[1].u.m4[0], 16);\n  memcpy(crypt_key[index + 2], ctx[2].u.m4[0], 16);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus5_fmt_plug/0"}
{"code": "for (int k = kk_min; k < kk_max; k += 2)\n{\n  for (int j = jj_min; j < jj_max; j += 2)\n  {\n    for (int i = ii_min; i < ii_max; i += 2)\n    {\n      temp = 0.5 * evaluate_array3d_bndy(array3d, N, i, j, k, recvarray);\n      temp += (1.0 / 12.0) * (((((evaluate_array3d_bndy(array3d, N, i + 1, j, k, recvarray) + evaluate_array3d_bndy(array3d, N, i - 1, j, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j + 1, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j - 1, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j, k + 1, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j, k - 1, recvarray));\n      fill_array3d(new_X, new_N, i / 2, j / 2, k / 2, temp);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/0"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = 1; j < M; j++)\n  {\n    norm = T[(i * M) + j] - T_source[(i * M) + j];\n    if (norm < 0)\n      norm = norm * (-1);\n\n    if (norm > max_norm)\n    {\n      max_norm = norm;\n      *i_max = i;\n      *j_max = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dxAdam/Parallel_Programming/Parallel_Poisson/openMP/poissonOMP/4"}
{"code": "for (int i = 0; i < 3731; ++i)\n{\n  for (int j = 0; j < 5716; ++j)\n  {\n    int s = 0;\n    for (int k = 0; k < 5; ++k)\n    {\n      s += data[((i + dx[k]) + 3731) % 3731][((j + dy[k]) + 5716) % 5716];\n    }\n\n    ans[i][j] = clamp(s / 5, 0, 255);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main1/0"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  if (x[i] > maxval)\n  {\n    maxval = x[i];\n    maxloc = i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-3/parallel/0"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  if (tt->ind[m][i] != tt->ind[m][j])\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prashant-vishwakarma/OpenMP-Reduction/src/minmax/3"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  h_c[i] = h_a[i] + h_b[i];\n}\n\n", "pragma": "omp parallel for num_threads (number_of_threads) schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-multiple-omp-parallel-for-combined-schedule-runtime/1"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 0; k <= (nz - 1); k++)\n    {\n      flux[i][j][k][0] = u[i][j][k][3];\n      u41 = u[i][j][k][3] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = u[i][j][k][1] * u41;\n      flux[i][j][k][2] = u[i][j][k][2] * u41;\n      flux[i][j][k][3] = (u[i][j][k][3] * u41) + (C2 * (u[i][j][k][4] - q));\n      flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u41;\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n      }\n\n    }\n\n    for (k = 1; k <= (nz - 1); k++)\n    {\n      tmp = 1.0 / u[i][j][k][0];\n      u21k = tmp * u[i][j][k][1];\n      u31k = tmp * u[i][j][k][2];\n      u41k = tmp * u[i][j][k][3];\n      u51k = tmp * u[i][j][k][4];\n      tmp = 1.0 / u[i][j][k - 1][0];\n      u21km1 = tmp * u[i][j][k - 1][1];\n      u31km1 = tmp * u[i][j][k - 1][2];\n      u41km1 = tmp * u[i][j][k - 1][3];\n      u51km1 = tmp * u[i][j][k - 1][4];\n      flux[i][j][k][1] = tz3 * (u21k - u21km1);\n      flux[i][j][k][2] = tz3 * (u31k - u31km1);\n      flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * (((pow2(u21k) + pow2(u31k)) + pow2(u41k)) - ((pow2(u21km1) + pow2(u31km1)) + pow2(u41km1)))) + (((1.0 / 6.0) * tz3) * (pow2(u41k) - pow2(u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      rsd[i][j][k][0] = rsd[i][j][k][0] + ((dz1 * tz1) * ((u[i][j][k - 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k + 1][0]));\n      rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][1] - flux[i][j][k][1]))) + ((dz2 * tz1) * ((u[i][j][k - 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k + 1][1]));\n      rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][2] - flux[i][j][k][2]))) + ((dz3 * tz1) * ((u[i][j][k - 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k + 1][2]));\n      rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][3] - flux[i][j][k][3]))) + ((dz4 * tz1) * ((u[i][j][k - 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k + 1][3]));\n      rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][4] - flux[i][j][k][4]))) + ((dz5 * tz1) * ((u[i][j][k - 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][1][m] = rsd[i][j][1][m] - (dssp * ((((+5.0) * u[i][j][1][m]) - (4.0 * u[i][j][2][m])) + u[i][j][3][m]));\n      rsd[i][j][2][m] = rsd[i][j][2][m] - (dssp * (((((-4.0) * u[i][j][1][m]) + (6.0 * u[i][j][2][m])) - (4.0 * u[i][j][3][m])) + u[i][j][4][m]));\n    }\n\n    for (k = 3; k <= (nz - 4); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][nz - 3][m] = rsd[i][j][nz - 3][m] - (dssp * (((u[i][j][nz - 5][m] - (4.0 * u[i][j][nz - 4][m])) + (6.0 * u[i][j][nz - 3][m])) - (4.0 * u[i][j][nz - 2][m])));\n      rsd[i][j][nz - 2][m] = rsd[i][j][nz - 2][m] - (dssp * ((u[i][j][nz - 4][m] - (4.0 * u[i][j][nz - 3][m])) + (5.0 * u[i][j][nz - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/83"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d executes loop iteration %d\\n\", omp_get_thread_num(), i);\n  a[i] = i;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.12-two-for-loops/0"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  if ((x[i] >= t[i]) && (eps >= (x[i] - t[i])))\n  {\n    c = c + 1;\n    if ((x[i] < t[i]) && (eps >= (t[i] - x[i])))\n      c = c + 1;\n\n  }\n\n}\n\n", "pragma": "omp for reduction( +:c )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joulook/Parallel-Processing-Spring-2021/Parallel Jacobi Method/Parallel Jacobi/parallelJacobi/5"}
{"code": "for (j = 0; j < y; j++)\n{\n  int lefter;\n  nmin = 0;\n  nmax = 0;\n  lefter = 0;\n  for (i = 0; i < x; i++)\n  {\n    n = (i + 6) - nmin;\n    xa0[n] = zxa[i];\n    dx0[n] = zdx[i];\n    xa[n] = zxa[i];\n    dx[n] = zdx[i];\n    if (dom[i][j][k] == 0)\n    {\n      state = DOM_FLUID;\n      rho_1D[n] = rho[i][j][k];\n      pre_1D[n] = pre[i][j][k];\n      vx_1D[n] = vx[i][j][k];\n      vy_1D[n] = vy[i][j][k];\n      vz_1D[n] = vz[i][j][k];\n      if (advection == 1)\n        marker_1D[n] = marker[i][j][k];\n\n      if (with_obstacles == 1)\n        pressure_solid_1D[n] = pressure_on_solid[i][j][k];\n\n      pre_1D[n] = max_sweep_x(smallp, pre_1D[n]);\n      eng_1D[n] = (pre_1D[n] / (rho_1D[n] * Gamma)) + (0.5 * ((pow(vx_1D[n], 2) + pow(vy_1D[n], 2)) + pow(vz_1D[n], 2)));\n      if (viscosity_on_off == 1)\n      {\n        if (dimension > 1)\n        {\n          if (((j > 0) && (dom[i][j - 1][k] == 0)) && (j < (y - 1)))\n          {\n            rhodown[n] = rho_visc[i][j - 1][k];\n            vxdown[n] = vx_visc[i][j - 1][k];\n            vydown[n] = vy_visc[i][j - 1][k];\n            vzdown[n] = vz_visc[i][j - 1][k];\n          }\n\n          if (((j > 0) && (dom[i][j - 1][k] != 0)) && (j < (y - 1)))\n          {\n            rhodown[n] = 0.0;\n            vxdown[n] = 0.0;\n            vydown[n] = 0.0;\n            vzdown[n] = 0.0;\n          }\n\n          if (j == 0)\n          {\n            if (bound.down == 0)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.down == 1)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.down == 2)\n              rhodown[n] = small;\n\n            if (bound.down == 3)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.down == 4)\n              rhodown[n] = inflow_density;\n\n            if (bound.down == 5)\n              rhodown[n] = rho_visc[i][y - 1][k];\n\n            if (bound.down == 0)\n              vxdown[n] = vx_visc[i][j][k];\n\n            if (bound.down == 1)\n              vxdown[n] = -vx_visc[i][j][k];\n\n            if (bound.down == 2)\n              vxdown[n] = small;\n\n            if (bound.down == 3)\n              vxdown[n] = vx_visc[i][j][k];\n\n            if (bound.down == 4)\n              vxdown[n] = 0.0;\n\n            if (bound.down == 5)\n              vxdown[n] = vx_visc[i][y - 1][k];\n\n            if (bound.down == 0)\n              vydown[n] = vy_visc[i][j][k];\n\n            if (bound.down == 1)\n              vydown[n] = -vy_visc[i][j][k];\n\n            if (bound.down == 2)\n              vydown[n] = small;\n\n            if (bound.down == 3)\n            {\n              if (vy_visc[i][j][k] > 0.0)\n                vydown[n] = small;\n\n              if (vy_visc[i][j][k] <= 0.0)\n                vydown[n] = vy_visc[i][j][k];\n\n            }\n\n            if (bound.down == 4)\n              vydown[n] = inflow_velocity;\n\n            if (bound.down == 5)\n              vydown[n] = vy_visc[i][y - 1][k];\n\n            if (bound.down == 0)\n              vzdown[n] = vz_visc[i][j][k];\n\n            if (bound.down == 1)\n              vzdown[n] = -vz_visc[i][j][k];\n\n            if (bound.down == 2)\n              vzdown[n] = small;\n\n            if (bound.down == 3)\n              vzdown[n] = vz_visc[i][j][k];\n\n            if (bound.down == 4)\n              vzdown[n] = 0.0;\n\n            if (bound.down == 5)\n              vzdown[n] = vz_visc[i][y - 1][k];\n\n            rhoup[n] = rho_visc[i][j + 1][k];\n            vxup[n] = vx_visc[i][j + 1][k];\n            vyup[n] = vy_visc[i][j + 1][k];\n            vzup[n] = vz_visc[i][j + 1][k];\n          }\n\n          if (((j < (y - 1)) && (dom[i][j + 1][k] == 0)) && (j > 0))\n          {\n            rhoup[n] = rho_visc[i][j + 1][k];\n            vxup[n] = vx_visc[i][j + 1][k];\n            vyup[n] = vy_visc[i][j + 1][k];\n            vzup[n] = vz_visc[i][j + 1][k];\n          }\n\n          if (((j < (y - 1)) && (dom[i][j + 1][k] != 0)) && (j > 0))\n          {\n            rhoup[n] = 0.0;\n            vxup[n] = 0.0;\n            vyup[n] = 0.0;\n            vzup[n] = 0.0;\n          }\n\n          if (j == (y - 1))\n          {\n            if (bound.up == 0)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.up == 1)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.up == 2)\n              rhoup[n] = small;\n\n            if (bound.up == 3)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.up == 4)\n              rhoup[n] = inflow_density;\n\n            if (bound.up == 5)\n              rhoup[n] = rho_visc[i][0][k];\n\n            if (bound.up == 0)\n              vxup[n] = vx_visc[i][j][k];\n\n            if (bound.up == 1)\n              vxup[n] = -vx_visc[i][j][k];\n\n            if (bound.up == 2)\n              vxup[n] = small;\n\n            if (bound.up == 3)\n              vxup[n] = vx_visc[i][j][k];\n\n            if (bound.up == 4)\n              vxup[n] = 0.0;\n\n            if (bound.up == 5)\n              vxup[n] = vx_visc[i][0][k];\n\n            if (bound.up == 0)\n              vyup[n] = vy_visc[i][j][k];\n\n            if (bound.up == 1)\n              vyup[n] = -vy_visc[i][j][k];\n\n            if (bound.up == 2)\n              vyup[n] = small;\n\n            if (bound.up == 3)\n            {\n              if (vy_visc[i][j][k] < 0.0)\n                vyup[n] = small;\n\n              if (vy_visc[i][j][k] >= 0.0)\n                vyup[n] = vy_visc[i][j][k];\n\n            }\n\n            if (bound.up == 4)\n              vyup[n] = inflow_velocity;\n\n            if (bound.up == 5)\n              vyup[n] = vy_visc[i][0][k];\n\n            if (bound.up == 0)\n              vzup[n] = vz_visc[i][j][k];\n\n            if (bound.up == 1)\n              vzup[n] = -vz_visc[i][j][k];\n\n            if (bound.up == 2)\n              vzup[n] = small;\n\n            if (bound.up == 3)\n              vzup[n] = vz_visc[i][j][k];\n\n            if (bound.up == 4)\n              vzup[n] = 0.0;\n\n            if (bound.up == 5)\n              vzup[n] = vz_visc[i][0][k];\n\n            rhodown[n] = rho_visc[i][j - 1][k];\n            vxdown[n] = vx_visc[i][j - 1][k];\n            vydown[n] = vy_visc[i][j - 1][k];\n            vzdown[n] = vz_visc[i][j - 1][k];\n          }\n\n        }\n\n        if (dimension > 2)\n        {\n          if (((k > 0) && (dom[i][j][k - 1] == 0)) && (k < (z - 1)))\n          {\n            rhofront[n] = rho_visc[i][j][k - 1];\n            vxfront[n] = vx_visc[i][j][k - 1];\n            vyfront[n] = vy_visc[i][j][k - 1];\n            vzfront[n] = vz_visc[i][j][k - 1];\n          }\n\n          if (((k > 0) && (dom[i][j][k - 1] != 0)) && (k < (z - 1)))\n          {\n            rhofront[n] = 0.0;\n            vxfront[n] = 0.0;\n            vyfront[n] = 0.0;\n            vzfront[n] = 0.0;\n          }\n\n          if (k == 0)\n          {\n            if (bound.front == 0)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 1)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 2)\n              rhofront[n] = small;\n\n            if (bound.front == 3)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 4)\n              rhofront[n] = inflow_density;\n\n            if (bound.front == 5)\n              rhofront[n] = rho_visc[i][j][z - 1];\n\n            if (bound.front == 0)\n              vxfront[n] = vx_visc[i][j][k];\n\n            if (bound.front == 1)\n              vxfront[n] = -vx_visc[i][j][k];\n\n            if (bound.front == 2)\n              vxfront[n] = small;\n\n            if (bound.front == 3)\n              vxfront[n] = vx_visc[i][j][k];\n\n            if (bound.front == 4)\n              vxfront[n] = 0.0;\n\n            if (bound.front == 5)\n              vxfront[n] = vx_visc[i][j][z - 1];\n\n            if (bound.front == 0)\n              vyfront[n] = vy_visc[i][j][k];\n\n            if (bound.front == 1)\n              vyfront[n] = -vy_visc[i][j][k];\n\n            if (bound.front == 2)\n              vyfront[n] = small;\n\n            if (bound.front == 3)\n              vyfront[n] = vy_visc[i][j][k];\n\n            if (bound.front == 4)\n              vyfront[n] = 0.0;\n\n            if (bound.front == 5)\n              vyfront[n] = vy_visc[i][y][z - 1];\n\n            if (bound.front == 0)\n              vzfront[n] = vz_visc[i][j][k];\n\n            if (bound.front == 1)\n              vzfront[n] = -vz_visc[i][j][k];\n\n            if (bound.front == 2)\n              vzfront[n] = small;\n\n            if (bound.front == 3)\n            {\n              if (vz_visc[i][j][k] > 0.0)\n                vzfront[n] = small;\n\n              if (vz_visc[i][j][k] <= 0.0)\n                vzfront[n] = vz_visc[i][j][k];\n\n            }\n\n            if (bound.front == 4)\n              vzfront[n] = inflow_velocity;\n\n            if (bound.front == 5)\n              vzfront[n] = vz_visc[i][j][z - 1];\n\n            rhoback[n] = rho_visc[i][j][k + 1];\n            vxback[n] = vx_visc[i][j][k + 1];\n            vyback[n] = vy_visc[i][j][k + 1];\n            vzback[n] = vz_visc[i][j][k + 1];\n          }\n\n          if (((k < (z - 1)) && (dom[i][j][k + 1] == 0)) && (k > 0))\n          {\n            rhoback[n] = rho_visc[i][j][k + 1];\n            vxback[n] = vx_visc[i][j][k + 1];\n            vyback[n] = vy_visc[i][j][k + 1];\n            vzback[n] = vz_visc[i][j][k + 1];\n          }\n\n          if (((k < (z - 1)) && (dom[i][j][k + 1] != 0)) && (k > 0))\n          {\n            rhoback[n] = 0.0;\n            vxback[n] = 0.0;\n            vyback[n] = 0.0;\n            vzback[n] = 0.0;\n          }\n\n          if (k == (z - 1))\n          {\n            if (bound.back == 0)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 1)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 2)\n              rhoback[n] = small;\n\n            if (bound.back == 3)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 4)\n              rhoback[n] = inflow_density;\n\n            if (bound.back == 5)\n              rhoback[n] = rho_visc[i][j][0];\n\n            if (bound.back == 0)\n              vxback[n] = vx_visc[i][j][k];\n\n            if (bound.back == 1)\n              vxback[n] = -vx_visc[i][j][k];\n\n            if (bound.back == 2)\n              vxback[n] = small;\n\n            if (bound.back == 3)\n              vxback[n] = vx_visc[i][j][k];\n\n            if (bound.back == 4)\n              vxback[n] = 0.0;\n\n            if (bound.back == 5)\n              vxback[n] = vx_visc[i][j][0];\n\n            if (bound.back == 0)\n              vyback[n] = vy_visc[i][j][k];\n\n            if (bound.back == 1)\n              vyback[n] = -vy_visc[i][j][k];\n\n            if (bound.back == 2)\n              vyback[n] = small;\n\n            if (bound.back == 3)\n              vyback[n] = vy_visc[i][j][k];\n\n            if (bound.back == 4)\n              vyback[n] = 0.0;\n\n            if (bound.back == 5)\n              vyback[n] = vy_visc[i][j][0];\n\n            if (bound.back == 0)\n              vzback[n] = vz_visc[i][j][k];\n\n            if (bound.back == 1)\n              vzback[n] = -vz_visc[i][j][k];\n\n            if (bound.back == 2)\n              vzback[n] = small;\n\n            if (bound.back == 3)\n            {\n              if (vz_visc[i][j][k] < 0.0)\n                vzback[n] = small;\n\n              if (vz_visc[i][j][k] >= 0.0)\n                vzback[n] = vz_visc[i][j][k];\n\n            }\n\n            if (bound.back == 4)\n              vzback[n] = inflow_velocity;\n\n            if (bound.back == 5)\n              vzback[n] = vz_visc[i][j][01];\n\n            rhofront[n] = rho_visc[i][j][k - 1];\n            vxfront[n] = vx_visc[i][j][k - 1];\n            vyfront[n] = vy_visc[i][j][k - 1];\n            vzfront[n] = vz_visc[i][j][k - 1];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (dom[i][j][k] == 1)\n    {\n      state = DOM_SOLID;\n      rho_1D[n] = obstacle_density;\n      pre_1D[n] = obstacle_temperature;\n      vx_1D[n] = 0.0;\n      vy_1D[n] = 0.0;\n      vz_1D[n] = 0.0;\n      if (advection == 1)\n        marker_1D[n] = 0.0;\n\n      if (with_obstacles == 1)\n        pressure_solid_1D[n] = 0.0;\n\n      pre_1D[n] = 0.0;\n      eng_1D[n] = 0.0;\n    }\n\n\n    if (i < (x - 1))\n    {\n      state_next = (dom[i + 1][j][k] == 0) ? (DOM_FLUID) : (DOM_SOLID);\n    }\n    else\n    {\n      state_next = (state == DOM_FLUID) ? (DOM_SOLID) : (DOM_FLUID);\n    }\n\n    if (state != state_next)\n    {\n      if (state == DOM_FLUID)\n      {\n        int bound_checker;\n        int ii;\n        int nminx2 = 6;\n        int nmaxx2 = (nmax - nmin) + 6;\n        if ((nmin == 0) || (nmax == (x - 1)))\n        {\n          bound_checker = 0;\n        }\n\n        if ((nmax - nmin) != (x - 1))\n        {\n          bound_checker = 1;\n          if (nmin == 0)\n            lefter = 1;\n\n          if (nmax == (x - 1))\n            lefter = 2;\n\n          if ((nmin != 0) && (nmax != (x - 1)))\n            lefter = 3;\n\n        }\n\n        ppm_step(i, j, k, direction, flag, nminx2, nmaxx2, a_coef, ai_coef, b_coef, bi_coef, c_coef, ci_coef, d_x, diffa, da, ar, pl, p6, rl, r6, u6, ul, vl, v6, wl, w6, el, e6, ql, q6, dp, du, dr, dv, dw, dq, de, scratch1, scratch2, scratch3, plft, prgh, ulft, urgh, rlft, rrgh, Cdtdx, fCdtdx, steep, flat, para, clft, crgh, plfti, prghi, pmid, pmold, wlft, wrgh, zlft, zrgh, umidl, umidr, umid, dm, dtbdm, upmid, xa1, xa2, xa3, vx_1D_old, dvol, dvol0, dvol1, delta, fluxr, fluxu, fluxv, fluxw, fluxe, fluxq, dm0, e_int_1D, rho_1D, pre_1D, eng_1D, vx_1D, vy_1D, vz_1D, marker_1D, pressure_solid_1D, dx0, xa0, xa, dx, bound_checker, lefter, rhodown, rhoup, rhofront, rhoback, vxdown, vxup, vxfront, vxback, vydown, vyup, vyfront, vyback, vzdown, vzup, vzfront, vzback, viscosity_on_off, dimension);\n        for (ii = nmin; ii <= nmax; ii++)\n        {\n          n = (ii + 6) - nmin;\n          rho[ii][j][k] = rho_1D[n];\n          pre[ii][j][k] = pre_1D[n];\n          vx[ii][j][k] = vx_1D[n];\n          vy[ii][j][k] = vy_1D[n];\n          vz[ii][j][k] = vz_1D[n];\n          if (advection == 1)\n            marker[ii][j][k] = marker_1D[n];\n\n          if (with_obstacles == 1)\n            pressure_on_solid[ii][j][k] = pressure_solid_1D[n];\n\n        }\n\n      }\n      else\n        if (state == DOM_SOLID)\n      {\n        nmin = nmax + 1;\n      }\n\n\n    }\n\n    nmax++;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/sweep_x/0"}
{"code": "for (k = 0; k < dims[2]; k++)\n{\n  x0 = starts[k];\n  for (j = 0; j < dims[1]; j++)\n  {\n    vranlc(2 * NX, &x0, A, (double *) (&u0[k][j][0]));\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(k,j,x0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/7"}
{"code": "for (int i = 0; i < n; i++)\n  a[i] = v[i];\n\n", "pragma": "#pragma omp target teams distribute parallel for map(a, v[:N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/nvptx_target_teams_distribute_parallel_for_codegen/4"}
{"code": "for (int x = 0; x < grid_dim_.first; x++)\n{\n  for (int y = 0; y < grid_dim_.second; y++)\n  {\n    if (grid_[x][y] == 1)\n    {\n      cout << \"\\u2588\";\n    }\n    else\n    {\n      cout << \".\";\n    }\n\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apallath/GameOfLife/src/Game/3"}
{"code": "for (i = 0; i < (numberOfSpots - 1); i++)\n{\n  temp = 0;\n  for (int j = 0; j < dimensions; j++)\n  {\n    temp += pow(Xarr[(i * dimensions) + j] - getVP(tree)[j], 2);\n  }\n\n  euclideanDistances[i] = sqrt(temp);\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikalaki/Vantage_point_tree_C_and_parallelism/vptree/src/vptree_openmp/0"}
{"code": "for (int i = s0; i < e0; i++)\n{\n  int neighbour_1 = adj[i];\n  int s1 = xadj[neighbour_1];\n  int e1 = xadj[neighbour_1 + 1];\n  for (int j = s1; j < e1; j++)\n  {\n    int neighbour_2 = adj[j];\n    if (neighbour_2 == index)\n      continue;\n\n    int s2 = xadj[neighbour_2];\n    int e2 = xadj[neighbour_2 + 1];\n    for (int k = s2; k < e2; k++)\n    {\n      int neighbour_3 = adj[k];\n      if (neighbour_3 == index)\n      {\n        localcount += 1;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/1"}
{"code": "for (col = norm; col < N; col++)\n{\n  A[row][col] -= A[norm][col] * multiplier;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArbaazShareef/PThreads-and-openMP-Programming/gauss_openMP/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    numoutside += testpoint(c);\n  }\n\n}\n\n", "pragma": "omp parallel for private(c,j) firstprivate(eps) reduction(+:numoutside)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OmpCommonCore/Exercises/C/solutions/mandel_reduction/0"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  A[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp parallel for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanwbrei/openmp_tutorial/src/exfor/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      ru1 = rho_i[i][j][k];\n      uu = us[i][j][k];\n      vv = vs[i][j][k];\n      ww = ws[i][j][k];\n      ac = speed[i][j][k];\n      ac2inv = ainv[i][j][k] * ainv[i][j][k];\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n      t2 = (bt * ru1) * ((uu * r1) - r2);\n      t3 = ((bt * ru1) * ac) * t1;\n      rhs[0][i][j][k] = r1 - t1;\n      rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n      rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n      rhs[3][i][j][k] = (-t2) + t3;\n      rhs[4][i][j][k] = t2 + t3;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(ru1, uu, vv, ww, ac, ac2inv, r1 ,r2 ,r3 ,r4 ,t1 ,t2 ,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/90"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if ((adj_matrix[(i * n) + j] != 0) && (adj_matrix[(i * n) + j] != INT_MAX))\n    {\n      edge_array[ei] = Edge(i, j);\n      weights[ei] = adj_matrix[(i * n) + j];\n      ei++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  part_sums[16 * tid] += A[i];\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/3"}
{"code": "for (i = 0; i < iSize; ++i)\n{\n  ComputeAndSaveColor(i, D, RepresentationFunction, Gradient, C);\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i) shared( D, C, iSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adammaj1/Mandelbrot-set-with-blended-gradients/src/d/2"}
{"code": "for (int i = 0; i < repeat; i++)\n  (bilateralFilter < 6) > ((h_src, h_dst, w, h, a_square, variance_I, variance_spatial));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bilateral-omp/main/4"}
{"code": "for (idx = 0; idx < 30; ++idx)\n{\n  a[idx] = (b[idx] = 1.0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/vec_add/vec_add/0"}
{"code": "for (i = 0; i < num_buckets; i++)\n{\n  tmp = counts[i];\n  offsets[i] = (counts[i] = offset);\n  offset += tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sort/5"}
{"code": "for (j = 0; j < 256; ++j)\n{\n  for (i = 0; i < 256; ++i)\n  {\n    c = get_pixel(i, j, canv);\n    memcpy(&px, &c, sizeof(pixel_t));\n    canvas[j][i] = px;\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lagodiuk/raytracing-render/demo/demo_gl/0"}
{"code": "for (i = length - 2; i >= 0; i--)\n{\n  for (j = 0; j < n; j++)\n  {\n    value = 0.0;\n    for (k = 0; k < n; k++)\n    {\n      if (observations[i + 1] == \"Heads\")\n      {\n        value = value + ((bwk[i + 1][k] * a[j][k]) * b[k][0]);\n      }\n      else\n      {\n        value = value + ((bwk[i + 1][k] * a[j][k]) * b[k][1]);\n      }\n\n    }\n\n    bwk[i][j] = value;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/15"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        lhs[i][j][k][1][m][m] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/19"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  if (vetor[i] == 1)\n  {\n    printf(\"%d\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunaflaviaaoliveira/crivodeeratostene/crivo_openmp/2"}
{"code": "for (i = 0; i < 1024; ++i)\n  a[i] += b[i] * 2;\n\n", "pragma": "omp for simd lastprivate (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/simd-1/1"}
{"code": "for (int i = 0; i < min_num_iterations; i++)\n{\n  flush_send();\n  num_pcls_sent = handle_received_particles();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/4"}
{"code": "for (int i = 0; i < rowA; ++i)\n{\n  for (int j = 0; j < colA; ++j)\n  {\n    int sum = 0;\n    for (int k = 0; k < colB; ++k)\n      sum += (*((matA + (i * colA)) + k)) * (*((matB + (k * colB)) + j));\n\n    *((matC + (i * colB)) + j) = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (ty2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/36"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    masC[i][j] = masA[i][j] + masB[i][j];\n\n}\n\n", "pragma": "#pragma omp parallel for shared(masA,masB,masC) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/8"}
{"code": "for (j = 0; j < total_grid_elem; j++)\n{\n  sum += A[j];\n}\n\n", "pragma": "omp for reduction(+:sum) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlessandroPiccolo/poisson-openmp-solver/source/poisson_parallel/5"}
{"code": "for (unsigned c = 0; c < Count(); c++)\n{\n  string > lines;\n  List[c]->GetConfig(lines);\n  Log->Print(lines);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsDamping/1"}
{"code": "for (CodeLen = MinCodeLen; CodeLen <= MaxCodeLen; ++CodeLen)\n{\n  maxCountIter = pow(lenAlp, CodeLen);\n  blockSize = maxCountIter / numThreads;\n  for (iter = 0; iter < maxCountIter; ++iter)\n  {\n    int tmpIter = iter;\n    int index;\n    for (len = 0; len < CodeLen; ++len)\n    {\n      index = tmpIter % lenAlp;\n      comb[len] = alphabet[index];\n      tmpIter /= lenAlp;\n    }\n\n    comb[CodeLen] = '\\0';\n    GetHash256(comb, CodeLen, strRetHash);\n    if (memcmp(hash, strRetHash, len) == 0)\n    {\n      t2 = omp_get_wtime() - t1;\n      pwd = comb;\n      CurrentPrint(CodeLen, iter, maxCountIter, t1);\n      IsFound = true;\n      return t2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/benchmarks/hackhash/0"}
{"code": "for (int i = k + 1; i < size; i++)\n{\n  double _val = _temp[i];\n  for (int j = k + 1; j < size; j++)\n    a_[i][j] -= _val * _r1[j];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/2"}
{"code": "for (int i = 0; i < Nt; ++i)\n{\n  Xpt.push_back(tp);\n  Ypt.push_back(tp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_parallel_large/5"}
{"code": "for (i = (world_rank * N) / world_size; i < (((world_rank + 1) * N) / world_size); i++)\n{\n  int j;\n  for (j = 0; j < N; j++)\n  {\n    int k;\n    int sum = 0;\n    for (k = 0; k < N; k++)\n      sum += mA[i][k] * mB[k][j];\n\n    mCtemp[i][j] = sum;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for shared(mA,mB,mC)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Robyroc/Project-AGATHA/examples/matrixmpi/0"}
{"code": "for (int n = 0; n < nNonZero; n++)\n{\n  int i = A[n][0];\n  int j = A[n][1];\n  double sum = 0;\n  for (int k = 0; k < nFeatures; k++)\n  {\n    sum += L[i][k] * RT[j][k];\n  }\n\n  B[i][j] = sum;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/0"}
{"code": "for (i = a - 1; i <= (a + 1); i++)\n{\n  for (j = b - 1; j <= (b + 1); j++)\n  {\n    if ((i == a) && (j == b))\n      continue;\n\n    if ((((j < size) && (i < size)) && (i >= 0)) && (j >= 0))\n      a += field[(size * i) + j];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FuzeProg/Game-of-Life-OMP/gol/1"}
{"code": "for (l = 1; l < maxII; l++)\n{\n  int cost[3];\n  int tmp;\n  cost[0] = prev[l - 1] + 1;\n  cost[1] = pprev[l - 1] + (a[q] != b[p]);\n  cost[2] = prev[l] + 1;\n  tmp = (cost[0] < cost[1]) ? (cost[0]) : (cost[1]);\n  tmp = (tmp < cost[2]) ? (tmp) : (cost[2]);\n  act[l] = tmp;\n  p++;\n  q--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/VecRec_Tasks/hirschberg_omp/3"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  vet[i] = matrix[(i * (dimension + 1)) + line];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giovaniortolani/Projeto2-ProgConc/src/gauss/7"}
{"code": "for (row = 1; row <= bheight; row++)\n{\n  for (col = 1; col <= bwidth; col++)\n  {\n    count = 0;\n    int ID = ((bwidth + 2) * row) + col;\n    count = ((((((inmat[ID + (bwidth + 2)] + inmat[ID - (bwidth + 2)]) + inmat[ID + 1]) + inmat[ID - 1]) + inmat[ID + (bwidth + 3)]) + inmat[ID - (bwidth + 3)]) + inmat[ID - (bwidth + 1)]) + inmat[ID + (bwidth + 1)];\n    if ((count < 2) || (count > 3))\n    {\n      newmat[ID] = 0;\n    }\n    else\n      if (count == 2)\n    {\n      newmat[ID] = inmat[ID];\n    }\n    else\n      if (count == 3)\n    {\n      newmat[ID] = 1;\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hanneshoettinger/GameOfLife-Sequential-OpenMP-OpenCL/GameOfLife/GameOfLife/2"}
{"code": "for (int j = mat * width; j < ((sizey / 2) + overlap_j); j++)\n{\n  for (int i = ((mat * width) - (mat > 0)) - ((mat > 0) * overlap_i); i < ((mat + 1) * width); i++)\n  {\n    cc.rho[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n  for (int i = ((sizex - (mat * width)) - 1) + ((mat > 0) * overlap_i); i >= ((sizex - ((mat + 1) * width)) - 1); i--)\n  {\n    cc.rho[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/1"}
{"code": "for (int i = 2; i < n_threads_max; i += n_threads_step)\n{\n  printf(\"\\n%d threads -- \\n\\n\", i);\n  for (j = 1; j < n_parts_max; j += n_parts_step)\n  {\n    tParallel = multiplicarMatricesParaleloGuided(m1, m2, mresParallel, i, j);\n    printf(\"LS= %d -> tm= %lf, \", j, tParallel);\n    printf(\"sp= %lf \", tSerial / tParallel);\n    printf(\"(%d)\\n\", sonIguales(mresSerial, mresParallel));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaelmanzanorivera/matrix-dot-prod-optimization-OpenMP/matricesOmp/8"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    mass_flux_y[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = -mass_flux_y[FTNREF2D(j, 1 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/56"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  cv[i] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jessechoi/goulas-openmp-demos/for/for/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (5.0 * u[m][i][j][k])));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/73"}
{"code": "for (unsigned p = 0; p < np; p++)\n  if (errpart[p] == 1)\n{\n  code[p] = CODE_SetOutIgnore(code[p]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/7"}
{"code": "for (int i = 0; i < totalNodes; i++)\n{\n  int processorNos = mapprocessor2dist[i];\n  if (((processorNos - 2) % 3) == 0)\n  {\n    int nodeNos = (processorNos - 2) / 3;\n    finalDepth[nodeNos] = distance[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac3/EulerTour_EREW_OpenMP/3"}
{"code": "for (int i = 0; i < num_clusters; i++)\n  free(clusters[i].centroid.attributes);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leoli51/Parallel-K-means-Clustering/KMeansMPClustering/4"}
{"code": "for (int i = 0; i < nspecies; ++i)\n  for (int iat = 0; iat < GroupID.size(); ++iat)\n  if (GroupID[iat] == i)\n  IndirectID[new_id++] = ID[iat];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  evaluacion(i, mat);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManuelCMS/HW-2.1/parallel_matrix/0"}
{"code": "for (i = 0; i < (SIZE * SIZE); i++)\n{\n  int x = i % SIZE;\n  int y = i / SIZE;\n  if (inp[x][y] == 0)\n  {\n    int ind;\n    ind = empty_cells++;\n    empty_cells_list[ind].x = x;\n    empty_cells_list[ind].y = y;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/19"}
{"code": "for (int j = 0; j < 800; j++)\n{\n  int as = _mm256_set1_pd(x0s2 + (sgsub * j));\n  for (int k = 0; k < 800; k += 4)\n  {\n    int bs = _mm256_set_pd(y0s2 + (sgsub * (k + 3)), y0s2 + (sgsub * (k + 2)), y0s2 + (sgsub * (k + 1)), y0s2 + (sgsub * (k + 0)));\n    color256(as, bs, (pixels + (j * 800)) + k);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astahfrom/mandelbrot/mandelbrot/0"}
{"code": "for (j = 1; j <= NLat; j++)\n{\n  if ((Node(idx(j, 1), iD) != 0) && (Node(idx(j, 2), iD) == 0))\n    Node(idx(j, 1), iD) = 0.;\n\n  if ((Node(idx(j, NLon), iD) != 0) && (Node(idx(j, NLon - 1), iD) == 0))\n    Node(idx(j, NLon), iD) = 0.;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/6"}
{"code": "for (int neighbor_ind = row_ptr[vertex]; (neighbor_ind < row_ptr[vertex + 1]) && colorValid; neighbor_ind++)\n{\n  const uint neighbor = col_ind[neighbor_ind];\n  if (colors[neighbor] == minColor)\n  {\n    colorValid = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/11"}
{"code": "for (int iBox = 0; iBox < nBoxes; iBox++)\n{\n  for (int iOff = MAXATOMS * iBox, ii = 0; ii < s->boxes->nAtoms[iBox]; ii++, iOff++)\n  {\n    s->atoms->p[iOff][0] += dt * s->atoms->f[iOff][0];\n    s->atoms->p[iOff][1] += dt * s->atoms->f[iOff][1];\n    s->atoms->p[iOff][2] += dt * s->atoms->f[iOff][2];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/timestep/0"}
{"code": "for (int j = 1; j < ny; j += 2)\n{\n  for (int i = 1; i < nx; i += 2)\n  {\n    temp = inv * ((rhs[i + ((nx + 1) * j)] + (hy_2 * (get(i + 1, j) + get(i - 1, j)))) + (hx_2 * (get(i, j + 1) + get(i, j - 1))));\n    set(i, j, temp);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for private (temp) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akjain90/OpenMP-parallized-RBGS-solver/matrix/3"}
{"code": "for (row = 0; row < rows; row++)\n{\n  long length = row_lengths[row];\n  b[row] = (int *) malloc((sizeof(int)) * length);\n  memcpy(b[row], vector[row], length * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kianenigma/pmms-heat-dissipation/assignment_2/vecsort/vecsort/5"}
{"code": "for (int i = 0; i < total_points; i++)\n{\n  int id_old_cluster = points[i].getCluster();\n  int id_nearest_center = getIDNearestCenter(points[i]);\n  if (id_old_cluster != id_nearest_center)\n  {\n    if (id_old_cluster != (-1))\n      clusters[id_old_cluster].removePoint(points[i].getID());\n\n    points[i].setCluster(id_nearest_center);\n    clusters[id_nearest_center].addPoint(points[i]);\n    done = false;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhabesh-chanduka/Parallel-K-Means/kmeans_omp/5"}
{"code": "for (int i = 0; i < ColN; i++)\n{\n  EAssertR(ColV[i].Len() == RowN, Fmt(\"%d != %d\", ColV[i].Len(), RowN));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/5"}
{"code": "for (int i = 1; i < PRIMESIZE; i++)\n  p_str[i] = ((int) ((2.0 * rand()) / (RAND_MAX + 1.0))) + 48;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aalmeidasilva/RSA-OpenMP-MPI/src/rsa/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  arrPoints[i].x = arrPoints[i].x + (time * arrPoints[i].vX);\n  arrPoints[i].y = arrPoints[i].y + (time * arrPoints[i].vY);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/6"}
{"code": "for (int i = 0; i < (n - 1); i++)\n  b[i] = malloc(((sizeof(int *)) * n) - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/4.Eigen_Vector_Values/eigen/1"}
{"code": "for (int i = 0; i < n; ++i)\n  fill(matr[i], m);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/16"}
{"code": "for (i = 0; i < 1024; i++)\n  for (j = 0; j < 1024; j++)\n  local_sum += a[j];\n\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/007_loop_iteration_variable/0"}
{"code": "for (int i = 0; i < firsttable->size; i++)\n{\n  finalresult->current[i] = descent->current[i + firsttable->size];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/3"}
{"code": "for (int ci = 0; ci < NCELLS; ci++)\n{\n  v_x = cell(ci).cal_mean_v(0);\n  v_y = cell(ci).cal_mean_v(1);\n  cur_speed += sqrt((v_x * v_x) + (v_y * v_y));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/109"}
{"code": "for (int i = 0; i < NUMBODIES; i++)\n{\n  for (int j = 0; j < NUMBODIES; j++)\n  {\n    if (j != i)\n    {\n      double dist = distance(p[i], p[j]);\n      double force = 0.0;\n      dist += 1e-7;\n      force = (MASS * MASS) / dist;\n      double x = p[j].cen_x - p[i].cen_x;\n      double y = p[j].cen_y - p[i].cen_y;\n      double z = p[j].cen_z - p[i].cen_z;\n      fx[i] += (force * x) / sqrt(dist);\n      fy[i] += (force * y) / sqrt(dist);\n      fz[i] += (force * z) / sqrt(dist);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) reduction(+: fx, fy, fz)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GChaitanya2001/HP3-OpenMP/Many Body Simulation/many-body-sim-program/0"}
{"code": "for (int block = 0; block < totalBlocks; block++)\n{\n  zfp_stream_close(zfp[block]);\n  stream_close(stream[block]);\n  free(buffer[block]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/utils/compressor/Compressor/7"}
{"code": "for (row = 0; row < NODES_NUM; row++)\n{\n  nextrank_value[row] = max((1.0 / NODES_NUM) / NODES_NUM, nextrank_value[row]);\n  nextrank_value[row] = min(1.0 - ((1.0 / NODES_NUM) / NODES_NUM), nextrank_value[row]);\n  tempsum += nextrank_value[row];\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_count)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhixue/Parrallel-programming-course/hk2_openmp/hw2_3/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = (int *) malloc(n * (sizeof(int)));\n  b[i] = (int *) malloc(n * (sizeof(int)));\n  res[i] = (int *) malloc(n * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/MatrixMul/2"}
{"code": "for (k = 0; k < 10; k++)\n  x[k] = (y + z) + k;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terbos/HPC-OPENMP/barrier1/0"}
{"code": "for (int j = 0; j < ((W * 3) * tailleblock); j++)\n{\n  im[(((3 * tailleblock) * status.MPI_TAG) * W) + j] = ligne[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sheld0/parallel_raytracer/raytracer_block/0"}
{"code": "for (i = n - 2; i >= 0; i--)\n{\n  x[i] = new_a[(i * (n + 1)) + n];\n  for (j = i + 1; j < n; j++)\n  {\n    x[i] = x[i] - (new_a[(i * (n + 1)) + j] * x[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/8"}
{"code": "for (int i = 0; i < arraySize; i++)\n{\n  printf(\"error[%d]: %f\\n\", i, *(error + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/boris109able/online-change-detection-openMP/onlinesimulation_openMP/Source/1"}
{"code": "for (i = 0; i < (64 * (1024 * 1024)); i++)\n  v[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dastyk/Actual-OpenMP/qsort_par/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int eval = evalLine(points[minx_ind], points[maxx_ind], points[i]);\n  if (eval > 0)\n    rig1.pb(points[i]);\n  else\n    if (eval < 0)\n    rig2.pb(points[i]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/quickhull/3"}
{"code": "for (unsigned int i = 0; i < 100; i++)\n{\n  cout << (i / 100.0);\n  for (unsigned int d = 2; d < 17; d++)\n  {\n    (cout << \"\\t\") << histogram[d_idx(d)][i];\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brian-Grant/OpenMPParallelNSpherePointSampling/ndsphere/1"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = ky - 1;\n  if (kl < 0)\n    kl += my1;\n\n  kl = kl * mx1;\n  kr = ky + 1;\n  if (kr >= my1)\n    kr -= my1;\n\n  kr = kr * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = kxr + kk;\n  ks[1] = kxl + kk;\n  ks[2] = kx + kr;\n  ks[3] = kxr + kr;\n  ks[4] = kxl + kr;\n  ks[5] = kx + kl;\n  ks[6] = kxr + kl;\n  ks[7] = kxl + kl;\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 8; ii++)\n  {\n    if (ii > 0)\n      ncoff = ncl[(ii - 1) + (8 * ks[ii])];\n\n    ip = ncl[ii + (8 * ks[ii])] - ncoff;\n    for (j = 0; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        j1 = npp;\n        npp += 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[i + (idimp * (j1 + (nppmx * k)))] = ppbuff[i + (idimp * ((j + ncoff) + (npbmx * ks[ii])))];\n        }\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    for (j = 0; j < ip; j++)\n    {\n      j1 = (npp - j) - 1;\n      j2 = ihole[2 * ((nh - j) + ((ntmax + 1) * k))] - 1;\n      if (j1 > j2)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[i + (idimp * (j2 + (nppmx * k)))] = ppart[i + (idimp * (j1 + (nppmx * k)))];\n        }\n\n      }\n\n    }\n\n    npp -= ip;\n  }\n\n  kpic[k] = npp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,ii,kk,npp,kx,ky,kl,kr,kxl,kxr,ih,nh,ncoff,ist,j1,j2,ip,ks)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/7"}
{"code": "for (int i = 1; i <= num_threads; i++)\n{\n  omp_set_num_threads(i);\n  start_time = omp_get_wtime();\n  for (int j = 0; j < 100; j++)\n    result = dotp(x, y);\n\n  run_time = omp_get_wtime() - start_time;\n  printf(\" %d thread(s) took %f seconds\\n\", i, run_time);\n  if (fabs(serial_result - result) > 0.001)\n  {\n    printf(\"Incorrect result!\\n\");\n    return -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShihengJiang666/ThreadParallelism/dotp/2"}
{"code": "for (int i = 0; i < nState; i++)\n{\n  maxProbOld[i] = initProb[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hmm-omp/ViterbiCPU/1"}
{"code": "for (i = 0; i <= 7; i++)\n{\n  fscanf(fp, \"%d\", &debug_vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/11"}
{"code": "for (i = 0; i < N; i++)\n  A[i] = (int *) malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1b/part1/codes/fw/2"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = b + (a[i] * 5);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB013-nowait-orig-yes/0"}
{"code": "for (step = 1; step <= niter; step += 1)\n{\n  if (((step % 20) == 0) || (step == 1))\n  {\n    printf(\" Time step %4d\\n\", step);\n  }\n\n  adi();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/149"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  count += table[as_bytes[i]];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/2"}
{"code": "for (unsigned long i = 0; i < 1000000000; i++)\n  vector[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielchristo/prog-dist/trabalho_2/1.eratosthenes/sieve/1"}
{"code": "for (j = 1; j < (Ny - 1); j++)\n{\n  for (i = 1; i < (Nx - 1); i++)\n  {\n    Un[i][j] = Unplus1[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saggelit/OpenMp/project2020parallel/7"}
{"code": "for (i = 0; i < (lDIM * nDIM); i++)\n  posix_memalign((float **) (&b[i]), getpagesize(), (BSIZE * BSIZE) * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = 1;\n  l = i;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for lastprivate(l) dist_schedule(static,128) schedule(static,32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/nvptx_target_teams_distribute_parallel_for_codegen/0"}
{"code": "for (long i = id; i < n; i += n_threads)\n{\n  t_sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/agdhruv/omp-parallel/sums/parallel/1"}
{"code": "for (z = slice_start; z < slice_end; z++)\n{\n  if (A[z].valid)\n  {\n    if (0 == supersteps)\n    {\n      edge *curr;\n      for (curr = A[z].edge_head; curr != 0; curr = curr->next)\n      {\n        send_message(curr->id, z, A[z].kcore, A);\n      }\n\n    }\n    else\n    {\n      if (1 == (supersteps & 1))\n      {\n        offsets[tid] += process_message(z, A);\n      }\n      else\n      {\n        if (A[z].active)\n        {\n          edge *curr;\n          for (curr = A[z].edge_head; curr != 0; curr = curr->next)\n          {\n            send_message(curr->id, z, A[z].kcore, A);\n            offsets[tid] = 1;\n          }\n\n        }\n        else\n        {\n          ;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tjj5036/kcore-openmp/parallel_kcore/6"}
{"code": "for (i = 1; i < (h - 1); i++)\n{\n  for (j = 1; j < (w - 1); j++)\n  {\n    curr_generation[i][j] = next_generation[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uros99/OpenMP-MPI-CUDA/OpenMP/gameoflife/2"}
{"code": "for (unsigned int i = 0; i < nodesTagsEdge.size(); ++i)\n{\n  for (unsigned int j = 0; j < nodesTagsElement.size(); ++j)\n  {\n    if (nodesTagsEdge[i] == nodesTagsElement[j])\n      edge.offsetInElm.push_back(j);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgregov/Multiphysics/srcs/mesh/Mesh/0"}
{"code": "for (int i = 0; i < nb_proc; i++)\n{\n  machines[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adahn/Project_Parallelism/version2/MPI/main/3"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  if (cell(ci).inside_hopper)\n    val += (0.5 * cell(ci).inertia) * pow(cell(ci).angularV, 2);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/124"}
{"code": "for (int i = 0; i <= K; i++)\n  if (log_file)\n  fprintf(log_file, \"%d - Y %g dY %g\\n\", i, Y[i], dLy[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/58"}
{"code": "for (i = 5; i < 16; i = i + bar(i))\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/15"}
{"code": "for (i = 0; i < lin; i++)\n{\n  menor[i] = matriz[i * col];\n  maior[i] = matriz[((i * col) + col) - 1];\n  mediana[i] += matriz[(i * col) + (col / 2)];\n  mediana[i] += matriz[((i * col) + (col / 2)) - 1];\n  mediana[i] *= 0.5;\n}\n\n", "pragma": "omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-zanetti/Metricas-Estatisticas-OpenMP-C/parallel_mestatisticas_openmp/3"}
{"code": "forceWall = (double *) malloc(((sizeof(double)) * numParticles) * 3)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/2"}
{"code": "for (unsigned int ii = 0; ii < corrs.size(); ++ii)\n{\n  for (int j = 0; j < corrs[i]->get_Np(); ++j)\n  {\n    current_idx++;\n    if (current_idx == i)\n    {\n      return ii;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  correct &= rgba[i].x == bgr[i].z;\n  correct &= rgba[i].y == bgr[i].y;\n  correct &= rgba[i].z == bgr[i].x;\n  correct &= rgba[i].w == 255;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Blaieet/Parallel-Computing/P1 - OpenMP/main/0"}
{"code": "for (int i = 0; i < dims; i++)\n  distance += pow(pointA[i] - pointB[i], 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/distance/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n  }\n\n  lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(m ,k ,fac1 ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/161"}
{"code": "for (int i = 0; i < level; i++)\n  choose_option(instance, ctx, buffer[i + 1], -1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/29"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"thread %d ejecuta la iteraci\u00f3n %d del bucle\\n\", omp_get_thread_num(), i);\n  printf(\"Elapsed time: %11.9f\\t\\n\", omp_get_wtime() - a);\n  printf(\"/V1[%d]+V2[%d](%8.6f+%8.6f=%8.6f)/\\n\", i, i, i, v1[i], v2[i], v3[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica1/ejercicio7/0"}
{"code": "for (i = 0; i < n; ++i)\n  array[i] = (rand() % ((upper - lower) + 1)) + lower;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/count_sort/count_sort_parallel/1"}
{"code": "for (i = 0; i < 1700; i++)\n{\n  int n_neighbour = (rand() % 1700) + 1;\n  j = 0;\n  int count = 0;\n  while (count < n_neighbour)\n  {\n    if (j == i)\n    {\n      G[i][j] = 0;\n      C[i][j] = 0;\n      D[i][j] = 0;\n    }\n    else\n    {\n      int alpha = rand();\n      if (alpha < (0.25 * 2147483647))\n      {\n        int weight = rand() % 100;\n        G[i][j] = 1;\n        C[i][j] = weight;\n        D[i][j] = weight;\n        count++;\n      }\n\n    }\n\n    j = (j + 1) % 1700;\n  }\n\n  G[i][i] = 0;\n  C[i][i] = 0;\n  D[i][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dmitrybbch/parallelized-floyd-warshall/floydwarshall/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n  }\n\n  lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,k,m) firstprivate (n,j1,j2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/184"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int x = 0; x < GRAIN; x++)\n  {\n    for (int y = 0; y < GRAIN; y++)\n    {\n      if (current_array[(x * GRAIN) + y] == 1)\n      {\n        current_array[(x * GRAIN) + y] = 0;\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            compute_new_state(i, j);\n            if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n            {\n              next_array[(x * GRAIN) + y] = 1;\n              if (((i % TILEX) == 0) && (x > 0))\n              {\n                next_array[((x - 1) * GRAIN) + y] = 1;\n                if (((j % TILEY) == 0) && (y > 0))\n                {\n                  next_array[((x - 1) * GRAIN) + (y - 1)] = 1;\n                }\n\n                if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n                {\n                  next_array[((x - 1) * GRAIN) + (y + 1)] = 1;\n                }\n\n              }\n\n              if (((i % TILEX) == (TILEX - 1)) && (x < (GRAIN - 1)))\n              {\n                next_array[((x + 1) * GRAIN) + y] = 1;\n                if (((j % TILEY) == 0) && (y > 0))\n                {\n                  next_array[((x + 1) * GRAIN) + (y - 1)] = 1;\n                }\n\n                if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n                {\n                  next_array[((x + 1) * GRAIN) + (y + 1)] = 1;\n                }\n\n              }\n\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[(x * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[(x * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n            if (next_img(i, j) != 0xFFFF00FF)\n            {\n              next_img(i, j) = 0xFF0000FF;\n            }\n\n          }\n\n        }\n\n      }\n      else\n      {\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            if (next_img(i, j) != 0xFFFF00FF)\n            {\n              next_img(i, j) = 0;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  swap_images();\n  int *tmp = current_array;\n  current_array = next_array;\n  next_array = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/23"}
{"code": "for (j = 0; j < n; ++j)\n  (void) printf(\"%d = %d\\n\", j + 0, freq[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/char_freq/char_freq_parallel_array_of_locks_global/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += r[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/9"}
{"code": "for (n = 0; n < 10; ++n)\n{\n  hist[n] += h1[n];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/neha-boloor/Parallel-Computing---Otsu/otsu_omp_critical/5"}
{"code": "for (i = 0; i < max_iterations; i++)\n{\n  display(univ, w, h);\n  if (!survivors(univ, w, h))\n  {\n    break;\n  }\n\n  fprintf(stderr, \"Iteration %u\\n\", i);\n  evolve(univ, w, h);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/8"}
{"code": "for (j = 0; j < nbuffer[ThisTask]; j++)\n{\n  force_treeevaluate_potential(j, 1);\n}\n\n", "pragma": "omp parallel for schedule(guided,8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/potential/1"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (cj = 0; cj < NCELLS; cj++)\n  {\n    if (cj == ci)\n      (cout << \"0\") << \"  \";\n    else\n      (cout << contacts(ci, cj)) << \"  \";\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/53"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (fabs(c[i] - 3.f) > 0.00001f)\n  {\n    printf(\"Incorrect answer at index %d\\n\", i);\n    correct_results = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/advanced-hpc-examples/OpenMP/vecadd-openmp/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  TID = 0;\n  printf(\"Thread %d updates a[%d]\\n\", TID, i);\n  a[i] += i;\n  {\n    printf(\"Thread %d prints value of a[%d] = %d\\n\", TID, i, a[i]);\n  }\n}\n\n", "pragma": "omp parallel for default(none) ordered schedule(runtime) private(i,TID) shared(n,a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.74-ordered/1"}
{"code": "for (int k = 0; k < M; k++)\n{\n  norm_arr[k] = (c_norm * ii_bit[k]) + (a_norm * (!ii_bit[k]));\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  xtemp = x[i];\n  ytemp = y[i];\n  x[i] = (xtemp * cos(angle)) + (ytemp * sin(angle));\n  y[i] = ((-xtemp) * sin(angle)) + (ytemp * cos(angle));\n}\n\n", "pragma": "omp parallel for firstprivate(n,xtemp,ytemp,angle)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/2"}
{"code": "for (k = 0; k < 10; k++)\n{\n  printf(\".\");\n  fflush(stdout);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-CSC/exercises-gpu/stream-gpu/task1-basics/stream/0"}
{"code": "for (vj = nvtxs - 1; vj >= (nvtxs - maxhmsize); vj--)\n{\n  if (((xadj[vj + 1] - uxadj[vj]) == 1) || (xadj[vj] == uxadj[vj]))\n    continue;\n\n  nlocal = 0;\n  if ((xadj[vj + 1] - uxadj[vj]) == (nvtxs - vj))\n  {\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (ei = uxadj[vi]; adjncy[ei] > vj; ei++)\n        ;\n\n      nlocal += ei - uxadj[vi];\n      nprobes += ei - uxadj[vi];\n    }\n\n  }\n  else\n  {\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 1;\n\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (eiend = uxadj[vi]; adjncy[eiend] > vj; eiend++)\n        ;\n\n      for (ei = uxadj[vi]; ei < eiend; ei++)\n        nlocal += hmap[adjncy[ei]];\n\n      nprobes += ei - uxadj[vi];\n    }\n\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 0;\n\n  }\n\n  if (nlocal > 0)\n    ntriangles += nlocal;\n\n}\n\n", "pragma": "omp for schedule(dynamic,DBSIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/15"}
{"code": "for (size_t ib = 0; ib < n; ib += bf)\n  for (size_t kb = 0; kb < n; kb += bf)\n  for (size_t jb = 0; jb < n; jb += bf)\n{\n  {\n    for (size_t i = ib; i < (ib + bf); ++i)\n      for (size_t k = kb; k < (kb + bf); ++k)\n      for (size_t j = jb; j < (jb + bf); ++j)\n      C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];\n\n\n\n  }\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-2/04-matmul/solution/matmul/0"}
{"code": "for (i = 0; line[i] != '\\0'; i++)\n{\n  line[i] = toupper(line[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/hash_mpi/8"}
{"code": "for (indice = 0; indice < filasXproceso; indice++)\n{\n  arbolesContagiando = 0;\n  vecinosVisitados = 0;\n  if (indice > 0)\n  {\n    if (matrizLocal[indice - 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 1].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice > 1)\n  {\n    if (matrizLocal[indice - 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 2].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 1))\n  {\n    if (matrizLocal[indice + 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 1].fila < 1500)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 2))\n  {\n    if (matrizLocal[indice + 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 2].fila < 1500)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < 1500)\n  {\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + 1500].fila)\n    {\n      if (arregloArriba[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + 1500].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((matrizLocal[indice].fila - 1) == arregloArriba[indice + (1500 + 1)].fila) && (indice < (1500 - 1)))\n    {\n      if (arregloArriba[indice + (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (1500 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + (1500 - 1)].fila)\n    {\n      if (arregloArriba[indice + (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (1500 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 1500].fila)\n    {\n      if (matrizLocal[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 1500].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 1500)].fila)\n    {\n      if (matrizLocal[indice + (2 * 1500)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 1500)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice > (1500 - 1)) && (indice < (1500 * 2)))\n  {\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 1500].fila)\n    {\n      if (matrizLocal[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 1500].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 1500].fila)\n    {\n      if (matrizLocal[indice - 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 1500].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((indice - (1500 + 1)) >= 0) && ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 + 1)].fila))\n    {\n      if (matrizLocal[indice - (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (1500 * 2)) && (indice < (filasXproceso - (2 * 1500))))\n  {\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 1500].fila)\n    {\n      if (matrizLocal[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 + 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 - 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 1500)].fila)\n    {\n      if (matrizLocal[indice + (2 * 1500)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 1500)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 1500].fila)\n    {\n      if (matrizLocal[indice - 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 + 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 - 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 1500)].fila)\n    {\n      if (matrizLocal[indice - (2 * 1500)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 1500)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (filasXproceso - (1500 * 2))) && (indice < (filasXproceso - 1500)))\n  {\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajo].fila)\n    {\n      if (arregloAbajo[indiceAbajo].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajo].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 1500].fila)\n    {\n      if (matrizLocal[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice + (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (1500 - 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 1500].fila)\n    {\n      if (matrizLocal[indice - 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 + 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 - 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (1500 * 2)].fila)\n    {\n      if (matrizLocal[indice - (1500 * 2)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 * 2)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if ((indice >= (filasXproceso - 1500)) && (indice < filasXproceso))\n  {\n    if (indiceAbajoB == 1500)\n    {\n      indiceAbajoB = 0;\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB].fila)\n    {\n      if (arregloAbajo[indiceAbajoB].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (indiceAbajoB > 0)\n    {\n      if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB - 1].fila)\n      {\n        if (arregloAbajo[indiceAbajoB - 1].color == 3)\n        {\n          arbolesContagiando++;\n        }\n\n        if (arregloAbajo[indiceAbajoB - 1].fila < 1500)\n        {\n          vecinosVisitados++;\n        }\n\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB + 1].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 1].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 1].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajoB + 1500].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 1500].fila)\n    {\n      if (matrizLocal[indice - 1500].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 1500].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 + 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 + 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (1500 - 1)].fila)\n    {\n      if (matrizLocal[indice - (1500 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (1500 - 1)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 1500)].fila)\n    {\n      if (matrizLocal[indice - (2 * 1500)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 1500)].fila < 1500)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if (matrizLocal[indice].edad < 157)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.35 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.35;\n    }\n\n  }\n\n  if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.17 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.17;\n    }\n\n  }\n\n  if (matrizLocal[indice].edad >= 1821)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.63 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.63;\n    }\n\n  }\n\n  matrizLocalAux[indice].edad += 1;\n  if (matrizLocal[indice].color == 4)\n  {\n    matrizLocalAux[indice].semanasInfectado += 1;\n    matrizLocalAux[indice].semanasTotales++;\n  }\n\n  if (matrizLocal[indice].semanasInfectado == 3)\n  {\n    matrizLocalAux[indice].color = 3;\n  }\n\n  if (matrizLocal[indice].color == 3)\n  {\n    matrizLocalAux[indice].semanasTotales++;\n    if ((rand() % 100) <= 85)\n    {\n      matrizLocalAux[indice].color = 2;\n      matrizLocalAux[indice].semanasInfectado = 0;\n      matrizLocalAux[indice].semanasTotales += 1;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 2)\n  {\n    if (matrizLocal[indice].semanasTotales <= 8)\n    {\n      matrizLocalAux[indice].semanasTotales++;\n    }\n    else\n    {\n      if (matrizLocal[indice].edad < 157)\n      {\n        if ((rand() % 100) > 3)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n      {\n        if ((rand() % 100) > 15)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if (matrizLocal[indice].edad >= 1821)\n      {\n        if ((rand() % 100) > 53)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n          matrizLocalAux[indice].edad = 57;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 1)\n  {\n    if (matrizLocal[indice].semanasPodado <= 12)\n    {\n      matrizLocalAux[indice].semanasPodado++;\n    }\n    else\n    {\n      matrizLocalAux[indice].color = 5;\n      matrizLocalAux[indice].semanasPodado = 0;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 5)\n  {\n    porcentajeEnfermos = (float) (arbolesContagiando / vecinosVisitados);\n    probabilidadContagio = (((float) (porcentajeEnfermos + susceptibilidad)) * 0.60) + 0.07;\n    if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n    {\n      matrizLocalAux[indice].color = 4;\n    }\n\n  }\n\n  if (semana > 0)\n  {\n    probHeridas = rand() % 101;\n    if ((matrizLocal[indice].edad < 157) && (probHeridas < 23))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if (((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821)) && (probHeridas < 8))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if ((matrizLocal[indice].edad >= 1821) && (probHeridas < 37))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(indice,indiceAbajoB, susceptibilidad, porcentajeEnfermos, probabilidadContagio, probHeridas, arbolesContagiando, vecinosVisitados) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalHibrido1500/1"}
{"code": "for (int k = 0; k < 4; k++)\n  for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    matrix_local[i][j][k] = 0.0;\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/0"}
{"code": "for (int i = 1; i <= GRID_SIZE; i++)\n{\n  for (int j = 1; j <= GRID_SIZE; j++)\n  {\n    A[idx][0] = i * h;\n    A[idx][1] = j * h;\n    idx += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sharatchandraj/Gaussian-Process-Regression-OpenMP/GPR/2"}
{"code": "for (i = 0; i < (LX1 - 1); i++)\n{\n  idmo[iel][face][1][0][0][i] = mor_s_v[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/27"}
{"code": "for (int frame = 1; frame < nframes; ++frame)\n{\n  for (int i = 0; i < npframe; ++i)\n  {\n    leapfrog1(n, dt, x, v, a);\n    apply_reflect(n, x, v, a);\n    compute_forces(n, x, a, params);\n    leapfrog2(n, dt, v, a);\n  }\n\n  write_frame_data(fp, n, x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project2/nbody/nbomp/6"}
{"code": "for (int i = queue_front; i <= queue_rear; i++)\n{\n  queue[i]->solutions = 0;\n  solve(instance, queue[i]);\n  solutions += queue[i]->solutions;\n}\n\n", "pragma": "omp parallel for reduction(+:solutions) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/0"}
{"code": "for (i = offset + 1; i < (offset + (n - 1)); i++)\n{\n  for (j = 1; j < (m - 1); j++)\n  {\n    resid = ((((ax * (uold[j + ((i - 1) * m)] + uold[j + ((i + 1) * m)])) + (ay * (uold[(j - 1) + (i * m)] + uold[(j + 1) + (i * m)]))) + (b * uold[j + (i * m)])) - f[j + (i * m)]) / b;\n    u[j + (i * m)] = uold[j + (i * m)] - (omega * resid);\n    err_tmp = err_tmp + (resid * resid);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(uold,u,f, offset, ax,ay,b,omega,n) private(resid,j,i) reduction(+:err_tmp)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/jacobi-ompacc-multiGPU/1"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  primes[i] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/prime/prime/0"}
{"code": "for (i = 0; i < Entries_N; i++)\n{\n  Error_T[i] = Entries[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/10"}
{"code": "for (i = 0; i < 9; i++)\n{\n  for (j = 0; j < 9; j++)\n  {\n    printf(\"%d   \", table[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] += b[i] + c[i];\n}\n\n", "pragma": "#pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-parallel-for-back2back/test/1"}
{"code": "for (i = 0; i < maxIter; i++)\n{\n  stop = gauss(a, localI, localJ);\n  MPI_Gather(&stop, 1, (MPI_Datatype) 0x4c000405, 0, 1, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  if (has_north(my_rank))\n  {\n    int neighbor = my_rank - ichunk;\n    MPI_Sendrecv(a + localJ, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, north_buff, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    for (j = 0; j < localJ; j++)\n    {\n      a[j] = north_buff[j];\n    }\n\n  }\n\n  if (has_south(my_rank))\n  {\n    int neighbor = my_rank + ichunk;\n    double *send_buff = &a[((localI - 2) * localJ) + 0];\n    MPI_Sendrecv(send_buff, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, south_buff, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    for (j = 0; j < localJ; j++)\n    {\n      a[((localI - 1) * localJ) + j] = south_buff[j];\n    }\n\n  }\n\n  if (has_west(my_rank))\n  {\n    int neighbor = my_rank - 1;\n    double *send_buff = malloc((sizeof(double)) * localI);\n    for (j = 0; j < localI; j++)\n    {\n      send_buff[j] = a[(j * localJ) + 1];\n    }\n\n    MPI_Sendrecv(send_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, west_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    free(send_buff);\n    for (j = 0; j < localI; j++)\n    {\n      a[(j * localJ) + 0] = west_buff[j];\n    }\n\n  }\n\n  if (has_east(my_rank))\n  {\n    int neighbor = my_rank + 1;\n    double *send_buff = malloc((sizeof(double)) * localI);\n    for (j = 0; j < localI; j++)\n    {\n      send_buff[j] = a[(j * localJ) + (localJ - 2)];\n    }\n\n    MPI_Sendrecv(send_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, east_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    free(send_buff);\n    for (j = 0; j < localI; j++)\n    {\n      a[(j * localJ) + (localJ - 1)] = east_buff[j];\n    }\n\n  }\n\n  MPI_Bcast(&should_continue, 1, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  if (should_continue == 0)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  (((myfile << macd[i]) << \",\") << signal[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harshnagarkar/OpenMP-MACD-performance-evaluator/stock_macd_omp/2"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      const int index = (((ii * _chunk.y) * _chunk.x) + (jj * _chunk.x)) + kk;\n      const double smvp = SMVP(u);\n      w[index] = smvp;\n      r[index] = u[index] - w[index];\n      p[index] = r[index];\n      rroTemp += r[index] * p[index];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:rroTemp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_cg_kernel/3"}
{"code": "for (row = 0; row < n; row++)\n{\n  if (((!(rowmask & (1 << row))) & (!(dia1 & (1 << (row + col))))) & (!(dia2 & (1 << (((row + n) - 1) - col)))))\n  {\n    ans += call(col + 1, rowmask | (1 << row), dia1 | (1 << (row + col)), dia2 | (1 << (((row + n) - 1) - col)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shafaet/OpenMP-Examples/Parallel N-Queen problem/1"}
{"code": "for (i = 0; i < nd; i++)\n{\n  if (c1[i] == 0)\n  {\n    for (j = 0; j < nd; j++)\n    {\n      x1[j] = x1[j] + (last_x1[i] / ((double) nd));\n    }\n\n  }\n  else\n  {\n    for (j = 0; j < c1[i]; j++)\n    {\n      pos = L1[i][j];\n      x1[pos] = x1[pos] + (last_x1[i] / ((double) c1[i]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/girihemant19/Pagerank-serial-C-and-parallel-openMp-/pagerank_openMp/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (house[i].distance < min_val)\n  {\n    min_val = house[i].distance;\n    closestHouseID = i;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AllynVo/Simple-Parallel-Computing-with-OpenMP/Source Code Allyn_openmp/Allyn_final_project/Allyn_final_project/2"}
{"code": "for (int i = 0; i < nb_nodes; ++i)\n{\n  if (__builtin_expect(mesh->isCorner(i), 0))\n    sync.activ[i] = -1;\n  else\n    sync.activ[i] = (char) ((mesh->topo.stenc[i].empty()) ? (0) : (1));\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/0"}
{"code": "for (unsigned int it = 0; it < learning_set_count; ++it)\n{\n  learning_set[it].distance(test_point);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main_fast/0"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int x = 0; x < GRAIN; x++)\n  {\n    for (int y = 0; y < GRAIN; y++)\n    {\n      if (current_array[(x * GRAIN) + y] == 1)\n      {\n        current_array[(x * GRAIN) + y] = 0;\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            compute_new_state(i, j);\n            if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n            {\n              for (int k = max(0, x - 1); k <= min(GRAIN - 1, x + 1); k++)\n                for (int l = max(0, y - 1); l <= min(GRAIN - 1, y + 1); l++)\n                next_array[(k * GRAIN) + l] = 1;\n\n\n            }\n\n            if (next_img(i, j) != 0xFFFF00FF)\n            {\n              next_img(i, j) = 0xFF0000FF;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  swap_images();\n  int *tmp = current_array;\n  current_array = next_array;\n  next_array = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/26"}
{"code": "for (i = 1; i < (size - 1); i++)\n{\n  for (j = 1; j < (size - 1); j++)\n  {\n    output[(i * size) + j] = ((a * (((input[(((i - 1) * size) + j) - 1] + input[(((i - 1) * size) + j) + 1]) + input[(((i + 1) * size) + j) + 1]) + input[(((i + 1) * size) + j) - 1])) + (b * (((input[((i - 1) * size) + j] + input[((i + 1) * size) + j]) + input[((i * size) + j) + 1]) + input[((i * size) + j) - 1]))) + (c * input[(i * size) + j]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/texasfight/OpenMP_HW1/parallel_script/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (d = 0; d < 3; d++)\n  {\n    rms[m] = rms[m] / ((double) (grid_points[d] - 2));\n  }\n\n  double _imopVarPre192;\n  double _imopVarPre193;\n  _imopVarPre192 = rms[m];\n  _imopVarPre193 = sqrt(_imopVarPre192);\n  rms[m] = _imopVarPre193;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/SP/sp-wrongSVE/4"}
{"code": "for (i = iend; i >= ist; i += -1)\n{\n  for (j = jend; j >= jst; j += -1)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i + 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tx1) * dx1;\n    a[i][j][0][1] = dt * tx2;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = 0.0;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = ((dt * tx2) * (((-(u[i + 1][j][k][1] * tmp1)) * (u[i + 1][j][k][1] * tmp1)) + (((0.40e+00 * 0.50) * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i + 1][j][k][1]));\n    a[i][j][1][1] = (((dt * tx2) * ((2.0 - 0.40e+00) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    a[i][j][1][2] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][2] * tmp1));\n    a[i][j][1][3] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][3] * tmp1));\n    a[i][j][1][4] = (dt * tx2) * 0.40e+00;\n    a[i][j][2][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][2]));\n    a[i][j][2][1] = (dt * tx2) * (u[i + 1][j][k][2] * tmp1);\n    a[i][j][2][2] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    a[i][j][2][3] = 0.0;\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][3]));\n    a[i][j][3][1] = (dt * tx2) * (u[i + 1][j][k][3] * tmp1);\n    a[i][j][3][2] = 0.0;\n    a[i][j][3][3] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    a[i][j][3][4] = 0.0;\n    a[i][j][4][0] = ((dt * tx2) * ((((0.40e+00 * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2) - (1.40e+00 * (u[i + 1][j][k][4] * tmp1))) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i + 1][j][k][1] * u[i + 1][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][2] * u[i + 1][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) - ((c1345 * tmp2) * u[i + 1][j][k][4])));\n    a[i][j][4][1] = ((dt * tx2) * ((1.40e+00 * (u[i + 1][j][k][4] * tmp1)) - ((0.50 * 0.40e+00) * (((((3.0 * u[i + 1][j][k][1]) * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i + 1][j][k][1]);\n    a[i][j][4][2] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][2] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][2]);\n    a[i][j][4][3] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][3] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][3]);\n    a[i][j][4][4] = (((dt * tx2) * (1.40e+00 * (u[i + 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n    tmp1 = 1.0 / u[i][j + 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = dt * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = ((dt * ty2) * ((-(u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][1]));\n    b[i][j][1][1] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = (dt * ty2) * (u[i][j + 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = ((dt * ty2) * (((-(u[i][j + 1][k][2] * tmp1)) * (u[i][j + 1][k][2] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j + 1][k][2]));\n    b[i][j][2][1] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][1] * tmp1));\n    b[i][j][2][2] = (((dt * ty2) * ((2.0 - 0.40e+00) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][3] * tmp1));\n    b[i][j][2][4] = (dt * ty2) * 0.40e+00;\n    b[i][j][3][0] = ((dt * ty2) * ((-(u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = (dt * ty2) * (u[i][j + 1][k][3] * tmp1);\n    b[i][j][3][3] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = ((dt * ty2) * ((((0.40e+00 * (((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) * tmp2) - (1.40e+00 * (u[i][j + 1][k][4] * tmp1))) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j + 1][k][1] * u[i][j + 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j + 1][k][2] * u[i][j + 1][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) - ((c1345 * tmp2) * u[i][j + 1][k][4])));\n    b[i][j][4][1] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][1]);\n    b[i][j][4][2] = ((dt * ty2) * ((1.40e+00 * (u[i][j + 1][k][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + ((3.0 * u[i][j + 1][k][2]) * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j + 1][k][2]);\n    b[i][j][4][3] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][3]);\n    b[i][j][4][4] = (((dt * ty2) * (1.40e+00 * (u[i][j + 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i][j][k + 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tz1) * dz1;\n    c[i][j][0][1] = 0.0;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = dt * tz2;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = ((dt * tz2) * ((-(u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][1]));\n    c[i][j][1][1] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    c[i][j][1][2] = 0.0;\n    c[i][j][1][3] = (dt * tz2) * (u[i][j][k + 1][1] * tmp1);\n    c[i][j][1][4] = 0.0;\n    c[i][j][2][0] = ((dt * tz2) * ((-(u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][2]));\n    c[i][j][2][1] = 0.0;\n    c[i][j][2][2] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    c[i][j][2][3] = (dt * tz2) * (u[i][j][k + 1][2] * tmp1);\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = ((dt * tz2) * (((-(u[i][j][k + 1][3] * tmp1)) * (u[i][j][k + 1][3] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k + 1][3]));\n    c[i][j][3][1] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][1] * tmp1));\n    c[i][j][3][2] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][2] * tmp1));\n    c[i][j][3][3] = ((((dt * tz2) * (2.0 - 0.40e+00)) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    c[i][j][3][4] = (dt * tz2) * 0.40e+00;\n    c[i][j][4][0] = ((dt * tz2) * ((((0.40e+00 * (((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) * tmp2) - (1.40e+00 * (u[i][j][k + 1][4] * tmp1))) * (u[i][j][k + 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k + 1][1] * u[i][j][k + 1][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k + 1][2] * u[i][j][k + 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) - ((c1345 * tmp2) * u[i][j][k + 1][4])));\n    c[i][j][4][1] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][1]);\n    c[i][j][4][2] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][2]);\n    c[i][j][4][3] = ((dt * tz2) * ((1.40e+00 * (u[i][j][k + 1][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + ((3.0 * u[i][j][k + 1][3]) * u[i][j][k + 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k + 1][3]);\n    c[i][j][4][4] = (((dt * tz2) * (1.40e+00 * (u[i][j][k + 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n  }\n\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,i,j) firstprivate (ist,jst,jend)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/59"}
{"code": "for (unsigned int m = 0; m < cell_num_height; ++m)\n{\n  r_sum = 0;\n  g_sum = 0;\n  b_sum = 0;\n  for (unsigned int n = 0; n < cell_size; ++n)\n  {\n    index = ((((m * image->width) * cell_size) + (n * image->width)) + (cell_num_weight * cell_size)) * 3;\n    for (unsigned int l = 0; l < cell_remain_weight; ++l)\n    {\n      r_sum += p_data[index + (l * 3)];\n      g_sum += p_data[(index + (l * 3)) + 1];\n      b_sum += p_data[(index + (l * 3)) + 2];\n    }\n\n  }\n\n  num_in_cell = cell_remain_weight * cell_size;\n  r = (unsigned char) (r_sum / num_in_cell);\n  g = (unsigned char) (g_sum / num_in_cell);\n  b = (unsigned char) (b_sum / num_in_cell);\n  for (unsigned int n = 0; n < cell_size; ++n)\n  {\n    index = ((((m * image->width) * cell_size) + (n * image->width)) + (cell_num_weight * cell_size)) * 3;\n    for (unsigned int q = 0; q < cell_remain_weight; ++q)\n    {\n      p_data[index + (q * 3)] = r;\n      p_data[(index + (q * 3)) + 1] = g;\n      p_data[(index + (q * 3)) + 2] = b;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NYXFLOWER/Mosaics-CUDA-OpenMP/photo_mosaic/mosaic/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpsejujq1t.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/exaloop/openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (i = 1; i < m; i++)\n{\n  if (y[i] != i)\n  {\n    errors += 1;\n    if (errors == 1)\n      printf(\"for - VALUES IN Y ARE NOT AS EXPECTED\\n\");\n\n    printf(\"EXPECTED Y[%d] = %d OBSERVED %d\\n\", i, i, y[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny04/ocl_tiny04/tiny04/4"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j][k - 1][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/61"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  ++(*size_colors)[color[i] - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/30"}
{"code": "for (uint i = 2; i <= N; i++)\n{\n  if (isPrime[i])\n  {\n    if (((i * 1LL) * i) <= N)\n    {\n      for (uint j = i * i; j <= N; j += i)\n        isPrime[j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe/3"}
{"code": "for (k = 0; k < N; ++k)\n{\n  kn = k * N;\n  for (i = start_i; i <= end_i; ++i)\n  {\n    ik = (i * N) + k;\n    in = i * N;\n    if (dist[ik] < 9999999)\n    {\n      for (j = 0; j < unroll_end; j += 8)\n      {\n        int ij = in + j;\n        int kj = kn + j;\n        int ij_values = _mm256_load_si256(&dist[ij]);\n        int ik_values = _mm256_set1_epi32(dist[ik]);\n        int kj_values = _mm256_load_si256(&dist[kj]);\n        int sums = _mm256_add_epi32(ik_values, kj_values);\n        int results = _mm256_min_epi32(sums, ij_values);\n        _mm256_storeu_si256(&dist[ij], results);\n      }\n\n      for (l = l_start; l < N; ++l)\n      {\n        int kl = kn + l;\n        int il = in + l;\n        int sum = dist[ik] + dist[kl];\n        dist[il] = (sum < dist[il]) ? (sum) : (dist[il]);\n      }\n\n    }\n\n  }\n\n  pthread_barrier_wait(&bar);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/5"}
{"code": "for (int i = 0; i < u->get_size()[0]; ++i)\n{\n  (cout << u->get_const_values()[i]) << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ginkgo-project/ginkgo/examples/custom-matrix-format/custom-matrix-format/0"}
{"code": "for (i = 0; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    switch (world_indexer[i][j].type)\n    {\n      case 1:\n        printf(\"%d %d %c\\n\", i, j, 's');\n        break;\n\n      case 2:\n        printf(\"%d %d %c\\n\", i, j, 'w');\n        break;\n\n      case 3:\n        printf(\"%d %d %c\\n\", i, j, 't');\n        break;\n\n      case 4:\n        printf(\"%d %d %c\\n\", i, j, 'i');\n        break;\n\n      case 5:\n        printf(\"%d %d %c\\n\", i, j, '$');\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfcorreia/squirrels/src/wolves-squirrels-omp/3"}
{"code": "for (j = 0; j < ((size_t) nt); ++j)\n  sum += sums[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex3-dot-product-openmp-sta/1"}
{"code": "for (long i = 0; i < N; i++)\n{\n  printf(\"[\");\n  for (long j = 0; j < N; j++)\n  {\n    printf(\"%7.2lf \", m[(i * N) + j]);\n  }\n\n  printf(\"]\");\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gadube/simple_openmp_examples/mxv_openmp/1"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  a[i] = (rand() % 100) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task6/0"}
{"code": "for (u = 0; u <= n; u++)\n{\n  adj[u].resize(n + 1);\n  for (v = 0; v <= n; v++)\n    adj[u][v] = INF;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishal-2504/Parallelization-of-Floyd-Warshall-Algorithm/floyd_naive_dynamic_scheduling/2"}
{"code": "for (i = 0; i < (n * (n + 1)); i++)\n{\n  matrix[i] = 4 * (drand48() - 0.5);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/4"}
{"code": "for (i = 0; i < size_0; i++)\n{\n  fscanf(fp, \"%s\", str_1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shyeok/Distributed-Programming/OpenMP/p/1"}
{"code": "for (i = 0; i < ncols; ++i)\n{\n  temp = 0.0;\n  #pragma ivdep\n  for (j = colPtr[i]; j < colPtr[i + 1]; ++j)\n  {\n    r[rowInd[j]] += (double) (A[j] * v[i]);\n    temp += (double) (A[j] * v[i]);\n  }\n\n  r[rowInd[j]] = temp;\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j, temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/0"}
{"code": "for (i = 0; i < (nthreads * 2); i++)\n{\n  shmemx_ctx_destroy(contexts[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/19"}
{"code": "for (j = 0; j < tam; j++)\n{\n  sLocal += Ar[i][j] * vec[j];\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muttaqiahmadalladin/OpenMP-MPI/VSS_A1_2/3"}
{"code": "for (int i = 0; i < matrixSize; i++)\n{\n  for (int j = 0; j < matrixSize; j++)\n  {\n    (cout << elements[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeioff/OpenMP-matrix-experiments/main/3"}
{"code": "for (int col = 0; col < 4;)\n{\n  calc_next_valid(col);\n  valid_row = get_next_valid(col);\n  printf(\"COLUMN: %d VALID ROW: %d\\n\", col, valid_row);\n  if (valid_row >= 0)\n  {\n    ROWS_PLACED[col++] = valid_row;\n    tries++;\n  }\n  else\n  {\n    ROWS_PLACED[col] = -1;\n    if (col == 0)\n    {\n      printf(\"NO SOLUTION EXISTS\\n\");\n      return 0;\n    }\n\n    col--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens2/Queens2.0/2"}
{"code": "for (unsigned int i = 0; i < parents.at(0).size(); ++i)\n{\n  daughter.push_back(\" \");\n  son.push_back(\" \");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/5"}
{"code": "for (int i = 0; i < arraySize; i++)\n{\n  delay[i] = bucketB[i] / runTime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/boris109able/online-change-detection-openMP/onlinesimulation_openMP/Source/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  rowmask = 0;\n  dia1 = 0, dia2 = 0;\n  int col = 0;\n  int row = i;\n  ans += call(1, rowmask | (1 << row), dia1 | (1 << (row + col)), dia2 | (1 << (((row + n) - 1) - col)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shafaet/OpenMP-Examples/Parallel N-Queen problem/3"}
{"code": "for (int32_t i = 0; i != n; ++i)\n{\n  *y = *x;\n  x += incx;\n  y += incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/8"}
{"code": "for (i = 0; i < posLength; i++)\n{\n  printf(\"%s\\n\", positive[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/7"}
{"code": "for (i = 1; i < argc; i++)\n  if (argv[i][0] == '-')\n{\n  switch (argv[i][1])\n  {\n    case 'N':\n      sscanf(argv[i + 1], \"%d\", &N);\n      break;\n\n    case 'M':\n      sscanf(argv[i + 1], \"%d\", &M);\n      break;\n\n    case 'a':\n      sscanf(argv[i + 1], \"%lf\", &accuracy);\n      break;\n\n    case 'o':\n      sscanf(argv[i + 1], \"%lf\", &omega);\n      break;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/10"}
{"code": "for (int i = 2; i < 10; i++)\n{\n  fib[i] = fib[i - 2] + fib[i - 1];\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/demos/openmp/parallel-for/1"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  {\n    rhons[is][i][j][k] += invVOL * moments[i][j][k][0];\n    Jxs[is][i][j][k] += invVOL * moments[i][j][k][1];\n    Jys[is][i][j][k] += invVOL * moments[i][j][k][2];\n    Jzs[is][i][j][k] += invVOL * moments[i][j][k][3];\n    pXXsn[is][i][j][k] += invVOL * moments[i][j][k][4];\n    pXYsn[is][i][j][k] += invVOL * moments[i][j][k][5];\n    pXZsn[is][i][j][k] += invVOL * moments[i][j][k][6];\n    pYYsn[is][i][j][k] += invVOL * moments[i][j][k][7];\n    pYZsn[is][i][j][k] += invVOL * moments[i][j][k][8];\n    pZZsn[is][i][j][k] += invVOL * moments[i][j][k][9];\n  }\n}\n\n\n\n", "pragma": "      #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_tasks_OmpSs/ipic3d/fields/EMfields3D/0"}
{"code": "for (i = 0; i < 800; i++)\n{\n  free(c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/10"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (k = 0; k < n; k++)\n  {\n    r[i][j] = r[i][j] + (a[i][k] * b[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a,b,r,n) private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/matrix_parallel_inner/0"}
{"code": "for (i = 0; i < V; i++)\n  dist[i] = 99999, sptSet[i] = 0;\n\n", "pragma": "omp parallel for schedule(dynamic,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sneha711/OpenMP/dijkstra_parallel/1"}
{"code": "for (int i = 0; i < x.dim1(); i++)\n{\n  for (int j = 0; j < x.dim2(); j++)\n  {\n    (cout << x[i][j]) << \"  \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leoaugustoam/PCA-Parallel-OpenMP/pca/8"}
{"code": "for (j = 1, noffset[0] = 0; j < NTask; j++)\n  noffset[j] = noffset[j - 1] + nsend_local[j - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/density/6"}
{"code": "for (int i = 0; i < k; i++)\n{\n  temp_l = l[k][i];\n  l[k][i] = l[kdash][i];\n  l[kdash][i] = temp_l;\n}\n\n", "pragma": "        #pragma omp parallel for private(temp_l) if(k>500)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brijeshvp/LU-Decomposition-using-Parallel-Programming/omp_parallel/LU_omp/2"}
{"code": "for (int i = 0; i <= maximumLength; i++)\n{\n  C[i][0] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhavya2711/LCS_OpenMP_Adv/lcs/1"}
{"code": "for (i = 0; i < num; i++)\n  b[i] = ((num * num) * num) % 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/VectorDotProduct/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  hist[i] = 0;\n  omp_init_lock(&hist_lcks[i]);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OmpCommonCore/Book/C/Fig_11.6_hist/0"}
{"code": "for (j = k + 1; j <= (n - 1); j++)\n{\n  A[k][j] = A[k][j] / A[k][k];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shrmoud/jarvis/hw2/openMPgauss/0"}
{"code": "for (int i = 1; i < argc; ++i)\n{\n  for (int pi = 0; pi < n_params; ++pi)\n  {\n    if (starts_with(argv[i], params[pi]))\n    {\n      if ((sscanf(argv[i] + strlen(params[pi]), \"%d\", iparams + pi) != 1) || (iparams[pi] < 1))\n      {\n        iparams[pi] = defaultv;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lanl/libquo/demos/mpi-openmp/dgemv/3"}
{"code": "for (worker = 1; worker < n_tasks; worker++)\n{\n  if (sent_arrays < 960)\n  {\n    k = 0;\n    for (i = 0; i < 32; i++)\n    {\n      for (j = 0; j < msg_size; j++)\n      {\n        buffer[k++] = bag_of_tasks[sent_arrays][j];\n      }\n\n      sent_arrays++;\n    }\n\n    MPI_Send(buffer, buffer_size, (MPI_Datatype) 0x4c000405, worker, 2, 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_hybrid/4"}
{"code": "for (i = 0; i < N; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    for (k = 0; k < N; ++k)\n    {\n      C[(i * N) + j] += A[(i * N) + k] * B[(k * N) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HectorMontillo/OpenMP/openmp2/0"}
{"code": "for (i = 0; i < number_of_buckets; i++)\n  qsort(final_array + global_boucket_start[i], global_boucket_count[i], sizeof(int), compare);\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training6/b0521229-train6/2"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      rho_inv = 1.0 / u[i][j][k][0];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[i][j][k][1] * rho_inv;\n      vs[i][j][k] = u[i][j][k][2] * rho_inv;\n      ws[i][j][k] = u[i][j][k][3] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/67"}
{"code": "for (int k = 0; k < lines.size(); k++)\n{\n  tid = omp_get_thread_num();\n  system(lines[k].c_str());\n}\n\n", "pragma": "        #pragma omp parallel for private(tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afg1/SimpleDispatcher/CPP_multidisp/0"}
{"code": "for (int i = 0; i < samples; i++)\n{\n  double point = (next_rand(gen) * (b - a)) + a;\n  double f_value = (*f)(point);\n  tot_value += f_value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bereydev/multiprocessor-architecture/A1/integral/1"}
{"code": "for (long idx = 0; idx < NUM_SLICES; idx++)\n{\n  {\n    fib[idx + 2] = (c = fib[idx] + fib[idx + 1]);\n    printf(\"%02ld: %ld\\r\\n\", idx, c);\n  }\n}\n\n", "pragma": "\t\t#pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex6_1_hard_Fibonacci/0"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  gl_taskData.execTasks[i] = rand() % 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p3/task/6"}
{"code": "for (i = 0; i < subprob_size; i++)\n{\n  for (j = 0; j < subprob_size; j++)\n    a[i][j] = INITIAL_GRID;\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/1"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    ICOL_LIST[j] = -1;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    remake:\n    kk = (int) ((((double) 100000) * rand()) * dc_inv);\n\n    if (kk == 100000)\n      kk = 100000 - 1;\n\n    if (ICOL_LIST[kk] != (-1))\n    {\n      goto remake;\n    }\n    else\n    {\n      ICOL_LIST[kk] = 1;\n    }\n\n  }\n\n  for (j = 0; j < 100000; j++)\n  {\n    if (ICOL_LIST[j] == 1)\n    {\n      ICOL[k] = j;\n      VAL[k] = 1.0;\n      k++;\n    }\n\n  }\n\n  IRP[i + 1] = k;\n  X[i] = 1.0;\n  Y[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/SpMV/C/spmv/0"}
{"code": "for (i = 0; i < (2048 * 2048); i++)\n{\n  v[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/QuickSort_Parallell/3"}
{"code": "for (int i = 0; i < pointsPerProcess; i++)\n{\n  for (int j = 0; j < numThreads; j++)\n  {\n    partForces[((start2 + i) * 3) + 0] += tempForces[(((i * numThreads) * 3) + (j * 3)) + 0];\n    partForces[((start2 + i) * 3) + 1] += tempForces[(((i * numThreads) * 3) + (j * 3)) + 1];\n    partForces[((start2 + i) * 3) + 2] += tempForces[(((i * numThreads) * 3) + (j * 3)) + 2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Garrus007/GravSim2/MPIGrav/Simulator/MpiGravSim/8"}
{"code": "for (int i = 0; i < numDimensions; i++)\n  printf(\"%8.5f\", acceleration[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Dynamique_Moleculaire/DynMol_parallel/6"}
{"code": "for (uint32_t i = 0; i < (vertex_num - 1); i++)\n  Poly_Rect_end[i] = Poly_Rect_begin[i + 1] - 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/9"}
{"code": "for (i = 0; i < sizei; i++)\n{\n  for (j = 0; j < sizej; j++)\n  {\n    curr_matrix[i][j] = next_matrix[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petros-ioannidis/parallel_CGOL/OPENMP_CGOL/graph_main_openmp/2"}
{"code": "for (i = 0; i < bheight; ++i)\n  memmove(&data[((((i + 1) * (bwidth + 2)) + bwidth) + 1) * channels], &data[(((i + 1) * (bwidth + 2)) + bwidth) * channels], channels * (sizeof(unsigned char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/6"}
{"code": "for (j = i + 1; j < sz; j++)\n{\n  if (strcmp(s[i].row_key, s[j].row_key) > 0)\n  {\n    hashed tmp;\n    tmp = s[i];\n    s[i] = s[j];\n    s[j] = tmp;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(j)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Bigtable-in-C/Bigtable2/0"}
{"code": "for (i = 0; i < nThreads; i++)\n  outPiece[i] = malloc(150 * (sizeof(char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/22"}
{"code": "for (double fi = 0; fi < 10.0; fi++)\n{\n  c[(int) fi] = a[(int) fi] + b[(int) fi];\n}\n\n", "pragma": "omp for lastprivate(x, y) firstprivate(x, y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_misc_messages/7"}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  for (j = 0; j < Mdim; j++)\n  {\n    tmp = 0.0;\n    for (k = 0; k < Pdim; k++)\n    {\n      tmp += (*(A + ((i * Ndim) + k))) * (*(B + ((k * Pdim) + j)));\n    }\n\n    *(C + ((i * Ndim) + j)) = tmp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) private(tmp, i, j, k)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/schedule/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  printf(\"%d \", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/Laborator/lab01/ex_pdf/for/2"}
{"code": "for (int i = 1; i < n; i++)\n{\n  pass &= arr[i - 1] <= arr[i];\n}\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/bitonic-sort-project/src/hybrid/bitonic_sort_hybrid/4"}
{"code": "for (i = 0; i < nl; i++)\n{\n  data[i] = othersBB[(((number * ns) * nl) + (i * ns)) + colno];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/13"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/25"}
{"code": "for (c1 = (0 > nj) ? (0) : (nj); c1 <= (nm + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/95"}
{"code": "for (int i = 0; i < in.getSize(); i++)\n{\n  double res = 0.0;\n  const int j_begin = M.AI[i];\n  const int j_end = M.AI[i + 1];\n  for (int j_ = j_begin; j_ < j_end; j_++)\n  {\n    int j = M.AJ[j_];\n    double a_ij = M.A[j_];\n    count += 2;\n    res += a_ij * in[j];\n  }\n\n  out[i] = res;\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vortigaunt007/Solution-Grid-Equations_OpenMP/BasicOperation/0"}
{"code": "for (idx = 0; idx < count; idx += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 64];\n  unsigned char *cp = &tmp[len];\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_plain[idx], len);\n  SHA512_Update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 64;\n  SHA512_Final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, tmp, len);\n    SHA512_Final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/11"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/194"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < k; ++j)\n    fprintf(fp, (j == (k - 1)) ? (\"%d\") : (\"%d \"), a[i][j]);\n\n  fprintf(fp, (i == (n - 1)) ? (\"\\n\\n\") : (\"\\n\"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/4/matrixMultiplication/2"}
{"code": "for (int i = 0; i < (tablo->size / 2); i++)\n{\n  tablo->tab[i + (tablo->size / 2)] += old_tab[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/7"}
{"code": "for (int i = 0; i < 1; ++i)\n  ++i;\n\n", "pragma": "omp for unknown_clause", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-omp/clang/test/OpenMP/openmp_common/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  uint32_t c;\n  SHA_CTX ctx;\n  SHA256_CTX sctx;\n  SHA512_CTX sctx2;\n  MD5_CTX mctx;\n  unsigned char buf[64];\n  if (cur_salt->fmt == 0)\n  {\n    MD5_Init(&mctx);\n    MD5_Update(&mctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    MD5_Final(buf, &mctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      MD5_Init(&mctx);\n      MD5_Update(&mctx, buf, 16);\n      MD5_Final(buf, &mctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 1)\n  {\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    SHA1_Final(buf, &ctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, buf, 20);\n      SHA1_Final(buf, &ctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 2)\n  {\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, cur_salt->salt, cur_salt->saltlen);\n    SHA1_Update(&ctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    SHA1_Final(buf, &ctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, buf, 20);\n      SHA1_Final(buf, &ctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 3)\n  {\n    SHA256_Init(&sctx);\n    SHA256_Update(&sctx, cur_salt->salt, cur_salt->saltlen);\n    SHA256_Update(&sctx, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    SHA256_Final(buf, &sctx);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      SHA256_Init(&sctx);\n      SHA256_Update(&sctx, buf, 32);\n      SHA256_Final(buf, &sctx);\n    }\n\n  }\n  else\n    if (cur_salt->fmt == 4)\n  {\n    SHA512_Init(&sctx2);\n    SHA512_Update(&sctx2, cur_salt->salt, cur_salt->saltlen);\n    SHA512_Update(&sctx2, (const unsigned char *) saved_key[index], strlen(saved_key[index]));\n    SHA512_Final(buf, &sctx2);\n    for (c = 1; c < cur_salt->iterations; c++)\n    {\n      SHA512_Init(&sctx2);\n      SHA512_Update(&sctx2, buf, 64);\n      SHA512_Final(buf, &sctx2);\n    }\n\n  }\n\n\n\n\n\n  memcpy(crypt_out[index], buf, BINARY_SIZE_MIN);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sspr_fmt_plug/0"}
{"code": "for (i = se2; i > 0; i--)\n{\n  HH[i] = -1;\n  DD[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/8"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n    fprintf(fp, \"%d \", (i * 2048) + j);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Trace Analyzer Test/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (long i = 0; i <= NV; i++)\n  edgeListPtrOut[i] = 0;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/1"}
{"code": "for (size_t j = cIdx; j < cLen; j += 2)\n{\n  for (int k = 0; k < 2; ++k)\n    unalignMove(unalignVec, ptrIn, start, end, j + k);\n\n  simdMergeUnit(block, start, end, j, cIdx, selector);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/21"}
{"code": "for (i = 0; i < m_size; i++)\n{\n  aArray[i] = (double *) malloc((sizeof(double)) * m_size);\n  uArray[i] = (double *) malloc((sizeof(double)) * m_size);\n  lArray[i] = (double *) malloc((sizeof(double)) * m_size);\n}\n\n", "pragma": "  #pragma omp prallel for private(i) shared(aArray, uArray, lArray)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/0"}
{"code": "for (i = 0; i < npm; i++)\n  value[i] = (rank * (npm + 1)) + i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kylexu1005/Parallel-Binary-Search/pbsearch/4"}
{"code": "for (int i = 0; i < image.rows; i++)\n{\n  fin[i] = encode((unsigned char *) pixels[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Justmalhar/Parallelized-Image-Compression/imagecompression/2"}
{"code": "for (int i = 0; i < Comb_loops; i++)\n{\n  Comb_Filt(origx, n, num, W_Comb, Comb_Approved + (i * num), x_sampt_comb[i], samples_comb[i], offset[i], sigma, p_comb);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/evanmacbride/parallel-fft/original-sources/sFFT-1.0-2.0-par-openacc/sFFT-1.0-2.0-par-openacc/computefourier/2"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    add_point(image, i, j);\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lonkenzo/Article_OpenMP/codes/comparaison_performances/main2/0"}
{"code": "for (k = 0; k < size; k++)\n{\n  for (i = k + 1; i < size; i++)\n  {\n    l[i][k] = u[i][k] / u[k][k];\n    for (j = k; j < size; j++)\n    {\n      u[i][j] = u[i][j] - (l[i][k] * u[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/inverse/1"}
{"code": "for (int i = 0; i < ans[1].size(); i++)\n  (out_file << ans[1][i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zarechnev/lr-2_openMP/ConsoleApplication1/ConsoleApplication1/1"}
{"code": "for (i = 0; i < P; i++)\n{\n  proc_bytes[i] = 0;\n  last_malloc[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexandrehsd/splash2-lu_cb/src/lu/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    F[(i * SIZE) + j] = 0;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      F[(i * SIZE) + j] += C[(i * SIZE) + k] * D[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/3MM/3mm/1"}
{"code": "for (int i = 0; i < factorNameSize; ++i)\n{\n  if (strcmp(factorName, factorNames[i].factorName) == 0)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/23"}
{"code": "for (int il = 0; il < N1; il++)\n{\n  omp_init_lock(locks + il);\n  chromos[il] = chromos[0];\n  random_shuffle(chromos[il].begin(), chromos[il].end(), myrandom);\n  float x = 0;\n  for (int j = 0; j < N; j++)\n  {\n    x += dist[chromos[il][j]][chromos[il][(j + 1) % N]];\n  }\n\n  fitness[il] = x;\n  if (maxfitness > fitness[il])\n  {\n    omp_set_lock(&lock4bests);\n    maxfitness = fitness[il];\n    best = (++best) % BESTS;\n    bests[best] = chromos[il];\n    omp_unset_lock(&lock4bests);\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rachit95arora/travelling-salesman-openmp/src/main/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  b[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/7ydini/OpenMP/barrier&lock/Main/1"}
{"code": "for (iCntr = 0; iCntr < iLoopCntr; iCntr++)\n{\n  if (iCntr == 0)\n  {\n    iThreadCnt = omp_get_num_threads();\n  }\n\n  int result1 = _mm256_add_epi32(vec1, vec2);\n  int result2 = _mm256_add_epi32(vec3, vec4);\n  int result3 = _mm256_sub_epi32(result1, result2);\n  int result4 = _mm256_add_epi32(result1, result2);\n  asm(\"\");\n}\n\n", "pragma": "omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tkonduri/HPC_1/iCode/0"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  uint32_t j;\n  for (j = 0; j < totalPartitions; ++j)\n  {\n    uint32_t k;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      uint32_t src = partition->edgeList->edges_array_src[k];\n      uint32_t dest = partition->edgeList->edges_array_dest[k];\n      float weight = 1;\n      if (getBit(bitmapCurr, src))\n      {\n        if (arguments->algo_numThreads == 1)\n          activeVertices += bellmanFordRelax(src, dest, weight, stats, bitmapNext);\n        else\n          activeVertices += bellmanFordAtomicRelax(src, dest, weight, stats, bitmapNext);\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(+ : activeVertices) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/1"}
{"code": "for (unsigned int i = 0; i < n; i++)\n{\n  indices[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam-zlatniczki/moar-zeta-cpp-openmp/src/local_zeta/0"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  init_array(X);\n  start = _rdtsc();\n  parallel_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X))\n  {\n    fprintf(stderr, \"ERROR: the array is not properly sorted\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/bubble/6"}
{"code": "for (i = 0; i < strlen(msg); i++)\n{\n  sprintf(tmps, \"%03d\", (int) msg[i]);\n  strcat(intmsg, tmps);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aalmeidasilva/RSA-OpenMP-MPI/src/rsa/2"}
{"code": "forbiddens.resize(nov)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/2"}
{"code": "for (unsigned int elem_index = 0; elem_index < obj_initial.vector_dimension; elem_index++)\n{\n  obj_to_be_copied.values[elem_index] = obj_initial.values[elem_index];\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shreyas-Gururaj/HPC_PNLA_Library_OpenMP/src/vector_omp/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (new_eco[i].type != ROCK)\n  {\n    new_eco[i].type = EMPTY;\n    new_eco[i].temp_type = EMPTY;\n    new_eco[i].gen_proc = 0;\n    new_eco[i].gen_food = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (x[i] != 0.0)\n  {\n    absxi = fabs(x[i]);\n    if (scale < absxi)\n    {\n      ssq = 1.0 + (ssq * pow(scale / absxi, 2));\n      scale = absxi;\n    }\n    else\n    {\n      ssq = ssq + pow(absxi / scale, 2);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/norm2_noowr/main/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n    printf(\"%lf \", A[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Gauss-Fatorization/gauss/1"}
{"code": "for (int r = 0; r < max_row; ++r)\n{\n  for (int c = 0; c < max_column; ++c)\n    ma << mat[r][c];\n\n  ma << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danielakuinchtner/MandelbrotSet_OpenMP/mandelbrotParalel/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  cInfo[i].size += cUpdate[i].size;\n  cInfo[i].degree += cUpdate[i].degree;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/parallelLouvainMethod/1"}
{"code": "for (c = 0; c < nr_class; c++)\n  for (i = 0; i < nr_fold; i++)\n{\n  int begin = start[c] + ((i * count[c]) / nr_fold);\n  int end = start[c] + (((i + 1) * count[c]) / nr_fold);\n  for (int j = begin; j < end; j++)\n  {\n    perm[fold_start[i]] = index[j];\n    fold_start[i]++;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/70"}
{"code": "for (i = 0; i < 16384; i++)\n{\n  for (j = 0; j < 16384; j++)\n    if (i == j)\n  {\n    fprintf(fp, \"%d \", 1);\n  }\n  else\n  {\n    fprintf(fp, \"%d \", 0);\n  }\n\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/PKU-HPC/Testing on Intel Xeon E5 CPUs/ProblemScale/16384*16384/fox_floats_timer_caching_omp_fileIO_benchmark/0"}
{"code": "for (i = 0; i < _Q; i++)\n{\n  iter_2 = i * _K;\n  for (k = 0; k < _K; k++)\n  {\n    sumWl1 += (_W[iter_2 + k] < 0) ? (-_W[iter_2 + k]) : (_W[iter_2 + k]);\n    sumWl2 += _W[iter_2 + k] * _W[iter_2 + k];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(_Q,_K) private(i,k) reduction(+:sumWl1,sumWl2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afarasat/ParallelSparseMatrixFactorization_OpenMP/solution/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  gtid_test();\n}\n\n", "pragma": "#pragma omp distribute parallel for if (parallel: false)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-5.0.0/llvm/tools/clang/test/OpenMP/distribute_parallel_for_if_codegen/0"}
{"code": "for (i = 0; i < ((phi_max_index + 1) - phi_min_index); i++)\n{\n  for (j = 0; j < ((theta_max_index + 1) - theta_min_index); j++)\n  {\n    for (k = 0; k < ((r_max_index + 1) - r_min_index); k++)\n    {\n      r_index = r_min_index + k;\n      if (ph_inj_switch == 0)\n      {\n        if (((ph_rmin - ((elem_factor * C_LIGHT) / fps)) < (*(r_unprc + r_index))) && ((*(r_unprc + r_index)) < (ph_rmax + ((elem_factor * C_LIGHT) / fps))))\n        {\n          elem++;\n        }\n\n      }\n      else\n      {\n        if (((r_inj - ((elem_factor * C_LIGHT) / fps)) < (*(r_unprc + r_index))) && ((*(r_unprc + r_index)) < (r_inj + ((elem_factor * C_LIGHT) / fps))))\n        {\n          elem++;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib_3d/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n    fac2 = 1. / lhs[n + 2][i][j][k1];\n    rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/64"}
{"code": "for (int i = 0; i < my_vector.size(); i++)\n{\n  my_vector[i] = exp(-sin((i * i) + (pi * log(i + 1.0))));\n  my_vector[i] += -exp(-cos(((i * i) * i) + (pi * log10(i + 10.0))));\n  my_vector[i] -= exp(-tan((((i * i) * i) * i) + (pi * log(i + 99.0))));\n  my_vector[i] += exp(-sin(((((i * i) * i) * i) * i) + (pi * log(i + 2.0))));\n  my_vector[i] -= -exp(-cos((((((i * i) * i) * i) * i) * i) + (pi * log10(i + 20.0))));\n  my_vector[i] += exp(-tan(((((((i * i) * i) * i) * i) * i) * i) + (pi * log(i + 199.0))));\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/void-mckenzie/OpenMP-Work/Programs/omp_test/0"}
{"code": "for_handler_post(directive)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/base/tl-omp-base/1"}
{"code": "for (unsigned long i = 0; i < BlockGroup.Parents.size(); ++i)\n{\n  ((cout << dec) << BlockGroup.Parents[i].index) << \", \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/src/OAORewriter/5"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_exit_data); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/6"}
{"code": "for (int level = 0; level < task.depth; ++level)\n{\n  movePoints();\n  saveStat(level, stat, form);\n  showStat(level, form);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/smoothing/5"}
{"code": "for (i = 0; i <= smaller; i++)\n{\n  dp[i][0] = i * pgap;\n  dp[0][i] = i * pgap;\n}\n\n", "pragma": "\t#pragma omp parallel for simd shared(dp, pgap) linear(i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalignomp/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    ru1 = rho_i[i][j][k];\n    uu = us[i][j][k];\n    vv = vs[i][j][k];\n    ww = ws[i][j][k];\n    ac = speed[i][j][k];\n    ac2inv = ainv[i][j][k] * ainv[i][j][k];\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n    t2 = (bt * ru1) * ((uu * r1) - r2);\n    t3 = ((bt * ru1) * ac) * t1;\n    rhs[0][i][j][k] = r1 - t1;\n    rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n    rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n    rhs[3][i][j][k] = (-t2) + t3;\n    rhs[4][i][j][k] = t2 + t3;\n  }\n\n}\n\n", "pragma": "omp parallel for private(ru1, uu, vv, ww, ac, ac2inv, r1 ,r2 ,r3 ,r4 ,t1 ,t2 ,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/91"}
{"code": "for (int i = 0; i < size; i++)\n{\n  r[i] = v1[i] + v2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/als-movie-recommender/main/13"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float temp = 0.0;\n    for (int k = 0; k < N; k++)\n    {\n      temp += A[(i * N) + k] * B[(k * N) + j];\n    }\n\n    C[(i * N) + j] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Masa-731/OpenMP-vs-OpenACC/matrixmul/openmp-cpu/0"}
{"code": "for (int i = 0; i < temp.rows; i++)\n{\n  for (int j = 0; j < temp.cols; j++)\n  {\n    int x = x_ratio * j;\n    int y = y_ratio * i;\n    float x_diff = (x_ratio * j) - x;\n    float y_diff = (y_ratio * i) - y;\n    temp(i, j)[0] = bilinear_interp(x, y, x_diff, y_diff, 0);\n    temp(i, j)[1] = bilinear_interp(x, y, x_diff, y_diff, 1);\n    temp(i, j)[2] = bilinear_interp(x, y, x_diff, y_diff, 2);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OluwaseunOjeleye/OpenMP-based-Image-Processing-/image_processing/IP/1"}
{"code": "for (i = 0; i < (LX1 - 1); i++)\n{\n  idmo[iel][face][1][1][i][LX1 - 1] = mor_s_v[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/21"}
{"code": "for (j = 0; j < (argc - 1); j++)\n{\n  tid = omp_get_thread_num();\n  printf(\"Hello World from thread = %d\\n\", tid);\n  printf(\"file %d\", j);\n  n = ReadWords(argv[j + 1], words[j]);\n  total_words += n;\n  printf(\"\\n n=%d \", n);\n}\n\n", "pragma": "omp parallel for reduction(+ : total_words)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/fileread_parallel/0"}
{"code": "for (i = 0; i < grid->num_vertices; ++i)\n{\n  grid->out_degree[i] = 0;\n  grid->in_degree[i] = 0;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(grid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/grid/2"}
{"code": "for (int i = 1; i <= strLen; i++)\n{\n  for (int j = 0; j < np; j++)\n    for (int k = 1; gram[j][k] != \"\"; k++)\n    if (gram[j][k][0] == str[i - 1])\n  {\n    table[1][i][gram[j][0][0]] = true;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-CYK-CFG-Parser-OMP/src/parser/0"}
{"code": "for (unsigned long row = 0; row < copy.Rows(); ++row)\n  for (unsigned long column = 0; column < copy.Columns(); ++column)\n  copy(row, column) = copy(row, column) / op2;\n\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShariqueMohd/Parallel-Image-Compression-using-PCA/DenseMatrix/15"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  for (j = 1; j < numprocs; j++)\n  {\n    MPI_Send(allClusters[i].virutalCenter.coordinates, allClusters[i].virutalCenter.dimensions, MPI_DOUBLE, j, 0, MPI_COMM_WORLD);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/6"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  for (j = 0; j < 1000; ++j)\n  {\n    A[(i * 1000) + j] = (float) ((q - (10 * i)) - (5 * j));\n    B_GPU[(i * 1000) + j] = 0.0f;\n    B_CPU[(i * 1000) + j] = 0.0f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/cholesky/src/cholesky_gpu/1"}
{"code": "for (int q = 0; q < data_size_Y; q++)\n{\n  for (int w = 0; w < data_size_X; w++)\n  {\n    *(padded_in + ((((q + 1) * (data_size_X + 2)) + w) + 1)) = *(in + ((q * data_size_X) + w));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(data_size_X, data_size_Y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erictu/Image-Processing-Optimization/part2/1"}
{"code": "for (int i = 0; i < mat.size(); i++)\n  for (int j = 0; j < mat[1].size(); j++)\n  mat[i][j] = RAND_FLOAT();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchSequential/0"}
{"code": "for (i1 = 0; i1 < 24; ++i1)\n  for (i2 = 0; i2 < 24; ++i2)\n  for (i3 = 0; i3 < 24; ++i3)\n  for (i4 = 0; i4 < 24; ++i4)\n  for (i5 = 0; i5 < 24; ++i5)\n  for (i6 = 0; i6 < 24; ++i6)\n  a[i1][i2][i3][i4][i5][i6] = 3.0;\n\n\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-nwchem-s1_1/clang-nwchem-s1_1/1"}
{"code": "for (ix = 0; ix < grid.EX; ix++)\n{\n  for (iy = 0; iy < grid.EY; iy++)\n  {\n    v = grid.Values[ix + (iy * Xdots)];\n    if ((v <= vmax) && (v >= vmin))\n    {\n      pp->weight[n] = v * 10.0;\n      p = ((pgrid.Xe - pgrid.Xs) * ix) / (grid.EX * 2.0);\n      pp->x[n] = (pgrid.Xs + ((pgrid.Xe - pgrid.Xs) / 4.0)) + p;\n      p = ((pgrid.Ye - pgrid.Ys) * iy) / (grid.EY * 2.0);\n      pp->y[n] = (pgrid.Ys + ((pgrid.Ye - pgrid.Ys) / 4.0)) + p;\n      pp->vx[n] = (pp->vy[n] = 0.0);\n      n++;\n      if (n >= np)\n        break;\n\n    }\n\n  }\n\n  if (n >= np)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/5"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  Y[i] = X[i];\n  Y[i + 1] = X[i + 1];\n  Y[i + 2] = X[i + 2];\n  Y[i + 3] = X[i + 3];\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/copy/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i += 1)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (5.0 * u[m][i][j][k])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/148"}
{"code": "for (int i = 0; i < agents.size(); i++)\n{\n  int sx = agents[i]->getX();\n  int sy = agents[i]->getY();\n  stateUnit(sx, sy) = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hd-zhao-uu/PedestrianSimulation/libpedsim/ped_model/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] = x[i] + y[i];\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stephanmg/cuda-playground/vecadd_cpu/0"}
{"code": "for (int g = 0; g < egroups; g++)\n{\n  state_flux[g] = ((t1[g] + t2[g]) + t3[g]) + t4[g];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/14"}
{"code": "for (int phase = 0; phase < n; phase++)\n{\n  int temp;\n  if ((phase % 2) == 0)\n  {\n    for (int i = 1; i < n; i += 2)\n    {\n      if (myList[i - 1] > myList[i])\n      {\n        temp = myList[i];\n        myList[i] = myList[i - 1];\n        myList[i - 1] = temp;\n      }\n\n    }\n\n  }\n  else\n  {\n    for (int i = 1; i < (n - 1); i += 2)\n    {\n      if (myList[i] > myList[i + 1])\n      {\n        temp = myList[i];\n        myList[i] = myList[i + 1];\n        myList[i + 1] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmalAljabri/Parallel_Computing/odd-even_transposition_sort_invariant_of_bubble_sort/OpenMP/oddeven_sort/0"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  if (i < 500)\n  {\n    array[i] = 1 + (rand() % 500);\n  }\n  else\n    if (i < 1000)\n  {\n    array[i] = 501 + (rand() % 500);\n  }\n  else\n    if (i < 1500)\n  {\n    array[i] = 1001 + (rand() % 500);\n  }\n  else\n    if (i < 2000)\n  {\n    array[i] = 1501 + (rand() % 500);\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Elusive7733/OpenMP-vs-Pthread-vs-Serial-Sorting/OpenMP/BubbleSort_OpenMP/2"}
{"code": "for (i = (2U * 0x7fffffff) + 1; i > (2U * 0x7fffffff); i--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr43893/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float diff = (*((diPlus1 + (i * N)) + j)) - (*((di + (i * N)) + j));\n    *errorIplus1 += diff * diff;\n    diff = (*((eiPlus1 + (i * N)) + j)) - (*((ei + (i * N)) + j));\n    *errorIplus1 += diff * diff;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/8"}
{"code": "for (k = 0; k <= ((int) (n - pow(2, d + 1))); k += (int) pow(2, d + 1))\n{\n  int tmp = data[(k + pow(2, d)) - 1];\n  data[(k + pow(2, d)) - 1] = data[(k + pow(2, d + 1)) - 1];\n  if (flag_init[k + pow(2, d)] == 1)\n    data[(k + pow(2, d + 1)) - 1] = 0;\n  else\n    if (flag[(k + pow(2, d)) - 1] == 1)\n    data[(k + pow(2, d + 1)) - 1] = tmp;\n  else\n    data[(k + pow(2, d + 1)) - 1] = tmp + data[(k + pow(2, d + 1)) - 1];\n\n\n  flag[(k + pow(2, d)) - 1] = 0;\n}\n\n", "pragma": "                #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/scan/lab_scan_frag/scan_frag/2"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  count[i] = calloc(2, sizeof(int));\n  cdata[i] = calloc(2, sizeof(double));\n  cmask[i] = malloc(2 * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/118"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n  f >> a[(i * n) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Matrix Multiplication/matrix_mul_parallel/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * ((u[i][j][k - 2][m_imopVar133] - (4.0 * u[i][j][k - 1][m_imopVar133])) + (5.0 * u[i][j][k][m_imopVar133])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/74"}
{"code": "for (i = 0; i < n2; i++)\n{\n  R[i] = fit[(mid + 1) + i];\n  copy(G2[i], genes[(mid + 1) + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/9"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  if (distance[i] > max_distance)\n  {\n    max_distance = distance[i];\n    max_index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/10"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  const idx_t * const restrict ind = tt->ind[m];\n  for (idx_t n = 0; n < tt->nnz; ++n)\n  {\n    eind[eptr[offset + ind[n]]++] = n;\n  }\n\n  offset += tt->dims[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/12"}
{"code": "for (int i = 0; i < fin; i++)\n{\n  if (numero == arreglo.at(i))\n  {\n    contador++;\n  }\n  else\n  {\n    if (contador > contadorAux)\n    {\n      contadorAux = contador;\n      numeroAux = numero;\n    }\n\n    contador = 1;\n    numero = arreglo.at(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IsraelRamirez/Promediador-Omp-Mpi-Secuencial/openmp-cpp/main/3"}
{"code": "for (i = 0; i < size; ++i)\n{\n  sum += arr[i];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum) shared(arr) default(none)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zsxoff/course-parallel-programming/task-2/src/omp/0"}
{"code": "for (int row = 0; row < n; row++)\n  for (int col = 0; col < ms; col++)\n  row_mult_col(arr1, arr2, m, row, col, res);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t2/5"}
{"code": "for (i = 0; i < NUMBALLS; i++)\n  bodies[i].updateposition();\n\n", "pragma": "  #pragma omp parallel for num_threads(numthreads) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sayanmandal/Many-Body-Simulation-OpenMP/simulation/3"}
{"code": "for (bits = 0; bits < dstbits; bits += 6)\n{\n  uint32_t c = atoi64[*(src++)];\n  if (c > 63)\n  {\n    *dst = 0;\n    return 0;\n  }\n\n  *dst |= c << bits;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/scrypt_fmt/2"}
{"code": "for (j = it; j < nxh; j++)\n{\n  at1 = crealf(ffc[j]) * cimagf(ffc[j]);\n  at2 = (at1 * dnx) * ((float) j);\n  zt1 = cimagf(q[j]) - (crealf(q[j]) * _Complex_I);\n  fxy[2 * j] = at2 * zt1;\n  fxy[1 + (2 * j)] = zero;\n  fxy[(2 * j) + k1] = zero;\n  fxy[(1 + (2 * j)) + k1] = zero;\n  wp += at1 * (q[j] * conjf(q[j]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/ssempush2/11"}
{"code": "for (int i = 0; i < (g.nodemax - 1); i++)\n{\n  prefix_sum[i + 1] = prefix_sum[i] + partial_deg[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/converter/pscan_input_to_edge_list/0"}
{"code": "for (int i = 0; i < answer[index].getNumCities(); i++)\n{\n  (((((outFile << answer[index].getCityId(i)) << \" \") << answer[index].getXAt(i)) << \" \") << answer[index].getYAt(i)) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenFields724/TravelingSalesmanProblem_ParallelGeneticAlgorithm/TSP_OpenMP_Genetic_Algorithm/main/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  data[i] = data2[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(p)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/pquick/4"}
{"code": "for (int i = 0; i < _column_size; i++)\n{\n  x[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/5"}
{"code": "for (int j = 0; j < n; j++)\n{\n  for (int k = 0; k < n; k++)\n    c[(i * n) + j] += a[(i * n) + k] * b[(k * n) + j];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/mm/main/1"}
{"code": "for (i_imopVar0 = 1; i_imopVar0 < (grid_points[0] - 1); i_imopVar0++)\n{\n  for (k_imopVar2 = 1; k_imopVar2 < (grid_points[2] - 1); k_imopVar2++)\n  {\n    double *_imopVarPre378;\n    double (*_imopVarPre379)[5];\n    double (*_imopVarPre380)[5];\n    _imopVarPre378 = rhs[i_imopVar0][0][k_imopVar2];\n    _imopVarPre379 = lhs[i_imopVar0][0][k_imopVar2][2];\n    _imopVarPre380 = lhs[i_imopVar0][0][k_imopVar2][1];\n    binvcrhs(_imopVarPre380, _imopVarPre379, _imopVarPre378);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/7"}
{"code": "for (int n = start; n < end; ++n)\n{\n  MPI_Recv(nodes[n]->x, model.dim_features, MPI_FLOAT, 0, TAG_DATA_COMM_X_VECTOR, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_hybrid/1"}
{"code": "for (i = 1; i < (blockDimension + 1); i += blockDimension - 1)\n{\n  for (j = 1; j < (blockDimension + 1); j++)\n  {\n    neighbors = 0;\n    if (block[j - 1][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j - 1][i] == 'X')\n      neighbors++;\n\n    if (block[j - 1][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j][i] == 'X')\n    {\n      if (neighbors <= 1)\n      {\n        changed++;\n        newblock[j][i] = '.';\n      }\n      else\n        if ((neighbors == 2) || (neighbors == 3))\n      {\n        newblock[j][i] = 'X';\n      }\n      else\n        if (neighbors > 3)\n      {\n        changed++;\n        newblock[j][i] = '.';\n      }\n\n\n\n    }\n    else\n    {\n      if (neighbors == 3)\n      {\n        changed++;\n        newblock[j][i] = 'X';\n      }\n      else\n      {\n        newblock[j][i] = '.';\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(neighbors,i,j) reduction(+:changed) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ippokratoys/Game-Of-Life-MPI-OpenMp-CUDA/openMp/2"}
{"code": "for (i = 0; i < (length / 2); i++)\n  if (data[i * 2] > data[(i * 2) + 1])\n{\n  t = data[i * 2];\n  data[i * 2] = data[(i * 2) + 1];\n  data[(i * 2) + 1] = t;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUSTechBruce/Multithread-merge_sort/merge_sort/0"}
{"code": "for (int m = 0; m < ITERATIONS; m++)\n{\n  if (errors[m] < minimal)\n  {\n    for (int u = 0; u < K; u++)\n    {\n      for (int p = 0; p < (DIM + 1); p++)\n      {\n        finalFinalCenters[u][p] = finalCenters[m][u][p];\n      }\n\n    }\n\n    minimal = errors[m];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hejohns/kmeans/kmeans/3"}
{"code": "for (int ki = 0; ki < m; ki++)\n{\n  for (int kj = 0; kj < l; kj++)\n  {\n    mset[ki][kj] = (int) (rand() % 2);\n    nset[ki][kj] = (int) (rand() % 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpaltsai/OpenMP/project_3_omp_fg_vectorized/3"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = (float) strtod(head, &tail);\n    if (tail == head)\n    {\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n    }\n\n    if (mat->rsizes[i] < 0)\n    {\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n      if (tail == head)\n      {\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n      }\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n      {\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = (float) strtod(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n      }\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/65"}
{"code": "for (i = 0; i < cutoutsize; i++)\n{\n  equal = false;\n  for (j = 0; j < listsize; j++)\n  {\n    if (cutout[i] == filterlist[j])\n    {\n      equal = true;\n      break;\n    }\n\n  }\n\n  if ((!equal) || (cutout[i] > filterlist[j]))\n    cutout[i] = 0;\n\n}\n\n", "pragma": "#pragma omp for private(i,j,equal) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/neurodata/ndlib/cpp_version/filterCutoutOMP/0"}
{"code": "for (y = 0; y < (1 * omp_para); y++)\n  for (x = 0; x < SIMD_COEF_32; x++)\n{\n  if (((MD5_word *) binary)[0] == ((MD5_word *) sout)[x + ((y * SIMD_COEF_32) * 4)])\n    return 1;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/MD5_fmt/2"}
{"code": "for (iRow = 0; iRow < nRow; iRow++)\n{\n  SumD[iRow] = (int *) malloc(nCol * (sizeof(int)));\n  if (SumD[iRow] == 0)\n  {\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/MatrixAdditionOMP/3"}
{"code": "for (i = 0; i < nvals; i++)\n{\n  dbl[i] = dns[i];\n}\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/fft_util_omp45/3"}
{"code": "for (int j = 0; j < currMatrixSize; j++)\n{\n  diagonal[j] = M(j, j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/JacobiIteration1/0"}
{"code": "for (size_t i = 0; i < a->nr_vertices; ++i)\n{\n  for (size_t j = 0; j < a->nr_vertices; ++j)\n    da[i + ai_off][j + aj_off] = MIN(da[i + ai_off][j + aj_off], db[i + bi_off][k + bj_off] + dc[k + ci_off][j + cj_off]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimosr/Parallel_Programming/Project3/graph/0"}
{"code": "for (long long i = 0; i <= d; i++)\n  first = first + i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GennadySX/vvrs/lab_1/main/0"}
{"code": "for (index = 0; index < count; index++)\n  if (((uint64_t *) binary)[0] == crypt_out[index][0])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/leet_cc_fmt_plug/1"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  printf(\"\\t douto1=%f \\n\", douto[col]);\n  col = col + 4;\n  printf(\"\\t dneto1=%f \\n\", dneto[col]);\n  col = col + 4;\n  printf(\"\\t dE=%f \\n\", dE[col]);\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/13"}
{"code": "for (int dimension = 200; dimension <= 2000; dimension += 200)\n{\n  matrixMultiplicationTest(dimension);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tvn2005/Matrix-multiplication-using-OpenMP/ompnMatrixMultiplication/0"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    mul[i][j] = 0;\n    for (k = 0; k < c; k++)\n    {\n      mul[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lakshmipooja/OpenMP/mat_mul/3"}
{"code": "for (index = 0; index < count; index++)\n{\n  DES_cblock des_key;\n  DES_key_schedule schedule;\n  int i;\n  int saved_key_length = strlen(saved_key[index]);\n  if (saved_key_length <= 8)\n  {\n    for (i = 0; saved_key[index][i]; i++)\n      des_key[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    while (i < 8)\n      des_key[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key, &schedule);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, (DES_cblock *) crypt_out[index], &schedule, 1);\n  }\n  else\n  {\n    DES_cblock des_key1;\n    DES_cblock des_key2;\n    DES_key_schedule schedule1;\n    DES_key_schedule schedule2;\n    DES_cblock hash_1;\n    DES_cblock hash_2;\n    unsigned char output[8];\n    for (i = 0; i < 8; i++)\n      des_key1[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][i])];\n\n    for (i = 0; i < (saved_key_length - 8); i++)\n      des_key2[i] = a2e_precomputed[ARCH_INDEX(saved_key[index][8 + i])];\n\n    while (i < 8)\n      des_key2[i++] = 0x2a;\n\n    DES_set_key_unchecked(&des_key1, &schedule1);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, &hash_1, &schedule1, 1);\n    DES_set_key_unchecked(&des_key2, &schedule2);\n    DES_ecb_encrypt((const_DES_cblock *) cur_salt->userid, &hash_2, &schedule2, 1);\n    for (i = 0; i < 8; i++)\n    {\n      output[i] = hash_1[i] ^ hash_2[i];\n    }\n\n    memcpy((unsigned char *) crypt_out[index], output, 8);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/as400_des_fmt_plug/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (data[i] != (-1))\n    data[i] = i;\n\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/9"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (n = 0; n < 5; n++)\n  {\n    lhs[i][j][k][0][m][n] = 0.0;\n    lhs[i][j][k][1][m][n] = 0.0;\n    lhs[i][j][k][2][m][n] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/18"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[index], (16 * 2) * 2);\n  MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/0"}
{"code": "for (iterator i_node = temp_nodes_container.begin(); i_node != temp_nodes_container.end(); ++i_node)\n{\n  if (i_node->IsNot(IdentifierFlag))\n    r_mesh.Nodes().push_back(move(*i_node.base()));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/sources/model_part/1"}
{"code": "for (index = 0; index < count; index += 3)\n{\n  int i;\n  int j;\n  if (keys_changed)\n  {\n    char *k0 = saved_key[index];\n    char *k1 = saved_key[index + 1];\n    char *k2 = saved_key[index + 2];\n    unsigned char digest16[3][16];\n    domino_big_md_3((unsigned char *) k0, strlen(k0), (unsigned char *) k1, strlen(k1), (unsigned char *) k2, strlen(k2), digest16[0], digest16[1], digest16[2]);\n    for (i = 0, j = 6; i < 14; i++, j += 2)\n    {\n      const char *hex2 = hex_table[ARCH_INDEX(digest16[0][i])];\n      digest34[index][j] = hex2[0];\n      digest34[index][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[1][i])];\n      digest34[index + 1][j] = hex2[0];\n      digest34[index + 1][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[2][i])];\n      digest34[index + 2][j] = hex2[0];\n      digest34[index + 2][j + 1] = hex2[1];\n    }\n\n  }\n\n  if (salt_changed)\n  {\n    digest34[index + 2][0] = (digest34[index + 1][0] = (digest34[index][0] = saved_salt[0]));\n    digest34[index + 2][1] = (digest34[index + 1][1] = (digest34[index][1] = saved_salt[1]));\n    digest34[index + 2][2] = (digest34[index + 1][2] = (digest34[index][2] = saved_salt[2]));\n    digest34[index + 2][3] = (digest34[index + 1][3] = (digest34[index][3] = saved_salt[3]));\n    digest34[index + 2][4] = (digest34[index + 1][4] = (digest34[index][4] = saved_salt[4]));\n    digest34[index + 2][5] = (digest34[index + 1][5] = (digest34[index][5] = '('));\n  }\n\n  domino_big_md_3_34(digest34[index], digest34[index + 1], digest34[index + 2], (unsigned char *) crypt_out[index], (unsigned char *) crypt_out[index + 1], (unsigned char *) crypt_out[index + 2]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC_fmt_plug/0"}
{"code": "for (i = 0; i < SIZE_OF_CNT; ++i)\n{\n  cnt[i] += offset;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/5"}
{"code": "for (int i = 0; i < ((n - k) - 1); i++)\n{\n  temp_u[i] = u[k][(i + k) + 1];\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brijeshvp/LU-Decomposition-using-Parallel-Programming/omp_parallel/LU_omp/3"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, 9, (MPI_Datatype) 0x4c000406, T, 9, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/45"}
{"code": "for (i = 0; i < n; i++)\n{\n  double num = 0;\n  for (j = 0; j < n; j++)\n  {\n    num = num + (m[i][j] * v1[j]);\n  }\n\n  v2[i] = num;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp2/ejer9/pmv-OPM-a/0"}
{"code": "for (size_t i = 0; i < nodes_num; ++i)\n{\n  nodes[i] = node->data();\n  node = node->next();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_linked_list_traversal/c1/calculate/0"}
{"code": "for (int j = 0; j < n; j++)\n  for (int k = 0; k < n; k++)\n  c[i][j] += a[i][k] * b[k][j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kielfriedt/Multithreading/Pthreads/Pthread_MatrixMult/0"}
{"code": "for (int i = 0; i < n; i++)\n  shuffle[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/urmilas239/Openmp/common/11"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, &cur_salt->id, 1);\n  MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  MD5_Update(&ctx, cur_salt->challenge, cur_salt->challenge_length);\n  MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/chap_fmt_plug/0"}
{"code": "for (i = 0; i < N; i++)\n  sum += B[i] * C[i];\n\n", "pragma": "omp distribute parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/distribute_parallel_for/0"}
{"code": "for (int n = 0; n < N; n++)\n{\n  xbest[n] = x[i][n];\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/R1ES_omp_alt/7"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    matrix[i][j] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Examples/openmp/3"}
{"code": "for (int i = 0; i < M; i++)\n{\n  printf(\"%d \", s_array_wl[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR7/LR7_1/3"}
{"code": "for (i_imopVarPre84 = ist; i_imopVarPre84 <= iend; i_imopVarPre84++)\n{\n  for (j_imopVarPre85 = L1; j_imopVarPre85 <= L2; j_imopVarPre85++)\n  {\n    for (k_imopVarPre86 = 1; k_imopVarPre86 <= (nz - 2); k_imopVarPre86++)\n    {\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2];\n      u31 = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      q = (0.50 * (((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1]) + (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2])) + (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3]))) / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] * u31;\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] * u31) + (0.40e+00 * (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] - q));\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] * u31;\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = ((1.40e+00 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4]) - (0.40e+00 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/9"}
{"code": "for (this->a = 0; a < 2; ++a)\n  ++this->a;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_lastprivate_codegen/5"}
{"code": "for (; xv_it != xv_in->end(); ++xv_it)\n{\n  for (yv_it = zv_it; yv_it != yv_in->end(); ++yv_it)\n  {\n    if (yv_it->first == xv_it->first)\n    {\n      sum += yv_it->second * xv_it->second;\n      zv_it = yv_it;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/3"}
{"code": "for (int i = 1; i < NUM_BINS; i += 2)\n  localBins[tID][i] += localBins[tID - offset][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/11"}
{"code": "for (int p = 0; p < (k - 1); p++)\n{\n  sum += L[k - 1][p] * U[p][j - 1];\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/croutMethod/2"}
{"code": "for (size_t i = 0; i < m.r; ++i)\n{\n  for (size_t j = 0; j < m.c; ++j)\n  {\n    T elem = m.data[(i * m.c) + j];\n    if (elem != 0)\n    {\n      (((((os << i) << \" \") << j) << \" \") << elem) << endl;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zambonin/lovelace/matrix-mult/smm/0"}
{"code": "for (int i = N - 2; i >= 0; i--)\n{\n  res.col(i) += suma.col(omp_get_thread_num());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/reverseCummulativeSum/3"}
{"code": "for (k = lt - 1; k >= 1; k--)\n{\n  nx[k] = nx[k + 1] / 2;\n  ny[k] = ny[k + 1] / 2;\n  nz[k] = nz[k + 1] / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/17"}
{"code": "for (i = 0; i < nvtxs; i++)\n{\n  if (nopen == 0)\n  {\n    gk_i32pqInsert(queue, ot[0], 1);\n    nopen++;\n  }\n\n  if ((v = gk_i32pqGetTop(queue)) == (-1))\n    gk_errexit(SIGERR, \"The priority queue got empty ahead of time [i=%d].\\n\", i);\n\n  if (perm[v] != (-1))\n    gk_errexit(SIGERR, \"The perm[%d] has already been set.\\n\", v);\n\n  perm[v] = i;\n  if (ot[pos[v]] != v)\n    gk_errexit(SIGERR, \"Something went wrong [ot[pos[%d]]!=%d.\\n\", v, v);\n\n  if (pos[v] >= nopen)\n    gk_errexit(SIGERR, \"The position of v is not in open list. pos[%d]=%d is >=%d.\\n\", v, pos[v], nopen);\n\n  ot[pos[v]] = ot[nopen - 1];\n  pos[ot[nopen - 1]] = pos[v];\n  if (ntodo > nopen)\n  {\n    ot[nopen - 1] = ot[ntodo - 1];\n    pos[ot[ntodo - 1]] = nopen - 1;\n  }\n\n  nopen--;\n  ntodo--;\n  for (j = xadj[v]; j < xadj[v + 1]; j++)\n  {\n    u = adjncy[j];\n    if (perm[u] == (-1))\n    {\n      if (degrees[u] == 0)\n      {\n        ot[pos[u]] = ot[nopen];\n        pos[ot[nopen]] = pos[u];\n        ot[nopen] = u;\n        pos[u] = nopen;\n        nopen++;\n        level[u] = level[v] + 1;\n        gk_i32pqInsert(queue, u, 0);\n      }\n\n      degrees[u]++;\n      switch (type)\n      {\n        case 1:\n          gk_i32pqUpdate(queue, u, (1000 * (i + 1)) + degrees[u]);\n          break;\n\n        case 2:\n          gk_i32pqUpdate(queue, u, degrees[u]);\n          break;\n\n        case 3:\n          wdegrees[u] += i;\n          gk_i32pqUpdate(queue, u, wdegrees[u]);\n          break;\n\n        case 4:\n          ;\n          break;\n\n        case 5:\n          gk_i32pqUpdate(queue, u, -((1000 * level[u]) - degrees[u]));\n          break;\n\n        case 6:\n          gk_i32pqUpdate(queue, u, (i + 1) * degrees[u]);\n          break;\n\n        default:\n          ;\n\n      }\n\n    }\n\n  }\n\n  if (type == 4)\n  {\n    for (j = 0; j < nopen; j++)\n    {\n      u = ot[j];\n      if (perm[u] != (-1))\n        gk_errexit(SIGERR, \"For i=%d, the open list contains a closed vertex: ot[%zd]=%d, perm[%d]=%d.\\n\", i, j, u, u, perm[u]);\n\n      sod[u] += degrees[u];\n      if ((i < 1000) || ((i % 25) == 0))\n        gk_i32pqUpdate(queue, u, sod[u]);\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/10"}
{"code": "for (j = 0; j < Maze->Sections[i]; ++j)\n{\n  Maze->Edges[k + j].Weight = ((k - j) % 5) + 1;\n  Maze->Edges[k + j].Loc = k + j;\n  Maze->Edges[k + j].A = &Maze->Nodes[i][j];\n  Maze->Edges[k + j].B = &Maze->Nodes[i][(j + 1) % Maze->Sections[i]];\n  Maze->Nodes[i][j].Friends[0] = Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Self;\n  Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Friends[1] = Maze->Nodes[i][j].Self;\n  Maze->Nodes[i][j].Friends[2] = -1;\n  Maze->Nodes[i][j].EdgeTo[0] = k + j;\n  Maze->Nodes[i][(j + 1) % Maze->Sections[i]].EdgeTo[1] = k + j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/17"}
{"code": "for (int j = 0; j < ((int) A->GetY()); j++)\n{\n  for (int i = 0; i < ((int) A->GetX()); i++)\n  {\n    if ((((i > 0) && (i < (((int) A->GetX()) - 1))) && (A->GetValue(i + 1, j) > 0.)) && (A->GetValue(i - 1, j) > 0.))\n    {\n      A->GetValue(i, j) = 0.5 * (A->GetValue(i + 1, j) + A->GetValue(i - 1, j));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libOutCFD/out_cfd_param/5"}
{"code": "for (i = 0; i <= maxNode; i++)\n{\n  for (j = 0; j <= maxNode; j++)\n  {\n    r2[i] += M[i][j] * r[j];\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/natbprice/pagerank/Task 1/Task_1_Code/5"}
{"code": "for (int n = 0; n < microenvironment.number_of_densities(); n++)\n{\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_xmin[n])\n  {\n    xmin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_xmax[n])\n  {\n    xmax = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_ymin[n])\n  {\n    ymin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_ymax[n])\n  {\n    ymax = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_zmin[n])\n  {\n    zmin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_zmax[n])\n  {\n    zmax = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/21"}
{"code": "for (i = num_var - 1; i >= 0; i--)\n{\n  for (j = num_var - 1; j > i; j--)\n    sol[i] += sol[j] * var[(i * (num_var + 1)) + j];\n\n  sol[i] = (var[(i * (num_var + 1)) + num_var] - sol[i]) / var[(i * (num_var + 1)) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/workout_3_gaussian_elimination/linearAlgebra_16EE30025/4"}
{"code": "for (i = 0; i < 4; i++)\n  DoTrades(i);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_ompOLD/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  y[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/daxpy-loop/2"}
{"code": "for (unsigned int i = 0; i < kClusters.size(); i++)\n{\n  (((((myfile << kClusters.at(i).getX()) << \"\\t\") << kClusters.at(i).getY()) << \"\\t\") << (-1)) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicholasfresneda/kmeans/openmp_impl/Cluster/1"}
{"code": "for (it = 1; it <= itmax; it++)\n{\n  eps = 0.;\n  relax();\n  if (eps < maxeps)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AVasK/SuperPCs_OpenMP/redb_2d_parallel_final/6"}
{"code": "for (int i = 0; i < ((height * width) * 3); i++)\n{\n  pic[i] = stretched[pic[i]];\n}\n\n", "pragma": "            #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GermanRandle/contrast-openmp/image-processor/main/8"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  for (int j = 0; j < 729; j++)\n  {\n    b[i][j] = ((double) ((i * j) + 1)) / ((double) (729 * 729));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/6"}
{"code": "for (i = BLOWFISH_ROUNDS + 1; i > 1; --i)\n{\n  Xl = Xl ^ P[i];\n  Xr = F(S, Xl) ^ Xr;\n  temp = Xl;\n  Xl = Xr;\n  Xr = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zagorskid/blowfish-omp/blowfish-omp/blowfish-omp/1"}
{"code": "for (int i = low; i < min(high, n); i++)\n{\n  for (int j = k; j < n; j++)\n  {\n    a[i][j] -= l[i][k] * u[k][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NisargGB/Multi-threaded-LU-Decomposition/pthreads_sparse/0"}
{"code": "for (size_t i = 1; i < pPower.size(); i++)\n  pPower[i] = pPower[i - 1] * P;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mserebryaakov/study-parallel-programming/Lab3-OpenMP/0"}
{"code": "for (k = 3; k <= (grid_points[2] - 4); k += 1)\n{\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][k - 2] - (4.0 * ue[m][k - 1])) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n}\n\n", "pragma": "omp parallel for private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/29"}
{"code": "for (int i = 0; i < size; i++)\n{\n  outv[i] = v1[i] / mag;\n}\n\n", "pragma": "omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-7-openmp/omp_vectors/3"}
{"code": "for (size_t i = 0; i < getLength(size(), proc, 0); i++)\n{\n  my_partition[i] = bodies[i];\n  cnu(my_partition[i], para->radius, para->gravity, snapshot);\n  my_partition[i].update_for_tick(para->elapse, para->position_range, para->radius);\n}\n\n", "pragma": "        #pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/philipzhux/parallel-n-body/src/body_pool/2"}
{"code": "for (unsigned int i = 0; i < v.size(); ++i)\n{\n  if ((v[i] % 2) == 0)\n    sums_th[0] += v[i];\n  else\n    sums_th[1] += v[i];\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sahityamantravadi/cme213-sp18/hw1code/main_q1/1"}
{"code": "for (j = 0; j < (SIZE * SIZE); j++)\n{\n  int x = j % SIZE;\n  int y = j / SIZE;\n  if (inp[x][y] != 0)\n  {\n    continue;\n  }\n\n  int pos = findPosition(x, y);\n  if (pos > 0)\n  {\n    inp[x][y] = pos;\n    printf(\"Elimination at x=%d, y=%d, val=%d\\n\", x, y, pos);\n    populate_f(x, y, pos, forward_map);\n    changed = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  res += vec1[i] * vec2[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+:res) num_threads(thrdsCount)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ngc436/Parallel-Programming-openMP1/matrix/Parallel_task1/2"}
{"code": "for (long i = 0; i < 500000000; i++)\n{\n  float x = rand_r(&seed) / ((float) 32767);\n  float y = rand_r(&seed) / ((float) 32767);\n  if (sqrt((x * x) + (y * y)) < 1)\n    localsum++;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment4/Task1/Atomic/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    score[i][j] = 0;\n    pred[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/smith-waterman/smith_waterman_par/1"}
{"code": "for (int f = 0; f < feat; f++)\n{\n  for (int oy = 0; oy < osize; oy++)\n  {\n    for (int ox = 0; ox < osize; ox++)\n    {\n      for (int fy = oy * stride; fy < (p * stride); fy++)\n      {\n        for (int fx = ox * stride; fx < (p * stride); fx++)\n        {\n          output[f][oy][ox] = max(output[f][oy][ox], input[f][fy][fx]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  TransposeSPMXNd2(M, M1, M2, M3, i, count);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/TransposeSPMX/3"}
{"code": "for (i = start; i < (start + split_length); i++)\n  compare(i, i + split_length, direction);\n\n", "pragma": "omp parallel for shared(arr, direction, start, split_length) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/bitonic-sort-project/src/openmp/bitonic_sort_openmp/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  sequential_odd_even_transposition_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/odd-even-transposition/9"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  ue[j][m] = dtemp[m];\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/18"}
{"code": "for (int i = 5; i >= 0; i--)\n{\n  printf(\"[%d] \", pos->_Cases[1][i * 16]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/2"}
{"code": "for (size_t i = 0; i < get_nnz(); i++)\n{\n  vald[i] = data[i];\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/utils/crs_constructor/1"}
{"code": "for (int x_pos2 = x_offset; x_pos2 > 0; x_pos2--)\n{\n  xans[x_pos2] = (int) '_';\n}\n\n", "pragma": "        #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/8"}
{"code": "for (j_imopVarPre85 = jst; j_imopVarPre85 <= jend; j_imopVarPre85++)\n{\n  for (k_imopVarPre86 = 1; k_imopVarPre86 <= (nz - 2); k_imopVarPre86++)\n  {\n    for (i_imopVarPre84 = ist; i_imopVarPre84 <= iend; i_imopVarPre84++)\n    {\n      for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n      {\n        rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (tx2 * (flux[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - flux[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]));\n      }\n\n    }\n\n    L2 = nx - 1;\n    for (i_imopVarPre84 = ist; i_imopVarPre84 <= L2; i_imopVarPre84++)\n    {\n      tmp_imopVarPre88 = 1.0 / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      u21i = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1];\n      u31i = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2];\n      u41i = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3];\n      u51i = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4];\n      tmp_imopVarPre88 = 1.0 / u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][0];\n      u21im1 = tmp_imopVarPre88 * u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][1];\n      u31im1 = tmp_imopVarPre88 * u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][2];\n      u41im1 = tmp_imopVarPre88 * u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][3];\n      u51im1 = tmp_imopVarPre88 * u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][4];\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = tx3 * (u31i - u31im1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = tx3 * (u41i - u41im1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((1.40e+00 * 1.40e+00) * tx3) * (u51i - u51im1));\n    }\n\n    for (i_imopVarPre84 = ist; i_imopVarPre84 <= iend; i_imopVarPre84++)\n    {\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] + ((dx1 * tx1) * ((u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][0] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0])) + u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][0]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] + (((tx3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][1] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1]))) + ((dx2 * tx1) * ((u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][1] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1])) + u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][1]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] + (((tx3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][2] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2]))) + ((dx3 * tx1) * ((u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][2] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2])) + u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][2]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] + (((tx3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][3] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3]))) + ((dx4 * tx1) * ((u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][3] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3])) + u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][3]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] + (((tx3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][4] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4]))) + ((dx5 * tx1) * ((u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][4] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4])) + u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][4]));\n    }\n\n    for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n    {\n      rsd[1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * ((((+5.0) * u[1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]) - (4.0 * u[2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + u[3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]));\n      rsd[2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * (((((-4.0) * u[1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]) + (6.0 * u[2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) - (4.0 * u[3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + u[4][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]));\n    }\n\n    ist1 = 3;\n    iend1 = nx - 4;\n    for (i_imopVarPre84 = ist1; i_imopVarPre84 <= iend1; i_imopVarPre84++)\n    {\n      for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n      {\n        rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * ((((u[i_imopVarPre84 - 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (4.0 * u[i_imopVarPre84 - 1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + (6.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) - (4.0 * u[i_imopVarPre84 + 1][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + u[i_imopVarPre84 + 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87]));\n      }\n\n    }\n\n    for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n    {\n      rsd[nx - 3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[nx - 3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * (((u[nx - 5][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (4.0 * u[nx - 4][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + (6.0 * u[nx - 3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) - (4.0 * u[nx - 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])));\n      rsd[nx - 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[nx - 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * ((u[nx - 4][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (4.0 * u[nx - 3][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) + (5.0 * u[nx - 2][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/8"}
{"code": "for (int i = 0; i < NUM; i++)\n{\n  ans += v1[i] * v2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ssssmiyassss/openmp_test/test00/1"}
{"code": "for (localX = 0; local < 10; localX++)\n{\n  {\n    localY = x;\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/src/imop/lib/testcases/cfgTests/orderedConstruct/0"}
{"code": "for (unsigned i = 0; i < x.size(); ++i)\n{\n  int nz;\n  int ierr;\n  zbesj_(&x[i], &y[i], &r_1, &c_1, &c_1, &re_ref[i], &im_ref[i], &nz, &ierr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/2"}
{"code": "for (ii = 0; ii < num_steps; ii++)\n{\n  x = (ii + 0.5) * step;\n  x2 = 4.0 / (1.0 + (x * x));\n  sum = sum + x2;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(x,x2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/OpenMP---Examples/openmp/example2/reduction_pi/0"}
{"code": "for (int i = 0; i < 10; i++)\n  x = i;\n\n", "pragma": "omp for lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hermannwilfried694/OpenMP1/lastpriv/0"}
{"code": "for (size_t i = 0; i != count; ++i)\n{\n  vrt[i].x = rx[i];\n  vrt[i].y = ry[i];\n  vrt[i].z = rz[i];\n  vel[i].x = vx[i];\n  vel[i].y = vy[i];\n  vel[i].z = vz[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_cuda/1"}
{"code": "for (i = 0; i < 1000; i++)\n  printf(\"%.2f, %.2f, %.2f\\n\", matrix[i][0], matrix[i][1], matrix[i][2]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/fjc/1"}
{"code": "for (int k = 0; k < lenght_n; k++)\n  a[ir][k] = (a[ir][k] * 2.0) / (lenght_n + 1);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/math/fourier/2"}
{"code": "for (int i = 0; i < k; i++)\n  cin >> genes[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel1/0"}
{"code": "for (k = 0; k < n; k++)\n{\n  if ((k % 2) == 0)\n    factor = 1.0;\n  else\n    factor = -1.0;\n\n  sum += k;\n  n1 += k;\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(thread_count)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pengjintao/OpenMP/06_omp_explicit_variable/0"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  sum += i;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(sum) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kw90/OpenMP/summation/1"}
{"code": "for (k = nz / 2; k < (3 * (nz / 4)); k++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    for (i = 1; i < (nx - 1); i++)\n    {\n      Anext[Index3D(nx, ny, i, j, k)] = (((((A0[Index3D(nx, ny, i, j, k + 1)] + A0[Index3D(nx, ny, i, j, k - 1)]) + A0[Index3D(nx, ny, i, j + 1, k)]) + A0[Index3D(nx, ny, i, j - 1, k)]) + A0[Index3D(nx, ny, i + 1, j, k)]) + A0[Index3D(nx, ny, i - 1, j, k)]) - ((6.0 * A0[Index3D(nx, ny, i, j, k)]) / (fac * fac));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/stencil/3dHeat/Variations/heat_ompv2/2"}
{"code": "for (i = 0; i < r_length; i++)\n{\n  for (j = 0; j < c_length; j++)\n  {\n    aT[(j * r_length) + i] = a[(i * c_length) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/par_mm/4"}
{"code": "for (k = 0; k < n; k++)\n{\n  t = omp_get_thread_num();\n  did_something = 0;\n  do\n  {\n    temp = 0;\n    omp_set_lock(&mtx);\n    temp = flags[k];\n    omp_unset_lock(&mtx);\n    if (temp == 1)\n    {\n      for (j = k + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] / A[k][k];\n        s_l[j] = A[k][j];\n      }\n\n      s_l[k] = 1;\n      y[k] = b[k] / A[k][k];\n      A[k][k] = 1;\n      s_v_r = y[k];\n      s_index = k;\n      omp_set_lock(&mtx);\n      flags[k] = 2;\n      for (j = k + 1; j < n; j++)\n        flags[j] = 3;\n\n      flags[k + 1] = 4;\n      omp_unset_lock(&mtx);\n      did_something = 1;\n    }\n\n    if (temp == 3)\n    {\n      for (j = s_index + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] - (A[k][s_index] * s_l[j]);\n      }\n\n      b[k] = b[k] - (A[k][s_index] * s_v_r);\n      A[k][s_index] = 0;\n      omp_set_lock(&mtx);\n      flags[k] = 0;\n      omp_unset_lock(&mtx);\n      did_something = 1;\n    }\n\n    if (temp == 4)\n    {\n      for (j = s_index + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] - (A[k][s_index] * s_l[j]);\n      }\n\n      b[k] = b[k] - (A[k][s_index] * s_v_r);\n      A[k][s_index] = 0;\n      omp_set_lock(&mtx);\n      flags[k] = 1;\n      omp_unset_lock(&mtx);\n      did_something = 1;\n    }\n\n    if (temp == 2)\n      did_something = 1;\n\n  }\n  while (!did_something);\n}\n\n", "pragma": "omp parallel for schedule(static,1) shared(y,n,s_l, flags,s_v_r , s_index) private(j,t,did_something,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/leahu/0"}
{"code": "for (int i = c; i <= 5; i++)\n{\n  if ((newPos->_Cases[j][16 * i] == 2) || (newPos->_Cases[j][16 * i] == 3))\n  {\n    newPos->_PionsPris[joueur] += newPos->_Cases[j][16 * i];\n    newPos->_Cases[j][16 * i] = 0;\n  }\n  else\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif_padding/9"}
{"code": "for (int i = 0; i < thread_number; i++)\n{\n  temp[i] = malloc(column_size * (sizeof(double)));\n  result[i] = 0.0;\n  for (int j = 0; j < column_size; j++)\n    temp[i][j] = 0.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/3"}
{"code": "for (i = 0; i < (rows * columns); i++)\n  culture_cells[i] = 0;\n\n", "pragma": "omp parallel for default(none) shared(rows, columns, culture_cells) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HylianPablo/Paralela2020/PRACTICA1 - OPENMP/OpenMP - Version final/backup/2"}
{"code": "for (unsigned int i = 0; i < (nodes.size() - 1); ++i)\n{\n  double partial_sum = find_calculated_data(nodes.at(i), nodes.at(i + 1));\n  if (partial_sum != (-1))\n  {\n    sum += partial_sum;\n  }\n  else\n  {\n    partial_sum = get_distance(nodes.at(i), nodes.at(i + 1), mapa);\n    add_to_calculated_data(nodes.at(i), nodes.at(i + 1), partial_sum);\n    sum += partial_sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/19"}
{"code": "for (ii = 0; ii < params.maxIters; ii++)\n{\n  accelerate_flow(params, cells, obstacles);\n  propagate(params, cells, tmp_cells);\n  av_vels[ii] = collision(params, cells, tmp_cells, obstacles);\n  add_frame(params, cells, obstacles, vw);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/an4/HPC-OpenMP/d2q9-bgk/10"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  A[i] = i;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB049-fprintf-orig-no/0"}
{"code": "for (int i = 0; i < lda; i += LARGE_M)\n{\n  int M = (LARGE_M < (lda - i)) ? (LARGE_M) : (lda - i);\n  for (int j = 0; j < lda; j += LARGE_N)\n  {\n    int N = (LARGE_N < (lda - j)) ? (LARGE_N) : (lda - j);\n    for (int k = 0; k < lda; k += LARGE_K)\n    {\n      int K = (LARGE_K < (lda - k)) ? (LARGE_K) : (lda - k);\n      divide_into_small_blocks(weird_A + ((i * lda) + (k * 8)), B + ((j * lda) + k), C + ((j * lda) + i), M, N, K, lda);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-bad/6"}
{"code": "for (i = 0; i < E; i++)\n{\n  scanf(\"%d %d %d\", &graph->edge[i].src, &graph->edge[i].dest, &graph->edge[i].weight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sneha711/OpenMP/bellman_parallel/4"}
{"code": "for (int i = 0; i < this->coo_nnz_; ++i)\n{\n  this->mat_.COO.val[i] = cast_mat->mat_.COO.val[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_hyb/4"}
{"code": "for (i = 2; i <= n; i++)\n{\n  if (prime[i] == 1)\n  {\n    printf(\"%d\\n \", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp4/prime/2"}
{"code": "for (i = 0; i < (MAX_THREADS * padding); i++)\n{\n  if (maxval[i] > maxval2)\n  {\n    maxval2 = maxval[i];\n    maxloc2 = maxloc[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_non_critical/4"}
{"code": "for (int i = 0; i < vecsize; i++)\n  if (((i + 1) % 2) != 0)\n  sum_seq += vec1[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab5/lab5/1"}
{"code": "for (j = 1; j < (n - 1); j++)\n  for (k = 0; k < 3; k++)\n  Q[j + (n * (i + (m * k)))] = Q[j + (n * (i + (m * k)))] - ((dt / dy) * (nFy[k][j + 1] - nFy[k][j]));\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/5"}
{"code": "for (k = 0; k < N; k++)\n  for (j = k + 1; j < N; j++)\n{\n  T = M[(k * N) + j];\n  M[(k * N) + j] = M[(j * N) + k];\n  M[(j * N) + k] = T;\n}\n\n\n", "pragma": "omp parallel for private(k,j,T)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoecheverria/openmp-lab/masterOMP/3"}
{"code": "for (i = jz; i > 1; i--)\n{\n  double fv = fq[i - 1] + fq[i];\n  fq[i] += fq[i - 1] - fv;\n  fq[i - 1] = fv;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/21"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (((i == j) || ((i - 1) == j)) || ((i + 1) == j))\n    {\n      val = rand() % 100;\n    }\n    else\n    {\n      val = 0;\n    }\n\n    (*matrix)[i][j] = val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/5"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_key[index], saved_len[index]);\n  SHA512_Update(&ctx, saved_salt->data.c, saved_salt->len);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ssha512_fmt_plug/1"}
{"code": "for (i = 0; i < 2; i++)\n{\n  yc[ielnew][i] = y1;\n  yc[ielnew][i + 4] = y1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/18"}
{"code": "for (int r = 0; r < N; r++)\n{\n  dest[r] = (int *) malloc(N * (sizeof(int)));\n  assert(dest[r] != 0);\n  for (int c = 0; c < N; c++)\n  {\n    dest[r][c] = from[r][c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CI4822-EneMar2020/BombingField/src/6"}
{"code": "for (i = 0; i <= (1000 + 1); i++)\n{\n  for (j = 0; j <= (1000 + 1); j++)\n  {\n    t[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kuanweih/XSEDE-HPC-Workshop/Exercises-my/OpenMP/Examples/laplace_parallel_region/3"}
{"code": "for (int j = 0; j < 100; j++)\n{\n  generateExecTasks();\n  runTasks_1();\n  runTasks_2();\n  runTasks_3();\n  runTasks_4();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p4/task/0"}
{"code": "for (int x = 3; x < (N_x + 3); x++)\n{\n  for (int y = 3; y < (N_y + 3); y++)\n  {\n    f[x][y] = ((((-v_x[x][y]) * (((((((1.0 / 60.0) * v_y[x + 3][y]) - ((1.0 / 60.0) * v_y[x - 3][y])) - ((3.0 / 20.0) * v_y[x + 2][y])) + ((3.0 / 20.0) * v_y[x - 2][y])) + ((3.0 / 4.0) * v_y[x + 1][y])) - ((3.0 / 4.0) * v_y[x - 1][y]))) / Delta_x) - ((v_y[x][y] * (((((((1.0 / 60.0) * v_y[x][y + 3]) - ((1.0 / 60.0) * v_y[x][y - 3])) - ((3.0 / 20.0) * v_y[x][y + 2])) + ((3.0 / 20.0) * v_y[x][y - 2])) + ((3.0 / 4.0) * v_y[x][y + 1])) - ((3.0 / 4.0) * v_y[x][y - 1]))) / Delta_y)) - ((g * (((((((1.0 / 60.0) * h[x][y + 3]) - ((1.0 / 60.0) * h[x][y - 3])) - ((3.0 / 20.0) * h[x][y + 2])) + ((3.0 / 20.0) * h[x][y - 2])) + ((3.0 / 4.0) * h[x][y + 1])) - ((3.0 / 4.0) * h[x][y - 1]))) / Delta_y);\n  }\n\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anubhav-cs/Numerical-Methods/Shallow Water Flow/shallow_water_openmp/10"}
{"code": "for (int i = 0; i < this->index_size_; ++i)\n{\n  values[i] = this->vec_[this->index_array_[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/38"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int k = 0; k < n; k++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      mat_3[i][j] = mat_3[i][j] + (mat_1[i][k] * mat_2[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment2/2"}
{"code": "for (i = 0; i < 11; i++)\n{\n  if ((edges[i].u == u.title) && (edges[i].v == v.title))\n  {\n    return weights[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/upadhyatejas/HPC-parallelization/djiparallel/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = (double *) malloc(n * (sizeof(double *)));\n  b[i] = (double *) malloc(n * (sizeof(double *)));\n  r[i] = (double *) malloc(n * (sizeof(double *)));\n  for (j = 0; j < N; j++)\n  {\n    a[i][j] = 1;\n    b[i][j] = 1;\n    r[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/matrix_parallel_block/1"}
{"code": "for (i = 0; i < arraysize; i++)\n{\n  array_A[i] = i + 5;\n  checkarray[i] = array_A[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPforClause/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  v[i][0] /= tempSum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/7"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  if (scanf(\"%f\", &aMatr[wI]) != 1)\n  {\n    fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d\\n\", wI);\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/13"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    sharp[i][j] = fuzzyPadded[i + d][j + d] - ((scale / norm) * convolution[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/z4/dosharpen/6"}
{"code": "for (i = 0; i < numOfProcs; i++)\n{\n  dispCoords[i] = counter * pointDim;\n  dispPoints[i] = counter;\n  if (i == root)\n  {\n    countsPoints[i] = rootDatabaseSize;\n    countsCoords[i] = rootDatabaseSize * pointDim;\n    counter += rootDatabaseSize;\n  }\n  else\n  {\n    countsPoints[i] = othersDatabaseSize;\n    countsCoords[i] = othersDatabaseSize * pointDim;\n    counter += othersDatabaseSize;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/MPI_Kmeans/0"}
{"code": "for (int i = 0; i < nrows; ++i)\n{\n  const float norm = sqrt(_sqsum[i]);\n  for (int j = indptr[i]; j < indptr[i + 1]; ++j)\n  {\n    data[j] /= norm;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/data/0"}
{"code": "for (c = 0; c < p; c++)\n{\n  for (d = 0; d < q; d++)\n  {\n    printf(\"%d\\t\", second[c][d]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javierchacon262/IntroPP2160044_1/omp_matrixMultiplication/4"}
{"code": "for (int _i = 0; _i < omp_num_threads; _i++)\n  for (int _j = 0; _j < 3; _j++)\n  stack_sizes_overview[_i][_j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MickiFoerster/spl-transformer/test-suite/adjoint-test-wt-p-threads/3"}
{"code": "for (int j = 0; j < 10; ++j)\n  ++a;\n\n", "pragma": "#pragma omp distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/7"}
{"code": "for (int k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    yvel1[FTNREF2D((x_max + 1) + j, k, x_max + 5, x_min - 2, y_min - 2)] = yvel1[FTNREF2D((x_max + 1) - j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/43"}
{"code": "for (int i = 0; i < k; ++i)\n{\n  for (int j = 0; j < m; ++j)\n    fprintf(fp, (j == (k - 1)) ? (\"%d\") : (\"%d \"), b[i][j]);\n\n  fprintf(fp, (i == (m - 1)) ? (\"\") : (\"\\n\"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/4/matrixMultiplication/3"}
{"code": "for (i = start_n; i < (start_n + length_n); i++)\n{\n  for (j = 0; j < n; j++)\n    y[i] += a[(i * n) + j] * x[j];\n\n}\n\n", "pragma": "omp parallel for simd shared(y, x, a, start_n, length_n) private(i,j) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matvec/matvec_cpu_omp_kernel/0"}
{"code": "for (k = 0; k < M; k++)\n{\n  MPI_Status status;\n  for (int procid = 0; procid < np; procid++)\n  {\n    if (procid == id)\n      continue;\n\n    MPI_Send(x, n, MPI_DOUBLE, procid, 0, MPI_COMM_WORLD);\n    MPI_Recv(X + (procid * n), n, MPI_DOUBLE, procid, 0, MPI_COMM_WORLD, &status);\n  }\n\n  for (i = 0; i < n; i++)\n  {\n    ai = a + (i * N);\n    for (j = 0; j < N; j++)\n      y[i] += ai[j] * X[j];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/denis-anuprienko/mvm21/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    lent[i][j] = 0;\n    for (int t = 0; t < o; t++)\n    {\n      lent[i][j] += A[i][t] * B[t][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task4/2"}
{"code": "for (i = 0; i < world->num_bodies; i++)\n{\n  int my_rank = omp_get_thread_num();\n  for (j = i + 1; j < world->num_bodies; j++)\n  {\n    diff_x = world->bodies[j].x - world->bodies[i].x;\n    diff_y = world->bodies[j].y - world->bodies[i].y;\n    d = sqrt((diff_x * diff_x) + (diff_y * diff_y));\n    if (d < 25)\n    {\n      d = 25;\n    }\n\n    d_cubed = (d * d) * d;\n    loc_forces_x[my_rank][i] += (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_x;\n    loc_forces_y[my_rank][i] += (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_y;\n    loc_forces_x[my_rank][j] -= (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_x;\n    loc_forces_y[my_rank][j] -= (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_y;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(world,thread_count,loc_forces_x,loc_forces_y) private(diff_x,diff_y,d,d_cubed,i,j) schedule(static,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuanshengHu/Parallel-and-Distributed-Programming/2/nbody_openMP_IMPROVED/1"}
{"code": "for (int i = 0; i < cols; i++)\n{\n  a_reduced[i] = 0;\n  for (int j = 0; j < rows; j++)\n  {\n    a_reduced[i] += (int32_t) a[(i * rows) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rgr19/MKL-DNN_Eigen_Boost_OpenMPI_GoogleTests_Examples/src/bin/mkl-dnn/simple_rnn_int8/0"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  rho += r[j] * r[j];\n}\n\n", "pragma": "\t#pragma omp for reduction(+:rho)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/9"}
{"code": "for (unsigned short l_tg = 0; l_tg < m_nGroups; l_tg++)\n{\n  ((((((((EDGE_V_LOG_INFO << \"  \") << l_tg) << \" \") << m_nGroupEls[l_tg]) << \" [\") << m_tsIntervals[l_tg]) << \", \") << m_tsIntervals[l_tg + 1]) << \"[\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/time/Groups/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n    b[i][j] = (i * m) + j;\n\n}\n\n", "pragma": "omp parallel for private(i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB015-outofbounds-var-yes/0"}
{"code": "for (int j = 0; j < Freq_cell; ++j)\n{\n  for (int i = 0; i < Holo_Freq_cell; ++i)\n  {\n    fprintf(map_fp, \"%f,\", hhs_map[j][i]);\n  }\n\n  fprintf(map_fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/53"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    E[(i * 1000) + j] = 0.0;\n    for (int k = 0; k < 1000; ++k)\n    {\n      E[(i * 1000) + j] += C[(i * 1000) + k] * D[(k * 1000) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse (1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/1"}
{"code": "for (int i = 0; i < nf; ++i)\n{\n  getline(R, line);\n  freq[i] = stof(line);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/fdt/0"}
{"code": "for (j = 0; j < cache->assoc; j++)\n{\n  setPLRU(&cache->cacheLines[i][j], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/13"}
{"code": "for (int i = 0; i < count; i++)\n{\n  printf(\"%d \", res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab6_OpenMP/Lab6_OpenMP/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  arr[i] = arr[i] * 2;\n}\n\n", "pragma": "omp target parallel for map(tofrom: arr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/assume/test_assume_holds/0"}
{"code": "for (int j = loop_chunk; j < (n - 1); j += 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    swap(arr[j], arr[j + 1]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) ,shared(arr,loop_chunk, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMPTask/5.assignment-openmp-advanced/5.assignment-openmp-advanced/bubblesort/bubblesort/0"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (k = 0; k < K; ++k)\n  {\n    char A_PART = A[(i * lda) + k];\n    if (A_PART)\n    {\n      for (j = 0; j < N; ++j)\n      {\n        C[(i * ldc) + j] += B[(k * ldb) + j];\n      }\n\n    }\n    else\n    {\n      for (j = 0; j < N; ++j)\n      {\n        C[(i * ldc) + j] -= B[(k * ldb) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openmpf/openmpf-component-archive/DarknetDetection/darknet_lib/src/gemm/4"}
{"code": "for (i = 1; i < (width - 1); i++)\n{\n  for (j = 1; j < (height - 1); j++)\n  {\n    const int c = i + (width * j);\n    const int nn = c - width;\n    const int ss = c + width;\n    const int ww = c + 1;\n    const int ee = c - 1;\n    const int nw = nn + 1;\n    const int ne = nn - 1;\n    const int sw = ss + 1;\n    const int se = ss - 1;\n    const float dir = ((float) (fmod(atan2(after_Gy[c], after_Gx[c]) + M_PI, M_PI) / M_PI)) * 8;\n    if (((((((dir <= 1) || (dir > 7)) && (G[c] > G[ee])) && (G[c] > G[ww])) || ((((dir > 1) && (dir <= 3)) && (G[c] > G[nw])) && (G[c] > G[se]))) || ((((dir > 3) && (dir <= 5)) && (G[c] > G[nn])) && (G[c] > G[ss]))) || ((((dir > 5) && (dir <= 7)) && (G[c] > G[ne])) && (G[c] > G[sw])))\n      nms[c] = G[c];\n    else\n      nms[c] = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) shared(nms) num_threads(nthreads) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheTwoOfUs/video-canny-edge-detection/mpi-omp/mpi-omp/2"}
{"code": "for (uint64_t b = 0; b < NUM_BUCKETS; b++)\n{\n  chunk_bucket_offsets[(b * num_threads) + 0] = local_bucket_offsets[b];\n  for (int w = 1; w < num_threads; w++)\n  {\n    chunk_bucket_offsets[(b * num_threads) + w] = chunk_bucket_offsets[((b * num_threads) + w) - 1] + bucket_counts_per_chunk[w - 1][b];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/7"}
{"code": "for (i = 0; i < 4; i++)\n{\n  zc[ielnew][i] = z1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/20"}
{"code": "for (j = 0; j < p_work; j++)\n  mark_table[j] = '0';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Sieve_of_Eratosthenes_MPI_and_OpenMP/src/sieve_of_erath/1"}
{"code": "for (INT i = 0; i < nzz_num; i++)\n{\n  fscanf(fp_mtx, \"%d %d %lf\", &col, &row, &nzz);\n  row--;\n  while (v < row)\n  {\n    v++;\n    if ((cnt % mtx_width) != 0)\n    {\n      cnt = (((cnt + mtx_width) - 1) / mtx_width) * mtx_width;\n    }\n\n    row_ptr[v] = cnt;\n  }\n\n  col_idx[cnt] = col;\n  mtx_val[cnt] = nzz;\n  cnt++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/CSR2/CSR2_SPMV/1"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  struct tablo *SubMatrixAByRows = allocateTablo(getSizeSubmatrixDividedByRows(matrixA, numprocs));\n  getSubmatrixDividedByRows(matrixA, SubMatrixAByRows, i, numprocs);\n  send_slice(SubMatrixAByRows->tab, SubMatrixAByRows->size, i);\n  free(SubMatrixAByRows);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/13"}
{"code": "for (i = 0; i < numOfPoints; i++)\n{\n  int sign = getSign(classified[i]);\n  const double *point = getPointAtLocation(points, i);\n  if (sign != points->tags[i])\n  {\n    redefineWeights(W, w0, alpha, k, points->tags[i], point);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roteml8/binary_classification/BinaryClassifier/4"}
{"code": "for (int i = 0; i < noOfChar; i++)\n{\n  messageStream << symbol;\n  encodedStream << encoder.Encode2(symbol);\n  symbol = inputFile.get();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MeetSable/Huffman-encoding-and-Adaptive-Huffman-encoding-OpenMP/adaptiveHuffman/0"}
{"code": "for (int k = 0; k < o; k++)\n{\n  fprintf(fp, \"# z = %g\\n\", k * dl);\n  for (int j = 0; j < m; j++)\n  {\n    for (int i = 0; i < n; i++)\n    {\n      fprintf(fp, \"%.1f \", T[(((k * n) * m) + (j * n)) + i] - 273.15);\n    }\n\n    fprintf(fp, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/heatsink_openmp/5"}
{"code": "for (int i = 0; i <= m_nSubbasins; i++)\n{\n  tmp_surfq2ch[i] = 0.f;\n  tmp_sed2ch[i] = 0.f;\n  tmp_sno32ch[i] = 0.f;\n  tmp_snh42ch[i] = 0.f;\n  tmp_solp2ch[i] = 0.f;\n  tmp_cod2ch[i] = 0.f;\n  tmp_orgn2ch[i] = 0.f;\n  tmp_orgp2ch[i] = 0.f;\n  tmp_minpa2ch[i] = 0.f;\n  tmp_minps2ch[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IMP_SWAT/pothole_SWAT/2"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  a = a + i;\n  a = a * a;\n  result[i] = a;\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture8/ScopeOfVariables/ScopeOfVariables/0"}
{"code": "for (r = 0, pos = 0; r < rows; r++)\n{\n  for (c = 0; c < cols; c++, pos++)\n  {\n    if (edge[pos] == 128)\n      hist[mag[pos]]++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/14"}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char iv[16];\n  unsigned char key[32];\n  unsigned char outbuf[16];\n  AES_KEY aes_decrypt_key;\n  int len = strlen(saved_key[index]);\n  if (cracked[index])\n    cracked[index] = 0;\n\n  if (cur_salt->type == 1)\n  {\n    unsigned char c;\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, saved_key[index], len);\n    MD5_Update(&ctx, cur_salt->salt, 8);\n    MD5_Final(key, &ctx);\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, key, 16);\n    MD5_Update(&ctx, saved_key[index], len);\n    MD5_Update(&ctx, cur_salt->salt, 8);\n    MD5_Final(key + 16, &ctx);\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, key + 16, 16);\n    MD5_Update(&ctx, saved_key[index], len);\n    MD5_Update(&ctx, cur_salt->salt, 8);\n    MD5_Final(iv, &ctx);\n    AES_set_decrypt_key(key, 256, &aes_decrypt_key);\n    AES_cbc_encrypt(cur_salt->block, outbuf, 16, &aes_decrypt_key, iv, AES_DECRYPT);\n    c = outbuf[0];\n    if ((((c == 'L') || (c == 'K')) || (c == '5')) || (c == 'Q'))\n    {\n      if (is_base58(outbuf + 1, 15))\n      {\n        AES_cbc_encrypt(cur_salt->block + 16, outbuf, 16, &aes_decrypt_key, iv, AES_DECRYPT);\n        if (is_base58(outbuf, 16))\n          cracked[index] = 1;\n\n      }\n\n    }\n    else\n      if (c == '#')\n    {\n      if (memcmp((const char *) outbuf, \"# KEEP YOUR PRIV\", 8) == 0)\n        cracked[index] = 1;\n\n    }\n    else\n      if (c == '\\x0a')\n    {\n      if (is_bitcoinj_protobuf_data(outbuf))\n        cracked[index] = 1;\n\n    }\n\n\n\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    UTF16 password[(125 * 2) + 1];\n    len = enc_to_utf16_be(password, 125, (const unsigned char *) saved_key[index], len + 1);\n    if (len < 0)\n      len = strlen16(password);\n\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    static const yescrypt_params_t params = {.N = 16384, .r = 8, .p = 1};\n    if (yescrypt_kdf(0, &local[t], (const uint8_t *) password, (len + 1) * 2, (const uint8_t *) salt_hardcoded, 8, &params, key, 32))\n    {\n      failed = (errno) ? (errno) : (EINVAL);\n    }\n\n    AES_set_decrypt_key(key, 128 * 2, &aes_decrypt_key);\n    memcpy(iv, cur_salt->iv, 16);\n    AES_cbc_encrypt(cur_salt->block, outbuf, 16, &aes_decrypt_key, iv, AES_DECRYPT);\n    if (is_bitcoinj_protobuf_data(outbuf))\n      cracked[index] = 1;\n    else\n    {\n      AES_set_decrypt_key(key, 128 * 2, &aes_decrypt_key);\n      memcpy(iv, iv_hardcoded, 16);\n      AES_cbc_encrypt(cur_salt->block2, outbuf, 16, &aes_decrypt_key, iv, AES_DECRYPT);\n      if (is_bitcoinj_protobuf_data(outbuf))\n        cracked[index] = 1;\n\n    }\n\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    UTF16 password[(125 * 2) + 1];\n    len = enc_to_utf16_be(password, 125, (const unsigned char *) saved_key[index], len + 1);\n    if (len < 0)\n      len = strlen16(password);\n\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    yescrypt_params_t params = {.N = cur_salt->n, .r = cur_salt->r, .p = cur_salt->p};\n    if (yescrypt_kdf(0, &local[t], (const uint8_t *) password, (len + 1) * 2, (const uint8_t *) cur_salt->salt, 8, &params, key, 32))\n    {\n      failed = (errno) ? (errno) : (EINVAL);\n    }\n\n    memcpy(iv, cur_salt->block, 16);\n    AES_set_decrypt_key(key, 256, &aes_decrypt_key);\n    AES_cbc_encrypt(cur_salt->block + 16, outbuf, 16, &aes_decrypt_key, iv, AES_DECRYPT);\n    if (!memcmp(outbuf, \"\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\", 16))\n      cracked[index] = 1;\n\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/multibit_fmt_plug/0"}
{"code": "for (int i = 0; i < sim->LANES; i++)\n{\n  for (int j = 0; j < length; j++)\n  {\n    if (grid[(sim->L * i) + j] != (-1))\n    {\n      printf(\"\\033[1;32m%d\\033[0m\", cars[grid[(sim->L * i) + j]].lane_change_now);\n    }\n    else\n    {\n      printf(\"\\033[2;35m\\u2588\\033[0m\");\n    }\n\n  }\n\n  printf(\"\\n\\033[K\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/13"}
{"code": "for (int RowId = 0; RowId < RowN; RowId++)\n{\n  out->PutInt(m[RowId]);\n  out->PutCh('\\n');\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/18"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dtty2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/70"}
{"code": "for (int j = i + 1; j < m; j++)\n{\n  A[(i * n) + j] /= x;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shorin1/openMP/openMP/openMP/5"}
{"code": "for (i = 0; i < heightA; i++)\n{\n  for (j = 0; j < widthB; j++)\n  {\n    *(C + ((i * rstrideC) + j)) += (*(A + ((i * rstrideA) + k))) * (*(B + ((j * rstrideB) + k)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/mmult/strass/3"}
{"code": "for (int i = li_mImage; i < x_ls_mImage; i++)\n{\n  for (int j = li_mImage; j < y_ls_mImage; j++)\n  {\n    mImage[i][j] = image[i - 2][j - 2];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) num_threads(thread_count) shared(mImage, image)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/Filter/Filter/2"}
{"code": "for (int i = 0; i < vectorCount; ++i)\n{\n  threadFunction(i, vectorCount, &vectors);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tigran-kocharyan/cpp_openmp_coplanar_vectors/main/2"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = nxhd * i;\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[j1 + joff];\n      f[j1 + joff] = f[j + joff];\n      f[j + joff] = t1;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        t1 = sct[kmr * j];\n        t2 = t1 * f[(j + k2) + joff];\n        f[(j + k2) + joff] = f[(j + k1) + joff] - t2;\n        f[(j + k1) + joff] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxy / nx;\n  ani = 0.5 / (((float) nx) * ((float) ny));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    t2 = conjf(f[(nxh - j) + joff]);\n    t1 = f[j + joff] + t2;\n    t2 = (f[j + joff] - t2) * t3;\n    f[j + joff] = ani * (t1 + t2);\n    f[(nxh - j) + joff] = ani * conjf(t1 - t2);\n  }\n\n  ani = 2.0 * ani;\n  f[nxhh + joff] = ani * conjf(f[nxhh + joff]);\n  f[joff] = ani * ((crealf(f[joff]) + cimagf(f[joff])) + ((crealf(f[joff]) - cimagf(f[joff])) * _Complex_I));\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,j1,joff,ani,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/21"}
{"code": "for (int row = 1; row < (Ny - 1); ++row)\n{\n  dU[row * Nx] = ((((-3.0) * U[row * Nx]) + U[(row + 1) * Nx]) + U[(row - 1) * Nx]) + U[(row * Nx) + 1];\n  dV[row * Nx] = ((((-3.0) * V[row * Nx]) + V[(row + 1) * Nx]) + V[(row - 1) * Nx]) + V[(row * Nx) + 1];\n  dU[((row + 1) * Nx) - 1] = ((((-3.0) * U[((row + 1) * Nx) - 1]) + U[((row + 1) * Nx) - 2]) + U[(row * Nx) - 1]) + U[((row + 2) * Nx) - 1];\n  dV[((row + 1) * Nx) - 1] = ((((-3.0) * V[((row + 1) * Nx) - 1]) + V[((row + 1) * Nx) - 2]) + V[(row * Nx) - 1]) + V[((row + 2) * Nx) - 1];\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raihaan123/HPC/CPP/src/ReactionDiffusion/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    mat_3[i][j] = 0;\n    for (int k = 0; k < n; k++)\n    {\n      mat_3[i][j] = mat_3[i][j] + (mat_1[i][k] * mat_2[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment2/1"}
{"code": "for (int i = -1; i <= 1; i++)\n{\n  for (int j = -1; j <= 1; j++)\n  {\n    if (!((i == 0) && (j == 0)))\n    {\n      if ((((row + i) >= 0) && ((row + i) < this->gridRow)) && (((column + j) >= 0) && ((column + j) < this->gridColumn)))\n      {\n        neighbours.push_back(this->nextCellGrid[row + i][column + j]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/batux/parallel_conway_game_of_life/parallel_game_of_life/src/ParallelGameOfLife/2"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < columns; j++)\n  {\n    if (ocean[i][j].type == 2)\n    {\n      ocean[i][j].moved = 0;\n    }\n\n    if (ocean[i][j].type == 1)\n    {\n      ocean[i][j].moved = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JJ0421/Planet-Wa-Tor/Finale/8"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  assignew = DoptBCDOne(data_proc.rows(0, cov_num - 1), n, cov_num);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Up;\n  TU = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (Up - diff_data);\n  mupdate = ((Up - diff_data) > (2 * (Um - diff_data))) || ((Up - diff_data) < ((Um - diff_data) * 0.5));\n  Up = (TU > (diff_data - ((Up * n1c) / n))) ? (Up - ((c * alpha) / m)) : (Up + ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Um = (mupdate) ? (Up) : (Um);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/30"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = (static_cast < ValueType) > 1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/6"}
{"code": "for (int i = 0; i < train_len; i++)\n  X_train[i] = X[index[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/2"}
{"code": "for (int i = 0; i <= start_point_boundary; i++)\n{\n  ULL minimum = 0ULL - 1ULL;\n  ULL temp_sum;\n  const int split_point_boundary = (i + length) - 2;\n  const int end_boundary = (i + length) - 1;\n  for (int j = i; j <= split_point_boundary; j++)\n  {\n    temp_sum = (dptable[i][j] + ((dimensions[i] * dimensions[j + 1]) * dimensions[i + length])) + dptable[j + 1][end_boundary];\n    if (temp_sum < minimum)\n    {\n      minimum = temp_sum;\n    }\n\n  }\n\n  dptable[end_boundary][i] = (dptable[i][end_boundary] = minimum);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10203/fast_matrix/3"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    adj = adjacent(grid1, size, x, y);\n    if ((adj < 2) || (adj > 3))\n      grid2[x][y] = 0;\n\n    if (adj == 2)\n      grid2[x][y] = grid1[x][y];\n\n    if (adj == 3)\n      grid2[x][y] = 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(grid1, grid2, size) private(x, y, adj) schedule(dynamic, CHUNKSIZE)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SgtSwagrid/supercomputing/02 - Conway+RDF/life/0"}
{"code": "for (int nt = 0; nt < size; nt++)\n{\n  startthread.push_back(nt * ((int) (l / size)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/6"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  data[i] = tmpdata[i];\n  ptr[i] = tmpptr[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/1"}
{"code": "for (int data_idx = 0; data_idx < 10; data_idx++)\n{\n  int bucket = 0;\n  while ((bucket < (kBuckets - 1)) && (data[data_idx] > tresholds[bucket]))\n  {\n    bucket++;\n  }\n\n  omp_set_lock(&histogram_locks[bucket]);\n  histogram[bucket]++;\n  omp_unset_lock(&histogram_locks[bucket]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olszewskip/openmp_notes/locks0/0"}
{"code": "for (i = 0; i <= n2; i++)\n{\n  for (j = 0; j <= n3; j++)\n  {\n    fastcopy(&new_t->hidden_weights[i][j], &mem[memcnt], sizeof(float));\n    memcnt += sizeof(float);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/14"}
{"code": "for (i = 0; i < N; i++)\n  fprintf(bubbleFile, \"%d \", isBound[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/4"}
{"code": "for (register int l = -lmax; l < (lmax + 1); l++)\n{\n  deltaf += (((((a3[l + lmax] * Ex_mod) * exp(I * Ex_phase)) + ((a1[l + lmax] * Ey_mod) * exp(I * Ey_phase))) + ((a2[l + lmax] * Ez_mod) * exp(I * Ez_phase))) / (((kpar * vpar) + (l * om_c)) - omega)) * exp(((-I) * phi) * ((double) l));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/22"}
{"code": "for (int i = SIZE; i > 0; i--)\n{\n  for (int j = 1; j <= i; j++)\n  {\n    if (a[j] > a[j - 1])\n    {\n      int tmp = a[j];\n      a[j] = a[j - 1];\n      a[j - 1] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(a) schedule(static) firstprivate(i, j)  num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IvanOnJava/OpenMP_examples/OpenMP_example_BubleSort/1"}
{"code": "for (int i = 0; i < ((nr_class * (nr_class - 1)) / 2); i++)\n  fprintf(fp, \" %g\", model->rho[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/86"}
{"code": "for (i = nxi - 1; i < nxt; i++)\n{\n  for (k = 0; k < ny; k++)\n  {\n    koff = (2 * nxhd) * k;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (2 * nxhd) * k1;\n      v_t1 = _mm_load_ps((float *) (&f[(2 * i) + k1]));\n      v_t2 = _mm_load_ps((float *) (&f[(2 * i) + koff]));\n      _mm_store_ps((float *) (&f[(2 * i) + k1]), v_t2);\n      _mm_store_ps((float *) (&f[(2 * i) + koff]), v_t1);\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (2 * nxhd) * (j + k1);\n        j2 = (2 * nxhd) * (j + k2);\n        v_t1 = _mm_loadl_pi(v_t1, (__m64 *) (&sct[kmr * j]));\n        v_t1 = _mm_movelh_ps(v_t1, v_t1);\n        v_t1 = _mm_mul_ps(v_t1, v_n);\n        v_t2 = _mm_load_ps((float *) (&f[(2 * i) + j2]));\n        v_t3 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 160));\n        v_t2 = _mm_shuffle_ps(v_t2, v_t2, 177);\n        v_t2 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 245));\n        v_t2 = _mm_add_ps(v_t3, _mm_mul_ps(v_t2, v_m));\n        v_t3 = _mm_load_ps((float *) (&f[(2 * i) + j1]));\n        v_t4 = _mm_sub_ps(v_t3, v_t2);\n        _mm_store_ps((float *) (&f[(2 * i) + j2]), v_t4);\n        v_t2 = _mm_add_ps(v_t3, v_t2);\n        _mm_store_ps((float *) (&f[(2 * i) + j1]), v_t2);\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,koff,v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/ssempush2/6"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  printf(\"%f \", vector[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yattroman/nsu-opp-mpi-openmp-labs/laboratory-2/version-2/mv/mvOperations_l2_2nd/0"}
{"code": "for (i = 0; i < (query_nb * dim); i++)\n  query[i] = ((float) rand()) / ((float) RAND_MAX);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/4"}
{"code": "for (idx = 0; idx < edge_num; idx++)\n{\n  row = start_edge[idx];\n  col = end_edge[idx];\n  nextrank_value[col] += currentrank_value[row] * transition[idx];\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_count)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhixue/Parrallel-programming-course/hk2_openmp/hw2_3/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  #pragma acc loop independent\n  #pragma acc loop independent\n  for (k = 0; k < N; ++k)\n  {\n    int idx = pa.idx(i, j, k);\n    _pa[idx] = sqrt(_pa[idx]) + ((((double) i) * j) * k);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for default(shared) private(j, k) num_threads(32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cwru-pat/cpp_parallelization/main/1"}
{"code": "for (int i = 0; i < 10000000; i++)\n  z_oracle[i] = x[i] + y[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kishkaru/OpenMP_Demos/OpenMP/vadd_OmpFor/2"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (data->committee >= g->N)\n  {\n    correct = 0;\n    WARN(\"%d apparently belongs to a non-existant committee %d\\n\", i, data->committee);\n    goto end;\n  }\n\n  committee_count[data->committee]++;\n  1(\"%d->committee = %d\\n\", i, data->committee);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/8"}
{"code": "for (int j = 0; j < n; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    float dx = points[i].x - points[j].x;\n    float dy = points[i].y - points[j].y;\n    float dz = points[i].z - points[j].z;\n    float sqr_dist = ((dx * dx) + (dy * dy)) + (dz * dz);\n    (*sqr_distances)[(j * n) + i] = sqr_dist <= sqr_radius;\n  }\n\n  (*sqr_distances)[(j * n) + j] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(points, sqr_distances, n, sqr_radius) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload/euclidean_cluster/kernel/0"}
{"code": "for (i = 0; i < ((ptrdiff_t) count); ++i)\n{\n  owner[i] = VERTEX_OWNER(vertex[i]);\n  local[i] = VERTEX_LOCAL(vertex[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_custom/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    vector__1[i][j] = (rand() % 4) + 1;\n    vector__2[i][j] = (rand() % 4) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EALH/Prog_Paralela/OpenMp/matXmat/0"}
{"code": "for (i = 0; i < init_count; i++)\n{\n  num[i] = i + 2;\n  crossed[i] = 0;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SteveDengZishi/Parallel_MPI_OpenMP_CUDA/lab2/genprime/0"}
{"code": "for (i = 1; i < 10; i++)\n{\n  fprintf(outfile, \"%s \\n\", configdata[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NiramayVaidya/Linux_OpenMP_Benchmark_Results/code_and_results_files/32_bit/memspeed/code/memory_speed/1"}
{"code": "for (i = 0; i < size; i++)\n  free(A[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/17"}
{"code": "for (i = 0; i < threadCount; i++)\n  _patchI[i] = (_patchJ[i] = (_Ix[i] = (_Iy[i] = 0)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/2"}
{"code": "for (i = 0; i < (3 * np); i++)\n{\n  pos[i] = (rand() / ((double) 32767)) * L;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Steven6798/Repulsive-forces-calculation-with-openMP/Code/Repulsive_forces/3"}
{"code": "for (int I = 0; I < NumberOfDevices; ++I)\n  DeviceAllocators.emplace_back(I, DeviceData);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/plugins/cuda/src/rtl/0"}
{"code": "for (i = 0; p[i * 2]; i++)\n  cs.pw[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/o5logon_fmt_plug/2"}
{"code": "for (i = 0; i < 32; i++)\n{\n  a[i] = tid;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwina/five-short-openmp/fill/0"}
{"code": "for (i = 0; i < x; ++i)\n{\n  for (j = 0; j < x; ++j)\n    printf(\"%4d to%4d     %4d\\n\", count + i, count + j, distance[i][j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trdiaz/openmpLab2/test/3"}
{"code": "for (i = 0; i < (512 * 2); i++)\n{\n  if (atoi16l[ARCH_INDEX((ciphertext + pos)[i])] == 0x7F)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/truecrypt_fmt_plug/2"}
{"code": "for (it = 1; it <= 100; it++)\n{\n  eps = 0.0;\n  relax(size, A, thread_num);\n  if (eps < maxeps)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hapiny/mpi-openmp-msu-course/omp/3"}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  dgemm_time = wtime();\n  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, order, order, order, 1.0, &A[0 + (order * 0)], order, &B[0 + (order * 0)], order, 1.0, &C[0 + (order * 0)], order);\n  dgemm_time = wtime() - dgemm_time;\n  if ((iter > 0) || (iterations == 1))\n  {\n    avgtime = avgtime + dgemm_time;\n    mintime = MIN(mintime, dgemm_time);\n    maxtime = MAX(maxtime, dgemm_time);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/DGEMM/dgemm/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  scanf(\"%d\t%d\", &a, &b);\n  ind[a].push_back(b);\n  ind[b].push_back(a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saiharshavellanki/K-BFS/rv/2"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  fprintf(fp, \"Samples[%i] = %.2f + %.2fi\\n\", i, creal(array[i]), cimag(array[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qixuxiang/simple-fft-openmp/fft_omp/4"}
{"code": "for (int i = 0; i < sumLen; i++)\n{\n  if (indexA >= lenA)\n  {\n    totalAr[i] = arrB[indexB];\n    indexB++;\n  }\n  else\n    if (indexB >= lenB)\n  {\n    totalAr[i] = arrA[indexA];\n    indexA++;\n  }\n  else\n  {\n    if (arrA[indexA] <= arrB[indexB])\n    {\n      totalAr[i] = arrA[indexA];\n      indexA++;\n    }\n    else\n    {\n      totalAr[i] = arrB[indexB];\n      indexB++;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/mergeSort/3"}
{"code": "for (i = 2; i <= n; i++)\n{\n  if (prime[i] == 1)\n  {\n    printf(\"%d\\t   from thread =%d of %d\\n \", i, omp_get_thread_num(), omp_get_num_threads());\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/MultiTask/main/0"}
{"code": "for (int iat = 0; iat < AtomicOrbitals.size(); iat++)\n{\n  AtomicOrbitals[iat].set_num_bands(NumValenceOrbs);\n  AtomicOrbitals[iat].allocate();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderReadBands_ESHDF/1"}
{"code": "for (int i = 1; i < 256; i++)\n{\n  histogram_eq[i] = (int) (((((float) cdf[i]) - cdf[0]) / ((((float) width) * height) - 1)) * 255);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlessandroLemmo/Histogram-Equalization-OpenMP/HistogramEqualizationOpenMP/main/2"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  for (k = 0; k < 500; k++)\n  c[(i * 500) + j] = a[(i * 500) + j] * b[(k * 500) + j];\n\n\n\n", "pragma": "omp teams distribute parallel for simd collapse(2) private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/application_kernels/mmm_target_parallel_for_simd/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (colour[i] > max)\n  {\n    max = colour[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YigitAras/OpenMP_Greedy_GraphColouring/colouring_hw2/1"}
{"code": "for (j = 0; j < ARRAY_SIZE; j++)\n{\n  result[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_array_reduction_01/3"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x[i], nbins, xmin, xmax, edges);\n  weight = w[i];\n  values[bin] += weight;\n  variances[bin] += weight * weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/6"}
{"code": "for (int i = 0; i < A.Rows; i++)\n{\n  for (int j = 0; j < B.Cols; j++)\n  {\n    float sum = 0.0f;\n    for (int k = 0; k < A.Cols; k++)\n    {\n      sum += arrayA[i][k] * arrayB[k][j];\n    }\n\n    arrayC[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haniyeka/Parallel-Programming/Assignment3/Prob3/Prob3/Parallel/0"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->baseNumThreads); codeletCounter++)\n{\n  *checkInCodelets903Ptr = _checkInCodelets903(2, 1, this, codeletCounter);\n  (*checkInCodelets903Ptr).decDep();\n  checkInCodelets903Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/17"}
{"code": "for (int k = 1; k <= nk; ++k)\n{\n  for (int j = 1; j <= nj; ++j)\n  {\n    for (int i = 1; i <= ni; ++i)\n    {\n      if (m == mst)\n        Pworkqm[LOC3D(i, j, k)] = 1.0 / (Pvol[LOC3D(i, j, k)] + Pvol[LOC3D(i - il1, j - jl1, k - kl1)]);\n\n      Pdqdx_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n      Pdqdy_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n      Pdqdz_4d[LOC4D(i, j, k, m)] *= Pworkqm[LOC3D(i, j, k)];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/report/FYArray/src/main/1"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < min(10, m_br); j++)\n    (cout << (*phc)[j]) << \" \";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danfergo/cpar/assignment/cpp/matrixprod/3"}
{"code": "for (int i = 0; i < processors.size(); i++)\n{\n  float pf = (float) (((float) processors[i].getSpeed()) / ((float) taskLength));\n  processors[i].setPerformancefactor(pf);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/4"}
{"code": "for (i3 = 1; i3 < e3; i3++)\n{\n  x1 = x0;\n  for (i2 = 1; i2 < e2; i2++)\n  {\n    xx = x1;\n    vranlc(d1, &xx, A, &z[i3][i2][0]);\n    randlc(&x1, a1);\n  }\n\n  randlc(&x0, a2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/20"}
{"code": "for (j = 2; j <= (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/21"}
{"code": "for (result = 0; str[result] != '\\0'; ++result)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DragosUnguru/ParallelFrameworksAnalyze/parallel_encoder/2"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_copyin())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/parallel/omp_parallel_copyin/0"}
{"code": "for (wJ = wI; wJ < (wI + (BIGN / 4)); wJ += 4)\n{\n  wV1 = _mm_load_ps(&aVect1[wJ]);\n  wV2 = _mm_load_ps(&aVect2[wJ]);\n  wRes = _mm_dp_ps(wV1, wV2, 0xFF);\n  wReturned += wRes[0];\n}\n\n", "pragma": "omp parallel for reduction(+:wReturned) firstprivate(wI) private(wJ, wV1, wV2, wRes)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vectb/6"}
{"code": "for (i = 0; i < n; i++)\n  printf(\" a[%3d] = %6d ref[%3d] = %6d\\n\", i, a[i], i, ref[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.47-barrier/2"}
{"code": "for (register int ii = 0; ii <= (len - 1); ii += 1)\n{\n  int count = idxBound[ii + 1] - idxBound[ii];\n  int *list = &idxList[idxBound[ii]];\n  double sum = 0.0;\n  for (register int jj = 0; jj <= (count - 1); jj += 1)\n  {\n    int idx = list[jj];\n    sum += tmp[list[jj]];\n  }\n\n  force[ii] += sum;\n}\n\n", "pragma": "omp parallel for private (jj) firstprivate (len)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_accumulateForce/0"}
{"code": "for (m = i; m < (j + 1); m++)\n{\n  if (isPrime(m))\n    printf(\" %d \", m);\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task15/0"}
{"code": "for (i = 0; i < (1024 * 1024); i++)\n  d[i] = a[i] + b[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr82374/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  vecsInCenter = 0;\n  memset(newCenterValues, 0, sizeof(newCenterValues));\n  for (int j = 0; j < 100000; j++)\n    if (classes[j] == i)\n  {\n    vecsInCenter++;\n    for (int k = 0; k < 1000; k++)\n      newCenterValues[k] += vectors[j][k];\n\n  }\n\n\n  for (int k = 0; k < 1000; k++)\n    centers[i][k] = newCenterValues[k] / vecsInCenter;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Spiros-Dimitriou/k-means/kmeans/2"}
{"code": "for (i = 0; i < max_num_threads; i++)\n{\n  arr[i] = (long *) malloc(256 * (sizeof(long)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JingruGao09/OpenMP_Performance/histogram_creative/histo_creative/0"}
{"code": "for (i = 0; i < ARR_SIZE; ++i)\n{\n  a[i] = 1;\n}\n\n", "pragma": "\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lumeng16/OpenMPstudy/Basic/task/0"}
{"code": "for (int i = 5; ((2 * i) + 17) > i; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/46"}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = KISS;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/4"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  total = total + (((float) i) * 1);\n}\n\n", "pragma": "omp for schedule(dynamic, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task9/bugged2/0"}
{"code": "for (size_t t = 1; t <= tmax; ++t)\n{\n  double radius;\n  double alpha;\n  const double ratio = ((double) t) / tmax;\n  switch (rcool)\n  {\n    case EXPONENTIAL:\n      radius = radius0 * pow(radiusN / radius0, ratio);\n      break;\n\n    case LINEAR:\n\n    default:\n      radius = radiusN + ((radius0 - radiusN) * (1. - ratio));\n      break;\n\n  }\n\n  switch (acool)\n  {\n    case EXPONENTIAL:\n      alpha = alpha0 * pow(alphaN / alpha0, ratio);\n      break;\n\n    case LINEAR:\n\n    default:\n      alpha = alphaN + ((alpha0 - alphaN) * (1. - ratio));\n      break;\n\n  }\n\n  const size_t k = uidist(rng);\n  double dStar;\n  const size_t kStar = getBmu(data, k, dStar);\n  update(data, k, kStar, radius, alpha, stdCoeff);\n  if (m_verbose > 1)\n  {\n    dStar += data._sqsum[k];\n    Qe += sqrt(max(0., dStar));\n    if ((t % percent) == 0)\n    {\n      (((((((((((((cout << \"  \") << (t / percent)) << \"% (\") << t) << \" / \") << tmax) << \")\") << \" - r = \") << radius) << \", a = \") << alpha) << \" - approx. QE \") << (Qe / percent)) << endl;\n      Qe = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/som/5"}
{"code": "for (int j = 0; j < NUMHID; j++)\n  for (int i = 0; i < NUMIN; i++)\n  WeightIH[j][i] += DeltaWeightIH[j][i];\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oriolmartinezac/cap-openmp/nn-vo-db/6"}
{"code": "for (j = i + 1; j <= n; j++)\n{\n  if (L[i] > L[j])\n  {\n    win[i] = win[i] + 1;\n  }\n  else\n  {\n    win[j] = win[j] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoCRCW/2"}
{"code": "for (i = 0; i < 11; i++)\n{\n  printf(\"%g\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nadezhdagub/OpenMP-MPI/lab7_1/1"}
{"code": "for (int i = 0; i < 50; i++)\n  for (int j = 0; j < 50; j++)\n{\n  a[i][j] = i * j;\n  b[i][j] = i * j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kielfriedt/Multithreading/Pthreads/Pthread_MatrixMult/3"}
{"code": "for (; (i + 15) < n; i += 16)\n{\n  xv[0] = _mm256_load_pd(&x[i + 0]);\n  xv[1] = _mm256_load_pd(&x[i + 4]);\n  xv[2] = _mm256_load_pd(&x[i + 8]);\n  xv[3] = _mm256_load_pd(&x[i + 12]);\n  _mm256_store_pd(&y[i + 0], xv[0]);\n  _mm256_store_pd(&y[i + 4], xv[1]);\n  _mm256_store_pd(&y[i + 8], xv[2]);\n  _mm256_store_pd(&y[i + 12], xv[3]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/27"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = drandom();\n  y = drandom();\n  if (((x * x) + (y * y)) <= 1)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/value-of-pi/value-of-pie-thread-safe/0"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      t1 = bt * r1;\n      t2 = 0.5 * (r4 + r5);\n      rhs[k][j][i][0] = bt * (r4 - r5);\n      rhs[k][j][i][1] = -r3;\n      rhs[k][j][i][2] = r2;\n      rhs[k][j][i][3] = (-t1) + t2;\n      rhs[k][j][i][4] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/19"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    matriz[i][j] = i * j;\n    printf(\"/matriz[%d][%d] con valor[%d] ejecutado por la hebra: %d\\n\", i, j, matriz[i][j], omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio9/0"}
{"code": "for (k = lt; k >= (lb + 1); k--)\n{\n  j = k - 1;\n  rprj3(&r[ir[k]], m1[k], m2[k], m3[k], &r[ir[j]], m1[j], m2[j], m3[j], k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/7"}
{"code": "for (int i = 0; i < MAX_FREE_TASK_GROUPS; ++i)\n{\n  if (freeTaskGroups[i] == NULL)\n  {\n    void *ptr = lAtomicCompareAndSwapPointer((void **) (&freeTaskGroups[i]), tg, NULL);\n    if (ptr == NULL)\n      return;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/7"}
{"code": "for (i = 0; i < Nc; i++)\n{\n  xc[i][0] = xc0[i];\n  yc[i][0] = yc0[i];\n  for (j = 0; j < Np; j++)\n  {\n    r[i][j][0] = (double) R;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/2"}
{"code": "for (int triangleIdx = 0; triangleIdx < numTriangles; triangleIdx++)\n{\n  int32_t p1;\n  int32_t p2;\n  int32_t p3;\n  bin.read((char *) (&p1), sizeof(int32_t));\n  bin.read((char *) (&p2), sizeof(int32_t));\n  bin.read((char *) (&p3), sizeof(int32_t));\n  triangles.emplace_back(p1, p2, p3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/antonvoznia/ctu-pag-triangulation/src/Triangulation/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (((b[i] != 0) && ((abs(tempb[i] - b[i]) / b[i]) > 1e-6)) || ((tempb[i] != 0) && ((abs(tempb[i] - b[i]) / tempb[i]) > 1e-6)))\n  {\n    printf(\"error:\\n%.20f: %.20f\\n\", b[i], tempb[i]);\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaempunk/linear-equations-solution-openmp/linear_equations/0"}
{"code": "for (z = 0; z < threads_num; z++)\n{\n  sizeCentroid = 0;\n  int t = 0;\n  for (l = 0; l < numOfPoints; l++)\n  {\n    nearestx[z][l] = 0;\n    nearesty[z][l] = 0;\n    if (((int) assign[t]) == z)\n    {\n      nearestx[z][sizeCentroid] = myPoints[l][0];\n      nearesty[z][sizeCentroid] = myPoints[l][1];\n      sizeCentroid++;\n    }\n\n    t++;\n  }\n\n  all_centroid_size[z] = sizeCentroid;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oshaesam1/K-means-Clustering-using-openMp-FCAI-/main/5"}
{"code": "for (i = 0; i < numObjs; i++)\n  membership[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/5"}
{"code": "for (int i = 0; i < numChunks; i++)\n{\n  for (k = 0; k < chunk; k++)\n  {\n    x = ((double) rand()) / ((double) RAND_MAX);\n    y = ((double) rand()) / ((double) RAND_MAX);\n    x = x * r;\n    y = y * r;\n    if (((x * x) + (y * y)) < (r * r))\n    {\n      c++;\n    }\n\n  }\n\n}\n\n", "pragma": "          #pragma omp parallel for shared(numChunks, chunk, l) reduction(+:c) private(k, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laurasgm/HPC-Needles-Dartboard-openMP/dartboard-openMP/0"}
{"code": "for (j = 0; j < M; j++)\n{\n  cont++;\n}\n\n", "pragma": "omp parallel for num_threads(T) private(i,j,cont)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/paralelo7/0"}
{"code": "for (int i = 0; i < 992; i++)\n{\n  if (A[i] != (1 * 2))\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, ((double) 1) * 2, A[i]);\n    fail = 1;\n  }\n\n  if (B[i] != (1 * 3))\n  {\n    printf(\"Error at B[%d], h = %lf, d = %lf\\n\", i, ((double) 1) * 3, B[i]);\n    fail = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/3"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  globalized[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_shared_array/reduction_shared_array/0"}
{"code": "for (i = 0; i < 1000; i++)\n  if (tids[i] != tids2[i])\n{\n  fprintf(stderr, \"Chunk no. %d was assigned once to thread %d and later to thread %d.\\n\", i, tids[i], tids2[i]);\n  result = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static_3/2"}
{"code": "for (countSameStreetCar = 0; countSameStreetCar < countStreet[car_state[c].street]; countSameStreetCar++)\n{\n  int i = factorSlot[car_state[c].street][countSameStreetCar];\n  if (i == c)\n    continue;\n\n  if ((car_state[c].street == car_state[i].street) && (car_state[c].position < car_state[i].position))\n  {\n    car_state[i].position--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chalearm/OpenMPApp/TrafficSignaling/solution_check/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i].x = (rand() / ((float) 32767)) - 0.5;\n  p[i].y = (rand() / ((float) 32767)) - 0.5;\n  p[i].z = (rand() / ((float) 32767)) - 0.5;\n  v[i].x = (rand() / ((float) 32767)) - 0.5;\n  v[i].y = (rand() / ((float) 32767)) - 0.5;\n  v[i].z = (rand() / ((float) 32767)) - 0.5;\n  m[i] = ((rand() / ((float) 32767)) * 10) + 0.01;\n  f[i].x = (f[i].y = (f[i].z = 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NievinEvgeny/N-body/parallel-v1/main/1"}
{"code": "for (int i = 0; i < m->row; i++)\n{\n  for (int j = 0; j < m->col; j++)\n  {\n    printf(\"matr[%d][%d] = %lf\\n\", i, j, m->tab[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/1"}
{"code": "for (i = 0; i < 20; i += 1)\n{\n  for (j = 0; j < 20; j += 1)\n  {\n    printf(\"%lf\\n\", a[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB053-inneronly1-orig-no/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (k = 0, j = ptr[i]; j < ptr[i + 1]; j++)\n  {\n    if ((j > ptr[i]) && (ind[j] < ind[j - 1]))\n    {\n      k = 1;\n    }\n\n    cand[j - ptr[i]].val = j - ptr[i];\n    cand[j - ptr[i]].key = ind[j];\n    tval[j - ptr[i]] = val[j];\n  }\n\n  if (k)\n  {\n    gk_ikvsorti(ptr[i + 1] - ptr[i], cand);\n    for (j = ptr[i]; j < ptr[i + 1]; j++)\n    {\n      ind[j] = cand[j - ptr[i]].key;\n      val[j] = tval[cand[j - ptr[i]].val];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/2"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  printf(\"%d %d %d\\n\", centroid_p[i].x[0], centroid_p[i].x[1], centroid_p[i].x[2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MahmoudAshraf97/OpenMP-KMeans-Clustering/Q1/13"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c3 = 16 * c2; c3 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c3++)\n  {\n    for (c4 = 16 * c1; c4 <= ((((16 * c1) + 15) < (n + (-1))) ? ((16 * c1) + 15) : (n + (-1))); c4++)\n    {\n      A[c4][c3] = ((((double) c4) * (c3 + 2)) + 2) / n;\n      B[c4][c3] = ((((double) c4) * (c3 + 3)) + 3) / n;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2 ,c3 ,c4 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB056-jacobi2d-tile-no/1"}
{"code": "for (i_imopVarPre79 = ist; i_imopVarPre79 <= iend; i_imopVarPre79++)\n{\n  for (j_imopVarPre80 = jst; j_imopVarPre80 <= jend; j_imopVarPre80++)\n  {\n    for (k_imopVarPre81 = 0; k_imopVarPre81 <= (nz - 1); k_imopVarPre81++)\n    {\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3];\n      u41 = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      q = (0.50 * (((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1]) + (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2])) + (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3]))) / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] * u41;\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] * u41;\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] * u41) + (0.40e+00 * (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] - q));\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = ((1.40e+00 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4]) - (0.40e+00 * q)) * u41;\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 2); k_imopVarPre81++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (tz2 * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][m_imopVarPre82] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][m_imopVarPre82]));\n      }\n\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 1); k_imopVarPre81++)\n    {\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      u21k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1];\n      u31k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2];\n      u41k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3];\n      u51k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4];\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][0];\n      u21km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][1];\n      u31km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][2];\n      u41km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][3];\n      u51km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][4];\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = tz3 * (u21k - u21km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = tz3 * (u31k - u31km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((1.40e+00 * 1.40e+00) * tz3) * (u51k - u51km1));\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 2); k_imopVarPre81++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] + ((dz1 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][0] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][0]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][1] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1]))) + ((dz2 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][1] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][1]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][2] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2]))) + ((dz3 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][2] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][2]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][3] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3]))) + ((dz4 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][3] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][3]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][4] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4]))) + ((dz5 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][4] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][4]));\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82] - (dssp * ((((+5.0) * u[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82]) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][3][m_imopVarPre82]));\n      rsd[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82] - (dssp * (((((-4.0) * u[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82]) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][3][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][4][m_imopVarPre82]));\n    }\n\n    for (k_imopVarPre81 = 3; k_imopVarPre81 <= (nz - 4); k_imopVarPre81++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (dssp * ((((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 2][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 2][m_imopVarPre82]));\n      }\n\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82] - (dssp * (((u[i_imopVarPre79][j_imopVarPre80][nz - 5][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 4][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82])));\n      rsd[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82] - (dssp * ((u[i_imopVarPre79][j_imopVarPre80][nz - 4][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82])) + (5.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/19"}
{"code": "for (i = 0; i < N; i++)\n{\n  x_arr[i] = rand() % 100000;\n  y_arr[i] = rand() % 100000;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AllynVo/Simple-Parallel-Computing-with-OpenMP/Source Code Allyn_openmp/Allyn_final_project/Allyn_final_project/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    int tmp1[150];\n    int tmp2[150];\n    int tmp3[150];\n    int index = j + (i * cols);\n    int x1 = i - n;\n    int y1 = j - n;\n    int x2 = i + n;\n    int y2 = j + n;\n    int ni;\n    int nj;\n    int k = 0;\n    for (ni = x1; ni <= x2; ni++)\n    {\n      for (nj = y1; nj <= y2; nj++)\n      {\n        int ii;\n        int jj;\n        ii = ni;\n        jj = nj;\n        if (ii < 0)\n          ii = 0;\n\n        if (jj < 0)\n          jj = 0;\n\n        if (ii >= rows)\n          ii = rows - 1;\n\n        if (jj >= cols)\n          jj = cols - 1;\n\n        int in = (ii * cols) + jj;\n        PPMPixel *t = im->data + in;\n        tmp1[k] = t->red;\n        tmp2[k] = t->green;\n        tmp3[k++] = t->blue;\n      }\n\n    }\n\n    qsort(tmp1, k, sizeof(int), cmpfunc);\n    int med1 = tmp1[k / 2];\n    qsort(tmp3, k, sizeof(int), cmpfunc);\n    int med3 = tmp3[k / 2];\n    qsort(tmp2, k, sizeof(int), cmpfunc);\n    int med2 = tmp2[k / 2];\n    PPMPixel *c = im2->data + index;\n    c->red = med1;\n    c->green = med2;\n    c->blue = med3;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/parallel_median/0"}
{"code": "for (int64_t i = a + 1; i <= pi_x13; i++)\n{\n  int64_t xi = x / primes[i];\n  int64_t bi = pi[isqrt(xi)];\n  for (int64_t j = i; j <= bi; j++)\n    sum += pi[xi / primes[j]] - (j - 1);\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic) num_threads(threads) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primecount/src/P3/0"}
{"code": "for (c2 = 0; c2 <= 127; c2++)\n{\n  for (c5 = 0; c5 <= 127; c5++)\n  {\n    E[c1][c2] += A[c1][c5] * B[c5][c2];\n  }\n\n  for (c5 = 0; c5 <= 127; c5++)\n  {\n    G[c1][c5] += E[c1][c2] * F[c2][c5];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c5, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/38"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  finalRecvBuf[i] = pingRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(finalRecvBuf,dataSize,sizeofBuffer,pingRecvBuf) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_multiPingping/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  clGetProgramBuildInfo(program, device_id[i], CL_PROGRAM_BUILD_LOG, 0, 0, &log_size);\n  log = (char *) malloc(log_size);\n  clGetProgramBuildInfo(program, device_id[i], CL_PROGRAM_BUILD_LOG, log_size, log, 0);\n  printf(\">>> Build log for device %d:\\n\", i);\n  printf(\"%s\\n\", log);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/3"}
{"code": "for (int j = 0; j < omp_p; j++)\n{\n  unsigned int seed = (j * p) + myrank;\n  size_t start = (j * N) / omp_p;\n  size_t end = ((j + 1) * N) / omp_p;\n  for (unsigned int i = start; i < end; i++)\n  {\n    in[i] = mn + (((sqrt(((-2) * log((rand_r(&seed) * 1.0) / RAND_MAX)) / log_e) * cos(((rand_r(&seed) * 2) * M_PI) / RAND_MAX)) * RAND_MAX) * 0.1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hsundar/usort/src/main/2"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  fscanf(fptr, \"%d\", &jump[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/11"}
{"code": "for (int i = 0; i < (window_size - 1); i++)\n{\n  for (int j = 0; j < ((window_size - i) - 1); j++)\n  {\n    if (array[j] > array[j + 1])\n    {\n      float temp = array[j];\n      array[j] = array[j + 1];\n      array[j + 1] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OluwaseunOjeleye/OpenMP-based-Image-Processing-/image_processing/IP/16"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  for (subcycle = 0; subcycle < 10; subcycle++)\n  {\n    partArray[0]->update_count = 1;\n    partArray[0]->firstZone->value = calc_deposit();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp/15"}
{"code": "for (int col_num = 0; col_num < nx; col_num++)\n{\n  *((*h) + col_num) = HI_TEMP;\n  *((*g) + col_num) = HI_TEMP;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joshuaburkhart/laplace/laplace/2"}
{"code": "for (f = 0; f < N; f++)\n  for (c = f; c < N; c++)\n  v2[f] += M[f][c] * v1[c];\n\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica3/src/pmtv-OpenMP/2"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  buffer = (unsigned int *) calloc(nz_per_col, sizeof(unsigned int));\n  if (buffer == 0)\n    exit(-1);\n\n  for (int j = 0; j < nz_per_col; j++)\n  {\n    do\n    {\n      buffer[j] = (unsigned int) (rand() % 1000000);\n    }\n    while (hasDuplicate(buffer, nz_per_col, j));\n  }\n\n  bubblesort(buffer);\n  for (int j = 0; j < nz_per_col; j++)\n  {\n    row[(i * nz_per_col) + j] = buffer[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/13"}
{"code": "for (int j = i; j < ub; j++)\n  ;\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/libomptarget/deviceRTLs/nvptx/test/parallel/level/0"}
{"code": "for (j = 0; j < ((theta_max_index + 1) - theta_min_index); j++)\n{\n  for (k = 0; k < ((r_max_index + 1) - r_min_index); k++)\n  {\n    i = r_min_index + k;\n    if (ph_inj_switch == 0)\n    {\n      if (((ph_rmin - ((elem_factor * C_LIGHT) / fps)) < (*(r_unprc + i))) && ((*(r_unprc + i)) < (ph_rmax + ((elem_factor * C_LIGHT) / fps))))\n      {\n        elem++;\n      }\n\n    }\n    else\n    {\n      if (((r_inj - (C_LIGHT / fps)) < (*(r_unprc + i))) && ((*(r_unprc + i)) < (r_inj + (C_LIGHT / fps))))\n      {\n        elem++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/18"}
{"code": "for (int y = 0; y < ystrips; y++)\n{\n  int ye = y * yerrperstrip;\n  for (int x = 0; x < xstrips; x++)\n  {\n    int xe = x * xerrperstrip;\n    int i = ((((y * STEP) + yoff) + ye) * m_width) + (((x * STEP) + xoff) + xe);\n    kseedsl[n] = m_lvec[i];\n    kseedsa[n] = m_avec[i];\n    kseedsb[n] = m_bvec[i];\n    kseedsx[n] = ((x * STEP) + xoff) + xe;\n    kseedsy[n] = ((y * STEP) + yoff) + ye;\n    n++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/5"}
{"code": "for (x = 1; x <= nrl; x++)\n  for (y = 1; y <= NC; y++)\n  for (z = 0; z <= EXTRA; z++)\n{\n  t[1][x][y] += z;\n  t[1][x][y] -= z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/11"}
{"code": "for (unsigned short l_di = 0; l_di < 3; l_di++)\n{\n  l_exprTk.addVar(l_crdsName[l_di], l_crds[l_di]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/mesh/Refinement/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,j1 ,j ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/180"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < (width * 3); j += 3, pos++)\n  {\n    imgdata[(i * rgb_width) + j] = red[pos];\n    imgdata[((i * rgb_width) + j) + 1] = green[pos];\n    imgdata[((i * rgb_width) + j) + 2] = blue[pos];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manogna-mujje/Image-Processing/OpenMP/max_paralleize_openmp/4"}
{"code": "for (i = 0; i < len; i++)\n{\n  if ((i % 2) == 0)\n    x[i] = 5;\n  else\n    x[i] = -5;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/minusminus-orig-yes/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  x = ((double) i) / ((double) (nx - 1));\n  for (j = 0; j < ny; j++)\n  {\n    y = ((double) j) / ((double) (ny - 1));\n    if ((((i == 0) || (i == (nx - 1))) || (j == 0)) || (j == (ny - 1)))\n    {\n      f[(i * npadded) + j] = u_exact(x, y);\n    }\n    else\n    {\n      f[(i * npadded) + j] = -uxxyy_exact(x, y);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/POISSON/poisson_openmp/10"}
{"code": "for (int i = 0; i <= n; i++)\n  scanf(\"%lld\", &sizes[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/MatrixChainMultiplication/main/1"}
{"code": "for (int j = (0 > (y - 1)) ? (0) : (y - 1); j <= (((1080 - 1) < (y + 1)) ? (1080 - 1) : (y + 1)); j++)\n{\n  for (int i = (0 > (x - 1)) ? (0) : (x - 1); i <= (((1920 - 1) < (x + 1)) ? (1920 - 1) : (x + 1)); i++)\n  {\n    int rr = image[(3 * (i + (j * 1920))) + 0];\n    int gg = image[(3 * (i + (j * 1920))) + 1];\n    int bb = image[(3 * (i + (j * 1920))) + 2];\n    if (!same_color(*r, *g, *b, rr, gg, bb))\n    {\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/misc/mandelbrot/4"}
{"code": "for (i = sizeOfArray - 2; i >= 0; i--)\n{\n  backwardsSum = 0;\n  for (j = i; j <= (sizeOfArray - 1); j++)\n  {\n    backwardsSum = backwardsSum + (augmentedMatrix[i][j] * values[j]);\n  }\n\n  values[i] = (augmentedMatrix[i][sizeOfArray] - backwardsSum) / augmentedMatrix[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adamneal/openMP/Source/2"}
{"code": "for (i = 0; i < K; i++)\n{\n  mean[i]._r = newMean[i]._r;\n  mean[i]._g = newMean[i]._g;\n  mean[i]._b = newMean[i]._b;\n  mean[i]._m = newMean[i]._m;\n  mean[i]._n = newMean[i]._n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Projects/PC-Project/parallel code/kmean_omp/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  omp_set_lock(&lock);\n  sum += max_;\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/6/6/Source/1"}
{"code": "for (index = 0; index < self->params.max_keys_per_crypt; ++index)\n{\n  ((unsigned int *) sse_hash1)[((15 * SIMD_COEF_32) + (index & (SIMD_COEF_32 - 1))) + (((((unsigned int) index) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32)] = 84 << 3;\n  sse_hash1[GETPOS(20, index)] = 0x80;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash2_fmt_plug/8"}
{"code": "for (i = 0; i < Size; i++)\n{\n  if (pRes[i] != pSerialResult[i])\n  {\n    equal = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Matrix Multiplication/Parallel/main/4"}
{"code": "for (int i = 1; i < qValues->columnas(); i++)\n{\n  temporal = qValues->num(estado, i);\n  if (temporal > valor)\n  {\n    valor = temporal;\n    accion = i;\n  }\n  else\n    if (temporal == valor)\n  {\n    cantI++;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kunkkaharden/Proyecto-de-tesis/source/modelo/agente/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < len; j++)\n    u[i][j] = 0.5;\n\n}\n\n", "pragma": "omp parallel for private(i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB021-reductionmissing-orig-yes/0"}
{"code": "for (j = 0; j < N; j++)\n{\n  if (i == j)\n    continue;\n\n  if (adj[i][j] <= first)\n  {\n    second = first;\n    first = adj[i][j];\n  }\n  else\n    if ((adj[i][j] <= second) && (adj[i][j] != first))\n    second = adj[i][j];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhishekgupta-1/Parallel-Computing-Assignment/submission/tsp_openmp/tsp_openmp/4"}
{"code": "for (int i = 0; i < parents.size(); ++i)\n{\n  int index1 = rand() % parents.size();\n  int index2 = rand() % parents.size();\n  swap(parents[index1], parents[index2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/5"}
{"code": "for (int i = 0; i < Dim; i++)\n{\n  Result(i, i) = Diag[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/107"}
{"code": "for (int i = 0; i < 128; i++)\n{\n  for (int j = 0; j < 128; j++)\n  {\n    m[i][j] = ((i * 128) + j) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/omp_MMMUL/1"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlusInverse->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/30"}
{"code": "for (int i = 0; i < 16; i++)\n  for (int j = 0; j < 16; j = j + i)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/66"}
{"code": "for (i = k + 1; i <= m; i++)\n{\n  currVal = (A[((i - 1) * Alda) + (k - 1)] > 0.0) ? (A[((i - 1) * Alda) + (k - 1)]) : (-A[((i - 1) * Alda) + (k - 1)]);\n  if (piv_local < currVal)\n  {\n    piv_local = currVal;\n    iPiv_local = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivC_OpenMP/0"}
{"code": "for (i = 0; i < (2 * N); i += 4)\n{\n  incx = i * incX;\n  incy = i * incY;\n  x = _mm_load_ps(a + incx);\n  y = _mm_load_ps(b + incy);\n  _mm_store_ps(b + incy, x);\n  _mm_store_ps(a + incx, y);\n}\n\n", "pragma": "omp for schedule(static) private(incx, incy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/swap/3"}
{"code": "for (dest = 1; dest < nprocs; dest++)\n{\n  next_year = dest - 1;\n  MPI_Send(&years_bag[next_year], 1, (MPI_Datatype) 0x4c000405, dest, 1, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/1"}
{"code": "for (i = 0; i < gathered_number_count; i++)\n{\n  comm_rank_numbers[i].comm_rank = i;\n  memcpy(&comm_rank_numbers[i].number, gathered_numbers + (i * datatype_size), datatype_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/madisonjordan/KNN_Parallelized/main/3"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  czekaj(1);\n  for (int j = 0; j < SIZE; j++)\n  {\n    for (int k = 0; k < SIZE; k++)\n    {\n      AB_1[i][j] += A[i][k] * B[k][j];\n      CD_1[i][j] += C[i][k] * D[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WikGru/ParallelOpenMP/zad1+/zad1+/4"}
{"code": "for (int i = 0; i < data.width(); i++)\n{\n  for (int j = 0; j < data.height(); j++)\n  {\n    double tmpR = 0;\n    double tmpG = 0;\n    double tmpB = 0;\n    for (int m = 0; m < kernel.height; m++)\n    {\n      int ii = j + (m - kCenter1);\n      if (ii < 0)\n        ii = 0;\n      else\n        if (ii >= data.height())\n        ii = data.height() - 1;\n\n\n      tmpR += tempResult[i + (data.width() * (ii + (data.height() * 0)))] * kernel2[m];\n      tmpG += tempResult[i + (data.width() * (ii + (data.height() * 1)))] * kernel2[m];\n      tmpB += tempResult[i + (data.width() * (ii + (data.height() * 2)))] * kernel2[m];\n    }\n\n    if (tmpR > 255)\n      tmpR = 255;\n    else\n      if (tmpR < 0)\n      tmpR = 0;\n\n\n    if (tmpG > 255)\n      tmpG = 255;\n    else\n      if (tmpG < 0)\n      tmpG = 0;\n\n\n    if (tmpB > 255)\n      tmpB = 255;\n    else\n      if (tmpB < 0)\n      tmpB = 0;\n\n\n    v(i, j)[0] = tmpR;\n    v(i, j)[1] = tmpG;\n    v(i, j)[2] = tmpB;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for collapse(2) schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/6"}
{"code": "for (uint k = 0; k < num_stations; k++)\n{\n  num_jobs[k] = thr * response[k];\n  response[k] = demand[k] * (1 + num_jobs[k]);\n  tot_resp += response[k];\n}\n\n", "pragma": "            #pragma omp for reduction(+:tot_resp) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cattaneo-riccardo/ExactMVA_OpenMP/mva/1"}
{"code": "for (y = 0; y < OMP_yMax; y += 8)\n{\n  int ind = OMP_Index(0, y, z);\n  u[ind] *= boundryScale;\n  u[ind + OMP_xMax] *= boundryScale;\n  u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  for (x = 1; x < OMP_xMax; x++)\n  {\n    int xyzInd = OMP_Index(x, y, z);\n    u[xyzInd] += u[xyzInd - 1] * nu;\n    u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n    u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n  }\n\n  u[ind] *= boundryScale;\n  u[ind + OMP_xMax] *= boundryScale;\n  u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  for (x = OMP_xMax - 2; x >= 0; x--)\n  {\n    int xyzInd = OMP_Index(x, y, z);\n    u[xyzInd] += u[xyzInd + 1] * nu;\n    u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n    u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n  }\n\n}\n\n", "pragma": "omp parallel for private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/vompDeblur/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  c[i] = a[i] * b[i];\n}\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/samples/vmul/vmul/0"}
{"code": "for (i = 0; i < 1; i++)\n{\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, cur_salt->salt, cur_salt->saltSize);\n  SHA1_Update(&ctx, saved_key[idx + i], saved_len[idx + i]);\n  SHA1_Final(hashBuf, &ctx);\n  for (j = 4; j < 24; j++)\n    keys[GETPOS_1(j, i)] = hashBuf[j - 4];\n\n  keys[GETPOS_1(j, i)] = 0x80;\n  keys[GETPOS_1(63, i)] = 192;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/8"}
{"code": "for (int i = 0; i < size_; ++i)\n{\n  (*this)[i] += obj[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/1"}
{"code": "for (source = 1; source < grid->p; source++)\n{\n  MPI_Recv(temp_mat, 1, local_matrix_mpi_t, source, 0, grid->comm, &status);\n  MPI_Cart_coords(grid->comm, source, 2, coords);\n  fprintf(fp, \"Process %d > grid_row = %d, grid_col = %d\\n\", source, coords[0], coords[1]);\n  for (i = 0; i < temp_mat->n_bar; i++)\n  {\n    for (j = 0; j < temp_mat->n_bar; j++)\n      fprintf(fp, \"%20.15E \", *((temp_mat->entries + (temp_mat->n_bar * j)) + i));\n\n    fprintf(fp, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/24"}
{"code": "for (int row = 0; row < N; row++)\n{\n  for (int col = 0; col < N; col++)\n  {\n    A[col + (row * N)] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/goceee/jacobi-openmp/Parallellised/jacobi/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    lwr[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clamslam12/LUdecomposition/ludecomp/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    res[(j * n) + i] = vec[(i * n) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(res, vec, n) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_block_transpose/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  for (j = 0; j < npp; j++)\n  {\n    m = kp[j + (nppmx * k)];\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[j + (nppmx * (i + (idimp * k)))] = part[i + (idimp * m)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,npp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/0"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  float *bloc = (float *) malloc((sizeof(float)) * k);\n  for (size_t j = 0; j < k; j++)\n    *(bloc + j) = db[i][j];\n\n  *(sorted_db + i) = bloc;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/12"}
{"code": "for (j = 0; j < d_imopVarPre103[1]; j++)\n{\n  for (ii = 0; ii <= (d_imopVarPre103[0] - fftblock); ii += fftblock)\n  {\n    for (k = 0; k < d_imopVarPre103[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        y0[k][i].real = x_imopVarPre104[k][j][i + ii].real;\n        y0[k][i].imag = x_imopVarPre104[k][j][i + ii].imag;\n      }\n\n    }\n\n    int _imopVarPre261;\n    int _imopVarPre262;\n    _imopVarPre261 = d_imopVarPre103[2];\n    _imopVarPre262 = logd_imopVarPre106[2];\n    cfftz(is_imopVarPre102, _imopVarPre262, _imopVarPre261, y0, y1);\n    for (k = 0; k < d_imopVarPre103[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        xout_imopVarPre105[k][j][i + ii].real = y0[k][i].real;\n        xout_imopVarPre105[k][j][i + ii].imag = y0[k][i].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  k[i] = v[i] + w[i];\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggrbill/omp-tutorial/src/omp_flush/0"}
{"code": "for (int j = 0; j < 4; ++j)\n{\n  b[j] = b[j] + a[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-06-OmpParallelNestedForLoops/1"}
{"code": "for (c2 = 0; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/78"}
{"code": "for (i = 1; i <= file_num; i++)\n{\n  if (file_num == 1)\n    sprintf(file_name, \"%s%s%04d%s%04d\", INPUT_FOLDER, \"/vel\", SNAPSHOT, \".\", CUR_STEP);\n  else\n    sprintf(file_name, \"%s%s%04d%s%04d%s%02d\", INPUT_FOLDER, \"/vel\", SNAPSHOT, \".\", CUR_STEP, \".\", i);\n\n  fp = fopen(file_name, \"rb\");\n  printf(\"Open %s\\n\", file_name);\n  fseek(fp, 0, 2);\n  file_len = ftell(fp);\n  readby = 0L;\n  if (i == 1)\n  {\n    header_size = ((2 * (sizeof(long int))) + (6 * (sizeof(float)))) + (2 * (sizeof(int)));\n    fseek(fp, header_size, 0);\n    file_len -= header_size;\n  }\n  else\n    rewind(fp);\n\n  while (readby < file_len)\n  {\n    fread(&block_size_1, sizeof(block_size_1), 1, fp);\n    fread(&reader_vel[readby_total], sizeof(char), abs(block_size_1), fp);\n    fread(&block_size_2, sizeof(block_size_2), 1, fp);\n    if (abs(block_size_2) != abs(block_size_1))\n    {\n      printf(\"Inconsistency found in %s\\n\", file_name);\n      warn_and_end(\"End\");\n    }\n\n    readby += abs(block_size_1) + (2 * (sizeof(block_size_1)));\n    readby_total += abs(block_size_1);\n  }\n\n  fclose(fp);\n  printf(\"Finish reading.\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/load_jing/3"}
{"code": "for (i = 0; i < (len - 1); i++)\n  a[i] = a[i + 1] + 1;\n\n", "pragma": "omp target parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/targetparallelforsimd/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    double *_imopVarPre344;\n    double *_imopVarPre345;\n    double (*_imopVarPre346)[5];\n    _imopVarPre344 = rhs[i][j][k];\n    _imopVarPre345 = rhs[i - 1][j][k];\n    _imopVarPre346 = lhs[i][j][k][0];\n    matvec_sub(_imopVarPre346, _imopVarPre345, _imopVarPre344);\n    double (*_imopVarPre350)[5];\n    double (*_imopVarPre351)[5];\n    double (*_imopVarPre352)[5];\n    _imopVarPre350 = lhs[i][j][k][1];\n    _imopVarPre351 = lhs[i - 1][j][k][2];\n    _imopVarPre352 = lhs[i][j][k][0];\n    matmul_sub(_imopVarPre352, _imopVarPre351, _imopVarPre350);\n    double *_imopVarPre356;\n    double (*_imopVarPre357)[5];\n    double (*_imopVarPre358)[5];\n    _imopVarPre356 = rhs[i][j][k];\n    _imopVarPre357 = lhs[i][j][k][2];\n    _imopVarPre358 = lhs[i][j][k][1];\n    binvcrhs(_imopVarPre358, _imopVarPre357, _imopVarPre356);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/78"}
{"code": "for (int i = 0; i < (W + 1); i++)\n{\n  data[i] = 0;\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bruno-26/Parallel-knapsack-C-OpenMP-MPI/knapSack/1"}
{"code": "for (i = 0; i < matrix.count; i++)\n{\n  matrix.elements[i].value.f = ((double) matrix.elements[i].value.i) * scalar;\n}\n\n", "pragma": "omp parallel for shared(matrix,scalar) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/0"}
{"code": "for (int iv = 0; iv < NUMNODES; iv++)\n{\n  for (int iu = 0; iu < NUMNODES; iu++)\n  {\n    float z = Height(iu, iv);\n    if (((((iv == 0) && (iu == 0)) || ((iv == 0) && (iu == (NUMNODES - 1)))) || ((iv == (NUMNODES - 1)) && (iu == (NUMNODES - 1)))) || ((iv == (NUMNODES - 1)) && (iu == 0)))\n    {\n      volume = volume + ((fullTileArea * z) / 4);\n    }\n    else\n      if ((((iv == 0) || (iv == (NUMNODES - 1))) || (iu == 0)) || (iu == (NUMNODES - 1)))\n    {\n      volume = volume + ((fullTileArea * z) / 2);\n    }\n    else\n    {\n      volume = volume + (fullTileArea * z);\n    }\n\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for collapse(2) default(none), shared(fullTileArea), reduction(+:volume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joykm/superquadric-volume/superquadricVolume/0"}
{"code": "for (int i = 0; i < total; i++)\n{\n  for (int j = 0; j < total; j++)\n  {\n    ma[i][j] = (rand() % 10) + 1;\n    mb[i][j] = (rand() % 10) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gonzalezlrjesus/Multiplicacion-Matrices-OpenMP/matriz/0"}
{"code": "for (j = begin_element; j < (input_vector_size - 1); j += 1)\n{\n  if (input_vector[j] > input_vector[j + 1])\n  {\n    swap(&input_vector[j], &input_vector[j + 1]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmirsamanAhmadi/OpenMPSorting/Combined Project/Combined Project/1"}
{"code": "for (i = 3; i <= n; i++)\n{\n  #pragma atomic update\n  nouv = der + av_der;\n  av_der = der;\n  der = nouv;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/exercices/fibonaci_parallel/1"}
{"code": "for_epilog = make(omp_for_appendix_environment, loop_context.shallow_copy(), prependix_list, appendix_list, omp_for.get_locus())\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/simd/tl-omp-simd-visitor/5"}
{"code": "for (int row = 0; row < A.num_rows; row++)\n  lu_decomp(A.entries[A.row_ptr[row]], swap[row]);\n\n", "pragma": "omp for SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/linsolv/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  km1 = k - 1;\n  kp1 = k + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tz2 * (ue[3][kp1] - ue[3][km1]))) + (dz1tz1 * ((ue[0][kp1] - (2.0 * ue[0][k])) + ue[0][km1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tz2 * ((ue[1][kp1] * buf[3][kp1]) - (ue[1][km1] * buf[3][km1])))) + (zzcon2 * ((buf[1][kp1] - (2.0 * buf[1][k])) + buf[1][km1]))) + (dz2tz1 * ((ue[1][kp1] - (2.0 * ue[1][k])) + ue[1][km1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tz2 * ((ue[2][kp1] * buf[3][kp1]) - (ue[2][km1] * buf[3][km1])))) + (zzcon2 * ((buf[2][kp1] - (2.0 * buf[2][k])) + buf[2][km1]))) + (dz3tz1 * ((ue[2][kp1] - (2.0 * ue[2][k])) + ue[2][km1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tz2 * (((ue[3][kp1] * buf[3][kp1]) + (c2 * (ue[4][kp1] - q[kp1]))) - ((ue[3][km1] * buf[3][km1]) + (c2 * (ue[4][km1] - q[km1])))))) + (zzcon1 * ((buf[3][kp1] - (2.0 * buf[3][k])) + buf[3][km1]))) + (dz4tz1 * ((ue[3][kp1] - (2.0 * ue[3][k])) + ue[3][km1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tz2 * ((buf[3][kp1] * ((c1 * ue[4][kp1]) - (c2 * q[kp1]))) - (buf[3][km1] * ((c1 * ue[4][km1]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[0][kp1] - (2.0 * buf[0][k])) + buf[0][km1]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[4][kp1] - (2.0 * buf[4][k])) + buf[4][km1]))) + (dz5tz1 * ((ue[4][kp1] - (2.0 * ue[4][k])) + ue[4][km1]));\n}\n\n", "pragma": "omp parallel for private (km1,kp1,k) firstprivate (tz2,zzcon1,zzcon2,zzcon3,zzcon4,zzcon5,dz1tz1,dz2tz1,dz3tz1,dz4tz1,dz5tz1,c1,c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/26"}
{"code": "for (i = 0; i < 1000; i++)\n  dist[i] = (int *) malloc(1000 * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gnalexandridis/Floyd-Warshall_HUA-PCA-2017-2018/openMP/1"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  a[x] = 1;\n  b[x] = x;\n  num_threads[x] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_add/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  A[i] = B[i] + C[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab2-Array_Operations/array_addition/0"}
{"code": "for (i = 0; i < nproc; ++i)\n{\n  printf(\"Processor %i performed %i iterations\\n\", i, its_per_proc[i]);\n  sum += its_per_proc[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WarwickRSE/OpenMPExamples/FromSlides/C/02_loop_decompose_1/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  scanf(\"%lf\", a + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timbo-rafa/parallel_programming/count_sort/count_sort_paralelo/2"}
{"code": "for (size_t i = 0; i < ex.size(); i++)\n  LOG_ERROR(((((\"ex[\" << ijk) << \"][\") << i) << \"]=\") << ex[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/GridStore/0"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < 2048; j++)\n  {\n    grid[i][j] = newgrid[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunosampaio08-zz/Game-Of-Life-PCD/gof-openmp/1"}
{"code": "for (int i = 0; i < TOTALSTEP; i++)\n{\n  double st = omp_get_wtime();\n  run_simulation(bodies);\n  (cout << (omp_get_wtime() - st)) << endl;\n  if (((i + 1) % PRINTSTEP) == 0)\n  {\n    writeBinary(myfile, bodies);\n    (cout << \"Writing Done...\") << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sayanmandal/Many-Body-Simulation-OpenMP/simulation/8"}
{"code": "for (j = 0; j < columns; j++)\n  printf(\"---\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pabvald/parallel-computing/openmp/openmp_implementation/11"}
{"code": "for (i = xadj[v]; i < xadj[v + 1]; i++)\n{\n  u = adjncy[i];\n  if (inqueue[u] == 2)\n    continue;\n\n  if ((sps[u] < 0) || ((sps[v] + adjwgt[i]) < sps[u]))\n  {\n    sps[u] = sps[v] + adjwgt[i];\n    if (inqueue[u])\n      gk_i32pqUpdate(queue, u, -sps[u]);\n    else\n    {\n      gk_i32pqInsert(queue, u, -sps[u]);\n      inqueue[u] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/11"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < cols; ++j)\n  {\n    (cout << mat[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/matrice_vector/src/main/3"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < min(10, m_br); j++)\n    (cout << phc[j]) << \" | \";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/3"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((0.75 - TEMP_MIN) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * SAMPLES), stat[i].e2 / ((((double) (L * L)) * (L * L)) * SAMPLES), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/47"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 1; j <= (x_max + 2); j++)\n  {\n    node_mass_post[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = 0.25 * ((((density1[FTNREF2D(j, k - 1, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j, k - 1, x_max + 5, x_min - 2, y_min - 2)]) + (density1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)])) + (density1[FTNREF2D(j - 1, k - 1, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j - 1, k - 1, x_max + 5, x_min - 2, y_min - 2)])) + (density1[FTNREF2D(j - 1, k, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)]));\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/5"}
{"code": "for (int j = 0; j < N; j++)\n  a[j] = b[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/openmp/veccopy/veccopy/0"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/8"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpakp0o2at.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpakp0o2at.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/23"}
{"code": "for (int i = 0; i < n_clusters; i++)\n{\n  for (int j = 0; j < n_features; j++)\n  {\n    if (cluster_sizes[i] > 0)\n    {\n      centroids[i][j] = new_centroids[i][j] / cluster_sizes[i];\n    }\n\n    new_centroids[i][j] = 0.0;\n  }\n\n  cluster_sizes[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/9"}
{"code": "for (int k = 0; k < (geom1->n_grid_z - 1); k++)\n  j_z[geom1->n_grid_r - 1][k] = 0.;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/current/4"}
{"code": "for (int i1 = 0; i1 < taskList.size(); i1++)\n{\n  cout << taskList[i1].toString();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/9"}
{"code": "for (jj = kk + 1; jj < bots_arg_size; jj++)\n  if (BENCH[(kk * bots_arg_size) + jj] != 0)\n{\n  {\n    fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n  }\n}\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/bots_bench/bots-sparselu-for/sparselu/0"}
{"code": "for (unsigned int k = 0; k < mesh.z_coordinates.size(); k++)\n{\n  for (unsigned int i = 0; i < mesh.x_coordinates.size(); i++)\n  {\n    for (unsigned int q = 0; q < number_of_densities(); q++)\n    {\n      int j = 0;\n      int n = voxel_index(i, j, k);\n      gradient_vectors[n][q][1] = (*p_density_vectors)[n + thomas_j_jump][q];\n      gradient_vectors[n][q][1] -= (*p_density_vectors)[n][q];\n      gradient_vectors[n][q][1] /= mesh.dy;\n      gradient_vector_computed[n] = true;\n    }\n\n    for (unsigned int q = 0; q < number_of_densities(); q++)\n    {\n      int j = mesh.y_coordinates.size() - 1;\n      int n = voxel_index(i, j, k);\n      gradient_vectors[n][q][1] = (*p_density_vectors)[n][q];\n      gradient_vectors[n][q][1] -= (*p_density_vectors)[n - thomas_j_jump][q];\n      gradient_vectors[n][q][1] /= mesh.dy;\n      gradient_vector_computed[n] = true;\n    }\n\n    for (unsigned int j = 1; j < (mesh.y_coordinates.size() - 1); j++)\n    {\n      for (unsigned int q = 0; q < number_of_densities(); q++)\n      {\n        int n = voxel_index(i, j, k);\n        gradient_vectors[n][q][1] = (*p_density_vectors)[n + thomas_j_jump][q];\n        gradient_vectors[n][q][1] -= (*p_density_vectors)[n - thomas_j_jump][q];\n        gradient_vectors[n][q][1] /= two_dy;\n        gradient_vector_computed[n] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/14"}
{"code": "for (int i = j + 1; i < m; i++)\n{\n  int im = i * m;\n  sum = at[i + jm];\n  for (k = 0; k < j; k++)\n  {\n    sum -= at[im + k] * at[jm + k];\n  }\n\n  at[im + j] = sum / at[j + jm];\n}\n\n", "pragma": "        #pragma omp parallel for private(k, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/0"}
{"code": "for (x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    left = (x == 0) ? (res_f[y * L]) : (phi_f[(x - 1) + (y * L)]);\n    right = (x == (L - 1)) ? (res_f[x + (y * L)]) : (phi_f[(x + 1) + (y * L)]);\n    up = (y == 0) ? (res_f[x]) : (phi_f[x + ((y - 1) * L)]);\n    down = (y == (L - 1)) ? (res_f[x + (y * L)]) : (phi_f[x + ((y + 1) * L)]);\n    r[x + (y * L)] = (res_f[x + (y * L)] - phi_f[x + (y * L)]) + (p.scale[lev] * (((left + right) + up) + down));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg_redblack/2"}
{"code": "for (int i = 0; i < n_line; i++)\n{\n  centroid_index = points_array[i].cluster_id - 1;\n  part_n_points[centroid_index]++;\n  for (int j = 0; j < 115; j++)\n  {\n    part_centroids[centroid_index].coordinate[j] += points_array[i].coordinate[j];\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/1"}
{"code": "for (j = 0; j < step_new_cells; j++)\n  cells[num_cells + j] = new_cells[j];\n\n", "pragma": "omp parallel for default(none) shared(step_new_cells, cells, new_cells, num_cells) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HylianPablo/Paralela2020/PRACTICA1 - OPENMP/OpenMP - Version final/backup/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] += alpha * P[i];\n}\n\n", "pragma": "#pragma omp parallel for shared(P, alpha, x, n) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/13"}
{"code": "for (unsigned local_vert = 0; local_vert < nlocalverts; local_vert++)\n{\n  uint64_t global_vert = local_min_vertex + ((uint64_t) local_vert);\n  if (is_visited_longlong(global_vert, last_marked) && (!is_visited_longlong(global_vert, marked)))\n  {\n    const unsigned neighbor_start = local_vertex_offsets[local_vert];\n    const unsigned neighbor_end = local_vertex_offsets[local_vert + 1];\n    for (int j = neighbor_start; j < neighbor_end; j++)\n    {\n      const uint64_t to_explore_global_id = neighbors[j];\n      if (!is_visited_longlong(to_explore_global_id, marked))\n      {\n        preds[to_explore_global_id] = global_vert;\n        set_visited_longlong(to_explore_global_id, marking, longlong_length);\n        count_signals++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/5"}
{"code": "for (int i = 0; i < n; ++i)\n  U[i] = (double *) malloc(n * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/21"}
{"code": "for (i = 0; i < size; i++)\n  for (j = 0; j < size; j++)\n{\n  a = adjacent_to(board, size, i, j);\n  if (a == 2)\n    newboard[i][j] = board[i][j];\n\n  if (a == 3)\n    newboard[i][j] = 1;\n\n  if (a < 2)\n    newboard[i][j] = 0;\n\n  if (a > 3)\n    newboard[i][j] = 0;\n\n}\n\n\n", "pragma": "omp parallel for private(i,j) num_threads(T)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/jogo_da_vida/paralell_life/0"}
{"code": "for (i = 0; i < (imax + 2); i++)\n{\n  fread(u[i], sizeof(float), jmax + 2, fp);\n  fread(v[i], sizeof(float), jmax + 2, fp);\n  fread(p[i], sizeof(float), jmax + 2, fp);\n  fread(flag[i], sizeof(char), jmax + 2, fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/karman/3"}
{"code": "for (int i = 0; i < order; i += 1)\n{\n  mask[i][0] = cornerX + i;\n  mask[i][1] = cornerY;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serrearthur/Fauxtoshop/source/src/base/mask/4"}
{"code": "for (j = 1; j <= 1024; j++)\n{\n  q = (j % 512) + 1;\n  if ((q >= xstart[0]) && (q <= xend[0]))\n  {\n    r = ((3 * j) % 256) + 1;\n    if ((r >= ystart[0]) && (r <= yend[0]))\n    {\n      s = ((5 * j) % 256) + 1;\n      if ((s >= zstart[0]) && (s <= zend[0]))\n      {\n        chk.real = chk.real + u1[s - zstart[0]][r - ystart[0]][q - xstart[0]].real, chk.imag = chk.imag + u1[s - zstart[0]][r - ystart[0]][q - xstart[0]].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  array[i] = rand() % 100;\n  fprintf(fptr, \"%f \", array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Assignments/1/ncpar/1"}
{"code": "for (int iCell = 0; iCell < m_cellSize; iCell++)\n{\n  this->m_INFRate[iCell] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SUR_GA/SUR_GreenAmpt/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  p[i] = 1.0 / n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leankyr/Parallel_Pagerank/Final/Implementation_2/main2/7"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  for (int j = 0; j <= i; j++)\n    C[i][j] *= beta;\n\n  for (int k = 0; k < 20; k++)\n  {\n    for (int j = 0; j <= i; j++)\n      C[i][j] += (alpha * A[i][k]) * A[j][k];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/1.norace12/0"}
{"code": "for (int i = 1; i < p; i++)\n{\n  int lp = segment_size * i;\n  int rp = (lp + segment_size) - 1;\n  if (i == (p - 1))\n  {\n    rp = t - 1;\n  }\n\n  bool parallel = 0;\n  float s1[q];\n  int s2[q];\n  for (int j = lp; j <= rp; j++)\n  {\n    fix_stage(n, j, q, t, s1, s2, dp1, Y, A, B);\n    parallel = is_parallel(q, t, j, s1, dp1);\n    if (parallel)\n    {\n      conv[i] = 1;\n      break;\n    }\n\n    copy_new_stage_to_old(q, t, j, s1, s2, dp1, dp2);\n  }\n\n  bool local_conv = 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_openmp/0"}
{"code": "for (i = 0; i < m; i++)\n  y[i] = z[i];\n\n", "pragma": "omp for nowait ordered schedule ( monotonic : runtime )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor10/1"}
{"code": "for (u = ((2U * 0x7fffffff) + 1) - 6; u < (((2U * 0x7fffffff) + 1) - 1); u++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/9"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  extend_with_margins(L, C, bools, bools_normal);\n  simulate_matrix(L + 2, C + 2, bools_normal, bools_buffered);\n  shrink_without_margins(L + 2, C + 2, bools_buffered, bools);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cristof17/Game-of-Life-OpenMP/g_omp/13"}
{"code": "for (int i = 0; i < NUM_OF_TASKS; i++)\n{\n  elems_in_partition[i] = min_elem_per_task + ((int) (remainder_elems != 0));\n  if (remainder_elems > 0)\n    remainder_elems--;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalgoyall/ParallelMatrixMult/Competition/main/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  int i;\n  if (oo_cur_salt->type < 3)\n  {\n    MD5_CTX ctx;\n    unsigned char hashBuf[21 * 16];\n    unsigned char key_hash[16];\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, saved_key[index], saved_len[index]);\n    MD5_Final(key_hash, &ctx);\n    for (i = 0; i < 16; i++)\n    {\n      memcpy(hashBuf + (i * 21), key_hash, 5);\n      memcpy((hashBuf + (i * 21)) + 5, oo_cur_salt->salt, 16);\n    }\n\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, hashBuf, 21 * 16);\n    MD5_Final(mitm_key[index], &ctx);\n    memset(&mitm_key[index][5], 0, 11);\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, mitm_key[index], 9);\n    MD5_Final(rc4_key[index], &ctx);\n  }\n  else\n  {\n    SHA_CTX ctx;\n    unsigned char H0[24];\n    unsigned char key_hash[20];\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, oo_cur_salt->salt, 16);\n    SHA1_Update(&ctx, saved_key[index], saved_len[index]);\n    SHA1_Final(H0, &ctx);\n    memset(&H0[20], 0, 4);\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, H0, 24);\n    SHA1_Final(key_hash, &ctx);\n    if (oo_cur_salt->type < 4)\n    {\n      memcpy(mitm_key[index], key_hash, 5);\n      memset(&mitm_key[index][5], 0, 11);\n    }\n    else\n      if (oo_cur_salt->type == 5)\n    {\n      memcpy(mitm_key[index], key_hash, 7);\n      memset(&mitm_key[index][7], 0, 9);\n    }\n    else\n      memcpy(mitm_key[index], key_hash, 16);\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/oldoffice_fmt_plug/0"}
{"code": "for (int i = 0; i < width; i++)\n  temp.push_back(0.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/2/Matrix/0"}
{"code": "for (i = 0; i < x; i++)\n{\n  if (dom[i][j][k] == 0)\n  {\n    svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / zdx[i];\n    xvel = fabs(vx[i][j][k]) / zdx[i];\n    tmp = max_dt(svel, xvel);\n    rdt1 = max_dt(tmp, rdt1);\n    if (viscosity_on_off == 1)\n    {\n      temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n      kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n      s_visc = kin_viscosity / (tmp * tmp);\n      rdt1 = max_dt(s_visc, rdt1);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc/2"}
{"code": "for (int n = 0; n < nArrays; n++)\n{\n  sumArray(factor[n], nElems, arrays + (n * nElems), result + n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/rfs-omp/main/4"}
{"code": "for (int i = 0; i < ALTURA; ++i)\n{\n  for (int j = 0; j < ALTURA; ++j)\n  {\n    double suma = pow(i - centroY, 2) + pow(j - centroX, 2);\n    if (suma > pow(radio, 2))\n    {\n      matrizPixeles[i][j].r *= 0.3;\n      matrizPixeles[i][j].g *= 0.59;\n      matrizPixeles[i][j].b *= 0.11;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danielsto/arcos-openmp/Paralela/ARCfmtut_par/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (mask1[index1][i] && mask2[index2][i])\n  {\n    tdata1[m] = data1[index1][i];\n    tdata2[m] = data2[index2][i];\n    m++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/41"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  dky2 = dky * dky;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1.0 / ((dkx * dkx) + dky2);\n    zt1 = cimagf(amu[6 * (j + kj)]) - (crealf(amu[6 * (j + kj)]) * _Complex_I);\n    zt2 = cimagf(amu[1 + (6 * (j + kj))]) - (crealf(amu[1 + (6 * (j + kj))]) * _Complex_I);\n    zt3 = cimagf(amu[2 + (6 * (j + kj))]) - (crealf(amu[2 + (6 * (j + kj))]) * _Complex_I);\n    zt1 = (dkx * zt1) + (dky * zt2);\n    zt4 = cimagf(amu[3 + (6 * (j + kj))]) - (crealf(amu[3 + (6 * (j + kj))]) * _Complex_I);\n    zt5 = cimagf(amu[4 + (6 * (j + kj))]) - (crealf(amu[4 + (6 * (j + kj))]) * _Complex_I);\n    zt2 = (dkx * zt2) + (dky * zt4);\n    zt3 = (dkx * zt3) + (dky * zt5);\n    zt4 = at1 * ((dkx * zt1) + (dky * zt2));\n    dcu[3 * (j + kj)] = zt1 - (dkx * zt4);\n    dcu[1 + (3 * (j + kj))] = zt2 - (dky * zt4);\n    dcu[2 + (3 * (j + kj))] = zt3;\n    dcu[3 * ((j + kj) + l1)] = zero;\n    dcu[1 + (3 * ((j + kj) + l1))] = zero;\n    dcu[2 + (3 * ((j + kj) + l1))] = zero;\n    zt1 = cimagf(amu[6 * (j + k1)]) - (crealf(amu[6 * (j + k1)]) * _Complex_I);\n    zt2 = cimagf(amu[1 + (6 * (j + k1))]) - (crealf(amu[1 + (6 * (j + k1))]) * _Complex_I);\n    zt3 = cimagf(amu[2 + (6 * (j + k1))]) - (crealf(amu[2 + (6 * (j + k1))]) * _Complex_I);\n    zt1 = (dkx * zt1) - (dky * zt2);\n    zt4 = cimagf(amu[3 + (6 * (j + k1))]) - (crealf(amu[3 + (6 * (j + k1))]) * _Complex_I);\n    zt5 = cimagf(amu[4 + (6 * (j + k1))]) - (crealf(amu[4 + (6 * (j + k1))]) * _Complex_I);\n    zt2 = (dkx * zt2) - (dky * zt4);\n    zt3 = (dkx * zt3) - (dky * zt5);\n    zt4 = at1 * ((dkx * zt1) - (dky * zt2));\n    dcu[3 * (j + k1)] = zt1 - (dkx * zt4);\n    dcu[1 + (3 * (j + k1))] = zt2 + (dky * zt4);\n    dcu[2 + (3 * (j + k1))] = zt3;\n    dcu[3 * ((j + k1) + l1)] = zero;\n    dcu[1 + (3 * ((j + k1) + l1))] = zero;\n    dcu[2 + (3 * ((j + k1) + l1))] = zero;\n  }\n\n  zt2 = cimagf(amu[1 + (6 * kj)]) - (crealf(amu[1 + (6 * kj)]) * _Complex_I);\n  zt1 = dky * zt2;\n  zt5 = cimagf(amu[4 + (6 * kj)]) - (crealf(amu[4 + (6 * kj)]) * _Complex_I);\n  zt3 = dky * zt5;\n  dcu[3 * kj] = zt1;\n  dcu[1 + (3 * kj)] = zero;\n  dcu[2 + (3 * kj)] = zt3;\n  dcu[3 * k1] = zero;\n  dcu[1 + (3 * k1)] = zero;\n  dcu[2 + (3 * k1)] = zero;\n  dcu[3 * (kj + l1)] = zero;\n  dcu[1 + (3 * (kj + l1))] = zero;\n  dcu[2 + (3 * (kj + l1))] = zero;\n  dcu[3 * (k1 + l1)] = zero;\n  dcu[1 + (3 * (k1 + l1))] = zero;\n  dcu[2 + (3 * (k1 + l1))] = zero;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kj,dky,dky2,dkx,at1,zt1,zt2,zt3,zt4,zt5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/7"}
{"code": "for (int i = w.start; i < w.end; i++)\n{\n  Pole pole = poles[(nuc * max_num_poles) + i];\n  RSComplex E_c = {E, 0};\n  RSComplex dopp_c = {dopp, 0};\n  RSComplex Z = c_mul(c_sub(E_c, pole.MP_EA), dopp_c);\n  RSComplex faddeeva = fast_nuclear_W(Z);\n  sigT += c_mul(pole.MP_RT, c_mul(faddeeva, sigTfactors[pole.l_value])).r;\n  sigA += c_mul(pole.MP_RA, faddeeva).r;\n  sigF += c_mul(pole.MP_RF, faddeeva).r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/rsbench-omp/simulation/4"}
{"code": "for (int i = 1; i < checkpointCount; i++)\n{\n  checkpointInstantOfTime[i] = checkpointInstantOfTime[i - 1] + checkpointTimeDelta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_DimensionalSplittingCharm/0"}
{"code": "formula.append(number(f) + \"x^2 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/24"}
{"code": "for (int i = 0; i < trace_size; i++)\n{\n  int trace_offset = (trace_step * trace_size) + i;\n  int offset = ((pos_y[i] * wnz_wnx) + std_offset) + pos_x[i];\n  ApplyOnPressure(offset, trace_offset, pressure, velocity, traces);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/trace-managers/SeismicTraceManager/0"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  solution[i] = equal_prob;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/steven112163/Parallel-Programming/HW3/part2/page_rank/page_rank/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    testaccumulator += m_testmatrix->GetElem(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fpaboim/gpufem/src/Test/SPRmatrixTest/4"}
{"code": "for (unsigned c = 0; c < TimerGetCount(); c++)\n  if (TimerIsActive(c))\n{\n  hinfo = (hinfo + \";\") + TimerGetName(c);\n  dinfo = (dinfo + \";\") + FloatStr(TimerGetValue(c) / 1000.f);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src_mphase/DSPH_v5.0_NNewtonian/source/JSphCpu/1"}
{"code": "for (int i = 1; i <= actualSize; i++)\n{\n  final_total += matrixMultiply(n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KasunEdward/OpenMP_Project/OV_Parallel/4"}
{"code": "for (i = 0; i < size; ++i)\n{\n  tid = omp_get_thread_num();\n  res[tid * 8] += a[i];\n}\n\n", "pragma": "omp parallel for private (i, tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/Reduction/0"}
{"code": "for (int i = 0; i < VERTICES; i++)\n{\n  filaActualFile = filasArchivo[i];\n  tokenizedstr = strtok(filaActualFile, \" \");\n  actualNum = atoi(tokenizedstr);\n  graph[i][0] = actualNum;\n  for (int j = 1; j < VERTICES; j++)\n  {\n    tokenizedstr = strtok(NULL, \" \");\n    actualNum = atoi(tokenizedstr);\n    graph[i][j] = actualNum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JFcoZC/PrimMSTParallelOpenMP/PrimSTPOpenMP/1"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == fluid)\n  {\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double duXi = 0.0;\n    double duYi = 0.0;\n    double duZi = 0.0;\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstij2);\n                double dw = delWeight(dst, reS, weightType);\n                duXi += dw * (vel[j * 3] - velXi);\n                duYi += dw * (vel[(j * 3) + 1] - velYi);\n                duZi += dw * (vel[(j * 3) + 2] - velZi);\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    if (particleBC[i] == inner)\n    {\n      vel[i * 3] -= coeffShifting1 * duXi;\n      vel[(i * 3) + 1] -= coeffShifting1 * duYi;\n      vel[(i * 3) + 2] -= coeffShifting1 * duZi;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/85"}
{"code": "for (int i = 0; i < numberSats; i++)\n{\n  update_satellite(&satellites[i], DELTA_TIME);\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KeelyHill/Parallel-Sat-Swarm/main/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  temp = (struct node *) malloc(sizeof(struct node));\n  p->next = temp;\n  p = temp;\n  p->data = (38 + i) + 1;\n  p->fibdata = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OmpCommonCore/ChallengeProblems/Linked_lists/Solutions/linked_omp25/0"}
{"code": "for (int i = 0; i < d_set.size(); i++)\n{\n  if (search == d_set.at(i))\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alaw-private/CS110C-ParProg-OpenMP/o-mp-headers/parallelSearch/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      R[i][j] = 0.0;\n    }\n    else\n    {\n      R[i][j] = A[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/1"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    scanfReturn = fscanf(myFile, \"%d%*c\", &myvar2);\n    if (scanfReturn == 1)\n    {\n    }\n    else\n    {\n      printf(\"error in %d,%d. \\n\", i, j);\n      return 1;\n    }\n\n    if ((i >= start) && (i <= end))\n    {\n      if (pointPerkNN[i - start][j] != myvar2)\n        errors++;\n\n    }\n\n    if (i > end)\n    {\n      goto stop2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpinb/2"}
{"code": "for (i = 0; i <= (12 + 1); i++)\n{\n  for (k = 0; k <= (12 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/28"}
{"code": "for (row = 0; row < N; row++)\n{\n  float tmp = 0.0;\n  for (col = 0; col < N; col++)\n  {\n    tmp += Aprime[col + (row * N)] * x[col];\n  }\n\n  tmp = b[row] - tmp;\n  err += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/textfox/jacobi_openmp/jacobi/4"}
{"code": "for (; (CI != CE) && (SI != SE); ++CI, ++SI)\n{\n  if ((CurrentRegionOnly && ((((isa < ArraySubscriptExpr) > CI->getAssociatedExpression()) || ((isa < OMPArraySectionExpr) > CI->getAssociatedExpression())) || ((isa < OMPArrayShapingExpr) > CI->getAssociatedExpression()))) && ((((isa < ArraySubscriptExpr) > SI->getAssociatedExpression()) || ((isa < OMPArraySectionExpr) > SI->getAssociatedExpression())) || ((isa < OMPArrayShapingExpr) > SI->getAssociatedExpression())))\n  {\n    SemaRef.Diag(CI->getAssociatedExpression()->getExprLoc(), err_omp_multiple_array_items_in_map_clause) << CI->getAssociatedExpression()->getSourceRange();\n    SemaRef.Diag(SI->getAssociatedExpression()->getExprLoc(), note_used_here) << SI->getAssociatedExpression()->getSourceRange();\n    return true;\n  }\n\n  if (CI->getAssociatedExpression()->getStmtClass() != SI->getAssociatedExpression()->getStmtClass())\n    break;\n\n  if (CI->getAssociatedDeclaration() != SI->getAssociatedDeclaration())\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/lib/Sema/SemaOpenMP/3"}
{"code": "for (i = i0; i < (((i0 + block_size) > n) ? (n) : (i0 + block_size)); i++)\n  sum += B[i] * C[i];\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.54.2/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (jmin = 0; jmin < n; jmin = jmin + 4)\n  {\n    jmax = min(jmin + 4, n);\n    for (j = jmin; j < jmax; j++)\n    {\n      ((((((salida << \"  \") << r[i][j]) << \"  \") << g[i][j]) << \"  \") << b[i][j]) << \"\\n\";\n    }\n\n    salida << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/Fractal-Mandelbrot/main/1"}
{"code": "for (int i = starts[thread_num] + 1; i < ends[thread_num]; i++)\n{\n  a[i] += a[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/radinshayanfar/MCP/Lab4/Lab_4_m1/1"}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  for (j = 1; j <= 1000; j++)\n  {\n    Anew[i][j] = 0.25 * (((A[i + 1][j] + A[i - 1][j]) + A[i][j + 1]) + A[i][j - 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos de aula/OpenACC/OMP_jacobi/0"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  printf(\"%d, \", array.array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/domo23/mpr_openmp/random/1"}
{"code": "for (i = id + 1;; i++)\n{\n  if (i == p)\n    i = 0;\n\n  if (i == id)\n    continue;\n\n  MPI_Send(&i, 1, (MPI_Datatype) 0x4c000405, i, 3, (MPI_Comm) 0x44000000);\n  MPI_Probe(-2, -1, (MPI_Comm) 0x44000000, &status);\n  MPI_Get_count(&status, (MPI_Datatype) 0x4c000405, &number_amount);\n  int *number_buf = (int *) malloc(number_amount * (sizeof(int)));\n  MPI_Recv(number_buf, number_amount, (MPI_Datatype) 0x4c000405, status.MPI_SOURCE, -1, (MPI_Comm) 0x44000000, &status);\n  if ((status.MPI_TAG == 1) && (number_amount != 2))\n  {\n    Item hyp_recv;\n    memcpy(&hyp_recv, number_buf, sizeof(Item));\n    memcpy(cp_sudoku, number_buf + 2, v_size * (sizeof(int)));\n    delete_from(sudoku, cp_sudoku, rows_mask, cols_mask, boxes_mask, hyp_recv.cell);\n    insert_head(work, hyp_recv);\n    free(number_buf);\n    break;\n  }\n  else\n    if ((status.MPI_TAG == 1) && (number_amount == 2))\n  {\n    no_sol_count++;\n  }\n  else\n    if (status.MPI_TAG == 2)\n  {\n    send_ring(&id, 2, -1);\n    return 0;\n  }\n  else\n    if (status.MPI_TAG == 3)\n  {\n    MPI_Send(&no_hyp, 2, (MPI_Datatype) 0x4c000405, status.MPI_SOURCE, 1, (MPI_Comm) 0x44000000);\n  }\n\n\n\n\n  if ((no_sol_count == (p - 1)) && (id == 0))\n  {\n    send_ring(&id, 2, -1);\n    return 0;\n  }\n\n  free(number_buf);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/8"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  free(g->n[i].adj);\n  omp_destroy_lock(&g->n[i].mutex);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/sol/part3b.sol.2/1"}
{"code": "for (int block_count = 0; block_count < (s * q); block_count++)\n{\n  int i = block_count / q;\n  int j = block_count % q;\n  for (int k = i * block_height; k < ((i + 1) * block_height); k++)\n    for (int l = j * block_width; l < ((j + 1) * block_width); l++)\n    result[k] += a[k][l] * b[l];\n\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task5/OpenMPtask5/3"}
{"code": "for (j = nps - 1; j < npt; j++)\n{\n  part[2 + (idimp * j)] -= sum4[0];\n  part[3 + (idimp * j)] -= sum4[1];\n  part[4 + (idimp * j)] -= sum4[2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/27"}
{"code": "for (j = 0; j < len; j++)\n{\n  printf(\"%lf\", a[i][j]);\n}\n\n", "pragma": "omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB003-antidep2-orig-yes/2"}
{"code": "for (int i = 0; i < M; ++i)\n  for (int j = 0; j < M; ++j)\n{\n  if ((((i % 2) == 0) && ((j % 2) == 0)) || (((i % 2) != 0) && ((j % 2) != 0)))\n    black += chess[i][j];\n\n  if ((((i % 2) == 0) && ((j % 2) != 0)) || (((i % 2) != 0) && ((j % 2) == 0)))\n    white += chess[i][j];\n\n}\n\n\n", "pragma": "\t\t#pragma omp for reduction(+: black) reduction(+: white)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kei91/openmp/7/1"}
{"code": "for (int j = 0; j < 4; j++)\n  b->q[j] += h * dq[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zcl2016/Gazebo-exercise/gazebo7_7.14.0_exercise/deps/opende/src/util/2"}
{"code": "for (int gid = 0; gid < (num / VEC_LENGTH); gid++)\n{\n  for (int i = 0; i < DIM; ++i)\n  {\n    for (int j = 0; j < DIM; ++j)\n    {\n      for (int k = 0; k < DIM; ++k)\n      {\n        sigma_out[sigma_imag(i, j)] -= hamiltonian[ham_real(i, k)] * sigma_in[sigma_real(k, j)];\n        sigma_out[sigma_imag(i, j)] += sigma_in[sigma_real(i, k)] * hamiltonian[ham_real(k, j)];\n        sigma_out[sigma_imag(i, j)] += hamiltonian[ham_imag(i, k)] * sigma_in[sigma_imag(k, j)];\n        sigma_out[sigma_imag(i, j)] -= sigma_in[sigma_imag(i, k)] * hamiltonian[ham_imag(k, j)];\n        sigma_out[sigma_real(i, j)] += hamiltonian[ham_real(i, k)] * sigma_in[sigma_imag(k, j)];\n        sigma_out[sigma_real(i, j)] -= sigma_in[sigma_real(i, k)] * hamiltonian[ham_imag(k, j)];\n        sigma_out[sigma_real(i, j)] += hamiltonian[ham_imag(i, k)] * sigma_in[sigma_real(k, j)];\n        sigma_out[sigma_real(i, j)] -= sigma_in[sigma_imag(i, k)] * hamiltonian[ham_real(k, j)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp target teams distribute parallel for thread_limit(VEC_LENGTH)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hexciton-omp/main/9"}
{"code": "for (int i = 1; i < npes; i++)\n{\n  MPI_Send(0, 0, MPI_INT, i, TERMINATE_TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ricaidito/MandelbrotSet/Parallel/MandelbrotSetParallel/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  int a;\n  int b;\n  int c;\n  for (int j = 0; j < 10; ++j)\n    ;\n\n  {\n    for (int j = 0; j < 10; ++j)\n      ;\n\n    for (int j = 0; j < 10; ++j)\n      ;\n\n  }\n}\n\n", "pragma": "#pragma omp for collapse(2)      ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_collapse_messages/2"}
{"code": "for (i = 0; i < 64; i++)\n  derivedKey[i] = (i < 20) ? (0x36 ^ hashValue[i]) : (0x36);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/2"}
{"code": "for (i = 1; i <= length; i++)\n{\n  if (i <= n_A)\n    AA[i] = rank(A[(i * a) - 1] - 1, B, sizeB);\n\n  if (j <= n_B)\n    BB[j - 1] = rank(B[(j * b) - 1], A, sizeA);\n\n  j++;\n}\n\n", "pragma": "omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/B/ass2-openmp/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  temp[length + i] = 'c';\n}\n\n", "pragma": "omp parallel for shared(temp,i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/test4/0"}
{"code": "for (int src = 0; src < m; src++)\n{\n  if (depth[src] < 0)\n  {\n    int row_begin = row_offsets[src];\n    int row_end = row_offsets[src + 1];\n    for (int offset = row_begin; offset < row_end; offset++)\n    {\n      int dst = column_indices[offset];\n      if (front.get_bit(dst))\n      {\n        depth[src] = depth[dst] + 1;\n        awake_count++;\n        next.set_bit(src);\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : awake_count) schedule(dynamic, 1024)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bfs/omp_target/0"}
{"code": "for (i = 0; i < bLength; i++)\n{\n  a[currentOffset + i] = b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eduardnegru/Parallel-Odd-Even-Transposition-Sort/hybrid_omp/4"}
{"code": "for (int i = 0; i < pointsSize; ++i)\n{\n  clusterTmp[i] = whichClosest(&freqTable, i, cluster[i], clouds, cloudSize);\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/10"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n  cin >> A[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jake33rus/MPI-OpenMP-labs-and-CursProject/lab2Parallels/lab2Parallels/lab2Parallels/5"}
{"code": "for (md4_size = 0; md4_size < len; i++, md4_size += 2)\n{\n  key.u16[md4_size] = keybuffer[i] >> 16;\n  key.u16[md4_size + 1] = keybuffer[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash1_fmt_plug/8"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  avg += a[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task6/1"}
{"code": "for (int i = 0; i < no_of_threads; i++)\n{\n  local_start[i] = ave * i;\n  local_end[i] = ave * (i + 1);\n  if (i == (no_of_threads - 1))\n  {\n    local_end[i] = n;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IzaanSohail1999/OpenMP-ShortestPathProblem-BellmanFord/Shortest_path_problem_openmp/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (graph->grid->out_degree[v])\n    riDividedOnDiClause[v] = DoubleToFixed64(stats->pageRanks[v] / graph->grid->out_degree[v]);\n  else\n    riDividedOnDiClause[v] = 0.0f;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/7"}
{"code": "for (int kk = 0; kk < (N + 2); kk += 2)\n{\n  for (int ii = 0; ii < (N + 2); ii += 2)\n  {\n    fill_array3d(new_X, new_N, ii / 2, 0, kk / 2, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/1"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  v1[i] = (double) i;\n  v2[i] = (double) (i / 2.0);\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/vector_dot_product/0"}
{"code": "for (int i = 0; i < b; i++)\n  p *= a;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhasamritasarmah/mpi_openmp_programming_basics/mpi_omp_drakes_equation_problem_formulation/6"}
{"code": "for (j = 0; j < n; j++)\n  s = s + (a[j][i] * a[j][i]);\n\n", "pragma": "omp parallel for reduction(+:s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_2/QRD/Approach 1/parallel/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  C[i + 10] = A[i] + B[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/examples/tools/asan/heap_buffer_overflow/openmp/vecadd-HBO/0"}
{"code": "for (int k = 0; k < (100 / 4); k++)\n  for (int l = 0; l < 4; l++)\n  a[(k * 4) + l] = (k * 4) + l;\n\n\n", "pragma": "omp target parallel for simd collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-parallel-for-simd-clauses/test/1"}
{"code": "for (i = 0; i < 24; i++)\n  p[i] = p[i] + 1;\n\n", "pragma": "omp target teams distribute parallel for map(p[0:24])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/target-8/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    for (k = 0; k <= ((i < j) ? (i) : (j)); k++)\n      m[(i * size) + j] = l[(i * size) + k] * u[(j * size) + k];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lud/omp/lud_omp_one_file/3"}
{"code": "for (int i = 0; i < N; i++)\n  (cout << a[i]) << \", \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/0"}
{"code": "for (j = 0; j < NB; j++)\n{\n  double sum = C[(i * NB) + j];\n  for (k = 0; k < NB; k++)\n  {\n    sum += A[(i * NB) + k] * B[(k * NB) + j];\n  }\n\n  C[(i * NB) + j] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/15"}
{"code": "for (i = 0; i < s; i++)\n{\n  x[i] = rand() / 32768.0;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/cg/7"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n{\n  for (int j = 0; j < k; ++j)\n  {\n    double *maxk = max_element(weights[i], weights[i] + sizeOfItems);\n    maxKWeight[i][j] = *maxk;\n    maxKIndex[i][j] = maxk - weights[i];\n    *maxk = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-action-based/4"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"%f\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/openmp/2"}
{"code": "for (i = 1; i <= n; ++i)\n{\n  remainder = 1;\n  for (digit = 0; (digit < (d + 11)) && remainder; ++digit)\n  {\n    div = remainder / i;\n    mod = remainder % i;\n    aux[omp_get_thread_num()][digit] += div;\n    remainder = mod * 10;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(digit, div, mod, remainder)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonardocreatus/Progama-oParalela-OpenMP/reduce/1"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int n_genes_to_sent;\n  MPI_Recv(&n_genes_to_sent, 1, MPI_INT, i, ask_for_genes_tag, comm, &status);\n  int genes_to_sent_id[n_genes_to_sent];\n  MPI_Recv(genes_to_sent_id, n_genes_to_sent, MPI_INT, i, ask_for_genes_tag, comm, &status);\n  ((cout << \"rank[0][recv] rank[\") << i) << \"][want] string(id): \";\n  for (int j = 0; j < n_genes_to_sent; j++)\n  {\n    (cout << genes_to_sent_id[j]) << \" \";\n    MPI_Send(&genes_length[genes_to_sent_id[j]], 1, MPI_INT, i, j, MPI_COMM_WORLD);\n    MPI_Send(genes[genes_to_sent_id[j]].c_str(), genes_length[genes_to_sent_id[j]], MPI_CHAR, i, j, MPI_COMM_WORLD);\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel1/4"}
{"code": "for (i = 2; i < Ph; i++)\n{\n  for (j = 2; j < Pw; j++)\n  {\n    for (l = 0; l < d; l++)\n    {\n      output_imag[(((i * d) * (Pw + 2)) + (d * j)) + l] = ((((((((input_imag[(((((i + 0) - 1) * d) * (Pw + 2)) + (d * ((j + 0) - 1))) + l] * h[0][0]) + (input_imag[(((((i + 0) - 1) * d) * (Pw + 2)) + (d * ((j + 1) - 1))) + l] * h[0][1])) + (input_imag[(((((i + 0) - 1) * d) * (Pw + 2)) + (d * ((j + 2) - 1))) + l] * h[0][2])) + (input_imag[(((((i + 1) - 1) * d) * (Pw + 2)) + (d * ((j + 0) - 1))) + l] * h[1][0])) + (input_imag[(((((i + 1) - 1) * d) * (Pw + 2)) + (d * ((j + 1) - 1))) + l] * h[1][1])) + (input_imag[(((((i + 1) - 1) * d) * (Pw + 2)) + (d * ((j + 2) - 1))) + l] * h[1][2])) + (input_imag[(((((i + 2) - 1) * d) * (Pw + 2)) + (d * ((j + 0) - 1))) + l] * h[2][0])) + (input_imag[(((((i + 2) - 1) * d) * (Pw + 2)) + (d * ((j + 1) - 1))) + l] * h[2][1])) + (input_imag[(((((i + 2) - 1) * d) * (Pw + 2)) + (d * ((j + 2) - 1))) + l] * h[2][2]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(2) default(none) private(i,j,l) shared(input_imag,output_imag,Pw,Ph,d) schedule(static,4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chpapantonis/Parallel_Programming/OpenMP/main/0"}
{"code": "for (i = 0; i < (subvector_size * nTHREADS); i += subvector_size)\n{\n  s += vector[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/sum_vector/4"}
{"code": "for (int j = 2; j < ny; j += 2)\n{\n  for (int i = 2; i < nx; i += 2)\n  {\n    temp = inv * ((rhs[i + ((nx + 1) * j)] + (hy_2 * (get(i + 1, j) + get(i - 1, j)))) + (hx_2 * (get(i, j + 1) + get(i, j - 1))));\n    set(i, j, temp);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for private (temp) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akjain90/OpenMP-parallized-RBGS-solver/matrix/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = i;\n  if (N > 10000)\n  {\n    A[0] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB178-input-dependence-var-yes/0"}
{"code": "for (i = 0; i < nodes; i++)\n{\n  x_old[i] = one_over_N;\n  x_new[i] = 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/Ferdig/PE_functions_15243/1"}
{"code": "for (int a_block_count = 0; a_block_count < (p * q); a_block_count++)\n{\n  int i_block_index = a_block_count / q;\n  int j_block_index = a_block_count % q;\n  for (int t_block_index = 0; t_block_index < r; t_block_index++)\n  {\n    for (int i = i_block_index * a_block_height; i < ((i_block_index + 1) * a_block_height); i++)\n      for (int j = j_block_index * a_block_width; j < ((j_block_index + 1) * a_block_width); j++)\n      for (int t = t_block_index * b_block_width; t < ((t_block_index + 1) * b_block_width); t++)\n      res_matrix[i][t] += matrix1[i][j] * matrix2[j][t];\n\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergere15/OpenMP_tasks/task4/Task4/0"}
{"code": "for (int I = 0; I < Dimension; I++)\n{\n  X[I] = B[I];\n  for (int J = 0; J < Dimension; J++)\n  {\n    if (I != J)\n      X[I] -= A[(I * Dimension) + J] * X_last[J];\n\n  }\n\n  X[I] = X[I] / A[(I * Dimension) + I];\n  X[0];\n  X[1];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Parallel-Programming/Jacobi_openMP/EquationsLinearSystem/4"}
{"code": "for (i = 2; i < 500; i += 500 / 250)\n{\n  init(i, a, b_gpu);\n  Crout_GPU(i, a, b_gpu);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/lu-decomposition/src/lu-decomposition_gpu/3"}
{"code": "for (int i = 0; i < 100000400; ++i)\n{\n  min_test.push_back(rand() % 20000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jonahkall/JBParallel/ptest/1"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  for (j = 0; j < npp; j++)\n  {\n    dx = ppart[idimp * (j + (nppmx * k))];\n    dy = ppart[1 + (idimp * (j + (nppmx * k)))];\n    ist = 0;\n    if (dx < edgelx)\n      ist = 1;\n\n    if (dx >= edgerx)\n      ist = 2;\n\n    if (dy < edgely)\n      ist += 3;\n\n    if (dy >= edgery)\n      ist += 6;\n\n    if (ist > 0)\n      *irc = k + 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,noff,moff,npp,nn,mm,ist,edgelx,edgely,edgerx,edgery,dx,dy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/0"}
{"code": "for (int l = 0; l < 100; l++)\n{\n  for (int i = 0; i < 100; i++)\n  {\n    A = CreateArray(temp);\n    start = omp_get_wtime();\n    shellSortParallel(A, length);\n    end = omp_get_wtime();\n    instanceTotal = end - start;\n    total += instanceTotal;\n  }\n\n  ntotal = total / 100;\n  newtotal += ntotal;\n  newtotal = newtotal / 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Matt-st/Parallel_shell_sort/ShellOpenMP/1"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  for (j = 0; j < nclusters; j++)\n    partial_new_centers[i][j] = (float *) calloc(nfeatures, sizeof(float));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_kmeans_openmp/kmeans_clustering/9"}
{"code": "for (int i = 0; i < ((512 * 512) * 256); i++)\n{\n  if (serialarray[i] != parallelarray[i])\n  {\n    printf(\"Data check failed offset %d\\n\", i);\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tiandiao123/parallel-programming/project 1/filter/1"}
{"code": "for (i = 0; i < nygrid; i++)\n  free(dummymask[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/100"}
{"code": "for (i = 0; i < n; i++)\n  *nrm += x[i] * x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/6"}
{"code": "for (int i = k + 1; i < n; i++)\n  for (int j = k + 1; j < n; j++)\n{\n  data[i][j] -= data[k][j] * data[i][k];\n}\n\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmwu/Matrix-LU-decomposition/luDecomp/4"}
{"code": "for (size_t i = 0; i < n1; i++)\n{\n  for (size_t k = 0; k < m1; k++)\n  {\n    const float *bl = mb[k];\n    const float v = ma[i][k];\n    float *rl = resultMatrix[i];\n    for (size_t j = 0; j < m2; j++)\n    {\n      rl[j] += v * bl[j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/4"}
{"code": "for (int i = 0; i < v1.size(); ++i)\n{\n  result[i] = v1[i] + v2[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(v1,v2,result)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ntuhpc/training-ay1819/4-Parallel_Programming_Models/OpenMP/solution/vec_add_omp/0"}
{"code": "for (i = 0; i < l; i++)\n  if (labels[i] > 0)\n  prior1 += 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/39"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      wijk = ws[k][j][i];\n      wp1 = ws[k + 1][j][i];\n      wm1 = ws[k - 1][j][i];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dz1tz1 * ((u[k + 1][j][i][0] - (2.0 * u[k][j][i][0])) + u[k - 1][j][i][0]))) - (tz2 * (u[k + 1][j][i][3] - u[k - 1][j][i][3]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dz2tz1 * ((u[k + 1][j][i][1] - (2.0 * u[k][j][i][1])) + u[k - 1][j][i][1]))) + (zzcon2 * ((us[k + 1][j][i] - (2.0 * us[k][j][i])) + us[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][1] * wp1) - (u[k - 1][j][i][1] * wm1)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dz3tz1 * ((u[k + 1][j][i][2] - (2.0 * u[k][j][i][2])) + u[k - 1][j][i][2]))) + (zzcon2 * ((vs[k + 1][j][i] - (2.0 * vs[k][j][i])) + vs[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][2] * wp1) - (u[k - 1][j][i][2] * wm1)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dz4tz1 * ((u[k + 1][j][i][3] - (2.0 * u[k][j][i][3])) + u[k - 1][j][i][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[k + 1][j][i][3] * wp1) - (u[k - 1][j][i][3] * wm1)) + ((((u[k + 1][j][i][4] - square[k + 1][j][i]) - u[k - 1][j][i][4]) + square[k - 1][j][i]) * c2)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dz5tz1 * ((u[k + 1][j][i][4] - (2.0 * u[k][j][i][4])) + u[k - 1][j][i][4]))) + (zzcon3 * ((qs[k + 1][j][i] - (2.0 * qs[k][j][i])) + qs[k - 1][j][i]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[k + 1][j][i][4] * rho_i[k + 1][j][i]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k - 1][j][i][4] * rho_i[k - 1][j][i])))) - (tz2 * ((((c1 * u[k + 1][j][i][4]) - (c2 * square[k + 1][j][i])) * wp1) - (((c1 * u[k - 1][j][i][4]) - (c2 * square[k - 1][j][i])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/4"}
{"code": "for (j = 0; j <= sizeOfArray; j++)\n{\n  augmentedMatrix[i][j] = augmentedMatrix[i][j] - (ratio * augmentedMatrix[k][j]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adamneal/openMP/Source/1"}
{"code": "for (int g = 0; g < I.n_egroups; g++)\n{\n  flux_integral[g] = ((((q0[g] * tau[g]) + (((sigT[g] * psi[g]) - q0[g]) * expVal[g])) / sigT2[g]) + ((q1[g] * mu) * reuse[g])) + (((q2[g] * mu2) * ((tau[g] * ((tau[g] * (tau[g] - 3.f)) + 6.f)) - (6.f * expVal[g]))) / ((3.f * sigT2[g]) * sigT2[g]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/11"}
{"code": "for (int test = 1; test <= 10; test++)\n{\n  printf(\"\\nInicio test= %i\\n\", test);\n  init_vector();\n  if (0 == 1)\n    print_vector(W, 512);\n\n  init_matrix(A, 512);\n  if (0 == 1)\n    print_matrix(A, 512);\n\n  init_matrix(B, 512);\n  if (0 == 1)\n    print_matrix(B, 512);\n\n  step = 1;\n  time_init = MPI_Wtime();\n  while (step <= 5)\n  {\n    printf(\"\\nstep = %i\\n\", step);\n    for (id_slave = 1; id_slave <= slaves; id_slave++)\n    {\n      if (id_slave == slaves)\n        rows = rest;\n\n      MPI_Send(&step, 1, (MPI_Datatype) 0x4c000405, id_slave, 0, 1);\n      MPI_Send(&rows, 1, (MPI_Datatype) 0x4c000405, id_slave, 0, 1);\n      MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, id_slave, 0, 1);\n      switch (step)\n      {\n        case 1:\n\n        case 3:\n\n        case 5:\n          MPI_Send(&A[offset][0], rows * 512, (MPI_Datatype) 0x4c00080b, id_slave, 0, 1);\n          MPI_Send(&B, 512 * 512, (MPI_Datatype) 0x4c00080b, id_slave, 0, 1);\n          MPI_Send(&W, 512, (MPI_Datatype) 0x4c00080b, id_slave, 0, 1);\n          break;\n\n        case 2:\n          MPI_Send(&C[offset][0], rows * 512, (MPI_Datatype) 0x4c00080b, id_slave, 0, 1);\n          break;\n\n        case 4:\n          MPI_Type_vector(512, 1, 512, (MPI_Datatype) 0x4c00080b, &dt_aux);\n          MPI_Type_create_resized(dt_aux, 0, sizeof(double), &dt_column);\n          MPI_Type_commit(&dt_column);\n          MPI_Send(&C[0][offset], rows, dt_column, id_slave, 0, 1);\n          break;\n\n      }\n\n      offset = offset + rows;\n    }\n\n    for (id_slave = 1; id_slave <= slaves; id_slave++)\n    {\n      MPI_Recv(&offset, 1, (MPI_Datatype) 0x4c000405, id_slave, 1, 1, &status);\n      MPI_Recv(&rows, 1, (MPI_Datatype) 0x4c000405, id_slave, 1, 1, &status);\n      switch (step)\n      {\n        case 1:\n\n        case 3:\n\n        case 5:\n          MPI_Recv(&C[offset][0], rows * 512, (MPI_Datatype) 0x4c00080b, id_slave, 1, 1, &status);\n          break;\n\n        case 2:\n          MPI_Recv(&W[offset], rows, (MPI_Datatype) 0x4c00080b, id_slave, 1, 1, &status);\n          break;\n\n        case 4:\n          MPI_Recv(&W[offset], rows, (MPI_Datatype) 0x4c00080b, id_slave, 1, 1, &status);\n          break;\n\n      }\n\n    }\n\n    if (0 == 1)\n      print_matrix(C, 512);\n\n    if (0 == 1)\n      print_vector(W, 512);\n\n    if ((test == 10) && (step == 5))\n    {\n      for (id_slave = 1; id_slave <= slaves; id_slave++)\n      {\n        step = 100;\n        MPI_Send(&step, 1, (MPI_Datatype) 0x4c000405, id_slave, 0, 1);\n      }\n\n    }\n\n    step++;\n    rows = 512 / slaves;\n    offset = 0;\n  }\n\n  time_final = MPI_Wtime();\n  if (0 == 1)\n    print_matrix(C, 512);\n\n  if (0 == 1)\n    print_vector(W, 512);\n\n  printf(\"\\nTime: %f\\n\\n\", time_final - time_init);\n  fprintf(f, \"%d,%d,%d,%d,%lf\\n\", test, 512, process_nro, threads_nro, time_final - time_init);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maturocha/multiplication-matrix/src/openmp_multiplication/7"}
{"code": "for (i = 0; i < (50000 - 1); i++)\n{\n  for (j = 0; j < 1; j++)\n  {\n    keys[GETPOS_1(0, j)] = i & 0xff;\n    keys[GETPOS_1(1, j)] = i >> 8;\n  }\n\n  SIMDSHA1body(keys, &keys32[SIMD_COEF_32], 0, SSEi_MIXED_IN | SSEi_OUTPUT_AS_INP_FMT);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/9"}
{"code": "for (i = 0; i < nsize; i++)\n{\n  C[i] = V[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaowei-su/ParallelGaussianElimination/gaussOPENMP/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (cout << v[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task8/1"}
{"code": "for (i = 1; i <= nx; i++)\n{\n  for (j = 1; j <= ny; j++)\n  {\n    Unew[i][j] = (U[i][j] + (((dt_max / 2) * ((U[i + 1][j] + U[i - 1][j]) - (2 * U[i][j]))) / (dx * dx))) + (((dt_max / 2) * ((U[i][j + 1] + U[i][j - 1]) - (2 * U[i][j]))) / (dy * dy));\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/ADI-OpenMP-example/Numerical Tests on Simple Systems/openmp version/baseline02/0"}
{"code": "for (int i = 0; i < filesCount; i++)\n{\n  FILE *f = fopen(fileFindings[i].fileName, \"rb\");\n  fseek(f, 0, 2);\n  long fsize = ftell(f);\n  fseek(f, 0, 0);\n  char *fileString = malloc(fsize + 1);\n  fread(fileString, fsize, 1, f);\n  kmp(T, keyWord, fileString, &fileFindings[i]);\n  fclose(f);\n  fileString[fsize] = 0;\n  free(fileString);\n}\n\n", "pragma": "omp parallel for default(none) shared(filesCount, fileFindings, T, keyWord)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcingolenia/KMP-using-C-and-OMP/main_omp/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (i <= 10)\n  {\n    if (histogram[i] > peak1)\n    {\n      peak1 = histogram[i];\n      i_peak1 = i;\n    }\n\n  }\n\n  if ((i >= 10) && (i <= 30))\n  {\n    if (histogram[i] > peak2)\n    {\n      peak2 = histogram[i];\n      i_peak2 = i;\n    }\n\n  }\n\n  if (i >= 30)\n  {\n    if (histogram[i] > peak3)\n    {\n      peak3 = histogram[i];\n      i_peak3 = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ALB/alb/3"}
{"code": "for (i = n; i >= 2; i--)\n{\n  l = i - 1;\n  h = (scale = 0.0);\n  if (l > 1)\n  {\n    for (k = 1; k <= l; k++)\n      scale += fabs(a(i - 1, k - 1).Val);\n\n    if (scale == 0.0)\n      e[i] = a(i - 1, l - 1);\n    else\n    {\n      for (k = 1; k <= l; k++)\n      {\n        a(i - 1, k - 1) /= scale;\n        h += a(i - 1, k - 1) * a(i - 1, k - 1);\n      }\n\n      f = a(i - 1, l - 1);\n      g = (f >= 0.0) ? (-sqrt(h)) : (sqrt(h));\n      EAssertR(_isnan(g) == 0, GetStr(h));\n      e[i] = scale * g;\n      h -= f * g;\n      a(i - 1, l - 1) = f - g;\n      f = 0.0;\n      for (j = 1; j <= l; j++)\n      {\n        a(j - 1, i - 1) = a(i - 1, j - 1) / h;\n        g = 0.0;\n        for (k = 1; k <= j; k++)\n          g += a(j - 1, k - 1) * a(i - 1, k - 1);\n\n        for (k = j + 1; k <= l; k++)\n          g += a(k - 1, j - 1) * a(i - 1, k - 1);\n\n        e[j] = g / h;\n        f += e[j] * a(i - 1, j - 1);\n      }\n\n      hh = f / (h + h);\n      for (j = 1; j <= l; j++)\n      {\n        f = a(i - 1, j - 1);\n        e[j] = (g = e[j] - (hh * f));\n        for (k = 1; k <= j; k++)\n        {\n          a(j - 1, k - 1) -= (f * e[k]) + (g * a(i - 1, k - 1));\n          EAssert(!a(j - 1, k - 1).IsNan());\n        }\n\n      }\n\n    }\n\n  }\n  else\n    e[i] = a(i - 1, l - 1);\n\n  d[i] = h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/60"}
{"code": "for (iPE = 0; iPE < nPEs; iPE++)\n  for (iter = 5; iter < NITER; iter++)\n{\n  *meanTime += times[iPE][iter];\n  *maxTime = ((*maxTime) > times[iPE][iter]) ? (*maxTime) : (times[iPE][iter]);\n  *minTime = ((*minTime) > times[iPE][iter]) ? (times[iPE][iter]) : (*minTime);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/15"}
{"code": "for (int MCURow = 0; MCURow < Y_S_F; ++MCURow)\n{\n  for (int MCUCol = 0; MCUCol < X_S_F; ++MCUCol)\n  {\n    LoadY(&MCU[MCURow][MCUCol], &input(Row, ((InputComponentsPerMCU * MCUIdx) + (X_S_F * MCURow)) + MCUCol));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/interpolators/Cr2sRawInterpolator/4"}
{"code": "for (int i = 0; i < (NUMNODES * NUMNODES); i++)\n{\n  int iu = i % NUMNODES;\n  int iv = i / NUMNODES;\n  if (((iv > 0) && (iv < (NUMNODES - 1))) && ((iu > 0) && (iu < (NUMNODES - 1))))\n  {\n    float tempHeight = Height(iu, iv);\n    float tempVolume = tempHeight * fullTileArea;\n    volume += tempVolume;\n  }\n  else\n  {\n    if (((((iv == 0) && (iu == 0)) || ((iv == 0) && (iu == (NUMNODES - 1)))) || ((iv == (NUMNODES - 1)) && (iu == 0))) || ((iv == (NUMNODES - 1)) && (iu == (NUMNODES - 1))))\n    {\n      float tempHeight = Height(iu, iv);\n      float tempVolume = tempHeight * (fullTileArea * QUATER_TILE_MULTIPLIER);\n      volume += tempVolume;\n    }\n    else\n    {\n      float tempHeight = Height(iu, iv);\n      float tempVolume = tempHeight * (fullTileArea * HALF_TILE_MULTIPLIER);\n      volume += tempVolume;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(fullTileArea) reduction(+:volume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/salazjos/openMP_2/openMPproject2/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  parallel_merge_sort1(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting(optimized) of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/4"}
{"code": "for (row = xoffset + 1; row < ((xoffset + myxsize) + 1); row++)\n{\n  MPI_Send(&u[old][row][yoffset + 1], 1, row_type, dest, msgtype, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/4"}
{"code": "for (int i = 0; i < q; i++)\n{\n  for (int j = 0; j < t; j++)\n  {\n    if (j == 0)\n    {\n      int observation = Y[0];\n      dp1[i][0] = I[i] + B[i][observation];\n      dp2[i][0] = 0;\n    }\n    else\n    {\n      dp1[i][j] = get_rand_float(min_prob, max_prob);\n      dp2[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_openmp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = rand() % 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/ArrayNumbersBorders/2"}
{"code": "for (int i = 0; i < NUM_GREY; i++)\n{\n  omp_init_lock(&lock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/histogram/histogram/0"}
{"code": "for (int i = 0; i < cont_cnt; i++)\n{\n  if (i != docker_host_name)\n    topo[(i * cont_cnt) + i] = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apollo12221/Parallel-AG-Gen-Docker/c_bfs/0"}
{"code": "for (i = 0; i < num_runs; i++)\n{\n  axpy_omp_parallel_for(N, Y_parallel, X, a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/omptrace/examples/axpy/1"}
{"code": "for (int i = 0; i < fil; i++)\n{\n  free(matris[i]);\n  free(matris2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nachoLedesma1/openMP2/openMPLedesmaIgnacio/5"}
{"code": "for (int i = 0; i < centers.size(); i++)\n{\n  for (int j = i; j < centers.size(); j++)\n  {\n    intercluster_distance += pairwise_distance(centers[i], centers[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par3/3"}
{"code": "for (int i = 0; i < numOfNodes; ++i)\n{\n  int u = nodes[i];\n  int degree = A->rowptr[u + 1] - A->rowptr[u];\n  if (degree < temp_min)\n  {\n    temp_min = degree;\n    temp_min_idx = u;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/10"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < 5; j++)\n  {\n    printf(\"%lf \", data[(i * size) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA1/stencil_2D/3"}
{"code": "for (uint16_t i = 0; i < n_groups; ++i)\n{\n  for (uint32_t j = 0; j < n_obs; ++j)\n  {\n    newnorm += (exp(gamma_Z(i, j)) * (dL_dphi(i, j) - colsums[j])) * dL_dphi(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) reduction(+:newnorm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/rcg/5"}
{"code": "for (int j = 0; j < 5000; j++)\n{\n  c[j] = j + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adityakaria/5-Sem/pc/lab2/q1/no-wait/3"}
{"code": "for (int i = 0; i < length; i++)\n  printf(\"%f\\n\", *(ptr0 + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/4"}
{"code": "for (row = 1; row < (NRows + 1); row++)\n{\n  for (col = 1; col < (NCols + 1); col++)\n  {\n    Trees[(row * NColsPlusBounds) + col] = NewTrees[((row - 1) * NCols) + (col - 1)];\n  }\n\n}\n\n", "pragma": "omp parallel for private(col)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/fire/3"}
{"code": "for (int i = 0; i < size; ++i)\n  avg += data[i];\n\n", "pragma": "omp parallel for reduction(+:avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KlausDornsbach/OpenMP/atividade_7/exercicio_3/main/0"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n  for (k = 0; k < ((250 * 1024) / 256); k++)\n  C[(i * ((250 * 1024) / 256)) + k] = ((-((float) ((250 * 1024) / 256))) * M) * ((250 * 1024) / 256);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/6"}
{"code": "for (j = 0; j < count; j++)\n{\n  for (i = 0; i < rows; i++)\n    data2[i][j] = data[j][i];\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/3"}
{"code": "for (i = 0; i < DIM; i++)\n  if (mins_seq[i] > max_of_mins_seq)\n{\n  {\n    max_of_mins_seq = mins_seq[i];\n  }\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/min_max_matrix_element/6"}
{"code": "for (i = 0; i < N; i++)\n  tar[i] = rand() % 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaoziyu/Parallel-Programming/OpenMP/omp_mat_vect_mult/3"}
{"code": "for (int i = 63; i >= 0; i--)\n{\n  if (n & (1ULL << i))\n    printf(\"1\");\n  else\n    printf(\"0\");\n\n  if ((i % 4) == 0)\n    printf(\" \");\n\n  if ((i % 8) == 0)\n    printf(\"| \");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/utils/4"}
{"code": "for (i = 0; i < cs.store_data_length; i++)\n  cs.store_data[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/bks_fmt_plug/1"}
{"code": "for (h = 0; h < size2; h++)\n{\n  if (h != k)\n  {\n    float mulPosX = posx[h] - posx[k];\n    float mulPosY = posy[h] - posy[k];\n    float mulPosZ = posz[h] - posz[k];\n    float d = sqrtf(((mulPosX * mulPosX) + (mulPosY * mulPosY)) + (mulPosZ * mulPosZ));\n    if (d < 1.0)\n      d = 1.0;\n\n    float l = (masse[h] * M) * (1 / ((d * d) * d));\n    accelx[k] += mulPosX * l;\n    accely[k] += mulPosY * l;\n    accelz[k] += mulPosZ * l;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/2"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (TYPE) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    if (i != j)\n      xnew[i] += A[(i * Ndim) + j] * xold[j];\n\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_par_dat_reg/0"}
{"code": "for (int j = 0; j < y; j++)\n{\n  int sum = 0;\n  for (int i = 0; i < x; i++)\n  {\n    sum += Mat[i][j];\n  }\n\n  Mat[j][j] += sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thesaurabhkumar/ParallelInverseUpperTriangleMatrixOpenMP/inverse/9"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  mean = (mean + w[i][0]) + w[i][N - 1];\n}\n\n", "pragma": "omp for reduction ( + : mean )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhin-kakkad/SteadyStateHeatEquation/Project_parallel/4"}
{"code": "for (uint i = 0; i < ktot; ++i)\n{\n  double rhoDeltaIJ_2 = (2.0 * ((double) kCount[i])) * currentAxes.volInv[box];\n  uint index = (kind * ktot) + i;\n  tcDiff += ((lambdaNew - lambdaOld) * mols.pairEnCorrections[index]) * rhoDeltaIJ_2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/26"}
{"code": "for (i = 1; i < size; i++)\n{\n  if (!(a[i - 1] <= a[i]))\n  {\n    printf(\"Error: final array not sorted => a[%d]=%d > a[%d]=%d\\n\", i - 1, a[i - 1], i, a[i]);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IvanFekete/mergesort-paralell/tasks-mergesort/omp_mergesort/3"}
{"code": "for (i = 0; i < ncolors; i++)\n{\n  smats[i]->rowind = gk_imalloc(smats[i]->rowptr[nrows], \"gk_csr_Split: smats[i]->rowind\");\n  smats[i]->rowval = gk_fmalloc(smats[i]->rowptr[nrows], \"gk_csr_Split: smats[i]->rowval\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/26"}
{"code": "for (int u = Ap[i]; u < Ap[i + 1]; u++)\n  if (i == Aj[u])\n  d[i] += Ax[u];\n\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/11"}
{"code": "for (long i = 0; i < numUniqueClusters; i++)\n{\n  omp_destroy_lock(&nlocks[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/5"}
{"code": "for (i = 1; i < (numOfRows - 1); i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a = adjacent_to(board, i, j, numOfRows, N);\n    if (a == 2)\n      NewBoard(i, j) = Board(i, j);\n\n    if (a == 3)\n      NewBoard(i, j) = 1;\n\n    if (a < 2)\n      NewBoard(i, j) = 0;\n\n    if (a > 3)\n      NewBoard(i, j) = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i,j,a) shared(newboard,board,N)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/GameOfLife_game/src/src/play/0"}
{"code": "for (unsigned long long it = 2000; it >= 600; it -= 400)\n{\n  aa += 1;\n}\n\n", "pragma": "  #pragma omp target parallel for if(target: 1) linear(lin, a : get_val()) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/2"}
{"code": "for (c3 = max(0, ((-N) + c1) + 1); c3 <= ((c1 - 1) / 17); c3 += 1)\n  for (c4 = 0; c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    for (c5 = 0; c5 <= c3; c5 += 1)\n      for (c9 = (N - c1) + (17 * c3); c9 <= min(N - 1, ((N - c1) + (17 * c3)) + 15); c9 += 1)\n    {\n      if ((c5 == c3) && ((c1 + c9) >= ((N + (17 * c3)) + 1)))\n        Q[((N - c1) + c3) - 1][c9] = Q[((N - c1) + c3) - 1][c9 - 1];\n\n      if ((c5 == c3) && ((c1 + c9) >= ((N + (17 * c3)) + 1)))\n        for (c11 = 0; c11 < (16 * c3); c11 += 1)\n        Q[((N - c1) + c3) - 1][c9] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][c9];\n\n\n      for (c11 = 16 * c5; c11 <= min((16 * c5) + 15, (((-N) + c1) - c3) + c9); c11 += 1)\n      {\n        Qbp[c11 + (((N - c1) + c3) - 1)][c9] = (Q[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1] * ERT) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n        if (c5 == c3)\n        {\n          Q[((N - c1) + c3) - 1][c9] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][c9];\n        }\n        else\n          if ((c1 + c9) == (N + (17 * c3)))\n        {\n          Q[((N - c1) + c3) - 1][(N - c1) + (17 * c3)] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][(N - c1) + (17 * c3)];\n        }\n\n\n      }\n\n    }\n\n\n  }\n  else\n  {\n    Q[((N - c1) + c3) - 1][(N - c1) + (17 * c3)] = Q[((N - c1) + c3) - 1][((N - c1) + (17 * c3)) - 1];\n  }\n\n}\n\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/mcc/mcc_dapt/3"}
{"code": "for (i = 0; i < (DIM - 1); i++)\n{\n  tmp += super[i] * simple[i];\n  moving_average = 0;\n  for (ton = i; ton < ((DIM - 1) - WINDOW_SIZE); ton++)\n  {\n    moving_average += simple[ton];\n  }\n\n}\n\n", "pragma": "omp for lastprivate(i, moving_average)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/exojosh/OpenMP-Parallel-Threading-Practice/parallel/1"}
{"code": "for (unsigned int i = 0; i < travel.flights.size(); i++)\n  if ((travel.flights[i].from == city) || (travel.flights[i].to == city))\n  return false;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoLR548/CPguacamole/Tarefa12/main/6"}
{"code": "for (m = 0; m < 5; m++)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,iend1 ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/21"}
{"code": "for (i = 0; i < size; i++)\n{\n  result = result + (v1[i] * v2[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(v1, v2, size) private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/1"}
{"code": "for (i = 0; i <= (2048 + 1); i++)\n{\n  T[i][0] = 0.0;\n  T[i][2048 + 1] = (128.0 / 2048) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    printf(\"%d\\t\", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/mul_omp_q6/6"}
{"code": "for (step = 1; step <= step_num; step++)\n{\n  compute(np, nd, pos, vel, mass, force, &potential, &kinetic);\n  if (step == step_print)\n  {\n    ((((((((((((cout << \"  \") << setw(8)) << step) << \"  \") << setw(14)) << potential) << \"  \") << setw(14)) << kinetic) << \"  \") << setw(14)) << (((potential + kinetic) - e0) / e0)) << \"\\n\";\n    step_print_index = step_print_index + 1;\n    step_print = (step_print_index * step_num) / step_print_num;\n  }\n\n  update(np, nd, pos, vel, force, acc, mass, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/md/1"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  data[i] = this->vec_[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/2"}
{"code": "for (int i = 0; i < 20; ++i)\n  for (int j = 0; j < 10; ++j)\n  mat[i][j] = (j * 20) + i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_07/3"}
{"code": "for (int i = 0; i < 256; i++)\n  if (a[i] != (((((i & 3) == 0) && (i >= 8)) && (i < (8 + (48 * 4)))) ? (((i - 8) / 4) + 16) : (0)))\n  __builtin_abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/linear-1/6"}
{"code": "for (c3 = (0 > (((-N) + c1) + 1)) ? (0) : (((-N) + c1) + 1); c3 <= ((c1 - 1) / 129); c3 += 1)\n  for (c4 = 0; c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c10 = (0 > (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1)) ? (0) : (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1); c10 <= 1; c10 += 1)\n    {\n      if (c10 == 1)\n      {\n        M[((N - c1) + c3) - 1][c9] = (M[((N - c1) + c3) - 1][c9] > (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1])) ? (M[((N - c1) + c3) - 1][c9]) : (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1]);\n      }\n      else\n      {\n        for (c11 = (128 * c3) + 2; c11 <= ((((-N) + c1) - c3) + c9); c11 += 1)\n          M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n      }\n\n    }\n\n\n  }\n  else\n  {\n    for (c5 = 0; c5 <= (8 * c3); c5 += 1)\n      for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c11 = 16 * c5; c11 <= ((((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) < ((((-N) + c1) - c3) + c9)) ? ((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) : ((((-N) + c1) - c3) + c9)); c11 += 1)\n      M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mea_traco/2"}
{"code": "for (int i = 0; i < t; i++)\n{\n  printf(\"%d \", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E2/sieve/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    printf(\"%.2f\\t\", a[(i * cols) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EliseuPHP/PAD/OpenMP/src/exerc/4"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= k; j++)\n  {\n    filename = malloc(20 * (sizeof(char)));\n    sprintf(filename, \"images/%d.%d.txt\", i, j);\n    training_sets[idx] = read_pgm_file(filename, rows, cols);\n    idx++;\n    free(filename);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gulsumgudukbay/Parallel-P3-FaceRecognition/FaceDetection/src/lbp_omp/10"}
{"code": "for (size_t i = 0; i < num_rows; ++i)\n{\n  double h = 0.0;\n  for (size_t k = 0; k < rows[i].size(); k++)\n  {\n    double h_i = (num_outgoing[rows[i][k]]) ? (1.0 / num_outgoing[rows[i][k]]) : (0.0);\n    h += h_i * old_pr[rows[i][k]];\n  }\n\n  h *= alpha;\n  pr[i] = (h + one_A) + one_I;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/pagerank/src/omp_pagerank_v1/5"}
{"code": "for (cell = hyp.cell + 1; cell < v_size; cell++)\n{\n  if (cp_sudoku[cell])\n    continue;\n\n  for (val = m_size; val >= 1; val--)\n  {\n    if (is_safe_num(rows_mask, cols_mask, boxes_mask, cell / m_size, cell % m_size, val))\n    {\n      if (cell == last_pos)\n      {\n        cp_sudoku[cell] = val;\n        send_ring(&id, 2, -1);\n        return 1;\n      }\n\n      hyp.cell = cell;\n      hyp.num = val;\n      insert_head(work, hyp);\n    }\n\n  }\n\n  break;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/5"}
{"code": "for (int n = halfSize; n < (height - halfSize); ++n)\n{\n  float neighbors_dist[k];\n  int neighbors_prev[k];\n  int neighbors_next[k];\n  int head;\n  int tail;\n  float neighbors_max;\n  for (int m = halfSize; m < (width - halfSize); ++m)\n  {\n    if (imgIn[m + (n * width)] != 0.f)\n    {\n      for (int i = 0; i < k; i++)\n      {\n        neighbors_dist[i] = INF;\n        neighbors_next[i] = i + 1;\n        neighbors_prev[i] = i - 1;\n      }\n\n      head = 0;\n      tail = k - 1;\n      neighbors_max = INF;\n      const float center_depth = imgIn[m + (n * width)];\n      const float depth_squared = center_depth * center_depth;\n      const float width_per_pixel = fast_sqrt((2 * depth_squared) * reverse_cos_angle_width_per_pixel);\n      const float height_per_pixel = fast_sqrt((2 * depth_squared) * reverse_cos_angle_height_per_pixel);\n      float distance;\n      for (int x = 0; x < kernelSize; ++x)\n      {\n        for (int y = 0; y < kernelSize; ++y)\n        {\n          distance = (fabs(imgIn[((m - halfSize) + x) + (((n - halfSize) + y) * width)] - center_depth) + (width_per_pixel * abs(x - halfSize))) + (height_per_pixel * abs(y - halfSize));\n          if ((distance != 0.f) && (distance < neighbors_max))\n          {\n            neighbors_dist[tail] = distance;\n            int i = head;\n            while (distance > neighbors_dist[i])\n              i = neighbors_next[i];\n\n            if (i == head)\n            {\n              neighbors_next[tail] = head;\n              neighbors_prev[head] = tail;\n              head = tail;\n              tail = neighbors_prev[tail];\n              neighbors_next[neighbors_prev[head]] = k;\n              neighbors_prev[head] = -1;\n            }\n            else\n              if (i != tail)\n            {\n              int tmp_tail = tail;\n              neighbors_next[neighbors_prev[tail]] = k;\n              neighbors_next[tail] = i;\n              neighbors_next[neighbors_prev[i]] = tail;\n              tail = neighbors_prev[tail];\n              neighbors_prev[tmp_tail] = neighbors_prev[i];\n              neighbors_prev[i] = tmp_tail;\n            }\n\n\n            neighbors_max = neighbors_dist[tail];\n          }\n\n        }\n\n      }\n\n      float k_sum = 0.f;\n      for (int i = 0; i < k; ++i)\n        k_sum += neighbors_dist[i];\n\n      if ((k_sum / k) > distance_thr)\n      {\n        counter++;\n        imgOut[m + (n * width)] = 0.f;\n      }\n      else\n        imgOut[m + (n * width)] = imgIn[m + (n * width)];\n\n    }\n    else\n      imgOut[m + (n * width)] = 0.f;\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:counter)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josehu07/CA-KNNFloatImgOMP/KNNFloatImg_original/0"}
{"code": "for (int i = 0; i < count; ++i)\n  a[i] = rand() % count;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kang235/OpenMP/MergeSort/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    xvel = us[i][j][k];\n    yvel = vs[i][j][k];\n    zvel = ws[i][j][k];\n    ac = speed[i][j][k];\n    acinv = ainv[i][j][k];\n    ac2u = ac * ac;\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    uzik1 = u[0][i][j][k];\n    btuz = bt * uzik1;\n    t1 = (btuz * acinv) * (r4 + r5);\n    t2 = r3 + t1;\n    t3 = btuz * (r4 - r5);\n    rhs[0][i][j][k] = t2;\n    rhs[1][i][j][k] = ((-uzik1) * r2) + (xvel * t2);\n    rhs[2][i][j][k] = (uzik1 * r1) + (yvel * t2);\n    rhs[3][i][j][k] = (zvel * t2) + t3;\n    rhs[4][i][j][k] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[i][j][k] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,xvel ,yvel ,zvel ,ac ,acinv ,r1 ,r2 ,r3 ,r4 ,r5 ,uzik1 ,btuz ,t1 ,t2 ,t3 ,bt ,c2iv ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/158"}
{"code": "for (int i = 2; i < pow_max; ++i)\n{\n  n_stop *= 4;\n  printf(\" %16llu,% 3.16e,%3.16e,%3.16e \\n\", n_stop, approx_integral[i], fabs(approx_integral[i] - approx_integral[i + 1]), fabs(approx_integral[i] - 0.0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p1c/2"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = malloc(sizeof(payload));\n  data->leader = kvals[i];\n  data->default_leader = kvals[i];\n  data->committee = g->N + 1;\n  data->min_active = g->N + 1;\n  data->invite = default_invite;\n  cur->data = data;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/6"}
{"code": "for (i = 0; i < numEdges; ++i)\n{\n  key = edges[i].src;\n  vertex_cnt[key]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iMeanHow/OpenMP/Radix/src/sort/1"}
{"code": "for (int y = 1; y < (rows - 1); y++)\n{\n  for (int x = 1; x < (columns - 1); x++)\n  {\n    cell = grid[y][x];\n    nliving = countNeighbors(grid, y, x);\n    newCell = &newGrid[y][x];\n    if ((nliving == 3) || ((nliving == 2) && (cell == '#')))\n      *newCell = '#';\n    else\n      *newCell = '.';\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp/0"}
{"code": "for (int i = 0; i < numSlice; i++)\n{\n  float max_ = input[i * sliceSize];\n  for (int j = 0; j < sliceSize; j++)\n  {\n    max_ = (max_ < input[(i * sliceSize) + j]) ? (input[(i * sliceSize) + j]) : (max_);\n  }\n\n  float sum = 0;\n  for (int j = 0; j < sliceSize; j++)\n  {\n    sum += expf(input[(i * sliceSize) + j] - max_);\n  }\n\n  for (int j = 0; j < sliceSize; j++)\n  {\n    output_gpu[(i * sliceSize) + j] = expf(input[(i * sliceSize) + j] - max_) / sum;\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for simd thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/softmax-omp/main/2"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  memcpy(saved_key[index] + saved_len[index], cursalt, 4);\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_key[index], saved_len[index] + 4);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mssql12_fmt_plug/5"}
{"code": "for (int i = 1; i < (1000000 / 5000); i++)\n{\n  B_nz_blocks_ptr[i] = B_nz_blocks_ptr[i - 1] + B_nz_blocks_per_col[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  cluster[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lineu96/relatorio_openmp/arquivos/02_kmeans/kmeans_paralelo/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  int ij = i ^ j;\n  if (ij > i)\n  {\n    if (((i & k) == 0) && (arr[i] > arr[ij]))\n      swap(&arr[i], &arr[ij]);\n\n    if (((i & k) != 0) && (arr[i] < arr[ij]))\n      swap(&arr[i], &arr[ij]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) shared(k, j, n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/turfaa/bitonic-sort-openmp/src/bitonic_sort/0"}
{"code": "for (int i = 0; i < frame_.height(); ++i)\n  for (int j = 0; j < frame_.width(); ++j)\n  frame_.setPixelColor(j, i, evaluateColorForPoint(j, i));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DenDunno/MandelbrotSet/MandelbrotSet/mandelbrotsetframe/0"}
{"code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  n = n / mx;\n  m = part[1 + (idimp * j)];\n  m = m / my;\n  l = part[2 + (idimp * j)];\n  l = l / mz;\n  m = (n + (mx1 * m)) + (mxy1 * l);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      kp[ip + (nppmx * m)] = j;\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/49"}
{"code": "for (i = (end - mid) - 1; i >= 0; i--)\n{\n  if ((j > begin) && ((globC[j] > globC[k]) || (k <= mid)))\n  {\n    top[i] = globC[j];\n    j--;\n  }\n  else\n  {\n    top[i] = globC[k];\n    k--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/7"}
{"code": "for (row = 0; row < 1024; row++)\n  for (col = 0; col < 1024; col++)\n  A[(row * 1024) + col] = rand();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Indrasish117/Parallel-Matrix-multiplication-in-C-using-OpenMP/MatrixMul/0"}
{"code": "for (size_t i = 0; i < loop; ++i)\n{\n  loadSimdData(rData, blocks, blockBound, 2, halfArrayLen);\n  bitonicSort16232(rData);\n  storeData(output, rData, halfArrayLen);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/9"}
{"code": "for (reg0 = 0; reg0 < 10; reg0 += 1)\n  c[reg0] = a[reg0];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/41"}
{"code": "for (j = 2; j <= (nrows + 1); j += 1)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/23"}
{"code": "for (long pidx_darts_counter_temp1284 = *pidx; (pidx_darts_counter_temp1284 < endRange) && (pidx_darts_counter_temp1284 < this->inputsTPParent->lastIteration1284); pidx_darts_counter_temp1284++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1284], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/52"}
{"code": "for (i = 0; i < (num_rows * num_vectors); i++)\n  y_data[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/1"}
{"code": "for (int j = 0; j < threads_cnt; ++j)\n{\n  ret[j] = transform_function(test_input);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/gtests/transforms_test/4"}
{"code": "for (int j = 0; j < 50; j++)\n{\n  printf(\"%u \", C[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MiloVahos/PruebasOMP/parallelfor/5"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (arr[i] > max)\n  {\n    max = arr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/atomic/test_atomic_compare/1"}
{"code": "for (int i = 0; i < GRAIN; i++)\n{\n  for (int j = 0; j < GRAIN; j++)\n  {\n    current_array[(i * GRAIN) + j] = 1;\n    next_array[(i * GRAIN) + j] = 0;\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < np; j++)\n  {\n    flag = 0;\n    atual = particulas[i];\n    parede_horizontal = checkParedeLados(atual.posicao, n);\n    if ((atual.direcao == indo_esquerda) && (parede_horizontal == 0))\n    {\n      atual.direcao == indo_direita;\n    }\n    else\n      if ((atual.direcao == indo_direita) && (parede_horizontal == (n - 1)))\n    {\n      atual.direcao == indo_esquerda;\n    }\n    else\n      if ((atual.direcao == indo_cima) && (atual.posicao < n))\n    {\n      atual.direcao == indo_baixo;\n    }\n    else\n      if ((atual.direcao == indo_baixo) && (atual.posicao > (((n * n) - n) - 1)))\n    {\n      atual.direcao == indo_cima;\n    }\n    else\n    {\n      for (k = 0; k < np; k++)\n      {\n        if ((atual.posicao == particulas[k].posicao) && (atual.id != particulas[k].id))\n        {\n          if (atual.direcao == indo_esquerda)\n          {\n            flag = 1;\n            particulas[k].direcao == indo_direita;\n            if (atual.posicao > (n - 1))\n            {\n              atual.posicao = atual.posicao - n;\n              atual.direcao = indo_cima;\n            }\n            else\n            {\n              atual.direcao = indo_baixo;\n            }\n\n          }\n          else\n            if (atual.direcao == indo_direita)\n          {\n            flag = 1;\n            particulas[k].direcao == indo_esquerda;\n            if (atual.posicao < ((n * n) - n))\n            {\n              atual.posicao = atual.posicao + n;\n              atual.direcao = indo_baixo;\n            }\n            else\n            {\n              atual.direcao = indo_cima;\n            }\n\n          }\n          else\n            if (atual.direcao == indo_cima)\n          {\n            particulas[k].direcao == indo_baixo;\n            if (parede_horizontal < (n - 1))\n            {\n              atual.posicao = atual.posicao + 1;\n              atual.direcao = indo_direita;\n            }\n            else\n            {\n              atual.direcao = indo_esquerda;\n            }\n\n          }\n          else\n            if (atual.direcao == indo_baixo)\n          {\n            particulas[k].direcao == indo_cima;\n            if (parede_horizontal != 0)\n            {\n              atual.posicao = atual.posicao + 1;\n              atual.direcao = indo_esquerda;\n            }\n            else\n            {\n              atual.direcao = indo_direita;\n            }\n\n          }\n\n\n\n\n        }\n\n      }\n\n    }\n\n\n\n\n    if (flag == 0)\n    {\n      if ((atual.direcao == indo_esquerda) && (parede_horizontal > 0))\n      {\n        atual.posicao = atual.posicao - 1;\n      }\n      else\n        if ((atual.direcao == indo_direita) && (parede_horizontal < (n - 1)))\n      {\n        atual.posicao = atual.posicao + 1;\n      }\n      else\n        if ((atual.direcao == indo_cima) && (atual.posicao > (n - 1)))\n      {\n        atual.posicao = atual.posicao - n;\n      }\n      else\n        if ((atual.direcao == indo_baixo) && (atual.posicao <= ((n * n) - n)))\n      {\n        atual.posicao = atual.posicao + n;\n      }\n\n\n\n\n    }\n\n    next[i].posicao = atual.posicao;\n    next[i].direcao = atual.direcao;\n    next[i].id = atual.id;\n  }\n\n  particulas = copia_particulas_para_next(particulas, next, n);\n}\n\n", "pragma": "omp parallel for private(j, k, parede_horizontal, parede_vertical, atual, flag)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JonatasDelatorre/Modelo_HPP_OpenMP/trabalhoHPP/0"}
{"code": "for (i = 0; i < 20000000; i++)\n{\n  a[i] = 1.0;\n  b[i] = 2.0;\n  c[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/0"}
{"code": "for (int i = 0; i <= end; i++)\n{\n  int index = i + lower_bound(array, mid + 1, high + 1, array[i + base]);\n  aux[index + low] = array[i + base];\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Mergesort_Serial_Parallel/0"}
{"code": "for (int i = 0; i < mod; ++i)\n{\n  scores[cur_alignment + i] = score_overflow[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-neumann/versalignLib/src/Kernels/AVX-SSE/SSEKernel/2"}
{"code": "for (j = 0; j < dataSet.p; j++)\n{\n  sum = 0;\n  for (k = 0; k < dataSet.m; k++)\n  {\n    sum += dataSet.A[(i * dataSet.m) + k] * dataSet.B[(k * dataSet.p) + j];\n  }\n\n  dataSet.C[(i * dataSet.p) + j] = sum;\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 200)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/Parallax/docs/assignment-2/matrix-multiplication/matmul/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (points[i].cluster == cluster)\n  {\n    (output << points[i].x) << \" \";\n    (output << points[i].y) << endl;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilvitto/KMeans/ParallelKMeans/4"}
{"code": "for (i = 0; i < K; i++)\n{\n  members[i] = 0;\n  newMean[i]._r = 0;\n  newMean[i]._g = 0;\n  newMean[i]._b = 0;\n  newMean[i]._m = 0;\n  newMean[i]._n = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Projects/PC-Project/parallel code/kmean_omp/5"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    if (j != i)\n    {\n      ratio = mat_aug(j, i) / mat_aug(i, i);\n      for (int k = 0; k < (2 * _cols); k++)\n      {\n        mat_aug(j, k) -= mat_aug(i, k) * ratio;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/14"}
{"code": "for (i = 0; i < nvtxs; i++)\n{\n  gk_i32pqInsert(queue, i, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/9"}
{"code": "for (int k = 0; k < N; ++k)\n{\n  x = a + (((k - 0.5) * (b - a)) / N);\n  sum += sqrt(1 - pow(x, 2));\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, 10000) reduction(+:sum)     ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/OpenMP/pi_computation/pi_omp_d/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 23) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    INT_TYPE test_rank = test_rank_array[i];\n    int failed = 0;\n    switch (CLASS)\n    {\n      case 'S':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'W':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n        test_rank += iteration - 1;\n      else\n        test_rank -= iteration - 1;\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'D':\n        if (i < 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'E':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        if (i == 2)\n      {\n        test_rank += iteration - 2;\n        if (iteration > 4)\n          test_rank -= 2;\n        else\n          if (iteration > 2)\n          test_rank -= 1;\n\n\n      }\n      else\n        test_rank -= iteration - 2;\n\n\n        break;\n\n    }\n\n    if (key_rank != test_rank)\n      failed = 1;\n    else\n      passed_verification++;\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/20"}
{"code": "for (i = 0; i < size; i++)\n{\n  total += c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/matrix_sum_omp/4"}
{"code": "for (int n = 0; n < rows; n++)\n  wall[n] = data + (cols * n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/pathfinder/pathfinder/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    if (i == j)\n    {\n      arr[(size * i) + j] = 1;\n    }\n    else\n    {\n      arr[(size * i) + j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(8) private(j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/2"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    B[i][j] = A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab6_OpenMP/macropipelinev2/3"}
{"code": "for (int i = 0; i < num_points; i++)\n{\n  (((((outfile << points[i].get_x()) << \" \") << points[i].get_y()) << \" \") << points[i].get_cluster()) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/A7F/aca-kmeans/parallel/3"}
{"code": "for (i = 0; i < rows; i++)\n{\n  if (i == (rows - 1))\n    printf(\"%.2f ] \\n\", mean[i]);\n  else\n    printf(\"%.2f , \", mean[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/7"}
{"code": "for (int k = 0; k < offsprings.size(); ++k)\n{\n  for (int i = 0; i < cities_cnt; ++i)\n  {\n    int random = rand() % 10000;\n    float rand_val = random / 10000.0;\n    if (rand_val < mutation_rate)\n    {\n      int j = rand() % cities_cnt;\n      swap(offsprings[k].cities[i], offsprings[k].cities[j]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/4"}
{"code": "for (i = 0; i <= n; i++)\n{\n  dp[i][i] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel6/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/70"}
{"code": "for (i = 0; i <= (10 - 1); i++)\n{\n  double _imopVarPre353;\n  _imopVarPre353 = q[i];\n  printf(\"%3d %15.0f\\n\", i, _imopVarPre353);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/EP/ep/4"}
{"code": "for (int i = 0; i < 10; i++)\n  CalculateInitialMaxIndentations(r_process_info);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/0"}
{"code": "for (i = 1; i < (procCoords.x_cells_num - 1); i++)\n{\n  delta_f[(j * procCoords.x_cells_num) + i] = (((f[(j * procCoords.x_cells_num) + i] - f[((j * procCoords.x_cells_num) + i) - 1]) - (f[((j * procCoords.x_cells_num) + i) + 1] - f[(j * procCoords.x_cells_num) + i])) / hx2) + (((f[(j * procCoords.x_cells_num) + i] - recv_message_td[i]) - (f[((j + 1) * procCoords.x_cells_num) + i] - f[(j * procCoords.x_cells_num) + i])) / hy2);\n}\n\n", "pragma": "                #pragma omp for schedule (static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    m[(i * n) + j] = rand() / 10.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/mm/main/3"}
{"code": "for (int y = 0; y < Ly; y++)\n  for (int x = 1; x < ((Lx / 4) - 1); x++)\n{\n  int lx = Lx / 4;\n  int v00 = x + (y * lx);\n  int v0p = v00 + 1;\n  int v0m = v00 - 1;\n  int vp0 = x + (((y + 1) % Ly) * lx);\n  int vm0 = x + (((Ly + (y - 1)) % Ly) * lx);\n  int in00 = _mm_load_ps(&in[v00].site4[0]);\n  int in0p = _mm_load_ps(&in[v0p].site4[0]);\n  int in0m = _mm_load_ps(&in[v0m].site4[0]);\n  int inp0 = _mm_load_ps(&in[vp0].site4[0]);\n  int inm0 = _mm_load_ps(&in[vm0].site4[0]);\n  int hop = _mm_add_ps(inm0, inp0);\n  hop = _mm_add_ps(hop, in0p);\n  hop = _mm_add_ps(hop, in0m);\n  hop = _mm_mul_ps(hop, vdelta);\n  int dia = _mm_mul_ps(vnorm, in00);\n  hop = _mm_add_ps(dia, hop);\n  _mm_store_ps(&out[v00].site4[0], hop);\n}\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/heat2d-sycl/lapl_ss/0"}
{"code": "for (int i = 0; i < n; i++)\n  if (i != startnode)\n{\n  printf(\"\\nDistance of node%d=%d\", i, distance[i]);\n  printf(\"\\nPath=%d\", i);\n  int j = i;\n  do\n  {\n    j = predecessor[j];\n    printf(\"<-%d\", j);\n  }\n  while (j != startnode);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Akash01010/Dijkstra_OpenMP/dijkstra/7"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  int thread = omp_get_thread_num();\n  bucket = ((double) tab[i]) / bucketSize;\n  if (bucket == count)\n    bucket--;\n\n  struct node *tmp = (struct node *) malloc(sizeof(struct node));\n  tmp->val = tab[i];\n  tmp->next = buckets[bucket + (thread * count)];\n  buckets[bucket + (thread * count)] = tmp;\n}\n\n", "pragma": "omp for private(bucket)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/mainB/1"}
{"code": "for (checksum = 0.0, j = 0; j < order; j++)\n  for (i = 0; i < order; i++)\n  checksum += C[i + (order * j)];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/DGEMM/dgemm/3"}
{"code": "for (i = 0; i < count; i++)\n{\n  sa[0] += (a[i].x * a[i].x) + (a[i].y * a[i].y);\n  sa[1] += 0;\n  sa[2] += a[i].x;\n  sa[3] += a[i].y;\n  sa[4] += 0;\n  sa[5] += (a[i].x * a[i].x) + (a[i].y * a[i].y);\n  sa[6] += -a[i].y;\n  sa[7] += a[i].x;\n  sa[8] += a[i].x;\n  sa[9] += -a[i].y;\n  sa[10] += 1;\n  sa[11] += 0;\n  sa[12] += a[i].y;\n  sa[13] += a[i].x;\n  sa[14] += 0;\n  sa[15] += 1;\n  sb[0] += (a[i].x * b[i].x) + (a[i].y * b[i].y);\n  sb[1] += (a[i].x * b[i].y) - (a[i].y * b[i].x);\n  sb[2] += b[i].x;\n  sb[3] += b[i].y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/7"}
{"code": "for (i = 0; i < MatrixDim; i++)\n{\n  for (j = 0; j < MatrixDim; j++)\n  {\n    if (i == j)\n    {\n      L[(i * MatrixDim) + j] = 1.0;\n      U[(i * MatrixDim) + j] = ((FP_NUMBER) rand()) / (((FP_NUMBER) 32767) + ((FP_NUMBER) 1));\n    }\n    else\n      if (i < j)\n    {\n      L[(i * MatrixDim) + j] = 0;\n      U[(i * MatrixDim) + j] = ((FP_NUMBER) rand()) / (((FP_NUMBER) 32767) + ((FP_NUMBER) 1));\n    }\n    else\n    {\n      L[(i * MatrixDim) + j] = ((FP_NUMBER) rand()) / (((FP_NUMBER) 32767) + ((FP_NUMBER) 1));\n      U[(i * MatrixDim) + j] = 0;\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i,j) shared(L,U,MatrixDim)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/lud/tools/gen_input.ref/0"}
{"code": "for (j = 0; (DIM < 1) && (j < ND); j++)\n  if (SZ[j] > 1)\n  DIM = j + 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/sumskipnan_mex/0"}
{"code": "for (int i = 0; i < in.n_isotopes; i++)\n  qsort(&SD.nuclide_grid[i * in.n_gridpoints], in.n_gridpoints, sizeof(NuclideGridPoint), NGP_compare);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/xsbench-omp/GridInit/2"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  R[i] = initial_density(x_init[i]);\n  P[i] = initial_pressure(x_init[i]);\n  U[i] = initial_velocity(x_init[i]);\n}\n\n", "pragma": "#pragma omp for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/1"}
{"code": "for (middle = 0; middle < 800; middle++)\n{\n  int *dm = distance_matrix[middle];\n  for (src = 0; src < 800; src++)\n  {\n    int *ds = distance_matrix[src];\n    for (dst = 0; dst < 800; dst++)\n    {\n      ds[dst] = (ds[dst] < (ds[middle] + dm[dst])) ? (ds[dst]) : (ds[middle] + dm[dst]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuvrajdalia/openmp_project/floydp/2"}
{"code": "for (int i = 0; i < WorkerNumber; i++)\n{\n  int buffer = 0;\n  MPI_Recv(&buffer, 1, MPI_INT, MPI_ANY_SOURCE, NProcess, MPI_COMM_WORLD, &status);\n  threadNumber[status.MPI_SOURCE] = buffer * TaskMultiplier;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gabrielefronze/VanAllen/VanAllenFinalMPIOMP_noROOT/VanAllenMonitor/FunctionMaster/1"}
{"code": "for (int i = 0; i < sortedVectors[currentPointerIndex]->size(); ++i)\n{\n  dest->push_back((*sortedVectors[currentPointerIndex])[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bwqr/openmp-prime-generator/main/1"}
{"code": "for (i = 0; i < n_clusters; i++)\n{\n  for (j = 0; j < 115; j++)\n  {\n    actual_centroids_array[i].coordinate[j] = points_array[centroid_index].coordinate[j];\n  }\n\n  actual_centroids_array[i].cluster_id = i + 1;\n  centroid_index += get_index_factor(n_line, n_clusters);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/5"}
{"code": "for (i = 0; i < splitPoint; i++)\n{\n  child.person[i].x_pos = parentOne.person[i].x_pos;\n  child.person[i].y_pos = parentOne.person[i].y_pos;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/4"}
{"code": "for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)\n{\n  for (int j = 0; j < bi.biWidth; j++)\n  {\n    RGBTRIPLE triple;\n    fread(&triple, sizeof(RGBTRIPLE), 1, fname);\n    img[img_idx] = ((.3 * triple.rgbtBlue) + (.59 * triple.rgbtGreen)) + (.11 * triple.rgbtRed);\n    img_idx++;\n  }\n\n  fseek(fname, padding, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/10"}
{"code": "for (int exp = 1; (m / exp) > 0; exp *= 10)\n{\n  countSort(arr, n, exp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/7"}
{"code": "for (int i = 0; i < (N - 1); ++i)\n{\n  sum += (x[i + 1] - x[i]) * (fvals[i] + fvals[i + 1]);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astrophpeter/C-OpenMP-MPI/homework3/src/integrate/0"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    if ((d[i][j] % 3) == 0)\n      count++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvgeniiSamarin/OPenMP/openMP/main/5"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      tmp1 = 1.0 / u[i][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i][j][k][0][0] = 0.0;\n      fjac[i][j][k][0][1] = 0.0;\n      fjac[i][j][k][0][2] = 1.0;\n      fjac[i][j][k][0][3] = 0.0;\n      fjac[i][j][k][0][4] = 0.0;\n      fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][2])) * tmp2;\n      fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1;\n      fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1;\n      fjac[i][j][k][1][3] = 0.0;\n      fjac[i][j][k][1][4] = 0.0;\n      fjac[i][j][k][2][0] = (-((u[i][j][k][2] * u[i][j][k][2]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n      fjac[i][j][k][2][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n      fjac[i][j][k][2][2] = ((2.0 - c2) * u[i][j][k][2]) * tmp1;\n      fjac[i][j][k][2][3] = ((-c2) * u[i][j][k][3]) * tmp1;\n      fjac[i][j][k][2][4] = c2;\n      fjac[i][j][k][3][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][3][1] = 0.0;\n      fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1;\n      fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1;\n      fjac[i][j][k][3][4] = 0.0;\n      fjac[i][j][k][4][0] = ((((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - ((c1 * u[i][j][k][4]) * tmp1)) * u[i][j][k][2]) * tmp1;\n      fjac[i][j][k][4][1] = (((-c2) * u[i][j][k][1]) * u[i][j][k][2]) * tmp2;\n      fjac[i][j][k][4][2] = ((c1 * u[i][j][k][4]) * tmp1) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + ((3.0 * u[i][j][k][2]) * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n      fjac[i][j][k][4][3] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][4][4] = (c1 * u[i][j][k][2]) * tmp1;\n      njac[i][j][k][0][0] = 0.0;\n      njac[i][j][k][0][1] = 0.0;\n      njac[i][j][k][0][2] = 0.0;\n      njac[i][j][k][0][3] = 0.0;\n      njac[i][j][k][0][4] = 0.0;\n      njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n      njac[i][j][k][1][1] = c3c4 * tmp1;\n      njac[i][j][k][1][2] = 0.0;\n      njac[i][j][k][1][3] = 0.0;\n      njac[i][j][k][1][4] = 0.0;\n      njac[i][j][k][2][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][2];\n      njac[i][j][k][2][1] = 0.0;\n      njac[i][j][k][2][2] = (con43 * c3c4) * tmp1;\n      njac[i][j][k][2][3] = 0.0;\n      njac[i][j][k][2][4] = 0.0;\n      njac[i][j][k][3][0] = ((-c3c4) * tmp2) * u[i][j][k][3];\n      njac[i][j][k][3][1] = 0.0;\n      njac[i][j][k][3][2] = 0.0;\n      njac[i][j][k][3][3] = c3c4 * tmp1;\n      njac[i][j][k][3][4] = 0.0;\n      njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - ((((con43 * c3c4) - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c3c4 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n      njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n      njac[i][j][k][4][2] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][2];\n      njac[i][j][k][4][3] = ((c3c4 - c1345) * tmp2) * u[i][j][k][3];\n      njac[i][j][k][4][4] = c1345 * tmp1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/59"}
{"code": "for (i = 0; i < nb_steps; i++)\n{\n  term = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (term * term));\n}\n\n", "pragma": "omp for reduction(+:sum) schedule(guided)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/faxmishok/Matrix-PI-OpenMP-pw4-parallel/ex2_reduction/0"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    if (!obstacles[(ii * params.nx) + jj])\n    {\n      double local_density = 0.0;\n      for (int kk = 0; kk < 9; kk++)\n      {\n        local_density += tmp_cells[(ii * params.nx) + jj].speeds[kk];\n      }\n\n      double inv_local_density = 1.0 / local_density;\n      double u_x = (((tmp_cells[(ii * params.nx) + jj].speeds[1] + tmp_cells[(ii * params.nx) + jj].speeds[5]) + tmp_cells[(ii * params.nx) + jj].speeds[8]) - ((tmp_cells[(ii * params.nx) + jj].speeds[3] + tmp_cells[(ii * params.nx) + jj].speeds[6]) + tmp_cells[(ii * params.nx) + jj].speeds[7])) * inv_local_density;\n      double u_y = (((tmp_cells[(ii * params.nx) + jj].speeds[2] + tmp_cells[(ii * params.nx) + jj].speeds[5]) + tmp_cells[(ii * params.nx) + jj].speeds[6]) - ((tmp_cells[(ii * params.nx) + jj].speeds[4] + tmp_cells[(ii * params.nx) + jj].speeds[7]) + tmp_cells[(ii * params.nx) + jj].speeds[8])) * inv_local_density;\n      double u_sq = (u_x * u_x) + (u_y * u_y);\n      temp_u += sqrt(u_sq);\n      double u[9];\n      u[1] = u_x;\n      u[2] = u_y;\n      u[3] = -u_x;\n      u[4] = -u_y;\n      u[5] = u_x + u_y;\n      u[6] = (-u_x) + u_y;\n      u[7] = (-u_x) - u_y;\n      u[8] = u_x - u_y;\n      double d_equ;\n      d_equ = (w0 * local_density) * (1.0 - (u_sq * inv_double_c_sq));\n      cells[(ii * params.nx) + jj].speeds[0] = tmp_cells[(ii * params.nx) + jj].speeds[0] + (params.omega * (d_equ - tmp_cells[(ii * params.nx) + jj].speeds[0]));\n      for (int kk = 1; kk < 5; kk++)\n      {\n        d_equ = (w1 * local_density) * (((1.0 + (u[kk] * inv_c_sq)) + ((u[kk] * u[kk]) * inv_sq_c_sq)) - (u_sq * inv_double_c_sq));\n        cells[(ii * params.nx) + jj].speeds[kk] = tmp_cells[(ii * params.nx) + jj].speeds[kk] + (params.omega * (d_equ - tmp_cells[(ii * params.nx) + jj].speeds[kk]));\n      }\n\n      for (int kk = 5; kk < 9; kk++)\n      {\n        d_equ = (w2 * local_density) * (((1.0 + (u[kk] * inv_c_sq)) + ((u[kk] * u[kk]) * inv_sq_c_sq)) - (u_sq * inv_double_c_sq));\n        cells[(ii * params.nx) + jj].speeds[kk] = tmp_cells[(ii * params.nx) + jj].speeds[kk] + (params.omega * (d_equ - tmp_cells[(ii * params.nx) + jj].speeds[kk]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:temp_u)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/borektsioglou/OpenMP/d2q9-bgk/3"}
{"code": "for (long long i = 0; i < (len - (pid * n)); i++)\n{\n  val = (((double) rand()) / RAND_MAX) + 1;\n  vec.push_back(val);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(nt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhasamritasarmah/mpi_openmp_programming_basics/mpi_omp_drakes_equation_problem_formulation/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    value = rand() % 10;\n    mat1[i][j] = value;\n    (cout << mat1[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TeoGavrilescu31/Parallel-Programming-Project-OPENMP/proiect/4"}
{"code": "for (k = 0; k < mxyz1; k++)\n{\n  npp = kpic[k];\n  for (j = 0; j < npp; j++)\n  {\n    m = kp[j + (nppmx * k)];\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[j + (nppmx * (i + (idimp * k)))] = part[i + (idimp * m)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,npp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/0"}
{"code": "for (i = 0; i < 102; i++)\n{\n  for (j = 0; j < 102; j++)\n  {\n    for (k = 0; k < 102; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/ArithmeticMeasureTool/test/bt_single/2"}
{"code": "for (int i = 0; i < (testIn.size() / 3); i++)\n{\n  base64Transform(testIn, transformResult, i * 3, i * 4, b64EncodingString);\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phoenixEkb/OpenMP-base64-encoder-decoder/OpenMPTest/OpenMPTest/7"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    res(i, j) = this->mat[j][i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/8"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  init_array(X);\n  start = _rdtsc();\n  parallel_merge_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X))\n  {\n    fprintf(stderr, \"ERROR: the array is not properly sorted\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/mergesort/3"}
{"code": "for (i = 0; i < 12; i++)\n  Me[i] = tt;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/15"}
{"code": "for (i = 3 * 1; i <= ((grid_points[0] - (3 * 1)) - 1); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/55"}
{"code": "for (int iter = 0; iter <= dom->nbiter_; ++iter)\n  fprintf(fileid, \"%17.13e %17.13e %17.13e %17.13e %17.13e\\n\", iter * dom->dt_, nrj_(iter), nrjx_(iter), nrjy_(iter), mass_(iter));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yasahi-hpc/P3-miniapps/miniapps/vlp4d_mpi/openacc/Diags/0"}
{"code": "for (j = 0; j < chtrellis.stateNb; j++)\n{\n  index = 0;\n  for (n = 0; n < chtrellis.stateNb; n++)\n  {\n    for (k = 0; k < 2; k++)\n    {\n      if (chtrellis.nextState[n + (k * chtrellis.stateNb)] == j)\n      {\n        chtrellis.prevState[j + (index * chtrellis.stateNb)] = n;\n        chtrellis.input[j + (index * chtrellis.stateNb)] = k;\n        index++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j,index,n,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_eq/0"}
{"code": "for (size_t j = 0; j < gridLoc.size(); ++j)\n{\n  if (!gridLoc[j].inGrid)\n    continue;\n\n  ++numInGrid;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/7"}
{"code": "for (int i = 0; i < strlen(origin); i++)\n  reverse[i] = origin[(strlen(origin) - i) - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ssujinn/Distributed-Parallel-Programming-HW/hw3/problem1/palindrome/0"}
{"code": "for (i = 0; i < size; i++)\n  printf(\"%d  \", arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/24"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    A[i][j] = rand() % 5;\n    B[i][j] = rand() % 5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/1"}
{"code": "for (int i = 0; i < num_processes; i++)\n{\n  prows[i] += (krowsh * 2) * cols;\n  firstrow[i] -= krowsh * cols;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Arrays/convolution2D/mpi1/8"}
{"code": "for (unsigned int i = 0; i < number; i++)\n  if (is_alive[i])\n{\n  if (((isnan(pos[i][0]) || (isinf(pos[i][0]) != 0)) || isnan(pos[i][2])) || (isinf(pos[i][2]) != 0))\n  {\n    (((((cerr << \"ERROR(charge_weighting): radius[\") << i) << \"] or longitude[\") << i) << \"] is not valid number. Can not continue.\") << endl;\n    exit(1);\n  }\n\n  r_i = CELL_NUMBER(pos[i][0], dr);\n  z_k = CELL_NUMBER(pos[i][2], dz);\n  if (r_i < 0)\n    r_i = 0;\n\n  if (z_k < 0)\n    z_k = 0;\n\n  if (pos[i][0] > dr)\n  {\n    r1 = pos[i][0] - (0.5 * dr);\n    r2 = (r_i + 0.5) * dr;\n    r3 = pos[i][0] + (0.5 * dr);\n    ro_v = charge_array[i] / ((((2. * PI) * dz) * dr) * pos[i][0]);\n    v_1 = CELL_VOLUME(r_i, dr, dz);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    dz1 = ((z_k + 0.5) * dz) - (pos[i][2] - (0.5 * dz));\n    dz2 = (pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    value = (ro_v * CYL_RNG_VOL(dz1, r1, r2)) / v_1;\n    ro1->inc_rho(r_i, z_k, value);\n    value = (ro_v * CYL_RNG_VOL(dz1, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k, value);\n    value = (ro_v * CYL_RNG_VOL(dz2, r1, r2)) / v_1;\n    ro1->inc_rho(r_i, z_k + 1, value);\n    value = (ro_v * CYL_RNG_VOL(dz2, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k + 1, value);\n  }\n  else\n    if (pos[i][0] <= (dr / 2.))\n  {\n    r_i = 0;\n    r1 = 0.;\n    r2 = (r_i + 0.5) * dr;\n    r3 = pos[i][0] + (0.5 * dr);\n    dz1 = ((z_k + 0.5) * dz) - (pos[i][2] - (0.5 * dz));\n    dz2 = (pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    ro_v = charge_array[i] / ((PI * dz) * (((2. * pos[i][0]) * pos[i][0]) + ((dr * dr) / 2.)));\n    v_1 = CYL_VOL(dz, dr);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    value = (((ro_v * PI) * dz1) * ((((dr * dr) / 2.) - (pos[i][0] * dr)) + (pos[i][0] * pos[i][0]))) / v_1;\n    ro1->inc_rho(r_i, z_k, value);\n    value = (ro_v * CYL_RNG_VOL(dz1, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k, value);\n    value = (((ro_v * PI) * dz2) * ((((dr * dr) / 2.) - (pos[i][0] * dr)) + (pos[i][0] * pos[i][0]))) / v_1;\n    ro1->inc_rho(r_i, z_k + 1, value);\n    value = (ro_v * CYL_RNG_VOL(dz2, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k + 1, value);\n  }\n  else\n  {\n    r1 = pos[i][0] - (0.5 * dr);\n    r2 = (r_i + 0.5) * dr;\n    r3 = pos[i][0] + (0.5 * dr);\n    dz1 = ((z_k + 0.5) * dz) - (pos[i][2] - (0.5 * dz));\n    dz2 = (pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    ro_v = charge_array[i] / ((((2. * PI) * dz) * dr) * pos[i][0]);\n    v_1 = CYL_VOL(dz, dr);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    value = (ro_v * CYL_RNG_VOL(dz1, r1, r2)) / v_1;\n    ro1->inc_rho(r_i, z_k, value);\n    value = (ro_v * CYL_RNG_VOL(dz1, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k, value);\n    value = (ro_v * CYL_RNG_VOL(dz2, r1, r2)) / v_1;\n    ro1->inc_rho(r_i, z_k + 1, value);\n    value = (ro_v * CYL_RNG_VOL(dz2, r2, r3)) / v_2;\n    ro1->inc_rho(r_i + 1, z_k + 1, value);\n  }\n\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  SHA_CTX ctx;\n  SHA_CTX ctxi;\n  SHA_CTX ctxo;\n  int i;\n  union \n  {\n    unsigned char uc[64];\n    uint32_t ui[64 / 4];\n  } pad;\n  unsigned char buffer[20];\n  unsigned char tk[20];\n  unsigned char key[40];\n  DES_cblock ivec;\n  DES_key_schedule ks1;\n  DES_key_schedule ks2;\n  DES_key_schedule ks3;\n  memcpy(&ctx, &cur_salt->pctx, sizeof(SHA_CTX));\n  SHA1_Update(&ctx, saved_key[index], saved_len[index]);\n  SHA1_Final(buffer, &ctx);\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, buffer, 20);\n  SHA1_Update(&ctx, cur_salt->local_salt, cur_salt->local_salt_length);\n  SHA1_Final(buffer, &ctx);\n  SHA1_Init(&ctxi);\n  SHA1_Init(&ctxo);\n  memset(pad.uc, 0x36, 64);\n  for (i = 0; i < 20; ++i)\n    pad.uc[i] ^= buffer[i];\n\n  SHA1_Update(&ctxi, pad.uc, 64);\n  for (i = 0; i < (64 / 4); ++i)\n    pad.ui[i] ^= 0x36363636 ^ 0x5c5c5c5c;\n\n  SHA1_Update(&ctxo, pad.uc, 64);\n  memcpy(&ctx, &ctxi, sizeof(ctx));\n  SHA1_Update(&ctx, cur_salt->local_salt, 20);\n  SHA1_Update(&ctx, cur_salt->local_salt, cur_salt->local_salt_length);\n  SHA1_Final(buffer, &ctx);\n  memcpy(&ctx, &ctxo, sizeof(ctx));\n  SHA1_Update(&ctx, buffer, 20);\n  SHA1_Final(key, &ctx);\n  memcpy(&ctx, &ctxi, sizeof(ctx));\n  SHA1_Update(&ctx, cur_salt->local_salt, 20);\n  SHA1_Final(buffer, &ctx);\n  memcpy(&ctx, &ctxo, sizeof(ctx));\n  SHA1_Update(&ctx, buffer, 20);\n  SHA1_Final(tk, &ctx);\n  SHA1_Update(&ctxi, tk, 20);\n  SHA1_Update(&ctxi, cur_salt->local_salt, cur_salt->local_salt_length);\n  SHA1_Final(buffer, &ctxi);\n  SHA1_Update(&ctxo, buffer, 20);\n  SHA1_Final(key + 20, &ctxo);\n  DES_set_key_unchecked((DES_cblock *) key, &ks1);\n  DES_set_key_unchecked((DES_cblock *) (key + 8), &ks2);\n  DES_set_key_unchecked((DES_cblock *) (key + 16), &ks3);\n  memcpy(ivec, key + 32, 8);\n  DES_ede3_cbc_encrypt((unsigned char *) \"password-check\\x02\\x02\", (unsigned char *) crypt_out[index], 16, &ks1, &ks2, &ks3, &ivec, 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mozilla_ng_fmt_plug/0"}
{"code": "for (int k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    vol_flux_y[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = vol_flux_y[FTNREF2D(1 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/54"}
{"code": "for (int e = start; e < end; e++)\n{\n  int n_op = col_reord[e];\n  int map0idx = map0[n_op + (set_size1 * 0)];\n  int map1idx = map0[n_op + (set_size1 * 1)];\n  int map2idx = map2[n_op + (set_size1 * 0)];\n  int map3idx = map2[n_op + (set_size1 * 1)];\n  const double *coord2a = &data0[3 * map0idx];\n  const double *coord2b = &data0[3 * map1idx];\n  const double *coord1a = &data2[3 * map2idx];\n  const double *coord1b = &data2[3 * map3idx];\n  const double *residuals1a = &data4[5 * map2idx];\n  const double *residuals1b = &data4[5 * map3idx];\n  double *residuals1a_prolonged = &data6[5 * map0idx];\n  double *residuals1b_prolonged = &data6[5 * map1idx];\n  double *residuals1a_prolonged_wsum = &data8[1 * map0idx];\n  double *residuals1b_prolonged_wsum = &data8[1 * map1idx];\n  double dx_a1a2 = coord2a[0] - coord1a[0];\n  double dy_a1a2 = coord2a[1] - coord1a[1];\n  double dz_a1a2 = coord2a[2] - coord1a[2];\n  if (((dx_a1a2 == 0.0) && (dy_a1a2 == 0.0)) && (dz_a1a2 == 0.0))\n  {\n    residuals1a_prolonged[VAR_DENSITY] = residuals1a[VAR_DENSITY];\n    residuals1a_prolonged[VAR_MOMENTUM + 0] = residuals1a[VAR_MOMENTUM + 0];\n    residuals1a_prolonged[VAR_MOMENTUM + 1] = residuals1a[VAR_MOMENTUM + 1];\n    residuals1a_prolonged[VAR_MOMENTUM + 2] = residuals1a[VAR_MOMENTUM + 2];\n    residuals1a_prolonged[VAR_DENSITY_ENERGY] = residuals1a[VAR_DENSITY_ENERGY];\n    *residuals1a_prolonged_wsum = 1.0;\n  }\n  else\n  {\n    const double idist_a1a2 = 1.0 / sqrt(((dx_a1a2 * dx_a1a2) + (dy_a1a2 * dy_a1a2)) + (dz_a1a2 * dz_a1a2));\n    residuals1a_prolonged[VAR_DENSITY] += idist_a1a2 * residuals1a[VAR_DENSITY];\n    residuals1a_prolonged[VAR_MOMENTUM + 0] += idist_a1a2 * residuals1a[VAR_MOMENTUM + 0];\n    residuals1a_prolonged[VAR_MOMENTUM + 1] += idist_a1a2 * residuals1a[VAR_MOMENTUM + 1];\n    residuals1a_prolonged[VAR_MOMENTUM + 2] += idist_a1a2 * residuals1a[VAR_MOMENTUM + 2];\n    residuals1a_prolonged[VAR_DENSITY_ENERGY] += idist_a1a2 * residuals1a[VAR_DENSITY_ENERGY];\n    *residuals1a_prolonged_wsum += idist_a1a2;\n    double dx_b1a2 = coord1b[0] - coord2a[0];\n    double dy_b1a2 = coord1b[1] - coord2a[1];\n    double dz_b1a2 = coord1b[2] - coord2a[2];\n    const double idist_b1a2 = 1.0 / sqrt(((dx_b1a2 * dx_b1a2) + (dy_b1a2 * dy_b1a2)) + (dz_b1a2 * dz_b1a2));\n    residuals1a_prolonged[VAR_DENSITY] += idist_b1a2 * residuals1b[VAR_DENSITY];\n    residuals1a_prolonged[VAR_MOMENTUM + 0] += idist_b1a2 * residuals1b[VAR_MOMENTUM + 0];\n    residuals1a_prolonged[VAR_MOMENTUM + 1] += idist_b1a2 * residuals1b[VAR_MOMENTUM + 1];\n    residuals1a_prolonged[VAR_MOMENTUM + 2] += idist_b1a2 * residuals1b[VAR_MOMENTUM + 2];\n    residuals1a_prolonged[VAR_DENSITY_ENERGY] += idist_b1a2 * residuals1b[VAR_DENSITY_ENERGY];\n    *residuals1a_prolonged_wsum += idist_b1a2;\n  }\n\n  double dx_b1b2 = coord2b[0] - coord1b[0];\n  double dy_b1b2 = coord2b[1] - coord1b[1];\n  double dz_b1b2 = coord2b[2] - coord1b[2];\n  if (((dx_b1b2 == 0.0) && (dy_b1b2 == 0.0)) && (dz_b1b2 == 0.0))\n  {\n    residuals1b_prolonged[VAR_DENSITY] = residuals1b[VAR_DENSITY];\n    residuals1b_prolonged[VAR_MOMENTUM + 0] = residuals1b[VAR_MOMENTUM + 0];\n    residuals1b_prolonged[VAR_MOMENTUM + 1] = residuals1b[VAR_MOMENTUM + 1];\n    residuals1b_prolonged[VAR_MOMENTUM + 2] = residuals1b[VAR_MOMENTUM + 2];\n    residuals1b_prolonged[VAR_DENSITY_ENERGY] = residuals1b[VAR_DENSITY_ENERGY];\n    *residuals1b_prolonged_wsum = 1.0;\n  }\n  else\n  {\n    const double idist_b1b2 = 1.0 / sqrt(((dx_b1b2 * dx_b1b2) + (dy_b1b2 * dy_b1b2)) + (dz_b1b2 * dz_b1b2));\n    residuals1b_prolonged[VAR_DENSITY] += idist_b1b2 * residuals1b[VAR_DENSITY];\n    residuals1b_prolonged[VAR_MOMENTUM + 0] += idist_b1b2 * residuals1b[VAR_MOMENTUM + 0];\n    residuals1b_prolonged[VAR_MOMENTUM + 1] += idist_b1b2 * residuals1b[VAR_MOMENTUM + 1];\n    residuals1b_prolonged[VAR_MOMENTUM + 2] += idist_b1b2 * residuals1b[VAR_MOMENTUM + 2];\n    residuals1b_prolonged[VAR_DENSITY_ENERGY] += idist_b1b2 * residuals1b[VAR_DENSITY_ENERGY];\n    *residuals1b_prolonged_wsum += idist_b1b2;\n    double dx_a1b2 = coord1a[0] - coord2b[0];\n    double dy_a1b2 = coord1a[1] - coord2b[1];\n    double dz_a1b2 = coord1a[2] - coord2b[2];\n    const double idist_a1b2 = 1.0 / sqrt(((dx_a1b2 * dx_a1b2) + (dy_a1b2 * dy_a1b2)) + (dz_a1b2 * dz_a1b2));\n    residuals1b_prolonged[VAR_DENSITY] += idist_a1b2 * residuals1b[VAR_DENSITY];\n    residuals1b_prolonged[VAR_MOMENTUM + 0] += idist_a1b2 * residuals1b[VAR_MOMENTUM + 0];\n    residuals1b_prolonged[VAR_MOMENTUM + 1] += idist_a1b2 * residuals1b[VAR_MOMENTUM + 1];\n    residuals1b_prolonged[VAR_MOMENTUM + 2] += idist_a1b2 * residuals1b[VAR_MOMENTUM + 2];\n    residuals1b_prolonged[VAR_DENSITY_ENERGY] += idist_a1b2 * residuals1b[VAR_DENSITY_ENERGY];\n    *residuals1b_prolonged_wsum += idist_a1b2;\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/down_v2_kernel_omp4kernel_func/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  int tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/2018-private-origin-no/0"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  out3[i] = sigmoid(in3[i]);\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/7"}
{"code": "for (i = 0; i <= 98; i += 1)\n{\n  a[i + j] = a[i + k] + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_dep_distance/2"}
{"code": "for (uint32_t i = 0; i < rows; i++)\n{\n  for (uint32_t idCol = csrF.pointer[i], j = 0; idCol < csrF.pointer[i + 1]; idCol++)\n  {\n    j = csrF.indices[idCol];\n    idStartCol = csrA.pointer[i];\n    idEndCol = csrA.pointer[i + 1];\n    if (idStartCol == idEndCol)\n    {\n      break;\n    }\n\n    idStartRow = cscB.pointer[j];\n    idEndRow = cscB.pointer[j + 1];\n    bool isCommon = hasCommon(csrA.indices.begin() + idStartCol, csrA.indices.begin() + idEndCol, cscB.indices.begin() + idStartRow, cscB.indices.begin() + idEndRow);\n    if (isCommon)\n    {\n      mulResult.indices.push_back(j);\n      nnz++;\n    }\n\n  }\n\n  mulResult.pointer[i + 1] = nnz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thodkatz/sparse-bmm/src/spgemm/1"}
{"code": "for (int i = 0; i < 50; i++)\n{\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FedeVerges/SistemasDistribuidos_MemoriaCompartida_OpenMP/OpenMP/Ejercicio4/Ejercicio4/1"}
{"code": "for (i = 0; i < numT; i++)\n  localProcessI(i, 0, aMesh->elements->elementAt(i));\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_external_libraries/tetMeshOpt/u_ParallelFunctions/5"}
{"code": "for (int i = 0; i < (n * K); i++)\n  item_lv[i] = h_item_lv[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/sgd/omp_target/1"}
{"code": "for (unsigned i = 0; i < ntasks; i++)\n{\n  int work;\n  private_load += (work = tasks[i]);\n  start = omp_get_wtime();\n  sum += kernel_cpu(work, load);\n  private_time += omp_get_wtime() - start;\n}\n\n", "pragma": "omp for schedule(runtime) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp-benchmarks/src/benchmark/benchmark/0"}
{"code": "for (int i = 0; i <= N; i++)\n  fprintf(fi, \"%g\\n\", Om[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/102"}
{"code": "for (size_t from = 0; from < size; ++from)\n{\n  for (size_t to = 0; to < size; ++to)\n  {\n    assert(distances[to + (size * from)] == distances[from + (size * to)]);\n    printf(\"%05d \", distances[to + (size * from)]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkestene/tsp/openmp/tsp/1"}
{"code": "for (int i = 0; i < numcells; i++)\n{\n  U[i] = RU[i] / R[i];\n  P[i] = (GAMMA - 1.0) * (RE[i] - ((0.5 * RU[i]) * U[i]));\n  S[i] = S_func(P[i], R[i]);\n  E[i] = (P[i] / (GAMMA - 1.0)) / R[i];\n  RS[i] = R[i] * S[i];\n  S_diff[i] = S[i] - S_prev[i];\n  RS_diff[i] = (RS[i] - RS_prev[i]) + (dtdx * (FRUS[i + 1] - FRUS[i]));\n  S_prev[i] = S[i];\n  RS_prev[i] = RS[i];\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/17"}
{"code": "for (int i = 1; i < size_N; ++i)\n{\n  tmp_xi = (a * tmp_xi) + b;\n  result[i] = tmp_xi;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArtTikidji/Study_openMP_AVX/main/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LiyaSharipova/OpenMP-Tasks/task11/0"}
{"code": "for (i = 0; i < l; i++)\n{\n  int j;\n  for (j = 0; j < SIZE; j++)\n  {\n    if (forward_map[empty_cells_list[idx].x][empty_cells_list[idx].y][j] == 0)\n    {\n      int a;\n      int b;\n      int c;\n      struct queue_element *temp = malloc(sizeof(struct queue_element));\n      for (a = 0; a < SIZE; a++)\n        for (b = 0; b < SIZE; b++)\n        temp->board[a][b] = q->list[i]->board[a][b];\n\n\n      for (a = 0; a < SIZE; a++)\n        for (b = 0; b < SIZE; b++)\n        for (c = 0; c < SIZE; c++)\n        temp->forward_map[a][b][c] = q->list[i]->forward_map[a][b][c];\n\n\n\n      temp->board[empty_cells_list[idx].x][empty_cells_list[idx].y] = j + 1;\n      populate_f(empty_cells_list[idx].x, empty_cells_list[idx].y, j + 1, temp->forward_map);\n      push(tmp, temp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/22"}
{"code": "for (i = 1; i <= 672; i++)\n{\n  for (j = 1; j <= 672; j++)\n  {\n    Temperature[i][j] = 0.25 * (((Temperature_last[i + 1][j] + Temperature_last[i - 1][j]) + Temperature_last[i][j + 1]) + Temperature_last[i][j - 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/0"}
{"code": "for (long i = 0; i < numUniqueClusters; i++)\n{\n  omp_init_lock(&nlocks[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/2"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  grid->activePartitions[i] = 0;\n}\n\n", "pragma": "omp parallel for default(none) shared(grid,totalPartitions) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/grid/0"}
{"code": "for (i = 0; i < a_r; i++)\n{\n  for (j = 0; j < b_c; j++)\n  {\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vishwassathish/Parallel-computing-to-multiply-large-matrices/withmp/2"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  for (int j = 0; j <= i; j++)\n  {\n    expected_x += a[j];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n  expected_x = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/scan/test_scan/3"}
{"code": "for (int i = 0; i < tmp.size(); i++)\n  setlen.insert(tmp[i].length());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/meeraramesh-sjsu/netgpu-master/src/Common/Dissector/3"}
{"code": "for (j = 1; j < cache->assoc; j++)\n{\n  if (getRRPV(&cache->cacheLines[i][j]) > min)\n  {\n    victim = j;\n    min = getRRPV(&cache->cacheLines[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/22"}
{"code": "for (int ii = 0; ii < n; ++ii)\n  table->values[ii] = data[ii];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/1"}
{"code": "for (i = 1; i < numClusters; i++)\n  newClusters[i] = newClusters[i - 1] + numFea;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/10"}
{"code": "for (int i = 0; i < _vpnts.size(); i++)\n{\n  sort(_vpnts[i].begin(), _vpnts[i].end(), sortY);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Guiming/ParallelRipleysKfunction/spp_mpi/SpatialPointPattern/0"}
{"code": "for (i = 1; i < 100; i++)\n{\n  {\n    is_larger = check_i_islarger2(i) && is_larger;\n    sum = sum + i;\n  }\n}\n\n", "pragma": "omp parallel for schedule(static,1) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/parallel_for_ordered/0"}
{"code": "for (int ien = 0; ien < Occ.size(); ien++)\n{\n  if (Occ[ien] < 0)\n    Removed.push_back(-Occ[ien]);\n  else\n    if (Occ[ien] > 0)\n    Added.push_back(Occ[ien]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderESHDF.fft/6"}
{"code": "form[0] = format(nb.activ)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/5"}
{"code": "for (i = 0; i < N; i++)\n  *(x + i) = *(b + i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannahGulle/Baby_BLAS/OMPSolvers/openmp/dls/4"}
{"code": "for (j = 1; j < (arraysize - 1); ++j)\n{\n  for (k = 1; k < (arraysize - 1); ++k)\n  {\n    neighbours = calculate_neighbours_inside(current, j, k, arraysize);\n    next[j][k] = next_state(neighbours, current[j][k]);\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisOrf/Game-of-Life/Hybrid_game_of_life/0"}
{"code": "for (int i = 0; i < N; ++i)\n  if (max < array[i])\n  max = array[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kvitnat/Parallel-programming-lab/OpenMP/omp/3"}
{"code": "for (k = 0; k < ny; k++)\n{\n  cu[(3 * nxe) * k] += cu[(3 * nx) + ((3 * nxe) * k)];\n  cu[1 + ((3 * nxe) * k)] += cu[(1 + (3 * nx)) + ((3 * nxe) * k)];\n  cu[2 + ((3 * nxe) * k)] += cu[(2 + (3 * nx)) + ((3 * nxe) * k)];\n  cu[(3 * nx) + ((3 * nxe) * k)] = 0.0;\n  cu[(1 + (3 * nx)) + ((3 * nxe) * k)] = 0.0;\n  cu[(2 + (3 * nx)) + ((3 * nxe) * k)] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/32"}
{"code": "for (; i < size_; i += BYN, p1 += BYN, p2 += BYN)\n  sum += vector_dot_product_pointer16(p1, p2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/2"}
{"code": "for (i = 0; i < natom; i++)\n{\n  ax[i] = ((float) rand()) / ((float) RAND_MAX);\n  ay[i] = ((float) rand()) / ((float) RAND_MAX);\n  az[i] = ((float) rand()) / ((float) RAND_MAX);\n  charge[i] = ((float) rand()) / ((float) RAND_MAX);\n  size[i] = ((float) rand()) / ((float) RAND_MAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mdh-omp/main/0"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vPressure[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/56"}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/18"}
{"code": "for (int i = 0; i < num_variates; i++)\n{\n  variates[i] = uniform_int(eng);\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmadsen/neutral-model-cpp/src/parallel_random/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  s += g(a + (i * h));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/1_cons/0"}
{"code": "for (i = 0; i < nnodes; i++)\n{\n  j = result[i].left;\n  k = vector[j];\n  result[i].left = index[j];\n  result[i].right = index[k];\n  index[k] = (-i) - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/84"}
{"code": "for (int k = 0; k < 1; k++)\n{\n  printf(\"\\ntimings %s:\\n\", TIMINGS_NAMES[k]);\n  double std_dev = 0;\n  for (int j = 0; j < 2; j++)\n  {\n    min_timings[k][j] = timings[k][j][0];\n    max_timings[k][j] = timings[k][j][0];\n    std_dev = timings[k][j][0] * timings[k][j][0];\n    for (int i = 1; i < nthreads; i++)\n    {\n      timings[k][j][0] += timings[k][j][i];\n      std_dev += timings[k][j][i] * timings[k][j][i];\n      min_timings[k][j] = (min_timings[k][j] < timings[k][j][i]) ? (min_timings[k][j]) : (timings[k][j][i]);\n      max_timings[k][j] = (max_timings[k][j] > timings[k][j][i]) ? (max_timings[k][j]) : (timings[k][j][i]);\n    }\n\n    timings[k][j][0] /= nthreads;\n    std_dev = sqrt((std_dev / (nthreads - 1)) - (((nthreads / (nthreads - 1)) * timings[k][j][0]) * timings[k][j][0]));\n    printf(\"\\t%16s :  w-clock %9.7g, avg %9.7g +- %9.7g, min: %9.7g, max: %9.7g\\n\", STRATEGIES_NAMES[j], wtimings[k][j] * INV_REP, timings[k][j][0] * INV_REP, std_dev * INV_REP, min_timings[k][j] * INV_REP, max_timings[k][j] * INV_REP);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/04_unpredictable_pattern/1"}
{"code": "for (i = 0; i < nt; i++)\n{\n  lbuf[i] = (double *) malloc(rows * (sizeof(double)));\n  rbuf[i] = (double *) malloc(rows * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh-raghavan/Parallel-Programming/TempDistribution/3/6"}
{"code": "for (i = 0; i < 100; i++)\n  C[i] += C_private[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/counting/6"}
{"code": "for (j = 0; j < numThreads; j++)\n{\n  thread_params[j]._tid = j;\n  thread_params[j]._ran = ran;\n  thread_params[j]._table = Table;\n  thread_params[j]._blockSize = (1024 * 1024LU) / numThreads;\n  thread_params[j]._logTableSize = logTableSize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/pthread/single_node_lcg/2"}
{"code": "for (int i = 0; i < 16; i = bar(j) + i)\n  for (int j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/74"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"Hello world from thread number %d \\n\", omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice1/0"}
{"code": "for (i = 0; i < (itersperthr * nthreads); i++)\n{\n  delay(delaylength);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/epcc-c/schedbench/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  ytemp = y[i];\n  ztemp = z[i];\n  y[i] = (ytemp * cos(angle)) + (ztemp * sin(angle));\n  z[i] = ((-ytemp) * sin(angle)) + (ztemp * cos(angle));\n}\n\n", "pragma": "omp parallel for firstprivate(n,ytemp,ztemp,angle)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/0"}
{"code": "for (i = 0; i < (s + 2); i++)\n{\n  free(filter->array[i]);\n  filter->array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/filter_OMP/8"}
{"code": "for (int i = 0; i < NBUCKETS; i++)\n{\n  omp_destroy_lock(&hist_locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olia92/OpenMP_Mattson/Hist/hist_omp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (c[i] != ((((double) 2) * i) + i))\n  {\n    err++;\n    printf(\"%d: got %d, expected %d\\n\", i, c[i], (2 * i) + i);\n    if (err > 10)\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/target_depend_dag/target_depend_dag/2"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp4cn1r6ea.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp4cn1r6ea.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/30"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n  for (k = 0; k < 2048; k++)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amineremache/matrix_mult/matrix_mul_openmp/5"}
{"code": "for (int i = 0; i < (*w); i++)\n{\n  (*dgauss_Kernel)[i] = ((-1) * (i - pw)) * exp((((-1) * (i - pw)) * (i - pw)) / ((2 * sigma) * sigma));\n  sum -= i * (*dgauss_Kernel)[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcoisgood/High-Performance-Computing/3.Canny-Edge-Detector with MPI&openMP+MPI)/openMP+MPI/canny_edge_Mix/4"}
{"code": "for (int i = 0; i < k; ++i)\n{\n  centroid.push_back(points.at(rand() % n));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SukritiGupta/K-means-parallel-and-sequential/Omp/2"}
{"code": "for (j = 0; j < 10000; j++)\n{\n  count = 0;\n  for (k = 0; k < 1000; k++)\n  {\n    count = count * (count + 1);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adityakaria/5-Sem/pc/lab4/test/pc4al/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  kernel[i] /= sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MuhammadAhmed8/Image-Convolution-OpenMp/img_conv_mpi/1"}
{"code": "for (int i = 0; i < size; i++)\n  (cout << a[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonshting/mipt-openmp-mpi/openmp-mpi/06/main_omp/1"}
{"code": "for (chunk_idx = 0; chunk_idx < (word_len_in_bitmap / chunk_len); ++chunk_idx)\n{\n  fprintf(stderr, \"<%u,%u> = %d: Started scan step for chunk %zu at %lf\\n\", row, rank_in_row, bfs_rank, chunk_idx, times[(chunk_idx * 4) + 0]);\n  fprintf(stderr, \"<%u,%u> = %d: Scan recv done for chunk %zu at %lf\\n\", row, rank_in_row, bfs_rank, chunk_idx, times[(chunk_idx * 4) + 1]);\n  fprintf(stderr, \"<%u,%u> = %d: Scan update done for chunk %zu at %lf\\n\", row, rank_in_row, bfs_rank, chunk_idx, times[(chunk_idx * 4) + 2]);\n  fprintf(stderr, \"<%u,%u> = %d: Scan send done for chunk %zu at %lf\\n\", row, rank_in_row, bfs_rank, chunk_idx, times[(chunk_idx * 4) + 3]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/24"}
{"code": "for (i = 0; i < lines; i++)\n{\n  for (j = 0; j < samples; j++)\n  {\n    for (k = 0; k < bands; k++)\n      if (image[((i * offset_CW) + (k * samples)) + j] == (-9999))\n      processedImage[((i * offset_CW) + (j * bands)) + k] = 0;\n    else\n      processedImage[((i * offset_CW) + (j * bands)) + k] = image[((i * offset_CW) + (k * samples)) + j];\n\n\n    maxR = (threads > 1) ? (image[((i * offset_CW) + (R * samples)) + j]) : ((maxR < image[((i * offset_CW) + (R * samples)) + j]) ? (image[((i * offset_CW) + (R * samples)) + j]) : (maxR));\n    maxG = (threads > 1) ? (image[((i * offset_CW) + (G * samples)) + j]) : ((maxG < image[((i * offset_CW) + (G * samples)) + j]) ? (image[((i * offset_CW) + (G * samples)) + j]) : (maxG));\n    maxB = (threads > 1) ? (image[((i * offset_CW) + (B * samples)) + j]) : ((maxB < image[((i * offset_CW) + (B * samples)) + j]) ? (image[((i * offset_CW) + (B * samples)) + j]) : (maxB));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) default(shared) private(k) reduction(max:maxR, maxG, maxB)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnMinelli/Parallel-KMeans/dataManager/0"}
{"code": "for (i = 0; i < matrixAData.iSize; i++)\n{\n  for (j = 0; j < matrixBData.jSize; j++)\n  {\n    matrixAIndex = matrixAData.startingJ + ((matrixAData.startingI + i) * matrixAData.matrixJSize);\n    matrixBIndex = (matrixBData.startingJ + j) + (matrixBData.startingI * matrixBData.matrixJSize);\n    resultIndex = (resultData.startingJ + j) + ((resultData.startingI + i) * resultData.matrixJSize);\n    result[resultIndex] = 0;\n    for (k = 0; k < matrixAData.jSize; k++)\n    {\n      result[resultIndex] += matrixA[matrixAIndex] * matrixB[matrixBIndex];\n      matrixAIndex++;\n      matrixBIndex += matrixBData.matrixJSize;\n    }\n\n    if (!isPositive)\n    {\n      result[resultIndex] = -result[resultIndex];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for nowait collapse(2) private(i, j, k, matrixAIndex, matrixBIndex, resultIndex)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_MatrixInverse/inverse_matrix/1"}
{"code": "for (i = 0; i < array_length; i++)\n{\n  theta_prime = acos((*(y + i)) / (*(r + i)));\n  if ((theta_prime < theta_max) && (theta_prime >= theta_min))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      y_dum = 1;\n      yfr_dum = 0;\n      while (y_dum > yfr_dum)\n      {\n        fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * (*(temps + i));\n        y_dum = gsl_rng_uniform_pos(rand);\n        if (spect == 'w')\n        {\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / (*(temps + i)), 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n        else\n        {\n          fr_max = 5.88e10 * (*(temps + i));\n          bb_norm = ((PL_CONST * fr_max) * pow(fr_max / C_LIGHT, 2.0)) / (exp((PL_CONST * fr_max) / (K_B * (*(temps + i)))) - 1);\n          yfr_dum = ((((1.0 / bb_norm) * PL_CONST) * fr_dum) * pow(fr_dum / C_LIGHT, 2.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n\n      }\n\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      *(boost + 0) = (-1) * (*(vx + i));\n      *(boost + 1) = (-1) * (*(vy + i));\n      *(boost + 2) = (-1) * (*(vz + i));\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].r0 = *(x + i);\n      (*ph)[ph_tot].r1 = *(y + i);\n      (*ph)[ph_tot].r2 = *(z + i);\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib_3d/6"}
{"code": "for (iterator i = path.begin(); i != path.end(); i++)\n{\n  ((((cout << \"(\") << (*i).x) << \", \") << (*i).y) << \") \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/patrick100/A-Star-OpenMP/A_star_p2/3"}
{"code": "for (i = 1; i < num_roots; ++i)\n{\n  void *status;\n  pthread_join(roots[i], &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/root-threads-affinity/3"}
{"code": "for (i = 0; i < nT; i++)\n{\n  for (j = 0; j < nT; j++)\n  {\n    if (i > j)\n    {\n      {\n        cblas_dgemv(CblasRowMajor, CblasNoTrans, wT, wT, 1.0, A[i][j], wT, &x[j * wT], 1, 1.0, &y[i * wT], 1);\n      }\n    }\n    else\n      if (i == j)\n    {\n      cblas_dsymv(CblasRowMajor, CblasLower, wT, 1.0, A[i][i], wT, &x[j * wT], 1, 1.0, &y[i * wT], 1);\n    }\n    else\n    {\n      cblas_dgemv(CblasRowMajor, CblasTrans, wT, wT, 1.0, A[j][i], wT, &x[j * wT], 1, 1.0, &y[i * wT], 1);\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic,2) reduction(+:y[0:nT*wT])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhyuchao123/OpenMP-and-CUDA-for-matrix-decomposition/openmp/checkCholesky/0"}
{"code": "for (i = 0; i < 302; i++)\n{\n  solution[cur_gen][0][i] = solution[cur_gen][1][i];\n  solution[cur_gen][302 - 1][i] = solution[cur_gen][302 - 2][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moreandres/hotspot/tests/examples/heat2d/heat2d/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    assert(v[i][j] == 1);\n    v[i][j]++;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(v)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_vla_04/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  mat[i] = &linear[i * n];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lamyaraed/Parallel-Processing/MatrixAddition(OMP)/5"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (this->mat_.col[aj] > ai)\n    {\n      col[nnz] = this->mat_.col[aj];\n      val[nnz] = this->mat_.val[aj];\n      ++nnz;\n    }\n\n  }\n\n  row_offset[ai + 1] = nnz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/14"}
{"code": "for (j = yStart; j < yEnd; j++)\n  for (i = 0; i < XPICR; i++)\n{\n  a = (-2.05f) + ((3.00f * ((float) i)) * IXRES);\n  b = 1.10f - ((2.24f * ((float) j)) * IYRES);\n  {\n    buffer[iCnt++] = IterateMandelbrot(a, b);\n  }\n}\n\n\n", "pragma": "omp parallel for private(j, i) schedule(runtime) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sloox/OPENMPIMANDEL/mandle/0"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  P[i] = B[i] - AX[i];\n  R[i] = P[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/CG/C/cg/12"}
{"code": "for (int i = 0; i < s.st_size; i++)\n{\n  sudoku_grid[(int) floor(i / 9)][i % 9] = &addr_sudoku[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidator/6"}
{"code": "for (i = 0; i < nvars; i++)\n{\n  newx[i] = xbefore[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iloudaros/Paralllelll/Code/1.OpenMP/multistart_hooke_omp/5"}
{"code": "for (k = 0; k < size2; k++)\n{\n  for (h = 0; h < size2; h++)\n  {\n    if (h != k)\n    {\n      float mulPosX = posx[h] - posx[k];\n      float mulPosY = posy[h] - posy[k];\n      float mulPosZ = posz[h] - posz[k];\n      float d = sqrtf(((mulPosX * mulPosX) + (mulPosY * mulPosY)) + (mulPosZ * mulPosZ));\n      if (d < 1.0)\n        d = 1.0;\n\n      float l = (masse[h] * M) * (1 / ((d * d) * d));\n      accelx[k] += mulPosX * l;\n      accely[k] += mulPosY * l;\n      accelz[k] += mulPosZ * l;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  while (!omp_test_nest_lock(&lck))\n  {\n  }\n\n  ;\n  nr_threads_in_single++;\n  nr_iterations++;\n  nr_threads_in_single--;\n  result = result + nr_threads_in_single;\n  omp_unset_nest_lock(&lck);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_nest_testlock/0"}
{"code": "for (i = 0; i < digits.size(); i++)\n{\n  digit++;\n  counter = counter + pow(*it, digit);\n  it++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/itwitch13/parallel-solutions/DisariumNumber/openMPDisarium/0"}
{"code": "for (h = 0; h < cnt; h++)\n{\n  h2 = 1;\n  while (h2 <= topoinfo->numG)\n  {\n    fprintf(f_s[cnt - 1], \"\\t%f\", log2(tmprlt->soln[((topoinfo->numG * h) + h2) - 1]));\n    fprintf(f_s[n], \"\\t%f\", log2(tmprlt->soln[((topoinfo->numG * h) + h2) - 1]));\n    h2++;\n  }\n\n  if (h != (cnt - 1))\n  {\n    fprintf(f_s[n], \"\\n\");\n    fprintf(f_s[n], \"%d\\t%d\", num, cnt);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/63"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  dep += i;\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StephanPirnbaum/insieme-examples/exp6/exp6/0"}
{"code": "for (step = 1; step <= 10; step++)\n{\n  forces = memset(forces, 0, 10 * (sizeof(vect_t)));\n  {\n    {\n      for (q = 0, i = 0; q < 500; q++, i++)\n      {\n        pos[q][X] = ((rand() / ((double) 32767)) * 2) - 1;\n        pos[q][Y] = ((rand() / ((double) 32767)) * 2) - 1;\n        old_pos[i][X] = pos[q][X];\n        old_pos[i][Y] = pos[q][Y];\n        vel[q][X] = ((rand() / ((double) 32767)) * 2) - 1;\n        vel[q][Y] = ((rand() / ((double) 32767)) * 2) - 1;\n        mass[q] = fabs(((rand() / ((double) 32767)) * 2) - 1);\n      }\n\n    }\n  }\n  {\n    {\n      for (q = 0; q < 500; q++)\n      {\n        for (k = 0; k < 500; k++)\n        {\n          if (k != q)\n          {\n            x_diff = pos[q][X] - pos[k][X];\n            y_diff = pos[q][Y] - pos[k][Y];\n            dist = sqrt((x_diff * x_diff) + (y_diff * y_diff));\n            dist_cubed = (dist * dist) * dist;\n            forces[q][X] -= (((6.674e-11 * mass[q]) * mass[k]) / dist_cubed) * x_diff;\n            forces[q][Y] -= (((6.674e-11 * mass[q]) * mass[k]) / dist_cubed) * y_diff;\n          }\n\n        }\n\n      }\n\n    }\n  }\n  {\n    {\n      for (h = 0; h < 500; h++)\n      {\n        pos[h][X] += 0.05 * vel[h][X];\n        pos[h][Y] += 0.05 * vel[h][Y];\n        vel[h][X] += (0.05 / mass[h]) * forces[h][X];\n        vel[h][Y] += (0.05 / mass[h]) * forces[h][Y];\n      }\n\n    }\n  }\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/simple(parallel) (Scheduled)/0"}
{"code": "for (i = 1; i <= (75000 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/CG/cg_single/0"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testDrand48_sema(8000000, i);\n  printf(\"testD sema  | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc() * 10000., stop() * 10000., stopt() / 8e6);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/9"}
{"code": "for (int i = 0; i < numsOfParts[indexGroup - 1]; i++)\n{\n  if (island[i + explored] == 1)\n  {\n    found = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double sum = 0.0;\n  for (int j = 0; j < n; j++)\n  {\n    sum += A[i + (j * n)] * v[j];\n  }\n\n  out[i] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/kalman-omp/main/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  b[j] = B[j];\n  for (k = 0; k < n; k++)\n    a[j][k] = A[(j + k) + counter];\n\n  counter += n - 1;\n}\n\n", "pragma": "#pragma omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kielfriedt/Multithreading/OpenMP/MatSolv/0"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  pos = i * sizeInput;\n  max = contadores[i];\n  for (int j = 0; j < max; j++)\n  {\n    numerosInput[c++] = buckets[pos + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raphael28/cp2018/Trabalho/Codigo/src/bucketSortPrl/3"}
{"code": "for (int j = 0; j < N; j++)\n{\n  rNext[j] = r[j] - ((alpha * A[(j * N) + j]) * z[j]);\n  sum += rNext[j] * rNext[j];\n}\n\n", "pragma": "#pragma omp for schedule(TYPE, CHUNK) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_2/4"}
{"code": "for (int k = kini; k < kend; k++)\n{\n  res += source(i, k) * vec[k - kini];\n  total += vec[k - kini];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/sepOMP/0"}
{"code": "for (int i = first_index; i < last_index; i++)\n{\n  if (is_node_intersect_search_region(m_vLowerLimitOfX[i], m_vUpperLimitOfX[i], m_vLowerLimitOfY[i], m_vUpperLimitOfY[i], m_vLowerLimitOfZ[i], m_vUpperLimitOfZ[i], search_x, search_y, search_z, radius))\n    nodelist.push_back(i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/octree/9"}
{"code": "for (i = 0; i < 64; i++)\n{\n  cnt = DES_IP[i ^ 0x20];\n  j = (unsigned char) ((binary_salt[cnt >> 3] >> (7 - (cnt & 7))) & 1);\n  temp[i / 8] |= j << (7 - (i % 8));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETNTLM_bs_fmt_plug/3"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  douth1[col] = outh[col] * (1 - outh[col]);\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/27"}
{"code": "for (size_t i = 0; i < grid_size; i++)\n{\n  organism_update(&env.grid[i]);\n}\n\n", "pragma": "omp parallel for num_threads(num_threads) schedule(static, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-shared/0"}
{"code": "for (n = 0; n < ((local_N - 2) * (local_M - 2)); ++n)\n{\n  int i;\n  int j;\n  int sum;\n  i = (n / (local_M - 2)) + 2;\n  j = (n % (local_M - 2)) + 2;\n  find_neighbourhood_sum(i, j, &sum);\n  changed_cells += find_next_state(i, j, sum);\n}\n\n", "pragma": "omp for schedule(static) reduction(+:changed_cells)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giorgospan/Game-Of-Life/mpi_openmp/game/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    printf(\"%d \", data[(i * cols) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/pathfinder/pathfinder.ref/2"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < 16; j++)\n  for (k = 0; k < 16; k++)\n{\n  C[i][j] += A[i][k] * B[k][j];\n}\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesxu90/Speedup-program-using-OpenMP-and-OpenACC-on-CUDA-and-Coprocessor/Presentation/ddt_training/programs/openmp/matrix/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = 10.0;\n  b[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Homagn/openmp_cpp_course/Homagni_assn5/Task3/OMP_parallel_dot/main/2"}
{"code": "for (idx_t j_off = 0; j_off < (jend - jbegin); ++j_off)\n{\n  const idx_t j = (jend - j_off) - 1;\n  idx_t idx = tt->ind[m][j];\n  --histogram[idx];\n  idx_t offset = histogram[idx];\n  new_vals[offset] = tt->vals[j];\n  for (idx_t mode = 0; mode < tt->nmodes; ++mode)\n  {\n    if (mode != m)\n    {\n      new_ind[mode][offset] = tt->ind[mode][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/16"}
{"code": "for (int i = 1; i < (ROW - 1); i++)\n{\n  currentGeneration[COLUMN - 1][i] = '.';\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rzaaeeff/GameofLife-OpenMP/GoLParallel/2"}
{"code": "for (int lineCol = line; lineCol <= end; lineCol += step)\n{\n  time = OnMultBlock(lineCol, lineCol, blockSize);\n  ret = PAPI_stop(EventSet, values);\n  printf(\"retorno da fun\u00e7\u00e3o de multiplica\u00e7\u00e3o %d\\n\", ret);\n  if (ret != PAPI_OK)\n    (cout << \"ERROR: Stop PAPI\") << endl;\n\n  double l2dmiss = ((double) values[1]) / (((double) values[1]) + ((double) values[0]));\n  double gflops = (double) ((2 * pow(lineCol * lineCol, 3)) / time);\n  double ipc = ((double) values[3]) / ((double) values[2]);\n  printf(\"CYCLES: %lld \\n\", values[2]);\n  printf(\"L2 DCA: %lld \\n\", values[0]);\n  printf(\"L2 DCM: %lld \\n\", values[1]);\n  printf(\"Total Instructions: %lld \\n\", values[3]);\n  printf(\"%lld L2 Data Cache Misses (%.4lf%% misses) with %lld L2 Data Cache Access in %lld Cycles\\n\", values[1], l2dmiss, values[0], values[2]);\n  printf(\"GFLOPS %.10lf 10e9\\n\", (gflops * 1) * 10e-9);\n  printf(\"Inst per cycle \\n%.10lf\", ipc);\n  ret = PAPI_reset(EventSet);\n  if (ret != PAPI_OK)\n    (cout << \"FAIL reset\") << endl;\n\n  ((((((((((((((((logfile << lineCol) << \" | \") << blockSize) << \" | \") << time) << \" | \") << values[2]) << \" | \") << l2dmiss) << \" | \") << (1 - l2dmiss)) << \" | \") << ((gflops * 1) * 10e-9)) << \" | \") << ipc) << \" | \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/9"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  for (size_t j = 0; j < n; j++)\n  {\n    fscanf(fileA, \"%lf\", &A[i][j]);\n    L[i][j] = 0;\n    U[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JaiJaveria/Parallel_Crout_Decomposition/crout/5"}
{"code": "for (i = 0; i < size; i++)\n  array[i] = ((int) rand()) % 7;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShoeShi/Parallel-Programming-Samples/1OpenMPColumnWiseMat/main/4"}
{"code": "for (int i = 0; i < point_dim; i++)\n{\n  dst[i] = src[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/treyvian/Kmeans-with-OpenMP/src/kmedoids/kmedoids/1"}
{"code": "for (i = 0; i < ns_inst; i++)\n{\n  fscanf(fin, \"%d %f\", &ival, &val);\n  segs[i] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/16"}
{"code": "for (j = i; j < (i + m); j++)\n  rank[index[j]] = value;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/8"}
{"code": "for (j = 0; j < o.n; ++j)\n  u0[j] = u[j];\n\n", "pragma": "        #pragma omp parallel for default(none) shared(u0,u,rho,o) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex8-poisson-openmp/1"}
{"code": "for (int q = 0; q < local_n; q++)\n{\n  for (int k = 0; k < n; k++)\n  {\n    if (k != (q + (process_id * local_n)))\n    {\n      double x_diff = (*(((positions + ((process_id * local_n) * 2)) + (q * 2)) + 0)) - (*((positions + (k * 2)) + 0));\n      double y_diff = (*(((positions + ((process_id * local_n) * 2)) + (q * 2)) + 1)) - (*((positions + (k * 2)) + 1));\n      double dist = sqrt((x_diff * x_diff) + (y_diff * y_diff));\n      double dist_cubed = (dist * dist) * dist;\n      *((local_forces + (q * 2)) + 0) -= (((G * masses[(process_id * local_n) + q]) * masses[k]) / dist_cubed) * x_diff;\n      *((local_forces + (q * 2)) + 1) -= (((G * masses[(process_id * local_n) + q]) * masses[k]) / dist_cubed) * y_diff;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(number_of_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VicXekro/n_body_cpp/N_Body_MPI_OMP/n_body/0"}
{"code": "for (long i = NV - 1; i >= 0; i--)\n{\n  if (old2NewMap[i] < NS)\n  {\n    Rprime[rowCounter] = old2NewMap[i];\n    rowCounter++;\n  }\n  else\n  {\n    Rprime[colCounter] = old2NewMap[i];\n    colCounter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReorderingND/1"}
{"code": "for (int row = 0; row < bound_length; row++)\n{\n  #pragma ivdep\n  for (int column = 0; column < bound_length; column++)\n  {\n    next[(((start_z + row) * wnx) + column) + start_x] *= min(sponge_coefficients[column], sponge_coefficients[row]);\n    next[((((end_z - 1) - row) * wnx) + column) + start_x] *= min(sponge_coefficients[column], sponge_coefficients[row]);\n    next[((start_z + row) * wnx) + ((end_x - 1) - column)] *= min(sponge_coefficients[column], sponge_coefficients[row]);\n    next[(((end_z - 1) - row) * wnx) + ((end_x - 1) - column)] *= min(sponge_coefficients[column], sponge_coefficients[row]);\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(static, 1) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp/boundary-managers/SpongeBoundaryManager/2"}
{"code": "for (i = 0; i < sine_num; i++)\n{\n  sines[i] = 0.0;\n  for (j = 0; j <= i; j++)\n  {\n    a = (((double) j) * pi) / ((double) (sine_num - 1));\n    sines[i] = sines[i] + sin(a);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/6"}
{"code": "for (int k = 1; k < kn; k++)\n{\n  for (int j = 1; j < jn; j++)\n  {\n    za[k][j] = ((((zp[k + 1][j - 1] + zq[k + 1][j - 1]) - zp[k][j - 1]) - zq[k][j - 1]) * (zr[k][j] + zr[k][j - 1])) / (zm[k][j - 1] + zm[k + 1][j - 1]);\n    zb[k][j] = ((((zp[k][j - 1] + zq[k][j - 1]) - zp[k][j]) - zq[k][j]) * (zr[k][j] + zr[k - 1][j])) / (zm[k][j] + zm[k][j - 1]);\n  }\n\n}\n\n", "pragma": "      #pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/23"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  vaik = _mm256_set1_ps(a[i][k]);\n  t2 = a[i][k];\n  for (j = k + 1; (j + 8) < n; j += 8)\n  {\n    vakj = _mm256_loadu_ps(&a[k][j]);\n    vaij = _mm256_loadu_ps(&a[i][j]);\n    vx = _mm256_mul_ps(vakj, vaik);\n    vaij = _mm256_sub_ps(vaij, vx);\n    _mm256_storeu_ps(&a[i][j], vaij);\n  }\n\n  for (j; j < n; j++)\n  {\n    a[i][j] -= t2 * a[k][j];\n  }\n\n  a[i][k] = 0;\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_x86_linux/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  xcrdif[m] = fabs((xcr[m] - xcrref[m]) / xcrref[m]);\n  xcedif[m] = fabs((xce[m] - xceref[m]) / xceref[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/151"}
{"code": "for (int i = 0; i < ((size / 2) - 1); ++i)\n{\n  if (T[(2 * i) + 1] > T[(2 * i) + 2])\n  {\n    echanger(T, (2 * i) + 1, (2 * i) + 2);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/bubble/1"}
{"code": "for (unsigned int i = 0; i < triangle_side; ++i)\n{\n  for (unsigned int j = 0; j < triangle_side; ++j)\n  {\n    uint32_t x = compute_coord_owner_info(i, j);\n    owner_table[i][j] = x;\n    reverse_owner_table[x / nsubranks_1d][x % nsubranks_1d] = (i << 16) | j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/3"}
{"code": "for (j = start; j < end; j++)\n{\n  for (i = 0; i < ((int) floor(WIDTH / 1.0)); i++)\n  {\n    domain_ptr[j - start][i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/357r4bd/2d-heat/src/openmp-2dheat/7"}
{"code": "for (int iter = 0; iter < 5; iter++)\n{\n  r = nr;\n  c = nc;\n  float dxx = (curPtr[((r * cols) + c) - 1] - (2.0f * curPtr[(r * cols) + c])) + curPtr[((r * cols) + c) + 1];\n  float dyy = (curPtr[((r - 1) * cols) + c] - (2.0f * curPtr[(r * cols) + c])) + curPtr[((r + 1) * cols) + c];\n  float dss = (lowPtr[(r * cols) + c] - (2.0f * curPtr[(r * cols) + c])) + highPtr[(r * cols) + c];\n  float dxy = 0.25f * (((curPtr[(((r + 1) * cols) + c) + 1] - curPtr[(((r + 1) * cols) + c) - 1]) - curPtr[(((r - 1) * cols) + c) + 1]) + curPtr[(((r - 1) * cols) + c) - 1]);\n  if (0 == iter)\n  {\n    float edgeScore = ((dxx + dyy) * (dxx + dyy)) / ((dxx * dyy) - (dxy * dxy));\n    if ((edgeScore >= edgeScoreThreshold) || (edgeScore < 0))\n      return;\n\n  }\n\n  float dxs = 0.25f * (((highPtr[((r * cols) + c) + 1] - highPtr[((r * cols) + c) - 1]) - lowPtr[((r * cols) + c) + 1]) + lowPtr[((r * cols) + c) - 1]);\n  float dys = 0.25f * (((highPtr[((r + 1) * cols) + c] - highPtr[((r - 1) * cols) + c]) - lowPtr[((r + 1) * cols) + c]) + lowPtr[((r - 1) * cols) + c]);\n  float A[9];\n  A[0] = dxx;\n  A[1] = dxy;\n  A[2] = dxs;\n  A[3] = dxy;\n  A[4] = dyy;\n  A[5] = dys;\n  A[6] = dxs;\n  A[7] = dys;\n  A[8] = dss;\n  float dx = 0.5f * (curPtr[((r * cols) + c) + 1] - curPtr[((r * cols) + c) - 1]);\n  float dy = 0.5f * (curPtr[((r + 1) * cols) + c] - curPtr[((r - 1) * cols) + c]);\n  float ds = 0.5f * (highPtr[(r * cols) + c] - lowPtr[(r * cols) + c]);\n  b[0] = -dx;\n  b[1] = -dy;\n  b[2] = -ds;\n  solveLinear3x3(A, b);\n  if ((isnan(b[0]) || isnan(b[1])) || isnan(b[2]))\n    return;\n\n  val = curPtr[(r * cols) + c] + (0.5f * (((dx * b[0]) + (dy * b[1])) + (ds * b[2])));\n  if (b[0] > MAX_SUBPIXEL_SHIFT)\n  {\n    if (c < (cols - POINT_SAFETY_BORDER))\n      nc++;\n    else\n      return;\n\n  }\n\n  if (b[1] > MAX_SUBPIXEL_SHIFT)\n  {\n    if (r < (rows - POINT_SAFETY_BORDER))\n      nr++;\n    else\n      return;\n\n  }\n\n  if (b[0] < (-MAX_SUBPIXEL_SHIFT))\n  {\n    if (c > POINT_SAFETY_BORDER)\n      nc--;\n    else\n      return;\n\n  }\n\n  if (b[1] < (-MAX_SUBPIXEL_SHIFT))\n  {\n    if (r > POINT_SAFETY_BORDER)\n      nr--;\n    else\n      return;\n\n  }\n\n  if ((nr == r) && (nc == c))\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucaLovagnini/parallelHesaff/src/pyramid/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"test2() iteration %d\\n\", i);\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/1_ordered/0"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  for (k = 0; k < nz; k++)\n  {\n    exact(iglob, 0, k, &u[i][0][k][0]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/21"}
{"code": "for (int i = 0; i < length; ++i)\n{\n  new_mat->data[i] = this->data[i] * other_mat->data[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishig25/2017Block2/project/openmp/6"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < k; j++)\n  result[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task6/OpenMPtask6/0"}
{"code": "for (j = Jmin; j <= Jmax; j++)\n{\n  for (i = Imin; i <= Imax; i++)\n  {\n    ftmp = (float) Node(idx(j, i), iHmax);\n    fwrite(&ftmp, sizeof(float), 1, fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/22"}
{"code": "for (k = 1 * 3; k <= ((grid_points[2] - 3) - 1); k += 1)\n{\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n}\n\n", "pragma": "omp parallel for private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/30"}
{"code": "for (int k = 0; k < 100; k++)\n{\n  n = k;\n  a[k] = n;\n}\n\n", "pragma": "omp target parallel for simd private(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-parallel-for-simd-clauses/test/4"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      printf(\"hello\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp metadirective when(user={condition(OMP_MODEL_TARGET)}: target teams distribute parallel for simd collapse(3))       \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-meta/clang-meta/0"}
{"code": "for (linha = 0; linha < tamanhoTotal; linha++)\n{\n  for (coluna = 0; coluna < tamanhoTotal; coluna++)\n  {\n    if ((((linha == 0) || (linha == tamanhoParcial)) || (coluna == 0)) || (coluna == tamanhoParcial))\n    {\n      matriz[linha][coluna] = 0;\n      matrizResultado[linha][coluna] = 0;\n    }\n    else\n    {\n      if ((rand() % 100) > 50)\n      {\n        matriz[linha][coluna] = 1;\n      }\n      else\n      {\n        matriz[linha][coluna] = 0;\n      }\n\n      matrizResultado[linha][coluna] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bruno-braganca/gameOfLife_OpenMP/game_of_life/2"}
{"code": "for (j = 0; j < i; j++)\n{\n  if (((edge[i][0] == edge[j][0]) && (edge[i][1] == edge[j][1])) || ((edge[i][0] == edge[j][1]) && (edge[i][1] == edge[j][0])))\n  {\n    i--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcdino/Paralleling-Model-Performance-Workloadbalance/BFS/BFS_tbb/0"}
{"code": "for (int i = 0; i < cloudSize; ++i)\n{\n  ccsum += clouds[i].dusts.size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/13"}
{"code": "for (i = 0; i < tam; i++)\n  free(num[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adrikei/FinalParalela/src/openmp/3"}
{"code": "for (i = 0; i < 4000; ++i)\n{\n  doWork(w[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/TestSchedule/0"}
{"code": "for (int k = 0; k < N; k++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    for (int i = 0; i < N; i++)\n    {\n      fill_array3d(fluxfct, N, i, j, k, 0);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/multigrid/1"}
{"code": "for (i = l; i <= r; i++)\n{\n  swap(l, i);\n  permute(l + 1, r, num);\n  if (population.size() > num)\n  {\n    i = r;\n  }\n\n  swap(l, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prachi220/Parallel-Programming/Travelling Salesman Problem/tsp_2014CS50289/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  v = a[i];\n  printf(\"thread %d v=%d\\n \", 0, v);\n}\n\n", "pragma": "omp parallel for lastprivate(v)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/lastprivate-clause/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  dims[i][0] = 512;\n  dims[i][1] = 512;\n  dims[i][2] = 512;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/17"}
{"code": "for (i = offset_start; i < offset_end; i++)\n{\n  u = (*pageRanksFP)[i];\n  t = (u >> (radix * 8)) & 0xff;\n  o = buckets_count[(t_id * buckets) + t];\n  (*pageRanksFPTemp)[o] = (*pageRanksFP)[i];\n  (*labelsTemp)[o] = (*labels)[i];\n  buckets_count[(t_id * buckets) + t]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/15"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  reduce_real += this->vec_[i].real();\n  reduce_imag += this->vec_[i].imag();\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : reduce_real, reduce_imag)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/27"}
{"code": "for (i = 0; i < nvtxs; i++)\n  degrees[perm[i]] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/9"}
{"code": "for (int x = startx; x < height; ++x)\n{\n  for (int y = starty; y < width; ++y)\n  {\n    grad_x = 0;\n    grad_y = 0;\n    if ((x == (image_height - 1)) || (y == (image_width - 1)))\n      grad = 0;\n    else\n    {\n      for (int i = 0; i <= 1; i++)\n      {\n        for (int j = 0; j <= 1; j++)\n        {\n          grad_x += inputImage[x + i][y + j] * maskX[i][j];\n        }\n\n      }\n\n      for (int i = 0; i <= 1; i++)\n      {\n        for (int j = 0; j <= 1; j++)\n        {\n          grad_y += inputImage[x + i][y + j] * maskY[i][j];\n        }\n\n      }\n\n      grad = (int) sqrt((grad_x * grad_x) + (grad_y * grad_y));\n    }\n\n    outputImage[x][y] = (grad <= 255) ? (grad) : (255);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/usaruner/OpenMP/ImplementationA-tester/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  inpG[2 * i] = inpG[2 * i] * f[i];\n  inpG[(2 * i) + 1] = inpG[(2 * i) + 1] * f[i];\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/15. filter (mkl)/filter/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  assert(C[i] >= 0);\n  pastCommAss[i] = C[i];\n  currCommAss[i] = C[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/parallelLouvainMethodInitialized/0"}
{"code": "for (i = 0; i < X.nonzeros; i++)\n{\n  fgets(tmp, 10005, fin);\n  len = strlen(tmp);\n  int k = 0;\n  int idx = 0;\n  int flag = 0;\n  int flag2 = 0;\n  double mul = 0.1;\n  double val = 0;\n  for (j = 0; j < len; j++)\n  {\n    if ((tmp[j] == ' ') || (tmp[j] == '\\t'))\n    {\n      X.index[pos++] = idx - 1;\n      if (X.dimension[k] < idx)\n        X.dimension[k] = idx;\n\n      idx = 0;\n      k++;\n    }\n    else\n      if ((tmp[j] >= '0') && (tmp[j] <= '9'))\n    {\n      if (flag == 1)\n      {\n        val += mul * (tmp[j] - '0');\n        mul /= 10;\n      }\n      else\n        idx = ((idx * 10) + tmp[j]) - '0';\n\n    }\n    else\n      if (tmp[j] == '.')\n    {\n      val += idx;\n      flag = 1;\n    }\n    else\n      if (tmp[j] == '-')\n    {\n      flag2 = 1;\n    }\n\n\n\n\n  }\n\n  if (flag == 0)\n    val = idx;\n\n  if (flag2 == 0)\n  {\n    X.value[i] = val;\n  }\n  else\n  {\n    X.value[i] = -val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/2"}
{"code": "for (i = 0; i < 5000000; i++)\n{\n  x[i] = rand() % 1000;\n  y[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/addition/1"}
{"code": "for (begin = end; begin < end; ++begin)\n  ++begin;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/49"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i += 1)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j += 1)\n    {\n      for (k = grid_points[2] - 3; k >= 0; k += -1)\n      {\n        k1 = k + 1;\n        k2 = k + 2;\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j][k1])) - (lhs[n + 4][i][j][k] * rhs[m][i][j][k2]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (k1,k2,i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/219"}
{"code": "for (i = 0; i < 16; i++)\n{\n  printf(\"| \");\n  for (j = 0; j < 16; j++)\n  {\n    printf(\" %.2f \", A[i][j]);\n  }\n\n  printf(\" |  *  | \");\n  for (j = 0; j < 16; j++)\n  {\n    printf(\" %.2f \", B[i][j]);\n  }\n\n  printf(\" |  =  |\");\n  for (j = 0; j < 16; j++)\n  {\n    printf(\" %.2f \", C[i][j]);\n  }\n\n  printf(\" |\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesxu90/Speedup-program-using-OpenMP-and-OpenACC-on-CUDA-and-Coprocessor/Presentation/ddt_training/programs/openmp/matrix/2"}
{"code": "for (int i = 0; i < numOfAtoms; ++i)\n{\n  this->nucleiCharges_[i] = geom.getCharge(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfPopulation/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  int sign = (calcResults[i] > 0) ? (1) : (-1);\n  const double *point = getPointAt(points, i);\n  if (sign != points->groupTags[i])\n  {\n    updateWeightsVector(weights, w0, alpha, points->groupTags[i], point, k);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yotamMoshe7/C-Classification-Problem-Precepton/MPI_OMP_CUDA/PerceptronClassification/5"}
{"code": "for (i = startNumber; i <= endNumber; i++)\n{\n  counter = 0;\n  n = i;\n  omp_set_num_threads(nThreads);\n  while (n > 1)\n  {\n    isodd = n % 2;\n    if (isodd)\n      n = (3 * n) + 1;\n    else\n      n /= 2;\n\n    counter++;\n  }\n\n  iter[i - startNumber] = counter;\n}\n\n", "pragma": "omp parallel for private(counter, n, isodd)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CsatiZoltan/Collatz/src/collatz/0"}
{"code": "for (int i = 1; i < 16; i++)\n{\n  if (i <= 4)\n  {\n    printf(\"---------------------------RODANDO COM 2 THREADS---------------------------\\n\");\n    omp_set_num_threads(2);\n  }\n  else\n    if ((i > 4) && (i <= 8))\n  {\n    printf(\"---------------------------RODANDO COM 4 THREADS---------------------------\\n\");\n    omp_set_num_threads(4);\n  }\n  else\n    if ((i > 8) && (i <= 12))\n  {\n    printf(\"---------------------------RODANDO COM 6 THREADS---------------------------\\n\");\n    omp_set_num_threads(6);\n  }\n  else\n    if ((i > 12) && (i <= 16))\n  {\n    printf(\"---------------------------RODANDO COM 8 THREADS---------------------------\\n\");\n    omp_set_num_threads(8);\n  }\n\n\n\n\n  int *vetParalelInvertido;\n  vetParalelInvertido = (int *) malloc(tam * (sizeof(int)));\n  preenche_vetor_em_sequencia(vetParalelInvertido, &tam);\n  vetParalelInvertido = inverte_vetor(vetParalelInvertido, &tam);\n  printf(\"Vetor desordenado: \");\n  imprimirVetor(vetParalelInvertido, &tam);\n  start = omp_get_wtime();\n  paralelo(vetParalelInvertido, &tam);\n  end = omp_get_wtime();\n  printf(\"Paralelo com vetor invertido = %f\\n\", end - start);\n  printf(\"Vetor ordenado: \");\n  imprimirVetor(vetParalelInvertido, &tam);\n  free(vetParalelInvertido);\n  printf(\"-----------------------------------------------\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/6"}
{"code": "for (i = 0; i < VECLEN; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/ParallelRegionOrphanedDirective/1"}
{"code": "for (int i = 0; i < n; i++)\n  a[i] = f(i);\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/CumulativeSumDCA/2"}
{"code": "for (int by = y_start; by < nyEnd; by += block_y)\n{\n  for (int bz = offset; bz < nzEnd; bz += block_z)\n  {\n    for (int bx = offset; bx < nxEnd; bx += block_x)\n    {\n      int izEnd = fmin(bz + block_z, nzEnd);\n      int iyEnd = fmin(by + block_y, nyEnd);\n      int ixEnd = fmin(block_x, nxEnd - bx);\n      float *src_ptr;\n      float *rec_ptr;\n      float *correlation_output;\n      float *source_i;\n      float *receive_i;\n      uint b_offset = 0;\n      float value = 0;\n      for (int iy = by; iy < iyEnd; ++iy)\n      {\n        for (int iz = bz; iz < izEnd; ++iz)\n        {\n          b_offset = (((iy * wnx) * wnz) + (iz * wnx)) + bx;\n          src_ptr = source_base + b_offset;\n          rec_ptr = receiver_base + b_offset;\n          correlation_output = correlation_output_base + b_offset;\n          source_i = source_i_base + b_offset;\n          receive_i = receive_i_base + b_offset;\n          for (int ix = 0; ix < ixEnd; ++ix)\n          {\n            value = src_ptr[ix] * rec_ptr[ix];\n            correlation_output[ix] += value;\n            if (_COMPENSATION_TYPE == COMBINED_COMPENSATION)\n            {\n              source_i[ix] += src_ptr[ix] * src_ptr[ix];\n              receive_i[ix] += rec_ptr[ix] * rec_ptr[ix];\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp teams  distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/migration-accommodators/CrossCorrelationKernel/0"}
{"code": "for (i = 0; i < Nparticles; i++)\n  seed[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/12"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid->start) + ((1.0 - rx) * x_grid->end);\n  for (int j = 0; j < num_splines; j++)\n    eval_NUBspline_1d_z(norm_splines[j], x, &norm_vals[j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/22"}
{"code": "for (int bucketId = 0; bucketId < BUCKET_AMOUNT; bucketId++)\n{\n  int bucketBinSize = ((maximumElement - minimumElement) + 1) / BUCKET_AMOUNT;\n  int lowerBinCriteria = (bucketId * bucketBinSize) + minimumElement;\n  int upperBinCriteria = (lowerBinCriteria + bucketBinSize) - 1;\n  if (bucketId == (BUCKET_AMOUNT - 1))\n  {\n    upperBinCriteria = maximumElement;\n  }\n\n  for (j = 0; j < DATA_SIZE; j++)\n  {\n    if ((data[j] >= lowerBinCriteria) && (data[j] <= upperBinCriteria))\n    {\n      bucketDataCount[bucketId] += 1;\n    }\n\n  }\n\n  int slicingCount = 0;\n  int sliced[bucketDataCount[bucketId]];\n  for (j = 0; j < DATA_SIZE; j++)\n  {\n    if ((data[j] >= lowerBinCriteria) && (data[j] <= upperBinCriteria))\n    {\n      sliced[slicingCount++] = data[j];\n    }\n\n  }\n\n  mergeSort(sliced, 0, slicingCount - 1);\n  for (int k = 0; k < bucketDataCount[bucketId]; k++)\n  {\n    sortedData[sortedArrayLastElementPointer++] = sliced[k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/15"}
{"code": "for (k = 0; k < K; k++)\n{\n  ptres[k] = 0;\n  kp = (K - k) - 1;\n  p = floor((sqrt(1 + (8 * kp)) - 1) / 2);\n  i1 = (I - (kp - ((p * (p + 1)) / 2))) - 1;\n  i2 = i1 - ((I - 1) - p);\n  for (j = 0; j < J; j++)\n  {\n    ptres[k] += abs(ptx[i1 + (I * j)] - ptx[i2 + (I * j)]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(ptx, ptres) private(i1, i2, j, k, kp, p)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Atrebas/pmdr/src/distance/2"}
{"code": "for (; p1 != end; ++p1)\n  sum += ((*p1) > 0) ? (*p1) : (-1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/11"}
{"code": "for (polynomialItertor = 0; polynomialItertor <= polynomialDegree; polynomialItertor++)\n{\n  tmpCalc = coefficients[polynomialItertor] * pow(x, polynomialItertor);\n  functionResult += tmpCalc;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zdzwie/PiASK_Project/integral_omp/1"}
{"code": "for (i_imopVarPre79 = ist; i_imopVarPre79 <= iend; i_imopVarPre79++)\n{\n  for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 2); k_imopVarPre81++)\n  {\n    for (j_imopVarPre80 = jst; j_imopVarPre80 <= jend; j_imopVarPre80++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (ty2 * (flux[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][m_imopVarPre82] - flux[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][m_imopVarPre82]));\n      }\n\n    }\n\n    L2 = ny - 1;\n    for (j_imopVarPre80 = jst; j_imopVarPre80 <= L2; j_imopVarPre80++)\n    {\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      u21j = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1];\n      u31j = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2];\n      u41j = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3];\n      u51j = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4];\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][0];\n      u21jm1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][1];\n      u31jm1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][2];\n      u41jm1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][3];\n      u51jm1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][4];\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = ty3 * (u21j - u21jm1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = ty3 * (u41j - u41jm1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((1.40e+00 * 1.40e+00) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j_imopVarPre80 = jst; j_imopVarPre80 <= jend; j_imopVarPre80++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] + ((dy1 * ty1) * ((u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][0] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0])) + u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][0]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][1] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1]))) + ((dy2 * ty1) * ((u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][1] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1])) + u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][1]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][2] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2]))) + ((dy3 * ty1) * ((u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][2] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2])) + u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][2]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][3] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3]))) + ((dy4 * ty1) * ((u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][3] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3])) + u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][3]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][4] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4]))) + ((dy5 * ty1) * ((u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][4] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4])) + u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][4]));\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][1][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][1][k_imopVarPre81][m_imopVarPre82] - (dssp * ((((+5.0) * u[i_imopVarPre79][1][k_imopVarPre81][m_imopVarPre82]) - (4.0 * u[i_imopVarPre79][2][k_imopVarPre81][m_imopVarPre82])) + u[i_imopVarPre79][3][k_imopVarPre81][m_imopVarPre82]));\n      rsd[i_imopVarPre79][2][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][2][k_imopVarPre81][m_imopVarPre82] - (dssp * (((((-4.0) * u[i_imopVarPre79][1][k_imopVarPre81][m_imopVarPre82]) + (6.0 * u[i_imopVarPre79][2][k_imopVarPre81][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][3][k_imopVarPre81][m_imopVarPre82])) + u[i_imopVarPre79][4][k_imopVarPre81][m_imopVarPre82]));\n    }\n\n    jst1 = 3;\n    jend1 = ny - 4;\n    for (j_imopVarPre80 = jst1; j_imopVarPre80 <= jend1; j_imopVarPre80++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (dssp * ((((u[i_imopVarPre79][j_imopVarPre80 - 2][k_imopVarPre81][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80 - 1][k_imopVarPre81][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80 + 1][k_imopVarPre81][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80 + 2][k_imopVarPre81][m_imopVarPre82]));\n      }\n\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][ny - 3][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][ny - 3][k_imopVarPre81][m_imopVarPre82] - (dssp * (((u[i_imopVarPre79][ny - 5][k_imopVarPre81][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][ny - 4][k_imopVarPre81][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][ny - 3][k_imopVarPre81][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][ny - 2][k_imopVarPre81][m_imopVarPre82])));\n      rsd[i_imopVarPre79][ny - 2][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][ny - 2][k_imopVarPre81][m_imopVarPre82] - (dssp * ((u[i_imopVarPre79][ny - 4][k_imopVarPre81][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][ny - 3][k_imopVarPre81][m_imopVarPre82])) + (5.0 * u[i_imopVarPre79][ny - 2][k_imopVarPre81][m_imopVarPre82])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/18"}
{"code": "for (i = 0; i < 5; i++)\n  sum2 += i;\n\n", "pragma": "omp for schedule(static) reduction(+: sum2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PRUNERS/archer/test/reduction/parallel-reduction-nowait/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  edit_image(image);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/henne90gen/openmp-workshop/07_image_processing/1"}
{"code": "for (j = 0x7fffffffffffffffLL - 20000ULL; (0x7fffffffffffffffLL + 10000ULL) >= j; j += 10000ULL)\n{\n  if (j == (0x7fffffffffffffffLL - 20000ULL))\n    set(4, 0);\n  else\n    if (j == (0x7fffffffffffffffLL - 10000ULL))\n    set(4, 1);\n  else\n    if (j == 0x7fffffffffffffffLL)\n    set(4, 2);\n  else\n    if (j == (0x7fffffffffffffffLL + 10000ULL))\n    set(4, 3);\n  else\n    e = 1;\n\n\n\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-12/4"}
{"code": "for (int counter = 0; counter < 100; counter++)\n{\n  LARGE_INTEGER t1;\n  LARGE_INTEGER t2;\n  LARGE_INTEGER tc;\n  QueryPerformanceFrequency(&tc);\n  FILE *fp;\n  int w;\n  int h;\n  int i;\n  if (((fp = fopen(argv[1], \"r\")) == 0) && (argc == 1))\n  {\n  }\n  else\n  {\n    if (read_pgm_hdr(fp, &w, &h) != (-1))\n    {\n      struct image img;\n      struct image img_gauss;\n      struct image img_out;\n      img.width = w;\n      img.height = h;\n      unsigned char *img_data = malloc((w * h) * (sizeof(char)));\n      for (i = 0; i < (w * h); i++)\n      {\n        img_data[i] = fgetc(fp);\n      }\n\n      img.pixel_data = img_data;\n      img_out.width = (img_gauss.width = w);\n      img_out.height = (img_gauss.height = h);\n      unsigned char *img_gauss_data = malloc((w * h) * (sizeof(char)));\n      img_gauss.pixel_data = img_gauss_data;\n      unsigned char *img_out_data = malloc((w * h) * (sizeof(char)));\n      img_out.pixel_data = img_out_data;\n      QueryPerformanceCounter(&t1);\n      gaussian_noise_reduce(&img, &img_gauss);\n      canny_edge_detect(&img_gauss, &img_out);\n      QueryPerformanceCounter(&t2);\n      printf(\"%f\\n\", ((t2.QuadPart - t1.QuadPart) * 1.0) / tc.QuadPart);\n      write_pgm_image(&img_out);\n      free(img_data);\n      free(img_gauss_data);\n      free(img_out_data);\n    }\n    else\n    {\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMShek/Canny-SIMD/\u4e32\u884cCanny\u7b97\u6cd5/canny1/canny1/example/0"}
{"code": "for (i = 0; i < (1 << TOTAL_KEYS_LOG_2); i++)\n{\n  x = randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/IS/is/14"}
{"code": "for (int i = 0; i < extrar; ++i)\n  prows[i] = (splitr + 1) * cols;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Arrays/convolution2D/mpi1/5"}
{"code": "for (i = 1; i <= m; i++)\n{\n  grid[i + (0 * (m + 2))] = 0;\n  grid[i + ((n + 1) * (m + 2))] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/plloaao/lifegame_and_openmp/lifegame_omp/8"}
{"code": "for (size_t i = 0; i < data_size; ++i)\n{\n  for (size_t d = 0; d < dimensions; ++d)\n  {\n    double coord;\n    input >> coord;\n    (*data)[i][d] = coord;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/7"}
{"code": "for (int i = 0; i < alignedN; i += 16)\n  _mm512_storeu_ps(&z[i], _mm512_add_ps(_mm512_mul_ps(_mm512_loadu_ps(&x[i]), scalar), _mm512_loadu_ps(&y[i])));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/13"}
{"code": "for (int i = 0; i < len_vec; i++)\n{\n  i_bin = bin_finder(&vec[i], len_bin, min, max);\n  omp_set_lock(&hist_lock[i_bin]);\n  histogram[i_bin]++;\n  omp_unset_lock(&hist_lock[i_bin]);\n}\n\n", "pragma": "#pragma omp parallel for private(i_bin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/6"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  aResiduals[v] = 0.0f;\n  workListCurr[v] = 1;\n  workListNext[v] = 0;\n  activeVertices++;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    u = Nodes->dest;\n    Nodes = Nodes->next;\n    if (graph->vertices[u].out_degree)\n      aResiduals[v] += 1.0f / graph->vertices[u].out_degree;\n\n  }\n\n  aResiduals[v] = ((1.0f - stats->damp) * stats->damp) * aResiduals[v];\n}\n\n", "pragma": "omp parallel for private(Nodes,degree,v,j,u) shared(stats,workListCurr,workListNext,aResiduals) reduction(+:activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/39"}
{"code": "for (unsigned int var = 0; var < quesAfterDup[proc].size(); var++)\n{\n  if (quesAfterDup[proc].at(var).getTId() == task)\n  {\n    return quesAfterDup[proc].at(var);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/3"}
{"code": "for (size_t i = available_blocks_should_be; i < (available_blocks_should_be + 5); i++)\n{\n  const void *pointer = chunk.pGetData() + ((i * block_size_after_alignment) / (sizeof(BlockType)));\n  (((KRATOS_CHECK_EQUAL(chunk.Has(pointer), false) << chunk) << \" should Not have the pointer \") << pointer) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/tests/cpp_tests/sources/test_chunk/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  loop_1[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/parallel-region-with-multiple-loops/parallel-region-with-multiple-loops/9"}
{"code": "for (int i = 0; i < sampleSize; i++)\n{\n  double serial = serial_multiplication(n);\n  double parallel = parallel_for_multiplication(n);\n  sum1 += serial;\n  sum2 += parallel;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vini2/ParallelMatrixMultiplicationUsingOpenMP/old files/MatrixMultiplier/3"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  vcomplexe cc = v[i];\n  printf(\"(%f, %f) \", cc.REEL, cc.IMAG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/swap/9"}
{"code": "for (i = 0; i < N; i++)\n  if (((a[i] - b[i]) > 0.000001) || ((b[i] - a[i]) > 0.000001))\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.51.4/1"}
{"code": "for (int i = 0; i < classcount; i++)\n{\n  if (classname == classes[i])\n    return i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhantkulkarni/parallelmachinelearning/Code/Naive Bayesian/parallelnaive/6"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < width; k++)\n    {\n      double x = a[(i * width) + k];\n      double y = b[(k * width) + j];\n      sum += x * y;\n    }\n\n    c[(i * width) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa22/mmGPU/0"}
{"code": "for (i = 0; i < (n + m); i++)\n{\n  printf(\" %g\", res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Oidlichtnwoada/ParallelMergesort/parmerge_tester/5"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (v[i] > max)\n  {\n    max = v[i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) shared(v) reduction(max: max) num_threads(nt)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-zanetti/Openmp-foundmax-reduction-C/ompmaxred/0"}
{"code": "for (unsigned int j = pairs.size(); j > 1; j--)\n  for (unsigned int i = 0; i < (pairs.size() - 1); i++)\n{\n  if (pairs[i].second > pairs[i + 1].second)\n  {\n    temp = pairs[i];\n    pairs[i] = pairs[i + 1];\n    pairs[i + 1] = temp;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main/1"}
{"code": "for (m = 0; m < no_threads; m++)\n  pthread_join(threads[m], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hgn/openmp-benchmark/para-bench/6"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    res(i, j) = this->mat[i][j] + obj(i, j);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/3"}
{"code": "for (int i = 0; i < 4096; ++i)\n{\n  for (int j = 0; j < 4096; ++j)\n  {\n    for (int k = 0; k < 4096; ++k)\n    {\n      c[i][k] += a[i][j] * b[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JerryMouseZ/parallel-matrix-multiplication/omp_matrix/0"}
{"code": "for (int i = 0; i < n; i++)\n  b[i] = PRF(i, seed);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/OMP/cg/5"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  for (int i = 0; i < (wf.n1 + 2); i++)\n  {\n    const int index = wf.in2(j, i);\n    d.v_1D[i] = p.ABV_V[index];\n    d.wf_1D[i] = wf.wave[index];\n  }\n\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    if (gauge == lengthgauge)\n    {\n      arg_B = 0.;\n      arg_V = (idt * .5) * (((-wf.x1[i]) * field) + d.v_1D[i]);\n    }\n    else\n      if (gauge == velocitygauge)\n    {\n      arg_B = f_arg_B * ((-field) * one_by_lightC_au);\n      arg_V = (idt * .5) * d.v_1D[i];\n    }\n\n\n    tridag_low_Fast = arg_A - arg_B;\n    d.tridag_mid[i] = (1. - (2. * arg_A)) + arg_V;\n    tridag_upp_Fast = arg_A + arg_B;\n    d.wf_1D_rightside[i] = (((-tridag_low_Fast) * d.wf_1D[i - 1]) + (((1. + (2. * arg_A)) - arg_V) * d.wf_1D[i])) - (tridag_upp_Fast * d.wf_1D[i + 1]);\n    if (i == 1)\n    {\n      if (wf.symmetry_x1 == 1)\n      {\n        d.tridag_mid[i] = ((1. - arg_A) - arg_B) + arg_V;\n        d.wf_1D_rightside[i] = (((-tridag_low_Fast) * d.wf_1D[i - 1]) + ((((1. + arg_A) + arg_B) - arg_V) * d.wf_1D[i])) - (tridag_upp_Fast * d.wf_1D[i + 1]);\n      }\n\n      if (wf.symmetry_x1 == (-1))\n      {\n        d.tridag_mid[i] = ((1. - (3. * arg_A)) + arg_B) + arg_V;\n        d.wf_1D_rightside[i] = (((-tridag_low_Fast) * d.wf_1D[i - 1]) + ((((1. + (3. * arg_A)) - arg_B) - arg_V) * d.wf_1D[i])) - (tridag_upp_Fast * d.wf_1D[i + 1]);\n      }\n\n    }\n\n  }\n\n  Tridag_Fast(tridag_low_Fast, d.tridag_mid, tridag_upp_Fast, d.wf_1D_rightside, d.wf_1D_solution, d.gam);\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    wf.wave[wf.in2(j, i)] = d.wf_1D_solution[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  res[i] = n - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Oidlichtnwoada/ParallelMergesort/parmergesort_tester/1"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  const int j = urand() * n;\n  const int k = urand() * n;\n  swap(p[j], p[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/12"}
{"code": "for (j = 1; j <= lenB; ++j)\n{\n  if (FASTA1[i - 1] == FASTA2[j - 1])\n  {\n    compval = SWArray[i - 1][j - 1] + 3;\n  }\n\n  if (compval < (SWArray[i - 1][j] + (-2)))\n  {\n    compval = SWArray[i - 1][j] + (-2);\n  }\n\n  if (compval < (SWArray[i][j - 1] + (-2)))\n  {\n    compval = SWArray[i][j - 1] + (-2);\n  }\n\n  if (compval < 0)\n  {\n    compval = 0;\n  }\n\n  if (FASTA1[i - 1] != FASTA2[j - 1])\n  {\n    if (compval < (SWArray[i - 1][j - 1] + (-3)))\n    {\n      compval = SWArray[i - 1][j - 1] + (-3);\n    }\n\n    if (compval < (SWArray[i - 1][j] + (-2)))\n    {\n      compval = SWArray[i - 1][j] + (-2);\n    }\n\n    if (compval < (SWArray[i][j - 1] + (-2)))\n    {\n      compval = SWArray[i][j - 1] + (-2);\n    }\n\n    if (compval < 0)\n    {\n      compval = 0;\n    }\n\n  }\n\n  SWArray[i][j] = compval;\n  compval = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\t %d\\t\\t %d\\t\\t %d\\n\", i, a[i], b[i], c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A-Nikhil/OpenMP-Programming/Lab_1/vectorAdd/2"}
{"code": "for (int i = 0; i < 2; ++i)\n{\n  sivar += i;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for reduction(+: sivar)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_reduction_codegen/1"}
{"code": "for (int x = 0; x < GRAIN; x++)\n{\n  for (int y = 0; y < GRAIN; y++)\n  {\n    if (current_array[(x * GRAIN) + y] == 1)\n    {\n      current_array[(x * GRAIN) + y] = 0;\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          compute_new_state(i, j);\n          if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n          {\n            for (int k = max(0, x - 1); k <= min(GRAIN - 1, x + 1); k++)\n              for (int l = max(0, y - 1); l <= min(GRAIN - 1, y + 1); l++)\n              next_array[(k * GRAIN) + l] = 1;\n\n\n          }\n\n        }\n\n      }\n\n    }\n    else\n    {\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          if (next_img(i, j) != 0xFFFF00FF)\n          {\n            next_img(i, j) = 0;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/18"}
{"code": "for (j = 0; j < nx; j++)\n{\n  a[j] = b[j] + c[j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/quickstart/smdemo_omp/omplib/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    if (hashTable[i][j])\n    {\n      pHead = hashTable[i][j];\n      if (pHead)\n      {\n        free(pHead->Key);\n        free(pHead);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Songrui9269/Parallel-Programming-Project-2/Step1 WordCount openMP/1"}
{"code": "for (int physicsUpdateIndex = 0; physicsUpdateIndex < 100000; ++physicsUpdateIndex)\n{\n  for (int i = 0; i < 64; ++i)\n  {\n    doublevector positionToBlackHole = {.x = tmpPosition[i].x - (1024 / 2), .y = tmpPosition[i].y - (1024 / 2)};\n    double distToBlackHoleSquared = (positionToBlackHole.x * positionToBlackHole.x) + (positionToBlackHole.y * positionToBlackHole.y);\n    double distToBlackHole = sqrt(distToBlackHoleSquared);\n    doublevector normalizedDirection = {.x = positionToBlackHole.x / distToBlackHole, .y = positionToBlackHole.y / distToBlackHole};\n    double accumulation = 1.0f / distToBlackHoleSquared;\n    tmpVelocity[i].x -= ((accumulation * normalizedDirection.x) * 32) / 100000;\n    tmpVelocity[i].y -= ((accumulation * normalizedDirection.y) * 32) / 100000;\n    tmpPosition[i].x += (tmpVelocity[i].x * 32) / 100000;\n    tmpPosition[i].y += (tmpVelocity[i].y * 32) / 100000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/6"}
{"code": "for (int dest = 0; dest < new_no; ++dest)\n{\n  int src = code_map[dest];\n  const double *src_data = (src >= 0) ? (old_wf[src]) : (means.data());\n  memcpy(wf_[dest], src_data, ni * (sizeof(*src_data)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/4"}
{"code": "for (int k = 0; k < (blockN * blockN); k++)\n{\n  int k1 = k / blockN;\n  int k2 = k % blockN;\n  for (int i = 0; i < blockSize; i++)\n  {\n    for (int j = 0; j < blockSize; j++)\n    {\n      int iLocal = (k1 * blockSize) + i;\n      int jLocal = (k2 * blockSize) + j;\n      tempMat[iLocal][k2] += Mat[iLocal][jLocal] * Vec[jLocal];\n    }\n\n  }\n\n  if (k2 == (blockN - 1))\n  {\n    for (int i = 0; i < blockSize; i++)\n    {\n      for (int j = 0; j < tailSize; j++)\n      {\n        int iLocal = (k1 * blockSize) + i;\n        int jLocal = (blockN * blockSize) + j;\n        tempMat[iLocal][blockN] += Mat[iLocal][jLocal] * Vec[jLocal];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/4/4/5"}
{"code": "for (x = 1; x < (w - 1); ++x)\n{\n  for (y = 1; y < (h - 1); ++y)\n  {\n    int i;\n    int j;\n    int gx = 0;\n    for (i = -1; i < 2; ++i)\n    {\n      for (j = -1; j < 2; ++j)\n      {\n        gx += mattrix_x[i + 1][j + 1] * get_pixel(x + i, y + j, grayscaled_canv).r;\n      }\n\n    }\n\n    int gy = 0;\n    for (i = -1; i < 2; ++i)\n    {\n      for (j = -1; j < 2; ++j)\n      {\n        gy += mattrix_y[i + 1][j + 1] * get_pixel(x + i, y + j, grayscaled_canv).r;\n      }\n\n    }\n\n    Byte grad = (Byte) sqrt((gx * gx) + (gy * gy));\n    set_pixel(x, y, rgb(grad, grad, grad), grad_canv);\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic, IMG_CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lagodiuk/raytracing-render/render/src/canvas/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  char string[200];\n  fgets(string, 200, fp);\n  sscanf(string, \"%lf %lf\", &points[i].x, &points[i].y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Luca-Ferrera/k-means/app_mp/2"}
{"code": "for (int i = 0; i < table_size; i++)\n  table[i] = (i < n) ? (i) : (-1);\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(blockSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bwt-omp/bwt/0"}
{"code": "for (k = 0; k < MATRIX_SIZE; k++)\n  for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < MATRIX_SIZE; j++)\n    matrixResult[i][k] += matrixOne[i][j] * matrixTwo[j][k];\n\n}\n\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AhmadMamduhh/ParallelMatrixMultiplicationRepo/MatrixMultiplicationHybrid/4"}
{"code": "for (int i = 0; i < ans.size(); i++)\n{\n  ans[i] = (-1) * vec1[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector/minus/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  sumlocal += i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/015_critical_example/0"}
{"code": "for (size_t i = 0; i != count; ++i)\n{\n  bodies_indites[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_space_heap/0"}
{"code": "for (int j = start; j <= (end - 1); j++)\n{\n  if (array[j] <= t)\n  {\n    i++;\n    change(&array[i], &array[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/full_assignment/3"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  ws = 0.0;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + kk]);\n    zt1 = (-cimagf(exy[(2 + (3 * j)) + (3 * kj)])) + (crealf(exy[(2 + (3 * j)) + (3 * kj)]) * _Complex_I);\n    zt2 = (-cimagf(exy[(1 + (3 * j)) + (3 * kj)])) + (crealf(exy[(1 + (3 * j)) + (3 * kj)]) * _Complex_I);\n    zt3 = (-cimagf(exy[(3 * j) + (3 * kj)])) + (crealf(exy[(3 * j) + (3 * kj)]) * _Complex_I);\n    zt4 = bxy[(3 * j) + (3 * kj)] - (dth * (dky * zt1));\n    zt5 = bxy[(1 + (3 * j)) + (3 * kj)] + (dth * (dkx * zt1));\n    zt6 = bxy[(2 + (3 * j)) + (3 * kj)] - (dth * ((dkx * zt2) - (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exy[(3 * j) + (3 * kj)] + (cdt * (dky * zt1))) - (afdt * cu[(3 * j) + (3 * kj)]);\n    zt8 = (exy[(1 + (3 * j)) + (3 * kj)] - (cdt * (dkx * zt1))) - (afdt * cu[(1 + (3 * j)) + (3 * kj)]);\n    zt9 = (exy[(2 + (3 * j)) + (3 * kj)] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[(2 + (3 * j)) + (3 * kj)]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exy[(3 * j) + (3 * kj)] = zt7;\n    exy[(1 + (3 * j)) + (3 * kj)] = zt8;\n    exy[(2 + (3 * j)) + (3 * kj)] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n    bxy[(3 * j) + (3 * kj)] = zt4;\n    bxy[(1 + (3 * j)) + (3 * kj)] = zt5;\n    bxy[(2 + (3 * j)) + (3 * kj)] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    zt1 = (-cimagf(exy[(2 + (3 * j)) + (3 * k1)])) + (crealf(exy[(2 + (3 * j)) + (3 * k1)]) * _Complex_I);\n    zt2 = (-cimagf(exy[(1 + (3 * j)) + (3 * k1)])) + (crealf(exy[(1 + (3 * j)) + (3 * k1)]) * _Complex_I);\n    zt3 = (-cimagf(exy[(3 * j) + (3 * k1)])) + (crealf(exy[(3 * j) + (3 * k1)]) * _Complex_I);\n    zt4 = bxy[(3 * j) + (3 * k1)] + (dth * (dky * zt1));\n    zt5 = bxy[(1 + (3 * j)) + (3 * k1)] + (dth * (dkx * zt1));\n    zt6 = bxy[(2 + (3 * j)) + (3 * k1)] - (dth * ((dkx * zt2) + (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exy[(3 * j) + (3 * k1)] - (cdt * (dky * zt1))) - (afdt * cu[(3 * j) + (3 * k1)]);\n    zt8 = (exy[(1 + (3 * j)) + (3 * k1)] - (cdt * (dkx * zt1))) - (afdt * cu[(1 + (3 * j)) + (3 * k1)]);\n    zt9 = (exy[(2 + (3 * j)) + (3 * k1)] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[(2 + (3 * j)) + (3 * k1)]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exy[(3 * j) + (3 * k1)] = zt7;\n    exy[(1 + (3 * j)) + (3 * k1)] = zt8;\n    exy[(2 + (3 * j)) + (3 * k1)] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 += dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n    bxy[(3 * j) + (3 * k1)] = zt4;\n    bxy[(1 + (3 * j)) + (3 * k1)] = zt5;\n    bxy[(2 + (3 * j)) + (3 * k1)] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n  }\n\n  afdt = adt * cimagf(ffc[kk]);\n  zt1 = (-cimagf(exy[2 + (3 * kj)])) + (crealf(exy[2 + (3 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(exy[3 * kj])) + (crealf(exy[3 * kj]) * _Complex_I);\n  zt4 = bxy[3 * kj] - (dth * (dky * zt1));\n  zt6 = bxy[2 + (3 * kj)] + (dth * (dky * zt3));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exy[3 * kj] + (cdt * (dky * zt1))) - (afdt * cu[3 * kj]);\n  zt9 = (exy[2 + (3 * kj)] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * kj)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exy[3 * kj] = zt7;\n  exy[1 + (3 * kj)] = zero;\n  exy[2 + (3 * kj)] = zt9;\n  ws += anorm * ((zt7 * conjf(zt7)) + (zt9 * conjf(zt9)));\n  zt4 -= dth * (dky * zt1);\n  zt6 += dth * (dky * zt3);\n  bxy[3 * kj] = zt4;\n  bxy[1 + (3 * kj)] = zero;\n  bxy[2 + (3 * kj)] = zt6;\n  wp += anorm * ((zt4 * conjf(zt4)) + (zt6 * conjf(zt6)));\n  bxy[3 * k1] = zero;\n  bxy[1 + (3 * k1)] = zero;\n  bxy[2 + (3 * k1)] = zero;\n  exy[3 * k1] = zero;\n  exy[1 + (3 * k1)] = zero;\n  exy[2 + (3 * k1)] = zero;\n  sum1 += ws;\n  sum2 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,dkx,afdt,zt1,zt2,zt3,zt4,zt5,zt6,zt7,zt8, zt9,ws,wp) reduction(+:sum1,sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/11"}
{"code": "for (int i = 0; i < omp_get_num_threads(); ++i)\n{\n  if (a[min_array[i]] < a[global_min_index])\n    global_min_index = min_array[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP Tasks/q1_w/2"}
{"code": "for (int k = 0; k < (8 - 1); k++)\n{\n  int start = end[k] + 1;\n  int endd = end[k + 1] - 1;\n  int last_val = a[end[k]];\n  for (int j = start; j < endd; j++)\n    a[j] += last_val;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlirezaAK2000/Multicore-Programming/LAB4/hist/1"}
{"code": "for (int i = 0; i < (nov - 1); i++)\n{\n  double errorSum = 0;\n  double errorValue = 0;\n  int rowIndex = xadj[i];\n  for (; rowIndex < xadj[i + 1]; rowIndex++)\n  {\n    errorSum += cv[adj[rowIndex]] * rv[i];\n    errorValue = abs(1.0 - errorSum);\n  }\n\n  if (errorValue > maxErrorSum)\n  {\n    maxErrorSum = errorValue;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided) reduction(max \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kayagokalp/Sinkhorn-Knopp-Parallel-OpenMP/scalesk_hw1/2"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    ASSERT(rowind[j] < ncols);\n    collen[rowind[j]]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/31"}
{"code": "for (int j = 1; j < i; j++)\n{\n  int row = i - j;\n  if ((row < nr_rows) && (j < nr_cols))\n  {\n    parallel_matrix[row][j] = ((fabs(sin(parallel_matrix[row][j - 1])) + fabs(sin(parallel_matrix[row - 1][j - 1]))) + fabs(sin(parallel_matrix[row - 1][j]))) * 100;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FatbardhKadriu/OpenMP-StencilCode/src/stencil/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%f\\t\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/4.Eigen_Vector_Values/eigen/9"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double mi;\n  if (PTYPE[i] == 1)\n    mi = DNS_FL1;\n  else\n    mi = DNS_FL2;\n\n  double pressure = 0.0;\n  if (particleBC[i] == inner)\n  {\n    pressure = ((pndi[i] - pndSmallZero) * coeffPressEMPS) * mi;\n  }\n\n  if (pressure < 0.0)\n  {\n    pressure = 0.0;\n  }\n\n  press[i] = pressure;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/49"}
{"code": "for (i = 0; i < genomeSize; i++)\n{\n  genome1[i] = townsOrder[r1 + i];\n  genome2[i] = parent->townsOrder[r1 + i];\n  child1->townsOrder[r1 + i] = genome2[i];\n  child1->townsOrder[r1 + i] = genome2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/5"}
{"code": "for (i = 1; i < commSize; i++)\n{\n  myStart = (chunkSize / 9000) * (i - 1);\n  myEnd = myStart + (chunkSize / 9000);\n  MPI_Send(&myStart, 1, (MPI_Datatype) 0x4c000405, i, 0, 1);\n  MPI_Send(&myEnd, 1, (MPI_Datatype) 0x4c000405, i, 1, 1);\n  MPI_Send(&chunkSize, 1, (MPI_Datatype) 0x4c000405, i, 2, 1);\n  printf(\"Sent chunk data to node %d\\n\", i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JRWynneIII/Mandelbrot/openmp_mpi_mandelbrot/1"}
{"code": "for (int i = 0; i < (K + 1); i++)\n{\n  w[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TalPeretz94/Binary-Classification/CudaMPIOpenMP_onVDI/algorithm/1"}
{"code": "for (i1 = l1; i1 < u1; ++i1)\n  for (i2 = l2; i2 < u2; ++i2)\n  for (i3 = l3; i3 < u3; ++i3)\n  for (i4 = l4; i4 < u4; ++i4)\n  for (i5 = l5; i5 < u5; ++i5)\n  for (i6 = l6; i6 < u6; ++i6)\n  b[i1][i2][i3][i4][i5][i6] = a[i1][i2][i3][i4][i5][i6] + i3;\n\n\n\n\n\n\n", "pragma": "omp target teams distribute parallel for collapse(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-nwchem-s1_1/clang-nwchem-s1_1/0"}
{"code": "for (col = 0; col < MAXCOL; col++)\n{\n  int nei = 0;\n  int c;\n  int r;\n  for (r = row - 1; r <= (row + 1); r++)\n    for (c = col - 1; c <= (col + 1); c++)\n  {\n    if ((((r < 0) || (r >= MAXROW)) || (c < 0)) || (c >= MAXCOL))\n      continue;\n\n    if (allmap[(r * MAXCOL) + c] == ALIVE)\n      nei++;\n\n  }\n\n\n  if (allmap[(row * MAXCOL) + col] == ALIVE)\n    nei--;\n\n  switch (nei)\n  {\n    case 0:\n\n    case 1:\n\n    case 4:\n\n    case 5:\n\n    case 6:\n\n    case 7:\n\n    case 8:\n      newallmap[(row * MAXCOL) + col] = DEAD;\n      break;\n\n    case 2:\n      newallmap[(row * MAXCOL) + col] = allmap[(row * MAXCOL) + col];\n      break;\n\n    case 3:\n      newallmap[(row * MAXCOL) + col] = ALIVE;\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"GOL\" with OMP and MPI/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = rand();\n    b[i][j] = rand();\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mohrobati/OpenMP/MatrixMultiplication/parallel/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j][k1]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/198"}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (x[i] * y[i]);\n}\n\n", "pragma": "#pragma omp parallel for default(none) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/5"}
{"code": "for (int tmp_size = size; tmp_size > 1; tmp_size /= 2, m++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/11. filter (parallel)/fft/0"}
{"code": "for (int I = 0; I < Dimension; I++)\n  newArray[I] = Source[I];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Parallel-Programming/Jacobi_openMP/EquationsLinearSystem/1"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n  scanf(\"%d\", &first[m][n]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/husainhz7/Parallel-OpenMP-PrefixScan-MatrixMult/parallel_matrix/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    if (getRandomValue() <= 35)\n      *((table + (i * size)) + j) = '#';\n    else\n      *((table + (i * size)) + j) = '.';\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arielfreire/conways-game-of-life/jogo_da_vida/0"}
{"code": "for (k = 0; k < div; k++)\n{\n  for (i = 0; i < num_volatility; i++)\n    op[k].implied_vol[i] = newton_raphson(op[k].V_market[i][0], low_vol, epsilon, op[k].S, op[k].K[i], op[k].r, op[k].T, op[k].V_market[i][1]);\n\n}\n\n", "pragma": "omp parallel for default(private) shared(low_vol, epsilon, op) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DomenicoNatella/implied_volatility/implied_vol_newton_ver2/0"}
{"code": "for (int i = 0; i < 4; i++)\n  pi += partial_sums[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/Q5-Calculation-of-pi/2"}
{"code": "for (int col = k; col < size; col++)\n  U[row][col] = U[row][col] - (L[row][k] * U[k][col]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/5"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  val = (rand() % d) + c;\n  vec.push_back(val);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(nt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhasamritasarmah/mpi_openmp_programming_basics/mpi_omp_drakes_equation_problem_formulation/2"}
{"code": "for (int i = 0; i < rank; i++)\n  x_k[i] = b[i] / A[(i * rank) + i];\n\n", "pragma": "omp parallel for schedule(static) num_threads(nTreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    Ex.row(i) += X.row(j) * kernel_matrix_x(i, j);\n  }\n\n  Ex.row(i) /= Kx(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_local_solver/0"}
{"code": "for (ny = 0; ny < n; ny += block_size)\n{\n  pe += eval_pef_sub_level_2(n, delta, grav, sep, fcon, x, y, z, fx, fy, fz, nx, ny, block_size);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abu-abraham/open-MP/examples/Cloth Simulation/kernel_main_omp_block/0"}
{"code": "for (j = 1 << (l - 1); j <= ((1 << l) - 1); j++)\n{\n  if ((j % 2) == 0)\n  {\n    b->tab[j] = b->tab[j / 2];\n  }\n  else\n  {\n    b->tab[j] = fmax(b->tab[j / 2], a->tab[j - 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/8"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (cj = ci + 1; cj < NCELLS; cj++)\n  {\n    contactDistance = lenscales.at(ci) + lenscales.at(cj);\n    centerDistance = 0.0;\n    for (d = 0; d < NDIM; d++)\n    {\n      distanceVec.at(d) = cell(ci).cellDistance(cell(cj), d);\n      centerDistance += pow(distanceVec.at(d), 2);\n    }\n\n    if ((contactDistance * contactDistance) > centerDistance)\n    {\n      addContact(ci, cj);\n      centerDistance = sqrt(centerDistance);\n      overlap = centerDistance / contactDistance;\n      ftmp = (factor * (1 - overlap)) / contactDistance;\n      utmp = (factor * 0.5) * pow(1 - overlap, 2);\n      for (vi = 0; vi < cell(ci).getNV(); vi++)\n        cell(ci).setUInt(vi, cell(ci).uInt(vi) + ((0.5 * utmp) / cell(ci).getNV()));\n\n      for (vi = 0; vi < cell(cj).getNV(); vi++)\n        cell(cj).setUInt(vi, cell(cj).uInt(vi) + ((0.5 * utmp) / cell(cj).getNV()));\n\n      for (d = 0; d < NDIM; d++)\n      {\n        uv = distanceVec.at(d) / centerDistance;\n        cell(ci).setCForce(d, cell(ci).cforce(d) - (ftmp * uv));\n        cell(cj).setCForce(d, cell(cj).cforce(d) + (ftmp * uv));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/119"}
{"code": "for (; i < individualsNo; i++)\n{\n  result += individuals[i].toString();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/19"}
{"code": "for (int i = 0, n = DistTables.size(); i < n; i++)\n  DistTables[i]->update(iat);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/22"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  *(array->tab + i) = rand() % N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/19"}
{"code": "for (i = 0; i < New_size; i++)\n{\n  for (j = 0; j < New_size; j++)\n  {\n    k = i + New_size;\n    a11[i][j] = a[i][j];\n    a12[i][j] = a[i][j + New_size];\n    a21[i][j] = a[k][j];\n    a22[i][j] = a[k][j + New_size];\n    b11[i][j] = b[i][j];\n    b12[i][j] = b[i][j + New_size];\n    b21[i][j] = b[k][j];\n    b22[i][j] = b[k][j + New_size];\n  }\n\n}\n\n", "pragma": "  #pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pesfahanian/Parallel_Strassen/Strassan Matrix Multiplication Final/3"}
{"code": "for (; i < n; i++)\n{\n  temp = mat[i][k];\n  for (int j = k + 1; j < n; j++)\n  {\n    mat[i][j] -= temp * mat[k][j];\n  }\n\n  mat[i][k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/1"}
{"code": "for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4 += 1)\n{\n  __pyx_v_idx = __pyx_t_4;\n  __pyx_v_strides[__pyx_v_idx] = __pyx_v_stride;\n  __pyx_v_stride = __pyx_v_stride * __pyx_v_shape[__pyx_v_idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/16"}
{"code": "for (int i = 0; i < n; ++i)\n  fscanf(file, \"%lf \", &r[i]);\n\n", "pragma": "omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  out += (((((((\"for (int \" + iter_i(i)) + \" = 0; \") + iter_i(i)) + \" < \") + iter_Ni(i)) + \"; \") + iter_i(i)) + \"++ )\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/einsxiao/evawiz/evawiz/src/evacc/syntax_launch_kernel/7"}
{"code": "for (i = 0; i < 5; i++)\n{\n  a[i] += i;\n  printf(\"thread id: %d\\n\", omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp4/masterbarrier/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float prevPageRank = stats->pageRanks[v];\n  float nextPageRank = stats->base_pr + (stats->damp * pageRanksNext[v]);\n  stats->pageRanks[v] = nextPageRank;\n  pageRanksNext[v] = 0;\n  double error = fabs(nextPageRank - prevPageRank);\n  error_total += error / graph->num_vertices;\n  if (error >= arguments->epsilon)\n  {\n    activeVertices++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) shared(arguments, pageRanksNext,stats) reduction(+ : error_total, activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/11"}
{"code": "for (int j = 0; j < COLS; j++)\n{\n  int indexTrain = (784 * i) + j;\n  int indexTest = (784 * testRow) + j;\n  sum += (train[indexTrain] - test[indexTest]) * (train[indexTrain] - test[indexTest]);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(NUM_THREADS) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michal-dom/knn_with_openMP/main/7"}
{"code": "for (int k = 0; k < n; k++)\n{\n  int preprocessnumber = ((n - k) - 1) % 4;\n  int begin = (k + 1) + preprocessnumber;\n  float head[4] = {A[k][k], A[k][k], A[k][k], A[k][k]};\n  t2 = _mm_loadu_ps(head);\n  for (int j = k + 1; j < ((k + 1) + preprocessnumber); j++)\n  {\n    A[k][j] = A[k][j] / A[k][k];\n  }\n\n  for (int j = begin; j < n; j += 4)\n  {\n    t1 = _mm_loadu_ps(A[k] + j);\n    t1 = _mm_div_ps(t1, t2);\n    _mm_storeu_ps(A[k] + j, t1);\n  }\n\n  A[k][k] = 1;\n  t1 = _mm_setzero_ps();\n  t2 = _mm_setzero_ps();\n  for (int i = k + 1; i < n; i++)\n  {\n    for (int j = k + 1; j < ((k + 1) + preprocessnumber); j++)\n    {\n      A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n    }\n\n    A[i][k] = 0;\n  }\n\n  for (int i = k + 1; i < n; i++)\n  {\n    float head1[4] = {A[i][k], A[i][k], A[i][k], A[i][k]};\n    t3 = _mm_loadu_ps(head1);\n    for (int j = begin; j < n; j += 4)\n    {\n      t1 = _mm_loadu_ps(A[k] + j);\n      t2 = _mm_loadu_ps(A[i] + j);\n      t1 = _mm_mul_ps(t1, t3);\n      t2 = _mm_sub_ps(t2, t1);\n      _mm_storeu_ps(A[i] + j, t2);\n    }\n\n    A[i][k] = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/7"}
{"code": "for (i = 0; i < 100000; i++)\n  if (Buyers[i].quantityHeld == 1)\n  numberBought++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp2/3"}
{"code": "for (j = 3; j <= (grid_points[1] - 4); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/66"}
{"code": "for (i = 0; i < comm_sz; i++)\n{\n  counts[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/3"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum[id] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhbink/OpenMP-Caculating-Pi/code/201614790222/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  if ((*class) == 'U')\n  {\n    printf(\"          %2d%20.13e\\n\", m, xce[m]);\n  }\n  else\n    if (xcedif[m] > epsilon)\n  {\n    *verified = 0;\n    printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, xce[m], xceref[m], xcedif[m]);\n  }\n  else\n  {\n    printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, xce[m], xceref[m], xcedif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/153"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    b[i][j] = a[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gaurav047/High-Performance-Computing---OpenMP/Livemore Laboratory Codes/mxm_openMP/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (j = 0; j < m; j++)\n    if (v_trunc[i] == result[j])\n    break;\n\n\n  if (j == m)\n  {\n    result[m] = v_trunc[i];\n    m++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeGiacomoSimoes/OpenMP/vector_parallel_print/7"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = 0;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], position_phi);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      position3_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r2_size[i]) - (0.5 * hydro_data->r2_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, hydro_data->r2[i] + position3_rand);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/19"}
{"code": "for (i = 0; i < 11; i++)\n{\n  printf(\"Static Hello World %d\\n\", i);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-dynamic/0"}
{"code": "for (unsigned int i = 0; i < eventListProb.size(); i++)\n{\n  productEventListProb *= eventListProb[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/Proj/ompdice/4"}
{"code": "for (int i = 0; i < 50; i++)\n{\n  printf(\"%d \", nums[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/woshildh/OpenMPLearning/parallel/parallel/1"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    p[i][j] = 0.0;\n    p_new[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Laplace Equation/2-D_Laplace_Equation/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (solution->matching[i] == (-1))\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (((i != j) && solution->graph[i][j]) && (solution->matching[j] == (-1)))\n      {\n        solution->matching[i] = j;\n        solution->matching[j] = i;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xelaadryth/Edmonds-Parallel/OMP/src/eba/2"}
{"code": "for (uint s = 0; s < files; s++)\n{\n  ulong cur = s * blocksize;\n  for (ulong j = 0; j < blocksize; j++)\n  {\n    coeff[j] = (int) nmod_poly_get_coeff_ui(poly, cur++);\n    if (coeff[j] > half)\n    {\n      coeff[j] -= mod;\n    }\n\n  }\n\n  sprintf(name, \"%s%u\", resultname, s);\n  int fd = open(name, O_RDWR | O_CREAT, 0644);\n  if (fd == (-1))\n  {\n    perror(\"In nmod_poly_to_files: unable to open a file for reading.\\n\");\n    exit(1);\n  }\n\n  ftruncate(fd, (sizeof(int)) * blocksize);\n  int *file = (int *) mmap(0, (sizeof(int)) * blocksize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n  if (file == MAP_FAILED)\n  {\n    perror(\"In nmod_poly_to_files: mapping failed when writing.\\n\");\n    exit(1);\n  }\n\n  memcpy(file, coeff, (sizeof(int)) * blocksize);\n  munmap(file, (sizeof(int)) * blocksize);\n  close(fd);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amosunov/polymult-1.3/init/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    b[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/MatrixMul/3"}
{"code": "for (int i = 0; i < layer0->nweights; i++)\n{\n  layer0->weights[i] = scale * rand_normal();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/0"}
{"code": "for (i = 0; i < 30; i++)\n{\n  printf(\"%f\\n\", B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/testomp/3"}
{"code": "for (int freq = 0; freq < 5; freq++)\n{\n  double time = gemm_transpose(a, b, c, size);\n  counts.push_back(time);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_transpose/1"}
{"code": "for (int i = 0; i < (3 - 1); i++)\n{\n  if (row[i] != row[i + 1])\n  {\n    return -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/tictactoe_root/3"}
{"code": "for (int i = 0; i < 64; i += 4)\n{\n  c = c + (b != (7 + ((i / 4) * 3)));\n  foo(&b, &i, &i, 3);\n}\n\n", "pragma": "omp parallel for simd schedule (static, 4) linear(b:3) reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-17/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += a[i];\n  s[i] = sum;\n}\n\n", "pragma": "        #pragma omp for schedule(static) nowait ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Parushgit/Parallel-codes-using-OpenMP/TestParallel/0"}
{"code": "for (int i = 0; i < zSize; i++)\n{\n  unsigned nbits = 0;\n  while (n >> nbits)\n    nbits++;\n\n  size_t k = 1ULL << (nbits - 1);\n  T z = acc_z[i];\n  size_t idx = (acc_a[k] <= z) ? (k) : (0);\n  while (k >>= 1)\n  {\n    size_t r = idx | k;\n    size_t w = (r < n) ? (r) : (n);\n    if (z >= acc_a[w])\n    {\n      idx = r;\n    }\n\n  }\n\n  acc_r[i] = idx;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bsearch-omp/main/2"}
{"code": "for (size_t comp = 0; comp < TDim; ++comp)\n{\n  for (size_t i_node = 0; i_node < rGeometry.PointsNumber(); ++i_node)\n  {\n    rNormal(comp) += DN_DX(i_node, comp) * rElementalDistances[i_node];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/processes/calculate_discontinuous_distance_to_skin_process/6"}
{"code": "for (i = 0; i < Tam; i++)\n{\n  for (j = 0; j < Tam; j++)\n  {\n    C[i][j] = A[i][j] - B[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 3/Trab3_Strassen_OMP/4"}
{"code": "for (int i = 0; i < mn; i++)\n{\n  b[i] = a[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/23"}
{"code": "for (int e = 0; e < experTime; e++)\n{\n  times[e] = scale_omp(input, output, len);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/3"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  long ival = ((long) (x[i] - xlow)) / bucket_width;\n  omp_set_lock(&hist_lcks[ival]);\n  hist[ival]++;\n  omp_unset_lock(&hist_lcks[ival]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Solutions/hist_par/1"}
{"code": "for (i = 0; i < dim; i++)\n  x[i] = libre[i] / mat[i][i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Scientific Computing/sources/openmp_gj_old/gaussJ-omp-fast/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  m_zero(LB);\n  for (j = 0; j < M; j++)\n  {\n    double s = ((double) j) / ((double) M);\n    double a;\n    double b;\n    double c;\n    double d;\n    a = (((((((-1.0) * s) * s) * s) + ((3.0 * s) * s)) - (3.0 * s)) + 1.0) / 6.0;\n    b = (((((3.0 * s) * s) * s) - ((6.0 * s) * s)) + 4.0) / 6.0;\n    c = (((((((-3.0) * s) * s) * s) + ((3.0 * s) * s)) + (3.0 * s)) + 1.0) / 6.0;\n    d = ((s * s) * s) / 6.0;\n    m_set_val(LB, j, aindex[i], a);\n    m_set_val(LB, j, bindex[i], b);\n    m_set_val(LB, j, cindex[i], c);\n    m_set_val(LB, j, dindex[i], d);\n  }\n\n  int m;\n  int n;\n  for (m = i * M; m < ((i + 1) * M); m++)\n    for (n = 0; n < N; n++)\n    m_set_val(B, m, n, m_get_val(LB, m % M, n));\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/11"}
{"code": "for (wJ = wI; wJ < (wI + (SMALLN / 4)); wJ += 4)\n{\n  wV1 = _mm_load_ps(&aVect1[wJ]);\n  wV2 = _mm_load_ps(&aVect2[wJ]);\n  wV3 = _mm_add_ps(wV1, wV2);\n  _mm_store_ps(&aVect3[wJ], wV3);\n}\n\n", "pragma": "omp parallel for firstprivate(wI) private(wJ, wV1, wV2, wV3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vects/2"}
{"code": "for (i = 0; i < 4000; i++)\n{\n  for (j = 0; j < 4000; j++)\n  {\n    fscanf(fptr, \"%lld\", &a[i][j]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 5 & 6/matmulpar/0"}
{"code": "for (j = 0; j < 40000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/0"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i - 1][j][k][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/82"}
{"code": "for (i = 0; i < 512; i = i + 8)\n{\n  dot += X[i] * Y[i];\n  dot += X[i + 1] * Y[i + 1];\n  dot += X[i + 2] * Y[i + 2];\n  dot += X[i + 3] * Y[i + 3];\n  dot += X[i + 4] * Y[i + 4];\n  dot += X[i + 5] * Y[i + 5];\n  dot += X[i + 6] * Y[i + 6];\n  dot += X[i + 7] * Y[i + 7];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction (+:dot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/3"}
{"code": "for (*i = 0; (*i) < bots_arg_size; (*i)++)\n{\n  if (visited[*i] == 0)\n  {\n    if (omp_in_final() || ort_task_throttling())\n    {\n      void *_itn;\n      int _fip_i = *i;\n      int i = _fip_i;\n      int *_fip_cc = *cc;\n      int *cc = _fip_cc;\n      _itn = ort_task_immediate_start(0);\n      {\n        CC_par(i, *cc);\n        CANCEL_task_153:\n        ;\n\n      }\n      ort_task_immediate_end(_itn);\n    }\n    else\n    {\n      struct __taskenv__\n      {\n        int i;\n        int *cc;\n      };\n      struct __taskenv__ *_tenv;\n      _tenv = (struct __taskenv__ *) ort_taskenv_alloc(sizeof(struct __taskenv__), _taskFunc1_);\n      _tenv->i = *i;\n      _tenv->cc = *cc;\n      ort_new_task(_taskFunc1_, (void *) _tenv, 0, 1);\n    }\n\n    ort_taskwait(0);\n    (*(*cc))++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/concom/src/concom_ompi/7"}
{"code": "for (i = 0; i < n; ++i)\n{\n  j = i;\n  {\n    t += j;\n  }\n}\n\n", "pragma": "omp for ordered reduction(+:t)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kepai91/RMACC_2015/OpenMP/sync/ordered/0"}
{"code": "for (i = 1; i <= N; i++)\n{\n  printf(\"%d\\t\", i);\n  nextTerm = i + j;\n  i = j;\n  j = nextTerm;\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp5/fibonacci/0"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  PM.start(\"Section-B\");\n  x += somekernel();\n  PM.stop(\"Section-B\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/avr-aics-riken/PMlib/doc/src_advanced/parallel_do/0"}
{"code": "for (c = 0; c < 2; ++c)\n  ++this->a, --b, this->c /= 1;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_lastprivate_codegen/2"}
{"code": "for (int n_threads = 1; n_threads <= 32; n_threads = (n_threads <= 8) ? (2 * n_threads) : (n_threads + 4))\n{\n  omp_set_num_threads(n_threads);\n  for (int i = 0; i < n_runs; ++i)\n  {\n    start_time = omp_get_wtime();\n    total_sum = omp_critical_sum(x, size);\n    times[i] = omp_get_wtime() - start_time;\n    if (abs(total_sum - warmup_sum) > 0.001)\n      printf(\"Different results in omp_critical_sum with %2d threads: %f\\n\", n_threads, total_sum);\n\n  }\n\n  double avg;\n  double std_dev;\n  compute_statistics(times, n_runs, &avg, &std_dev);\n  printf(\"omp critical sum (%2d threads) - Average: %fs - Std. deviation: %fs - Sum value: %f\\n\", n_threads, avg, std_dev, total_sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/8"}
{"code": "for (int i = 0; i < k; i++)\n{\n  (((((((((cout << i) << \" \") << (sum1[i] / outClusters[i].size())) << \" \") << (sum2[i] / outClusters[i].size())) << \" \") << (sum3[i] / outClusters[i].size())) << \" \") << (sum4[i] / outClusters[i].size())) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MohamedAhmedIsmail/Kmeans-OpenMp-and-Sequential/K-MeansDC/Source/5"}
{"code": "for (int i = begin[selector ^ 1]; i < end[selector ^ 1]; ++i)\n  unalignData[n++] = data[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/8"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (var[i] != i)\n  {\n    printf(\"Data Race Present\\n\");\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB156-missingordered-orig-gpu-yes/1"}
{"code": "for (int i = 0; i < h.num_bins; i++)\n{\n  sprintf(str, \"%10d\\t\", h.bin_counts[i]);\n  str += 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/epielemeier/oc-openmp-histogram/histogram/4"}
{"code": "for (unsigned int j = 0; j < topology_[i]; j++)\n{\n  float acc = 0;\n  for (unsigned int offset = 0; offset < R; offset++)\n  {\n    acc += outputs_[i - 1][j + offset] * weights_[i - 1][(j * R) + offset];\n  }\n\n  outputs_[i][j] = activationFunction(acc + bias);\n}\n\n", "pragma": "            #pragma omp parallel for num_threads(omp_get_max_threads())\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guyez/Simple-Sparsely-Connected-NN/OpenMP/src/NeuralNet/1"}
{"code": "for (uint doci = 0; doci < total_num_docs; doci++)\n{\n  if (cpu_profileScore[doci] != h_profileScore[doci])\n  {\n    printf(\"FAILED\\n   : doc[%d] score: CPU = %lu, Device = %lu\\n\", doci, cpu_profileScore[doci], h_profileScore[doci]);\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/compute-score-omp/main/5"}
{"code": "for (int i = 0; i < A->m; ++i)\n{\n  assert(levels[i] != INT_MAX);\n  ++prefixSum[levels[i] + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/5"}
{"code": "for (i = 0; i < col; i++)\n{\n  AP[i] = ((double *) AP_grid) + (coarse_pts * i);\n  if (i < coarse_pts)\n  {\n    Acoarse[i] = ((double *) Acoarse_grid) + (coarse_pts * i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/4"}
{"code": "for (i = 0; i < num; i++)\n  y[99]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/main/5"}
{"code": "for (i = its->begin(); i != its->end(); ++i)\n  if ((f->iterator && f->iterator->name_str) && (!strcmp((char *) (*i), (char *) f->iterator->name_str)))\n  break;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/PolyOpt2/polyopt/PastToSage/0"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  temp2 = 0;\n  for (k = 0; k < N; k++)\n    temp2 += L[(i * N) + k] * U[(k * N) + j];\n\n  if ((((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) > 0.1) || (((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) < (-0.1)))\n    temp++;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/5"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  C[i] = (double *) malloc((sizeof(double)) * 1500);\n  B_T[i] = (double *) malloc((sizeof(double)) * 1500);\n  transp_res[i] = (double *) malloc((sizeof(double)) * 1500);\n  seq_res[i] = (double *) malloc((sizeof(double)) * 1500);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/omikulkarni02/OpenMP-Matrix-Multiplication/matrix_multiplication/7"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"%f \", mat[(i * n) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/12_omp_mat_vec_mul/3"}
{"code": "for (unsigned l = 0; l < batchSize; l++)\n{\n  unsigned i = (k * batchSize) + l;\n  A[0] = a[0];\n  A[1] = a[1];\n  A[2] = a[2];\n  B[0] = b[0];\n  B[1] = b[1];\n  B[2] = b[2];\n  C[0] = c[0];\n  C[1] = c[1];\n  C[2] = c[2];\n  D[0] = d[0][i];\n  D[1] = d[1][i];\n  D[2] = d[2][i];\n  E[0] = e[0][i];\n  E[1] = e[1][i];\n  E[2] = e[2][i];\n  F[0] = f[0][i];\n  F[1] = f[1][i];\n  F[2] = f[2][i];\n  penalty(A, B, C, D, E, F, P, Q, &error[l]);\n  p[0][i] = P[0];\n  p[1][i] = P[1];\n  p[2][i] = P[2];\n  q[0][i] = Q[0];\n  q[1][i] = Q[1];\n  q[2][i] = Q[2];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/zoltan/hybrid/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  ffy[0][j] = Q[j + (n * (i + (m * 2)))];\n  ffy[1][j] = (Q[j + (n * (i + (m * 1)))] * Q[j + (n * (i + (m * 2)))]) / Q[j + (n * (i + (m * 0)))];\n  ffy[2][j] = (pow(Q[j + (n * (i + (m * 2)))], 2) / Q[j + (n * (i + (m * 0)))]) + ((g * pow(Q[j + (n * (i + (m * 0)))], 2)) / 2.0);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/3"}
{"code": "for (int thread = 0; thread < threads; thread++)\n{\n  int startRow = (height / threads) * thread;\n  startRow += min(thread, height % threads);\n  BradleyThreshold(image + startRow, res + startRow, width, (height / threads) + (thread < (height % threads)));\n}\n\n", "pragma": "#pragma omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adalbert44/OpenMP/PictureBinarizationOpenMP/PictureBinarizationOpenMP/3"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  arr[i] = sparse5(xadj, adj, i);\n}\n\n", "pragma": "            #pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/6"}
{"code": "for (int q = 0; q < m; q++)\n  hamming_array[q] = (int *) malloc(n * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NekSfyris/OpenMP-pthreads_Hamming/omp_code/omp_1/3"}
{"code": "for (i = 0; i < k; i++)\n{\n  r = (int) (rand() % n);\n  centroids[i].x = points[r].x;\n  centroids[i].y = points[r].y;\n  centroids[i].cluster = i;\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for private(r)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilvitto/KMeans/Main/0"}
{"code": "for (i = 0; i < n; i++)\n  m[i] = (double *) malloc(n * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/puneetar/Parallel-LU-Factorization-with-OpenMP-MPI/OpenMP/OpenMP/4"}
{"code": "for (int i = 0; i < number_of_rectangles; ++i)\n{\n  combined_area += f(lower_limit + (i * rectangle_width));\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: combined_area)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Katherine506/C-OpenMP-MPI/CI0117-2020-S2/Laboratorios/6/riemann_omp/riemann_omp/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  A[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/15"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    d[i][j] = (rand() % 41) - 20;\n    printf(\"%d \", d[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/altzii/parallel-programming/OpenMP/task10/0"}
{"code": "for (int ch = 0; ch < 3; ch++)\n{\n  color[ch] = ((world.lightEnv * world.ka) * obj->material.color[ch]) + ((fatt * source.color[ch]) * (((obj->material.kd * obj->material.color[ch]) * cosTetha) + (obj->material.ks * pow(cosPhi, obj->material.n_shiny))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gabriellgpc/raytracing/raytrace/1"}
{"code": "for (unsigned int idx = 0; idx < _ffpbciparams.size(); idx++)\n{\n  if (type == _ffpbciparams[idx].a)\n    Pa = _ffpbciparams[idx]._dpar[0];\n\n  if (nbr_type == _ffpbciparams[idx].a)\n    Pb = _ffpbciparams[idx]._dpar[0];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/26"}
{"code": "for (int i = 0; i < size_mat; i++)\n{\n  for (int j = 0; j < size_mat; j++)\n  {\n    _MAT[i][j] = val;\n    val++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SboneloMdluli/ELEN4020-Lab2/OpenMP/block_MP/0"}
{"code": "for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n{\n  this_diff = RefOut[i][j] - C[i][j];\n  if (this_diff < 0)\n    this_diff = (-1.0) * this_diff;\n\n  if (this_diff > 0.000000001)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n      maxdiff = this_diff;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/4"}
{"code": "for (i = 0; i < NODE_N; i++)\n{\n  for (j = 0; j < NODE_N; j++)\n  {\n    preOrders[i][j] = orders[i][j];\n    preGraph[i][j] = graph[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/22"}
{"code": "for (unsigned long long int ii = 0; ii < N; ii++)\n  S += array[ii - first_iteration];\n\n", "pragma": "omp for schedule(static) reduction(+:S)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/threads_affinity/07_touch_by_all_threadprivate/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    swap(a[i][j], a[j][i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huxiaotaostasy/OpenMP/code_OpenMP/main/1"}
{"code": "for (int jj = 0; jj < params->ny; jj++)\n{\n  for (int ii = 0; ii < params->nx; ii++)\n  {\n    (*cells_ptr)->speeds[0][ii + (jj * params->nx)] = w0;\n    (*cells_ptr)->speeds[1][ii + (jj * params->nx)] = w1;\n    (*cells_ptr)->speeds[2][ii + (jj * params->nx)] = w1;\n    (*cells_ptr)->speeds[3][ii + (jj * params->nx)] = w1;\n    (*cells_ptr)->speeds[4][ii + (jj * params->nx)] = w1;\n    (*cells_ptr)->speeds[5][ii + (jj * params->nx)] = w2;\n    (*cells_ptr)->speeds[6][ii + (jj * params->nx)] = w2;\n    (*cells_ptr)->speeds[7][ii + (jj * params->nx)] = w2;\n    (*cells_ptr)->speeds[8][ii + (jj * params->nx)] = w2;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jerrykress/Lattice-Boltzmann-OpenMP/d2q9-bgk/2"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/59"}
{"code": "for (i = 0; i < 17; i++)\n{\n  for (j = 0; j <= i; j++)\n  {\n    PTUpdateEntry(arr, i, j, binomialCoeff(i, j));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sendevour/openmp-samples/pascal/0"}
{"code": "for (int iter = 0; iter < 10; iter++)\n{\n  deployAnts();\n  allAntsTour(iter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/1"}
{"code": "for (i = ibeg; i <= ifin; i += 1)\n{\n  iglob = i;\n  for (j = jbeg; j <= jfin; j += 1)\n  {\n    jglob = j;\n    k = ki1;\n    phi1[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n    k = ki2;\n    phi2[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,iglob,jglob,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/67"}
{"code": "for (int i = 0; i < (NX + 2); i++)\n{\n  for (int j = 0; j < (NY + 2); j++)\n  {\n    fprintf(final_file, \"%g %g %g\\n\", x_axis[i], y_axis[j], u_val[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nmac-dev/parallel-2D-advection/src/advection2D/8"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    }\n\n    lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(fac1, m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/94"}
{"code": "for (proc = 0; proc < size; proc++)\n{\n  sprintf(filename, \"../files/mandelbrot_hybrid_static_%d.ppm \", proc);\n  strcat(command, filename);\n  memset(filename, 0, sizeof(filename));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rochii/parallel-mandelbrot/hybrid/scripts/mandelbrot_hybrid_static/1"}
{"code": "for (int i = 0; i < outmat_row_dim; i++)\n{\n  for (int j = 0; j < outmat_col_dim; j++)\n  {\n    printf(\"%d\\t\", outmat[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/max/8"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i++)\n{\n  ru1 = c3c4 * rho_i[i][j][k];\n  cv[i] = us[i][j][k];\n  rhon[i] = ((dx2 + (con43 * ru1)) > (((dx5 + (c1c5 * ru1)) > (((dxmax + ru1) > dx1) ? (dxmax + ru1) : (dx1))) ? (dx5 + (c1c5 * ru1)) : (((dxmax + ru1) > dx1) ? (dxmax + ru1) : (dx1)))) ? (dx2 + (con43 * ru1)) : (((dx5 + (c1c5 * ru1)) > (((dxmax + ru1) > dx1) ? (dxmax + ru1) : (dx1))) ? (dx5 + (c1c5 * ru1)) : (((dxmax + ru1) > dx1) ? (dxmax + ru1) : (dx1)));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/SP/sp_single/0"}
{"code": "for (i = 0; i < MatrixDim; i++)\n{\n  for (j = 0; j < MatrixDim; j++)\n    fprintf(fl, \"%f \", L[(i * MatrixDim) + j]);\n\n  fprintf(fl, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/lud/tools/gen_input.ref/2"}
{"code": "for (int n = 0; n < (N * M); n++)\n{\n  int i = n / N;\n  int j = n % N;\n  dst[n] = src[(M * j) + i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucaAngioloni/ParallelComputingExam/Integral_Images_(final-term)/Code/OpenMP/openmp_integral_image/0"}
{"code": "for (i = 0; i < A->nrow; i++)\n{\n  A->rowStart[i] = i;\n  A->colIndex[i] = i;\n  AF->rowStart[i] = i;\n  AF->colIndex[i] = i;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/cg/9"}
{"code": "for (i = start; i < end; i = i + h)\n{\n  local_area += f(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jskankurgarg/Multicore_OpenMP_CUDA/openMP/integral_no_for_2/1"}
{"code": "for (int i = 0; i < numOfNodes; ++i)\n{\n  int u = nodes[i];\n  assert((u >= 0) && (u < m));\n  bv->atomicClear(u);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/13"}
{"code": "for (j = 0; j < n; j++)\n{\n  a[j] = ((float) rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/maximum/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i)))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/29"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum = sum + (a[i] * b[i]);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_reduction/0"}
{"code": "for (int i = 0; i < p_len; i++)\n{\n  float dist = getDist(p_list[i], center);\n  (((((((((cout << \"|    \") << i) << \"  \\t|   \") << old_dist[i]) << \"    \\t|   \") << dist) << \"    \\t| \") << (old_dist[i] - dist)) << \" \\t| \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lewis98/OpenMP_Tasks/parallelism/main/6"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i)\n{\n  pred_win.add_request(((i - i_start) * 2) + 0, edge_owner[((i - i_start) * 2) + 0], edge_local[((i - i_start) * 2) + 0], ((i - i_start) * 2) + 0);\n  pred_win.add_request(((i - i_start) * 2) + 1, edge_owner[((i - i_start) * 2) + 1], edge_local[((i - i_start) * 2) + 1], ((i - i_start) * 2) + 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/validate/4"}
{"code": "for (i = 672 - 5; i <= (672 - 3); i++)\n{\n  printf(\"[%d,%d]: %5.2f  \", i, i, Temperature[i][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/5"}
{"code": "for (register unsigned int i = 0; i < (N * 2); i += incX + 2)\n{\n  re = re + (((*(XP + i)) * (*(YP + i))) - ((0 - (*((XP + i) + 1))) * (*((YP + i) + 1))));\n  im = im + (((*(XP + i)) * (*((YP + i) + 1))) + ((0 - (*((XP + i) + 1))) * (*(YP + i))));\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:re, im)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/dot/2"}
{"code": "for (int i = 1; i < cfg.num_threads; i++)\n{\n  pre[i] = pre[i - 1] + temp[i - 1].size();\n  total += temp[i].size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankitsultana/parallel-df/src/populate_htables/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n    {\n      rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] - (dssp * (((((-4.0) * u[i][j][k - 1][m_imopVar18]) + (6.0 * u[i][j][k][m_imopVar18])) - (4.0 * u[i][j][k + 1][m_imopVar18])) + u[i][j][k + 2][m_imopVar18]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/26"}
{"code": "for (int i = 0; i < max_cols; i++)\n{\n  for (int j = 0; j < max_rows; j++)\n  {\n    input_itemsets_cpu[(i * max_cols) + j] = 0;\n    input_itemsets_gpu[(i * max_cols) + j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/nw/src/needle/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      matrix[(i * n) + j] = 0;\n    }\n    else\n    {\n      value = 1 + (rand() % MAX);\n      if (value > density)\n      {\n        matrix[(i * n) + j] = INF;\n      }\n      else\n      {\n        matrix[(i * n) + j] = value;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/openmp/1"}
{"code": "for (int i = 0; i < ciphertext.size(); i++)\n{\n  deciphertext.push_back(text[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/Des/parallelImplementation/1"}
{"code": "for (i = 2; i <= sqN; ++i)\n{\n  if (A[i] != 1)\n    continue;\n\n  for (j = 2; (i * j) < N; ++j)\n  {\n    A[i * j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) shared(A, sqN, N) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uprasad/omp/sieve_prime_parallel/0"}
{"code": "for (int i = 0; i < ((nr_class * (nr_class - 1)) / 2); i++)\n  fprintf(fp, \" %g\", model->probB[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/89"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  Arg = 0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/target_teams_distribute_parallel_for_simd_if_codegen/0"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"Proc#%d Num is %d\\n\", omp_get_thread_num(), num);\n\n", "pragma": "\t#pragma omp parallel for firstprivate(num)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR6/LR6_2/0"}
{"code": "for (i = 0; i < (*ph_num); i++)\n{\n  fread(phHolder, sizeof(struct photon), 1, fPtr);\n  (*ph)[i].p0 = phHolder->p0;\n  (*ph)[i].p1 = phHolder->p1;\n  (*ph)[i].p2 = phHolder->p2;\n  (*ph)[i].p3 = phHolder->p3;\n  (*ph)[i].comv_p0 = phHolder->comv_p0;\n  (*ph)[i].comv_p1 = phHolder->comv_p1;\n  (*ph)[i].comv_p2 = phHolder->comv_p2;\n  (*ph)[i].comv_p3 = phHolder->comv_p3;\n  (*ph)[i].r0 = phHolder->r0;\n  (*ph)[i].r1 = phHolder->r1;\n  (*ph)[i].r2 = phHolder->r2;\n  (*ph)[i].s0 = phHolder->s0;\n  (*ph)[i].s1 = phHolder->s1;\n  (*ph)[i].s2 = phHolder->s2;\n  (*ph)[i].s3 = phHolder->s3;\n  (*ph)[i].num_scatt = phHolder->num_scatt;\n  (*ph)[i].weight = phHolder->weight;\n  (*ph)[i].nearest_block_index = phHolder->nearest_block_index;\n  (*ph)[i].type = phHolder->type;\n  if ((((*ph)[i].weight != 0) && (((*ph)[i].type == COMPTONIZED_PHOTON) || ((*ph)[i].type == UNABSORBED_CS_PHOTON))) && ((*ph)[i].p0 > 0))\n  {\n    scatt_cyclosynch_num_ph++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mcrat_io/3"}
{"code": "for (uint64_t i = 0; i < (size / 4); i++)\n{\n  tmp = data_64[i];\n  hist[((tmp >> 0) & 0xFFFF) >> tail]++;\n  hist[((tmp >> 16) & 0xFFFF) >> tail]++;\n  hist[((tmp >> 32) & 0xFFFF) >> tail]++;\n  hist[((tmp >> 48) & 0xFFFF) >> tail]++;\n}\n\n", "pragma": "omp for reduction(+:hist[:1<<b])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    Task2(nArray_2[i], kArray_2[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IZIDIA/OpenMP-Testing/Main_OpenMP/3"}
{"code": "for (ix = x_start; ix <= (x_end - 1); ix++)\n  for (iy = y_start; iy <= (y_end - 1); iy++)\n  if (round_float(*((u1 + (ix * ny)) + iy)) != round_float(*((u2 + (ix * ny)) + iy)))\n  return 0;\n\n\n\n", "pragma": "omp parallel for collapse(2) private(ix, iy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iokasti/heatTransferSimulation-parallel/openmp/mpi_heat_openmp_functions/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  counts[i] = get_count(myfiles[j], search_words[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog6_WordSearch_openmp/0"}
{"code": "for (i = 0; i < numBBOthers; i++)\n{\n  fil = fopen(bbNameList[i + 2].c_str(), \"r\");\n  printf(\"Problem with %s \\r\\n\", bbNameList[i + 2].c_str());\n  fread((char *) rawOthers, 2, npix * nb, fil);\n  flattenData(rawOthers, (float *) (&othersBB[(ns * nl) * i]), ns, nl, nb);\n  fclose(fil);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/1"}
{"code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 200; j++)\n  {\n    b[i][j] = (i * j) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wahmingchen/parallel-computing/matrix_multiplication_with_MPI/mpi_mm/3"}
{"code": "for (j = 0; j < B_col; j++)\n{\n  for (i = 0; i < A_row; i++)\n  {\n    sum = 0;\n    for (k = 0; k < A_col; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A,B,C) private(i,j,k,sum) num_threads(number_of_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coherent17/Matrix-Multiplication-optimize-by-OpenMP/Parallel_Matrix_Multiplication_With_Openmp/jik_optimize/0"}
{"code": "for (i = 0; i < 64; i++)\n  for (j = 0; j < 64; j++)\n  board[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/floorplan/src/floorplan_ompi/6"}
{"code": "for (i = 0; i < (mDIM * lDIM); i++)\n  posix_memalign((float **) (&a[i]), getpagesize(), (BSIZE * BSIZE) * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/7"}
{"code": "for (int j = 0; j < range_tuple.size(); j++)\n  for (int m = range_tuple[j].first; m < (range_tuple[j].second - kmer_len); m++)\n  contig_block_kmer_counter[contig_sequences[i].substr(m, kmer_len)]++;\n\n\n", "pragma": "#pragma omp parallel for num_threads(contig_threads) default(shared) schedule(dynamic, 1) private(contig_block_kmer_counter)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rshreyas/kmer_counter_openmp/kmer_counter/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  printf(\"\\t%d \\t %d\\n\", A[i], B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ci-monk/parallel-programing/code/sum_array_in_parallel/2"}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= k0[i];\n  opad[index][i] ^= k0[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/hmacMD5_fmt_plug/2"}
{"code": "for (source = 1; source < grid->p; source++)\n{\n  MPI_Recv(temp_mat, 1, local_matrix_mpi_t, source, 0, grid->comm, &status);\n  MPI_Cart_coords(grid->comm, source, 2, coords);\n  fprintf(fp, \"Process %d > grid_row = %d, grid_col = %d\\n\", source, coords[0], coords[1]);\n  for (i = 0; i < temp_mat->n_bar; i++)\n  {\n    for (j = 0; j < temp_mat->n_bar; j++)\n      fprintf(fp, \"%20.15E \", *((temp_mat->entries + (temp_mat->n_bar * i)) + j));\n\n    fprintf(fp, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/22"}
{"code": "for (i = 0; i <= 4; i += 1)\n{\n  partial_verify_vals[i] = key_array[test_index_array[i]];\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/3"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if (m != centre)\n  {\n    if ((min1 == (-1.0)) || (dist_list[m] < min1))\n    {\n      min1 = dist_list[m];\n      ind1 = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/15"}
{"code": "for (j = 0; j < dim; j++)\n{\n  inv[k][j] = inv[k][j] / mat[k][k];\n  if (j != k)\n    mat[k][j] = mat[k][j] / mat[k][k];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj_inv/omp_gj_inv/1"}
{"code": "for (int jj = 0; jj < (N + 2); jj++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    slice[ii + (jj * (N + 2))] = array3d[(ii + (jj * (N + 2))) + ((slice_index * (N + 2)) * (N + 2))];\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/23"}
{"code": "for (i = 0; i < width; i++)\n  for (j = 0; j < height; j++)\n{\n  if (mainField[i][j].past != mainField[i][j].present)\n    result = 0;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/lgame/8"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  matrix[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw4/matrix/2"}
{"code": "for (i = 1; i <= 1; i++)\n  TOPO[i][(5 + 2) - 1] = TOPO[i][1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/8"}
{"code": "for (x = 1; x < (maxXcount - 1); x++)\n{\n  double f = ((((-alpha) * fx_thing[x - 1]) * fy_thing[0]) - (2.0 * fx_thing[x - 1])) - (2.0 * fy_thing[0]);\n  double updateVal = (((((u_old[(1 * maxXcount) + (x - 1)] + u_old[(1 * maxXcount) + (x + 1)]) * cx) + ((u_old[(0 * maxXcount) + x] + u_old[(2 * maxXcount) + x]) * cy)) + (u_old[(1 * maxXcount) + x] * cc)) - f) / cc;\n  u[(1 * maxXcount) + x] = u_old[(1 * maxXcount) + x] - (relax * updateVal);\n  local_square_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:local_square_error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MediaBilly/Poisson-Equation-Parallel-Solver/HybridMPI/jacobi_hybrid_mpi/1"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    const int y_n = (jj + 1) % params.ny;\n    const int x_e = (ii + 1) % params.nx;\n    const int y_s = (jj == 0) ? ((jj + params.ny) - 1) : (jj - 1);\n    const int x_w = (ii == 0) ? ((ii + params.nx) - 1) : (ii - 1);\n    const float speed0 = cells->speeds0[ii + (jj * params.nx)];\n    const float speed1 = cells->speeds1[x_w + (jj * params.nx)];\n    const float speed2 = cells->speeds2[ii + (y_s * params.nx)];\n    const float speed3 = cells->speeds3[x_e + (jj * params.nx)];\n    const float speed4 = cells->speeds4[ii + (y_n * params.nx)];\n    const float speed5 = cells->speeds5[x_w + (y_s * params.nx)];\n    const float speed6 = cells->speeds6[x_e + (y_s * params.nx)];\n    const float speed7 = cells->speeds7[x_e + (y_n * params.nx)];\n    const float speed8 = cells->speeds8[x_w + (y_n * params.nx)];\n    float local_density = 0.f;\n    local_density += speed0;\n    local_density += speed1;\n    local_density += speed2;\n    local_density += speed3;\n    local_density += speed4;\n    local_density += speed5;\n    local_density += speed6;\n    local_density += speed7;\n    local_density += speed8;\n    const float u_x = (((speed1 + speed5) + speed8) - ((speed3 + speed6) + speed7)) / local_density;\n    const float u_y = (((speed2 + speed5) + speed6) - ((speed4 + speed7) + speed8)) / local_density;\n    if (obstacles[(jj * params.nx) + ii])\n    {\n      tmp_cells->speeds0[ii + (jj * params.nx)] = speed0;\n      tmp_cells->speeds1[ii + (jj * params.nx)] = speed3;\n      tmp_cells->speeds2[ii + (jj * params.nx)] = speed4;\n      tmp_cells->speeds3[ii + (jj * params.nx)] = speed1;\n      tmp_cells->speeds4[ii + (jj * params.nx)] = speed2;\n      tmp_cells->speeds5[ii + (jj * params.nx)] = speed7;\n      tmp_cells->speeds6[ii + (jj * params.nx)] = speed8;\n      tmp_cells->speeds7[ii + (jj * params.nx)] = speed5;\n      tmp_cells->speeds8[ii + (jj * params.nx)] = speed6;\n    }\n    else\n    {\n      const float u_sq = (u_x * u_x) + (u_y * u_y);\n      const float u_sqhalfc_sq = u_sq * halfc_sq;\n      float u[9];\n      u[1] = u_x;\n      u[2] = u_y;\n      u[3] = -u_x;\n      u[4] = -u_y;\n      u[5] = u_x + u_y;\n      u[6] = (-u_x) + u_y;\n      u[7] = (-u_x) - u_y;\n      u[8] = u_x - u_y;\n      float d_equ[9];\n      d_equ[0] = (w0 * local_density) * (1.f - (u_sq * halfc_sq));\n      d_equ[1] = (w1 * local_density) * (((1.f + (u[1] * c_sq)) + ((u[1] * u[1]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[2] = (w1 * local_density) * (((1.f + (u[2] * c_sq)) + ((u[2] * u[2]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[3] = (w1 * local_density) * (((1.f + (u[3] * c_sq)) + ((u[3] * u[3]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[4] = (w1 * local_density) * (((1.f + (u[4] * c_sq)) + ((u[4] * u[4]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[5] = (w2 * local_density) * (((1.f + (u[5] * c_sq)) + ((u[5] * u[5]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[6] = (w2 * local_density) * (((1.f + (u[6] * c_sq)) + ((u[6] * u[6]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[7] = (w2 * local_density) * (((1.f + (u[7] * c_sq)) + ((u[7] * u[7]) * halfc_sqsq)) - u_sqhalfc_sq);\n      d_equ[8] = (w2 * local_density) * (((1.f + (u[8] * c_sq)) + ((u[8] * u[8]) * halfc_sqsq)) - u_sqhalfc_sq);\n      tmp_cells->speeds0[ii + (jj * params.nx)] = speed0 + (params.omega * (d_equ[0] - speed0));\n      tmp_cells->speeds1[ii + (jj * params.nx)] = speed1 + (params.omega * (d_equ[1] - speed1));\n      tmp_cells->speeds2[ii + (jj * params.nx)] = speed2 + (params.omega * (d_equ[2] - speed2));\n      tmp_cells->speeds3[ii + (jj * params.nx)] = speed3 + (params.omega * (d_equ[3] - speed3));\n      tmp_cells->speeds4[ii + (jj * params.nx)] = speed4 + (params.omega * (d_equ[4] - speed4));\n      tmp_cells->speeds5[ii + (jj * params.nx)] = speed5 + (params.omega * (d_equ[5] - speed5));\n      tmp_cells->speeds6[ii + (jj * params.nx)] = speed6 + (params.omega * (d_equ[6] - speed6));\n      tmp_cells->speeds7[ii + (jj * params.nx)] = speed7 + (params.omega * (d_equ[7] - speed7));\n      tmp_cells->speeds8[ii + (jj * params.nx)] = speed8 + (params.omega * (d_equ[8] - speed8));\n    }\n\n    tot_u += (!obstacles[(jj * params.nx) + ii]) ? (sqrtf((u_x * u_x) + (u_y * u_y))) : (0);\n    tot_cells += (!obstacles[(jj * params.nx) + ii]) ? (1) : (0);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:tot_cells, tot_u)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MichaelRol/Lattice-Boltzmann-OpenMP/d2q9-bgk/1"}
{"code": "for (unsigned int i = 0; i < md_length; ++i)\n{\n  (ss << hex) << ((unsigned int) md[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoggy/md5brute/md5brute/1"}
{"code": "for (i = 1; i <= 2048; i++)\n  for (j = 1; j <= 2048; j++)\n  T_new[i][j] = 0.25 * (((T[i + 1][j] + T[i - 1][j]) + T[i][j + 1]) + T[i][j - 1]);\n\n\n", "pragma": "omp teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/0"}
{"code": "for (size_t i = 0; i < (n * m); ++i)\n{\n  u1 = ((double) rand()) / ((double) 32767);\n  u2 = ((double) rand()) / ((double) 32767);\n  z0 = sqrt((-2) * log(u1)) * cos(6.28 * u2);\n  A[i] = mu + (sigma * z0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex5-norm-mean-stddev-openmp/2"}
{"code": "for (int i = y; i < (y + height); i++)\n{\n  for (int j = x; j < ((x + width) - reste); j += 8)\n  {\n    res = compute_vect_int(i, j);\n    change_vect = _mm256_or_si256(res, change_vect);\n  }\n\n  int j = (x + width) - reste;\n  for (int k = 0; k < reste; k++)\n    change += compute_new_state_int(i, j + k);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/23"}
{"code": "for (i = 0; i < nbfn; i++)\n{\n  i_off += nbfn;\n  DENS_DECL(i, i);\n  TOL_DECL(i, i);\n  if (g_schwarz[OFF(i, i)] < tol2e_over_g_schwarz_i_i)\n  {\n    CUT2(1);\n    continue;\n  }\n\n  CUT3(1);\n  double gg = G(i, i, i, i);\n  UPDATE(i, i, i, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/scf-openmp/twoel/6"}
{"code": "for (int i = 0; i < (numItems + 1); i++)\n{\n  csr_items[i] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cb1711/RecommenderSystem/src/main/1"}
{"code": "for (i = 0; i < 1008; i++)\n{\n  if (output[i] == 0)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoyMitra/android-parallel-benchmarks/openmp/parallel-prime/app/src/main/cpp/par-prime/2"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    double suma_parcial = 0;\n    if (C[(i * N) + j] < minC_local)\n      minC_local = C[(i * N) + j];\n\n    if (C[(i * N) + j] > maxC_local)\n      maxC_local = C[(i * N) + j];\n\n    totalC_local += C[(i * N) + j];\n    for (k = 0; k < N; k++)\n    {\n      suma_parcial += AB[(i * N) + k] * C[(j * N) + k];\n    }\n\n    D[(i * N) + j] = suma_parcial;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k) reduction(+:totalC_local) reduction(max:maxC_local) reduction(min:minC_local)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/pruebas/full-funneled/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  cast_perm->vec_[i] = (this->nrow_ - tmp_perm.vec_[i]) - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/80"}
{"code": "for (i = 0; i < nl; i++)\n{\n  for (j = 0; j < nc; j++)\n  {\n    printf(\"Thread: %d Charge: %d-%d \\n\", omp_get_thread_num(), i, j);\n    tab[i][j] = rand();\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex5-3/1"}
{"code": "for (int j = 0; j < Time_cell; ++j)\n{\n  for (int i = 0; i < Freq_cell; ++i)\n  {\n    map[j][i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/26"}
{"code": "for (m = 0; m < test_num; m++)\n{\n  for (i = 0; i < inputN; i++)\n    test[m].input[i] = test_images[m][i];\n\n  test[m].label[0] = test_labels[m];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchParallel/10"}
{"code": "for (i = 1; i <= nodesCount; ++i)\n{\n  for (j = 1; j <= nodesCount; ++j)\n  {\n    if (((distance[i][k] != NOT_CONNECTED) && (distance[k][j] != NOT_CONNECTED)) && ((distance[i][j] == NOT_CONNECTED) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n    {\n      distance[i][j] = distance[i][k] + distance[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) private(i, j) num_threads(numthreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harisrkhan7/FloydWarshallAlgorithmParallelisation/notdynamic_fw_in/0"}
{"code": "for (int i = 0; i < threads; i++)\n{\n  int LSideBegin = (i * pow(2, PERM_BLOCK_SIZE)) / threads;\n  int LSideEnd = (((i + 1) * pow(2, PERM_BLOCK_SIZE)) / threads) - 1;\n  permutate_thread(LSideBegin, LSideEnd);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kostascc/PDS-Project-4/src/Block9Permutations/2"}
{"code": "for (int neuron = 0; neuron < L1_NEURONS; neuron++)\n{\n  for (int input = 0; input < L1_DIM; input++)\n  {\n    printf(\"%.3f \", WL1[neuron][input]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/10"}
{"code": "for (i = 0; i < size; i++)\n{\n  trie_list[i] = get_Node();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svaderia/ParallelDF/driver/2"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n{\n  printf(\"%g\", A[i * ((250 * 1024) / 256)]);\n  for (j = 1; j < ((250 * 1024) / 256); j++)\n  {\n    printf(\" %g\", A[(i * ((250 * 1024) / 256)) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 1/matmul/5"}
{"code": "for (int j = 0; j < procCoords.y_cells_num; j++)\n{\n  for (int i = 0; i < procCoords.x_cells_num; i++)\n  {\n    scalar_product += (hxhy * f1[(j * procCoords.x_cells_num) + i]) * f2[(j * procCoords.x_cells_num) + i];\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule (static) reduction(+:scalar_product)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/0"}
{"code": "for (int i = 0; i < cast_mat_A->nrow_; ++i)\n{\n  int jj = 0;\n  for (int j = this->mat_.row_offset[i]; j < this->mat_.row_offset[i + 1]; ++j)\n  {\n    this->mat_.col[j] = new_col[i][jj];\n    ++jj;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/44"}
{"code": "for (int j = i; j < end; j++)\n{\n  if ((contents[j] == '\"') && (r == 1))\n  {\n    end = j;\n    break;\n  }\n\n  if (contents[j] == '\"')\n    r++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Po-Y-H/Parallel-Web-Crawler-by-OpenMP/03_ps/Crawler/2"}
{"code": "for (int i = n; i < (n + ((chromo_length * 30) / 100)); i++)\n{\n  z = i % chromo_length;\n  Chro->genes[z] = p.genes[z];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/16"}
{"code": "for (int i = 0; i < repeats; i++)\n{\n  for (int j = 0; j < arr_size; j++)\n  {\n    if (j != 0)\n    {\n      arr_dest[j] = arr_tmp[j - 1];\n    }\n    else\n    {\n      arr_dest[j] = 0;\n    }\n\n  }\n\n  memcpy(arr_tmp, arr_dest, (sizeof(double)) * arr_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/0"}
{"code": "for (i = 0; i < (totalSize - 1); i++)\n{\n  V[i] = f(V[i], V[i - 1]);\n}\n\n", "pragma": "omp parallel for default(none) shared(V,totalSize) private(i) schedule(static) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor8/0"}
{"code": "for (i = 0; i < (nca / 2); i++)\n{\n  for (j = 0; j < (nca / 2); j++)\n  {\n    a[((2 * nca) * nca) + ((i * nca) + j)] = ABC[in1 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + (((i * nca) + j) + (nca / 2))] = ABC[in2 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + (((i + (nca / 2)) * nca) + j)] = ABC[in3 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + ((((i + (nca / 2)) * nca) + j) + (nca / 2))] = ABC[in4 + ((i * (nca / 2)) + j)];\n  }\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/6"}
{"code": "for (i = 0; i < (p * n); i++)\n{\n  B[i] = (double) ((-i) - 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mkhan5/mkl-kernels/dgemm/dgemm_papi_flops_par/3"}
{"code": "for (j = nrows; j >= 1; j += -1)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/25"}
{"code": "for (i = 0; i < n; ++i)\n{\n  b[i] = 5;\n  printf(\"%d\\n\", b[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Vector/main/0"}
{"code": "for (i = 0; i < n; i++)\n  chunk->checksum += cs[i].checksum;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP2/inf8601-lab2-2.1.3/encode/algo/6"}
{"code": "for (int i = 0; i < sort_length; i++)\n{\n  if ((y + i) >= image->height)\n  {\n    break;\n  }\n\n  sorted.push_back(image->get_pixel(x, y + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MenesesGHZ/glitch/lib/glitch/3"}
{"code": "for (source = 1; source < workers; source++)\n{\n  rows = (source == (workers - 1)) ? (avg_rows + extra_rows) : (avg_rows);\n  start_row = source * avg_rows;\n  MPI_Recv(&new_bmp_img[start_row * wd], rows * wd, (MPI_Datatype) 0x4c000102, source, type, 1, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/naveentrtumkur/Sobel-Operator-using-MPI-and-OpenMP/mpi_program5/3"}
{"code": "for (unsigned int i = 0; i < m; i++)\n  y[i] = sqrt(z[i]);\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Fazendaaa/openmp_tutorial/src/no_wait/1"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  __assume_aligned(cells.speed0, 64);\n  __assume_aligned(cells.speed1, 64);\n  __assume_aligned(cells.speed2, 64);\n  __assume_aligned(cells.speed3, 64);\n  __assume_aligned(cells.speed4, 64);\n  __assume_aligned(cells.speed5, 64);\n  __assume_aligned(cells.speed6, 64);\n  __assume_aligned(cells.speed7, 64);\n  __assume_aligned(cells.speed8, 64);\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    cells.speed0[ii + (jj * params.nx)] = w0;\n    cells.speed1[ii + (jj * params.nx)] = w1;\n    cells.speed2[ii + (jj * params.nx)] = w1;\n    cells.speed3[ii + (jj * params.nx)] = w1;\n    cells.speed4[ii + (jj * params.nx)] = w1;\n    cells.speed5[ii + (jj * params.nx)] = w2;\n    cells.speed6[ii + (jj * params.nx)] = w2;\n    cells.speed7[ii + (jj * params.nx)] = w2;\n    cells.speed8[ii + (jj * params.nx)] = w2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/openMP/d2q9-bgk/0"}
{"code": "for (i = 0; i < width; i++)\n{\n  float x = x0 + (i * dx);\n  output[(j * width) + i] = mandel(x, y, maxIterations);\n}\n\n", "pragma": "omp simd for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_40_mandel/0"}
{"code": "for (size_t i_node = 0; i_node < rThisGeometry.size(); ++i_node)\n{\n  AtomicAddMatrix(rThisGeometry[i_node].GetValue(rThisVar), (N[i_node] * origin_values[GaussPointId]) * Weight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_processes/internal_variables_interpolation_process/5"}
{"code": "for (uint32_t j = startingY; j < originalH; j += 2)\n{\n  for (uint32_t i = startingX; i < originalW; i += 2)\n  {\n    Pixel3 c = zero3f;\n    for (uint32_t y = 0; y < rows; y++)\n    {\n      int32_t jy = (j + ((ystart + y) * 2)) - startingY;\n      for (uint32_t x = 0; x < cols; x++)\n      {\n        int32_t ix = (i + ((xstart + x) * 2)) - startingX;\n        if ((((ix >= 0) && (ix < originalW)) && (jy >= 0)) && (jy < originalH))\n        {\n          double kern_elem = filter[getKernelPosition(x, y)];\n          Pixel3 px = *getPixel3(source, ix, jy);\n          c.x += px.x * kern_elem;\n          c.y += px.y * kern_elem;\n          c.z += px.z * kern_elem;\n        }\n        else\n        {\n          double kern_elem = filter[getKernelPosition(x, y)];\n          Pixel3 px = *getPixel3(source, i - startingX, j - startingY);\n          c.x += px.x * kern_elem;\n          c.y += px.y * kern_elem;\n          c.z += px.z * kern_elem;\n        }\n\n      }\n\n    }\n\n    setPixel3(dest, i / 2, j / 2, &c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stranck/RealTimeLLF/src/OpenMP/openmp/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  v = a[i];\n  printf(\"thread %d v=%d\\n \", omp_get_thread_num(), v);\n}\n\n", "pragma": "omp parallel for lastprivate(v)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/lastprivate-clause/0"}
{"code": "for (int i = 2; i <= (subgrid->rows - 1); i++)\n{\n  for (int j = 2; j <= (subgrid->cols - 1); j++)\n  {\n    int alive_neighbours = (((((((prev_gen[i - 1][j - 1] == '1') + (prev_gen[i - 1][j] == '1')) + (prev_gen[i - 1][j + 1] == '1')) + (prev_gen[i][j - 1] == '1')) + (prev_gen[i][j + 1] == '1')) + (prev_gen[i + 1][j - 1] == '1')) + (prev_gen[i + 1][j] == '1')) + (prev_gen[i + 1][j + 1] == '1');\n    if (exec_game_rules(prev_gen, next_gen, i, j, alive_neighbours) == 1)\n    {\n      changed = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanPapag/Game-Of-Life/mpi_openmp/src/game_utils/0"}
{"code": "for (i = 0; i < n_threads; i++)\n{\n  for (j = 0; j < n_clusters; j++)\n    local_newClusters[i][j] = (float *) calloc(n_coords, sizeof(float));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreP-git/Kmeans-OpenMP/kmeans/9"}
{"code": "for (int frame = gpu_frames; frame < frames; frame++)\n{\n  delta = (Delta * 0.99) * pow(0.99, frame);\n  const double xMin = xMid - delta;\n  const double yMin = yMid - delta;\n  const double dw = (2.0 * delta) / width;\n  for (int row = 0; row < width; row++)\n  {\n    const double cy = (-yMin) - (row * dw);\n    for (int col = 0; col < width; col++)\n    {\n      const double cx = (-xMin) - (col * dw);\n      double x = cx;\n      double y = cy;\n      int depth = 256;\n      double x2;\n      double y2;\n      do\n      {\n        x2 = x * x;\n        y2 = y * y;\n        y = ((2 * x) * y) + cy;\n        x = (x2 - y2) + cx;\n        depth--;\n      }\n      while ((depth > 0) && ((x2 + y2) < 5.0));\n      pic[(((frame * width) * width) + (row * width)) + col] = (unsigned char) depth;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/diegoloya/Hybrid_OMP_CUDA/fractal_hyb1/0"}
{"code": "for (i = 1; i < ((int) n); i++)\n{\n  sum += 2.0 * func(from + (i * h));\n}\n\n", "pragma": "omp parallel for private(i,from) reduction(+:sum) shared(h,n)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tristingreenstein/Optimization-Techniques-using-Parallel-Task-in-OpenMP/Integration/0"}
{"code": "for (int x = 0; x < tam; x++)\n{\n  for (int y = 0; y < tam; y++)\n  {\n    a[(x * tam) + y] = (int) (rand() % 100);\n    b[(x * tam) + y] = (int) (rand() % 100);\n    c[(x * tam) + y] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HectorMontillo/MPI-OpenMp/test/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[i] = x[i] + (a * y[i]);\n}\n\n", "pragma": "omp parallel for num_threads(threads) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisaho/openmp/solver/2"}
{"code": "for (j = itn; j < nxh; j++)\n{\n  at1 = cimagf(ffc[j]);\n  fxyz[4 * j] = exyz[4 * j] * at1;\n  fxyz[1 + (4 * j)] = exyz[1 + (4 * j)] * at1;\n  fxyz[2 + (4 * j)] = exyz[2 + (4 * j)] * at1;\n  fxyz[4 * (j + k1)] = exyz[4 * (j + k1)] * at1;\n  fxyz[1 + (4 * (j + k1))] = exyz[1 + (4 * (j + k1))] * at1;\n  fxyz[2 + (4 * (j + k1))] = exyz[2 + (4 * (j + k1))] * at1;\n  fxyz[4 * (j + l1)] = exyz[4 * (j + l1)] * at1;\n  fxyz[1 + (4 * (j + l1))] = exyz[1 + (4 * (j + l1))] * at1;\n  fxyz[2 + (4 * (j + l1))] = exyz[2 + (4 * (j + l1))] * at1;\n  fxyz[4 * ((j + k1) + l1)] = exyz[4 * ((j + k1) + l1)] * at1;\n  fxyz[1 + (4 * ((j + k1) + l1))] = exyz[1 + (4 * ((j + k1) + l1))] * at1;\n  fxyz[2 + (4 * ((j + k1) + l1))] = exyz[2 + (4 * ((j + k1) + l1))] * at1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/57"}
{"code": "for (k = 10000000; k >= 1; k--)\n{\n  for (j = -1; j < 2; j = j + 2)\n  {\n    x = (6 * k) + j;\n    ymax = (int) ceil(sqrt((double) x));\n    for (y = 3; y <= ymax; y = y + 2)\n    {\n      success = x % y;\n      if (!success)\n        break;\n\n    }\n\n    if (success)\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,250) reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/R-A-Khan/Parallel-Prog-Projects/primes_count_omp/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->vector_output[v] = Fixed32ToFloat(vector_output[v]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/12"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < n; k++)\n    {\n      C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/matmul/0"}
{"code": "for (STEP = 0; STEP < 10; STEP++)\n{\n  initialize(array, STEP);\n  OSCR_timer_start(0);\n  qs(array, 0, SIZE - 1);\n  OSCR_timer_stop(0);\n  testit(array);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_QuickSort/c_qsort/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  fscanf(fp1, \"%lf\", &bodies[i].m);\n  fscanf(fp1, \"%lf\", &bodies[i].s[0]);\n  fscanf(fp1, \"%lf\", &bodies[i].s[1]);\n  fscanf(fp1, \"%lf\", &bodies[i].v[0]);\n  fscanf(fp1, \"%lf\", &bodies[i].v[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/4"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < n1; i1++)\n    {\n      u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n      u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      r[i3][i2][i1] = ((v[i3][i2][i1] - (a[0] * u[i3][i2][i1])) - (a[2] * ((u2[i1] + u1[i1 - 1]) + u1[i1 + 1]))) - (a[3] * (u2[i1 - 1] + u2[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i1 ,i2 ,i3 ,u1 ,u2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/MG/mg/1"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  matrice2[i] = malloc((sizeof(int)) * 3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP2EX3/2"}
{"code": "for (int i = 0; i < imageSize; i++)\n  memcpy(reversedImage + (i * imageSize), image + (((imageSize - i) - 1) * imageSize), imageSize * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JerryHu1994/CS-759-High-Performance-Computing/HW04/solutions/problem2/2"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  pr[i] = d / (N * 1.0);\n  for (int v = 0; v < rev[i].size(); v++)\n  {\n    int ver = rev[i][v];\n    pr[i] += ((prev[ver] * 1.0) / (outdeg[ver] * 1.0)) * (1.0 - d);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/baseline/1"}
{"code": "for (int k = number / 2; k < (alto * ancho); k++)\n{\n  row = k / ancho;\n  column = k - (row * ancho);\n  if (((((column + (number / 2)) < finishLine) && ((row + (number / 2)) < finishRow)) && (row > (number / 2))) && (column > (number / 2)))\n  {\n    baseRow = row - (number / 2);\n    auxrow = baseRow;\n    baseColumn = column - (number / 2);\n    auxcolumn = baseColumn;\n    for (int x = 0; x < (number * number); x++)\n    {\n      auxrow = baseRow + (x / number);\n      auxcolumn = (baseColumn + x) - ((x / number) * number);\n      center += ((float) img[auxrow][auxcolumn]) * factor;\n    }\n\n    img[row][column] = center;\n    printf(\" \\n %f %i %i\", center, row, column);\n    center = 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AsielTrejo/BlurringEffect/blur/1"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  norm2 += (this->vec_[i].real() * this->vec_[i].real()) + (this->vec_[i].imag() * this->vec_[i].imag());\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : norm2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/25"}
{"code": "for (int i = 0; i < img.all; i++)\n{\n  (((((file << img.data[i].red) << \" \") << img.data[i].green) << \" \") << img.data[i].blue) << ((((i + 1) % img.x) == 0) ? (\"\\n\") : (\" \"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elyaishere/sk_high_performance_computing/openmp/Car/1"}
{"code": "for (int j = 0; j < tam; j++)\n  fprintf(fp, \"%s \", names[j].c_str());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/3"}
{"code": "for (int j = 0; j < x; ++j)\n{\n  for (int k = 0; k < 10; ++k)\n  {\n    x = (((k * j) + ((k - j) * n)) + i) + ((i - (n * j)) * 100);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vibhatha/OpenMP/code/exp1/OpenMPExamples/0"}
{"code": "for (long int i = 0; i < n; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for schedule(dynamic, 10000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maxis42/Parallel-computing-Coursera/1 OpenMP/Week 3/3.1_add_2vector/3.1_add_2vector/main/1"}
{"code": "for (idx_t f = 1; f < nfibs; ++f)\n{\n  if ((ft->sids[f] / tsize) != (slab - 1))\n  {\n    ft->slabptr[slab++] = f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/ftensor/4"}
{"code": "for (i = 0; i < dev_num; i++)\n{\n  err = clFlush(command_queue[i]);\n  checkError(err, 331);\n  err = clFinish(command_queue[i]);\n  checkError(err, 333);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/B/photomosaic/4"}
{"code": "for (vi = 0; vi < nvtxs; vi++)\n  maxdegree = gk_max(maxdegree, (int32_t) (xadj[vi + 1] - xadj[vi]));\n\n", "pragma": "omp parallel for schedule(static,4096) default(none) shared(nvtxs, xadj) reduction(max: maxdegree)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/0"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  hash_tables[i] = createtable(HASH_SIZE);\n  populateHashMapWL(queue, hash_tables[i], &linesQlock);\n}\n\n", "pragma": "omp parallel for shared(queue, hash_tables)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/map-reduce-word-count-openmp-mpi/parallel_read_map_new/0"}
{"code": "for (v = 0; v < stats1->num_vertices; v++)\n{\n  if (stats1->distances[v] != stats2->distances[v])\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/14"}
{"code": "for (k = lt; k >= 1; k--)\n{\n  nx[k] = ng[k][0];\n  ny[k] = ng[k][1];\n  nz[k] = ng[k][2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/11"}
{"code": "for (i = 0; i < num_storms; i++)\n{\n  for (j = 0; j < storms[i].size; j++)\n  {\n    float energia = ((float) storms[i].posval[(j * 2) + 1]) / 1000;\n    int posicion = storms[i].posval[j * 2];\n    for (k = 0; k < layer_size; k++)\n    {\n      actualiza(layer, k, posicion, energia);\n    }\n\n  }\n\n  for (k = 0; k < layer_size; k++)\n    layer_copy[k] = layer[k];\n\n  for (k = 1; k < (layer_size - 1); k++)\n  {\n    layer[k] = ((layer_copy[k - 1] + layer_copy[k]) + layer_copy[k + 1]) / 3;\n  }\n\n  for (k = 1; k < (layer_size - 1); k++)\n  {\n    if ((layer[k] > layer[k - 1]) && (layer[k] > layer[k + 1]))\n    {\n      if (layer[k] > maximos[i])\n      {\n        maximos[i] = layer[k];\n        posiciones[i] = k;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bayons/OpenMP/Practica/energy_v2/6"}
{"code": "for (i = j; i < n; ++i)\n{\n  a[i] = a[i] + temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alty-ir/openmp/openmp/Lab_4_parallel1/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  diff = y[j] - 1.0;\n  if (fabs(diff) > 0.00001)\n  {\n    bogus = 1;\n    max_diff = diff;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/14"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/64"}
{"code": "for (i = 0; i < n; i++)\n{\n  term = pow(-1, i) / ((2 * i) + 1);\n  sum += term;\n}\n\n", "pragma": "omp for private(i,term) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eldonMed/Parallelize-the-Leibniz-formula-for-pi-using-CUDA-and-OpenMP/OpenMP leibniz/0"}
{"code": "for (int j = 0; j <= _M; j++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (_M / mpi_size)\n    bi = j / (_M / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = (bj + bi) % mpi_size;\n  st = ((mpi_size + st) - mpi_rank) % mpi_size;\n  s->rb = st * (sN / mpi_size);\n  s->re = s->rb + (sN / mpi_size);\n  if (st == 0)\n    s->rb = 1;\n\n  if (st == (mpi_size - 1))\n    s->re = sN;\n\n  s->Bt = s->sBt;\n  for (int i = s->rb; i < s->re; i++)\n  {\n    s->Bt[idx(i, j, k)] = s->Mcoefs_3d[0][1][idx(i, j, k)] * x[idx(i, j, k)];\n    s->Bt[idx(i, j, k)] += s->Mcoefs_3d[0][0][idx(i, j, k)] * x[idx(i - 1, j, k)];\n    s->Bt[idx(i, j, k)] += s->Mcoefs_3d[0][2][idx(i, j, k)] * x[idx(i + 1, j, k)];\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/155"}
{"code": "for (i = 0; i < (lDIM * nDIM); i++)\n  free(b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/12"}
{"code": "for (i_imopVar82 = 1; i_imopVar82 < (grid_points[0] - 1); i_imopVar82++)\n{\n  for (k_imopVar84 = 1; k_imopVar84 < (grid_points[2] - 1); k_imopVar84++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      for (n = 0; n < 5; n++)\n      {\n        rhs[i_imopVar82][j_imopVar83][k_imopVar84][m] = rhs[i_imopVar82][j_imopVar83][k_imopVar84][m] - (lhs[i_imopVar82][j_imopVar83][k_imopVar84][2][m][n] * rhs[i_imopVar82][j_imopVar83 + 1][k_imopVar84][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/58"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  int retval = __sync_fetch_and_add(&a[i % 3200], 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mogill/ems/Tests/accum_omp/0"}
{"code": "for (int i = 0; i < totalSize; i++)\n{\n  fscanf(fpB, \"%lf\", &ptB[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JerryHu1994/CS-759-High-Performance-Computing/HW06/problem1A/2"}
{"code": "for (int k = 0; k < n; k++)\n{\n  if (k == 0)\n  {\n    for (int i = 0; i < thread_count; i++)\n    {\n      pthread_create(&threadID[i], NULL, dealwithbycol_SSE, (void *) (&id[i]));\n    }\n\n  }\n\n  for (int i = 0; i < thread_count; i++)\n  {\n    sem_wait(&sem_parent);\n  }\n\n  pthread_barrier_wait(&childbarrier_col);\n  A[k][k] = 1;\n  for (int i = k + 1; i < n; i++)\n    A[i][k] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/13"}
{"code": "for (int i = 0; i < tmp_in_DG.size(); i++)\n{\n  if (in_DG[new2ori_polygon[i]])\n    tmp_in_DG[i] = true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/8"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  printf(\"PID: %d thread %d time %f\\n\", pid, i, timer_threads[pid][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eferos93/mandelbrotSet/src/mandelbrot_set/2"}
{"code": "for (int neuron = 0; neuron < L2_NEURONS; neuron++)\n{\n  for (int input = 0; input < L2_DIM; input++)\n  {\n    printf(\"%.3f \", WL2[neuron][input]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/11"}
{"code": "for (int i = 0; i < Comb_loops; i++)\n{\n  x_sampt_comb[i] = (complex_t *) malloc(W_Comb * (sizeof(*x_sampt_comb[i])));\n  samples_comb[i] = (real_t *) malloc(W_Comb * (sizeof(*samples_comb[i])));\n  offset[i] = (unsigned) floor(drand48() * sigma);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/evanmacbride/parallel-fft/original-sources/sFFT-1.0-2.0-par-openacc/sFFT-1.0-2.0-par-openacc/computefourier/10"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  for (int j = 0; j < Ndim; j++)\n  {\n    Beta.nM[i][j] = updated_Beta.nM[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/19"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  eta = ((double) j) * dnym1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[k][m] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[k][m] = dtpp * dtemp[m];\n      }\n\n      cuf[k] = buf[k][3] * buf[k][3];\n      buf[k][0] = (cuf[k] + (buf[k][1] * buf[k][1])) + (buf[k][2] * buf[k][2]);\n      q[k] = 0.5 * (((buf[k][1] * ue[k][1]) + (buf[k][2] * ue[k][2])) + (buf[k][3] * ue[k][3]));\n    }\n\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      km1 = k - 1;\n      kp1 = k + 1;\n      forcing[k][j][i][0] = (forcing[k][j][i][0] - (tz2 * (ue[kp1][3] - ue[km1][3]))) + (dz1tz1 * ((ue[kp1][0] - (2.0 * ue[k][0])) + ue[km1][0]));\n      forcing[k][j][i][1] = ((forcing[k][j][i][1] - (tz2 * ((ue[kp1][1] * buf[kp1][3]) - (ue[km1][1] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][1] - (2.0 * buf[k][1])) + buf[km1][1]))) + (dz2tz1 * ((ue[kp1][1] - (2.0 * ue[k][1])) + ue[km1][1]));\n      forcing[k][j][i][2] = ((forcing[k][j][i][2] - (tz2 * ((ue[kp1][2] * buf[kp1][3]) - (ue[km1][2] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][2] - (2.0 * buf[k][2])) + buf[km1][2]))) + (dz3tz1 * ((ue[kp1][2] - (2.0 * ue[k][2])) + ue[km1][2]));\n      forcing[k][j][i][3] = ((forcing[k][j][i][3] - (tz2 * (((ue[kp1][3] * buf[kp1][3]) + (c2 * (ue[kp1][4] - q[kp1]))) - ((ue[km1][3] * buf[km1][3]) + (c2 * (ue[km1][4] - q[km1])))))) + (zzcon1 * ((buf[kp1][3] - (2.0 * buf[k][3])) + buf[km1][3]))) + (dz4tz1 * ((ue[kp1][3] - (2.0 * ue[k][3])) + ue[km1][3]));\n      forcing[k][j][i][4] = ((((forcing[k][j][i][4] - (tz2 * ((buf[kp1][3] * ((c1 * ue[kp1][4]) - (c2 * q[kp1]))) - (buf[km1][3] * ((c1 * ue[km1][4]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[kp1][0] - (2.0 * buf[k][0])) + buf[km1][0]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[kp1][4] - (2.0 * buf[k][4])) + buf[km1][4]))) + (dz5tz1 * ((ue[kp1][4] - (2.0 * ue[k][4])) + ue[km1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = 1;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((5.0 * ue[k][m]) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      k = 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((((-4.0) * ue[k - 1][m]) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n    }\n\n    for (k = 3; k <= (grid_points[2] - 4); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = grid_points[2] - 3;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])));\n      k = grid_points[2] - 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (5.0 * ue[k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/exact_rhs/3"}
{"code": "for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  Bxc[i][j][k] = 0.0;\n  Byc[i][j][k] = 0.0;\n  Bzc[i][j][k] = 0.0;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/81"}
{"code": "for (i = 0; i < level->num_my_boxes; i++)\n  if (level->my_boxes[i].vectors)\n  free(level->my_boxes[i].vectors);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/33"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < 100; j++)\n  {\n    a[i][j] = i;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB073-doall2-orig-yes/0"}
{"code": "for (int i = 0; i < n; i++, k++)\n{\n  if (k == range)\n  {\n    k = 0;\n  }\n\n  arr[i] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/Intel Vtune Amplifier and histogram/cat/1"}
{"code": "for (i = 0; i < np1; i++)\n{\n  for (j = 0; j < np2; j++)\n    for (k = 0; k < np3; k++)\n  {\n    k1 = i - (np1 / 2);\n    k2 = j - (np2 / 2);\n    k3 = k - (np3 / 2);\n    k_s = ((2.0 * Pi) / L_box) * sqrt(((k1 * k1) + (k2 * k2)) + (k3 * k3));\n    pf[i][j][k].Re *= (Dz * T_k(k_s)) / C1;\n    pf[i][j][k].Im *= (Dz * T_k(k_s)) / C1;\n  }\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/LTic/zedolvech/0"}
{"code": "for (i = 0; i < local_n0; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n{\n  int z = ((((i * N) + j) * 2) * Nf) + k;\n  s_in[0] += ((U[z] * U[z]) + (V[z] * V[z])) + (W[z] * W[z]);\n}\n\n\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/13"}
{"code": "for (int j = 0; j < 4; ++j)\n{\n  b[j] = b[j] + a[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-08-ParallelForParallelFor/0"}
{"code": "for (k = i; k < dim_n; k++)\n{\n  tmp = A[(maxIndex * dim_n) + k];\n  A[(maxIndex * dim_n) + k] = A[(i * dim_n) + k];\n  A[(i * dim_n) + k] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZhixinLai/Parallel-Computing/Gaussian elimination with partial pivoting by OpenMP/gaussian/4"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  double x;\n  double y;\n  double test;\n  x = random();\n  y = random();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "omp parallel for reduction(+:Ncirc)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParallelProgTeam/Aula-3-OpenMP/OMP_Exercises/solutions/pi_mc_par_array/0"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n    printf(\"%d \", matB[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/9"}
{"code": "for (int j = 0; j < sizey; j++)\n{\n  for (int i = 0; i < sizex; i++)\n  {\n    for (int mat = 0; mat < Nmats; mat++)\n    {\n      mc.rho[((ncells * mat) + i) + (sizex * j)] = cc.rho[((i + (sizex * j)) * Nmats) + mat];\n      mc.p[((ncells * mat) + i) + (sizex * j)] = cc.p[((i + (sizex * j)) * Nmats) + mat];\n      mc.Vf[((ncells * mat) + i) + (sizex * j)] = cc.Vf[((i + (sizex * j)) * Nmats) + mat];\n      mc.t[((ncells * mat) + i) + (sizex * j)] = cc.t[((i + (sizex * j)) * Nmats) + mat];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/14"}
{"code": "for (int ii = 0; ii < N; ++ii)\n{\n  for (int kk = 0; kk < N; ++kk)\n  {\n    float r = A[(ii * N) + kk];\n    for (int jj = 0; jj < N; ++jj)\n    {\n      C[(ii * N) + jj] += r * B[(kk * N) + jj];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_goto+cuBLAS/0"}
{"code": "for (i = 0; i < numf1s; i++)\n{\n  for (j = 0; j < numf2s; j++)\n  {\n    busp[i][j] = bus[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/48"}
{"code": "for (q = 0; q < Nqd; q++)\n{\n  PolPol = (quads(q, 2) * Poltau.block(q, 0, 1, k + 1).transpose()) * Psit.block(q, 0, 1, k + 2);\n  Kdq.setZero();\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, g.prev(i)) = Kprev(q, i);\n  }\n\n  Kprime += kron(Kdq, PolPol);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/24"}
{"code": "for (int j = 0; j < g_populationSize; ++j)\n{\n  sum += probability[j];\n  if (r < sum)\n  {\n    for (int k = 0; k < g_nParents; ++k)\n    {\n      if ((*fatherIndex) == j)\n      {\n        alreadyPicked = true;\n        break;\n      }\n\n    }\n\n    if (!alreadyPicked)\n    {\n      if (nParentsChosen == 0)\n        *fatherIndex = j;\n      else\n        *motherIndex = j;\n\n      nParentsChosen++;\n    }\n\n    alreadyPicked = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jontelarsson94/OpenMPGeneticAlgorithm/MainWithOpenMP/main/3"}
{"code": "for (i = 0; i < subprob_size; i++)\n{\n  rlcbuff[i] = 1.0;\n  rfcbuff[i] = INITIAL_GRID;\n  rlrbuff[i] = INITIAL_GRID;\n  rfrbuff[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    A[i][j] = distribution(generator);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aqfort/mipt_omp/extra/matrix/0"}
{"code": "for (i = 0; i < nodes; i++)\n{\n  num_out_links[i] = 0;\n  for (j = 0; j < edges; j++)\n  {\n    if ((FromNode[j] == i) && (ToNode[j] != FromNode[j]))\n    {\n      num_out_links[i]++;\n      nz++;\n    }\n\n  }\n\n  if (num_out_links[i] == 0)\n    *z_ptr += 1;\n\n}\n\n", "pragma": "omp parallel for private(i,j) reduction(+:nz)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/Ferdig/PE_functions_15243/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sums += a[i];\n}\n\n", "pragma": "        #pragma omp for reduction(+:sums) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruparelmetarya/OpenMP-vs-TBB-A-survey-on-Parallel-Programming-Models/Source-codes/sum-red-openmp/1"}
{"code": "for (int i = 0; i < (*width); i++)\n  (*gaus_dv)[i] /= sum;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GlennRC/HighPerformanceComputing/Program-3/main_omp/6"}
{"code": "for (i = 1; i < numClusters; i++)\n  newClusters[i] = newClusters[i - 1] + numCoords;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/6"}
{"code": "for (int i = 0; i < (D_len + 1); i++)\n{\n  ScoreTable[0][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skalogerakis/TUC_Parallel_Computer_Architecture/Smith-Waterman/OpenMP_FineGrained/main/4"}
{"code": "for (int i = 0; i < NUMBER; ++i)\n{\n  sum += i;\n  printf(\"Iteraction %d executed by thread %d, temporal sum value is %d\\n\", i, omp_get_thread_num(), sum);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_programing_CSharp/LU6_reduction/LU6_reduction/Ex1/0"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  produit_scalaire_complexe = dotc1(d, e);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/18"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    goal[i][j] = (i * 3) + j;\n    pz[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShekharShiroor/8-Puzzle-problem-using-CPP-and-OpenMP/8-puzzle/0"}
{"code": "for (uint64_t i = 0; i < 20; i++)\n  array[i] += i;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_01/3"}
{"code": "for (unsigned i = 0; i < size; ++i)\n{\n  resTmp = 0.;\n  for (unsigned j = 0; j < size; ++j)\n  {\n    resTmp += mat[(i * size) + j] * vec[j];\n  }\n\n  res[i] = resTmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/MatrixVector/CDParallelism/utils/2"}
{"code": "for (i = 0; i < 3; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/access_delegator_variables_openmp/0"}
{"code": "for (j = 0; j < cache->assoc; j++)\n{\n  uint8_t SRRPV = getSRRPV(&cache->cacheLines[i][j]) + diff;\n  setSRRPV(&cache->cacheLines[i][j], SRRPV);\n  assert(SRRPV <= SRRPV_INIT);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/25"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    tmp1 = rho_i[k][j][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[j][i][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[j][i][1][0] = 0.0;\n    d[j][i][2][0] = 0.0;\n    d[j][i][3][0] = 0.0;\n    d[j][i][4][0] = 0.0;\n    d[j][i][0][1] = (((((-dt) * 2.0) * (((tx1 * r43) + ty1) + tz1)) * c34) * tmp2) * u[k][j][i][1];\n    d[j][i][1][1] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * (((tx1 * r43) + ty1) + tz1))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[j][i][2][1] = 0.0;\n    d[j][i][3][1] = 0.0;\n    d[j][i][4][1] = 0.0;\n    d[j][i][0][2] = (((((-dt) * 2.0) * ((tx1 + (ty1 * r43)) + tz1)) * c34) * tmp2) * u[k][j][i][2];\n    d[j][i][1][2] = 0.0;\n    d[j][i][2][2] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * ((tx1 + (ty1 * r43)) + tz1))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[j][i][3][2] = 0.0;\n    d[j][i][4][2] = 0.0;\n    d[j][i][0][3] = (((((-dt) * 2.0) * ((tx1 + ty1) + (tz1 * r43))) * c34) * tmp2) * u[k][j][i][3];\n    d[j][i][1][3] = 0.0;\n    d[j][i][2][3] = 0.0;\n    d[j][i][3][3] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * ((tx1 + ty1) + (tz1 * r43)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[j][i][4][3] = 0.0;\n    d[j][i][0][4] = ((-dt) * 2.0) * ((((((((tx1 * ((r43 * c34) - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * (c34 - c1345))) * (u[k][j][i][1] * u[k][j][i][1])) + ((((tx1 * (c34 - c1345)) + (ty1 * ((r43 * c34) - c1345))) + (tz1 * (c34 - c1345))) * (u[k][j][i][2] * u[k][j][i][2]))) + ((((tx1 * (c34 - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * ((r43 * c34) - c1345))) * (u[k][j][i][3] * u[k][j][i][3]))) * tmp3) + (((((tx1 + ty1) + tz1) * c1345) * tmp2) * u[k][j][i][4]));\n    d[j][i][1][4] = (((dt * 2.0) * tmp2) * u[k][j][i][1]) * (((tx1 * ((r43 * c34) - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * (c34 - c1345)));\n    d[j][i][2][4] = (((dt * 2.0) * tmp2) * u[k][j][i][2]) * (((tx1 * (c34 - c1345)) + (ty1 * ((r43 * c34) - c1345))) + (tz1 * (c34 - c1345)));\n    d[j][i][3][4] = (((dt * 2.0) * tmp2) * u[k][j][i][3]) * (((tx1 * (c34 - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * ((r43 * c34) - c1345)));\n    d[j][i][4][4] = (1.0 + ((((dt * 2.0) * ((tx1 + ty1) + tz1)) * c1345) * tmp1)) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = rho_i[k - 1][j][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[j][i][0][0] = ((-dt) * tz1) * dz1;\n    a[j][i][1][0] = 0.0;\n    a[j][i][2][0] = 0.0;\n    a[j][i][3][0] = (-dt) * tz2;\n    a[j][i][4][0] = 0.0;\n    a[j][i][0][1] = (((-dt) * tz2) * ((-(u[k - 1][j][i][1] * u[k - 1][j][i][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[k - 1][j][i][1]));\n    a[j][i][1][1] = ((((-dt) * tz2) * (u[k - 1][j][i][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    a[j][i][2][1] = 0.0;\n    a[j][i][3][1] = ((-dt) * tz2) * (u[k - 1][j][i][1] * tmp1);\n    a[j][i][4][1] = 0.0;\n    a[j][i][0][2] = (((-dt) * tz2) * ((-(u[k - 1][j][i][2] * u[k - 1][j][i][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[k - 1][j][i][2]));\n    a[j][i][1][2] = 0.0;\n    a[j][i][2][2] = ((((-dt) * tz2) * (u[k - 1][j][i][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    a[j][i][3][2] = ((-dt) * tz2) * (u[k - 1][j][i][2] * tmp1);\n    a[j][i][4][2] = 0.0;\n    a[j][i][0][3] = (((-dt) * tz2) * (((-(u[k - 1][j][i][3] * tmp1)) * (u[k - 1][j][i][3] * tmp1)) + ((C2 * qs[k - 1][j][i]) * tmp1))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[k - 1][j][i][3]));\n    a[j][i][1][3] = ((-dt) * tz2) * ((-C2) * (u[k - 1][j][i][1] * tmp1));\n    a[j][i][2][3] = ((-dt) * tz2) * ((-C2) * (u[k - 1][j][i][2] * tmp1));\n    a[j][i][3][3] = (((((-dt) * tz2) * (2.0 - C2)) * (u[k - 1][j][i][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    a[j][i][4][3] = ((-dt) * tz2) * C2;\n    a[j][i][0][4] = (((-dt) * tz2) * (((((C2 * 2.0) * qs[k - 1][j][i]) - (C1 * u[k - 1][j][i][4])) * u[k - 1][j][i][3]) * tmp2)) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[k - 1][j][i][1] * u[k - 1][j][i][1])) - (((c34 - c1345) * tmp3) * (u[k - 1][j][i][2] * u[k - 1][j][i][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[k - 1][j][i][3] * u[k - 1][j][i][3]))) - ((c1345 * tmp2) * u[k - 1][j][i][4])));\n    a[j][i][1][4] = (((-dt) * tz2) * (((-C2) * (u[k - 1][j][i][1] * u[k - 1][j][i][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[k - 1][j][i][1]);\n    a[j][i][2][4] = (((-dt) * tz2) * (((-C2) * (u[k - 1][j][i][2] * u[k - 1][j][i][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[k - 1][j][i][2]);\n    a[j][i][3][4] = (((-dt) * tz2) * ((C1 * (u[k - 1][j][i][4] * tmp1)) - (C2 * ((qs[k - 1][j][i] * tmp1) + ((u[k - 1][j][i][3] * u[k - 1][j][i][3]) * tmp2))))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[k - 1][j][i][3]);\n    a[j][i][4][4] = ((((-dt) * tz2) * (C1 * (u[k - 1][j][i][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n    tmp1 = rho_i[k][j - 1][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[j][i][0][0] = ((-dt) * ty1) * dy1;\n    b[j][i][1][0] = 0.0;\n    b[j][i][2][0] = (-dt) * ty2;\n    b[j][i][3][0] = 0.0;\n    b[j][i][4][0] = 0.0;\n    b[j][i][0][1] = (((-dt) * ty2) * ((-(u[k][j - 1][i][1] * u[k][j - 1][i][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[k][j - 1][i][1]));\n    b[j][i][1][1] = ((((-dt) * ty2) * (u[k][j - 1][i][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[j][i][2][1] = ((-dt) * ty2) * (u[k][j - 1][i][1] * tmp1);\n    b[j][i][3][1] = 0.0;\n    b[j][i][4][1] = 0.0;\n    b[j][i][0][2] = (((-dt) * ty2) * (((-(u[k][j - 1][i][2] * tmp1)) * (u[k][j - 1][i][2] * tmp1)) + (C2 * (qs[k][j - 1][i] * tmp1)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[k][j - 1][i][2]));\n    b[j][i][1][2] = ((-dt) * ty2) * ((-C2) * (u[k][j - 1][i][1] * tmp1));\n    b[j][i][2][2] = ((((-dt) * ty2) * ((2.0 - C2) * (u[k][j - 1][i][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[j][i][3][2] = ((-dt) * ty2) * ((-C2) * (u[k][j - 1][i][3] * tmp1));\n    b[j][i][4][2] = ((-dt) * ty2) * C2;\n    b[j][i][0][3] = (((-dt) * ty2) * ((-(u[k][j - 1][i][2] * u[k][j - 1][i][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[k][j - 1][i][3]));\n    b[j][i][1][3] = 0.0;\n    b[j][i][2][3] = ((-dt) * ty2) * (u[k][j - 1][i][3] * tmp1);\n    b[j][i][3][3] = ((((-dt) * ty2) * (u[k][j - 1][i][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[j][i][4][3] = 0.0;\n    b[j][i][0][4] = (((-dt) * ty2) * ((((C2 * 2.0) * qs[k][j - 1][i]) - (C1 * u[k][j - 1][i][4])) * (u[k][j - 1][i][2] * tmp2))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * (u[k][j - 1][i][1] * u[k][j - 1][i][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[k][j - 1][i][2] * u[k][j - 1][i][2]))) - (((c34 - c1345) * tmp3) * (u[k][j - 1][i][3] * u[k][j - 1][i][3]))) - ((c1345 * tmp2) * u[k][j - 1][i][4])));\n    b[j][i][1][4] = (((-dt) * ty2) * (((-C2) * (u[k][j - 1][i][1] * u[k][j - 1][i][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[k][j - 1][i][1]);\n    b[j][i][2][4] = (((-dt) * ty2) * ((C1 * (u[k][j - 1][i][4] * tmp1)) - (C2 * ((qs[k][j - 1][i] * tmp1) + ((u[k][j - 1][i][2] * u[k][j - 1][i][2]) * tmp2))))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[k][j - 1][i][2]);\n    b[j][i][3][4] = (((-dt) * ty2) * (((-C2) * (u[k][j - 1][i][2] * u[k][j - 1][i][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[k][j - 1][i][3]);\n    b[j][i][4][4] = ((((-dt) * ty2) * (C1 * (u[k][j - 1][i][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = rho_i[k][j][i - 1];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[j][i][0][0] = ((-dt) * tx1) * dx1;\n    c[j][i][1][0] = (-dt) * tx2;\n    c[j][i][2][0] = 0.0;\n    c[j][i][3][0] = 0.0;\n    c[j][i][4][0] = 0.0;\n    c[j][i][0][1] = (((-dt) * tx2) * (((-(u[k][j][i - 1][1] * tmp1)) * (u[k][j][i - 1][1] * tmp1)) + ((C2 * qs[k][j][i - 1]) * tmp1))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[k][j][i - 1][1]));\n    c[j][i][1][1] = ((((-dt) * tx2) * ((2.0 - C2) * (u[k][j][i - 1][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    c[j][i][2][1] = ((-dt) * tx2) * ((-C2) * (u[k][j][i - 1][2] * tmp1));\n    c[j][i][3][1] = ((-dt) * tx2) * ((-C2) * (u[k][j][i - 1][3] * tmp1));\n    c[j][i][4][1] = ((-dt) * tx2) * C2;\n    c[j][i][0][2] = (((-dt) * tx2) * ((-(u[k][j][i - 1][1] * u[k][j][i - 1][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[k][j][i - 1][2]));\n    c[j][i][1][2] = ((-dt) * tx2) * (u[k][j][i - 1][2] * tmp1);\n    c[j][i][2][2] = ((((-dt) * tx2) * (u[k][j][i - 1][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    c[j][i][3][2] = 0.0;\n    c[j][i][4][2] = 0.0;\n    c[j][i][0][3] = (((-dt) * tx2) * ((-(u[k][j][i - 1][1] * u[k][j][i - 1][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[k][j][i - 1][3]));\n    c[j][i][1][3] = ((-dt) * tx2) * (u[k][j][i - 1][3] * tmp1);\n    c[j][i][2][3] = 0.0;\n    c[j][i][3][3] = ((((-dt) * tx2) * (u[k][j][i - 1][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    c[j][i][4][3] = 0.0;\n    c[j][i][0][4] = (((-dt) * tx2) * (((((C2 * 2.0) * qs[k][j][i - 1]) - (C1 * u[k][j][i - 1][4])) * u[k][j][i - 1][1]) * tmp2)) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[k][j][i - 1][1] * u[k][j][i - 1][1])) - (((c34 - c1345) * tmp3) * (u[k][j][i - 1][2] * u[k][j][i - 1][2]))) - (((c34 - c1345) * tmp3) * (u[k][j][i - 1][3] * u[k][j][i - 1][3]))) - ((c1345 * tmp2) * u[k][j][i - 1][4])));\n    c[j][i][1][4] = (((-dt) * tx2) * ((C1 * (u[k][j][i - 1][4] * tmp1)) - (C2 * (((u[k][j][i - 1][1] * u[k][j][i - 1][1]) * tmp2) + (qs[k][j][i - 1] * tmp1))))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[k][j][i - 1][1]);\n    c[j][i][2][4] = (((-dt) * tx2) * (((-C2) * (u[k][j][i - 1][2] * u[k][j][i - 1][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[k][j][i - 1][2]);\n    c[j][i][3][4] = (((-dt) * tx2) * (((-C2) * (u[k][j][i - 1][3] * u[k][j][i - 1][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[k][j][i - 1][3]);\n    c[j][i][4][4] = ((((-dt) * tx2) * (C1 * (u[k][j][i - 1][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/14"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    vol_flux_x[FTNREF2D(1 - j, k, x_max + 5, x_min - 2, y_min - 2)] = -vol_flux_x[FTNREF2D(1 + j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/46"}
{"code": "for (i = 0; i < p; ++i)\n{\n  a1 = a->matrix + (i * q);\n  c = result->matrix + (i * r);\n  for (j = 0; j < r; ++j)\n  {\n    b1 = b->matrix + (j * q);\n    temp = 0;\n    for (k = 0; k < q; k++)\n      temp += (*(a1 + k)) * (*(b1 + k));\n\n    *(c + j) = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunth2001/Software-Programming-for-Performance/Assignment2/trials/3/0"}
{"code": "for (i = 0; i < num_vertices; ++i)\n{\n  edgeList->mask_array[i] = edgeListmem->mask_array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/3"}
{"code": "for (i = 0; i < 16; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/multibit_fmt_plug/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    A[j + (i * n)] = (double) ((i == j) ? (i * i) : (i + j));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/2"}
{"code": "for (unsigned int i = 0; i < n; i++)\n{\n  int point_index = i * k;\n  {\n    sort(nn_x + point_index, (nn_x + point_index) + k);\n    sort(nn_j + point_index, (nn_j + point_index) + k);\n  }\n  double num_matches = 0;\n  unsigned int pos_x = 0;\n  unsigned int pos_j = 0;\n  bool merge = true;\n  while (merge)\n  {\n    if ((pos_x + pos_j) == max_pos_sum)\n    {\n      merge = false;\n    }\n    else\n    {\n      if ((pos_x == max_pos) && (nn_x[point_index + pos_x] < nn_j[point_index + pos_j]))\n        merge = false;\n\n      if ((pos_j == max_pos) && (nn_x[point_index + pos_x] > nn_j[point_index + pos_j]))\n        merge = false;\n\n    }\n\n    if (nn_x[point_index + pos_x] == nn_j[point_index + pos_j])\n    {\n      num_matches++;\n      if (pos_x < max_pos)\n        pos_x++;\n\n      if (pos_j < max_pos)\n        pos_j++;\n\n    }\n    else\n    {\n      if (nn_x[point_index + pos_x] < nn_j[point_index + pos_j])\n      {\n        if (pos_x < max_pos)\n          pos_x++;\n\n      }\n      else\n      {\n        if (pos_j < max_pos)\n          pos_j++;\n\n      }\n\n    }\n\n  }\n\n  local_zeta[i] = num_matches / k;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam-zlatniczki/moar-zeta-cpp-openmp/src/local_zeta/2"}
{"code": "for (n = 0; n < N; n++)\n{\n  for (int c = 0; c < C; c++)\n  {\n    for (int h = 0; h < H; h++)\n    {\n      for (int w = 0; w < W; w++)\n      {\n        inputT[find_NCHW_idx(n, h, w, c, N, H, W, C)] = input[find_NCHW_idx(n, c, h, w, N, C, H, W)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/utils/1"}
{"code": "for (uint32_t i = 0; i < vertex_num; i++)\n{\n  if (delta(*m_db->vPatternBbox[i], HORIZONTAL) == threshold)\n  {\n    m_isVDDGND[i] = false;\n    mplPrint(kDEBUG, \"dirty coding for oracle cases\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/7"}
{"code": "for (i3 = 1; i3 < e3; i3++)\n{\n  x1 = x0;\n  for (i2 = 1; i2 < e2; i2++)\n  {\n    xx = x1;\n    vranlc(d1, &xx, pow(5.0, 13), &z[i3][i2][0]);\n    rdummy = randlc(&x1, a1);\n  }\n\n  rdummy = randlc(&x0, a2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/21"}
{"code": "for (int k = 0; k < 20; k++)\n{\n  (cout << k) << endl;\n  timeStart = omp_get_wtime();\n  FillingMas(masA, MasLen);\n  timeEnd = omp_get_wtime();\n  FillingMasTime += timeEnd - timeStart;\n  for (int i = 2; i < 5; i++)\n  {\n    timeStart = omp_get_wtime();\n    FillingMasParallel(masB, MasLen, i);\n    timeEnd = omp_get_wtime();\n    FillingMasParallelTime[i - 2] += timeEnd - timeStart;\n  }\n\n  timeStart = omp_get_wtime();\n  SumAB(masA, masB, masC, MasLen);\n  timeEnd = omp_get_wtime();\n  SumABTime += timeEnd - timeStart;\n  for (int i = 2; i < 5; i++)\n  {\n    timeStart = omp_get_wtime();\n    SumABParallelFor(masA, masB, masC, MasLen, i);\n    timeEnd = omp_get_wtime();\n    SumABParallelForTime[i - 2] += timeEnd - timeStart;\n  }\n\n  for (int i = 2; i < 5; i++)\n  {\n    timeStart = omp_get_wtime();\n    SumABParallelSection(masA, masB, masC, MasLen, i);\n    timeEnd = omp_get_wtime();\n    SumABParallelSectionTime[i - 2] += timeEnd - timeStart;\n  }\n\n  timeStart = omp_get_wtime();\n  SumC(masC, MasLen);\n  timeEnd = omp_get_wtime();\n  SumCTime += timeEnd - timeStart;\n  for (int i = 2; i < 5; i++)\n  {\n    timeStart = omp_get_wtime();\n    SumCCritical(masC, MasLen, i);\n    timeEnd = omp_get_wtime();\n    SumCCriticalTime[i - 2] += timeEnd - timeStart;\n  }\n\n  for (int i = 2; i < 5; i++)\n  {\n    timeStart = omp_get_wtime();\n    SumCReductor(masC, MasLen, i);\n    timeEnd = omp_get_wtime();\n    SumCReductorTime[i - 2] += timeEnd - timeStart;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/0"}
{"code": "for (int i = 0; i < ((sizeof(counts)) / (sizeof(*counts))); i++)\n{\n  Log(\"==============================================================================\");\n  LaunchMatrixRowsCount(counts[i], counts[i], true);\n  LaunchMatrixRowsCount(counts[i], counts[i], false);\n  Log(\"==============================================================================\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/Source/7"}
{"code": "for (ptrdiff_t i = 0; i < size; ++i)\n{\n  (*this)[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/0"}
{"code": "for (uint32_t x = chunk->x0; x < chunk->x1; ++x)\n  for (uint32_t y = chunk->y0; y < chunk->y1; ++y)\n  setPixelColor(image, x, y, chunk->pixels[x][y]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alecsmirnov/nstu-parallel-programming/3/imageprocessor/imageprocessor/3"}
{"code": "for (j = jbeg; j <= jfin1; j++)\n{\n  for (k = ki1; k <= (ki2 - 1); k++)\n  {\n    frc3 = frc3 + (((((((phi1[j][k] + phi1[j + 1][k]) + phi1[j][k + 1]) + phi1[j + 1][k + 1]) + phi2[j][k]) + phi2[j + 1][k]) + phi2[j][k + 1]) + phi2[j + 1][k + 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/43"}
{"code": "for (i = 0; i < n; i++)\n{\n  pair[i] = i;\n  int j;\n  for (j = 0; j < n; j++)\n    if (free_energy_of_pair(p, i, j) < free_energy_of_pair(p, i, pair[i]))\n    pair[i] = j;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/prna-omp/prna/7"}
{"code": "for (i = 0; i < MNMIN; i = i + 10)\n  fprintf(fp, \"%E\\t\", UNEW[i][i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/9"}
{"code": "for (int i = (input->np / 4) * 4; i < input->np; ++i)\n{\n  sup->W[i] += sup->delta_f[i] / min_delta_f;\n  sup->w_sum += sup->W[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/10"}
{"code": "for (i = 0; i < 40; i++)\n  pi += sum[i][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/pi_padded/1"}
{"code": "for (i = 0; i < TOTAL_THREADS; i++)\n{\n  threadDataCount[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/6"}
{"code": "for (i = 0; i < samples; i++)\n{\n  x = erand48(xi);\n  y = erand48(xi);\n  if (((x * x) + (y * y)) <= 1.0)\n    count++;\n\n}\n\n", "pragma": "        #pragma omp parallel for firstprivate(xi) private (x, y) reduction(+:count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/add19/Parallel-Programming/ompPi/0"}
{"code": "for (int i = 0; i < many_length; i++)\n  distances[i] = euclidean_distance(one_point, many_points[i], dims);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/distance/3"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  uint32_t j;\n  for (j = 0; j < totalPartitions; ++j)\n  {\n    uint32_t k;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      uint32_t src = partition->edgeList->edges_array_src[k];\n      uint32_t dest = partition->edgeList->edges_array_dest[k];\n      uint32_t comp_src = stats->components[src];\n      uint32_t comp_dest = stats->components[dest];\n      if (comp_src != comp_dest)\n      {\n        uint32_t comp_high = (comp_src > comp_dest) ? (comp_src) : (comp_dest);\n        uint32_t comp_low = comp_src + (comp_dest - comp_high);\n        if (comp_high == stats->components[comp_high])\n        {\n          change = 1;\n          stats->components[comp_high] = comp_low;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/6"}
{"code": "for (int i = 0; i < strlen(str); i++)\n{\n  switch (str[i])\n  {\n    case '*':\n      NumberOfStars++;\n      break;\n\n    case ':':\n      NumberOfColons++;\n      break;\n\n    case '.':\n      NumberOfPoints++;\n      break;\n\n    case ' ':\n      NumberOfSpaces++;\n      break;\n\n    default:\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MatanF5/Sequence_Allignment_Parllel/functions/6"}
{"code": "for (int k = y_min; k <= y_max; k++)\n{\n  #pragma ivdep\n  for (int j = x_min; j <= x_max; j++)\n  {\n    density0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_reset_field/0"}
{"code": "for (j = 0; j <= 4; j += 1)\n{\n  cblock[0][j] = ((((cblock[0][j] - (ablock[0][0] * bblock[0][j])) - (ablock[0][1] * bblock[1][j])) - (ablock[0][2] * bblock[2][j])) - (ablock[0][3] * bblock[3][j])) - (ablock[0][4] * bblock[4][j]);\n  cblock[1][j] = ((((cblock[1][j] - (ablock[1][0] * bblock[0][j])) - (ablock[1][1] * bblock[1][j])) - (ablock[1][2] * bblock[2][j])) - (ablock[1][3] * bblock[3][j])) - (ablock[1][4] * bblock[4][j]);\n  cblock[2][j] = ((((cblock[2][j] - (ablock[2][0] * bblock[0][j])) - (ablock[2][1] * bblock[1][j])) - (ablock[2][2] * bblock[2][j])) - (ablock[2][3] * bblock[3][j])) - (ablock[2][4] * bblock[4][j]);\n  cblock[3][j] = ((((cblock[3][j] - (ablock[3][0] * bblock[0][j])) - (ablock[3][1] * bblock[1][j])) - (ablock[3][2] * bblock[2][j])) - (ablock[3][3] * bblock[3][j])) - (ablock[3][4] * bblock[4][j]);\n  cblock[4][j] = ((((cblock[4][j] - (ablock[4][0] * bblock[0][j])) - (ablock[4][1] * bblock[1][j])) - (ablock[4][2] * bblock[2][j])) - (ablock[4][3] * bblock[3][j])) - (ablock[4][4] * bblock[4][j]);\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/142"}
{"code": "for (int i = 0; i < t; ++i)\n{\n  sigmaTime += strassenParallelProduct(a, b, c, n, 0, 0, 0, 0, true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/3/strassen/1"}
{"code": "for (i = 0; i < 4; i++)\n  printf(\"%.3f processo:%d\\n\", row_array[i], my_rank);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/5"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n    fprintf(fp, \"%d \", (i * 1024) + j);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/PKU-HPC/Testing on Intel Xeon E5 CPUs/ProblemScale/1024*1024/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (k = kf; k >= ki; k--)\n{\n  sum = 0;\n  for (j = 0; j < numOfPartsY; j++)\n  {\n    for (i = 0; i < numOfPartsX; i++)\n      sum += (fun((a + (i * dx)) + (dx / 2), (ay + (j * dy)) + (dy / 2), k) * dx) * dy;\n\n  }\n\n  c_arr[k - 1] = sum;\n}\n\n", "pragma": "#pragma omp parallel for private(k,j,i) schedule(static) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gitsebste/openmpDoubleintegral/doubleIntegral/doubleIntegral/doubleIntegral/1"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  for (int j = 0; j < command_line_args.seq_len; j++)\n  {\n    m_arrays[i][j] = ((RAND_START + rand()) % RAND_STOP) / 100.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (Centers_matchings[i] != 0)\n    for (int j = 0; j < 1000; j++)\n    Centers[i][j] /= Centers_matchings[i];\n\n  else\n  {\n    printf(\"\\nWARNING: Center %d has no members.\\n\", i);\n    pickSubstituteCenter(i);\n    needToRecalculateCenters = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/2. K-means with OpenMP/kmeans12/9"}
{"code": "for (unsigned i = 0; i < N; ++i)\n  res = X[i] * Y[i];\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/penzn/omp-wasi-parallel/openmp-offload/dot/0"}
{"code": "for (i = 0; i < K; ++i)\n{\n  R[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielhauagge/pykmeans/pykmeans/3"}
{"code": "for (int z = 0; z < (rows * columns); ++z)\n{\n  x = z / columns;\n  y = z % columns;\n  for (int i = 0; i < FILTER_ROW_SIZE; ++i)\n  {\n    for (int j = 0; j < FILTER_COLUMN_SIZE; ++j)\n    {\n      a = (x + i) - (FILTER_ROW_SIZE / 2);\n      b = (y + j) - (FILTER_COLUMN_SIZE / 2);\n      x1 = (a < 0) ? (rows + a) : ((a > (rows - 1)) ? (a - rows) : (a));\n      x2 = (b < 0) ? (columns + b) : ((b > (columns - 1)) ? (b - columns) : (b));\n      output[(x * columns) + y] += data[(x1 * columns) + x2] * filter[(i * FILTER_COLUMN_SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for private(x, y, a, b, x1, x2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alaxalves/matrix/OpenMP/src/pspd-proj1/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  block_lengths[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KevinMTO/Helmholtz-ACC/MPI_GPU_AWARE+Openacc/main/1"}
{"code": "for (int i = 0; i < omp_get_max_threads(); ++i)\n  printf(\"tid = %d, cpuid = %d\\n\", i, cpuid[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/vasp1/vasp1/0"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  d += p[j] * q[j];\n}\n\n", "pragma": "\t\t#pragma omp for reduction(+:d)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/11"}
{"code": "for (i = 0; i < RowCount; i++)\n{\n  NewCellArray[i] = (double *) malloc(ColCount * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-omp-examples/heat1/3"}
{"code": "for (long int i = 0; i < size; i++)\n{\n  (cout << arr[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OnofreTZK/OpenMP_ShellSort/parallel/shellsort_prl/2"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/135"}
{"code": "for (int k = 0; k < Nz; k++)\n{\n  for (int j = 0; j < Ny; j++)\n  {\n    for (int i = 0; i < Nx; i++)\n    {\n      IA[n] = cnt;\n      if ((k - 1) >= 0)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = (i + (j * Nx)) + (((k - 1) * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      if ((j - 1) >= 0)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = (i + ((j - 1) * Nx)) + ((k * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      if ((i - 1) >= 0)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = ((i - 1) + (j * Nx)) + ((k * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      cnt++;\n      JA_old = JA;\n      JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n      *((JA + cnt) - 1) = (i + (j * Nx)) + ((k * Nx) * Ny);\n      if (JA_old != JA)\n        free(JA_old);\n\n      if ((i + 1) < Nx)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = ((i + 1) + (j * Nx)) + ((k * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      if ((j + 1) < Ny)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = (i + ((j + 1) * Nx)) + ((k * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      if ((k + 1) < Nz)\n      {\n        cnt++;\n        JA_old = JA;\n        JA = (int *) realloc(JA, (sizeof(int)) * cnt);\n        *((JA + cnt) - 1) = (i + (j * Nx)) + (((k + 1) * Nx) * Ny);\n        if (JA_old != JA)\n          free(JA_old);\n\n      }\n\n      n++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/10"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  layer_outputs[s][0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    layer_outputs[s][l] = malloc((sizeof(double)) * nodes_per_layer[l]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU1/2"}
{"code": "for (int i = (*pass_through) - 1; i >= 0; i--)\n{\n  printf(\"%s \", path[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/actumn/dijkstra-openmp/dijkstra/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = (b[i] = i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/ForChunk/ForChunk/Source/0"}
{"code": "for (int i = 0; i < nx; i++)\n  *(pc++) = COST_OBS;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/7"}
{"code": "for (int i_dest = 1; i_dest < comm_size; i_dest++)\n{\n  MPI_Send(shared_params, SHARED_PARAMS_SIZE, MPI_INT, i_dest, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/4"}
{"code": "for (int y = TILE_SIZE; y < DIM; y += 2 * TILE_SIZE)\n  changement += do_tile_unstable(1, y, DIM - 2, TILE_SIZE - ((y + TILE_SIZE) == DIM), omp_get_thread_num());\n\n", "pragma": "omp for reduction (+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/5"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  for (j = 0; j < 1000; ++j)\n  {\n    sum = 0.0;\n    for (k = 0; k < 1000; ++k)\n    {\n      sum = sum + (a[(i * 1000) + k] * b[(k * 1000) + j]);\n    }\n\n    c[(i * 1000) + j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/mat-mul/src/mat-mul_gpu/1"}
{"code": "for (i = 0; i < points->numOfPoints; i++)\n{\n  int sign = (calcResults[i] > 0) ? (1) : (-1);\n  const double *point = getPointAt(points, i);\n  if (points->groupTags[i] != sign)\n  {\n    updateWeightsVector(weights, w0, alpha, points->groupTags[i], point, points->dimensions);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yotamMoshe7/C-Classification-Problem-Precepton/MPI_OMP_CUDA/PerceptronClassification/0"}
{"code": "for (i = 0; i < TF_idx; i++)\n  fprintf(fp, \"%s\\n\", strings[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lkmokadam/TFIDF_MPI_OpenMP/TFIDF_extra/10"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    if (mat[i][j] >= 0)\n      printf(\" \");\n\n    printf(\" %f \", mat[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/11"}
{"code": "for (i = 0; i <= (10 - 1); i++)\n{\n  printf(\"%3d %15.0f\\n\", i, q[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/EP/ep/8"}
{"code": "for (int i = 0; i < num_features; ++i)\n  features.push_back(rand() % num_all_features);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/1"}
{"code": "for (size_t element = 0; element < m_labels.size(); ++element)\n{\n  m_cluster_index[m_labels[element]].insert(element);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/necst/DBSCAN/dbscan/2"}
{"code": "for (size_t i = 0; i < weights_layout.size(); ++i)\n{\n  if (weights_layout[i] == 0)\n  {\n    curr_layer = i;\n    found = true;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Networks/MLP/2"}
{"code": "for (i = 1; i < (n - 1); i++)\n  for (j = 1; j < (m - 1); j++)\n{\n  resid = ((((ax * (uold[j + ((i - 1) * m)] + uold[j + ((i + 1) * m)])) + (ay * (uold[(j - 1) + (i * m)] + uold[(j + 1) + (i * m)]))) + (b * uold[j + (i * m)])) - f[j + (i * m)]) / b;\n  u[j + (i * m)] = uold[j + (i * m)] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n\n", "pragma": "omp for private(resid,j,i) reduction(+:error) nowait", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/jacobi-ompacc-multiGPU/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == fluid)\n  {\n    gradConcentration[i * 3] = 0.0;\n    gradConcentration[(i * 3) + 1] = 0.0;\n    gradConcentration[(i * 3) + 2] = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double duXi = 0.0;\n    double duYi = 0.0;\n    double duZi = 0.0;\n    double conc_i = concentration[i];\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                gradConcentration[i * 3] += (((conc_i + concentration[j]) * v0ij) * wS) / dstij2;\n                gradConcentration[(i * 3) + 1] += (((conc_i + concentration[j]) * v1ij) * wS) / dstij2;\n                gradConcentration[(i * 3) + 2] += (((conc_i + concentration[j]) * v2ij) * wS) / dstij2;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    gradConcentration[3 * i] *= -coeffPressGrad;\n    gradConcentration[(3 * i) + 1] *= -coeffPressGrad;\n    gradConcentration[(3 * i) + 2] *= -coeffPressGrad;\n    if (particleBC[i] == inner)\n    {\n      pos[i * 3] -= coeffShifting2 * gradConcentration[3 * i];\n      pos[(i * 3) + 1] -= coeffShifting2 * gradConcentration[(3 * i) + 1];\n      pos[(i * 3) + 2] -= coeffShifting2 * gradConcentration[(3 * i) + 2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/90"}
{"code": "for (i = 0; i < 8; i++)\n{\n  id = omp_get_thread_num();\n  a = id + 1;\n  printf(\"a is %d from thread: %d\\n\", a, id);\n}\n\n", "pragma": "omp parallel for private(a,id) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/ordered/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    c[i] = a[i] + b[i];\n    if (c[i] > 10)\n    {\n      if (c[i] < 20)\n      {\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/51"}
{"code": "for (double x = -sphere_radius; x < sphere_radius; x += x_spacing, xc++)\n{\n  for (double y = -sphere_radius; y < sphere_radius; y += y_spacing, yc++)\n  {\n    tempPoint[1] = y + ((xc % 2) * cell_radius);\n    tempPoint[0] = x;\n    tempPoint[2] = 0;\n    if (sqrt(norm_squared(tempPoint)) < sphere_radius)\n    {\n      cells.push_back(tempPoint);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/sample_projects_intracellular/ode/ode_energy/custom_modules/custom/2"}
{"code": "for (i = 0; i < dimention; i++)\n{\n  for (j = 0; j < dimention; j++)\n  {\n    int a;\n    int b;\n    int c;\n    if ((generation % 2) == 0)\n    {\n      a = i % 256;\n      b = j % 256;\n      c = (i * j) % 256;\n    }\n    else\n    {\n      a = rand() % 0x100;\n      b = rand() % 0x100;\n      c = rand() % 0x100;\n    }\n\n    Input1[i][j][0] = a;\n    Input1[i][j][1] = b;\n    Input1[i][j][2] = c;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ojani-Eguia/ImageGeneratorTest/OpenMP/ParShader/1"}
{"code": "for (j = 0; j < 20000000; j++)\n{\n  aSumErr += ((a[j] - aj) >= 0) ? (a[j] - aj) : (-(a[j] - aj));\n  bSumErr += ((b[j] - bj) >= 0) ? (b[j] - bj) : (-(b[j] - bj));\n  cSumErr += ((c[j] - cj) >= 0) ? (c[j] - cj) : (-(c[j] - cj));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/stream/stream/6"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  int curr_node = closestNode(node_dist, visited_node, num_vertices);\n  visited_node[curr_node] = 1;\n  for (next = 0; next < num_vertices; next++)\n  {\n    int new_dist = node_dist[curr_node] + graph[(curr_node * num_vertices) + next];\n    if (((visited_node[next] != 1) && (graph[(curr_node * num_vertices) + next] != ((data_t) 0))) && (new_dist < node_dist[next]))\n    {\n      node_dist[next] = new_dist;\n      parent_node[next] = curr_node;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/11"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      rho_inv = 1.0 / u[i][j][k][0];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[i][j][k][1] * rho_inv;\n      vs[i][j][k] = u[i][j][k][2] * rho_inv;\n      ws[i][j][k] = u[i][j][k][3] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/18"}
{"code": "for (x = 1; x < width; x++)\n  dbase[x] = uchar((sbase[x] == 0) ? (0) : (lut[dbase[x - 1]]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvdistransform/1"}
{"code": "for (int i = 0; i < num_threads; i++)\n{\n  rand_gen generator = init_rand();\n  for (int j = 0; j < num_samples_per_thread; j++)\n  {\n    int tid = omp_get_thread_num();\n    int val = next_rand(generator) * num_buckets;\n    tmp_hist[tid][val]++;\n  }\n\n  free_rand(generator);\n}\n\n", "pragma": "omp parallel for shared (tmp_hist)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bereydev/multiprocessor-architecture/A2/sharing/0"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  uijk = us[i][j][k];\n  up1 = us[i + 1][j][k];\n  um1 = us[i - 1][j][k];\n  rhs[i][j][k][0] = (rhs[i][j][k][0] + (dx1tx1 * ((u[i + 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i - 1][j][k][0]))) - (tx2 * (u[i + 1][j][k][1] - u[i - 1][j][k][1]));\n  rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dx2tx1 * ((u[i + 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i - 1][j][k][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[i + 1][j][k][1] * up1) - (u[i - 1][j][k][1] * um1)) + ((((u[i + 1][j][k][4] - square[i + 1][j][k]) - u[i - 1][j][k][4]) + square[i - 1][j][k]) * c2)));\n  rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dx3tx1 * ((u[i + 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i - 1][j][k][2]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][2] * up1) - (u[i - 1][j][k][2] * um1)));\n  rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dx4tx1 * ((u[i + 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i - 1][j][k][3]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][3] * up1) - (u[i - 1][j][k][3] * um1)));\n  rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dx5tx1 * ((u[i + 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i - 1][j][k][4]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[i + 1][j][k][4] * rho_i[i + 1][j][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i - 1][j][k][4] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[i + 1][j][k][4]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[i - 1][j][k][4]) - (c2 * square[i - 1][j][k])) * um1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,uijk ,up1 ,um1 ,tx2 ,dx1tx1 ,c2 ,dx2tx1 ,con43 ,xxcon2 ,dx3tx1 ,dx4tx1 ,c1 ,xxcon5 ,xxcon3 ,dx5tx1 ,xxcon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/76"}
{"code": "for (i = 0; i < quantoPercorrer; i++)\n{\n  for (j = 0; j < orderOfMatrix; j++)\n  {\n    matrixAux[i][j] = vetor_rec[k];\n    k++;\n    printf(\"%d \", matrixAux[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/11"}
{"code": "for (int thread = 0; thread < threads; thread++)\n{\n  int end;\n  if ((thread + 1) == threads)\n  {\n    end = (((int) size) / floats_per_operation) * floats_per_operation;\n  }\n  else\n  {\n    end = pixel_per_thread_aligned * (thread + 1);\n  }\n\n  int r_vector;\n  int g_vector;\n  int b_vector;\n  int gray_vector;\n  int gray_vector_int;\n  for (int i = pixel_per_thread_aligned * thread; i < end; i += floats_per_operation)\n  {\n    r_vector = _mm_set_ps(img[i * channels], img[(i + 1) * channels], img[(i + 2) * channels], img[(i + 3) * channels]);\n    g_vector = _mm_set_ps(img[(i * channels) + 1], img[((i + 1) * channels) + 1], img[((i + 2) * channels) + 1], img[((i + 3) * channels) + 1]);\n    b_vector = _mm_set_ps(img[(i * channels) + 2], img[((i + 1) * channels) + 2], img[((i + 2) * channels) + 2], img[((i + 3) * channels) + 2]);\n    gray_vector = _mm_setzero_ps();\n    gray_vector = _mm_fmadd_ps(r_vector, r_factor, gray_vector);\n    gray_vector = _mm_fmadd_ps(g_vector, g_factor, gray_vector);\n    gray_vector = _mm_fmadd_ps(b_vector, b_factor, gray_vector);\n    gray_vector_int = _mm_cvtps_epi32(gray_vector);\n    gray_vector_int = _mm_packus_epi32(gray_vector_int, gray_vector_int);\n    gray_vector_int = _mm_packus_epi16(gray_vector_int, gray_vector_int);\n    *((int *) (&result[i])) = _mm_cvtsi128_si32(gray_vector_int);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiangRongLin/grayscale-conversion/cpu/algorithms/memory_simd_fma/0"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  size_t baseX = i * cols;\n  float sumX = preSum[i];\n  float s2 = preS23[i];\n  for (size_t j = i + 1; j < rows; j++)\n  {\n    size_t baseY = j * cols;\n    float sumXY = 0.0;\n    for (size_t k = 0; k < cols; k++)\n    {\n      float a = vectors[baseX + k];\n      float b = vectors[baseY + k];\n      sumXY += a * b;\n    }\n\n    float sumY = preSum[j];\n    float s3 = preS23[j];\n    float s1 = (sumXY * fCols) - (sumX * sumY);\n    float s4 = sqrtf(s2 * s3);\n    float correlation = s1 / s4;\n    size_t index = getIndex(i, j, rows);\n    output[index] = correlation;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dvhh/massCorrelation/src/correlationOMP/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"%f\\n\", w);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kirillston/OpenMP-MPI/7_1/openmp_itc_11/1"}
{"code": "for (int j = 0; j < ny; j++)\n  for (int k = 0; k < nz; k++)\n{\n  vectorX[nx - 4][j][k] = vectorX[nx - 5][j][k];\n  vectorY[nx - 4][j][k] = vectorY[nx - 5][j][k];\n  vectorZ[nx - 4][j][k] = vectorZ[nx - 5][j][k];\n  vectorX[nx - 3][j][k] = vectorX[nx - 5][j][k];\n  vectorY[nx - 3][j][k] = vectorY[nx - 5][j][k];\n  vectorZ[nx - 3][j][k] = vectorZ[nx - 5][j][k];\n  vectorX[nx - 2][j][k] = vectorX[nx - 5][j][k];\n  vectorY[nx - 2][j][k] = vectorY[nx - 5][j][k];\n  vectorZ[nx - 2][j][k] = vectorZ[nx - 5][j][k];\n  vectorX[nx - 1][j][k] = vectorX[nx - 5][j][k];\n  vectorY[nx - 1][j][k] = vectorY[nx - 5][j][k];\n  vectorZ[nx - 1][j][k] = vectorZ[nx - 5][j][k];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/107"}
{"code": "for (int ig = 0; ig < ncouls; ++ig)\n  indinv[ig] = ig;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gpp-omp/main/4"}
{"code": "for (i = 1; i < n_clusters; i++)\n{\n  double distance = calc_euclidean_distance(point, actual_centroids_array[i]);\n  if (distance < min_distance)\n  {\n    min_distance = distance;\n    cluster_id = actual_centroids_array[i].cluster_id;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/9"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  finalRightBuf[i] = leftRecvBuf[i];\n  finalLeftBuf[i] = rightRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(leftRecvBuf,rightRecvBuf,dataSize,sizeofBuffer) shared(finalLeftBuf,finalRightBuf) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_haloexchange/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double t = sqrt((outB[2 * i] * outB[2 * i]) + (outB[(2 * i) + 1] * outB[(2 * i) + 1]));\n  double p = log(t);\n  if (t != 0)\n  {\n    if (max < p)\n      max = p;\n\n    if (min > p)\n      min = p;\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/16"}
{"code": "for (unsigned int i = 0; i < 3; i++)\n{\n  rot_mat(0, i) = vec_u[i];\n  rot_mat(1, i) = vec_v[i];\n  rot_mat(2, i) = vec_w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/FluidDynamicsApplication/custom_processes/mass_conservation_check_process/0"}
{"code": "for (int i = 0; i < command_line_args.clust_num; i++)\n{\n  (((((((cout << \"Cluster:\") << i) << '(') << clusters_arr[i].x) << ',') << clusters_arr[i].y) << ')') << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ/main/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  newArray[i] = calculateSize(array[i]);\n  if (min > newArray[i])\n  {\n    min = newArray[i];\n  }\n\n  if (max < newArray[i])\n  {\n    max = newArray[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/amplifier XE&schedule/Lab-1-1/5"}
{"code": "for (i = 0; i < nlm; i++)\n{\n  observations[i][0] = 0.0;\n  observations[i][1] = 0.0;\n  observationftag[i] = 0;\n  ftag[i] = i;\n  da_table[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  cs += to_string(c[i]) + \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gerrytty/parallel-programming-course/openMP/task7/4"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n{\n  for (j = 0; j < bots_arg_size_1; j++)\n  {\n    r_err = M[(i * bots_arg_size_1) + j] - N[(i * bots_arg_size_1) + j];\n    if (r_err < 0.0)\n      r_err = -r_err;\n\n    r_err = r_err / M[(i * bots_arg_size_1) + j];\n    if (r_err > EPSILON)\n    {\n      bots_message(\"Checking failure: A[%d][%d]=%f  B[%d][%d]=%f; Relative Error=%f\\n\", i, j, M[(i * bots_arg_size_1) + j], i, j, N[(i * bots_arg_size_1) + j], r_err);\n      return FALSE;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_performance/task_performance/bots/omp-tasks/sparselu/sparselu_for/sparselu/0"}
{"code": "for (i = 0; i < 256; i++)\n  if (a[i] != (3 * (i >= 1)))\n  abort();\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/3"}
{"code": "for (int y = 0; y < m_height; y++)\n{\n  int Y = (y * step) + yoff;\n  if (Y > (m_height - 1))\n    break;\n\n  for (int x = 0; x < m_width; x++)\n  {\n    int X = (x * step) + (xoff << (r & 0x1));\n    if (X > (m_width - 1))\n      break;\n\n    int i = (Y * m_width) + X;\n    kseedsl.push_back(m_lvec[i]);\n    kseedsa.push_back(m_avec[i]);\n    kseedsb.push_back(m_bvec[i]);\n    kseedsx.push_back(X);\n    kseedsy.push_back(Y);\n    n++;\n  }\n\n  r++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double val = b[i][0];\n  for (int j = 0; j < i; j++)\n  {\n    val -= A[i][j] * y[j][0];\n  }\n\n  y[i][0] = val / A[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhinav-vaishya/Parallel-Computing---MPI-OpenMP-CUDA/codes/Q4/0"}
{"code": "for (i = 0; i < totalNumOfPoints; i++)\n{\n  pointsDatabase[totalPoints[i].id].belongTo = totalPoints[i].belongTo;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/MPI_Kmeans/6"}
{"code": "for (i = 0; i < 9; i++)\n  if (a[i] != ((i < 4) ? (0x55555555ULL) : (0)))\n  __builtin_abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-7/1"}
{"code": "for (size_t t = 0; t < n_threads; t++)\n{\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    free(layer_outputs[t][l]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/5"}
{"code": "for (size_t i = 0; i < size; i++)\n  result[(i * cols) + i] = 1;\n\n", "pragma": "\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Bazik29/OpenMP-labs/matrix/Matrix/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    a[(i * 1024) + j] = (((float) rand()) / 32767) / 2;\n    b[(i * 1024) + j] = (((float) rand()) / 32767) / 2;\n    c[(i * 1024) + j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SatoYuki8/example_openmp/omp_matmul/1"}
{"code": "for (i = 0; i <= (public.allPoints - 1); i += 1)\n{\n  private[i].d_in2_pad = (float *) malloc(public.in2_pad_mem);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/7"}
{"code": "for (int i = 0; i < Cols; i++)\n{\n  Res.Vec[i] *= Res.Vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/116"}
{"code": "for (j = 0; j < 150; j++)\n{\n  fi[j] = f1[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/12"}
{"code": "for (int kk = n + nbh; kk < ((n + nbh) + (nbv / 2)); kk++)\n{\n  if ((jj * dx) > ((bt - 1) * dx))\n  {\n    ii++;\n    jj = 0;\n  }\n\n  x[kk] = space2 + (jj * dx);\n  y[kk] = (space2 + (bt * dx)) + (ii * dx);\n  jj++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/11"}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = j + (((k + depth) - 1) * depth);\n    right_snd_buffer[FTNREF1D(index, 1)] = field[FTNREF2D((x_max + 1) - j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/pack_kernel_c/1"}
{"code": "forest.load(filename_to_load)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/21"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (bounce(xnew[i], ynew[i], znew[i], sconf))\n  {\n  }\n\n  x[i] = xnew[i];\n  y[i] = ynew[i];\n  z[i] = znew[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brabemi/ctu-fit-mi-pap-mod/main/3"}
{"code": "for (int k = 1; k < (num_nei + 1); k++)\n{\n  double h = local_x[k] - local_x[0];\n  A[k - 1] = h;\n  A[(k - 1) + (1 * num_row)] = (0.5 * h) * h;\n  b[k - 1] = local_u[k] - local_u[0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/61"}
{"code": "for (j = i; j < size; j++)\n{\n  sum = a[(i * size) + j];\n  for (k = 0; k < i; k++)\n    sum -= a[(i * size) + k] * a[(k * size) + j];\n\n  a[(i * size) + j] = sum;\n}\n\n", "pragma": "omp parallel for default(none) private(j,k,sum) shared(size,i,a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_lud/omp/lud_omp/0"}
{"code": "for (i = 1; i <= nt; i++)\n{\n  err = (sums[i].real - vdata_real_b[i]) / vdata_real_b[i];\n  double _imopVarPre318;\n  _imopVarPre318 = fabs(err);\n  if (_imopVarPre318 > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_b[i]) / vdata_imag_b[i];\n  double _imopVarPre320;\n  _imopVarPre320 = fabs(err);\n  if (_imopVarPre320 > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/28"}
{"code": "for (int jj = 0; jj < (N + 2); jj += 2)\n{\n  for (int ii = 0; ii < (N + 2); ii += 2)\n  {\n    fill_array3d(new_X, N / 2, ii / 2, jj / 2, 0, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/13"}
{"code": "for (i = 0, j = 0; i < 16; i += 2, j++)\n{\n  out[j] = (in[i] + in[i + 1]) % 62;\n  if (out[j] < 10)\n  {\n    out[j] += 48;\n  }\n  else\n    if (out[j] < 36)\n  {\n    out[j] += 55;\n  }\n  else\n  {\n    out[j] += 61;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dahua_fmt_plug/2"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  sumc += c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < p; k++)\n      sum += X[i][k] * Y[j][k];\n\n    Z[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/1"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  a[x] = 1;\n  b[x] = x;\n  num_threads[x] = -x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_subtract/0"}
{"code": "for (i = 0; i < 100000; i++)\n  Y[i] = F(Y[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.55.1/1"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n  for (k = 0; k < 512; k++)\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n\n\n\n", "pragma": "omp parallel for private(i,j,k) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/matrixmultiply/0"}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    lhs[(5 * n) + 2][i][j][k] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/20"}
{"code": "for (int i = 0; i < n; ++i)\n  if (x[i] != v)\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/sollve_vv/tests/5.0/target_loop/test_target_loop_teams_distribute/1"}
{"code": "for (y = 0; y < ((width * height) * 4); ++y)\n{\n  float d;\n  float dd;\n  float sig;\n  float minus;\n  float s = (10.0f * input[y]) + (100.0f * (1.0f - input[y]));\n  float t = (1.0f * input[y]) + (10.0f * (1.0f - input[y]));\n  float r = (0.01f * input[y]) + (0.05f * (1.0f - input[y]));\n  float sig2 = (0.01f * input[y]) + (0.10f * (1.0f - input[y]));\n  sig = sig2 * sqrtf(t);\n  d = (logf(s / s) + ((r + ((sig2 * sig2) / 2.0f)) * t)) / sig;\n  dd = d - sig;\n  minus = s * expf((-r) * t);\n  output1[y] = (s * func(d)) - (minus * func(dd));\n  output2[y] = (minus * func(-dd)) - (s * func(-d));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_12_parallel_blackscholes/1"}
{"code": "for (int i = 0; i < a; i++)\n{\n  sum += (i * 2) + 1;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task14/0"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  quickSort(&datos[i], 0, tamano - 1);\n  promedios[i] = promedio(datos[i], tamano);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IsraelRamirez/Promediador-Omp-Mpi-Secuencial/openmp-cpp/main/0"}
{"code": "for (ii = id * size; ii < ((id + 1) * size); ii++)\n{\n  fflush(stdout);\n  for (jj = 0; jj < tlines2; jj++)\n  {\n    seq_a = h_a[ii].wsentence;\n    seq_b = h_b[jj].wsentence;\n    mu = 1;\n    delta = 1;\n    N_a = seq_a.length();\n    N_b = seq_b.length();\n    double H[N_a + 1][N_b + 1];\n    double H_max;\n    double M[N_a + 1][N_b + 1];\n    char consensus_a[(N_a + N_b) + 2];\n    char consensus_b[(N_a + N_b) + 2];\n    int I_i[N_a + 1][N_b + 1];\n    int I_j[N_a + 1][N_b + 1];\n    for (i = 0; i <= N_a; i++)\n    {\n      for (j = 0; j <= N_b; j++)\n      {\n        H[i][j] = 0.;\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        temp[0] = H[i - 1][j - 1] + similarity_score(seq_a[i - 1], seq_b[j - 1]);\n        temp[1] = H[i - 1][j] - delta;\n        temp[2] = H[i][j - 1] - delta;\n        temp[3] = 0.;\n        H[i][j] = find_array_max(temp, 4);\n        switch (ind)\n        {\n          case 0:\n            I_i[i][j] = i - 1;\n            I_j[i][j] = j - 1;\n            break;\n\n          case 1:\n            I_i[i][j] = i - 1;\n            I_j[i][j] = j;\n            break;\n\n          case 2:\n            I_i[i][j] = i;\n            I_j[i][j] = j - 1;\n            break;\n\n          case 3:\n            I_i[i][j] = i;\n            I_j[i][j] = j;\n            break;\n\n        }\n\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        if (H[i][j] == 0)\n          M[i][j] = 0;\n        else\n          if (seq_a[i - 1] == seq_b[j - 1])\n          M[i][j] = H[i - 1][j - 1];\n        else\n          M[i][j] = MAX(MAX(MAX(MAX(MAX(M[i - 1][j], H[i - 1][j]), M[i][j - 1]), H[i][j - 1]), M[i - 1][j - 1]), H[i - 1][j - 1]);\n\n\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        H[i][j] = M[i][j];\n      }\n\n    }\n\n    H_max = 0.;\n    i_max = 0;\n    j_max = 0;\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        if (H[i][j] > H_max)\n        {\n          H_max = H[i][j];\n          i_max = i;\n          j_max = j;\n        }\n\n      }\n\n    }\n\n    current_i = i_max;\n    current_j = j_max;\n    next_i = I_i[current_i][current_j];\n    next_j = I_j[current_i][current_j];\n    tick = 0;\n    zzz = 0;\n    while ((((current_i != next_i) || (current_j != next_j)) && (next_j != 0)) && (next_i != 0))\n    {\n      if (next_i == current_i)\n      {\n        consensus_a[tick] = '-';\n        zzz -= mu;\n      }\n      else\n      {\n        consensus_a[tick] = seq_a[current_i - 1];\n        zzz += similarity_score(seq_a[current_i - 1], seq_b[current_j - 1]);\n      }\n\n      if (next_j == current_j)\n      {\n        consensus_b[tick] = '-';\n        zzz -= mu;\n      }\n      else\n      {\n        consensus_b[tick] = seq_b[current_j - 1];\n        zzz += similarity_score(seq_a[current_i - 1], seq_b[current_j - 1]);\n      }\n\n      current_i = next_i;\n      current_j = next_j;\n      next_i = I_i[current_i][current_j];\n      next_j = I_j[current_i][current_j];\n      tick++;\n    }\n\n    float similarity = (float) (zzz / MAX(N_a, N_b));\n    if (similarity > THRESHOLD)\n    {\n      ((((cout << \"\\n!!!Similarity between \") << ii) << \" of source and \") << jj) << \" of destination!!!!!\\n\";\n      sim += 1;\n    }\n    else\n    {\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/hhh/0"}
{"code": "for (i = 0; i < n; i++)\n  suma += a[i];\n\n", "pragma": "omp parallel for reduction(+:suma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/6/reduction-clause/0"}
{"code": "for (i = 0; i < contIndex; i++)\n{\n  j = matrixIndex[i];\n  matrixResultCopy[j] = matrixResult[j];\n}\n\n", "pragma": "omp parallel for private(i,j) firstprivate(matrixResult,matrixResultCopy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ismtabo/cp-2017-scan-sky/omp/ScanSky/0"}
{"code": "for (int i = 0; i < zSize; i++)\n{\n  unsigned nbits = 0;\n  while (n >> nbits)\n    nbits++;\n\n  size_t k = 1ULL << (nbits - 1);\n  T z = acc_z[i];\n  size_t idx = (acc_a[k] <= z) ? (k) : (0);\n  while (k >>= 1)\n  {\n    size_t r = idx | k;\n    if ((r < n) && (z >= acc_a[r]))\n    {\n      idx = r;\n    }\n\n  }\n\n  acc_r[i] = idx;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bsearch-omp/main/1"}
{"code": "for (i = 0; i < ndim; i++)\n{\n  memviewslice->shape[i] = buf->shape[i];\n  if (buf->suboffsets)\n  {\n    memviewslice->suboffsets[i] = buf->suboffsets[i];\n  }\n  else\n  {\n    memviewslice->suboffsets[i] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/27"}
{"code": "for (i = 0; i < size; i++)\n{\n  A[i] = (float *) malloc(size * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/18"}
{"code": "for (i = 0; i < N; i++)\n  L[(i * N) + i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/4"}
{"code": "for (j = 1; j <= 1024; j++)\n{\n  q = j % NX;\n  r = (3 * j) % NY;\n  s = (5 * j) % NZ;\n  my_chk = dcmplx_add(my_chk, u1[s][r][q]);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/7"}
{"code": "for (int i = 0; i < this->coo_nnz_; ++i)\n{\n  this->mat_.COO.col[i] = cast_mat->mat_.COO.col[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_hyb/3"}
{"code": "for (i = 0; i < len; i++)\n  cs.lotus85_user_blob[i] = (atoi16[ARCH_INDEX(ciphertext[i << 1])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i << 1) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus85_fmt_plug/7"}
{"code": "for (i = 0; i < 1; ++i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr25996/0"}
{"code": "for (k = 0; k < N; k++)\n{\n  allValue[k] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brightdo/genPrimeNumbers/genprimes/2"}
{"code": "for (i = 0; i < ((ncols < numprocs) ? (ncols) : (numprocs)); i++)\n{\n  for (j = 0; j < (strp_rows * ncols); j++)\n  {\n    strp_buffer[j] = aa[((i * strp_rows) * ncols) + j];\n  }\n\n  MPI_Send(strp_buffer, strp_rows * ncols, (MPI_Datatype) 0x4c00080b, i + 1, i + 1, 1);\n  strp_sent++;\n}\n\n", "pragma": "omp shared(strp_ret) for reduction(+:strp_ret)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/0"}
{"code": "for (j = 0; j < ((arr_size - i) - 1); j++)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    aux = arr[j];\n    arr[j] = arr[j + 1];\n    arr[j + 1] = aux;\n    replaced = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fgrehm/pucrs-mpi-openmp-master_slave/mpi_master_slave/7"}
{"code": "for (j = 0; j < model->r_size; ++j)\n{\n  xi = xi_fun(gsl_vector_get(model->tB_vec, j), gsl_vector_get(model->M_vec, j), gsl_vector_get(model->E_vec, j), gsl_vector_get(model->t_vec, i), model->cur);\n  eta = eta_fun(xi, model->cur, eta_interp);\n  gsl_matrix_set(model->R_mat, i, j, R_fun(gsl_vector_get(model->M_vec, j), gsl_vector_get(model->E_vec, j), eta, model->cur));\n}\n\n", "pragma": "omp for schedule(dynamic, chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/1"}
{"code": "for (int i = 2; i < 10000000; i++)\n{\n  if (check(i))\n  {\n    sum += i;\n    printf(\"the number is equal to : %d\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex30projecteuler/1"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  current[0][i] = rand() % 30;\n  current[i][0] = rand() % 30;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab6_OpenMP/macropipelinev2/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (i = ist; i <= iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n      }\n\n    }\n\n    L2 = nx - 1;\n    for (i = ist; i <= L2; i++)\n    {\n      tmp = 1.0 / u[i][j][k][0];\n      u21i = tmp * u[i][j][k][1];\n      u31i = tmp * u[i][j][k][2];\n      u41i = tmp * u[i][j][k][3];\n      u51i = tmp * u[i][j][k][4];\n      tmp = 1.0 / u[i - 1][j][k][0];\n      u21im1 = tmp * u[i - 1][j][k][1];\n      u31im1 = tmp * u[i - 1][j][k][2];\n      u41im1 = tmp * u[i - 1][j][k][3];\n      u51im1 = tmp * u[i - 1][j][k][4];\n      flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][j][k][2] = tx3 * (u31i - u31im1);\n      flux[i][j][k][3] = tx3 * (u41i - u41im1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * (((pow2(u21i) + pow2(u31i)) + pow2(u41i)) - ((pow2(u21im1) + pow2(u31im1)) + pow2(u41im1)))) + (((1.0 / 6.0) * tx3) * (pow2(u21i) - pow2(u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i <= iend; i++)\n    {\n      rsd[i][j][k][0] = rsd[i][j][k][0] + ((dx1 * tx1) * ((u[i - 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i + 1][j][k][0]));\n      rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((u[i - 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i + 1][j][k][1]));\n      rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((u[i - 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i + 1][j][k][2]));\n      rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((u[i - 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i + 1][j][k][3]));\n      rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((u[i - 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i + 1][j][k][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[1][j][k][m] = rsd[1][j][k][m] - (dssp * ((((+5.0) * u[1][j][k][m]) - (4.0 * u[2][j][k][m])) + u[3][j][k][m]));\n      rsd[2][j][k][m] = rsd[2][j][k][m] - (dssp * (((((-4.0) * u[1][j][k][m]) + (6.0 * u[2][j][k][m])) - (4.0 * u[3][j][k][m])) + u[4][j][k][m]));\n    }\n\n    ist1 = 3;\n    iend1 = nx - 4;\n    for (i = ist1; i <= iend1; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[nx - 3][j][k][m] = rsd[nx - 3][j][k][m] - (dssp * (((u[nx - 5][j][k][m] - (4.0 * u[nx - 4][j][k][m])) + (6.0 * u[nx - 3][j][k][m])) - (4.0 * u[nx - 2][j][k][m])));\n      rsd[nx - 2][j][k][m] = rsd[nx - 2][j][k][m] - (dssp * ((u[nx - 4][j][k][m] - (4.0 * u[nx - 3][j][k][m])) + (5.0 * u[nx - 2][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, u21i, u31i, u41i, u51i, u21im1, u31im1, u41im1, u51im1, ist1, iend1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/37"}
{"code": "for (i = 0; i <= (dims[2][0] - 1); i += 1)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n  ii2 = ii * ii;\n  for (j = 0; j <= (dims[2][1] - 1); j += 1)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k <= (dims[2][2] - 1); k += 1)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (ii,ii2,jj,ij2,kk,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/2"}
{"code": "for (int i = 0; i < num; i++)\n{\n  v[i] = info[i][7].toDouble();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/4"}
{"code": "for (int i = 0; i < output_numel; ++i)\n{\n  output[i] = ((float) rand()) / ((float) RAND_MAX);\n  output_grad[i] = input_width * input_height;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/pool-omp/main/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < colums; j++)\n  {\n    fscanf(pf, \"%lf\", &M[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markopand/Code/LU algorithm OpenMP/6"}
{"code": "for (int i = 0; i < 10; i++)\n  count[i] = word_count(file_name, words[i]);\n\n", "pragma": "    #pragma omp parallel for num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/8_word_search/search/0"}
{"code": "for (c = 0; c < channels_col; c++)\n{\n  for (h = 0; h < height_col; h++)\n  {\n    for (w = 0; w < width_col; w++)\n    {\n      w_offset = c % ksize;\n      h_offset = (c / ksize) % ksize;\n      c_im = (c / ksize) / ksize;\n      row = h_offset + (h * stride);\n      col = w_offset + (w * stride);\n      out_index = (((((b * height) * width) * channels) + ((c_im * height) * width)) + (row * width)) + col;\n      col_index = (((c * height_col) * width_col) + (h * width_col)) + w;\n      row -= pad;\n      col -= pad;\n      if (!((((row < 0) || (col < 0)) || (row >= height)) || (col >= width)))\n      {\n        delta_out[out_index] += conv_t2[col_index];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-gpu/7"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_threadprivate_for())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/threadprivate/omp_threadprivate_for/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  printf(\"%d \\t\", array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex5/2"}
{"code": "for (I = 0; I < M; I++)\n{\n  UOLD[I][N] = UOLD[I][0];\n  VOLD[I][N] = VOLD[I][0];\n  POLD[I][N] = POLD[I][0];\n  U[I][N] = U[I][0];\n  V[I][N] = V[I][0];\n  P[I][N] = P[I][0];\n}\n\n", "pragma": "omp for simd nowait schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/8"}
{"code": "for (int g = 0; g < 2; g++)\n{\n  for (int i = 0; i <= N; i++)\n  {\n    for (int j = 0; j <= N; j++)\n    {\n      Matrix[g][i][j] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/jacobi/1"}
{"code": "for (i = 0; i < (lDIM * nDIM); i++)\n  posix_memalign((double **) (&b[i]), getpagesize(), (BSIZE * BSIZE) * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/17"}
{"code": "for (j = 1; j < (((L / 5) + 2) - 1); j++)\n{\n  i = 0;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = grn[j];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = grn[j];\n\n  i = ((L / 1) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = grs[j];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = grs[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/43"}
{"code": "for (i = myPointSize; i < allPointsSize; i++)\n  MPI_Recv(&allPoints[i], 1, MPI_POINT_TYPE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &status);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/4"}
{"code": "for (size_t i = 1; i < size; i++)\n{\n  size_t row_start = (size_t) (i * rows_per_worker);\n  size_t amt_of_rows = (size_t) (((i + 1) * rows_per_worker) - row_start);\n  num_organisms[i - 1] = (process_info[0] = amt_of_rows * world_size);\n  beginning[i - 1] = (process_info[1] = row_start * world_size);\n  MPI_Send(process_info, 2, (MPI_Datatype) 0x4c000204, i, 0, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/11"}
{"code": "for (i = 0; (i < 81) && (num_pos_probades < 4); i++)\n{\n  if (!taula[i / 9][i % 9])\n  {\n    pos_probades[num_pos_probades][0] = i / 9;\n    pos_probades[num_pos_probades][1] = i % 9;\n    num_pos_probades++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AleixMT/Massive-Parallel-Computing/OpenMP/P1.2/P1.2_CPM_MarineRuiz/5"}
{"code": "for (int i = 0; i < 2000000; i++)\n{\n  a[i] = rand() % (2000000 - 1000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E1/max/1"}
{"code": "for (i = 0; i < image->n_images; i++)\n{\n  width = image->width[i];\n  height = image->height[i];\n  pixel *pi = p[i];\n  if ((width * height) > 200000)\n  {\n    apply_gray_filter_omp(width, height, pi);\n    apply_blur_filter_omp(width, height, pi, 5, 20);\n    apply_sobel_filter(width, height, pi);\n  }\n  else\n  {\n    apply_gray_filter(width, height, pi);\n    apply_blur_filter(width, height, pi, 5, 20);\n    apply_sobel_filter(width, height, pi);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/mpi_mode_0/1"}
{"code": "for (nchunks = 0, psum = 0, vi = vistart; vi < viend; vi++)\n{\n  if ((psum += nxadj[vi + 1] - nxadj[vi]) >= chunksize)\n  {\n    nchunks++;\n    psum = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/12"}
{"code": "for (i = 0; i < lDIM; ++i)\n{\n  for (j = 0; j < nDIM; ++j)\n  {\n    tileC[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  fprintf(f, \"%d\\t\", i + 1);\n  fprintf(f, \"%d\\t\", p->w5[i]);\n  fprintf(f, \"%d\\n\", p->w3[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/frna-omp/frna/10"}
{"code": "for (iter = 1; iter <= timesteps; iter++)\n{\n  for (i = 0; i < ARCHnodes; i++)\n    for (j = 0; j < 3; j++)\n    disp[disptplus][i][j] = 0.0;\n\n\n  smvp(ARCHnodes, K, ARCHmatrixcol, ARCHmatrixindex, disp[dispt], disp[disptplus]);\n  time = iter * Exc.dt;\n  for (i = 0; i < ARCHnodes; i++)\n  {\n    for (j = 0; j < 3; j++)\n    {\n      disp[disptplus][i][j] *= (-Exc.dt) * Exc.dt;\n      disp[disptplus][i][j] += (((2.0 * M[i][j]) * disp[dispt][i][j]) - ((M[i][j] - ((Exc.dt / 2.0) * C[i][j])) * disp[disptminus][i][j])) - ((Exc.dt * Exc.dt) * ((((M23[i][j] * phi2(time)) / 2.0) + ((C23[i][j] * phi1(time)) / 2.0)) + ((V23[i][j] * phi0(time)) / 2.0)));\n      disp[disptplus][i][j] = disp[disptplus][i][j] / (M[i][j] + ((Exc.dt / 2.0) * C[i][j]));\n      vel[i][j] = (0.5 / Exc.dt) * (disp[disptplus][i][j] - disp[disptminus][i][j]);\n    }\n\n  }\n\n  if ((iter % Step_stride) == 0)\n  {\n    fprintf(stderr, \"Time step %d\\n\", iter);\n    if (Src.sourcenode <= ARCHmine)\n      printf(\"%d: %.2e %.2e %.2e\\n\", ARCHglobalnode[Src.sourcenode], disp[disptplus][Src.sourcenode][0], disp[disptplus][Src.sourcenode][1], disp[disptplus][Src.sourcenode][2]);\n\n    if (Src.epicenternode <= ARCHmine)\n      printf(\"%d: %.2e %.2e %.2e\\n\", ARCHglobalnode[Src.epicenternode], disp[disptplus][Src.epicenternode][0], disp[disptplus][Src.epicenternode][1], disp[disptplus][Src.epicenternode][2]);\n\n    fflush(stdout);\n  }\n\n  i = disptminus;\n  disptminus = dispt;\n  dispt = disptplus;\n  disptplus = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Satvikkul/OpenMP-Assignment/CODE/quake1/0"}
{"code": "for (c = 0; c < channels_col; ++c)\n{\n  int w_offset = (c % ksize) + 1;\n  int h_offset = ((c / ksize) % ksize) + 1;\n  int c_im = (c / ksize) / ksize;\n  for (h = 0; h < height_col; ++h)\n  {\n    for (w = 0; w < width_col; ++w)\n    {\n      int im_row = ((h_offset * dilate_rate) + (h * stride)) - 1;\n      int im_col = ((w_offset * dilate_rate) + (w * stride)) - 1;\n      int col_index = (((c * height_col) + h) * width_col) + w;\n      data_col[col_index] = im2col_get_pixel(data_im, height, width, channels, im_row, im_col, c_im, pad);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/im2col/0"}
{"code": "for (int i = 0; i < 1024; i++)\n  b[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-omp/clang/test/OpenMP/target_control_loop_codegen_for_c/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    n = ((m - 3) + 1) * 5;\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (n,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/177"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Iteration %d executed by thread %d\\n\", i, 0);\n  for (j = 0; j < i; j++)\n    system(\"sleep 1\");\n\n}\n\n", "pragma": "omp parallel for default(none) schedule(runtime) private(i,j) shared(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.43-schedule-clause/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = ptr[i]; j < ptr[i + 1]; j++)\n  {\n    index[j] = 0;\n    value[j] = 0.0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMP/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  d[i] = 0.0;\n  for (int u = ptr[i]; u < ptr[i + 1]; u++)\n  {\n    if ((deb + i) == colIndex[u])\n    {\n      d[i] += values[u];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(d)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/0"}
{"code": "for (int i = 0; i < INITIAL_INFECTED_COUNT; ++i)\n{\n  individuals[i].infect();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/temp3rr0r/InfectiousDiseaseModelling/InfectiousDiseaseModeling/InfectiousDiseaseModeling/0"}
{"code": "for (end_iter = omp_end_pragma_list.rbegin(); end_iter != omp_end_pragma_list.rend(); end_iter++)\n  removeStatement(*end_iter);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/src/frontend/SageIII/ompAstConstruction/0"}
{"code": "for (size_t i_node = 0; i_node < rThisGeometry.size(); ++i_node)\n{\n  AtomicAddVector(rThisGeometry[i_node].GetValue(rThisVar), (N[i_node] * origin_value) * Weight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_processes/internal_variables_interpolation_process/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    double dot = 0;\n    for (k = 0; k < n; k++)\n    {\n      dot += A[(i * n) + k] * B2[(j * n) + k];\n    }\n\n    C[(i * n) + j] = dot;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/cache_friedly_mm/1"}
{"code": "for (int p = 0; p < NUMPAT; p++)\n  ranpat[p] = p;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Raptorino/NeuralNetworkMIMD/Code_OpenMP/nn-main/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/20"}
{"code": "for (; (i + 0) < n; i += 1)\n{\n  y[i] = x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/7"}
{"code": "for (int j = 0; j < MAX_LENGTH; j++)\n{\n  tempA += (a[j] - meanA) * (a[j] - meanA);\n  tempB += (b[j] - meanB) * (b[j] - meanB);\n  tempSum += (a[j] - meanA) * (b[j] - meanB);\n}\n\n", "pragma": "omp parallel for reduction(+:tempA) reduction(+:tempB) reduction(+:tempSum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/meismyles/pearson-cc/openmp/PearsonCC/1"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n  vector[i][ny - 2][1] += vector[i][ny - 1][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/33"}
{"code": "for (int k = 0; k <= floor(n / 2); k++)\n{\n  if (out[k] != 0)\n    printf(\"%d \", out[k]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisfrt/openmp-primenumbers/main/0"}
{"code": "for (k = 0; k < clusters_count; ++k)\n{\n  tnum = omp_get_thread_num();\n  double centX = 0.0;\n  double centY = 0.0;\n  int l;\n  for (l = 0; l < clusters[k].member_count; ++l)\n  {\n    centX += clusters[k].members[l].x;\n    centY += clusters[k].members[l].y;\n  }\n\n  if (clusters[k].member_count == 0)\n  {\n    continue;\n  }\n\n  centX = centX / clusters[k].member_count;\n  centY = centY / clusters[k].member_count;\n  clusters[k].centroid.x = centX;\n  clusters[k].centroid.y = centY;\n  printf(\"Thread Rank: %d Recalculated Centroid for Cluster Number: %d\\n\", tnum, k);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OmarKhaledm21/K-MEANS_Clustering-C_OpenMP-/K_MEANS_CLUSTERING/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  if (flag[i] == j)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/12"}
{"code": "for (ix = start; ix <= end; ix++)\n{\n  for (iy = 1; iy <= (ny - 2); iy++)\n  {\n    *((u2 + (ix * ny)) + iy) = ((*((u1 + (ix * ny)) + iy)) + (parms.cx * (((*((u1 + ((ix + 1) * ny)) + iy)) + (*((u1 + ((ix - 1) * ny)) + iy))) - (2.0 * (*((u1 + (ix * ny)) + iy)))))) + (parms.cy * (((*(((u1 + (ix * ny)) + iy) + 1)) + (*(((u1 + (ix * ny)) + iy) - 1))) - (2.0 * (*((u1 + (ix * ny)) + iy)))));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/spirosdelviniotis/parallel_programming/OpenMP/Pure_OpenMP_main/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    grid[i][j] = 0;\n    new_grid[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carmesim/concurrent-gol-hl/C/game_of_life/game_of_life/0"}
{"code": "for (long i = 0; i < (MaxDegree * NVer); i++)\n  Mark[i] = -1;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringDistanceOne/5"}
{"code": "for (j = 0; j < 1024; j++)\n  ran[j] = HPCC_starts_LCG(((4 * TableSize) / 1024) * j);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/2"}
{"code": "for (int i = 1; i <= threads_hardware; i++)\n{\n  double time = calculate_rnd_matrix(1000, i);\n  (((cout << setprecision(4)) << setw(12)) << left) << (\"|\" + to_string(time));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BRUS1NATOR/MatrixMul/MatrixMulOpenMP/4"}
{"code": "for (int i = 0; i < size; i++)\n  printf(\"B[%d]: %f\\n\", i, B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/16"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < L; j++)\n  {\n    temporary = BOLD[(i * L) + j];\n    BOLD_transpose[(j * N) + i] = temporary;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/6"}
{"code": "for (int i = 5; i < 16; i = baz(&i) + i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/54"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv19[layer19_index];\n    if (conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/71"}
{"code": "for (size_t i = 0; i < numRow; i++)\n{\n  int neiIndex = neighbourList[(index * maxNeiNum) + i];\n  double h = m_pParticleData->m_vPositionX[neiIndex] - m_pParticleData->m_vPositionX[index];\n  double k = m_pParticleData->m_vPositionY[neiIndex] - m_pParticleData->m_vPositionY[index];\n  A[i] = h;\n  A[i + (1 * numRow)] = k;\n  A[i + (2 * numRow)] = (0.5 * h) * h;\n  A[i + (3 * numRow)] = (0.5 * k) * k;\n  A[i + (4 * numRow)] = h * k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/22"}
{"code": "for (int pos = 0; pos < slice_size; pos++)\n  image_slice[pos] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Davide95/mandelbrot-CUCL/code/mpi/degree2/0"}
{"code": "for (int yy = 0; yy < _settings._size; yy++)\n  for (int xx = 0; xx < _settings._size; xx++)\n{\n  if (_settings._buffer[(yy * _settings._size) + xx] == _settings._iter)\n    injectPoint(xx, yy);\n  else\n    injectPoint(xx, yy, 255);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GuillaumeBouchetEpitech/Qt-OpenMP-Fractales/src/Fractale/1"}
{"code": "for (j = 0; j < ((int) MaxY); j++)\n{\n  for (i = 0; i < ((int) MaxX); i++)\n  {\n    ((*OutputData) << ((i * dx_out) * 1.e3)) << \"  \";\n    ((*OutputData) << ((dy_out * j) * 1.e3)) << \"  \";\n    Mach = (Re = (Re_t = 0));\n    if (!J->GetValue(i, j).isCond2D(CT_SOLID_2D))\n    {\n      ((*OutputData) << J->GetValue(i, j).U) << \"  \";\n      ((*OutputData) << J->GetValue(i, j).V) << \"  \";\n      ((*OutputData) << J->GetValue(i, j).Tg) << \"  \";\n      ((*OutputData) << J->GetValue(i, j).p) << \"  \";\n      ((*OutputData) << J->GetValue(i, j).S[0]) << \"  \";\n      A = sqrt(((J->GetValue(i, j).k * J->GetValue(i, j).R) * J->GetValue(i, j).Tg) + 1.e-30);\n      W = sqrt(((J->GetValue(i, j).U * J->GetValue(i, j).U) + (J->GetValue(i, j).V * J->GetValue(i, j).V)) + 1.e-30);\n      Mach = W / A;\n      if (J->GetValue(i, j).S[0] != 0.)\n      {\n        ((*OutputData) << (J->GetValue(i, j).S[4] / J->GetValue(i, j).S[0])) << \"  \";\n        ((*OutputData) << (J->GetValue(i, j).S[5] / J->GetValue(i, j).S[0])) << \"  \";\n        ((*OutputData) << (J->GetValue(i, j).S[6] / J->GetValue(i, j).S[0])) << \"  \";\n        ((*OutputData) << fabs(((1 - (J->GetValue(i, j).S[4] / J->GetValue(i, j).S[0])) - (J->GetValue(i, j).S[5] / J->GetValue(i, j).S[0])) - (J->GetValue(i, j).S[6] / J->GetValue(i, j).S[0]))) << \"  \";\n        if (is_p_asterisk_out)\n          ((*OutputData) << p_asterisk(&J->GetValue(i, j))) << \"  \";\n        else\n          ((*OutputData) << (J->GetValue(i, j).mu_t / J->GetValue(i, j).mu)) << \"  \";\n\n      }\n      else\n      {\n        (*OutputData) << \" +0. +0  +0  +0  +0  \";\n      }\n\n    }\n    else\n    {\n      (*OutputData) << \"  0  0  \";\n      (*OutputData) << J->GetValue(i, j).Tg;\n      (*OutputData) << \"  0  0  0  0  0  0  0\";\n    }\n\n    if (!J->GetValue(i, j).isCond2D(CT_SOLID_2D))\n    {\n      if (Mach > 1.e-30)\n        (((((*OutputData) << Mach) << \"  \") << J->GetValue(i, j).l_min) << \" \") << J->GetValue(i, j).y_plus;\n      else\n        (*OutputData) << \"  0  0  0  \";\n\n    }\n    else\n    {\n      (*OutputData) << \"  0  0  0  \";\n    }\n\n    if (is_Cx_calc)\n      (((*OutputData) << \" \") << Calc_Cp(&J->GetValue(i, j), Flow2DList->GetElement(Cx_Flow_index - 1))) << \"\\n\";\n    else\n      (*OutputData) << \" 0\\n\";\n\n  }\n\n  if (type)\n    (*OutputData) << \"\\n\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/17"}
{"code": "for (i = 0; i < length_of_array; i++)\n{\n  mean_of_a += a[i] / length_of_array;\n  mean_of_b += b[i] / length_of_array;\n}\n\n", "pragma": "omp for private(i) reduction(+:mean_of_a, mean_of_b)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luketowell/openMP_PCC/parallel/parallel-pinit-mean/1"}
{"code": "for (i = 0; i < n; i++)\n  scanf(\"%lf %lf %lf\", x + (i * 3), (x + (i * 3)) + 1, (x + (i * 3)) + 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lineu96/relatorio_openmp/arquivos/02_kmeans/kmeans_paralelo/3"}
{"code": "for (int k = Process_Num - i; k > 1; k--)\n{\n  cout << \"----\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nanyuu/Matrix-multiplication-OpenMP/OpenMP/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  int j;\n  int v = a[i];\n  for (j = i - 1; j >= 0; j--)\n  {\n    if (a[j] <= v)\n      break;\n\n    a[j + 1] = a[j];\n  }\n\n  a[j + 1] = v;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GlenGGG/FastParallelMergeSort/omp_mergesort/9"}
{"code": "for (int n = 0; n < 5; n++)\n{\n  center_indexes[n] = distr(eng);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/midNight-jam/openmp_lessons/knn_omp/2"}
{"code": "for (i = k1; i < k2; i++)\n{\n  x = randlc(&s, &an);\n  x += randlc(&s, &an);\n  x += randlc(&s, &an);\n  x += randlc(&s, &an);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/0"}
{"code": "for (int L = 2; L < n; L++)\n{\n  for (int i = 1; i < ((n - L) + 1); i++)\n  {\n    int j = (i + L) - 1;\n    m[i + ((j * (j - 1)) / 2)] = MAX;\n    for (int k = i; k <= (j - 1); k++)\n    {\n      q = (m[i + ((k * (k - 1)) / 2)] + m[(k + 1) + ((j * (j - 1)) / 2)]) + ((p[i - 1] * p[k]) * p[j]);\n      if (q < m[i + ((j * (j - 1)) / 2)])\n      {\n        m[i + ((j * (j - 1)) / 2)] = q;\n        bracket[i + ((j * (j - 1)) / 2)] = k;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/7"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*class) == 'U')\n  {\n    printf(\"          %2d%20.13e\\n\", m, xcr[m]);\n  }\n  else\n    if (xcrdif[m] > epsilon)\n  {\n    *verified = FALSE;\n    printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n  else\n  {\n    printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adk9/NPB2.3-omp-C/BT/bt/0"}
{"code": "for (k = 0; k < g->n[i].top; k++)\n  if (g->n[i].adj[k] == j)\n  return;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/part3b/3"}
{"code": "for (i = 0; i < nvar; i++)\n{\n  matrix[i] = calloc(nvar, sizeof(long double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cthadeusantos/gauss-seidel/gseidel_mp_schedule/1"}
{"code": "for (y = max(1, r); y < min(GLOBAL_GRID_W - 1, r + OMP_THREADS); ++y)\n  send_matrix_buf[y - r] = buf_grid_values[get_index_row(proc_x_indices.first, y)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/17"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (maxq < L[i])\n  {\n    maxq = L[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(max:maxq)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code-mj12/Multithreaded-Codes/OpenMP/q1c/3"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  assert(z[i][j] == ((i * mul) * col_sum));\n\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abiharb/trabalho01_arqComputadores/paralelo/2"}
{"code": "for (int time = 0; time < 20; time++)\n{\n  testing_loop(time, f_fitness);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markub3327/MazeSolver_GA/main/1"}
{"code": "for (i = 0; i < 729; i++)\n{\n  for (j = 0; j < 729; j++)\n  {\n    a[i][j] = 0.0;\n    b[i][j] = 3.142 * (i + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IKrepo/OpenMP_Scheduling/Part A/Part_A_Mean/3"}
{"code": "for (int i = 1; i < NUM_MEM_BUFFERS; ++i)\n{\n  memBuffers[i] = NULL;\n  memBufferSize[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/0"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  for (int j = 1; j < (n - 1); j++)\n  {\n    float F = *IDX(cur, i, j, n);\n    float *out = IDX(next, i, j, n);\n    if ((*IDX(cur, i, j - 1, n)) > 4.0f)\n    {\n      F += FDELTA;\n    }\n\n    if ((*IDX(cur, i, j + 1, n)) > 4.0f)\n    {\n      F += FDELTA;\n    }\n\n    if ((*IDX(cur, i - 1, j, n)) > 4.0f)\n    {\n      F += FDELTA;\n    }\n\n    if ((*IDX(cur, i + 1, j, n)) > 4.0f)\n    {\n      F += FDELTA;\n    }\n\n    if (F > 4.0f)\n    {\n      F -= 4.0f;\n    }\n\n    *out = F;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(n,cur,next) schedule(SCHED_TYPE, SCHED_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fam4r/uni-hpc/project/src/omp-earthquake/2"}
{"code": "for (unsigned int i = 0; i < number; i++)\n  if (is_alive[i])\n{\n  if (((isnan(pos[i][0]) || (isinf(pos[i][0]) != 0)) || isnan(pos[i][2])) || (isinf(pos[i][2]) != 0))\n  {\n    (((((cerr << \"ERROR(half_step_pos): radius[\") << i) << \"] or longitude[\") << i) << \"] is not valid number. Can not continue.\") << endl;\n    exit(1);\n  }\n\n  pos[i][0] = pos[i][0] + (vel[i][0] * half_dt);\n  pos[i][1] = pos[i][1] + (vel[i][1] * half_dt);\n  pos[i][2] = pos[i][2] + (vel[i][2] * half_dt);\n}\n\n\n", "pragma": "#pragma omp parallel for shared (half_dt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/0"}
{"code": "for (i = 2; i < (N - 1); i += 2)\n  u[i] = (hsq * (f - (((-u[i - 1]) - u[i + 1]) / hsq))) / 2;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jpmcd/HPC15-hw3/gs-omp/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/46"}
{"code": "for (int y = 0; y < height; y++)\n{\n  double imaginaryValue = upperLeftY - (y * incrementY);\n  double realValue = upperLeftX;\n  for (unsigned int x = 0; x < width; x++)\n  {\n    escapeCounts[(y * width) + x] = escapeTime(realValue, imaginaryValue, numberOfIterations);\n    realValue += incrementX;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Balta-Stefan/Mandelbrot-viewer/src/Mandelbrotters/mandelbrot_cpu_parallel/0"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  for (j = 0; j < 4; ++j)\n  {\n    printf(\"do %d\\n\", i);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenCMISS-Dependencies/opari2/test/data/test3/2"}
{"code": "for (int i = y; i < (y + height); i++)\n  for (int j = x; j < (x + width); j++)\n  change += compute_new_state_stable(i, j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/20"}
{"code": "for (unsigned int idx = 0; idx < 1024; idx++)\n  ap[idx] = bp[idx];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr68640/0"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    if (!obstacles[ii + (jj * params.nx)])\n    {\n      float local_density = (((((((cells->speed_0[ii + (jj * params.nx)] + cells->speed_1[ii + (jj * params.nx)]) + cells->speed_2[ii + (jj * params.nx)]) + cells->speed_3[ii + (jj * params.nx)]) + cells->speed_4[ii + (jj * params.nx)]) + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_6[ii + (jj * params.nx)]) + cells->speed_7[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)];\n      float u_x = (((cells->speed_1[ii + (jj * params.nx)] + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)]) - ((cells->speed_3[ii + (jj * params.nx)] + cells->speed_6[ii + (jj * params.nx)]) + cells->speed_7[ii + (jj * params.nx)])) / local_density;\n      float u_y = (((cells->speed_2[ii + (jj * params.nx)] + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_6[ii + (jj * params.nx)]) - ((cells->speed_4[ii + (jj * params.nx)] + cells->speed_7[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)])) / local_density;\n      tot_u += sqrtf((u_x * u_x) + (u_y * u_y));\n      tot_cells++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreiCNitu/HPC/lattice-boltzmann/openMP/lbm/4"}
{"code": "for (c1 = 0; c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/28"}
{"code": "for (int i = 0; i < l; i++)\n  alpha_[active_set[i]] = alpha[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/13"}
{"code": "for (i = 0; i < (n * n); ++i)\n{\n  uo[i] = u0[i];\n  uc[i] = u1[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/majetyhk/ParallelProgramming/HW3/p2/V2/lake/0"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  x_d[i] = 0.0001 * i;\n  y_d[i] = 0.00003 * i;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_teams(120*4) thread_limit(512) schedule(static,chunk) is_device_ptr(x_d,y_d) if(target:use_device)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-273739/clang-273739/0"}
{"code": "for (int i = 1; i < (ny - 1); i++)\n  vector[1][i][1] += vector[0][i][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/27"}
{"code": "for (unsigned i = 0; i < num_h_neurons; ++i)\n{\n  for (unsigned j = 0; j < num_v_neurons; ++j)\n  {\n    myRBM.W.at(i).at(j) = myRBM.W.at(i).at(j);\n    sum += myRBM.W.at(i).at(j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/1"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n  x1[i] += a[(i * 2048) + j] * y1[j];\n\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/12"}
{"code": "for (int x = 0; x < (m * n); x++)\n{\n  C[x] = X * C[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/machadoprx/CoolConvNN/gemm/2"}
{"code": "for (i = 0; i < N_samples; i++)\n{\n  k_best = 0;\n  dist_min = correlation(N_features, X[i], old_cluster_centers[k_best]);\n  for (k = 1; k < N_clusters; k++)\n  {\n    dist = correlation(N_features, X[i], old_cluster_centers[k]);\n    if (dist < dist_min)\n    {\n      dist_min = dist;\n      k_best = k;\n    }\n\n  }\n\n  labels[i] = k_best;\n  dist_sum_new += dist_min;\n}\n\n", "pragma": "omp parallel for default(shared) schedule(static) private(i,j,k,k_best,dist,dist_min) reduction(+:dist_sum_new)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JiaweiZhuang/CS205_final_project/Parallel_Algorithm/MPI/Kmean_mpi/0"}
{"code": "for (i = 0; i < matrixSize; i++)\n{\n  sprintf(comma, \"%s\", \"\");\n  for (j = 0; j < matrixSize; j++)\n  {\n    double d = getRand(min, max);\n    array[i][j] = d;\n    double d1 = getRand(min, max);\n    array4[i][j] = d1;\n    fprintf(fp, \"%s%f\", comma, d);\n    fprintf(fp1, \"%s%f\", comma, d1);\n    sprintf(comma, \"%s\", \",\");\n    array2[i][j] = 0;\n  }\n\n  fprintf(fp, \"\\n\");\n  fprintf(fp1, \"\\n\");\n}\n\n", "pragma": "omp parallel for shared(array, array2, array4) private( i, j, k) num_threads(nThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PureDevPer/Distributed-and-Parallel-Computing/openMP/Parallel/hw5Omp/0"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  curr_num_edges = edge_count[i];\n  while (curr_num_edges < 32)\n  {\n    rand_vertex = rand() % num_vertices;\n    weight = (rand() % 100000) + 1;\n    if ((rand_vertex != i) && (graph[(i * num_vertices) + rand_vertex] == 0))\n    {\n      graph[(i * num_vertices) + rand_vertex] = weight;\n      graph[(rand_vertex * num_vertices) + i] = weight;\n      edge_count[i] += 1;\n      curr_num_edges++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/7"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  tmpPosition[i].x = satelites[i].position.x;\n  tmpPosition[i].y = satelites[i].position.y;\n  tmpVelocity[i].x = satelites[i].velocity.x;\n  tmpVelocity[i].y = satelites[i].velocity.y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/2"}
{"code": "for (icol = 0; icol < ndiag; icol++)\n{\n  jj = 0;\n  if (world_rank == kk)\n  {\n    idiag = icol + 1;\n    mycol = idiag;\n    myrow = idiag;\n    colklass = mycol;\n    rowklass = myrow;\n    diagklass = 1;\n  }\n\n  kk++;\n  for (jj = 1; jj < nsegments; jj++)\n  {\n    if (world_rank == kk)\n    {\n      mycol = icol + 1;\n      myrow = (world_rank / nsegments) + jj;\n      myrow = (myrow % ndiag) + 1;\n      colklass = mycol;\n      rowklass = myrow;\n    }\n\n    kk++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdafibuzzaman/openmp-task-distributed/lobpcg_dist/6"}
{"code": "for (int i = 0; i < current; i++)\n{\n  if (array[i] == array[current])\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/15"}
{"code": "for (int i = 0; i < n; i++)\n{\n  c = table[i] * table[i];\n  printf(\"\\n square of %d = %d \", table[i], c);\n  printf(\"Thread number %d \\n\", omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5/2"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  if (thread_id[i] > maxThrd)\n    maxThrd = thread_id[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/threads/threads/2"}
{"code": "for (mat_row = 0; mat_row < n; mat_row++)\n{\n  grid_row = mat_row / local_A->n_bar;\n  coords[0] = grid_row;\n  for (grid_col = 0; grid_col < grid->q; grid_col++)\n  {\n    coords[1] = grid_col;\n    MPI_Cart_rank(grid->comm, coords, &dest);\n    if (dest == 0)\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        fscanf(fp, \"%lf\", (local_A->entries + (mat_row * local_A->n_bar)) + mat_col);\n\n    }\n    else\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        fscanf(fp, \"%lf\", temp + mat_col);\n\n      MPI_Send(temp, local_A->n_bar, (MPI_Datatype) 0x4c00080b, dest, 0, grid->comm);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/4"}
{"code": "for (j = 0; j < nd; j++)\n{\n  v_scores[j] = 0.0;\n  for (i = 0; i < nd; i++)\n  {\n    v_scores[j] += matrix[i][j] / rowsums[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/7"}
{"code": "for (i = 0; i < 64; i++)\n{\n  a[0] += i;\n  a[1] += 2 * i;\n  a[2] += 3 * i;\n}\n\n", "pragma": "omp for schedule (static, 1) reduction (+:a[:3])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-15/0"}
{"code": "for (int i = 0; i < str_len; i++)\n{\n  cin >> a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_2/search/1"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  int i;\n  memcpy(BF_current[lindex].S, BF_init_state.S, sizeof(BF_current[lindex].S));\n  memcpy(BF_current[lindex].P, BF_init_key[index], sizeof(BF_current[lindex].P));\n  L0 = (R0 = 0);\n  for (i = 0; i < (16 + 2); i += 2)\n  {\n    L0 ^= salt->salt[i & 2];\n    R0 ^= salt->salt[(i & 2) + 1];\n    L0 ^= BF_current[lindex].P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current[lindex].P[16 + 1];\n    ;\n    BF_current[lindex].P[i] = L0;\n    BF_current[lindex].P[i + 1] = R0;\n  }\n\n  ptr = BF_current[lindex].S[0];\n  do\n  {\n    ptr += 4;\n    L0 ^= salt->salt[(16 + 2) & 3];\n    R0 ^= salt->salt[(16 + 3) & 3];\n    L0 ^= BF_current[lindex].P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current[lindex].P[16 + 1];\n    ;\n    *(ptr - 4) = L0;\n    *(ptr - 3) = R0;\n    L0 ^= salt->salt[(16 + 4) & 3];\n    R0 ^= salt->salt[(16 + 5) & 3];\n    L0 ^= BF_current[lindex].P[0];\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[0 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[1 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[2 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[3 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[4 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[5 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[6 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[7 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[8 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[9 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[10 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[11 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[12 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[13 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u1 = L0 & 0xFF;\n    u1 <<= 2;\n    u2 = L0 >> 6;\n    u2 &= 0x3FC;\n    u3 = L0 >> 14;\n    u3 &= 0x3FC;\n    u4 = L0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    R0 ^= BF_current[lindex].P[14 + 1];\n    u3 += u1;\n    R0 ^= u3;\n    ;\n    u1 = R0 & 0xFF;\n    u1 <<= 2;\n    u2 = R0 >> 6;\n    u2 &= 0x3FC;\n    u3 = R0 >> 14;\n    u3 &= 0x3FC;\n    u4 = R0 >> 22;\n    u4 &= 0x3FC;\n    u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n    u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n    u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n    u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n    u3 ^= u2;\n    L0 ^= BF_current[lindex].P[15 + 1];\n    u3 += u1;\n    L0 ^= u3;\n    ;\n    u4 = R0;\n    R0 = L0;\n    L0 = u4 ^ BF_current[lindex].P[16 + 1];\n    ;\n    *(ptr - 2) = L0;\n    *(ptr - 1) = R0;\n  }\n  while (ptr < (&BF_current[lindex].S[3][0xFF]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/36"}
{"code": "for (i = 0; i < 10000; i = i + 1)\n{\n  Buyers[i].buyerOrSeller = 1;\n  Buyers[i].quantityHeld = 0;\n  Buyers[i].value = (rand() % 20) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp1/1"}
{"code": "for (i = 0; i < image->row; i++)\n{\n  for (j = 0; j < image->col; j++)\n  {\n    unsigned char ct = image->content[i][j];\n    omp_set_lock(&locks[ct]);\n    histo[ct]++;\n    omp_unset_lock(&locks[ct]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziwu14/OpenMP/histo/histo_locks/0"}
{"code": "for (k = 0; k <= (ISIZ3 + 1); k++)\n{\n  phi1[i][k] = 0.0;\n  phi2[i][k] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(k ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/50"}
{"code": "for (size_t i = 0; i < pr.size(); ++i)\n{\n  double cpr = pr[i];\n  sum_pr += cpr;\n  if (num_outgoing[i] == 0)\n  {\n    dangling_pr += cpr;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum_pr, dangling_pr) schedule(runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/pagerank/src/omp_pagerank_v1/3"}
{"code": "for (i = 0; i <= (public.allPoints - 1); i += 1)\n{\n  free(private[i].in_partial_sum);\n  free(private[i].in_sqr_partial_sum);\n  free(private[i].par_max_val);\n  free(private[i].par_max_coo);\n  free(private[i].d_in2);\n  free(private[i].d_in2_sqr);\n  free(private[i].d_in_mod);\n  free(private[i].d_in_sqr);\n  free(private[i].d_conv);\n  free(private[i].d_in2_pad);\n  free(private[i].d_in2_sub);\n  free(private[i].d_in2_sub2_sqr);\n  free(private[i].d_tMask);\n  free(private[i].d_mask_conv);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/13"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      frct[i][j][k][m] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/10"}
{"code": "for (i = 0; i < size; i++)\n{\n  array[i] = 0.;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/Ludwig/targetDP/targetDP_C/0"}
{"code": "for (i = start; i <= end; i++)\n{\n  temp += is_prime(i);\n}\n\n", "pragma": "omp for schedule(guided,100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bscheibe/OpenMP-lab/isprime/0"}
{"code": "for (int i = 0; i < sigar_cpu_list.number; i++)\n{\n  tmp_cpu = sigar_cpu_list.data[i];\n  cpu_list_prev_total += tmp_cpu.total;\n  cpu_list_prev_user += tmp_cpu.user;\n  cpu_list_prev_sys += tmp_cpu.sys;\n  cpu_list_prev_idle += tmp_cpu.idle;\n  cpu_list_prev_nice += tmp_cpu.nice;\n  cpu_list_prev_wait += tmp_cpu.wait;\n  cpu_list_prev_irq += tmp_cpu.irq;\n  cpu_list_prev_soft_irq += tmp_cpu.soft_irq;\n  cpu_list_prev_stolen += tmp_cpu.stolen;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/16"}
{"code": "for (unsigned i = 0; i < width; i++)\n{\n  for (unsigned j = 0; j < height; j++)\n  {\n    uint32_t sum = 0;\n    for (unsigned k = 0; k < width; k++)\n      sum = sum + (a[(i * width) + k] * b[(k * width) + j]);\n\n    c[(i * width) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) firstprivate(a, b, c, width, height)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/mm-small/mm-small/1"}
{"code": "for (unsigned int j = 0; j < sz; j++)\n{\n  encodedBlockBuffer.get()[idx].y.encoded[j].encoded = (*encodedBlock->y->encoded.get())[j].encoded;\n  encodedBlockBuffer.get()[idx].y.encoded[j].count = (*encodedBlock->y->encoded.get())[j].count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spenceryu/15618-final-project/src/rle/2"}
{"code": "for (i = lo; i < hi; i++)\n{\n  for (j = N - 1; j > i; j--)\n  {\n    a[i][j] += cos(b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cstyl/omp-scheduling/src/loops/workload/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n    M[i][j] = rand() % 50;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp/2"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  a[i] = (rand() % 10) + 1;\n  b[i] = (rand() % 10) + 1;\n  printf(\"iter = %d, thread id = %d out of %d b[%d] = %d a[%d] = %d \\n\", i, omp_get_thread_num(), omp_get_num_threads(), i, b[i], i, a[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static,3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task7/0"}
{"code": "for (j = 0; j < nrows; j++)\n{\n  int count = 0;\n  for (k = 0; k < n1; k++)\n  {\n    i = index1[k];\n    if (mask[j][i])\n    {\n      temp[count] = data[j][i];\n      count++;\n    }\n\n  }\n\n  if (count > 0)\n  {\n    cdata[j][0] = median(count, temp);\n    cmask[j][0] = 1;\n  }\n  else\n  {\n    cdata[j][0] = 0.;\n    cmask[j][0] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/128"}
{"code": "for (uint32_t i = 0; i < numKeys; i++)\n{\n  MurmurHash3_x64_128(d_keys + d_length[i], length[i], i, d_out + (i * 2));\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/6"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  int index = (i * COLS) + col;\n  sum += array[index];\n}\n\n", "pragma": "#pragma omp parallel for reduction (+:sum) num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michal-dom/knn_with_openMP/StandScaler/0"}
{"code": "for (int m = 0; m < 8; m++)\n{\n  unsigned long matrixSize = matrixSizes[m];\n  double *A = (double *) malloc((matrixSize * matrixSize) * (sizeof(double)));\n  double *B = (double *) malloc((matrixSize * matrixSize) * (sizeof(double)));\n  double *seqB_g = (double *) malloc((matrixSize * matrixSize) * (sizeof(double)));\n  double *parB_g = (double *) malloc((matrixSize * matrixSize) * (sizeof(double)));\n  int *globalVertices = (int *) malloc(matrixSize * (sizeof(int)));\n  double *D = (int *) malloc(matrixSize * (sizeof(int)));\n  genAdjacencyMatrix(A, matrixSize);\n  createDegreesVec(A, D, matrixSize, 1);\n  createModularityMatrix(B, A, D, matrixSize, 16);\n  createGlobalVertices(globalVertices, matrixSize, 1);\n  for (int a = 0; a < 20; a++)\n  {\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    doSequentialComputation(seqB_g, B, matrixSize, matrixSize, globalVertices);\n    clock_gettime(CLOCK_MONOTONIC, &finish);\n    elapsed = finish.tv_sec - start.tv_sec;\n    elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;\n    sequentialTimings[m] += elapsed;\n    for (int t = 1; t <= 8; t++)\n    {\n      clock_gettime(CLOCK_MONOTONIC, &start);\n      doParallelComputation(parB_g, B, matrixSize, matrixSize, globalVertices, t);\n      clock_gettime(CLOCK_MONOTONIC, &finish);\n      elapsed = finish.tv_sec - start.tv_sec;\n      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;\n      parallelTimings[m][t - 1] += elapsed;\n      for (int i = 0; i < matrixSize; i++)\n      {\n        for (int j = 0; j < matrixSize; j++)\n        {\n          assert(fabs(seqB_g[(i * matrixSize) + j] - parB_g[(i * matrixSize) + j]) < EQUALITY_THRESHOLD);\n        }\n\n      }\n\n    }\n\n  }\n\n  free(seqB_g);\n  free(parB_g);\n  free(B);\n  free(D);\n  free(A);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/subgraph_modularity_matrix/sgmm_benchmarking/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  TID = omp_get_thread_num();\n  printf(\"Thread %d updates a[%d]\\n\", TID, i);\n  a[i] += i;\n  {\n    printf(\"Thread %d prints value of a[%d] = %d\\n\", TID, i, a[i]);\n  }\n}\n\n", "pragma": "omp parallel for default(none) ordered schedule(runtime) private(i,TID) shared(n,a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.74-ordered/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  score2 = minmax_ab2(T[i], -1, niv - 1, score, beta, nb_noeuds, nb_coupes);\n  if (score2 > score)\n    score = score2;\n\n  if (score > beta)\n  {\n    *nb_coupes += 1;\n    return beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/parallel_vs_parallel_with_reordering/0"}
{"code": "for (i = start; i < end; i++)\n{\n  data_pts_cluster_global[i * 4] = data_pts_global[i * 3];\n  data_pts_cluster_global[(i * 4) + 1] = data_pts_global[(i * 3) + 1];\n  data_pts_cluster_global[(i * 4) + 2] = data_pts_global[(i * 3) + 2];\n  data_pts_cluster_global[(i * 4) + 3] = point_to_cluster_id[i - start];\n  assert((point_to_cluster_id[i - start] >= 0) && (point_to_cluster_id[i - start] < K_global));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/6"}
{"code": "for (int e = 0; e < model.num_edges; ++e)\n{\n  int source = model.edges[e];\n  int target = model.edges[model.num_edges + e];\n  if (source != target)\n  {\n    nodes[source]->neighbors.push_back(target);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_omp/0"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      s = s + (r[i3][i2][i1] * r[i3][i2][i1]);\n      a = fabs(r[i3][i2][i1]);\n      if (a > rnmu_local)\n      {\n        rnmu_local = a;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for reduction(+:s,rnmu_local) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/9"}
{"code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  for (jj = 0; jj < 3; jj++)\n  {\n    i1 = nnxhd * nyh;\n    i0 = i1 + ll;\n    i1 += l1;\n    t1 = cimagf(f[jj + i1]) + (crealf(f[jj + i1]) * _Complex_I);\n    f[jj + i1] = conjf(f[jj + i0] - t1);\n    f[jj + i0] += t1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/61"}
{"code": "for (i = k + 1; i <= n; i++)\n{\n  int processWorkingB = 0;\n  for (j = 1; j < size; j++)\n  {\n    if ((i > sendFrom[j]) && (i <= (sendFrom[j] + sizeToSend[j])))\n    {\n      processWorkingB = j;\n      break;\n    }\n\n  }\n\n  if (processWorkingA != processWorkingB)\n  {\n    if (processWorkingB == myId)\n    {\n      partialResultThread += b[i - 1] * A[((k - 1) * Alda) + (i - 1)];\n    }\n\n  }\n  else\n  {\n    if (processWorkingB == myId)\n    {\n      b[k - 1] -= b[i - 1] * A[((k - 1) * Alda) + (i - 1)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivC_OpenMP_MPI/2"}
{"code": "for (i = 0; i < num_points; i++)\n  data_points[i] = (double *) malloc(dimension * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/15"}
{"code": "for (x = 0; x < 64; x++)\n{\n  ;\n}\n\n", "pragma": "omp distribute parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/clauses-4/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  cin >> b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rohankurekar/HPC/OpenMP/matrix_vector multiplication/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < coulmns; j++)\n  {\n    a[i][j] = 5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yousaf2018/OpenMP-programming-/mulitplication_using_omp/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum += a[i];\n  printf(\"\\n Sum:%d i:%d id:%d\", sum, i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/sum_array_red/0"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  x_n[i] = x_n1[i];\n}\n\n", "pragma": "#pragma omp parallel for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/9"}
{"code": "for (int i = 0; i < n; i++)\n  sum += arr[i];\n\n", "pragma": "      #pragma omp parallel for schedule(static, granularity) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/reduce/0"}
{"code": "for (i = 0; i < size; i += TILE)\n{\n  for (k = 0; k < size; k += TILE)\n  {\n    for (j = 0; j < size; j += TILE)\n    {\n      for (x = i; x < (i + TILE); x++)\n      {\n        for (y = j; y < (j + TILE); y++)\n        {\n          for (z = k; z < (k + TILE); z++)\n          {\n            C[x][y] += A[x][z] * B[z][y];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i,j,k,x,y,z) shared(A,B,C)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/escobargabriel/MM_OMP/matriz-operacoes-omp/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double d2 = distance_sq(p, &arr[i]);\n  if (d2 > 0)\n  {\n    double total_force = (1.0 * 1.0) / d2;\n    double d = sqrt(d2);\n    f->x += total_force * ((arr[i].x - p->x) / d);\n    f->y += total_force * ((arr[i].y - p->y) / d);\n    f->z += total_force * ((arr[i].z - p->z) / d);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/7"}
{"code": "for (size_t i = start + 1; i < end; ++i)\n{\n  size_t j = i;\n  while ((j > start) && (p_ttcmp2(ind0, ind1, i, j - 1) < 0))\n  {\n    --j;\n  }\n\n  vbuf = vals[i];\n  memmove((vals + j) + 1, vals + j, (i - j) * (sizeof(val_t)));\n  vals[j] = vbuf;\n  ibuf = ind0[i];\n  memmove((ind0 + j) + 1, ind0 + j, (i - j) * (sizeof(idx_t)));\n  ind0[j] = ibuf;\n  ibuf = ind1[i];\n  memmove((ind1 + j) + 1, ind1 + j, (i - j) * (sizeof(idx_t)));\n  ind1[j] = ibuf;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/3"}
{"code": "for (row = norm + 1; row < N; row++)\n{\n  parloop(row);\n}\n\n", "pragma": "omp parallel for num_threads(pthread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArbaazShareef/PThreads-and-openMP-Programming/All_Versions/gauss_openMP_1/0"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    pre_old[i][j][k] = pre[i][j][k];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/pre_old_copy/0"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  u_new[0][i] = 1.0;\n  v_new[0][i] = 1.0;\n  u_new[x_points - 1][i] = 1.0;\n  v_new[x_points - 1][i] = 1.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Burgers Equation/2-D_Burgers_Equation/main/3"}
{"code": "for (u = ((2U * 0x7fffffff) + 1) - 6; u <= (((2U * 0x7fffffff) + 1) - 1); u += 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/22"}
{"code": "for (int i = 0; i < string_b.size(); i++)\n{\n  if (string_a[i] != string_b[i])\n  {\n    is_equivalent = false;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marsofandrew/openmp-mpi-labs/lab6.1/main/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_critical())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/critical/omp_critical/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    codes[(i * 3) + j] = compute_code(X[(i * 3) + j], low[j], step);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(codes,X,low,step,N) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/hash_codes/0"}
{"code": "for (int i = 0; i <= 100000; i++)\n{\n  dot_prod_omp += vector_A[i] * vector_B[i];\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task2/OpenMPtask2/2"}
{"code": "for (int k = 0; k < total_values; k++)\n  sum2 += pow(p2.values[k], 2.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/3"}
{"code": "for (int kk = (n + nbh) + (nbv / 2); kk < ((n + nbv) + nbh); kk++)\n{\n  if ((jj * dx) >= ((2 * bt) * dx))\n  {\n    ii++;\n    jj = 0;\n  }\n\n  x[kk] = (((space2 + dx) + (bt * dx)) + L) + (jj * dx);\n  y[kk] = (space2 + (bt * dx)) + (ii * dx);\n  jj++;\n  if ((jj % nbv_side) == 0)\n  {\n    ii++;\n    jj = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/12"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  km1 = k - 1;\n  kp1 = k + 1;\n  forcing[i][j][k][0] = (forcing[i][j][k][0] - (tz2 * (ue[kp1][3] - ue[km1][3]))) + (dz1tz1 * ((ue[kp1][0] - (2.0 * ue[k][0])) + ue[km1][0]));\n  forcing[i][j][k][1] = ((forcing[i][j][k][1] - (tz2 * ((ue[kp1][1] * buf[kp1][3]) - (ue[km1][1] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][1] - (2.0 * buf[k][1])) + buf[km1][1]))) + (dz2tz1 * ((ue[kp1][1] - (2.0 * ue[k][1])) + ue[km1][1]));\n  forcing[i][j][k][2] = ((forcing[i][j][k][2] - (tz2 * ((ue[kp1][2] * buf[kp1][3]) - (ue[km1][2] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][2] - (2.0 * buf[k][2])) + buf[km1][2]))) + (dz3tz1 * ((ue[kp1][2] - (2.0 * ue[k][2])) + ue[km1][2]));\n  forcing[i][j][k][3] = ((forcing[i][j][k][3] - (tz2 * (((ue[kp1][3] * buf[kp1][3]) + (c2 * (ue[kp1][4] - q[kp1]))) - ((ue[km1][3] * buf[km1][3]) + (c2 * (ue[km1][4] - q[km1])))))) + (zzcon1 * ((buf[kp1][3] - (2.0 * buf[k][3])) + buf[km1][3]))) + (dz4tz1 * ((ue[kp1][3] - (2.0 * ue[k][3])) + ue[km1][3]));\n  forcing[i][j][k][4] = ((((forcing[i][j][k][4] - (tz2 * ((buf[kp1][3] * ((c1 * ue[kp1][4]) - (c2 * q[kp1]))) - (buf[km1][3] * ((c1 * ue[km1][4]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[kp1][0] - (2.0 * buf[k][0])) + buf[km1][0]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[kp1][4] - (2.0 * buf[k][4])) + buf[km1][4]))) + (dz5tz1 * ((ue[kp1][4] - (2.0 * ue[k][4])) + ue[km1][4]));\n}\n\n", "pragma": "omp parallel for private (km1,kp1,k) firstprivate (tz2,zzcon1,zzcon2,zzcon3,zzcon4,zzcon5,dz1tz1,dz2tz1,dz3tz1,dz4tz1,dz5tz1,c1,c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/27"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  h[0][i] += a[i][j] * e[0][j];\n\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) private(i,j)shared(a,f,e)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gitsebste/openmpMatrixmult/openmpMatrixmult/openmpMatrixmult/openmpMatrixmult/5"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n{\n  printf(\"%g\", C[i * N]);\n  for (k = 1; k < N; k++)\n  {\n    printf(\" %g\", C[(i * N) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"thread %d: initial value = %d\\n\", omp_get_thread_num(), vtest);\n  vtest = i;\n}\n\n", "pragma": "omp parallel for private(i) firstprivate(vtest) lastprivate(vtest) shared(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaohao99/Introduction_to_OpenMP/source/firstlastprivate/solution/firstlastprivate/0"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  u_new[i][0] = ((((u[i][0] - ((u[i][0] * (del_t / del_x)) * (u[i][0] - u[i][x_points - 1]))) - ((v[i][0] * (del_t / del_y)) * (u[i][0] - u[i - 1][0]))) - ((del_t / ((2 * rho) * del_x)) * (p[i][1] - p[i][x_points - 1]))) + (nu * (((del_t / (del_x * del_x)) * ((u[i][1] + u[i][x_points - 1]) - (2 * u[i][0]))) + ((del_t / (del_y * del_y)) * ((u[i + 1][0] + u[i - 1][0]) - (2 * u[i][0])))))) + (F * del_t);\n  u_new[i][x_points - 1] = ((((u[i][x_points - 1] - ((u[i][x_points - 1] * (del_t / del_x)) * (u[i][x_points - 1] - u[i][x_points - 2]))) - ((v[i][x_points - 1] * (del_t / del_y)) * (u[i][x_points - 1] - u[i - 1][x_points - 1]))) - ((del_t / ((2 * rho) * del_x)) * (p[i][0] - p[i][x_points - 2]))) + (nu * (((del_t / (del_x * del_x)) * ((u[i][0] + u[i][x_points - 2]) - (2 * u[i][x_points - 1]))) + ((del_t / (del_y * del_y)) * ((u[i + 1][x_points - 1] + u[i - 1][x_points - 1]) - (2 * u[i][x_points - 1])))))) + (F * del_t);\n  v_new[i][0] = (((v[i][0] - ((u[i][0] * (del_t / del_x)) * (v[i][0] - v[i][x_points - 1]))) - ((v[i][0] * (del_t / del_y)) * (v[i][0] - v[i - 1][0]))) - ((del_t / ((2 * rho) * del_y)) * (p[i + 1][0] - p[i - 1][0]))) + (nu * (((del_t / (del_x * del_x)) * ((v[i][1] + v[i][x_points - 1]) - (2 * v[i][0]))) + ((del_t / (del_y * del_y)) * ((v[i + 1][0] + v[i - 1][0]) - (2 * v[i][0])))));\n  v_new[i][x_points - 1] = (((v[i][x_points - 1] - ((u[i][x_points - 1] * (del_t / del_x)) * (v[i][x_points - 1] - v[i][x_points - 2]))) - ((v[i][x_points - 1] * (del_t / del_y)) * (v[i][x_points - 1] - v[i - 1][x_points - 1]))) - ((del_t / ((2 * rho) * del_y)) * (p[i + 1][x_points - 1] - p[i - 1][x_points - 1]))) + (nu * (((del_t / (del_x * del_x)) * ((v[i][0] + v[i][x_points - 2]) - (2 * v[i][x_points - 1]))) + ((del_t / (del_y * del_y)) * ((v[i + 1][x_points - 1] + v[i - 1][x_points - 1]) - (2 * v[i][x_points - 1])))));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Channel Flow/2-D_Channel_Flow/main/1"}
{"code": "for (int i = 0; i < 40; i++)\n{\n  printf(\"OMP Thread# %d, loop variable %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tiandiao123/parallel-programming/omp/omp/loop/0"}
{"code": "for (i = 0; i < 1000000000; i++)\n{\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vishal-subbu/OpenMP/dot_prod/1"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n  work_buff[key_array[i] >> shift]++;\n\n", "pragma": "        #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n    printf(\"%d \", arr[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t2/2"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if ((((((mat2[rowcol] == (-28768)) || (mat8[rowcol] == 28768)) || (mat17[rowcol] == (-28768))) || isnan(mat17[rowcol])) || (mat16[rowcol] == (-28768))) || isnan(mat16[rowcol]))\n  {\n  }\n  else\n  {\n    tempk = mat8[rowcol] * 0.02;\n    Rn = mat16[rowcol];\n    g0 = mat17[rowcol];\n    albedo = mat2[rowcol] * 0.001;\n    dem = mat14[rowcol];\n    h0 = Rn - g0;\n    t0dem = tempk + (0.00627 * dem);\n    if (((((t0dem < t0dem_min) && (albedo < 0.15)) && (t0dem > 274.0)) && (Rn > 10.0)) && (g0 > 1.0))\n    {\n      t0dem_min = t0dem;\n      t0dem_wet = t0dem;\n      tempk_min = tempk;\n      tempk_wet = tempk;\n      Rn_wet = Rn;\n      g0_wet = g0;\n      rowcol_wet = rowcol;\n    }\n\n    if ((((t0dem > t0dem_max) && (h0 > h0_max)) && (t0dem > (t0dem_min + 1.0))) && (Rn > 0.0))\n    {\n      t0dem_max = t0dem;\n      t0dem_dry = t0dem;\n      tempk_max = tempk;\n      tempk_dry = tempk;\n      Rn_dry = Rn;\n      g0_dry = g0;\n      dem_dry = dem;\n      rowcol_dry = rowcol;\n    }\n\n    if (((((((tempk >= (((float) i_peak3) - 0.0)) && (tempk < (((float) i_peak3) + 7.0))) && (h0 > 10.0)) && (h0 > h0_max)) && (g0 > 1.0)) && (Rn > 0.0)) && (albedo > (0.5 * albedo_max)))\n    {\n      tempk_max = tempk;\n      tempk_dry = tempk;\n      t0dem_max = t0dem;\n      t0dem_dry = t0dem;\n      Rn_dry = Rn;\n      g0_dry = g0;\n      h0_max = h0;\n      dem_dry = dem;\n      rowcol_dry = rowcol;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, tempk, Rn, g0, albedo, dem, h0, t0dem) shared(N, t0dem_min, t0dem_max, tempk_min, tempk_max, tempk_wet, tempk_dry, t0dem_wet, t0dem_dry, g0_wet, g0_dry, Rn_wet, Rn_dry, dem_dry, rowcol_wet, rowcol_dry, h0_max, i_peak3, i_peak1, albedo_min, albedo_max, mat2, mat8, mat14, mat16, mat17)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta/1"}
{"code": "for (int i = 0; i < cluster_amount; i++)\n{\n  if (i == 0)\n  {\n    cluster_points_offset_arr[i] = 0;\n  }\n  else\n  {\n    for (int j = 0; j < i; j++)\n    {\n      cluster_points_offset_arr[i] += cluster_points_amount_arr[j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/19"}
{"code": "for (i = gap; i < size; i++)\n{\n  value = vet[i];\n  j = i - gap;\n  while ((j >= 0) && (value < vet[j]))\n  {\n    vet[j + gap] = vet[j];\n    j -= gap;\n  }\n\n  vet[j + gap] = value;\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcpablo/cefet-openmp/shellsort/parallel/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    C[(i * n) + j] = 0;\n\n  for (k = 0; k < n; k++)\n  {\n    for (j = 0; j < n; j++)\n    {\n      C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicklyz/Distributed-and-Parallel-Computing/lab2/mmul_main/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  compute_force_on_particle(&n->children[i], p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kawtar921/nbody/nbody_omp/nbody_barnes_hut/1"}
{"code": "for (k = 0; k < SIZE; k++)\n{\n  for (i = 0; i < SIZE; i++)\n  {\n    for (j = i + 1; j < SIZE; j++)\n    {\n      int l;\n      int cnt = 0;\n      int first = 0;\n      int second = 0;\n      int position[2];\n      for (l = 0; l < SIZE; l++)\n      {\n        if (forward_map[k][l][i] == 0)\n        {\n          first |= 1 << l;\n          if (cnt <= 1)\n            position[cnt] = l;\n          else\n          {\n            cnt = 0;\n            break;\n          }\n\n          cnt++;\n        }\n\n        if (forward_map[k][l][j] == 0)\n          second |= 1 << l;\n\n      }\n\n      if ((cnt == 2) && (second == first))\n      {\n        for (l = 0; l < SIZE; l++)\n        {\n          forward_map[k][position[0]][l] = 1;\n          forward_map[k][position[1]][l] = 1;\n        }\n\n        forward_map[k][position[0]][j] = 0;\n        forward_map[k][position[0]][i] = 0;\n        forward_map[k][position[1]][j] = 0;\n        forward_map[k][position[1]][i] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/15"}
{"code": "for (i = 0; i < ncolumns; i++)\n{\n  double closest;\n  int ix;\n  int iy;\n  for (j = 0; j < ndata; j++)\n    celldatavector[j] = &celldata[ixbest][iybest][j];\n\n  closest = metric(ndata, data, celldatavector, mask, dummymask, weights, i, 0, transpose);\n  for (ix = 0; ix < nxgrid; ix++)\n  {\n    for (iy = 0; iy < nygrid; iy++)\n    {\n      double distance;\n      for (j = 0; j < ndata; j++)\n        celldatavector[j] = &celldata[ix][iy][j];\n\n      distance = metric(ndata, data, celldatavector, mask, dummymask, weights, i, 0, transpose);\n      if (distance < closest)\n      {\n        ixbest = ix;\n        iybest = iy;\n        closest = distance;\n      }\n\n    }\n\n  }\n\n  clusterid[i][0] = ixbest;\n  clusterid[i][1] = iybest;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/105"}
{"code": "for (i = 1; i <= SIZE; i++)\n{\n  if ((i != twin1) && (i != twin2))\n  {\n    possiblevalues[row][col][i] = 0;\n    possiblevalues[row][uniquecol][i] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/1"}
{"code": "for (j = FIRST_PRIME * currentMultiple; j < max; j += currentMultiple)\n{\n  if (j > max)\n  {\n    return;\n  }\n\n  list[j] = NOT_PRIME;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esthefanielanza/primos-paralelo/primesParallel/1"}
{"code": "for (int proc = 0; proc < p; proc++)\n{\n  int start = (proc * pos) / p;\n  int end = ((proc + 1) * pos) / p;\n  kmp_search(v, b.substr(start, (end - start) + m), r + start, m, ((end - start) + m) - 1, f);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranshumaheshwari/Parallel-String-Matching/kmp_parallel/0"}
{"code": "for (int i = 0; i < NUMTHREADS; i++)\n{\n  for (int j = 0; j < K; j++)\n  {\n    mid_array[j * CPAD] += tmp_mid[j];\n  }\n\n}\n\n", "pragma": "    #pragma omp for reduction(+:mid_array[:K*CPAD]) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/2"}
{"code": "for (int n = 0; n < num_nodes; ++n)\n{\n  node = nodes[n];\n  for (int c_out = 0; c_out < node->num_classes; ++c_out)\n  {\n    for (int c_in = 0; c_in < node->dim_hidden; ++c_in)\n    {\n      node->tmp_logits[c_out] += node->hidden[c_in] * model.weight_2[(c_in * node->num_classes) + c_out];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyuejohn/Parallel-Programming-for-Graph-Convolutional-Neural-Networks/gcn_hybrid/1"}
{"code": "for (int i = 0; i < lookups; i++)\n{\n  double p_energy = rands[2 * i];\n  double roll = rands[(2 * i) + 1];\n  int mat;\n  for (mat = 0; mat < 12; mat++)\n  {\n    double running = 0;\n    for (int j = mat; j > 0; j--)\n      running += dist[j];\n\n    if (roll < running)\n      break;\n\n  }\n\n  mat = mat % 12;\n  double macro_xs_0 = 0;\n  double macro_xs_1 = 0;\n  double macro_xs_2 = 0;\n  double macro_xs_3 = 0;\n  double macro_xs_4 = 0;\n  long idx = 0;\n  long upperLimit = (n_isotopes * n_gridpoints) - 1;\n  long examinationPoint;\n  long length = upperLimit - idx;\n  while (length > 1)\n  {\n    examinationPoint = idx + (length / 2);\n    if (energy_grid[examinationPoint].energy > p_energy)\n      upperLimit = examinationPoint;\n    else\n      idx = examinationPoint;\n\n    length = upperLimit - idx;\n  }\n\n  for (int j = 0; j < num_nucs[mat]; j++)\n  {\n    int p_nuc = mats[mats_idx[mat] + j];\n    double conc = concs[mats_idx[mat] + j];\n    double f;\n    NuclideGridPoint *low;\n    NuclideGridPoint *high;\n    if (grid_ptrs[energy_grid[idx].xs_ptrs + p_nuc] == (n_gridpoints - 1))\n      low = &_nuclide_grids[((p_nuc * n_gridpoints) + grid_ptrs[energy_grid[idx].xs_ptrs + p_nuc]) - 1];\n    else\n      low = &_nuclide_grids[(p_nuc * n_gridpoints) + grid_ptrs[energy_grid[idx].xs_ptrs + p_nuc]];\n\n    high = low + 1;\n    f = (high->energy - p_energy) / (high->energy - low->energy);\n    macro_xs_0 += conc * (high->total_xs - (f * (high->total_xs - low->total_xs)));\n    macro_xs_1 += conc * (high->elastic_xs - (f * (high->elastic_xs - low->elastic_xs)));\n    macro_xs_2 += conc * (high->absorbtion_xs - (f * (high->absorbtion_xs - low->absorbtion_xs)));\n    macro_xs_3 += conc * (high->fission_xs - (f * (high->fission_xs - low->fission_xs)));\n    macro_xs_4 += conc * (high->nu_fission_xs - (f * (high->nu_fission_xs - low->nu_fission_xs)));\n  }\n\n  if (i == 0)\n  {\n    v_ints[i] = mat;\n    v_doubles[6 * i] = p_energy;\n    v_doubles[(6 * i) + 1] = macro_xs_0;\n    v_doubles[(6 * i) + 2] = macro_xs_1;\n    v_doubles[(6 * i) + 3] = macro_xs_2;\n    v_doubles[(6 * i) + 4] = macro_xs_3;\n    v_doubles[(6 * i) + 5] = macro_xs_4;\n  }\n\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/xsbench-mp4/src/Main/0"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j += 1)\n{\n  d = d + (p[j] * q[j]);\n}\n\n", "pragma": "omp parallel for private (j) reduction (+:d)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/9"}
{"code": "for (i = 0; i <= 2; i += 1)\n{\n  xstart[i] = 1;\n  xend[i] = 256;\n  ystart[i] = 1;\n  yend[i] = 256;\n  zstart[i] = 1;\n  zend[i] = 128;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/1"}
{"code": "for (k = 0; k < threads; k++)\n{\n  partialSumVector[k] = 0;\n  thread_counter[k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpaltsai/OpenMP/project_3_omp_fg_vectorized/6"}
{"code": "for (kk = 0; kk < bots_arg_size; kk++)\n{\n  lu0(BENCH[(kk * bots_arg_size) + kk]);\n  for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n  }\n\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n  {\n    bdiv(BENCH[(kk * bots_arg_size) + kk], BENCH[(ii * bots_arg_size) + kk]);\n  }\n\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n    for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    if (BENCH[(ii * bots_arg_size) + jj] == 0)\n      BENCH[(ii * bots_arg_size) + jj] = allocate_clean_block();\n\n    bmod(BENCH[(ii * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj], BENCH[(ii * bots_arg_size) + jj]);\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/sparselu/sparselu_for/sparselu/11"}
{"code": "for (int i = 0; i < numSweeps; i++)\n{\n  updateLattice(EVEN);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elena1905/ParallelIsingModel/src/worm/two_threads/Worm/3"}
{"code": "for (x = 0; x < Lc; x++)\n  for (y = 0; y < Lc; y++)\n  phi_c[x + (y * L)] = 0.0;\n\n\n", "pragma": "omp parallel for private(x, y) shared(p, L, Lc)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  int rank = omp_get_thread_num();\n  double x = ((double) (rand() % 10000)) / 10000;\n  double y = ((double) (rand() % 10000)) / 10000;\n  if (isInCircle(x, y))\n  {\n    in++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:in)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IAmArcanine/PA5/main/0"}
{"code": "for (i = 0; i < (Img->width * Img->height); i++)\n{\n  fprintf(fp, \"%d %d %d \", Img->R[i], Img->G[i], Img->B[i]);\n  if ((i % Img->height) == 0)\n    fprintf(fp, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eyadfhafi/HPC_OPENMP/conv-omp-dynamic/1"}
{"code": "for (i = 0; i < MAX_COLS; ++i)\n{\n  iArray[i] = output[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/13"}
{"code": "for (i = 0; i < N; i++)\n{\n  x[i] = 1;\n  y[i] = 0;\n  for (k = 0; k < N; k++)\n  {\n    A[i][k] = (i + k) - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/enhancing_efficiency/3"}
{"code": "for (m = 0; m < 5; m++)\n{\n  errnm[m] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/10"}
{"code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  t1 = cimagf(f[l1]) + (crealf(f[l1]) * _Complex_I);\n  f[l1] = conjf(f[ll] - t1);\n  f[ll] += t1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/60"}
{"code": "for (j = 1; j < (((L / NODESY) + 2) - 1); j++)\n{\n  i = 1;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    gnt[j] = whites[ii][j].data;\n  else\n    if (ii >= (((L / NODESX) + 2) / 2))\n    gnt[j] = blacks[ii - (((L / NODESX) + 2) / 2)][j].data;\n\n\n  i = ((L / NODESX) + 2) - 2;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    gst[j] = whites[ii][j].data;\n  else\n    if (ii >= (((L / NODESX) + 2) / 2))\n    gst[j] = blacks[ii - (((L / NODESX) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/142"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    dist = getDistance(block[i], block[j]);\n    tempPoint = (j + (world_rank * size)) + 1;\n    if (dist != 0)\n    {\n      for (m = 0; m < k; m++)\n      {\n        if (dist < kNNperBlock[i][m])\n        {\n          swap(&dist, &kNNperBlock[i][m]);\n          swap2(&pointPerkNN[i][m], &tempPoint);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/2"}
{"code": "for (int cdp_id = 0; cdp_id < ncdps; cdp_id++)\n{\n  int t_id0 = (cdp_id > 0) ? (ntraces_by_cdp_id[cdp_id - 1]) : (0);\n  int t_idf = ntraces_by_cdp_id[cdp_id];\n  h_compute_semblances(h_h, h_c, h_samples + (t_id0 * ns), h_num, h_stt, t_id0, t_idf, idt, dt, tau, w, nc, ns);\n  h_redux_semblances(h_num, h_stt, r_ctr, r_str, r_stk, nc, cdp_id, ns);\n  LOG(DEBUG, ((\"Progress: \" + to_string(cdp_id)) + \"/\") + to_string(ncdps));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cmp-omp/main/2"}
{"code": "for (int id_fake = 0; id_fake < ((mask_height * mask_width) * c); id_fake++)\n{\n  int channel = id_fake / (mask_height * mask_width);\n  int y = ((id_fake % (mask_height * mask_width)) / mask_width) + boundBoxMinY;\n  int x = ((id_fake % (mask_height * mask_width)) % mask_width) + boundBoxMinX;\n  int id = (x + (y * w)) + ((channel * w) * h);\n  int idx_nextX = ((x + 1) + (w * y)) + ((w * h) * channel);\n  int idx_prevX = ((x - 1) + (w * y)) + ((w * h) * channel);\n  int idx_nextY = (x + (w * (y + 1))) + ((w * h) * channel);\n  int idx_prevY = (x + (w * (y - 1))) + ((w * h) * channel);\n  if (boundary_array[id] == INSIDE_MASK)\n  {\n    double neighbor_target = ((targetimg[idx_nextY] + targetimg[idx_nextX]) + targetimg[idx_prevX]) + targetimg[idx_prevY];\n    double neighbor_output = ((outimg[idx_nextY] + outimg[idx_nextX]) + outimg[idx_prevX]) + outimg[idx_prevY];\n    outimg[id] = 0.25 * (((4 * targetimg[id]) - neighbor_target) + neighbor_output);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, CHUNKSIZE1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/14"}
{"code": "for (i = 0; i < num_edges; i++)\n{\n  src = edgeListmem->edges_array_src[i];\n  dest = edgeListmem->edges_array_dest[i];\n  if (symmetric)\n  {\n    edgeList->edges_array_src[i] = src;\n    edgeList->edges_array_dest[i] = dest;\n  }\n  else\n  {\n    edgeList->edges_array_src[i] = src;\n    edgeList->edges_array_dest[i] = dest;\n  }\n\n}\n\n", "pragma": "omp parallel for private(src,dest)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/6"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"Static %d: One more for iteration (Proc#%d)\\n\", i + 1, omp_get_thread_num());\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static, shcedule_num)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR6/LR6_1/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  if (adjacent_processes[i]->sent == 1)\n  {\n    continue;\n  }\n\n  MPI_Send(adjacent_processes[i]->cells_buffer_send, SIZEOF_CELL(adjacent_processes[i]->length_send_buffer), (MPI_Datatype) 0x4c00080b, adjacent_processes[i]->rank, TAG_SEND_CENTER_OF_MASS, cart_comm);\n  adjacent_processes[i]->sent = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/11"}
{"code": "for (unsigned int i = 0; i < corrs.size(); ++i)\n{\n  for (int j = 0; j < corrs[i]->get_Np(); ++j)\n  {\n    gsl_vector_set(p, p_idx, fc.p0[i][j]);\n    ++p_idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/7"}
{"code": "for (int i = 0; i < timePoints.size(); i++)\n  (ISFPrintObject << ((timePoints[i] * dt0) * print_frequency)) << ',';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/106"}
{"code": "for (int i = 0; i < (threadNum + 1); i++)\n{\n  offset += blocks[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akarsh3007/Parallel-Computing/Assignment-4/openmp/prefixsum/1"}
{"code": "for (i = 0; i < row; i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    *(resMV + i) += (*((matrix + (i * col)) + j)) * (*(vector + j));\n    printf(\"local = %d with row = %d in thread number %d \\n\", *(resMV + i), i, omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omama-mostafa/parallel-OpenMP-Matrix-Vector-Multiplication/Matrix_Vector/0"}
{"code": "for (j = 0; j < ny; j++)\n{\n  y = ((double) j) / ((double) (ny - 1));\n  for (i = 0; i < nx; i++)\n  {\n    x = ((double) i) / ((double) (nx - 1));\n    potential_exact_array[i][j] = potential_exact_function(x, y);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MRLintern/2D_Poisson_Equation_OpenMP/poisson/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = (b[i] = i * 1.1f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZishanAhmedOnik/OPENMP/divAndConq/1"}
{"code": "for (iterator it = EntitySettings.begin(); it != EntitySettings.end(); ++it)\n{\n  entities_table[it.name()] = &Get(EntitySettings[it.name()].GetString());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_processes/replace_multiple_elements_and_conditions_process/0"}
{"code": "for (int t = tempmin; t <= tempmax; t += tempsteps)\n{\n  startt;\n  latticeinirand(lattice);\n  acc = runmcmc(lattice, equibsweep, 0.01 * ((double) t), 0);\n  endt;\n  printf(\"Equilibration:: t=%f__acc=%f__Time=%I64d__Thread=%d\\n\", 0.01 * ((double) t), acc, showt, omp_get_thread_num());\n  latticeexport(lattice, 0.01 * ((double) t));\n  startt;\n  acc = runmcmc(lattice, measurelen * measurenum, 0.01 * ((double) t), 2);\n  endt;\n  printf(\"Measurement:: t=%f__acc=%f__Time=%I64d__Thread=%d\\n\", 0.01 * ((double) t), acc, showt, omp_get_thread_num());\n}\n\n", "pragma": "\t\t#pragma omp for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keygenx/N-Vector-Model/Vector Model/19"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  row_cnt[i] = m / nprocs;\n  row_disp[i] = (i * m) / nprocs;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgolubev/Conjugate_Gradient_with_MPI_and_OpenMP/src/conjugate_grad_dense/conj_grad_solve/3"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->fvsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->ivsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = strtof(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/30"}
{"code": "for (int i = 0; i < size; i++)\n  ds[i]->copyNewPosition();\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/zad6/DSEnsemble/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n  lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n  lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n  lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n  lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n  lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n  lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n  lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n  lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n  lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dttz2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/81"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->AssignToFlock(omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/9"}
{"code": "for (i = 0; i < hist_size; i++)\n  histogram[i] += histogram_private[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/histogram_2D/openmp_histogram/4"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n  count[(arr[i] / exp) % 10]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/6"}
{"code": "for (int k = nbthreads * granularity; k < n; k++)\n{\n  pr[k + 1] = pr[k + 1] + temp[nbthreads - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayuri34/parallel-computing/assignment-openmp-loop/prefixsum/prefixsum/4"}
{"code": "for (int i = regressionGraphCount - 1; 1 <= i; i--)\n{\n  ui->widget->removeGraph(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/54"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  vertex_array->edges_idx[i] = 0;\n  vertex_array->out_degree[i] = 0;\n  vertex_array->in_degree[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/vertex/0"}
{"code": "for (v7n = 0; v7n < 3; v7n++)\n{\n  int v7m = v7j + v7k;\n  v7i = 8;\n  v7l++;\n}\n\n", "pragma": "omp for private (v7i) firstprivate (v7k) reduction (+:v7l)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/debug-1/1"}
{"code": "for (i = 0; i <= (10000 + 1); i++)\n{\n  for (j = 0; j <= (10000 + 1); j++)\n  {\n    Temperature_last[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bakitybacon/parallelprogramming/Exercises/OpenMP/laplace_10k/2"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    density0[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = density0[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/2"}
{"code": "for (j = 0; j < 128; ++j)\n{\n  omp_set_lock(&locks[j]);\n  freq[j] += local_freq[j];\n  omp_unset_lock(&locks[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/char_freq/char_freq_parallel_array_of_locks_local/1"}
{"code": "for (row = kHalf; row < (paddedInputHeight - kHalf); row++)\n{\n  for (col = kHalf; col < (paddedInputWidth - kHalf); col++)\n  {\n    for (krow = 0; krow < kSize; krow++)\n    {\n      for (kcol = 0; kcol < kSize; kcol++)\n      {\n        for (ch = 0; ch < channels; ch++)\n        {\n          ucValue = paddedInput[(((((row - kHalf) + krow) * paddedInputWidth) * channels) + (((col - kHalf) + kcol) * channels)) + ch];\n          dValueKernel = kernel[(krow * kSize) + kcol];\n          dAgg[ch] += ucValue * dValueKernel;\n        }\n\n      }\n\n    }\n\n    for (ch = 0; ch < channels; ch++)\n    {\n      ucAgg = dAgg[ch];\n      if ((dAgg[ch] - ucAgg) >= 0.5)\n      {\n        ucAgg += 1;\n      }\n\n      output[((((row - kHalf) * width) * channels) + ((col - kHalf) * channels)) + ch] = ucAgg;\n      dAgg[ch] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(col, row, ch, krow, kcol, ucValue, dValueKernel, dAgg, ucAgg) collapse(2) schedule(dynamic, chunkSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sigurthorb/OpenMPvsGoroutines-Convolutions/ConvolutionLibrary/c/libConv/0"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  printf(\"%d \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw7/main/2"}
{"code": "for (i = 0; i < len; ++i)\n{\n  double volnew_o8 = 0.5 * c[i];\n  o1[i] = volnew_o8;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/functionparameter-orig-no/0"}
{"code": "for (i = 0; i < count; i++)\n  if (((uint32_t *) (&crypt_key[i]))[0] == ((uint32_t *) binary)[0])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/zip_fmt_plug/1"}
{"code": "for (int i = 0; i < maximum; ++i)\n{\n  if (Prime(i) == 1)\n    count++;\n\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiranor/IT_LR4/main/1"}
{"code": "for (int i = 0; i < columnsMaxValues.size(); i++)\n{\n  ((((cout << \"max of column <\") << i) << \">: \") << columnsMaxValues[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelaziz321/hybrid-mpi-openmp-example/main/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/185"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  finalRecvBuf[i] = pongRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(pongRecvBuf,finalRecvBuf,dataSize,sizeofBuffer) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_multiPingpong/0"}
{"code": "for (i = 1; i < (((2048 / 1) + 2) - 1); i++)\n{\n  j = ((2048 / 5) + 2) - 1;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = gre[i];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = gre[i];\n\n  j = 0;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = gro[i];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = gro[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/18"}
{"code": "for (int i = 0; i < maxRepeatOffset; i++)\n{\n  foregroundProbs[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/diamond-sycl/src/basic/masking/1"}
{"code": "for (i = 0; i <= 2; i += 1)\n{\n  dims[i][0] = 256;\n  dims[i][1] = 256;\n  dims[i][2] = 128;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/0"}
{"code": "for (size_t i = 0; i < size; i++)\n  result[i] = dis(gen);\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/first/Matrix/4"}
{"code": "for (size_t i = 0; i < W.size(); i++)\n{\n  g[i] += dW[i] * dW[i];\n  W[i] -= (alpha * dW[i]) / (sqrt(g[i]) + eps);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/optimizer/0"}
{"code": "for (I = 0; I < M; I++)\n{\n  for (J = 0; J < N; J++)\n  {\n    UNEW[I + 1][J] = (UOLD[I + 1][J] + ((TDTS8 * (Z[I + 1][J + 1] + Z[I + 1][J])) * (((CV[I + 1][J + 1] + CV[I][J + 1]) + CV[I][J]) + CV[I + 1][J]))) - (TDTSDX * (H[I + 1][J] - H[I][J]));\n    VNEW[I][J + 1] = (VOLD[I][J + 1] - ((TDTS8 * (Z[I + 1][J + 1] + Z[I][J + 1])) * (((CU[I + 1][J + 1] + CU[I][J + 1]) + CU[I][J]) + CU[I + 1][J]))) - (TDTSDY * (H[I][J + 1] - H[I][J]));\n    PNEW[I][J] = (POLD[I][J] - (TDTSDX * (CU[I + 1][J] - CU[I][J]))) - (TDTSDY * (CV[I][J + 1] - CV[I][J]));\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/3"}
{"code": "for (int i = 0; !in.atEnd(); i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    in >> str;\n    tirfilter[i][j] = str.toDouble();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/111"}
{"code": "for (uint i = 3; ((i * 1LL) * i) <= r; i += 2)\n{\n  if ((i >= (3 * 3)) && ((i % 3) == 0))\n    continue;\n\n  if ((i >= (5 * 5)) && ((i % 5) == 0))\n    continue;\n\n  if ((i >= (7 * 7)) && ((i % 7) == 0))\n    continue;\n\n  if ((i >= (11 * 11)) && ((i % 11) == 0))\n    continue;\n\n  if ((i >= (13 * 13)) && ((i % 13) == 0))\n    continue;\n\n  long long start = (((l + i) - 1) / i) * i;\n  if (start < ((i * 1LL) * i))\n    start = (i * 1LL) * i;\n\n  if ((start & 1) == 0)\n    start += i;\n\n  for (; start <= r; start += i << 1)\n    isPrime[(start - l) >> 1] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe_odd_only_blockwise/1"}
{"code": "for (j_imopVarPre81 = 1; j_imopVarPre81 <= ((lastcol - firstcol) + 1); j_imopVarPre81++)\n{\n  p[j_imopVarPre81] = r[j_imopVarPre81] + (beta * p[j_imopVarPre81]);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/9"}
{"code": "for (nnz = 0, j = 0, i = 0; i < graph->nrows; i++)\n{\n  if (part[i] == pid)\n  {\n    gk_icopy(graph->rowptr[i + 1] - graph->rowptr[i], graph->rowind + graph->rowptr[i], ngraph->rowind + nnz);\n    gk_fcopy(graph->rowptr[i + 1] - graph->rowptr[i], graph->rowval + graph->rowptr[i], ngraph->rowval + nnz);\n    nnz += graph->rowptr[i + 1] - graph->rowptr[i];\n    ngraph->rowptr[++j] = nnz;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/22"}
{"code": "for (int i = 0; i < 3; i++)\n  FillingMasParallelTime[i] /= 20;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/1"}
{"code": "for (unsigned i = 0; i < num_neurons; ++i)\n{\n  layer.at(i) = (layer.at(i) - mean) / stddev;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/26"}
{"code": "for (int i = 0; i < 10000000; i++)\n  res = res * pow(x, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vladislav-koval/openmp-lab/1-3/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += rank[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antoniadm/PageRank/pageRank_openMP/3"}
{"code": "for (i = 0; i < r; i++)\n  a1[i] = (int *) malloc(c * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog2_MatrixMul_opemmp/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    printf(\"[(%d,%d)= %d ] \", i, j, W[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmotel/zjp-labs/lab6/zad2/main/6"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  sendProduct(&allProducts[i], 1 + (i % (numprocs - 1)), MPI_Product);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/2"}
{"code": "for (unsigned i = 1; i < x.size(); ++i)\n{\n  x[i] = xydist(random_sequence);\n  y[i] = xydist(random_sequence);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 124; j++)\n  {\n    A[i][j] = 11 + j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prateek18597/OpenMP-Programs/3_MatrixMul/2"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"%.3f \", row[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/command/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  n++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruslancheb/juliakernel/juliakernel/sandbox/test_for/main/0"}
{"code": "for (int i = 0; i < alines; i++)\n{\n  for (int j = 0; j < blines; j++)\n  {\n    if (ax[i] == by[j])\n    {\n      myouty[mylines] = ay[i];\n      myoutx[mylines] = bx[j];\n      myoutval[mylines] = aval[i] * bval[j];\n      mylines++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarpenterD/distributed-matrix-multiplication/dmm/0"}
{"code": "for (int pos = lid; pos < N; pos += gsz)\n{\n  s_data[pos] = d_Src[pos];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fwt-omp/kernels/1"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  iOff = i * dimension;\n  for (j = 0; j < dimension; j++)\n  {\n    jOff = j * dimension;\n    tot = 0;\n    for (k = 0; k < dimension; k++)\n    {\n      tot += OneD_A[iOff + k] * OneD_B[jOff + k];\n    }\n\n    matrixC[i][j] = tot;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyamramawat/Large_Multiplication_Matrix_OPENMP/19210520_CA670_Assignment_2/Code/2"}
{"code": "for (int i = 0; i < rowcol; i++)\n{\n  for (int j = 0; j < rowcol; j++)\n  {\n    sqr = (*((arr + (rowcol * i)) + j)) * (*((arr + (rowcol * i)) + j));\n    sum += sqr;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KinseyMcG/Parallel-Matrix/matrix/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] = 0;\n  for (int u = ptr[i]; u < ptr[i + 1]; u++)\n  {\n    int j = colIndex[u];\n    double A_ij = values[u];\n    y[i] += A_ij * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for shared(y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/2"}
{"code": "for (T j = 0; j < M; j++)\n  for (i = 0; i < n; i += 2)\n{\n  a[i][j] = foo(i, j);\n  b[i][j] = bar(a[i][j], b[i - 1][j], b[i][j - 1]);\n  baz(a[i][j], b[i][j]);\n}\n\n\n", "pragma": "#pragma omp for ordered(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/ordered_doacross_codegen/1"}
{"code": "for (int coord_index = 1; coord_index <= 2; ++coord_index)\n{\n  n[coord_index] = wf.n[coord_index];\n  dx[coord_index] = wf.x[coord_index].delta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/0"}
{"code": "for (int i = 0; i < d; i++)\n{\n  T->vp[i] = Xarray[((n - 1) * d) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikalaki/Vantage_point_tree_C_and_parallelism/vptree/src/vptree_openmp/2"}
{"code": "for (i = 0; i < (N - 1); i++)\n  for (j = 0; j < ((N - 1) - i); j++)\n  if (p[j] > p[j + 1])\n{\n  temp = p[j];\n  p[j] = p[j + 1];\n  p[j + 1] = temp;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ssskz/Classical_Sort_Algorithm/BubbleAlgorithm/0"}
{"code": "for (int i = 0; i < n; i++)\n  if (a[i] != (2.0 * b[i]))\n{\n  err++;\n  printf(\"Error at %d, expected %lf, got %lf\\n\", i, 2.0 * b[i], a[i]);\n  if (err > 10)\n    return err;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/already_locked/already_locked/3"}
{"code": "for (i = 0; i < actualColumn; i++)\n{\n  threadID = omp_get_thread_num();\n  totalNumberThreads = omp_get_num_threads();\n  sum = 0;\n  for (j = 0; j < actualRow; j++)\n    sum += b[i][j] * c[j];\n\n  a[i] = sum;\n  printf(\"Thread %d of %d calculates i = %d\\n\", threadID, totalNumberThreads, i);\n}\n\n", "pragma": "omp parallel for default(none) private(threadID, i, j, sum) shared(actualColumn, actualRow, a, b, c, totalNumberThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javierip/parallel-processing-teaching-toolkit/03-multi-core-processors/01-openMP/03-parallel-for/main/0"}
{"code": "for (j = 1; j <= jmax; j++)\n{\n  for (i = 1; i <= imax; i++)\n  {\n    fprintf(f, \"%f \", matrix[(j * m) + i]);\n  }\n\n  fprintf(f, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlessandroPiccolo/poisson-openmp-solver/source/poisson_parallel/10"}
{"code": "for (k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    mass_flux_y[FTNREF2D(x_max + j, k, x_max + 4, x_min - 2, y_min - 2)] = mass_flux_y[FTNREF2D(x_max - j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/59"}
{"code": "for (uint i = 0; i < numBlocks; ++i)\n{\n  for (uint j = 0; j < numBuckets; ++j)\n  {\n    globalHisto[j] += blockHistograms[(i * numBuckets) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/1"}
{"code": "for (i = 0; i < myProductsSize; i++)\n{\n  sendProduct(&myProducts[i], 0, MPI_Product);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/10"}
{"code": "for (i = 0; i < LINHAS; i++)\n{\n  printf(\"Thread=%d fez a linha=%d\\n\", id, i);\n  for (j = 0; j < COLUNAS_B; j++)\n    for (k = 0; k < COLUNAS_A; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/6-Matriz/MultiMatriz/MultiMatriz/Origem/3"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  cluster[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Projects/PC-Project/parallel code/kmean_omp/3"}
{"code": "for (index = 0; index < count; ++index)\n  MixOrder[index] = index;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sha256crypt_fmt_plug/1"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpr4mnsmhi.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpr4mnsmhi.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/29"}
{"code": "for (iz = 0; iz < nzl; iz++)\n{\n  for (iy = 0; iy < nyl; iy++)\n  {\n    for (ix = 0; ix < nxl; ix++)\n    {\n      tvar[CELTNDX(ix, iy, iz)] = tN_new[CELTNDX3(ix, iy, iz)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ix, iy, iz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/init/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  b = 100;\n  d = 10;\n  printf(\"Thread %d (of %d total threads), iteration %d: b = %d, c = %d, d = %d, m = %d\\n\", omp_get_thread_num(), omp_get_num_threads(), i, b, c, d, m);\n  a[i] = omp_get_thread_num();\n  b = omp_get_thread_num();\n  c = omp_get_thread_num();\n  d = omp_get_thread_num();\n  m = omp_get_thread_num();\n}\n\n", "pragma": "#pragma omp parallel for default(none) private(i,b) firstprivate(c) lastprivate(d) shared(m,a) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/1"}
{"code": "for (i = 0; i < y; i++)\n{\n  for (j = 0; j < 1; j++)\n  {\n    matrizD[(i * 1) + j] = 0.0;\n    for (k = 0; k < v; k++)\n    {\n      matrizD[(i * 1) + j] = matrizD[(i * 1) + j] + (aux[(i * v) + k] * matrizC[(k * 1) + j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EliseuPHP/PAD/OpenMP/src/exerc/1"}
{"code": "for (j = 0; j < size; j++)\n{\n  for (i = 0; i < size; i++)\n  {\n    A[i + (size * j)] = sin(0.01 * (i + (size * j)));\n  }\n\n  b[j] = cos(0.01 * j);\n  x[j] = 0.0;\n}\n\n", "pragma": "omp for schedule(dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/matrix_vector/0"}
{"code": "for (int i = 0; i < nf; i++)\n{\n  if ((tset[i] = readImg(ifileL[i])) == 0)\n    error = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/10"}
{"code": "for (int i = 0; i < n; i++)\n  current = current | (colMask >> (n * i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krummelur/n-queens_openMP/n-queens/2"}
{"code": "for (i = 0; i < num_buckets; i++)\n{\n  if (offsets[i] != offsets[i + 1])\n  {\n    sort(&vector[offsets[i]], &vector[offsets[i + 1]]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sort/6"}
{"code": "for (i = 0; i < NSTEPS; i++)\n{\n  compute(NPARTS, 3, position, velocity, mass, force, &potential, &kinetic);\n  printf(\"%17.9e %17.9e %17.9e\\n\", potential, kinetic, ((potential + kinetic) - E0) / E0);\n  update(NPARTS, 3, position, velocity, force, accel, mass, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_MolecularDynamic/c_md/7"}
{"code": "for (int g = 0; g < egroups; g++)\n{\n  expVal[g] = 1.f - expf(-tau[g]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/4"}
{"code": "for (index = 0; index < count; index++)\n{\n  snefru_ctx ctx;\n  ;\n  rhash_snefru256_init(&ctx);\n  rhash_snefru_update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  rhash_snefru_final(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/snefru_fmt_plug/0"}
{"code": "for (int32_t x = 0; x < grid_width; x++)\n{\n  for (int32_t y = 0; y < grid_height; y++)\n  {\n    int32_t curr_ind = 1;\n    for (int32_t d = 0; d <= param.disp_max; d++)\n    {\n      if ((*(temp2 + getAddressOffsetGrid(x, y, d, grid_width, param.disp_max + 1))) > 0)\n      {\n        *(disparity_grid + getAddressOffsetGrid(x, y, curr_ind, grid_width, param.disp_max + 2)) = d;\n        curr_ind++;\n      }\n\n    }\n\n    *(disparity_grid + getAddressOffsetGrid(x, y, 0, grid_width, param.disp_max + 2)) = curr_ind - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/16"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float prod = 0.0;\n    for (int k = 0; k < M; k++)\n    {\n      prod += (*((D + (k * N)) + i)) * (*((D + (k * N)) + j));\n    }\n\n    *((DT_D + (i * N)) + j) = prod;\n  }\n\n}\n\n", "pragma": "omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"B[%d]= %d\\n\", i, B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgrigoras/parallel_algorithms/Lab 6/Lab6_p3_openmp/Hello_parallel/main/3"}
{"code": "for (i = 0; i < 256; i++)\n  histo_thread[i] = (long *) malloc((sizeof(long)) * num_thread);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_creative/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttx2 * speed[i - 1][j][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttx2 * speed[i + 1][j][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttx2 * speed[i - 1][j][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttx2 * speed[i + 1][j][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/25"}
{"code": "for (int i = 0; i < n; ++i)\n  fill(d[i], m);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/4"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  sum[id] += (h * 4.0) / (1 + (x * x));\n  x = x0 + (i * h);\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/pi/2"}
{"code": "for (int i = 0; i < ((int) sqrt(x)); i++)\n{\n  a[i] = 2.3 * x;\n  if (i < 10)\n    b[i] = a[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/week7/week7ex1/0"}
{"code": "for (int i = 1; i < 10; i++)\n{\n  char str[512];\n  char *result = str;\n  for (int j = 1; j < 10; j++)\n    result += sprintf(result, \"%dx%d=%d\\t\", i, j, i * j);\n\n  result = str;\n  printf(\"%s\\n\", result);\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task4/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  dtemp += A[i] * A[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Reduction/C/reduction/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = bt * r1;\n    t2 = 0.5 * (r4 + r5);\n    rhs[0][i][j][k] = bt * (r4 - r5);\n    rhs[1][i][j][k] = -r3;\n    rhs[2][i][j][k] = r2;\n    rhs[3][i][j][k] = (-t1) + t2;\n    rhs[4][i][j][k] = t1 + t2;\n  }\n\n}\n\n", "pragma": "omp parallel for private (r1,r2,r3,r4,r5,t1,t2,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/88"}
{"code": "for (a = 0; a < dimention; a++)\n{\n  for (b = 0; b < dimention; b++)\n  {\n    printf(\"%.2x ,\", Input1[a][b][0]);\n    printf(\"%.2x ,\", Input1[a][b][1]);\n    printf(\"%.2x \\t\", Input1[a][b][2]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ojani-Eguia/ImageGeneratorTest/OpenMP/ParShader/3"}
{"code": "for (i = 0; i <= (10000 / 2); i++)\n{\n  isgold[i] = (int *) malloc(((10000 / 2) + 1) * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhiy91/Goldbach_conjecture/goldbach_omp/2"}
{"code": "for (i = 0; i < size; i++)\n  U[i] = A[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/3"}
{"code": "for (i = 0; i < 16; ++i)\n{\n  ((char *) hex_salt)[i * 2] = itoa16[ARCH_INDEX(salt_hash[i] >> 4)];\n  ((char *) hex_salt)[(i * 2) + 1] = itoa16[ARCH_INDEX(salt_hash[i] & 0x0f)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/3"}
{"code": "for (i = 0; i < stepsize; i++)\n{\n  yValue = sqrt(1.0 - (xValue * xValue));\n  area = yValue * interval;\n  sum += area;\n  xValue += interval;\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Teddies1/Pirallelisation/HPCTask2/task2/0"}
{"code": "for (uint_fast32_t i = 0; i < iter; i++)\n{\n  to_solve->empty_sq[i] = (square *) malloc(iter * (sizeof(square)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/omp/sudoku-omp_BPsubqueues/0"}
{"code": "for (int i = 0; i < n; i++)\n  A[i] = (double *) malloc((sizeof(double)) * n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/9"}
{"code": "for (int i = 0; i < row1; i++)\n  for (int j = 0; j < col1; j++)\n  resultMat[i][j] = mat1[i][j] - mat2[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/22"}
{"code": "for (i = 0; i < ((ptrdiff_t) (width * height)); ++i)\n{\n  float_out[i] = (bool_in[(size_t) i] == true_is_zero) ? (0.f) : (INFINITY);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chaquator/chaq-sdfgen/openmp/sdfgen/1"}
{"code": "for (i = 0; i < 48; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/rawSHA384_fmt_plug/1"}
{"code": "for (long long k = 0; k < N; ++k)\n{\n  local_sum += ((k % 2) ? (-1.0) : (1.0)) / ((2 * k) + 1);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vyz333/parallel_c_tech_talk/pi_omp_n/0"}
{"code": "for (int i = 0; i < num; i++)\n{\n  COMM_WORLD.Recv(TmpBuff, fix_buf_size, BYTE, rank, tag_Matrix);\n  memcpy(dst + offset, TmpBuff, fix_buf_size);\n  offset += fix_buf_size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/26"}
{"code": "for (unsigned int u = 0; u < m_uNumberOfGridPoints1D; ++u)\n{\n  for (unsigned int v = 0; v < m_uNumberOfGridPoints1D; ++v)\n  {\n    m_gridHeat[u][v] = sin(((u * m_dGridPointSpacing) * 2) * M_PI) * sin(((v * m_dGridPointSpacing) * 2) * M_PI);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/4"}
{"code": "for (i = 0; i < Size; i++)\n{\n  pResult[i] = 0;\n  for (j = 0; j < Size; j++)\n    pResult[i] += pMatrix[i][j] * pVector[j];\n\n}\n\n", "pragma": "#pragma omp parallel for private (j) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PAAnisimofff/SLAU_OpenMP/SLAU_OpenMP/SLAU_OpenMP/6"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[2 * (i + (lxv * j))] = fxy[2 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (2 * (i + (lxv * j)))] = fxy[1 + (2 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      nn = x;\n      mm = y;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      n[j] = (nn - noff) + (lxv * (mm - moff));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      s[j] = amx * amy;\n      s[j + 32] = dxp * amy;\n      s[j + (2 * 32)] = amx * dyp;\n      s[j + (3 * 32)] = dxp * dyp;\n      t[j] = x;\n      t[j + 32] = y;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = (nn + lxv) - 2;\n      dx = 0.0f;\n      dy = 0.0f;\n      #pragma ivdep\n      for (i = 0; i < 4; i++)\n      {\n        if (i > 1)\n          nn = mm;\n\n        dx += sfxy[2 * (i + nn)] * s[j + (32 * i)];\n        dy += sfxy[1 + (2 * (i + nn))] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      dxp = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      dyp = ppart[((j + joff) + (3 * nppmx)) + npoff];\n      vx = dxp + (qtm * s[j]);\n      vy = dyp + (qtm * s[j + 32]);\n      dxp += vx;\n      dyp += vy;\n      sum1 += (dxp * dxp) + (dyp * dyp);\n      s[j] = x + (vx * dt);\n      s[j + 32] = y + (vy * dt);\n      s[j + (2 * 32)] = vx;\n      s[j + (3 * 32)] = vy;\n    }\n\n    #pragma novector\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      mm = 0;\n      if (dx >= edgerx)\n      {\n        if (dx >= anx)\n          dx -= anx;\n\n        mm = 2;\n      }\n      else\n        if (dx < edgelx)\n      {\n        if (dx < 0.0f)\n        {\n          dx += anx;\n          if (dx < anx)\n            mm = 1;\n          else\n            dx = 0.0;\n\n        }\n        else\n        {\n          mm = 1;\n        }\n\n      }\n\n\n      if (dy >= edgery)\n      {\n        if (dy >= any)\n          dy -= any;\n\n        mm += 6;\n      }\n      else\n        if (dy < edgely)\n      {\n        if (dy < 0.0)\n        {\n          dy += any;\n          if (dy < any)\n            mm += 3;\n          else\n            dy = 0.0;\n\n        }\n        else\n        {\n          mm += 3;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = s[j + (2 * 32)];\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = s[j + (3 * 32)];\n      if (mm > 0)\n      {\n        ncl[(mm + (8 * k)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * k))] = (j + joff) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nn = 2 * ((nn - noff) + (lxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dx = amy * ((dxp * sfxy[nn + 2]) + dx);\n    dy = amy * ((dxp * sfxy[nn + 3]) + dy);\n    nn += 2 * lxv;\n    vx = amx * sfxy[nn];\n    vy = amx * sfxy[nn + 1];\n    dx += dyp * ((dxp * sfxy[nn + 2]) + vx);\n    dy += dyp * ((dxp * sfxy[nn + 3]) + vy);\n    dxp = ppart[(j + (2 * nppmx)) + npoff];\n    dyp = ppart[(j + (3 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    dxp += vx;\n    dyp += vy;\n    sum1 += (dxp * dxp) + (dyp * dyp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,noff,moff,npp,npoff,ipp,joff,nps,nn,mm,ih,nh,x,y,dxp, dyp,amx,amy,dx,dy,vx,vy,edgelx,edgely,edgerx,edgery,sum1,sfxy,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (vet1[i] != vet2[i])\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danilo94/Genetic-Regulator-Network---With-OpenMP/main/1"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  if (num_attempts == 0)\n  {\n    a[x] = 0;\n  }\n\n  for (int y = 0; y < 16; ++y)\n  {\n    if ((rand() / ((double) 32767)) < false_margin)\n    {\n      a[x] += 1 << y;\n      have_true = 1;\n    }\n    else\n    {\n      have_false = 1;\n    }\n\n  }\n\n  num_threads[x] = -x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitand/0"}
{"code": "for (int j = k; j < (n - 1); j += 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    swap(arr[j], arr[j + 1]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none),shared(arr,k, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openMP_task/bubblesort/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int xx = 0;\n    int xy = 0;\n    int xz = 0;\n    int yx = 0;\n    int yy = 0;\n    int yz = 0;\n    for (int s = -1; s < 2; s++)\n    {\n      for (int t = -1; t < 2; t++)\n      {\n        if (((((i + s) < height) && ((j + t) < width)) && ((i + s) >= 0)) && ((j + t) >= 0))\n        {\n          xx += mx[s + 1][t + 1] * gaussres[3 * (((i + s) * width) + (j + t))];\n          xy += mx[s + 1][t + 1] * gaussres[(3 * (((i + s) * width) + (j + t))) + 1];\n          xz += mx[s + 1][t + 1] * gaussres[(3 * (((i + s) * width) + (j + t))) + 2];\n          yx += my[s + 1][t + 1] * gaussres[3 * (((i + s) * width) + (j + t))];\n          yy += my[s + 1][t + 1] * gaussres[(3 * (((i + s) * width) + (j + t))) + 1];\n          yz += my[s + 1][t + 1] * gaussres[(3 * (((i + s) * width) + (j + t))) + 2];\n        }\n\n      }\n\n    }\n\n    sobel[3 * ((i * width) + j)] = (abs(xx) + abs(yx)) / 8;\n    sobel[(3 * ((i * width) + j)) + 1] = (abs(xy) + abs(yy)) / 8;\n    sobel[(3 * ((i * width) + j)) + 2] = (abs(xz) + abs(yz)) / 8;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(8) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xVenve/POpenMP/image-par/1"}
{"code": "for (step = 1; step <= n_steps; step++)\n{\n  t = step * delta_t;\n  for (part = 0; part < n; part++)\n    Compute_force(part, forces, curr, n);\n\n  for (part = 0; part < n; part++)\n    Update_part(part, forces, curr, n, delta_t);\n\n  if ((step % output_freq) == 0)\n    Output_state(t, curr, n);\n\n}\n\n", "pragma": "omp parallel num_threads(thread_count) default(none) shared(curr, forces, thread_count, delta_t, n, n_steps, output_freq) private(step, part, t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/0"}
{"code": "for (i = 0; i < 2; i++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    temp = 0;\n    for (k = 0; k < 3; k++)\n    {\n      temp = temp + (H[i][k] * PHt[k][j]);\n    }\n\n    S[i][j] = temp + R[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/9"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n  {\n    fprintf(fp, \"1 \");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/144"}
{"code": "for (j = k + 1; j < num_elements; j++)\n{\n  U[(num_elements * k) + j] = (float) (U[(num_elements * k) + j] / U[(num_elements * k) + k]);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) private(j) shared(U, num_elements, k, thread_count)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mklobukov/Parallel-Programming/Parallelized Programs/Gaussian Elimination/Mark_Klobukov_Assignment1_ECEC622/gauss_eliminate/1"}
{"code": "for (k = 0; k < myid; k++)\n{\n  bucket_ptrs[0] += bucket_size[k][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/8"}
{"code": "for (int i = 0; i < n1; ++i)\n  for (int j = 0; j < n2; ++j)\n  info[(I[i] * n2) + j].top[0] = weight_table[(i * n2) + j];\n\n\n", "pragma": "#pragma omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziqi-zhang/Parallel-DAG-Traversal/openmp/4"}
{"code": "for (__pyx_temp = 0; __pyx_temp < __pyx_v_nslices; __pyx_temp++)\n{\n  __Pyx_INCREF(__pyx_slice__17);\n  __Pyx_GIVEREF(__pyx_slice__17);\n  PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__17);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/9"}
{"code": "for (long i = 0; i < n; i++)\n{\n  for (long j = 0; j < m; j++)\n    (cout << A[i][j]) << \" \";\n\n  cout << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task8/2"}
{"code": "for (int i = 0; i < num_nodes; i++)\n{\n  shipNodes[i] = i + active_row;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/2"}
{"code": "for (box = 0; box < level->num_my_boxes; box++)\n{\n  int blockcopy_i = BLOCKCOPY_TILE_I;\n  int blockcopy_j = BLOCKCOPY_TILE_J;\n  int blockcopy_k = BLOCKCOPY_TILE_K;\n  append_block_to_list(&level->my_blocks, &level->allocated_blocks, &level->num_my_blocks, level->my_boxes[box].dim, level->my_boxes[box].dim, level->my_boxes[box].dim, box, 0, 0, 0, 0, level->my_boxes[box].jStride, level->my_boxes[box].kStride, 1, box, 0, 0, 0, 0, level->my_boxes[box].jStride, level->my_boxes[box].kStride, 1, blockcopy_i, blockcopy_j, blockcopy_k, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/29"}
{"code": "for (j = 0; j < M; j++)\n  y[j] = 0 + (j * dy);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/1"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      for (ix = 0; ix < 2; ix++)\n      {\n        double *_imopVarPre199;\n        double _imopVarPre200;\n        _imopVarPre199 = &Pface[ix][0][0];\n        _imopVarPre200 = (double) ix;\n        exact_solution(_imopVarPre200, eta, zeta, _imopVarPre199);\n      }\n\n      for (iy = 0; iy < 2; iy++)\n      {\n        double *_imopVarPre203;\n        double _imopVarPre204;\n        _imopVarPre203 = &Pface[iy][1][0];\n        _imopVarPre204 = (double) iy;\n        exact_solution(xi, _imopVarPre204, zeta, _imopVarPre203);\n      }\n\n      for (iz = 0; iz < 2; iz++)\n      {\n        double *_imopVarPre207;\n        double _imopVarPre208;\n        _imopVarPre207 = &Pface[iz][2][0];\n        _imopVarPre208 = (double) iz;\n        exact_solution(xi, eta, _imopVarPre208, _imopVarPre207);\n      }\n\n      for (m = 0; m < 5; m++)\n      {\n        Pxi = (xi * Pface[1][0][m]) + ((1.0 - xi) * Pface[0][0][m]);\n        Peta = (eta * Pface[1][1][m]) + ((1.0 - eta) * Pface[0][1][m]);\n        Pzeta = (zeta * Pface[1][2][m]) + ((1.0 - zeta) * Pface[0][2][m]);\n        u[m][i][j][k] = (((((Pxi + Peta) + Pzeta) - (Pxi * Peta)) - (Pxi * Pzeta)) - (Peta * Pzeta)) + ((Pxi * Peta) * Pzeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/SP/sp-wrongSVE/6"}
{"code": "for (int i = 0; i < 32; ++i)\n{\n  sprintf(result + (2 * i), \"%02x\", output[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/secp256k1-omp/main/14"}
{"code": "for (i = 0; i < nvars; i++)\n{\n  printf(\"x[%3d] = %15.7le \\n\", i, best_pt[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/its-lito/Parallel-Programming/Code/OpenMP-Tasks/3"}
{"code": "for (uint64_t i = n - k; i < n; i++)\n{\n  m += (uint64_t) buffer[i];\n  for (uint64_t j = 0; j < (n - i); j++)\n  {\n    rk[j] += ((uint64_t) buffer[i]) * ((uint64_t) buffer[i + j]);\n  }\n\n}\n\n", "pragma": "omp for reduction(+:m), reduction(+:rk[:k])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/1"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  if (i == j)\n  dist[i][j] = 0;\nelse\n  dist[i][j] = rand() % 100;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gnalexandridis/Floyd-Warshall_HUA-PCA-2017-2018/openMP/2"}
{"code": "for (int i = k + 1; i < Size; i++)\n{\n  multiplier = pMatrix[(i * Size) + k] / pMatrix[(k * Size) + k];\n  for (int j = k + 1; j <= Size; j++)\n    pMatrix[(i * Size) + j] -= pMatrix[(k * Size) + j] * multiplier;\n\n  pMatrix[(i * Size) + k] = 0;\n  pVector[i] -= pVector[k] * multiplier;\n}\n\n", "pragma": "omp parallel for shared(pMatrix, pVector) private(multiplier) num_threads(NUM_THREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmarotti/less-openmp/src/gaussian_elimination/1"}
{"code": "for (i = 0; i < (ThreadID + 1); i++)\n{\n  offset += sChunks[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/inirion/MpiIndexowanie/Source/7"}
{"code": "for (i = 0; i < tam; i++)\n{\n  for (j = 0; j < tam; j++)\n  {\n    scanf(\"%d\", &num[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adrikei/FinalParalela/src/openmp/2"}
{"code": "for (i = 0; i < bitmap->size; i++)\n{\n  if (getBit(bitmap, i))\n  {\n    printf(\"**%u \\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shreyas097/Parallel-BFS-with-Push-Pull-operation-using-queue-bitmap-using-OpenMP/code/src/bitmap/2"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets1493Ptr = _checkInCodelets1493(1, 1, this, codeletCounter);\n  checkInCodelets1493Ptr++;\n  *checkInCodelets1490Ptr = _checkInCodelets1490(1, 1, this, codeletCounter);\n  checkInCodelets1490Ptr++;\n  *checkInCodelets1453Ptr = _checkInCodelets1453(1, 1, this, codeletCounter);\n  (*checkInCodelets1453Ptr).decDep();\n  checkInCodelets1453Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/82"}
{"code": "for (size_t ci = 0U; ci < csz; ci++)\n{\n  if (colors[ci] > ncolors)\n    ncolors = colors[ci];\n\n}\n\n", "pragma": "        #pragma omp parallel for default(none), shared(colors), reduction(max: ncolors), firstprivate(csz), schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/bColoring/initialColoringLU/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  t = omp_get_wtime();\n  printf(\"=================================================================\\n\");\n  switch (i)\n  {\n    case 0:\n      copiarVector(vord0, vini, 200000);\n      printf(\"Ordenando por el m\u00e9todo paralelo A\\n\");\n      ord_parA(vord0, 200000);\n      printf(\"\\nTiempo empleado por m\u00e9todo paralelo A: %0.8f milisegundos\\n\", 1000 * (omp_get_wtime() - t));\n      if (estaOrdenado(vord0, 200000))\n      printf(\"\\nEl vector obtenido por el m\u00e9todo paralelo A est\u00e1 ordenado\\n\");\n    else\n      printf(\"\\nEl vector obtenido por el m\u00e9todo paralelo A no est\u00e1 ordenado\\n\");\n\n      break;\n\n    case 1:\n      copiarVector(vord, vini, 200000);\n      printf(\"Ordenando por el m\u00e9todo secuencial B\\n\");\n      ord_secB(vord, 200000);\n      printf(\"\\nTiempo empleado por m\u00e9todo secuencial B: %0.8f milisegundos\\n\", 1000 * (omp_get_wtime() - t));\n      if (vectoresIguales(vord0, vord, 200000))\n      printf(\"\\nEl vector obtenido por el m\u00e9todo secuencial B coincide con el del m\u00e9todo secuencial A\\n\");\n    else\n      printf(\"\\nEl vector obtenido por el m\u00e9todo secuencial B no coincide con el del m\u00e9todo secuencial A\\n\");\n\n      break;\n\n    case 2:\n      copiarVector(vord, vini, 200000);\n      printf(\"Ordenando por el m\u00e9todo secuencial C\\n\");\n      ord_secC(vord, 200000);\n      printf(\"\\nTiempo empleado por m\u00e9todo secuencial C: %0.8f milisegundos\\n\", 1000 * (omp_get_wtime() - t));\n      if (vectoresIguales(vord0, vord, 200000))\n      printf(\"\\nEl vector obtenido por el m\u00e9todo secuencial C coincide con el del m\u00e9todo secuencial A\\n\");\n    else\n      printf(\"\\nEl vector obtenido por el m\u00e9todo secuencial C no coincide con el del m\u00e9todo secuencial A\\n\");\n\n      break;\n\n    case 3:\n      copiarVector(vord, vini, 200000);\n      printf(\"Ordenando por el m\u00e9todo paralelo D\\n\");\n      ord_parD(vord, 200000);\n      printf(\"\\nTiempo empleado por m\u00e9todo paralelo D: %0.8f milisegundos\\n\", 1000 * (omp_get_wtime() - t));\n      if (vectoresIguales(vord0, vord, 200000))\n      printf(\"\\nEl vector obtenido por el m\u00e9todo paralelo D coincide con el del m\u00e9todo paralelo A\\n\");\n    else\n      printf(\"\\nEl vector obtenido por el m\u00e9todo paralelo D no coincide con el del m\u00e9todo paralelo A\\n\");\n\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Josue-Zenteno/OpenMP-Project/src/OrdenaVectorOMP/9"}
{"code": "for (i = 1; i <= nt; i += 1)\n{\n  err = (sums[i].real - vdata_real_w[i]) / vdata_real_w[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_w[i]) / vdata_imag_w[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/30"}
{"code": "for (i = 0; i < Radius; ++i)\n{\n  k = PriorSum(Maze->Sections, i);\n  for (j = 0; j < Maze->Sections[i]; ++j)\n  {\n    Maze->Edges[k + j].Weight = ((k - j) % 5) + 1;\n    Maze->Edges[k + j].Loc = k + j;\n    Maze->Edges[k + j].A = &Maze->Nodes[i][j];\n    Maze->Edges[k + j].B = &Maze->Nodes[i][(j + 1) % Maze->Sections[i]];\n    Maze->Nodes[i][j].Friends[0] = Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Self;\n    Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Friends[1] = Maze->Nodes[i][j].Self;\n    Maze->Nodes[i][j].EdgeTo[0] = k + j;\n    Maze->Nodes[i][(j + 1) % Maze->Sections[i]].EdgeTo[1] = k + j;\n  }\n\n  if (Maze->Sections[i] < Maze->Sections[i + 1])\n    n = 2;\n  else\n    n = 1;\n\n  k += Maze->Sections[i];\n  for (j = 0; j < Maze->Sections[i]; ++j)\n  {\n    Maze->Edges[k + j].Weight = ((k + j) % 40) + 1;\n    Maze->Edges[k + j].Loc = k + j;\n    Maze->Edges[k + j].A = &Maze->Nodes[i][j];\n    Maze->Edges[k + j].B = &Maze->Nodes[i + 1][j * n];\n    Maze->Nodes[i][j].Friends[2] = Maze->Nodes[i + 1][j * n].Self;\n    Maze->Nodes[i + 1][j * n].Friends[3] = Maze->Nodes[i][j].Self;\n    Maze->Nodes[i][j].EdgeTo[2] = k + j;\n    Maze->Nodes[i + 1][j * n].EdgeTo[3] = k + j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/16"}
{"code": "for (int i = 0; i < r; i++)\n  mat[i] = (int *) malloc(c * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m3zai6i/Matrix-Vector-Algo-OpenMP-Threading/mat_vec_omp/1"}
{"code": "for (int d = 0; d < numDevice; d++)\n{\n  cudaSetDevice(d);\n  cudaDeviceSynchronize();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_mulgpu/1"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n  if (isBoundary(i))\n  nb_bounds++;\n\n\n", "pragma": "#pragma omp parallel for reduction(+:nb_bounds)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/io/1"}
{"code": "for (i = 0; i < ((int) parts); i++)\n{\n  long double local_denominator = (parts * parts) + (i * i);\n  ;\n  fraction_results[i].denominator = local_denominator;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akshatd/cs3211-openmp-mpi/integralMP/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < m; i++)\n  {\n    u_old[i + (m * j)] = u[i + (m * j)];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_host/helmholtz/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (p[j] != i)\n    {\n      inv_a[j][i] = 0;\n    }\n    else\n    {\n      inv_a[j][i] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_decomposition/Q1/2"}
{"code": "for (int i = 0; i < row2; i++)\n{\n  for (int j = 0; j < col2; j++)\n  {\n    printf(\"%d\\t\", b[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zeeshanmahar007/Matrix-Matrix-Multiplication-in-Parallel/omp_parallel/8"}
{"code": "for (int j = 0; j < SIZE; j++)\n{\n  if ((data[j] != (-1)) && (data[j] < data[prev[j]]))\n  {\n    flg0 = false;\n    data_old[j] = data[prev[j]];\n    prev_old[j] = prev[prev[j]];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(and:flg0)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/2"}
{"code": "for (i = 0; i < 99999999; ++i)\n{\n  a[i] = i >> 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonywyb/Lab-on-Parallel-and-Distributed-Computing/HW1/findSingleNumber/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  temp = 0.0;\n  for (i = 0; i < n; i++)\n  {\n    v1 = *(mat[perm[i]] + j);\n    for (k = 0; k < n; k++)\n    {\n      v1 -= (*(lower[i] + k)) * (*(upper[k] + j));\n    }\n\n    temp += v1 * v1;\n  }\n\n  ans += sqrt(temp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pradyumnameena/COL380-Parallel-Programming/A1/openmp/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  A[i] = (double *) malloc((sizeof(double)) * (n + 1));\n  for (j = n - 1; j >= 0; --j)\n  {\n    scanf(\"%lf\", &A[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vhcandido/hpc-erad-2015/src/main/2"}
{"code": "for (mat_row = 0; mat_row < n; mat_row++)\n{\n  grid_row = mat_row / local_A->n_bar;\n  coords[0] = grid_row;\n  for (grid_col = 0; grid_col < grid->q; grid_col++)\n  {\n    coords[1] = grid_col;\n    MPI_Cart_rank(grid->comm, coords, &dest);\n    if (dest == 0)\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        scanf(\"%lf\", (local_A->entries + (mat_row * local_A->n_bar)) + mat_col);\n\n    }\n    else\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        scanf(\"%lf\", temp + mat_col);\n\n      MPI_Send(temp, local_A->n_bar, (MPI_Datatype) 0x4c00080b, dest, 0, grid->comm);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Source Codes/C language/fox_floats_timer_caching_omp/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  x = (i - 0.5) * step;\n  sum[id] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ququwork/MPI-pi/3for/0"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    h[i][j] = p[i][j] + (.25 * ((((u[i + 1][j] * u[i + 1][j]) + (u[i][j] * u[i][j])) + (v[i][j + 1] * v[i][j + 1])) + (v[i][j] * v[i][j])));\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/5"}
{"code": "for (i = 0; i < (1000 * 1000); i++)\n{\n  mresult[0][i] = 0.0;\n  matrixa[0][i] = (matrixb[0][i] = rand() * ((float) 1.1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Willster419/parallel_computing_uac/PAC2/counters2omp/1"}
{"code": "for (int i = 0; i < difference.size(); ++i)\n{\n  if (!res)\n    continue;\n\n  if (!contains(set_3, difference[i]))\n  {\n    res = false;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kiiitG/homework4_openmp/main/6"}
{"code": "for (i = 1; i < N; i++)\n{\n  x = (i - 0.5) * step;\n  sum += 4.0 / (1 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ququwork/MPI-pi/4reduction/0"}
{"code": "for (int i = 0; i < (numOfProcs - 1); ++i)\n{\n  int proc = 0;\n  unsigned long tmp_size = 0;\n  rComm.receiveDataFromAnySource(tmp_size, &proc, tag);\n  if (tmp_size > 0)\n  {\n    MatrixElement > tmp_elements(tmp_size);\n    rComm.receiveDataX(&tmp_elements[0], tmp_size, proc, tag + 1);\n    const_iterator itEnd = tmp_elements.end();\n    for (const_iterator it = tmp_elements.begin(); it != itEnd; ++it)\n    {\n      colVectorMatrix.set(it->row, it->col, it->value);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD_Parallel/8"}
{"code": "for (i = 0; i < fftblock; i++)\n{\n  y0[j][i].real = x[k][j][i + ii].real;\n  y0[j][i].imag = x[k][j][i + ii].imag;\n}\n\n", "pragma": "omp parallel for firstprivate(i ,ii ,x ,fftblock ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/9"}
{"code": "for (unsigned int i = 0; i < ((L / NODESX) + 2); i++)\n  gro[i] = get[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/118"}
{"code": "for (i = 0; i < vectorsize; ++i)\n{\n  res[i] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlaaMensh/openMPI-with-files/OMP/Matrix-vector multiplication&20160060/2"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  a[i][j] = 999;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/privatej/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (f(ArrNumbers[i]) > 0)\n  {\n    counter++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(ArrNumbers) reduction(+: counter)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranzxc/Exam3_Parallal_OpenMP_MPI_CUDA/Exam3_Parallel_CUDA_MPI_OPENMP/MainProgram/1"}
{"code": "for (int i = 0; i < g->num_verts; ++i)\n  seen[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/14"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\"Executing thread %d\\n\", omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp3/ordered/0"}
{"code": "for (int i = x; i < (x + width); i++)\n{\n  for (int j = y; j < (y + height); j++)\n    matrix[i][j] = -1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luan-vilela/Parallel-Computing-Trabalho-1/matrixPar/1"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    density0[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = density0[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/2"}
{"code": "for (unsigned int i = 0; i < (DIM * DIM); ++i)\n{\n  inSrc[i] = distribution(generator);\n  outSrc[i] = inSrc[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olk/kruemelmonster/kruemelmonster_openmp/kruemelmonster_openmp/1"}
{"code": "for (i = 0; i < global_chunknr; i++)\n{\n  if (expected_chunk_size > 1)\n    expected_chunk_size = (c * openwork) / threads;\n\n  fprintf(stderr, \"%8d\\t%8d\\t%lf\\n\", chunksizes[i], expected_chunk_size, (c * chunksizes[i]) / expected_chunk_size);\n  if (abs(chunksizes[i] - expected_chunk_size) >= 2)\n  {\n    result = 0;\n  }\n\n  if ((expected_chunk_size - chunksizes[i]) < 0)\n    fprintf(stderr, \"Chunksize did not decrease: %d instead of %d\\n\", chunksizes[i], expected_chunk_size);\n\n  openwork -= chunksizes[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_guided/7"}
{"code": "for (i = 0; i < ROWS; i++)\n  for (j = 0; j < COLS; j++)\n  if (cost_dist[i][j] > 0)\n  suma[i][j] += req / pow(cost_dist[i][j], exp);\n\n\n\n", "pragma": "#pragma omp parallel for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/IDW/1"}
{"code": "for (int idx = 0; idx < valid_num; idx++)\n{\n  fs << idx;\n  for (int ilyr = 0; ilyr < nlyrs; ilyr++)\n  {\n    ((fs << \", \") << setprecision(8)) << m_2DData[idx][ilyr];\n  }\n\n  fs << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/2"}
{"code": "for (j = 0; j < m; j++)\n{\n  for (k = 0; k < m; k++)\n  {\n    q[k + (j * m)] = ((-2.0) * u[k]) * u[j];\n  }\n\n  q[j + (j * m)] += 1.0;\n}\n\n", "pragma": "    #pragma omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/12"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    if (scanf(\"%lf\", &aMatr[wI][wJ]) != 1)\n    {\n      fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d%d\\n\", wI, wJ);\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/11"}
{"code": "for (Max *ptr_max = max; ptr_max; ptr_max = ptr_max->prev)\n{\n  if (state_vertices_equals(state, &ptr_max->state))\n  {\n    return max;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/8"}
{"code": "for (int index = 0; index < readsCount; index++)\n{\n  int start = offsets[index];\n  int end = start + lengths[index];\n  int magic0 = 0;\n  int magic1 = 0;\n  int magic2 = 0;\n  int magic3 = 0;\n  char bases[4];\n  for (int i = 0; i < 4; i++)\n  {\n    bases[i] = 4;\n  }\n\n  int wordCount = 0;\n  for (int i = start; i < end; i++)\n  {\n    for (int j = 0; j < 3; j++)\n    {\n      bases[j] = bases[j + 1];\n    }\n\n    bases[3] = reads[i];\n    switch (bases[3])\n    {\n      case 0:\n        magic0++;\n        break;\n\n      case 1:\n        magic1++;\n        break;\n\n      case 2:\n        magic2++;\n        break;\n\n      case 3:\n        magic3++;\n        break;\n\n    }\n\n    unsigned short indexValue = 0;\n    int flag = 0;\n    for (int j = 0; j < 4; j++)\n    {\n      indexValue += (bases[j] & 3) << ((3 - j) * 2);\n      flag += max((int) (bases[j] - 3), 0);\n    }\n\n    indexs[i] = (flag) ? (65535) : (indexValue);\n    wordCount += (flag) ? (0) : (1);\n  }\n\n  words[index] = wordCount;\n  magicBase[(index * 4) + 0] = magic0;\n  magicBase[(index * 4) + 1] = magic1;\n  magicBase[(index * 4) + 2] = magic2;\n  magicBase[(index * 4) + 3] = magic3;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_threads(128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/deredundancy-omp/kernels/2"}
{"code": "for (m = 0; m < 5; m++)\n{\n  frct[i][j][k][m] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(nx ,m ,k ,j ,nz ,ny ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/11"}
{"code": "for (j = 0; j < n; j++)\n{\n  float diff_v[3] = {(float) x[(j * n) + i], (float) y[(j * n) + i], (float) z[(j * n) + i]};\n  int sse_current = _mm_load_ps(diff_v);\n  int sse_ball = _mm_load_ps(ball_v);\n  int sse_point_ball_diff = _mm_sub_ps(sse_current, sse_ball);\n  int sse_diff_mag = _mm_mul_ps(sse_point_ball_diff, sse_point_ball_diff);\n  float sum_v[3] = {0.0, 0.0, 0.0};\n  _mm_store_ps(sum_v, sse_diff_mag);\n  vmag = sqrt((sum_v[0] + sum_v[1]) + sum_v[2]);\n  if (vmag < rball)\n  {\n    float tmp[3] = {(float) (rball / vmag), (float) (rball / vmag), (float) (rball / vmag)};\n    int tmp_sse = _mm_load_ps(tmp);\n    tmp_sse = _mm_mul_ps(tmp_sse, sse_point_ball_diff);\n    sse_current = _mm_add_ps(sse_ball, tmp_sse);\n    _mm_store_ps(sum_v, sse_current);\n    x[(j * n) + i] = sum_v[0];\n    y[(j * n) + i] = sum_v[1];\n    z[(j * n) + i] = sum_v[2];\n    float one_v[3] = {1.0, 1.0, 1.0};\n    int sse_ones = _mm_load_ps(one_v);\n    sse_point_ball_diff = _mm_mul_ps(sse_point_ball_diff, sse_ones);\n    float vmag_v[3] = {vmag, vmag, vmag};\n    int sse_vmag = _mm_load_ps(vmag_v);\n    int sse_r = _mm_div_ps(sse_point_ball_diff, sse_vmag);\n    float ball_v[3] = {rball, rball, rball};\n    sse_r = _mm_div_ps(sse_r, _mm_load_ps(ball_v));\n    float v_v[3] = {vx[(j * n) + i], vy[(j * n) + i], vz[(j * n) + i]};\n    int sse_v = _mm_load_ps(v_v);\n    sse_v = _mm_sub_ps(sse_v, _mm_mul_ps(sse_v, _mm_mul_ps(sse_r, sse_r)));\n    _mm_store_ps(sum_v, sse_v);\n    vx[(j * n) + i] = sum_v[0];\n    vy[(j * n) + i] = sum_v[1];\n    vz[(j * n) + i] = sum_v[2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abu-abraham/open-MP/examples/Cloth Simulation/kernel_main_omp/7"}
{"code": "for (i = 1; i < 10; i++)\n{\n  m++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/cvalidation/omp_pragma_example2/2"}
{"code": "for (int i = 0; i < num_blocks; i++)\n{\n  uint64_t block = blocks[i];\n  for (int c = CHARS_PER_BLOCK - 1; c >= 0; c--)\n  {\n    uint64_t mask = 0xFF;\n    mask = mask << (c * 8);\n    unsigned char msg_char = (block & mask) >> (c * 8);\n    int idx = (i * CHARS_PER_BLOCK) + (CHARS_PER_BLOCK - (c + 1));\n    msg[idx] = msg_char;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/rsa/3"}
{"code": "for (c1 = nm; c1 <= (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/24"}
{"code": "for (i = se1; i > 0; i--)\n{\n  hh = (f = -1);\n  if (i == se1)\n    p = 0;\n  else\n    p = -1;\n\n  for (j = se2; j > 0; j--)\n  {\n    f -= gh;\n    t = (hh - g) - gh;\n    if (f < t)\n      f = t;\n\n    DD[j] -= gh;\n    t = (HH[j] - g) - gh;\n    if (DD[j] < t)\n      DD[j] = t;\n\n    hh = p + matrix[(int) ia[i]][(int) ib[j]];\n    if (hh < f)\n      hh = f;\n\n    if (hh < DD[j])\n      hh = DD[j];\n\n    p = HH[j];\n    HH[j] = hh;\n    if (hh > cost)\n    {\n      cost = hh;\n      *sb1 = i;\n      *sb2 = j;\n      if (cost >= maxscore)\n        break;\n\n    }\n\n  }\n\n  if (cost >= maxscore)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/9"}
{"code": "for (int i = 1; i < nOfLayers; i++)\n{\n  for (int j = 0; j < layers[i].nOfNeurons; j++)\n  {\n    for (int k = 0; k < (layers[i - 1].nOfNeurons + 1); k++)\n    {\n      if (layers[i].neurons[j].w != NULL)\n      {\n        layers[i].neurons[j].wCopy[k] = layers[i].neurons[j].w[k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/4"}
{"code": "for (int i = 0; i <= digits; ++i)\n  arr[i] = ARRINIT;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/neariot/openmp/openmp/0"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  j = (int) (i + ((nelements - i) * uniform()));\n  ix = index[j];\n  index[j] = index[i];\n  index[i] = ix;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/98"}
{"code": "for (i = 1930; i <= 1943; i++)\n{\n  years_bag[j] = i;\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/0"}
{"code": "for (i = 0; i < totalText; i++)\n{\n  FILE *f;\n  char fileName[1000];\n  sprintf(fileName, \"%s/text%d.txt\", \"inputs\", i);\n  f = fopen(fileName, \"r\");\n  if (f == 0)\n    exit(0);\n\n  readFromFile(f, &textData[i], &textLength[i]);\n  fclose(f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amckenna41/OMP-MPI-parallel-programming/omp/project_OMP/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  xcrref[m] = 1.0;\n  xceref[m] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/57"}
{"code": "for (uint8 x = 0; x < 15; x++)\n  for (uint8 y = 0; y < 30; y++)\n{\n  temp = features->layer5[4 * y][0][0];\n  temp += ((((((((((((((((((((((((features->layer4[x][0][0] * net->weight4_5[x][4 * y][0][0]) + (features->layer4[x][0][1] * net->weight4_5[x][4 * y][0][1])) + (features->layer4[x][0][2] * net->weight4_5[x][4 * y][0][2])) + (features->layer4[x][0][3] * net->weight4_5[x][4 * y][0][3])) + (features->layer4[x][0][4] * net->weight4_5[x][4 * y][0][4])) + (features->layer4[x][1][0] * net->weight4_5[x][4 * y][1][0])) + (features->layer4[x][1][1] * net->weight4_5[x][4 * y][1][1])) + (features->layer4[x][1][2] * net->weight4_5[x][4 * y][1][2])) + (features->layer4[x][1][3] * net->weight4_5[x][4 * y][1][3])) + (features->layer4[x][1][4] * net->weight4_5[x][4 * y][1][4])) + (features->layer4[x][2][0] * net->weight4_5[x][4 * y][2][0])) + (features->layer4[x][2][1] * net->weight4_5[x][4 * y][2][1])) + (features->layer4[x][2][2] * net->weight4_5[x][4 * y][2][2])) + (features->layer4[x][2][3] * net->weight4_5[x][4 * y][2][3])) + (features->layer4[x][2][4] * net->weight4_5[x][4 * y][2][4])) + (features->layer4[x][3][0] * net->weight4_5[x][4 * y][3][0])) + (features->layer4[x][3][1] * net->weight4_5[x][4 * y][3][1])) + (features->layer4[x][3][2] * net->weight4_5[x][4 * y][3][2])) + (features->layer4[x][3][3] * net->weight4_5[x][4 * y][3][3])) + (features->layer4[x][3][4] * net->weight4_5[x][4 * y][3][4])) + (features->layer4[x][4][0] * net->weight4_5[x][4 * y][4][0])) + (features->layer4[x][4][1] * net->weight4_5[x][4 * y][4][1])) + (features->layer4[x][4][2] * net->weight4_5[x][4 * y][4][2])) + (features->layer4[x][4][3] * net->weight4_5[x][4 * y][4][3])) + (features->layer4[x][4][4] * net->weight4_5[x][4 * y][4][4]);\n  features->layer5[4 * y][0][0] = temp;\n  temp = features->layer5[(4 * y) + 1][0][0];\n  temp += ((((((((((((((((((((((((features->layer4[x][0][0] * net->weight4_5[x][(4 * y) + 1][0][0]) + (features->layer4[x][0][1] * net->weight4_5[x][(4 * y) + 1][0][1])) + (features->layer4[x][0][2] * net->weight4_5[x][(4 * y) + 1][0][2])) + (features->layer4[x][0][3] * net->weight4_5[x][(4 * y) + 1][0][3])) + (features->layer4[x][0][4] * net->weight4_5[x][(4 * y) + 1][0][4])) + (features->layer4[x][1][0] * net->weight4_5[x][(4 * y) + 1][1][0])) + (features->layer4[x][1][1] * net->weight4_5[x][(4 * y) + 1][1][1])) + (features->layer4[x][1][2] * net->weight4_5[x][(4 * y) + 1][1][2])) + (features->layer4[x][1][3] * net->weight4_5[x][(4 * y) + 1][1][3])) + (features->layer4[x][1][4] * net->weight4_5[x][(4 * y) + 1][1][4])) + (features->layer4[x][2][0] * net->weight4_5[x][(4 * y) + 1][2][0])) + (features->layer4[x][2][1] * net->weight4_5[x][(4 * y) + 1][2][1])) + (features->layer4[x][2][2] * net->weight4_5[x][(4 * y) + 1][2][2])) + (features->layer4[x][2][3] * net->weight4_5[x][(4 * y) + 1][2][3])) + (features->layer4[x][2][4] * net->weight4_5[x][(4 * y) + 1][2][4])) + (features->layer4[x][3][0] * net->weight4_5[x][(4 * y) + 1][3][0])) + (features->layer4[x][3][1] * net->weight4_5[x][(4 * y) + 1][3][1])) + (features->layer4[x][3][2] * net->weight4_5[x][(4 * y) + 1][3][2])) + (features->layer4[x][3][3] * net->weight4_5[x][(4 * y) + 1][3][3])) + (features->layer4[x][3][4] * net->weight4_5[x][(4 * y) + 1][3][4])) + (features->layer4[x][4][0] * net->weight4_5[x][(4 * y) + 1][4][0])) + (features->layer4[x][4][1] * net->weight4_5[x][(4 * y) + 1][4][1])) + (features->layer4[x][4][2] * net->weight4_5[x][(4 * y) + 1][4][2])) + (features->layer4[x][4][3] * net->weight4_5[x][(4 * y) + 1][4][3])) + (features->layer4[x][4][4] * net->weight4_5[x][(4 * y) + 1][4][4]);\n  features->layer5[(4 * y) + 1][0][0] = temp;\n  temp = features->layer5[(4 * y) + 2][0][0];\n  temp += ((((((((((((((((((((((((features->layer4[x][0][0] * net->weight4_5[x][(4 * y) + 2][0][0]) + (features->layer4[x][0][1] * net->weight4_5[x][(4 * y) + 2][0][1])) + (features->layer4[x][0][2] * net->weight4_5[x][(4 * y) + 2][0][2])) + (features->layer4[x][0][3] * net->weight4_5[x][(4 * y) + 2][0][3])) + (features->layer4[x][0][4] * net->weight4_5[x][(4 * y) + 2][0][4])) + (features->layer4[x][1][0] * net->weight4_5[x][(4 * y) + 2][1][0])) + (features->layer4[x][1][1] * net->weight4_5[x][(4 * y) + 2][1][1])) + (features->layer4[x][1][2] * net->weight4_5[x][(4 * y) + 2][1][2])) + (features->layer4[x][1][3] * net->weight4_5[x][(4 * y) + 2][1][3])) + (features->layer4[x][1][4] * net->weight4_5[x][(4 * y) + 2][1][4])) + (features->layer4[x][2][0] * net->weight4_5[x][(4 * y) + 2][2][0])) + (features->layer4[x][2][1] * net->weight4_5[x][(4 * y) + 2][2][1])) + (features->layer4[x][2][2] * net->weight4_5[x][(4 * y) + 2][2][2])) + (features->layer4[x][2][3] * net->weight4_5[x][(4 * y) + 2][2][3])) + (features->layer4[x][2][4] * net->weight4_5[x][(4 * y) + 2][2][4])) + (features->layer4[x][3][0] * net->weight4_5[x][(4 * y) + 2][3][0])) + (features->layer4[x][3][1] * net->weight4_5[x][(4 * y) + 2][3][1])) + (features->layer4[x][3][2] * net->weight4_5[x][(4 * y) + 2][3][2])) + (features->layer4[x][3][3] * net->weight4_5[x][(4 * y) + 2][3][3])) + (features->layer4[x][3][4] * net->weight4_5[x][(4 * y) + 2][3][4])) + (features->layer4[x][4][0] * net->weight4_5[x][(4 * y) + 2][4][0])) + (features->layer4[x][4][1] * net->weight4_5[x][(4 * y) + 2][4][1])) + (features->layer4[x][4][2] * net->weight4_5[x][(4 * y) + 2][4][2])) + (features->layer4[x][4][3] * net->weight4_5[x][(4 * y) + 2][4][3])) + (features->layer4[x][4][4] * net->weight4_5[x][(4 * y) + 2][4][4]);\n  features->layer5[(4 * y) + 2][0][0] = temp;\n  temp = features->layer5[(4 * y) + 3][0][0];\n  temp += ((((((((((((((((((((((((features->layer4[x][0][0] * net->weight4_5[x][(4 * y) + 3][0][0]) + (features->layer4[x][0][1] * net->weight4_5[x][(4 * y) + 3][0][1])) + (features->layer4[x][0][2] * net->weight4_5[x][(4 * y) + 3][0][2])) + (features->layer4[x][0][3] * net->weight4_5[x][(4 * y) + 3][0][3])) + (features->layer4[x][0][4] * net->weight4_5[x][(4 * y) + 3][0][4])) + (features->layer4[x][1][0] * net->weight4_5[x][(4 * y) + 3][1][0])) + (features->layer4[x][1][1] * net->weight4_5[x][(4 * y) + 3][1][1])) + (features->layer4[x][1][2] * net->weight4_5[x][(4 * y) + 3][1][2])) + (features->layer4[x][1][3] * net->weight4_5[x][(4 * y) + 3][1][3])) + (features->layer4[x][1][4] * net->weight4_5[x][(4 * y) + 3][1][4])) + (features->layer4[x][2][0] * net->weight4_5[x][(4 * y) + 3][2][0])) + (features->layer4[x][2][1] * net->weight4_5[x][(4 * y) + 3][2][1])) + (features->layer4[x][2][2] * net->weight4_5[x][(4 * y) + 3][2][2])) + (features->layer4[x][2][3] * net->weight4_5[x][(4 * y) + 3][2][3])) + (features->layer4[x][2][4] * net->weight4_5[x][(4 * y) + 3][2][4])) + (features->layer4[x][3][0] * net->weight4_5[x][(4 * y) + 3][3][0])) + (features->layer4[x][3][1] * net->weight4_5[x][(4 * y) + 3][3][1])) + (features->layer4[x][3][2] * net->weight4_5[x][(4 * y) + 3][3][2])) + (features->layer4[x][3][3] * net->weight4_5[x][(4 * y) + 3][3][3])) + (features->layer4[x][3][4] * net->weight4_5[x][(4 * y) + 3][3][4])) + (features->layer4[x][4][0] * net->weight4_5[x][(4 * y) + 3][4][0])) + (features->layer4[x][4][1] * net->weight4_5[x][(4 * y) + 3][4][1])) + (features->layer4[x][4][2] * net->weight4_5[x][(4 * y) + 3][4][2])) + (features->layer4[x][4][3] * net->weight4_5[x][(4 * y) + 3][4][3])) + (features->layer4[x][4][4] * net->weight4_5[x][(4 * y) + 3][4][4]);\n  features->layer5[(4 * y) + 3][0][0] = temp;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NegarNd/CNN-Inference-Acceleration/main_omp/5"}
{"code": "for (unsigned int i = 0; i < latlen; i++)\n{\n  for (unsigned int k = 0; k < vd; k++)\n    templat[i][k] = 1.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keygenx/N-Vector-Model/Vector Model/14"}
{"code": "for (int i = 0; i < 4; i++)\n  macro_xs[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/rsbench-omp/simulation/1"}
{"code": "for (int i = 0; i < m_numParticles; i++)\n  m_parts[i]->update(timestep);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KunstDerFuge/PartSim/Space/4"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    u[i][j] = w[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/7"}
{"code": "for (int i = 0; i < k; i++)\n{\n  kernel[i] /= sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/OpenMP/1"}
{"code": "for (j = num_buckets - 1; j >= 0; --j)\n{\n  k = start_idx[(t_id * num_buckets) + j];\n  for (iter = vc_vector_begin(buckets[(t_id * num_buckets) + j]); iter != vc_vector_end(buckets[(t_id * num_buckets) + j]); iter = vc_vector_next(buckets[(t_id * num_buckets) + j], iter))\n  {\n    labels[*((uint32_t *) iter)] = k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/23"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  a[i] = (rand() % 10) + 1;\n  b[i] = (rand() % 10) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VladislavSmekhnov/OpenMP_tasks/openmp_6/0"}
{"code": "for (i = 0; i < bin_count; i++)\n  for (j = 0; j < thread_count; j++)\n{\n  bin_counts[i] += loc_bin_counts[(j * bin_count) + i];\n}\n\n\n", "pragma": "omp for private(i,j) schedule(static) reduction(+:bin_counts[:bin_count])", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysimonov/C-concurrent/OpenMP/lab3part3/1"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  row_sum = 0.0;\n  for (j = 0; j < num_columns; j++)\n  {\n    row_sum += fabs(M.elements[(i * M.num_rows) + j]);\n  }\n\n  M.elements[(i * M.num_rows) + i] = 0.5 + row_sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg443/Jacobi-Solver-OpenMP/jacobi_solver/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 0;\n  for (j = 0; j < n; j++)\n    b[i] += A[(i * n) + j] * x[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysimonov/C-concurrent/OpenMP/lab3part5/1"}
{"code": "for (xyz = 0; xyz <= 2; xyz++)\n{\n  dr[xyz] = r[i1][0][xyz] - r[i2][0][xyz];\n  shift[xyz] = (-L) * floor((dr[xyz] / L) + .5);\n  dr[xyz] = dr[xyz] + shift[xyz];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Energy-Calculation-for-a-box-of-water-molecules/waters_openmp/1"}
{"code": "for (uint64_t i = size; i > (size - k); i--)\n{\n  r[size - i] /= i * r0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/15"}
{"code": "for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/70"}
{"code": "for (i = 0; i <= last_frm; i++)\n{\n  snprintf(mc_filename, sizeof(mc_filename), \"%s%s%d%s\", mc_dir, \"mcdata_\", i, \"_P0.dat\");\n  for (j = 0; j < angle_procs; j++)\n  {\n    snprintf(mc_filename_2, sizeof(mc_filename), \"%s%s%d%s%d%s\", mc_dir, \"mcdata_\", i, \"_P0_\", j, \".dat\");\n    if ((access(mc_filename, F_OK) != (-1)) || (access(mc_filename_2, F_OK) != (-1)))\n    {\n      snprintf(mc_operation, sizeof(flash_prefix), \"%s%s%s%d%s\", \"exec rm \", mc_dir, \"mcdata_\", i, \"_*.dat\");\n      system(mc_operation);\n      snprintf(mc_operation, sizeof(flash_prefix), \"%s%s%s%d%s\", \"exec rm \", mc_dir, \"mcdata_\", i, \"_*\");\n      system(mc_operation);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/9"}
{"code": "for (int i = 0; i < length; i++)\n{\n  result[i] = a[i] + (b[i] * erff(c[i]));\n}\n\n", "pragma": "#pragma omp parallel for            ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kuldeepldec/Declarative-parallelization-using-OpenMP/openmp/0"}
{"code": "for (int index = 0; index < arrLen; index = index + (2 * numValsEach))\n{\n  int startIA = index;\n  int startIB = index + numValsEach;\n  if (startIB >= arrLen)\n  {\n    continue;\n  }\n\n  if (numValsEach == 1)\n  {\n    if (arr[startIA] <= arr[startIB])\n    {\n      continue;\n    }\n    else\n    {\n      double temp = arr[startIB];\n      arr[startIB] = arr[startIA];\n      arr[startIA] = temp;\n      continue;\n    }\n\n  }\n\n  int endI = index + (2 * numValsEach);\n  if (endI >= arrLen)\n  {\n    endI = arrLen;\n  }\n\n  buMerging(arr, startIA, startIB, endI);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/mergeSort/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  Matrix[0][i] = 1.0;\n  Matrix[10 - 1][i] = 1.0;\n  Matrix[i][0] = 1.0;\n  Matrix[i][10 - 1] = 1.0;\n  Matrix2[0][i] = 1.0;\n  Matrix2[10 - 1][i] = 1.0;\n  Matrix2[i][0] = 1.0;\n  Matrix2[i][10 - 1] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/omp_parallel_for/stencil/1"}
{"code": "for (i = 0; i < 150000; i++)\n{\n  a *= 0.5;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/Parallel-and-Distributed-Programming-Lab3/lab3/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  A[i] *= B[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/10.norace2/0"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || (mat2[rowcol] <= 0.001))\n  {\n    matOut3[rowcol] = 0.0;\n    matdtdry[rowcol] = -28768;\n  }\n  else\n  {\n    if (((mat1[rowcol] * 0.0001) > ndvi_max) && ((mat1[rowcol] * 0.0001) < 0.98))\n      ndvi_max = mat1[rowcol] * 0.0001;\n\n    if (((mat2[rowcol] * 0.001) > albedo_max) && ((mat2[rowcol] * 0.001) < 0.9))\n      albedo_max = mat2[rowcol] * 0.001;\n\n    if (((mat2[rowcol] * 0.001) < albedo_min) && ((mat2[rowcol] * 0.001) > 0.001))\n      albedo_min = mat2[rowcol] * 0.001;\n\n    tempk = mat8[rowcol] * 0.02;\n    dem = mat14[rowcol];\n    t0dem = tempk + (0.00627 * dem);\n    if ((t0dem > t0dem_max) && (t0dem > 274))\n      t0dem_max = t0dem;\n\n    if ((t0dem < t0dem_min) && (t0dem > 274))\n      t0dem_min = t0dem;\n\n    etpotd = et_pot_day(mat15[rowcol], tempk, roh_w);\n    matOut3[rowcol] = etpotd;\n    Rn = mat16[rowcol];\n    g0 = mat17[rowcol];\n    matdtdry[rowcol] = (0.2 * (Rn - g0)) / u2m;\n    if (matdtdry[rowcol] > 100)\n      matdtdry[rowcol] = 0;\n\n    if (matdtdry[rowcol] > dtdry_max)\n      dtdry_max = matdtdry[rowcol];\n\n    if (matdtdry[rowcol] < dtdry_min)\n      dtdry_min = matdtdry[rowcol];\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, tempk, etpotd, Rn, g0, dem, t0dem,) shared(N, nX, nY, roh_w, tsw, doy, u2m, t0dem_min,t0dem_max,dtdry_min,dtdry_max, ndvi_max,albedo_min,albedo_max, mat1,mat2,mat8,mat14, mat15,mat16, mat17, matdtdry, matOut3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"loop: %d, thread: %lu, iteration: %d\\n\", loop_index, 0, i);\n  loop_2[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/13"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i][j1][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/176"}
{"code": "for (int i = 0; i < n; i++)\n{\n  m[rowPut][i] += k * m[rowGet][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexeyshesh/InverseMatrixParallel/main/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  strip[i] = (double *) malloc(cols * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh-raghavan/Parallel-Programming/TempDistribution/3/2"}
{"code": "for (i = chunk * rank; i < (chunk * (rank + 1)); i++)\n{\n  if (strcmp(H_table[i].row_key, search) == 0)\n  {\n    printf(\"%d\", i);\n    found++;\n    printf(\"Match Found!\\n\");\n    printf(\"Key: %s\\n ID: %d\\n\", H_table[i].row_key, H_table[i].value);\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Bigtable-in-C/Bigtable2/2"}
{"code": "for (i = L1; i <= L2; i += 1)\n{\n  for (j = jst; j <= jend; j += 1)\n  {\n    for (k = 1; k <= (nz - 2); k += 1)\n    {\n      flux[i][j][k][0] = u[i][j][k][1];\n      u21 = u[i][j][k][1] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = (u[i][j][k][1] * u21) + (0.40e+00 * (u[i][j][k][4] - q));\n      flux[i][j][k][2] = u[i][j][k][2] * u21;\n      flux[i][j][k][3] = u[i][j][k][3] * u21;\n      flux[i][j][k][4] = ((1.40e+00 * u[i][j][k][4]) - (0.40e+00 * q)) * u21;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (q,u21,i,j,k) firstprivate (L2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/87"}
{"code": "for (int count = 0; count < columns; count++)\n{\n  ptrvectorOMP[count] = ptrarray[count];\n}\n\n", "pragma": "        #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/OMPmultMatrixAndVector/OMPmultMatrixAndVector/OMPmultMatrixAndVector/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  bool test = false;\n  int j = 0;\n  while (test == false)\n  {\n    if ((table[i] - j) < 1.0)\n    {\n      test = true;\n      histo_private[j]++;\n    }\n\n    j++;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Histogramme/Histo_reduction/0"}
{"code": "for (i = 0; i < 100; i++)\n  C[i] = 0;\n\n", "pragma": "omp parallel for shared(C) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/counting/0"}
{"code": "for (int a = -1; a < 2; a++)\n{\n  for (int b = -1; b < 2; b++)\n    if (main_ptr[i + a][j + b] == syms->ehead)\n    electronHeadNumber++;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/4"}
{"code": "for (k = 1; k < 10; k++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    avgtime[j] = avgtime[j] + times[j][k];\n    mintime[j] = (mintime[j] < times[j][k]) ? (mintime[j]) : (times[j][k]);\n    maxtime[j] = (maxtime[j] > times[j][k]) ? (maxtime[j]) : (times[j][k]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/6"}
{"code": "for (j = 0; j < nodes[i].n; j++)\n{\n  n = nodes[i].neighbor[j];\n  _taskFunc0_((void *) 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/concom/src/concom_ompi_trim/0"}
{"code": "for (int i = 0; i < strLength; ++i)\n{\n  if (((rand() % 10000) == 0) && ((strLength - i) > (subLength + 1)))\n  {\n    for (int j = 0; j < subLength; ++j)\n      string[i + j] = subString[j];\n\n    i += subLength;\n    if (!(rand() % 2))\n    {\n      string[i - 1] = 'a' + (rand() % 26);\n    }\n\n  }\n\n  string[i] = 'a' + (rand() % 26);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task5test/0"}
{"code": "for (int i = 0; i < numBlocks; i++)\n{\n  const int dev = i % ndevs;\n  printf(\"device chosen for iteration %d : %d\\n\", i, dev);\n  OMPVV_START_TIMER;\n  {\n    const int NN = blockWork[i];\n    const int startInd = (i % (numBlocks / ndevs)) * NN;\n    const int endInd = ((i % (numBlocks / ndevs)) + 1) * NN;\n    float *temp;\n    b[startInd - 1] = lboundary[i];\n    b[endInd + 1] = rboundary[i];\n    for (int j = startInd; j <= endInd; j++)\n      a[j] = ((b[j] + b[j - 1]) + b[j + 1]) / 3.0;\n\n    temp = b;\n    b = a;\n    a = temp;\n    lboundary[i] = a[startInd - 1];\n    rboundary[i] = a[endInd + 1];\n  }\n  OMPVV_STOP_TIMER;\n}\n\n", "pragma": "omp for schedule(static, gsz)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/ecp-omp/type1/structuredGrid/bench_stencil/0"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < len; j++)\n  a[j] += x[(i * len) + j];\n\n\n", "pragma": "  #pragma omp parallel for reduction(vec_float_plus : a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/7"}
{"code": "for (int l = i; l < n; l++)\n{\n  D[i][l] = ((a[i] == t[l]) && D[i - 1][l - 1]) ? (1) : (0);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranshumaheshwari/Parallel-String-Matching/parallel_shift_and/2"}
{"code": "for (int n = 0; n < m; n++)\n  biggest_score = max(biggest_score, scores[n]);\n\n", "pragma": "\t#pragma omp parallel for reduction(max : biggest_score)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bc/omp_target/4"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    fjac[i][j][k][0][0] = 0.0;\n    fjac[i][j][k][0][1] = 0.0;\n    fjac[i][j][k][0][2] = 1.0;\n    fjac[i][j][k][0][3] = 0.0;\n    fjac[i][j][k][0][4] = 0.0;\n    fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][2])) * tmp2;\n    fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1;\n    fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1;\n    fjac[i][j][k][1][3] = 0.0;\n    fjac[i][j][k][1][4] = 0.0;\n    fjac[i][j][k][2][0] = (-((u[i][j][k][2] * u[i][j][k][2]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n    fjac[i][j][k][2][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n    fjac[i][j][k][2][2] = ((2.0 - c2) * u[i][j][k][2]) * tmp1;\n    fjac[i][j][k][2][3] = ((-c2) * u[i][j][k][3]) * tmp1;\n    fjac[i][j][k][2][4] = c2;\n    fjac[i][j][k][3][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n    fjac[i][j][k][3][1] = 0.0;\n    fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1;\n    fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1;\n    fjac[i][j][k][3][4] = 0.0;\n    fjac[i][j][k][4][0] = ((((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - ((c1 * u[i][j][k][4]) * tmp1)) * u[i][j][k][2]) * tmp1;\n    fjac[i][j][k][4][1] = (((-c2) * u[i][j][k][1]) * u[i][j][k][2]) * tmp2;\n    fjac[i][j][k][4][2] = ((c1 * u[i][j][k][4]) * tmp1) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + ((3.0 * u[i][j][k][2]) * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n    fjac[i][j][k][4][3] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n    fjac[i][j][k][4][4] = (c1 * u[i][j][k][2]) * tmp1;\n    njac[i][j][k][0][0] = 0.0;\n    njac[i][j][k][0][1] = 0.0;\n    njac[i][j][k][0][2] = 0.0;\n    njac[i][j][k][0][3] = 0.0;\n    njac[i][j][k][0][4] = 0.0;\n    njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n    njac[i][j][k][1][1] = c3c4 * tmp1;\n    njac[i][j][k][1][2] = 0.0;\n    njac[i][j][k][1][3] = 0.0;\n    njac[i][j][k][1][4] = 0.0;\n    njac[i][j][k][2][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][2];\n    njac[i][j][k][2][1] = 0.0;\n    njac[i][j][k][2][2] = (con43 * c3c4) * tmp1;\n    njac[i][j][k][2][3] = 0.0;\n    njac[i][j][k][2][4] = 0.0;\n    njac[i][j][k][3][0] = ((-c3c4) * tmp2) * u[i][j][k][3];\n    njac[i][j][k][3][1] = 0.0;\n    njac[i][j][k][3][2] = 0.0;\n    njac[i][j][k][3][3] = c3c4 * tmp1;\n    njac[i][j][k][3][4] = 0.0;\n    njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - ((((con43 * c3c4) - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c3c4 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n    njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n    njac[i][j][k][4][2] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][2];\n    njac[i][j][k][4][3] = ((c3c4 - c1345) * tmp2) * u[i][j][k][3];\n    njac[i][j][k][4][4] = c1345 * tmp1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/57"}
{"code": "for (cnt = 0; cnt < 2; ++cnt)\n  for (int j = 0; j < (4 + cnt); j++)\n  k = cnt;\n\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_codegen/1"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_cell/5"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < width; k++)\n    {\n      double x = a[(i * width) + k];\n      double y = b[(k * width) + j];\n      sum += x * y;\n    }\n\n    c[(i * width) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa04/mm/0"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  p_new[i][0] = ((((del_y * del_y) * (p[i][1] + p[i][x_points - 1])) + ((del_x * del_x) * (p[i + 1][0] + p[i - 1][0]))) / (2 * ((del_x * del_x) + (del_y * del_y)))) - ((((((rho * del_x) * del_x) * del_y) * del_y) / (2 * ((del_x * del_x) + (del_y * del_y)))) * (((((1 / del_t) * (((u[i][1] - u[i][x_points - 1]) / (2 * del_x)) + ((v[i + 1][0] - v[i - 1][0]) / (2 * del_y)))) - (((u[i][1] - u[i][x_points - 1]) / (2 * del_x)) * ((u[i][1] - u[i][x_points - 1]) / (2 * del_x)))) - (2.0 * (((u[i + 1][0] - u[i - 1][0]) / (2 * del_y)) * ((v[i][1] - v[i][x_points - 1]) / (2 * del_x))))) - (((v[i + 1][0] - v[i - 1][0]) / (2 * del_y)) * ((v[i + 1][0] - v[i - 1][0]) / (2 * del_y)))));\n  p_new[i][x_points - 1] = ((((del_y * del_y) * (p[i][0] + p[i][x_points - 2])) + ((del_x * del_x) * (p[i + 1][x_points - 1] + p[i - 1][x_points - 1]))) / (2 * ((del_x * del_x) + (del_y * del_y)))) - ((((((rho * del_x) * del_x) * del_y) * del_y) / (2 * ((del_x * del_x) + (del_y * del_y)))) * (((((1 / del_t) * (((u[i][0] - u[i][x_points - 2]) / (2 * del_x)) + ((v[i + 1][x_points - 1] - v[i - 1][x_points - 1]) / (2 * del_y)))) - (((u[i][0] - u[i][x_points - 2]) / (2 * del_x)) * ((u[i][0] - u[i][x_points - 2]) / (2 * del_x)))) - (2.0 * (((u[i + 1][x_points - 1] - u[i - 1][x_points - 1]) / (2 * del_y)) * ((v[i][0] - v[i][x_points - 2]) / (2 * del_x))))) - (((v[i + 1][x_points - 1] - v[i - 1][x_points - 1]) / (2 * del_y)) * ((v[i + 1][x_points - 1] - v[i - 1][x_points - 1]) / (2 * del_y)))));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Channel Flow/2-D_Channel_Flow/main/3"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n    sum += j;\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49898-2/0"}
{"code": "for (int t = 0; t < p; t++)\n{\n  int lo = t * (N / p);\n  int hi = min(lo + (N / p), N - 1);\n  S(t) = 0.0f;\n  for (int i = lo; i < hi; i++)\n  {\n    if (j == 1)\n    {\n      D(i) = (C.row(j - 1) - X.row(i)).norm();\n    }\n    else\n    {\n      D(i) = min((X.row(i) - C.row(j - 1)).norm(), D(i));\n    }\n\n    S(t) = S(t) + D(i);\n  }\n\n  int sub_i = weighted_rand_index_bound(D, r, lo, hi);\n  I[t] = sub_i;\n}\n\n", "pragma": "    \t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JuliaCao/k_means_pp/omp/omp/3"}
{"code": "for (i = 0; i < 5; i++)\n{\n  tid = omp_get_thread_num();\n  amax = (amax > a[i]) ? (amax) : (a[i]);\n  printf(\"i = %d, amax = %d, id = %d\\n\", i, amax, tid);\n}\n\n", "pragma": "omp parallel for reduction(max:amax) private(i, tid) shared(a)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter3/rf/2"}
{"code": "for (int i = 0; i < 12000000; i++)\n{\n  x[i] = rand() % (1 << 10);\n  y[i] = rand() % (1 << 10);\n  z[i] = rand() % (1 << 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/agujjar2206/OpenMP/openMp/4"}
{"code": "for (int i = 0; i < R; i++)\n{\n  for (int j = 0; j < C; j++)\n  {\n    t_data[(i * C) + j] = data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/main/4"}
{"code": "for (int i = 0; i < schools.size(); i++)\n{\n  execute(schools[i]);\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stride-Apollo/proto-TBB/proto2/4"}
{"code": "for (long i = 0; i <= numColors; i++)\n{\n  colorPtr[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/equitableColoringDistanceOne/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  b[j] = c[j];\n}\n\n", "pragma": "omp parallel for shared(b) firstprivate(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/twoRegions/0"}
{"code": "for (int i = 1; i < NUM_PI; i++)\n{\n  MPI_Send(inmsg[0] + (i * sendsize), sendsize, MPI_BYTE, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ReinhartC/Parallel-RSA-on-Raspberry-Pi/Builds/OMP_MPI/RSA_OMP_MPI/0"}
{"code": "for (int j = 0; j < nCols; j++)\n{\n  arrayC[i][j] = arrayA[i][j] + arrayB[i][j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/MatrixOperations/MatrixOperations/Parallel/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/58"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    if (m[i][j] != 1)\n    {\n      printf(\"Element [%d,%d] not set... \\n\", i, j);\n      ok = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joeladams/patternlets/patternlets/openMP/11.private/private/1"}
{"code": "for (j = 0; j < nrows; j++)\n{\n  if (j > 0)\n  {\n    j1 = rowstr[j] - nzloc[j - 1];\n  }\n  else\n  {\n    j1 = 0;\n  }\n\n  j2 = rowstr[j + 1] - nzloc[j];\n  nza = rowstr[j];\n  for (k = j1; k < j2; k++)\n  {\n    nza = rowstr[j] + (k - j1);\n    a[k] = a[nza];\n    colidx[k] = colidx[nza];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jordan0605/OpenMP/CG/cg/0"}
{"code": "for (int i = 0; i < VECTOR_SIZE; i++)\n{\n  printf(\"%d + %d = %d\\n\", arr_a[i], arr_b[i], arr_c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yester31/openMP/opemMP_2/opemMP_2/4"}
{"code": "for (i = 0; i < fa; i++)\n{\n  for (j = 0; j < cb; j++)\n  {\n    s = 0.;\n    for (k = 0; k < ca; k++)\n      s = s + (a[(i * lda) + k] * b[(k * ldb) + j]);\n\n    c[(i * ldc) + j] = s;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k,s) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muriloboratto/hands-on-supercomputing-with-parallel-computing/Hands-On-5-Basic-Hybrid-Application-MPI+OpenMP/material/mm-mpi+openmp/0"}
{"code": "for (i = offset_start; i < offset_end; i++)\n{\n  key = edgeList->edges_array_dest[i];\n  pos = vertex_count[(t_id * num_vertices) + key];\n  sorted_edges_array->edges_array_dest[pos] = edgeList->edges_array_dest[i];\n  sorted_edges_array->edges_array_src[pos] = edgeList->edges_array_src[i];\n  sorted_edges_array->edges_array_weight[pos] = edgeList->edges_array_weight[i];\n  vertex_count[(t_id * num_vertices) + key]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/countsort/8"}
{"code": "for (i = 0; i < m; ++i)\n{\n  for (j = 0; j < p; ++j)\n  {\n    (((cout << \"Enter element B\") << (i + 1)) << (j + 1)) << \" : \";\n    cin >> b[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task1(a+b)/1"}
{"code": "for (int i = 0; i < num_obj; i++)\n{\n  t2 += stop_tab[i] - start_tab[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omar-E-R/tp-programmation-parallel-openMP/TP2/ELRIFAI_Omar_tp2/1"}
{"code": "for (int *q_iter = queue.begin(); q_iter < queue.end(); q_iter++)\n{\n  int u = *q_iter;\n  bm.set_bit_atomic(u);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bfs/omp_target/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  next_x[i] = b[i];\n  for (int j = 0; j < n; ++j)\n  {\n    if (i != j)\n    {\n      next_x[i] -= A[i][j] * x[j];\n    }\n\n  }\n\n  next_x[i] /= A[i][i];\n  norm = max(fabs(x[i] - next_x[i]), norm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/5"}
{"code": "for (i = 0; i < N_prime; i++)\n{\n  for (j = 0; j < L; j++)\n  {\n    temporary = BOLD[((so_far * L) + (i * L)) + j];\n    BOLD_section[(j * N_prime) + i] = temporary;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/7"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, 0, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x += 8)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n        u[xyzInd + 1] += u[(xyzInd + 1) - OMP_xMax] * nu;\n        u[xyzInd + 2] += u[(xyzInd + 2) - OMP_xMax] * nu;\n        u[xyzInd + 3] += u[(xyzInd + 3) - OMP_xMax] * nu;\n        u[xyzInd + 4] += u[(xyzInd + 4) - OMP_xMax] * nu;\n        u[xyzInd + 5] += u[(xyzInd + 5) - OMP_xMax] * nu;\n        u[xyzInd + 6] += u[(xyzInd + 6) - OMP_xMax] * nu;\n        u[xyzInd + 7] += u[(xyzInd + 7) - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, yval, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x += 8)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n        u[xyzInd + 1] += u[(xyzInd + 1) + OMP_xMax] * nu;\n        u[xyzInd + 2] += u[(xyzInd + 2) + OMP_xMax] * nu;\n        u[xyzInd + 3] += u[(xyzInd + 3) + OMP_xMax] * nu;\n        u[xyzInd + 4] += u[(xyzInd + 4) + OMP_xMax] * nu;\n        u[xyzInd + 5] += u[(xyzInd + 5) + OMP_xMax] * nu;\n        u[xyzInd + 6] += u[(xyzInd + 6) + OMP_xMax] * nu;\n        u[xyzInd + 7] += u[(xyzInd + 7) + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, 0);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x += 8)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n        u[xyzInd + 1] = u[(xyzInd + 1) - xyMax] * nu;\n        u[xyzInd + 2] = u[(xyzInd + 2) - xyMax] * nu;\n        u[xyzInd + 3] = u[(xyzInd + 3) - xyMax] * nu;\n        u[xyzInd + 4] = u[(xyzInd + 4) - xyMax] * nu;\n        u[xyzInd + 5] = u[(xyzInd + 5) - xyMax] * nu;\n        u[xyzInd + 6] = u[(xyzInd + 6) - xyMax] * nu;\n        u[xyzInd + 7] = u[(xyzInd + 7) - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, zval);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/tompDeblur/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  distances[i] = dist[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/3"}
{"code": "for (; itr != itrEnd; ++itr)\n{\n  (*itr).recenter();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimagimburg/KMeansAlgorithmSequentialAndParallel/clustering_points/ParallelKMeans/2"}
{"code": "for (i = 0; i < N; ++i)\n{\n  soma = 0.0f;\n  for (j = 0; j < N; ++j)\n  {\n    if (i != j)\n    {\n      soma += fabs(A[i][j]);\n    }\n\n  }\n\n  soma /= fabs(A[i][i]);\n  if (max < soma)\n  {\n    max = soma;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmunidario/Algoritmo_Jacobi/omp_jacobi/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  p[i] = (a + b) + c;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(a, b, c, p[:N]) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-class/test/2"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  float head1[8] = {A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k]};\n  t3 = _mm256_loadu_ps(head1);\n  for (int j = begin; j < n; j += 8)\n  {\n    t1 = _mm256_loadu_ps(A[k] + j);\n    t2 = _mm256_loadu_ps(A[i] + j);\n    t1 = _mm256_mul_ps(t1, t3);\n    t2 = _mm256_sub_ps(t2, t1);\n    _mm256_storeu_ps(A[i] + j, t2);\n  }\n\n  A[i][k] = 0;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/9"}
{"code": "for (int i = 0; i < rowCount; i++)\n{\n  int nonZeroCountCurRow = 0;\n  for (int j = 0; j < colCount; j++)\n  {\n    if (tempMatrix[i][j] != 0)\n    {\n      if (nonZeroCountCurRow == 0)\n      {\n        row_ptr[i] = currentIndex;\n      }\n\n      col_ind[row_ptr[i] + nonZeroCountCurRow] = j;\n      values[row_ptr[i] + nonZeroCountCurRow] = tempMatrix[i][j];\n      currentIndex++;\n      nonZeroCountCurRow++;\n    }\n\n  }\n\n  if (nonZeroCountCurRow == 0)\n  {\n    row_ptr[i] = currentIndex;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/5"}
{"code": "for (unsigned i = 0; i < num_neurons; ++i)\n{\n  variance += (layer.at(i) * (layer.at(i) - mean)) * (layer.at(i) - mean);\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:variance)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/25"}
{"code": "for (register int i = 1; i < (nx - 1); i++)\n  for (register int j = 1; j < (ny - 1); j++)\n  for (register int k = 1; k < (nz - 1); k++)\n{\n  *(vectSolver++) = vectPhys1.get(i, j, k);\n  *(vectSolver++) = vectPhys2.get(i, j, k);\n  *(vectSolver++) = vectPhys3.get(i, j, k);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/22"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (arr[i] == arr[j])\n    {\n      if (i == j)\n      {\n        continue;\n      }\n      else\n      {\n        redundant = arr[i];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yehia67/OpenMP-Examples/lab5_main1_Nested/0"}
{"code": "for (unsigned int i = 0; i < N; ++i)\n{\n  sum_omp += array_omp[i];\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum_omp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bbercovici/openMP_demo/source/main/3"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    exact(0, j, k, temp1);\n    exact(nx - 1, j, k, temp2);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][j][0][m] = temp1[m];\n      u[k][j][nx - 1][m] = temp2[m];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/34"}
{"code": "for (int i = 0; i < fil; i++)\n{\n  matris2[i] = (Celda *) malloc(col * (sizeof(Celda)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nachoLedesma1/openMP2/openMPLedesmaIgnacio/4"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttx2 * speed[i - 1][j][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttx2 * speed[i + 1][j][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttx2 * speed[i - 1][j][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttx2 * speed[i + 1][j][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dttx2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/61"}
{"code": "for (int i = 0; i < 26; i++)\n{\n  resReduce2 += resReduce1[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/mapreduce-openmp/1"}
{"code": "for (int i = 0; i < num_threads; i++)\n{\n  struct subarray struct1 = {i * num_threads, (i * num_threads) + idx_per_thread, n};\n  int status = pthread_create(&id[i], NULL, initialize, (void *) (&struct1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1_pthreads/0"}
{"code": "for (idx_t i = 0; i < M; ++i)\n{\n  for (idx_t jt = 0; jt < N; jt += TILE)\n  {\n    for (idx_t kt = 0; kt < Na; kt += TILE)\n    {\n      const idx_t JSTOP = SS_MIN(jt + TILE, N);\n      for (idx_t j = jt; j < JSTOP; ++j)\n      {\n        val_t accum = 0;\n        const idx_t KSTOP = SS_MIN(kt + TILE, Na);\n        for (idx_t k = kt; k < KSTOP; ++k)\n        {\n          accum += av[k + (i * Na)] * bv[j + (k * N)];\n        }\n\n        cv[j + (i * N)] += accum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/8"}
{"code": "for (size_t time_point = 1; time_point < parameters->time_points; ++time_point)\n{\n  mesh_Set(mesh, time_point, 0, parameters->boundary_condition_0);\n  mesh_Set(mesh, time_point, mesh->space_points - 1, parameters->boundary_condition_1);\n  for (size_t space_point = 1; space_point < (mesh->space_points - 1); ++space_point)\n  {\n    const real_type k_1 = f(space_step, time_step, parameters->diffusivity, mesh_Get(mesh, time_point - 1, space_point - 1), mesh_Get(mesh, time_point - 1, space_point), mesh_Get(mesh, time_point - 1, space_point + 1));\n    const real_type k_2 = f(space_step, time_step, parameters->diffusivity, mesh_Get(mesh, time_point - 1, space_point - 1) + (k_1 / 2.0), mesh_Get(mesh, time_point - 1, space_point) + (k_1 / 2.0), mesh_Get(mesh, time_point - 1, space_point + 1) + (k_1 / 2.0));\n    const real_type k_3 = f(space_step, time_step, parameters->diffusivity, mesh_Get(mesh, time_point - 1, space_point - 1) + (k_2 / 2.0), mesh_Get(mesh, time_point - 1, space_point) + (k_2 / 2.0), mesh_Get(mesh, time_point - 1, space_point + 1) + (k_2 / 2.0));\n    const real_type k_4 = f(space_step, time_step, parameters->diffusivity, mesh_Get(mesh, time_point - 1, space_point - 1) + k_3, mesh_Get(mesh, time_point - 1, space_point) + k_3, mesh_Get(mesh, time_point - 1, space_point + 1) + k_3);\n    const real_type temperature = mesh_Get(mesh, time_point - 1, space_point) + ((((k_1 + (2.0 * k_2)) + (2.0 * k_3)) + k_4) / 6.0);\n    mesh_Set(mesh, time_point, space_point, temperature);\n  }\n\n  if (on_solution != 0)\n  {\n    const int visited = on_solution(parameters, mesh, time_point);\n    if (visited != 0)\n    {\n      fprintf(stderr, \"Error: something went wrong.\\n\");\n      mesh_Destroy(mesh);\n      return visited;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/8"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  int cock;\n  int hen;\n  int chick;\n  for (cock = 0; cock <= 20; cock++)\n    for (hen = 0; hen <= 33; hen++)\n    for (chick = 0; chick <= 99; chick++)\n    if ((((5 * cock) + (3 * hen)) + (chick / 3)) == 100)\n    if (((chick % 3) == 0) && (i == 9999))\n    ((((((cout << \"cock = \") << cock) << \"hen = \") << hen) << \"chick = \") << chick) << endl;\n\n\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bbw7561135/NumCode/005/0"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  printf(\"%.2f \", B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/finalomp/5"}
{"code": "for (int row = 0; row < height; row++)\n{\n  for (int col = 0; col < width; col++)\n  {\n    for (int color = 0; color < 3; color++)\n      result[(((3 * row) * width) + (col * 3)) + color] = sobel(original, col, row, color, width, height);\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule(guided, 5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DCRobledo/OpenMP-image-filter-system/img-par/image-par/2"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  for (int j = 0; j < 900; j++)\n  {\n    Y[i] = Y[i] + (A[i][j] * X[j]);\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/6"}
{"code": "for (int j = 0; j < 16; j++)\n{\n  ris = (l[j] & 127) || (L[j] & 127);\n  p[0][j] = (l[j] + carry) + L[j];\n  if ((ris == 1) && ((p[0][j] & 127) == 0))\n    carry = 1;\n  else\n    carry = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/5"}
{"code": "for (long i = G.in_row[v]; i < G.in_row[v + 1]; i++)\n{\n  R.I_src.push_back(G.in_col[i]);\n  R.I_dst.push_back(v);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RickyDevMJ/Decremental-SCC/decremental_cpu/2"}
{"code": "for (i = 1; i < 30000000; i += 2)\n  a[i] = (a[i] + a[i - 1]) / 2.0;\n\n", "pragma": "omp parallel for schedule(runtime) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mars2020/Parallel-OpenMP/part_2/hw1/rb/prb_a/0"}
{"code": "for (int i = 0; i < n_centroids; i++)\n{\n  if (new_centroids_n_points[i] != 0)\n  {\n    new_centroids[i].x = new_centroids[i].x / new_centroids_n_points[i];\n    new_centroids[i].y = new_centroids[i].y / new_centroids_n_points[i];\n    curr_error += calc_distance(centroids[i], new_centroids[i], dist_algo);\n    centroids[i].x = new_centroids[i].x;\n    centroids[i].y = new_centroids[i].y;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+: curr_error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Luca-Ferrera/k-means/app_mp/1"}
{"code": "for (j = 0; j < k; j++)\n  a[j + 128] = j + 128;\n\n", "pragma": "omp for schedule (nonmonotonic: runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/8"}
{"code": "for (int j = 0; j < COLUMNS; j++)\n  for (int i = 0; i < ROWS; i++)\n{\n  if (!(abs(matrix_1[i][j] - matrix_2[i][j]) < 0.001))\n  {\n    ((cout << setprecision(9)) << matrix_1[i][j]) << endl;\n    ((cout << setprecision(9)) << matrix_2[i][j]) << endl;\n    return false;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/8"}
{"code": "for (i = 0; i < 13; i++)\n  a[i] = 1.02 * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_9/openmp_petle_simple/0"}
{"code": "for (c2 = 0; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/31"}
{"code": "for (int k = 0; k < n; k++)\n{\n  q += z[k] * x[k];\n}\n\n", "pragma": "       #pragma omp parallel for reduction(+:q)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/7"}
{"code": "for (int i = 0; i < cloud_size; ++i)\n{\n  processedStorage[i] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(cloud_size, processedStorage)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload/euclidean_cluster/kernel/3"}
{"code": "for (i = 1; i < (quantidade - 1); i++)\n{\n  for (j = i; j < quantidade; j++)\n  {\n    for (k = j; k <= quantidade; k++)\n    {\n      a = i * i;\n      b = j * j;\n      c = k * k;\n      if ((a + b) == c)\n      {\n        contador++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private (i,j,k,a,b,c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvaldolimeirasantos/PGCC011-OpenMP/TriplaModularizacao/0"}
{"code": "for (int idx = 0; idx < ndim; ++idx)\n{\n  l->output_count *= l->output_shape[idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/pooling/pooling/2"}
{"code": "for (unsigned current = 0; current < set->natoms; current++)\n{\n  calc_t force[3] = {0.0, 0.0, 0.0};\n  for (unsigned other = current - 1; other < set->natoms; other--)\n  {\n    if (z_distance(set, current, other) > LENNARD_SQUARED_CUTOFF)\n      break;\n\n    calc_t sq_dist = squared_distance(set, current, other);\n    if (sq_dist < LENNARD_SQUARED_CUTOFF)\n    {\n      calc_t intensity = lennard_jones(sq_dist);\n      calc_t *posx = set->pos.x;\n      force[0] += intensity * (posx[current] - posx[other]);\n      force[1] += intensity * (posx[set->offset + current] - posx[set->offset + other]);\n      force[2] += intensity * (posx[(set->offset * 2) + current] - posx[(set->offset * 2) + other]);\n    }\n\n  }\n\n  for (unsigned other = current + 1; other < set->natoms; other++)\n  {\n    if (z_distance(set, current, other) > LENNARD_SQUARED_CUTOFF)\n      break;\n\n    calc_t sq_dist = squared_distance(set, current, other);\n    if (sq_dist < LENNARD_SQUARED_CUTOFF)\n    {\n      calc_t intensity = lennard_jones(sq_dist);\n      calc_t *posx = set->pos.x;\n      force[0] += intensity * (posx[current] - posx[other]);\n      force[1] += intensity * (posx[set->offset + current] - posx[set->offset + other]);\n      force[2] += intensity * (posx[(set->offset * 2) + current] - posx[(set->offset * 2) + other]);\n    }\n\n  }\n\n  set->speed.dx[current] += force[0];\n  set->speed.dx[set->offset + current] += force[1];\n  set->speed.dx[(set->offset * 2) + current] += force[2];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/z-openmp/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < m; j++)\n  {\n    b[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB031-truedepfirstdimension-orig-yes/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double PNDup = 0.0;\n  double PNDdo = 0.0;\n  double posXi = pos[i * 3];\n  double posYi = pos[(i * 3) + 1];\n  double posZi = pos[(i * 3) + 2];\n  double posMirrorXi = mirrorParticlePos[i * 3];\n  double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n  double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n  int ix;\n  int iy;\n  int iz;\n  bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n  int minZ = (iz - 1) * ((int) (dim - 2.0));\n  int maxZ = (iz + 1) * ((int) (dim - 2.0));\n  for (int jz = minZ; jz <= maxZ; jz++)\n  {\n    for (int jy = iy - 1; jy <= (iy + 1); jy++)\n    {\n      for (int jx = ix - 1; jx <= (ix + 1); jx++)\n      {\n        int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n        int j = firstParticleInBucket[jb];\n        if (j == (-1))\n          continue;\n\n        double plx;\n        double ply;\n        double plz;\n        getPeriodicLengths(jb, plx, ply, plz);\n        while (true)\n        {\n          double v0ij;\n          double v1ij;\n          double v2ij;\n          double v0imj;\n          double v1imj;\n          double v2imj;\n          double dstij2;\n          double dstimj2;\n          sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n          sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n          if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n          {\n            if (j != i)\n            {\n              double dst = sqrt(dstij2);\n              double wS = weight(dst, reS, weightType);\n              PNDup += pndi[j] * wS;\n              PNDdo += wS;\n            }\n\n          }\n\n          j = nextParticleInSameBucket[j];\n          if (j == (-1))\n            break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n  acc[i * 3] += PNDup;\n  acc[(i * 3) + 1] += PNDdo;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/45"}
{"code": "for (first = 0; first < N; first++)\n{\n  if ((first % 2) == 0)\n  {\n    for (i = 1; i < N; i += 2)\n    {\n      if (A[i - 1] > A[i])\n      {\n        temp = A[i - 1];\n        A[i - 1] = A[i];\n        A[i] = temp;\n      }\n\n    }\n\n  }\n  else\n  {\n    for (i = 1; i < (N - 1); i += 2)\n    {\n      if (A[i] > A[i + 1])\n      {\n        temp = A[i + 1];\n        A[i + 1] = A[i];\n        A[i] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none),shared(A,N,first),private(temp,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 14 & 15/bubble_omp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  input_file.read((char *) (&p.x), sizeof(double));\n  input_file.read((char *) (&p.y), sizeof(double));\n  input_file.read((char *) (&p.z), sizeof(double));\n  centroids->points.push_back(p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/12"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttx2 * speed[i - 1][j][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttx2 * speed[i + 1][j][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttx2 * speed[i - 1][j][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttx2 * speed[i + 1][j][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/58"}
{"code": "for (j = 0; j < nx1; j++)\n{\n  f[j] += f[j + (nxv * nyp)];\n  f[j + (nxv * nyp)] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpplib2/8"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  tau = 0;\n  for (int j = 0; j < columns; j++)\n  {\n    tau = tau + pow(matrix_U[i][j], 2);\n  }\n\n  tau = sqrt(tau);\n  for (int j = 0; j < columns; j++)\n  {\n    matrix_U[i][j] = matrix_U[i][j] / tau;\n    if (i == j)\n    {\n      S[i] = tau;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/7"}
{"code": "for (int jj = 1; jj < (params.nx - 1); ++jj)\n{\n  cells[(line * params.nx) + jj].speeds[7] = recvbuf[((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)];\n  cells[(line * params.nx) + jj].speeds[4] = recvbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 1];\n  cells[(line * params.nx) + jj].speeds[8] = recvbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/20"}
{"code": "for (int i = 3; (i * i) <= n; i += 2)\n{\n  int start = (((m + i) - 1) / i) * i;\n  if (start < (i * i))\n    start = i * i;\n\n  start += ((start % 2) == 0) ? (i) : (0);\n  for (int j = start; j <= n; j += 2 * i)\n    czyPierwsza[(j - m) / 2] = false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/9"}
{"code": "for (ix = 0; ix < nx; ix++)\n{\n  for (iy = 0; iy < ny; iy++)\n    fprintf(fp, \"%6.1f\\t\", *((u1 + (ix * ny)) + iy));\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iokasti/heatTransferSimulation-parallel/openmp/mpi_heat_openmp_functions/4"}
{"code": "for (i = 0; i < mat2_1d; i++)\n{\n  for (j = 0; j < mat2_2d; j++)\n  {\n    scanf(\"%lf\", &matr2[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/5"}
{"code": "for (size_t i = 0; i < aux.size(); ++i)\n{\n  aux[i] = TotalWeight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_processes/internal_variables_interpolation_process/9"}
{"code": "for (int ii = 0; ii < (num_test * 10); ii++)\n{\n  t0 = clock();\n  float minDist;\n  GetClosestVertex(mesh, uniformGrid, randomSamples[ii], mesh.bbox.Diag(), minDist);\n  avgTime += elapsed(t0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dfsp-spirit/cpp_geodesics/third_party/vcglib/apps/sample/trimesh_indexing/trimesh_indexing/5"}
{"code": "for (i = m - 1; i >= 0; i--)\n{\n  l = i + 1;\n  g = w[i];\n  if (i != (m - 1))\n    for (j = l; j < m; j++)\n    u[j][i] = 0.0;\n\n\n  if (g != 0.0)\n  {\n    if (i != (m - 1))\n    {\n      for (j = l; j < m; j++)\n      {\n        s = 0.0;\n        for (k = l; k < n; k++)\n          s += u[i][k] * u[j][k];\n\n        f = (s / u[i][i]) / g;\n        for (k = i; k < n; k++)\n          u[j][k] += f * u[i][k];\n\n      }\n\n    }\n\n    for (j = i; j < n; j++)\n      u[i][j] /= g;\n\n  }\n  else\n    for (j = i; j < n; j++)\n    u[i][j] = 0.0;\n\n\n  u[i][i] += 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/19"}
{"code": "for (i = 0; i < (strlen(string) - 1); i++)\n{\n  newstring[i] = string[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/5"}
{"code": "for (i = dim_n - 1; i >= 0; i--)\n{\n  for (p = 0; p < dim_n; p++)\n  {\n    result[(i * dim_n) + p] = B[(i * dim_n) + p] / A[(i * dim_n) + i];\n  }\n\n  for (j = i - 1; j >= 0; j--)\n  {\n    for (p = 0; p < dim_n; p++)\n    {\n      B[(j * dim_n) + p] -= A[(j * dim_n) + i] * result[(i * dim_n) + p];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZhixinLai/Parallel-Computing/Gaussian elimination with partial pivoting by OpenMP/gaussian/6"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/0"}
{"code": "for (int j = 0; j < (nprocs_mpi * Q); j++)\n{\n  TT[fila][col] = T[j];\n  if (col == (Q - 1))\n  {\n    fila += 1;\n    col = 0;\n  }\n  else\n  {\n    col += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/54"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    Z->setCell(i + 1, j + 1, X->matrix[i][j] + Y->matrix[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/2/Matrix/8"}
{"code": "for (i = 0; i < M.num_rows; i++)\n  if (fabs(M.elements[(M.num_rows * i) + i] - 1.0) > 1e-6)\n  return -1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg443/Gaussian-Elimination-OpenMP/gauss_eliminate/5"}
{"code": "for (uint32_t i = 0; i < vStages.size(); i++)\n  (cout << vStages[i].second) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/18"}
{"code": "for (i = 1; i <= n; i++)\n{\n  (h_file << \"  \") << h[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/heat-mpi/3"}
{"code": "for (j = 1; j <= log2(N); j++)\n{\n  if (n & (1 << (((int) log2(N)) - j)))\n    p |= 1 << (j - 1);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qixuxiang/simple-fft-openmp/fft_omp/5"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    (cout << V_t[i][j]) << \"  \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saiharshavellanki/Parallel-SVD/parallel_svd/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  b[i] = a[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/02for/0"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  if (node->children[i].has_particle)\n  {\n    node->c_x += node->children[i].total_mass * calculate_center_of_mass_x(&node->children[i]);\n    m_tot += node->children[i].total_mass;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/6"}
{"code": "for (k = 0; k < myp1; k++)\n{\n  kk = (ndim * nxe) * k;\n  for (i = 0; i < ndim; i++)\n  {\n    cu[i + kk] += cu[(i + (ndim * nx)) + kk];\n    cu[(i + (ndim * nx)) + kk] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/34"}
{"code": "for (i = 0; i <= 524286; i += 1)\n{\n  prv_buff1[i + 1] += prv_buff1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/11"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  for (int j = 1; j < (tasksize + 1); j++)\n  {\n    Crow[(i * tasksize) + j] += row_sum;\n  }\n\n  row_sum = Crow[(i + 1) * tasksize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/7"}
{"code": "for (unsigned int i = 0; i < nsubranks_1d; ++i)\n  assert(g.comm_per_row[i] != MPI_COMM_NULL);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/13"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_32 * SIMD_PARA_MD4)\n{\n  pbkdf2_md4((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_MDx_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-md4_fmt_plug/1"}
{"code": "for (int param = param1; param < param2; param++)\n{\n  gsl_odeiv2_system sys = {ode_func, 0, 1, &param};\n  gsl_odeiv2_driver *d = gsl_odeiv2_driver_alloc_y_new(&sys, gsl_odeiv2_step_rk8pd, 1e-6, 1e-6, 0.0);\n  int i;\n  double x = x_start;\n  double x1 = x_end;\n  double y[1] = {y_start};\n  for (i = 1; i <= count; i++)\n  {\n    double xi = (i * x1) / count;\n    int status = gsl_odeiv2_driver_apply(d, &x, xi, y);\n    if (status != GSL_SUCCESS)\n    {\n      printf(\"error, return value=%d\\n\", status);\n      break;\n    }\n\n  }\n\n  gsl_odeiv2_driver_free(d);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gzimin/masters-work/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a[i][j] = i * mul;\n    b[i][j] = i;\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnx4015/CompParaleDist/Code/OpenMP/multParalleli/1"}
{"code": "for (int n = 0; n < LEN; n++)\n{\n  random_value = ((((double) rand()) / 32767) * 10.0) - 1.0;\n  a[n] = random_value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ujjwalx/gpu-prog/OpenMP/main/3"}
{"code": "for (i = size; i < size_optimal; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    A_new[i][j] = 0;\n    B_new[i][j] = 0;\n    C_new[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aqfort/mipt_omp/extra/matrix/4"}
{"code": "for (i = 0; i < NUM_BUCKETS; i++)\n  for (k = myid + 1; k < num_procs; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/11"}
{"code": "for (int i = 0; i < N; i++)\n  maxError = fmax(maxError, fabs(y[i] - 3.0f));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stephanmg/cuda-playground/vecadd_cpu/2"}
{"code": "for (k = 0; k < size; k++)\n{\n  temp = A[k][k];\n  for (j = 0; j < size; j++)\n  {\n    A[k][j] /= temp;\n    I[k][j] /= temp;\n  }\n\n  for (i = 0; i < size; i++)\n  {\n    temp = A[i][k];\n    for (j = 0; j < size; j++)\n    {\n      if (i == k)\n        break;\n\n      A[i][j] -= A[k][j] * temp;\n      I[i][j] -= I[k][j] * temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/14"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  ff = qom[is] / fabs(qom[is]);\n  if ((vct->getXleft_neighbor() == MPI_PROC_NULL) && (bcEMfaceXleft == 2))\n  {\n    for (int j = 0; j < ny; j++)\n      for (int k = 0; k < nz; k++)\n    {\n      rhons[is][0][j][k] = rhons[is][4][j][k];\n      rhons[is][1][j][k] = rhons[is][4][j][k];\n      rhons[is][2][j][k] = rhons[is][4][j][k];\n      rhons[is][3][j][k] = rhons[is][4][j][k];\n    }\n\n\n  }\n\n  if ((vct->getXright_neighbor() == MPI_PROC_NULL) && (bcEMfaceXright == 2))\n  {\n    for (int j = 0; j < ny; j++)\n      for (int k = 0; k < nz; k++)\n    {\n      rhons[is][nx - 4][j][k] = rhons[is][nx - 5][j][k];\n      rhons[is][nx - 3][j][k] = rhons[is][nx - 5][j][k];\n      rhons[is][nx - 2][j][k] = rhons[is][nx - 5][j][k];\n      rhons[is][nx - 1][j][k] = rhons[is][nx - 5][j][k];\n    }\n\n\n  }\n\n  if ((vct->getYleft_neighbor() == MPI_PROC_NULL) && (bcEMfaceYleft == 2))\n  {\n    for (int i = 0; i < nx; i++)\n      for (int k = 0; k < nz; k++)\n    {\n      rhons[is][i][0][k] = rhons[is][i][4][k];\n      rhons[is][i][1][k] = rhons[is][i][4][k];\n      rhons[is][i][2][k] = rhons[is][i][4][k];\n      rhons[is][i][3][k] = rhons[is][i][4][k];\n    }\n\n\n  }\n\n  if ((vct->getYright_neighbor() == MPI_PROC_NULL) && (bcEMfaceYright == 2))\n  {\n    for (int i = 0; i < nx; i++)\n      for (int k = 0; k < nz; k++)\n    {\n      rhons[is][i][ny - 4][k] = rhons[is][i][ny - 5][k];\n      rhons[is][i][ny - 3][k] = rhons[is][i][ny - 5][k];\n      rhons[is][i][ny - 2][k] = rhons[is][i][ny - 5][k];\n      rhons[is][i][ny - 1][k] = rhons[is][i][ny - 5][k];\n    }\n\n\n  }\n\n  if ((vct->getZleft_neighbor() == MPI_PROC_NULL) && (bcEMfaceZleft == 2))\n  {\n    for (int i = 0; i < nx; i++)\n      for (int j = 0; j < ny; j++)\n    {\n      rhons[is][i][j][0] = rhons[is][i][j][4];\n      rhons[is][i][j][1] = rhons[is][i][j][4];\n      rhons[is][i][j][2] = rhons[is][i][j][4];\n      rhons[is][i][j][3] = rhons[is][i][j][4];\n    }\n\n\n  }\n\n  if ((vct->getZright_neighbor() == MPI_PROC_NULL) && (bcEMfaceZright == 2))\n  {\n    for (int i = 0; i < nx; i++)\n      for (int j = 0; j < ny; j++)\n    {\n      rhons[is][i][j][nz - 4] = rhons[is][i][j][nz - 5];\n      rhons[is][i][j][nz - 3] = rhons[is][i][j][nz - 5];\n      rhons[is][i][j][nz - 2] = rhons[is][i][j][nz - 5];\n      rhons[is][i][j][nz - 1] = rhons[is][i][j][nz - 5];\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/40"}
{"code": "for (i_imopVar15 = 1; i_imopVar15 < (grid_points[0] - 1); i_imopVar15++)\n{\n  for (j_imopVar16 = 1; j_imopVar16 < (grid_points[1] - 1); j_imopVar16++)\n  {\n    double *_imopVarPre424;\n    double *_imopVarPre425;\n    double (*_imopVarPre426)[5];\n    _imopVarPre424 = rhs[i_imopVar15][j_imopVar16][k_imopVar17];\n    _imopVarPre425 = rhs[i_imopVar15][j_imopVar16][k_imopVar17 - 1];\n    _imopVarPre426 = lhs[i_imopVar15][j_imopVar16][k_imopVar17][0];\n    matvec_sub(_imopVarPre426, _imopVarPre425, _imopVarPre424);\n    double (*_imopVarPre430)[5];\n    double (*_imopVarPre431)[5];\n    double (*_imopVarPre432)[5];\n    _imopVarPre430 = lhs[i_imopVar15][j_imopVar16][k_imopVar17][1];\n    _imopVarPre431 = lhs[i_imopVar15][j_imopVar16][k_imopVar17 - 1][2];\n    _imopVarPre432 = lhs[i_imopVar15][j_imopVar16][k_imopVar17][0];\n    matmul_sub(_imopVarPre432, _imopVarPre431, _imopVarPre430);\n    double *_imopVarPre436;\n    double (*_imopVarPre437)[5];\n    double (*_imopVarPre438)[5];\n    _imopVarPre436 = rhs[i_imopVar15][j_imopVar16][k_imopVar17];\n    _imopVarPre437 = lhs[i_imopVar15][j_imopVar16][k_imopVar17][2];\n    _imopVarPre438 = lhs[i_imopVar15][j_imopVar16][k_imopVar17][1];\n    binvcrhs(_imopVarPre438, _imopVarPre437, _imopVarPre436);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/11"}
{"code": "for (int gene = 0; gene < 500; gene++)\n{\n  eval = evaluation(POPULATION[gene]);\n  if (eval == 0)\n    return gene;\n\n  gene_score = 1.0 / eval;\n  sum_score += gene_score;\n  scores[gene] = gene_score;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.1/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  vector[i] = vector[i] * value;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paulpaulych/parallel_labs/Lab2/var1/4"}
{"code": "for (int i = n - index; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    a[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/cpu_parallel_convolution/3"}
{"code": "for (int i = 0; i < extrar; ++i)\n  prows[i] = splitr + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rdb987/2DConvolution/src/hpc_conv_hybrid/1"}
{"code": "for (int j = 0; j < input->d; ++j)\n  sup->delta_x[(i * input->d) + j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss64comp/6"}
{"code": "for (j = 0; j <= i; j++)\n{\n  cl[j + i] = cl[j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/6"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  y = _mm_mul_ps(x, y);\n  y = _mm_add_ps(_mm_add_ps(y, y), b);\n  x = _mm_add_ps(_mm_sub_ps(x2, y2), a);\n  x2 = _mm_mul_ps(x, x);\n  y2 = _mm_mul_ps(y, y);\n  m2 = _mm_add_ps(x2, y2);\n  co = _mm_or_ps(co, _mm_cmpgt_ps(m2, th));\n  ite = _mm_add_ps(ite, _mm_andnot_ps(co, one));\n  if (_mm_movemask_ps(co) == 0x0f)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sloox/OPENMPIMANDEL/mandle/7"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n  lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n  lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n  lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n  lhs[0][i][j][k + 1] = lhs[0][i][j][k + 1] + comz1;\n  lhs[1][i][j][k + 1] = lhs[1][i][j][k + 1] - comz4;\n  lhs[2][i][j][k + 1] = lhs[2][i][j][k + 1] + comz5;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,comz1 ,k ,comz4 ,comz6 ,comz5 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/78"}
{"code": "for (int i = 0; i < TOP_X; i++)\n  strncpy(parents[i].itinerary, trip[i].itinerary, CITIES + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stahtews/TravellingSalesman-GeneticAlgorithm-OpenMp/tsp/8"}
{"code": "for (int i = 6; 1 < i; i--)\n  z[i - 1] = crc32inv(z[i], msb(y[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimci86/bkcrack/src/password/0"}
{"code": "for (i = 1; i < NV; i++)\n{\n  connected[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/0"}
{"code": "for (myrow = 0; myrow < MINIGRIDSIZE; myrow++)\n  for (mycol = 0; mycol < MINIGRIDSIZE; mycol++)\n  if (grid[myrow + boxStartRow][mycol + boxStartCol] == num)\n{\n  alreadyinbox = 1;\n  myrow = MINIGRIDSIZE;\n  mycol = MINIGRIDSIZE;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/17"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]);\n  }\n\n}\n\n", "pragma": "omp for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/7"}
{"code": "for (int i = 0; i < kb_cache_pts.size(); i++)\n  if ((kb_cache_pts[i] == points) || ((time != NULL) && (kb_cache_pts[i] == time)))\n{\n  i1 = i;\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/42"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += x[i] * y[i];\n}\n\n", "pragma": "omp parallel for ordered reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/3"}
{"code": "for (int i = MAX_ROWS - 1; i >= 0; --i)\n{\n  for (int j = MAX_COLS - 1; j >= 0; --j)\n  {\n    int index = output[(iArray[i][j] / iExp) % 10] - 1;\n    _allData[index / MAX_COLS][index % MAX_COLS] = iArray[i][j];\n    output[(iArray[i][j] / iExp) % 10]--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/26"}
{"code": "for (indice_columnas = 0; indice_columnas < columnas_a; indice_columnas++)\n{\n  a[indice_filas][indice_columnas] = ((indice_filas + 1) * columnas_a) - (columnas_a - (indice_columnas + 1));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanecaradonna/openMP/Ejercicio6/ejercicio6/0"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  mor_s_v[0][i - 1] = idmo[ntemp1][jjface[face]][0][0][i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/16"}
{"code": "for (i = 0; i < (num_processos - 1); i++)\n  pivos[i] = ListaPossiveisPivos[(((i + 1) * num_processos) + (num_processos / 2)) - 1];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aulospl/TrabConcorrente/PRSR/1"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  fprintf(pfile, \"%d\\n\", A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB049-fprintf-orig-no/1"}
{"code": "for (; r < rows; r++)\n{\n  int c = 0;\n  for (; c < cols; c++)\n  {\n    mat[(r * cols) + c] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pnookala/MIC_OpenMP_GeMTC/src/Apps/MatrixMul/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    k = (i * cols) + j;\n    cN = c[k];\n    cS = c[(iS[i] * cols) + j];\n    cW = c[k];\n    cE = c[(i * cols) + jE[j]];\n    D = (((cN * dN[k]) + (cS * dS[k])) + (cW * dW[k])) + (cE * dE[k]);\n    J[k] = J[k] + ((0.25 * lambda) * D);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for shared(J, c, rows, cols, lambda) private(i, j, k, D, cS, cN, cW, cE)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_srad/srad_v2/srad/4"}
{"code": "for (i = 0; i < arraysize; i++)\n  printf(\"%f \\t\", array_A[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPforClause/3"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 0; k <= (grid_points[2] - 3); k++)\n      {\n        k1 = k + 1;\n        k2 = k + 2;\n        fac1 = 1. / lhs[n + 2][i][j][k];\n        lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n        lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n        rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n        lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n        lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n        lhs[n + 1][i][j][k2] = lhs[n + 1][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 3][i][j][k]);\n        lhs[n + 2][i][j][k2] = lhs[n + 2][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j][k2] = rhs[m][i][j][k2] - (lhs[n + 0][i][j][k2] * rhs[m][i][j][k]);\n      }\n\n    }\n\n  }\n\n  k = grid_points[2] - 2;\n  k1 = grid_points[2] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n      rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n      fac2 = 1. / lhs[n + 2][i][j][k1];\n      rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/34"}
{"code": "for (int i = 0; i < steps; i++)\n{\n  double loop_i = i / 1000;\n  answer += (4.0 / (1 + (loop_i * loop_i))) * (1.0 / steps);\n  ((((cout << \"For i: \") << i) << \" Answer: \") << answer) << endl;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaustubhcs/Integration-Using-OpenMP/main/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  i = 1;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][i]) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n  i = 2;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][i - 1]) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n}\n\n", "pragma": "omp parallel for private (i,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/13"}
{"code": "for (i = 0; i < r; ++i)\n{\n  for (j = 0; j < c; ++j)\n  {\n    fprintf(fptr, \"%f \", sum[i][j]);\n  }\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_2/6"}
{"code": "for (int i = 0; i < (image_height * image_width); i++)\n  write_color(cout, out_image[i], samples_per_pixel);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZwFink/ParRay/src/bvh/ray_tracing/0"}
{"code": "for (i = 0; i < (count - 1); i++)\n{\n  if ((i > 0) && (tmp[i] == tmp[i + 1]))\n    flag = 1;\n\n  if (flag == 0)\n  {\n    if (tmp[i] <= tmp[i + 1])\n    {\n      result++;\n      fprintf(logFile, \"chunk size from %d to %d not decreased.\\n\", i, i + 1);\n    }\n\n  }\n  else\n    if (tmp[i] != tmp[i + 1])\n  {\n    result++;\n    fprintf(logFile, \"chunk size not maintained.\\n\");\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_schedule_guided/2"}
{"code": "for (int i = 0; i < (k * n); i++)\n{\n  histograms[i] = (int *) malloc(hist_size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gulsumgudukbay/Parallel-P3-FaceRecognition/FaceDetection/src/lbp_omp/11"}
{"code": "for (int i = 0; i < num_digits; i++)\n{\n  intStr[i] = ((char) (rand() % ((ASCII_9 - ASCII_0) + 1))) + ASCII_0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/utils/0"}
{"code": "for (i = 1; i < n; i++)\n{\n  if (b[i] != (2 * i))\n  {\n    errors += 1;\n    if (errors == 1)\n      printf(\"for - VALUES IN B ARE NOT AS EXPECTED\\n\");\n\n    printf(\"EXPECTED B[%d] = %d OBSERVED %d\\n\", i, 2 * i, b[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny04/ocl_tiny04/tiny04/3"}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char K3[16];\n  unsigned char cleartext[36];\n  HMACMD5Context ctx;\n  memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n  hmac_md5_update((unsigned char *) cur_salt->checksum, 16, &ctx);\n  hmac_md5_final(K3, &ctx);\n  RC4_single(K3, 16, cur_salt->timestamp, 16, cleartext);\n  if ((cleartext[14] == '2') && (cleartext[15] == '0'))\n  {\n    RC4_single(K3, 16, cur_salt->timestamp, 36, cleartext);\n    if (cleartext[28] == 'Z')\n    {\n      memcpy(&ctx, &saved_ctx[i], sizeof(ctx));\n      hmac_md5_update(cleartext, 36, &ctx);\n      hmac_md5_final((unsigned char *) output[i], &ctx);\n    }\n\n  }\n  else\n  {\n    output[i][0] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/krb5pa-md5_fmt_plug/1"}
{"code": "for (int i = 0; i < 992; i++)\n  for (int j = 0; j < 992; j++)\n{\n  S[(i * 992) + j] = 0.0;\n  T[(i * 992) + j] = 1.0;\n  U[(i * 992) + j] = 2.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/6"}
{"code": "for (x = 0; x < nptsside; x++)\n{\n  for (y = 0; y < nptsside; y++)\n  {\n    xv = (x - side2) / side4;\n    yv = (y - side2) / side4;\n    z = xv + (yv * I);\n    if (inset(z))\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1B/mandelbrot/1"}
{"code": "for (j = edge_idx; j < (edge_idx + graph->vertices->out_degree[v]); j++)\n{\n  uint32_t u = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n  int u_parent = stats->parents[u];\n  if (u_parent < 0)\n  {\n    if (__sync_bool_compare_and_swap(&stats->parents[u], u_parent, v))\n    {\n      arguments->source = u;\n      stats->distances[u] = stats->distances[v] + 1;\n      parallelDepthFirstSearchGraphCSRTask(arguments, graph, stats);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/DFS/1"}
{"code": "for (size_t i = 0; i < vertexNum; i++)\n{\n  g[i].fixed_value += bias;\n  error += fabs(g[i].fixed_value - memory[i]);\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gbossi/Pagerank-DOBFS/fixed_pagerank/2"}
{"code": "for (size_t space_point = 1; space_point < (mesh->space_points - 1); ++space_point)\n{\n  const real_type space = lerp((real_type) space_point, 0.0, (real_type) (mesh->space_points - 1), 0.0, parameters->space_max);\n  const real_type temperature = parameters->initial_condition(space);\n  mesh_Set(mesh, 0, space_point, temperature);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/3"}
{"code": "for (int i = 0; i < rValues.size(); i++)\n  if ((aux > rValues[i]) && (rValues[i] != 0.0))\n  aux = rValues[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/FemToDemApplication/custom_processes/generate_dem_process/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum_pr_lock += a[i];\n}\n\n", "pragma": "#pragma omp for private(i) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/custom_reduction/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  S[i] = Norm(V, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/77"}
{"code": "for (j = 3; j < LX1; j++)\n{\n  for (i = 0; i < LX1; i++)\n  {\n    dxm1[j][i] = -dxm1[(LX1 - 1) - j][(LX1 - 1) - i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/11"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  R[i] = R[i] - (dtdx * (FR[i + 1] - FR[i]));\n  RU[i] = RU[i] - (dtdx * (FRU[i + 1] - FRU[i]));\n  RE[i] = RE[i] - (dtdx * (FRE[i + 1] - FRE[i]));\n}\n\n", "pragma": "#pragma omp for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      temp_mat[(i * n) + j] = 0;\n    }\n    else\n    {\n      value = 1 + (rand() % MAX);\n      if (value > density)\n      {\n        temp_mat[(i * n) + j] = INF;\n      }\n      else\n      {\n        temp_mat[(i * n) + j] = value;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/hybrid/1"}
{"code": "for (int i = 0; i < to_solve->n; i++)\n{\n  for (int j = 0; j < to_solve->n; j++)\n  {\n    fscanf(sudoku_file, \"%2u\", &num);\n    to_solve->grid[i][j] = num;\n    if (num == 0)\n    {\n      iter++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/bin/sudoku-omp_bfsv1/7"}
{"code": "for (i = 0; i < matrix->m; i++)\n{\n  for (j = 0; j < matrix->n; j++)\n  {\n    sum += m_get_val(matrix, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/leukocyte/OpenMP/track_ellipse.ref/4"}
{"code": "for (int i = 1; i < (M - 1); i++)\n{\n  current_iteration[N - 1][i] = current_iteration[1][i];\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmin-ionita/OpenMP-Game-Of-Life/g_omp/2"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"Thread #%d, calculating element #%d\\n\", omp_get_thread_num(), i);\n  result[i] = arr1[i] + arr2[i];\n}\n\n", "pragma": "omp parallel for shared(result)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task1/0"}
{"code": "for (i = 0; i < 32; i++)\n{\n  printf(\"%f\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwina/five-short-openmp/stencil/2"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    phi_jac[i][j][0] = 1.0;\n    phi_jac[i][j][nz - 1] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/10"}
{"code": "for (int i = 0; i < verticesNumber; ++i)\n{\n  if (fVisited[i] && bVisited[i])\n    return i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ualisars/ParallelDijkstra/ParrallelDijkstra/BirDirDijkstraOpenMP/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[4 * (i + (mxv * j))] = fxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (4 * (i + (mxv * j)))] = fxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[2 + (4 * (i + (mxv * j)))] = fxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[4 * (i + (mxv * j))] = bxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[1 + (4 * (i + (mxv * j)))] = bxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[2 + (4 * (i + (mxv * j)))] = bxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * mxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * mxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,ih,nh,x,y,vx,vy,vz,dxp,dyp, amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1, rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery, sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/3"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  for (j = 0; j < 2000; j++)\n    printf(\"%.3f\\t\", a[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamodi08jaya/Parallel-Computing/openMPmm/4"}
{"code": "for (int i = n - 1; i >= 0; i--)\n{\n  x[i] = A[i][n] / A[i][i];\n  for (int k = i - 1; k >= 0; k--)\n  {\n    A[k][n] -= A[k][i] * x[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/17"}
{"code": "for (int shift = 0; shift < Size; shift++)\n{\n  float sum = 0.;\n  for (int i = 0; i < Size; i++)\n  {\n    sum += A[i] * A[i + shift];\n  }\n\n  Sums[shift] = sum;\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(Size, A, Sums)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/christopherPMello/Parallel-Programming/Auto Correlation Using CUDA, SIMD, and OpenMP/mainOMP/1"}
{"code": "for (i = 0; i < 32; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 256; j++)\n    for (k = 0; k < 256; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoyMitra/android-parallel-benchmarks/openmp/parallel-prefix/app/src/main/cpp/matrix-mult/2"}
{"code": "for (int i = 0; i <= m; i++)\n{\n  dp[i][0] = i * pgap;\n}\n\n", "pragma": "        #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing12/test/3"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,k ,m ,dt ,nz ,jst ,jend ,i ,istep )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/97"}
{"code": "for (int k = y_min - 2; k <= (y_max + 3); k++)\n{\n  vertexdy[FTNREF1D(k, y_min - 2)] = d_y;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/3"}
{"code": "for (j = 0; j < nnz; j++)\n{\n  int pre_val = j * order;\n  int pre_val2 = j * rrank;\n  int k;\n  int l;\n  int ii;\n  int *cach1 = (int *) malloc((sizeof(int)) * order);\n  for (l = 0; l < order; l++)\n    cach1[l] = X.index[pre_val + l];\n\n  for (l = 0; l < rrank; l++)\n    Delta[pre_val2 + l] = 0;\n\n  for (l = 0; l < CoreT.nonzeros; l++)\n  {\n    int pre1 = l * order;\n    int pre2 = 0;\n    int CorePos = CoreT.index[pre1 + i];\n    double res = CoreT.value[l];\n    for (ii = 0; ii < order; ii++)\n    {\n      if (ii != i)\n      {\n        int mulrow = cach1[ii];\n        int mulcol = CoreT.index[pre1];\n        res *= X.FactorM[(pre2 + (mulrow * rrank)) + mulcol];\n      }\n\n      pre1++;\n      pre2 += mult;\n    }\n\n    Delta[pre_val2 + CorePos] += res;\n  }\n\n  free(cach1);\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/18"}
{"code": "for (i = 0; i <= 10; i++)\n{\n  tid = omp_get_thread_num();\n  printf(\"Hi, this is thread %d with incr %d! \\n\", tid, incr);\n  x = tid;\n}\n\n", "pragma": "\t#pragma omp parallel for lastprivate(x) private(tid) shared(incr)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wibeck/c-edu/Test2/src/Test2/1"}
{"code": "for (int i = 0; i < generation_size; i++)\n  population[i] = random_individual(g, K);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jpaton/graph-ga/Engines/basic/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(fptr, \"%d\", &arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/1"}
{"code": "for (int i = 1; i < g->N; i++)\n  actual_weight += g->adj_mat[i][parent[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/13"}
{"code": "for (k1 = 0; k1 < N1; k1++)\n{\n  free(columns[k1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulises-jeremias/fft-parallel/fft/src/openmp/fft/7"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  triple vectorc = {a[i].c.x, a[i].c.y, a[i].c.z};\n  triple d;\n  diff(&d, e, vectorc);\n  double a1 = 1.0;\n  double b = 2 * dotp(d, r);\n  double c = ((pow(d.x, 2) + pow(d.y, 2)) + pow(d.z, 2)) - pow(a[i].r, 2);\n  double discriminant = pow(b, 2) - ((4 * a1) * c);\n  if (discriminant < 0)\n    continue;\n  else\n  {\n    double T = ((((-1) * b) - sqrt(discriminant)) / 2) * a1;\n    if (T < 0)\n      T = INFINITY;\n\n    if (T < minT)\n    {\n      minT = T;\n      minIndex = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kazuyachue/Parallel_Computing/RayTracer/movie/1"}
{"code": "for (int i = 1; i < (N - 1); i++)\n{\n  b[i] = ((a[i - 1] + a[i]) + a[i + 1]) / 3.0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 200) num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/greenmapc/OpenMP-MPI/OpenMP/Task8/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  old2NewMap[Rprime[i]] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReordering/4"}
{"code": "for (int i = 0; i < P; i++)\n{\n  temp_sigma[(i * N) + i] = (*SIGMA)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/10"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (j = 0; j < 26; j++)\n  {\n    ncl[j + (26 * l)] = 0;\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      z = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      nn = x;\n      mm = y;\n      ll = z;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      dzp = z - ((float) ll);\n      n[j] = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      dx1 = dxp * dyp;\n      dyp = amx * dyp;\n      amx = amx * amy;\n      amz = 1.0f - dzp;\n      amy = dxp * amy;\n      s[j] = amx * amz;\n      s[j + 32] = amy * amz;\n      s[j + (2 * 32)] = dyp * amz;\n      s[j + (3 * 32)] = dx1 * amz;\n      s[j + (4 * 32)] = amx * dzp;\n      s[j + (5 * 32)] = amy * dzp;\n      s[j + (6 * 32)] = dyp * dzp;\n      s[j + (7 * 32)] = dx1 * dzp;\n      t[j] = x;\n      t[j + 32] = y;\n      t[j + (2 * 32)] = z;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      #pragma ivdep\n      for (i = 0; i < 8; i++)\n      {\n        dx += sfxyz[n[j] + mn[i]] * s[j + (32 * i)];\n        dy += sfxyz[(1 + n[j]) + mn[i]] * s[j + (32 * i)];\n        dz += sfxyz[(2 + n[j]) + mn[i]] * s[j + (32 * i)];\n        ox += sbxyz[n[j] + mn[i]] * s[j + (32 * i)];\n        oy += sbxyz[(1 + n[j]) + mn[i]] * s[j + (32 * i)];\n        oz += sbxyz[(2 + n[j]) + mn[i]] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n      s[j + (2 * 32)] = dz;\n      s[j + (3 * 32)] = ox;\n      s[j + (4 * 32)] = oy;\n      s[j + (5 * 32)] = oz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      z = t[j + (2 * 32)];\n      dx = qtmh * s[j];\n      ;\n      dy = qtmh * s[j + 32];\n      dz = qtmh * s[j + (2 * 32)];\n      acx = ppart[((j + joff) + (3 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (4 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (5 * nppmx)) + npoff] + dz;\n      p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n      gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n      qtmg = qtmh * gami;\n      sum1 += (gami * p2) / (1.0f + gami);\n      omxt = qtmg * s[j + (3 * 32)];\n      omyt = qtmg * s[j + (4 * 32)];\n      omzt = qtmg * s[j + (5 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n      dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n      s[j] = x + (vx * dtg);\n      s[j + 32] = y + (vy * dtg);\n      s[j + (2 * 32)] = z + (vz * dtg);\n      s[j + (3 * 32)] = vx;\n      s[j + (4 * 32)] = vy;\n      s[j + (5 * 32)] = vz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      dz = s[j + (2 * 32)];\n      mm = 0;\n      if (dx >= edgerx)\n      {\n        if (dx >= anx)\n          dx = dx - anx;\n\n        mm = 2;\n      }\n      else\n        if (dx < edgelx)\n      {\n        if (dx < 0.0f)\n        {\n          dx += anx;\n          if (dx < anx)\n            mm = 1;\n          else\n            dx = 0.0f;\n\n        }\n        else\n        {\n          mm = 1;\n        }\n\n      }\n\n\n      if (dy >= edgery)\n      {\n        if (dy >= any)\n          dy = dy - any;\n\n        mm += 6;\n      }\n      else\n        if (dy < edgely)\n      {\n        if (dy < 0.0f)\n        {\n          dy += any;\n          if (dy < any)\n            mm += 3;\n          else\n            dy = 0.0f;\n\n        }\n        else\n        {\n          mm += 3;\n        }\n\n      }\n\n\n      if (dz >= edgerz)\n      {\n        if (dz >= anz)\n          dz = dz - anz;\n\n        mm += 18;\n      }\n      else\n        if (dz < edgelz)\n      {\n        if (dz < 0.0f)\n        {\n          dz += anz;\n          if (dz < anz)\n            mm += 9;\n          else\n            dz = 0.0f;\n\n        }\n        else\n        {\n          mm += 9;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = dz;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = s[j + (3 * 32)];\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = s[j + (4 * 32)];\n      ppart[((j + joff) + (5 * nppmx)) + npoff] = s[j + (5 * 32)];\n      n[j] = mm;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      mm = n[j];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + joff) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,ipp,joff,nps,nn,mm,ll,nm,ih, nh,x,y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy, acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8, rot9,p2,gami,qtmg,dtg,edgelx,edgely,edgelz,edgerx,edgery,edgerz,sum1, sfxyz,sbxyz,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/13"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  column[i] = 0;\n}\n\n", "pragma": "omp parallel for default(none) shared(column) private(size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artme-uni/OpenMP/OpenMP_2/matrix/column/0"}
{"code": "for (int i = 1; i < n; i++)\n{\n  double id = b[i] - (c[i - 1] * a[i]);\n  c[i] /= id;\n  d[i] = (d[i] - (d[i - 1] * a[i])) / id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  b[i] = RandomDouble(1, 10);\n}\n\n", "pragma": "    #pragma parallel omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/6_openmp/0"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    for (k = 0; k < z; k++)\n    {\n      rho_visc[i][j][k] = rho[i][j][k];\n      vx_visc[i][j][k] = vx[i][j][k];\n      vy_visc[i][j][k] = vy[i][j][k];\n      vz_visc[i][j][k] = vz[i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/copy_arrays_for_viscosity/1"}
{"code": "for (int i = 1; i <= N; i++)\n  s += f(x1 + (i * dx));\n\n", "pragma": "\t#pragma omp parallel for num_threads(nThreads) reduction(+: s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilmysliwiec/parallel-numerical-integration/main/0"}
{"code": "for (unsigned int i = 0; i < eventList.size(); i++)\n{\n  sort(eventList[i].begin(), eventList[i].end());\n  float successProbForThisRoll = 0.0;\n  for (unsigned int j = 0; j < eventList[i].size(); j++)\n  {\n    successProbForThisRoll = successProbForThisRoll + probs[(eventList[i][j] - 1) - (ndicePerRoll - 1)];\n  }\n\n  eventListProbs.push_back(successProbForThisRoll);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/Proj/ompdice/2"}
{"code": "for (int i = (M / 4) * 4; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double C_ij = C[i + (j * lda)];\n    for (int k = 0; k < K; k++)\n    {\n      C_ij += A[((((i / 8) * 8) * lda) + (k * 8)) + (i % 8)] * B[k + (j * lda)];\n    }\n\n    C[i + (j * lda)] = C_ij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-bad/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++a;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/5"}
{"code": "for (int i = 0; i < numIndividuals; i++)\n{\n  data.push_back(indexes[i]);\n  mpi_serialize_ind_from_worker(&inds[i], data);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/11"}
{"code": "for (int i = 0; i < 4000000; i++)\n{\n  vmax = vmaxq_f32(max, data[i]);\n}\n\n", "pragma": "omp parallel for reduction(max: vmax)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/min_max_reduction/2"}
{"code": "for (iouter = 0; iouter < n; iouter++)\n{\n  nzv = NONZER;\n  sprnvc(n, nzv, nn1, vc, ivc);\n  vecset(n, vc, ivc, &nzv, iouter + 1, 0.5);\n  arow[iouter] = nzv;\n  for (ivelt = 0; ivelt < nzv; ivelt++)\n  {\n    acol[iouter][ivelt] = ivc[ivelt] - 1;\n    aelt[iouter][ivelt] = vc[ivelt];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/16"}
{"code": "for (pk = 0; pk < MAX_TEST; pk++)\n{\n  i = rand() % ni;\n  j = rand() % nj;\n  pom = 0.0;\n  for (k = 0; k < nk; k++)\n  {\n    pom += mA[(i * nk) + k] * mB[(k * nj) + j];\n  }\n\n  pom = (a * pom) + (b * mC2[(i * nj) + j]);\n  k1 = mC[(i * nj) + j];\n  if (fabs(pom - k1) > 0.2)\n  {\n    err++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/holoubekm/BI-EIA/task_1/assignment/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < p; k++)\n    {\n      result[i][j] += first[i][k] * second[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(3) schedule(dynamic, p)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/1"}
{"code": "for (j = 0; j < (n / 2); j++)\n{\n  b[j] = a[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/c_veccopy_lto/veccpy1/0"}
{"code": "for (i = 0; i < row_each; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    res_vector[i] += vector[j] * local_arr[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/matrix-dot-product/hybridparallel/1"}
{"code": "for (i = 0; i < (HIgh_h / 2); i++)\n{\n  for (j = (Low_w / 4) * 3; j < (Low_w - 2); j++)\n  {\n    bicubic_Y[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Y[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/12"}
{"code": "for (i = -4; i <= 4; i++)\n  for (j = -4; j <= 4; j++)\n{\n  if (((i * i) + (j * j)) <= 16)\n    apt[nangle0++] = cvPoint(j, i);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvsurf/5"}
{"code": "for (i = 0; i < omp_num_devices; i++)\n{\n  omp_device_t *dev = &omp_devices[i];\n  if (i < num_hostcpu_dev)\n  {\n    omp_init_hostcpu_device(dev, i, host_dev_sysid, 1);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), host_dev_sysid);\n    host_dev_sysid++;\n  }\n  else\n    if (i < (num_thsim_dev + num_hostcpu_dev))\n  {\n    omp_init_thsim_device(dev, i, thsim_dev_sysid, 1);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), thsim_dev_sysid);\n    thsim_dev_sysid++;\n  }\n  else\n    if (i < ((num_nvgpu_dev + num_hostcpu_dev) + num_thsim_dev))\n  {\n    for (; nvgpu_dev_sysid < total_nvgpu; nvgpu_dev_sysid++)\n    {\n      if (nvgpu_selection[nvgpu_dev_sysid])\n      {\n        break;\n      }\n\n    }\n\n    omp_init_nvgpu_device(dev, i, nvgpu_dev_sysid);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), nvgpu_dev_sysid);\n    nvgpu_dev_sysid++;\n  }\n  else\n  {\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/5"}
{"code": "for (int i = st; i < end; i++)\n  arr[i - st] = s->b_U[idx(i, j, k)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/170"}
{"code": "for (int i = 0; i < nt; i++)\n{\n  for (int j = 0; j < nt; j++)\n  {\n    Ah[i][j] = malloc((ts * ts) * (sizeof(double)));\n    assert(Ah[i][j] != 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/11"}
{"code": "for (i = 0; i < num_elements; i++)\n{\n  this_histogram[my_number][input_data[i]]++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mklobukov/Parallel-Programming/Parallelized Programs/GaussianOpenMP/Assignment2_Mark_Klobukov/histogram/1"}
{"code": "for (long i = 0; i < vecsize; ++i)\n{\n  rsp[i] = func(srcp1[i], srcp2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hfxunlp/pamath/double_math_core/1"}
{"code": "for (i = 0; i < NUM_BUCKETS; i++)\n  work_buff[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/6"}
{"code": "for (ii = id * size; ii < ((id + 1) * size); ii++)\n{\n  fflush(stdout);\n  for (jj = 0; jj < tlines2; jj++)\n  {\n    seq_a = h_a[ii].wsentence;\n    seq_b = h_b[jj].wsentence;\n    mu = 1;\n    delta = 1;\n    N_a = seq_a.length();\n    N_b = seq_b.length();\n    double H[N_a + 1][N_b + 1];\n    double H_max;\n    double M[N_a + 1][N_b + 1];\n    char consensus_a[(N_a + N_b) + 2];\n    char consensus_b[(N_a + N_b) + 2];\n    int I_i[N_a + 1][N_b + 1];\n    int I_j[N_a + 1][N_b + 1];\n    for (i = 0; i <= N_a; i++)\n    {\n      for (j = 0; j <= N_b; j++)\n      {\n        H[i][j] = 0.;\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        temp[0] = H[i - 1][j - 1] + similarity_score(seq_a[i - 1], seq_b[j - 1]);\n        temp[1] = H[i - 1][j] - delta;\n        temp[2] = H[i][j - 1] - delta;\n        temp[3] = 0.;\n        H[i][j] = find_array_max(temp, 4);\n        switch (ind)\n        {\n          case 0:\n            I_i[i][j] = i - 1;\n            I_j[i][j] = j - 1;\n            break;\n\n          case 1:\n            I_i[i][j] = i - 1;\n            I_j[i][j] = j;\n            break;\n\n          case 2:\n            I_i[i][j] = i;\n            I_j[i][j] = j - 1;\n            break;\n\n          case 3:\n            I_i[i][j] = i;\n            I_j[i][j] = j;\n            break;\n\n        }\n\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        if (H[i][j] == 0)\n          M[i][j] = 0;\n        else\n          if (seq_a[i - 1] == seq_b[j - 1])\n          M[i][j] = H[i - 1][j - 1];\n        else\n          M[i][j] = MAX(MAX(MAX(MAX(MAX(M[i - 1][j], H[i - 1][j]), M[i][j - 1]), H[i][j - 1]), M[i - 1][j - 1]), H[i - 1][j - 1]);\n\n\n      }\n\n    }\n\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        H[i][j] = M[i][j];\n      }\n\n    }\n\n    H_max = 0.;\n    i_max = 0;\n    j_max = 0;\n    for (i = 1; i <= N_a; i++)\n    {\n      for (j = 1; j <= N_b; j++)\n      {\n        if (H[i][j] > H_max)\n        {\n          H_max = H[i][j];\n          i_max = i;\n          j_max = j;\n        }\n\n      }\n\n    }\n\n    current_i = i_max;\n    current_j = j_max;\n    next_i = I_i[current_i][current_j];\n    next_j = I_j[current_i][current_j];\n    tick = 0;\n    zzz = 0;\n    while ((((current_i != next_i) || (current_j != next_j)) && (next_j != 0)) && (next_i != 0))\n    {\n      if (next_i == current_i)\n      {\n        consensus_a[tick] = '-';\n        zzz -= mu;\n      }\n      else\n      {\n        consensus_a[tick] = seq_a[current_i - 1];\n        zzz += similarity_score(seq_a[current_i - 1], seq_b[current_j - 1]);\n      }\n\n      if (next_j == current_j)\n      {\n        consensus_b[tick] = '-';\n        zzz -= mu;\n      }\n      else\n      {\n        consensus_b[tick] = seq_b[current_j - 1];\n        zzz += similarity_score(seq_a[current_i - 1], seq_b[current_j - 1]);\n      }\n\n      current_i = next_i;\n      current_j = next_j;\n      next_i = I_i[current_i][current_j];\n      next_j = I_j[current_i][current_j];\n      tick++;\n    }\n\n    float similarity = (float) (zzz / MAX(N_a, N_b));\n    if (similarity > THRESHOLD)\n    {\n      ((((cout << \"\\n!!!Similarity between \") << ii) << \" of source and \") << jj) << \" of destination!!!!!\\n\";\n      sim += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/parplag/0"}
{"code": "for (int i = 0; i < 30; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUSTechBruce/Multithread-merge_sort/merge_sort/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (long j = 0; j < n; j++)\n  {\n    ResM[i][j] = M1[i][j] - M2[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/strassen_mul_2d_omp/2"}
{"code": "for (int i = 0; i < size; i++)\n  array[i] = (-1) + ((2 * ((double) rand())) / ((double) 32767));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn04/6"}
{"code": "for (i = 0; i < spreps; i++)\n{\n  D.zeros();\n  assignew = Assign(data_proc, D, P, n, cov_num, strt_num, level_num, omega, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  sp(i) = ((-sum(data_proc.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data_proc.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/13"}
{"code": "for (k = 0; k < diag_length; k++)\n{\n  for (ii = (i + (k * TILE)) + 1; (ii <= m) && (ii < (((i + (k * TILE)) + 1) + TILE)); ii++)\n  {\n    for (jj = (j - (k * TILE)) + 1; (jj <= n) && (jj < (((j - (k * TILE)) + 1) + TILE)); jj++)\n    {\n      if (x[ii - 1] == y[jj - 1])\n      {\n        dp[ii][jj] = dp[ii - 1][jj - 1];\n        continue;\n      }\n      else\n      {\n        first = ((dp[ii - 1][jj - 1] + pxy) <= (dp[ii - 1][jj] + pgap)) ? (dp[ii - 1][jj - 1] + pxy) : (dp[ii - 1][jj] + pgap);\n        dp[ii][jj] = ((dp[ii][jj - 1] + pgap) <= first) ? (dp[ii][jj - 1] + pgap) : (first);\n        continue;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(diag_length) schedule(dynamic) shared (x, y, dp, pxy, pgap, m, n) private(ii, jj, k, first)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalignomp/3"}
{"code": "for (int i = 0; i < 10000; i++)\n  for (int j = 0; j < 10000; j++)\n  T[i][j] *= coeff;\n\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/TSP/ants_parallel/0"}
{"code": "for (i = 0; i < count; i++)\n{\n  int len;\n  len = E_md4hash((uchar *) saved_plain[i], saved_len[i], saved_key[i]);\n  if (len <= 0)\n    saved_plain[i][-len] = 0;\n\n  setup_des_key(saved_key[i], i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/MSCHAPv2_bs_fmt_plug/11"}
{"code": "for (int f = 0; f < Frows; f++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    K(F(f, j), 0) -= A(f, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC203-Computacion_Grafica/Trabajo_2_Fast-Winding-Numbers/fast-winding-number-soups/libigl/include/igl/gaussian_curvature/0"}
{"code": "for (j = 1; j < (4096 + 1); j++)\n{\n  stddev[j] = 0.0;\n  int i;\n  for (i = 1; i < (4096 + 1); i++)\n  {\n    stddev[j] += (data[(i * (4096 + 1)) + j] - mean[j]) * (data[(i * (4096 + 1)) + j] - mean[j]);\n  }\n\n  stddev[j] /= 3214212.01f;\n  stddev[j] = sqrt(stddev[j]);\n  if (stddev[j] <= 0.005f)\n  {\n    stddev[j] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/correlation/1"}
{"code": "for (long i = 0; i < size; i++)\n{\n  for (long j = 0; j < size; j++)\n  {\n    for (long k = 0; k < size; k++)\n    {\n      result_matrix[i][j] += first_matrix[i][k] + second_matrix[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) collapse(3) shared(first_matrix,second_matrix,result_matrix,size) schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Multiplication_Serial_Parallel/0"}
{"code": "for (k = 0; k < n; k++)\n{\n  t = omp_get_thread_num();\n  did_something = 0;\n  do\n  {\n    temp = 0;\n    omp_set_lock(&mtx);\n    temp = flags[k];\n    omp_unset_lock(&mtx);\n    if (temp == 1)\n    {\n      printf(\"\\nThread %d folosit..   k= %d .. divizare\\n\", t, k);\n      for (j = k + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] / A[k][k];\n        s_l[j] = A[k][j];\n      }\n\n      s_l[k] = 1;\n      y[k] = b[k] / A[k][k];\n      A[k][k] = 1;\n      s_v_r = y[k];\n      s_index = k;\n      omp_set_lock(&mtx);\n      flags[k] = 2;\n      for (j = k + 1; j < n; j++)\n        flags[j] = 3;\n\n      flags[k + 1] = 4;\n      omp_unset_lock(&mtx);\n      ShowMatrixCol_int(flags, n);\n      did_something = 1;\n    }\n\n    if (temp == 3)\n    {\n      printf(\"\\nThread %d folosit..   k = %d .. eliminare cu linia %d\\n\", t, k, s_index);\n      for (j = s_index + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] - (A[k][s_index] * s_l[j]);\n      }\n\n      b[k] = b[k] - (A[k][s_index] * s_v_r);\n      A[k][s_index] = 0;\n      omp_set_lock(&mtx);\n      flags[k] = 0;\n      omp_unset_lock(&mtx);\n      ShowMatrixCol_int(flags, n);\n      did_something = 1;\n    }\n\n    if (temp == 4)\n    {\n      printf(\"\\nThread %d folosit..   k = %d .. eliminare cu linia %d\\n\", t, k, s_index);\n      ShowMatrixCol_int(flags, n);\n      for (j = s_index + 1; j < n; j++)\n      {\n        A[k][j] = A[k][j] - (A[k][s_index] * s_l[j]);\n      }\n\n      b[k] = b[k] - (A[k][s_index] * s_v_r);\n      A[k][s_index] = 0;\n      omp_set_lock(&mtx);\n      flags[k] = 1;\n      omp_unset_lock(&mtx);\n      did_something = 1;\n    }\n\n    if (temp == 2)\n      did_something = 1;\n\n  }\n  while (!did_something);\n}\n\n", "pragma": "omp parallel for schedule(static,1) shared(A,b,y,n,s_l, flags,s_v_r , s_index) private(j,t,did_something,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/leahu_orig/0"}
{"code": "for (int i = 0; i < x_shape; i++)\n  x[i] = 0.01f + ((i * (31.4f - 0.01f)) / x_shape);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lombscargle-omp/main/1"}
{"code": "for (i = 0; i < 100; i++)\n  is = is + i;\n\n", "pragma": "omp parallel for private(is)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lastprivate0/0"}
{"code": "for (int z = 0; z < count; z++)\n{\n  int i0 = ((min(num_tile_in_width, line) - z) - 1) * tile_width;\n  int j0 = (start_col + z) * tile_length;\n  int tile_i_start = i0 + 1;\n  int tile_j_start = j0 + 1;\n  for (int i = tile_i_start, i_minus_1 = i0; i < min(tile_i_start + tile_width, row); i++, i_minus_1++)\n  {\n    for (int j = tile_j_start, j_minus_1 = j0; j < min(tile_j_start + tile_length, col); j++, j_minus_1++)\n    {\n      if (x[i_minus_1] == y[j_minus_1])\n      {\n        dp[i][j] = dp[i_minus_1][j_minus_1];\n      }\n      else\n      {\n        dp[i][j] = min3(dp[i_minus_1][j_minus_1] + pxy, dp[i_minus_1][j] + pgap, dp[i][j_minus_1] + pgap);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel13/0"}
{"code": "for (long i = 0; i < NVer; i++)\n{\n  long tc = (long) vtxColor[i];\n  long Where = colorPtr[tc] + __sync_fetch_and_add(&colorAdded[tc], 1);\n  colorIndex[Where] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/equitableColoringDistanceOne/6"}
{"code": "for (i = 0; i < active_size; i++)\n  if (be_shrunk(i, Gmax1, Gmax2, Gmax3, Gmax4))\n{\n  active_size--;\n  while (active_size > i)\n  {\n    if (!be_shrunk(active_size, Gmax1, Gmax2, Gmax3, Gmax4))\n    {\n      swap_index(i, active_size);\n      break;\n    }\n\n    active_size--;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/22"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) p_rheo_new[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/117"}
{"code": "for (int i = 0; i < 100; i++)\n  for (int j = 0; j < (784 + 1); j++)\n  WL1[i][j] = (rand() / ((double) 32767)) - 0.5;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/NN/fashion-NN/8"}
{"code": "for (j = 1; j <= wf.n2; j++)\n{\n  (vector < complex) > v_1D(wf.n1 + 2), wf_1D(wf.n1 + 2);\n  for (int i = 0; i < (wf.n1 + 2); i++)\n  {\n    const int index = wf.in2(j, i);\n    if (gauge == lengthgauge)\n      v_1D[i] = vt[i] + p.ABV_V[index];\n\n    wf_1D[i] = wf.wave[index];\n  }\n\n  (vector < complex) > Ml_mid(wf.n1 + 2), wf_1D_rightside(wf.n1 + 2);\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    if (gauge == lengthgauge)\n    {\n      Ml_upp = c1 + (d2 * v_1D[i + 1]);\n      Ml_mid[i] = c4 + (d1 * v_1D[i]);\n      Ml_low = c1 + (d2 * v_1D[i - 1]);\n      Mr_upp = c2 - (d2 * v_1D[i + 1]);\n      Mr_mid = c3 - (d1 * v_1D[i]);\n      Mr_low = c2 - (d2 * v_1D[i - 1]);\n    }\n    else\n      if (gauge == velocitygauge)\n    {\n    }\n\n\n    wf_1D_rightside[i] = ((Mr_low * wf_1D[i - 1]) + (Mr_mid * wf_1D[i])) + (Mr_upp * wf_1D[i + 1]);\n  }\n\n  (vector < complex) > wf_1D_solution(wf.n1 + 2), gam(wf.n1 + 2);\n  Tridag_Fast(Ml_low, Ml_mid, Ml_upp, wf_1D_rightside, wf_1D_solution, gam);\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    wf.wave[wf.in2(j, i)] = wf_1D_solution[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp for private(j, Mr_upp, Mr_low, Mr_mid, Ml_upp, Ml_low)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/8"}
{"code": "for (j = 0; j < iterT; j++)\n{\n  for (i = 0; i < iter; i++)\n  {\n    (((((((outdata << inum[i]) << \" \") << (j + 1)) << \" \") << serial[i][j]) << \" \") << parallel[i][j]) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JamesdeLisle/OpenMP-messing/test2/2"}
{"code": "for (int i = 0; i < nprocs; ++i)\n{\n  displs[i] = cpt;\n  const int x = (rst > i) ? ((qte + 1) * n) : (qte * n);\n  count[i] = x;\n  cpt += x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ladislus/m2_php_mpi-project/rma_omp/0"}
{"code": "for (int j = 0; j < num_of_elements; j++)\n{\n  if (y[j] > max)\n    max = y[j];\n\n  maxlocation = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/parallel_with_critical/0"}
{"code": "for (int i = 0; i < no_of_features; ++i)\n  old_weights[i] = get_random();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/logistic/3"}
{"code": "for (int i = 0; i < M; i++)\n  for (int j = 0; j < M; j++)\n  for (int k = 0; k < M; k++)\n{\n  V[(((i * M) * M) + (j * M)) + k] = 2.0;\n  Z[(((i * M) * M) + (j * M)) + k] = 3.0;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/8"}
{"code": "for (i = 0; i < part_no; i++)\n{\n  x += (par[i].pos.x * par[i].m) / totalM;\n  y += (par[i].pos.y * par[i].m) / totalM;\n}\n\n", "pragma": "omp for private (i, x_aux, y_aux) reduction (+:x,y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/grid/0"}
{"code": "for (i = 3; i < (N_x + 3); i++)\n{\n  for (j = 3; j < (N_y + 3); j++)\n  {\n    h[i][j] = 1.0 + (0.5 * exp((-(1.0 / 25.0)) * (pow((x_min + (i * Delta_x)) - 30.0, 2) + pow((x_min + (j * Delta_y)) - 30.0, 2))));\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anubhav-cs/Numerical-Methods/Shallow Water Flow/shallow_water_openmp/0"}
{"code": "for (ix = start; ix < (start + len); ix++)\n{\n  for (iy = 0; iy < m; iy++)\n  {\n    int radius = drand48() * maxwin;\n    if (radius < 1)\n      continue;\n\n    int count = (4 * radius) + 1;\n    long offset = (((ix + radius) * u_dimY) + radius) + iy;\n    REAL *temp_u = &u[offset];\n    REAL *temp_uold = &uold[offset];\n    REAL result = temp_uold[0] * coeff[0];\n    for (ir = 1; ir <= radius; ir++)\n    {\n      result += coeff[ir] * temp_uold[ir];\n      result += coeff[-ir] * temp_uold[-ir];\n      result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n      result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n    }\n\n    *temp_u = result / count;\n  }\n\n}\n\n", "pragma": "omp parallel for private(ix, iy, ir) default(shared)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/bm2d/bm2d_cpu_omp_kernel/0"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  b[i] = (a[i] + a[i + 1]) / 2.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adityakaria/5-Sem/pc/lab2/q1/no-wait/0"}
{"code": "for (i = 0; i < bots_arg_size; i++)\n{\n  visited[i] = 0;\n  components[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/concom/src/concom_ompi/6"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[1][j][k][m] = rsd[1][j][k][m] - (dssp * ((((+5.0) * u[1][j][k][m]) - (4.0 * u[2][j][k][m])) + u[3][j][k][m]));\n  rsd[2][j][k][m] = rsd[2][j][k][m] - (dssp * (((((-4.0) * u[1][j][k][m]) + (6.0 * u[2][j][k][m])) - (4.0 * u[3][j][k][m])) + u[4][j][k][m]));\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/96"}
{"code": "for (long int i = start; i <= stop; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbertDeFusco/hybridPi/pi/0"}
{"code": "for (int x = 0; x < n; x++)\n{\n  K[x][x] = K[x][x] + t;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/doddapanenipurna/GaussianProcessRegression/gpr/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arzunuvar/Scientific_Computing_Codes/Paralel_Programlama_Ders_\u0130ci_Kodlar/countSorting (parallel)/0"}
{"code": "for (int i = 0; i < 5; i++)\n  printf(\"[%d] = %d\\n\", i, hist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram_omp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"%i  \", matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Documents/TrabajoDeCursada/Matrix Multiplication/mm/2"}
{"code": "for (size_t j = 0; j < (w_layout[i] - 1); ++j)\n{\n  if (i == (w_layout.size() - 1))\n  {\n    correction[j] = (expect[j] - v[i][j]) * activation_func_deriv(v[i][j]);\n    momentum_correction[i][j] = correction[j];\n    for (size_t l = 0; l < w_layout[i - 1]; ++l)\n    {\n      w[i][j][l] += ((1.0 - m) * ((correction[j] * nu) * v[i - 1][l])) + (m * momentum_correction[i][j]);\n    }\n\n  }\n  else\n  {\n    double sum = 0;\n    for (size_t l = 0; l < (w_layout[i + 1] - 1); ++l)\n    {\n      sum += w[i + 1][l][j] * correction_priv[l];\n    }\n\n    correction[j] = activation_func_deriv(v[i][j]) * sum;\n    momentum_correction[i][j] = correction[j];\n    for (size_t l = 0; l < w_layout[i - 1]; ++l)\n    {\n      w[i][j][l] += ((1.0 - m) * ((correction[j] * nu) * v[i - 1][l])) + (m * momentum_correction[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Learning/BackProp/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  a[i] = 0;\n  b[i] = 0;\n  c[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_variant/test_declare_variant/3"}
{"code": "for (i = 1; i < intervals; i++)\n{\n  x = step * (i + 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nowke/hpc_lab/1_pi_calculation/pi_calculation/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = i;\n  s += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_new_udr_01/0"}
{"code": "for (c2 = (nj > nl) ? (nj) : (nl); c2 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/6"}
{"code": "for (int i = 0; i < (1000 + 1); i++)\n{\n  printf(\">> %d \", Path[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant04/7"}
{"code": "for (int j = coluna; j < matriz[linha].size(); j++)\n{\n  matriz[i][j] += multiple * matriz[linha][j];\n}\n\n", "pragma": "                    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Landecrispim/Metodo-de-Gauss-cpp-OpenMP/guss/5"}
{"code": "for (int i = 0; i < ((str.length() - sub_str.length()) + 1); i++)\n{\n  vec[i] = 0;\n  for (int j = 0; j < sub_str.length(); j++)\n  {\n    if (str[i + j] == sub_str[j])\n    {\n      vec[i]++;\n    }\n    else\n    {\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergere15/OpenMP_tasks/Task5/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    Q[j + (n * (i + (m * 0)))] = 4.0;\n    Q[j + (n * (i + (m * 1)))] = 0.0;\n    Q[j + (n * (i + (m * 2)))] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eduardlopez/swallow-water-simulation-parallel-multiprocessing/swater2D-omp/11"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB070-simd1-orig-no/2"}
{"code": "for (char i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/1"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/2"}
{"code": "for (int i = 0; i < 3; i++)\n  (SaveOut << (FillingMasParallelTime[i] / 20)) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/4"}
{"code": "for (int i = 0; i < rectsPerProc; i++)\n{\n  const double x = ((rank * rectsPerProc) + i) * width;\n  const double heightSq = 1.0 - (x * x);\n  const double height = (heightSq < DBL_EPSILON) ? (0.0) : (sqrt(heightSq));\n  myAreaSum += width * height;\n}\n\n", "pragma": "omp parallel for reduction(+:myAreaSum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pi/0"}
{"code": "for (int i = 0; i < 150000; i++)\n{\n  a *= 0.5;\n}\n\n", "pragma": "omp parallel for schedule(static,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/Parallel-and-Distributed-Programming-Lab3/lab3/0"}
{"code": "for (i = 0; i < array_size; i++)\n  serial_sum = serial_sum + Check[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ksheeraj1161/OpenMP-MPI/OpenMP/program5/2"}
{"code": "for (int i = 0; i < (N / 2); i++)\n{\n  int sum = A[i] + B[i];\n  if (sum != 0)\n  {\n    product *= sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osovv/openmp-labs/lab_5/src/main/0"}
{"code": "for (i = 0; i < total_throws; i++)\n{\n  double rand_x = (rand() % (2147483647 - 1)) / ((double) 2147483647);\n  double rand_y = (rand() % (2147483647 - 1)) / ((double) 2147483647);\n  sq_dist = (rand_x * rand_x) + (rand_y * rand_y);\n  if (sq_dist <= 1)\n    throws_inside_circle++;\n\n}\n\n", "pragma": "omp parallel for num_threads(threadct) shared(total_throws) private(i, sq_dist) reduction(+: throws_inside_circle)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/monte-carlo-method/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  Y[i] = letters[rand() % 26];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_cache/4"}
{"code": "for (int i = 0; i < dimension; i++)\n{\n  for (int j = 0; j < dimension; j++)\n  {\n    flatA[(i * dimension) + j] = matrixA[i][j];\n    flatB[(j * dimension) + i] = matrixB[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iarchanaa/Large_Matrix_Multiplication_Using_openMP/LargeMatrixMultiplication/2"}
{"code": "for (int i = is_first; i < n; i++)\n{\n  integral += my_fun(xmin + (i * delta)) * delta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joaocassianox7x/Parallel_Integral/paralel_integral/0"}
{"code": "for (long long int i = 0; i < iterations; i++)\n{\n  double x = getRandomNumber(&seed);\n  double y = getRandomNumber(&seed);\n  double distanceSquared = (x * x) + (y * y);\n  if (distanceSquared <= 1)\n    numberInCircle++;\n\n}\n\n", "pragma": "omp for reduction(+: numberInCircle)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrigankdoshy/monte-carlo-simulation-pi/Pi/OpenMP/main/0"}
{"code": "for (int i = 0; i < 992; i++)\n  for (int j = 0; j < 992; j++)\n  S[(i * 992) + j] += T[(i * 992) + j] + U[(i * 992) + j];\n\n\n", "pragma": "omp distribute parallel for simd collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-dpfs-dist-clauses/test/4"}
{"code": "for (m = 0; m < ng; m++)\n{\n  f[i][m][k].Re = fft_data_local[2 * m];\n  f[i][m][k].Im = fft_data_local[(2 * m) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/Gpower/fft/8"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  double sum = 0.0;\n  for (int j = 0; j < COLS; j++)\n  {\n    int indexTrain = (784 * i) + j;\n    int indexTest = (784 * testRow) + j;\n    sum += fabs(train[indexTrain] - test[indexTest]);\n  }\n\n  if (minVal > sum)\n  {\n    minVal = sum;\n    classIndex = i;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(NUM_THREADS) shared(classIndex) reduction(min: minVal)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michal-dom/knn_with_openMP/main/2"}
{"code": "for (int jj = j; jj > 0; jj--)\n{\n  yans[jj + y_offset] = (int) y[jj - 1];\n}\n\n", "pragma": "        #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/9"}
{"code": "for (int j = 0; j < n2; j++)\n{\n  R[j] = a[(m + 1) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guruprasad-bangi/OpenMp/mergesort/2"}
{"code": "for (i = 0; i < n; ++i)\n{\n  maxabserr = (fabsf(yaccl[i] - yhost[i]) > maxabserr) ? (fabsf(yaccl[i] - yhost[i])) : (maxabserr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/saxpy-ompt-cuda/saxpy/1"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  tmp[i + (SIZE / 4)] = 0;\n  for (int j = 0; j < SIZE; j++)\n  {\n    tmp[i + (SIZE / 4)] = tmp[i + (SIZE / 4)] + (A2[(i * SIZE) + j] * x[j]);\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS) depend(in: a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/ATAX/ataxPL/1"}
{"code": "for (int i = 0; i < ALTURA; ++i)\n{\n  for (int j = 0; j < ANCHURA; ++j)\n  {\n    buffer[(i * ANCHURA) + j] = matrizPixeles[i][j].r;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danielsto/arcos-openmp/Paralela/ARCfmtut_par/3"}
{"code": "for (i = 0; i < SIZE; i++)\n  final_board[i] = malloc((sizeof(int)) * SIZE);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/11"}
{"code": "for (j = 0; j < M; j++)\n{\n  printf(\"%g\", B[j * ((250 * 1024) / 256)]);\n  for (k = 1; k < ((250 * 1024) / 256); k++)\n  {\n    printf(\" %g\", B[(j * ((250 * 1024) / 256)) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/8"}
{"code": "for (int i = 0; i < (NUM_WORDS / 2); i++)\n{\n  printf(\"input [%02d] = %5.2f | %5.2f\\n\", i, input[2 * i], input[(2 * i) + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/fft/sw/src/main/4"}
{"code": "for (int i = 0; i < r; i++)\n  M[i] = (double *) calloc(c, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/4"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 0; j <= (m - 1); j += 1)\n  {\n    b[i][j] = i + j;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB037-truedepseconddimension-orig-yes/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src;\n  uint32_t dest = v;\n  float weight = 0.0001f;\n  Nodes = graph->vertices[dest].outNodes;\n  degree = graph->vertices[dest].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    src = Nodes->dest;\n    Nodes = Nodes->next;\n    stats->vector_output[dest] += weight * stats->vector_input[src];\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/16"}
{"code": "for (int oy = 1; oy < (height - 1); oy += 4)\n{\n  for (int x = 1; x < (width - 1); x++)\n  {\n    for (int iy = 0; iy < 4; iy++)\n    {\n      int y = oy + iy;\n      gridA[(y * width) + x] = 0.25 * (((gridB[((y * width) + x) + 1] + gridB[((y * width) + x) - 1]) + gridB[((y + 1) * width) + x]) + gridB[((y - 1) * width) + x]);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/te42kyfo/omp_jacobi/main6/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  iN[i] = i - 1;\n  iS[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_srad/srad_v2/srad/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  arr[i] = cpy[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JakeThurman/OpenMPISample_Jacobi/Driver/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  mat[i] = (int *) malloc((sizeof(int)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q1/1"}
{"code": "for (i = 0; i < 8; ++i)\n  MPI_Wait(&send_reqs[i], &status);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/import-this/pgol/cgol_mpi_omp/5"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = nppmx * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[(3 * i) + (mxv3 * j)] = fxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[(1 + (3 * i)) + (mxv3 * j)] = fxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[(2 + (3 * i)) + (mxv3 * j)] = fxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[(3 * i) + (mxv3 * j)] = bxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[(1 + (3 * i)) + (mxv3 * j)] = bxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[(2 + (3 * i)) + (mxv3 * j)] = bxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = (3 * (nn - noff)) + (mxv3 * (mm - moff));\n    amx = 1.0 - dxp;\n    amy = 1.0 - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += mxv3;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += mxv3;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[2 + (idimp * (j + npoff))] + dx;\n    acy = ppart[3 + (idimp * (j + npoff))] + dy;\n    acz = ppart[4 + (idimp * (j + npoff))] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0 / sqrtf(1.0 + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0 + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0 / (1.0 + omt);\n    omt = 0.5 * (1.0 - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[2 + (idimp * (j + npoff))] = dx;\n    ppart[3 + (idimp * (j + npoff))] = dy;\n    ppart[4 + (idimp * (j + npoff))] = dz;\n    p2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (dx * dtg);\n    dy = y + (dy * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,ih,nh,x,y,dxp,dyp,amx,amy, dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3, rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery,p2,gami, qtmg,dtg,sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/4"}
{"code": "for (ii = 0; ii < 10; ii = ii + 1.0f)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/24"}
{"code": "for (i = 0; i < n_cmds; ++i)\n{\n  if (i == (mpi_size - 1))\n    break;\n\n  if (options.verbose)\n    printf(\"Init loop: n_cmds = %d, i_cmd = %d, cur_rank = %d\\n\", n_cmds, i, i + 1);\n\n  cmd_len = strlen(cmd_list[i]) + 1;\n  MPI_Send(&i, 1, (MPI_Datatype) 0x4c000405, i + 1, 0, (MPI_Comm) 0x44000000);\n  MPI_Send(&cmd_len, 1, (MPI_Datatype) 0x4c000405, i + 1, 1, (MPI_Comm) 0x44000000);\n  MPI_Send(cmd_list[i], cmd_len, (MPI_Datatype) 0x4c000101, i + 1, 2, (MPI_Comm) 0x44000000);\n  MPI_Send(&options.exit_on_error, 1, (MPI_Datatype) 0x4c000405, i + 1, 3, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gmcgarragh/divvy/divvy/3"}
{"code": "for (int i = 0; i < 10000; ++i)\n  v[i] = rand() % 100000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elard28/OpenMPparalelos/e3/1"}
{"code": "formula.append((\"- \" + number((-1) * dd)) + \"x^4 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/63"}
{"code": "for (int i = 1; i <= numUsers; i++)\n{\n  csr_users[i] += csr_users[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cb1711/RecommenderSystem/src/main/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  process(i);\n  (cout << i) << \" \";\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wynnliam/openmp-learning/dynamic_schedule/1"}
{"code": "for (i = 0; i <= 500; i++)\n{\n  MPI_Start(&north_send[new_old]);\n  MPI_Start(&south_send[new_old]);\n  MPI_Start(&west_send[new_old]);\n  MPI_Start(&east_send[new_old]);\n  MPI_Start(&north_receive[new_old]);\n  MPI_Start(&south_receive[new_old]);\n  MPI_Start(&west_receive[new_old]);\n  MPI_Start(&east_receive[new_old]);\n  update(2, x - 3, 2, y - 3, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  MPI_Wait(&east_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&west_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&north_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&south_receive[new_old], (MPI_Status *) 1);\n  update(1, x - 2, 1, 1, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(1, x - 2, y - 2, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(1, 1, 1, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(x - 2, x - 2, 1, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  MPI_Wait(&east_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&west_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&north_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&south_send[new_old], (MPI_Status *) 1);\n  new_old = 1 - new_old;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MikeAndroulakis/MPI-simulation-program/mpi_openmp/4"}
{"code": "for (j = start; j < end; j++)\n{\n  Fx[j] = 0;\n  Fy[j] = 0;\n  for (k = 0; k < N; k++)\n  {\n    if (k != j)\n    {\n      if ((((((((x[j] <= 1000000) && (x[k] <= 1000000)) && (y[j] <= 1000000)) && (y[k] <= 1000000)) && (x[j] >= (-1000000))) && (x[k] >= (-1000000))) && (y[j] >= (-1000000))) && (y[k] >= (-1000000)))\n      {\n        ftemp = (q[j] * q[k]) / (pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n        fx = (ftemp * (x[j] - x[k])) / sqrt(pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n        fy = (ftemp * (y[j] - y[k])) / sqrt(pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n        Fx[j] = Fx[j] + fx;\n        Fy[j] = Fy[j] + fy;\n      }\n\n    }\n\n  }\n\n  Ax[j] = Fx[j] / m[j];\n  Ay[j] = Fy[j] / m[j];\n  dax[j] = d * Ax[j];\n  day[j] = d * Ay[j];\n  dvx[j] = d * vx[j];\n  dvy[j] = d * vy[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/assignment3_5/1"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    for (n = 0; n < 5; n++)\n    {\n      lhs[i][j][k][0][m][n] = 0.0;\n      lhs[i][j][k][1][m][n] = 0.0;\n      lhs[i][j][k][2][m][n] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,n ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/49"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/28"}
{"code": "for (i = 0; i < max_words; i++)\n{\n  if (!strcmp(histo[i].word, token))\n  {\n    res = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/word_count/0"}
{"code": "for (uint8_t i = 0; i < 2; ++i)\n{\n  for (uint8_t j = 0; j < 2; ++j)\n  {\n    X(r[i][j]) = i * width1;\n    Y(r[i][j]) = j * height1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinnik-dmitry07/image-homography/ImageHomographyOMP/1"}
{"code": "for (unsigned i = 0; i < num_edges; ++i)\n{\n  getline(infile, line, ' ');\n  src = atoi(line.c_str());\n  getline(infile, line);\n  dst = atoi(line.c_str());\n  srcs[counter] = src;\n  dsts[counter] = dst;\n  ++counter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  vec[i] = rand();\n  copy[i] = vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/florin-alistar/AlistarSerbanFlorin_Tema1_OpenMP/radix/3"}
{"code": "for (int j = 0; j < (n + 1); j++)\n{\n  t = (0 - P[c_i][j]) < 0;\n  s = 0 - (prev_dp[j] - (t * prev_dp[P[c_i][j] - 1]));\n  DP[j] = (((t ^ 1) || (s ^ 0)) * prev_dp[j]) + ((!((t ^ 1) || (s ^ 0))) * (prev_dp[P[c_i][j] - 1] + 1));\n}\n\n", "pragma": "omp parallel for private(t,s) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v2/space_optimized/row_wise_v2/0"}
{"code": "for (e = 0; e < epochs; e++)\n{\n  error = 0.0;\n  for (m = 0; m < batches; m++)\n  {\n    for (k = 0; k < MINIBATCH; k++)\n    {\n      for (i = 0; i < inputN; i++)\n        x[k][i] = data[m].input[i];\n\n      for (i = 0; i < outN; i++)\n        y[k][i] = data[m].label[i];\n\n    }\n\n    feedforward(x, wh, hidden, wout, out, bh, bout);\n    for (k = 0; k < MINIBATCH; k++)\n    {\n      for (i = 0; i < outN; i++)\n      {\n        errtemp = y[k][i] - out[k][i];\n        out_delta[k][i] = (errtemp * out[k][i]) * (1.0 - out[k][i]);\n        error += (0.5 * errtemp) * errtemp;\n      }\n\n    }\n\n    for (k = 0; k < MINIBATCH; k++)\n    {\n      for (i = 0; i < outN; i++)\n      {\n        bout[i] += eta * out_delta[k][i];\n        for (j = 0; j < hN; j++)\n          wout[j][i] += (eta * out_delta[k][i]) * hidden[k][j];\n\n      }\n\n    }\n\n    for (k = 0; k < MINIBATCH; k++)\n    {\n      for (i = 0; i < hN; i++)\n      {\n        errtemp = 0.0;\n        for (j = 0; j < outN; j++)\n          errtemp += out_delta[k][j] * wout[i][j];\n\n        h_delta[k][i] = (errtemp * hidden[k][i]) * (1.0 - hidden[k][i]);\n      }\n\n    }\n\n    for (k = 0; k < MINIBATCH; k++)\n    {\n      for (i = 0; i < hN; i++)\n      {\n        bh[i] += eta * h_delta[k][i];\n        for (j = 0; j < inputN; j++)\n          wh[j][i] += (eta * h_delta[k][i]) * x[k][j];\n\n      }\n\n    }\n\n  }\n\n  error = error;\n  ((cout << \"\\nEpoch \") << e) << \" Completed!\";\n  printf(\"The %d th training, error: %f\\n\", e, error);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchSequential/3"}
{"code": "for (size_t ivert = 0; ivert < nverts; ++ivert)\n{\n  m_vertsx_GPU[ivert] = m_verts[ivert][0];\n  m_vertsy_GPU[ivert] = m_verts[ivert][1];\n  m_vertsz_GPU[ivert] = m_verts[ivert][2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/SurfMeshSmooth/Mesh/1"}
{"code": "for (int i = 0; i < even_num_particles; i++)\n{\n  if (((num_particles == even_num_particles) || ((i / num_particles_per_process) < (num_particles % num_processes))) || ((i % num_particles_per_process) != (num_particles_per_process - 1)))\n  {\n    fprintf(output_stream, \"%.16lf %.16lf %.16lf %.16lf %.16lf %.16lf\\n\", output_coordinates[i].x, output_coordinates[i].y, output_coordinates[i].z, output_velocity[i].x, output_velocity[i].y, output_velocity[i].z);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jankopanski/Three-Body-Problem/body3_mpi_omp/9"}
{"code": "for (i = 0; i <= (2048 + 1); i++)\n{\n  for (j = 0; j <= (2048 + 1); j++)\n  {\n    T[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/2"}
{"code": "for (j = 1; j < numprocs; j++)\n{\n  tStart = tEnd;\n  MPI_Send(&tStart, 1, MPI_INT, j, 0, MPI_COMM_WORLD);\n  tEnd = tStart + ((helper / numprocs) * helper);\n  max -= tEnd - tStart;\n  if (j == (numprocs - 1))\n    if (max != 0)\n    tEnd += max;\n\n\n  MPI_Send(&tEnd, 1, MPI_INT, j, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/main/3"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  out[i] = ((0.25 * in[i - 1]) + (0.5 * in[i])) + (0.25 * in[i + 1]);\n  if (stable)\n    stable = fabs(out[i] - in[i]) <= eps;\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Borroot/heat/src/openmp/major/relax_join/1"}
{"code": "for (v = 0; v < nvtxs; v++)\n{\n  u = iperm[v];\n  for (j = xadj[u]; j < xadj[u + 1]; j++, jj++)\n  {\n    ngraph->adjncy[jj] = perm[adjncy[j]];\n    if (graph->iadjwgt)\n      ngraph->iadjwgt[jj] = graph->iadjwgt[j];\n\n    if (graph->fadjwgt)\n      ngraph->fadjwgt[jj] = graph->fadjwgt[j];\n\n  }\n\n  if (graph->ivwgts)\n    ngraph->ivwgts[v] = graph->ivwgts[u];\n\n  if (graph->fvwgts)\n    ngraph->fvwgts[v] = graph->fvwgts[u];\n\n  if (graph->ivsizes)\n    ngraph->ivsizes[v] = graph->ivsizes[u];\n\n  if (graph->fvsizes)\n    ngraph->fvsizes[v] = graph->fvsizes[u];\n\n  if (graph->vlabels)\n    ngraph->vlabels[v] = graph->vlabels[u];\n\n  ngraph->xadj[v + 1] = jj;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/5"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n{\n  Ex[i][j][0] += Ex_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + Ex_phase);\n  Ey[i][j][0] += Ey_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + Ey_phase);\n  Ez[i][j][0] += Ez_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + Ez_phase);\n  Bxn[i][j][0] += Bx_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + Bx_phase);\n  Byn[i][j][0] += By_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + By_phase);\n  Bzn[i][j][0] += Bz_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + Bz_phase);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/47"}
{"code": "for (i = start_local; i < end_local; i++)\n{\n  x = h * (((double) i) + 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Hybrid/Eval_pi_integral_OMPI/0"}
{"code": "for (z = 0; z < t; z++)\n{\n  if (x <= 1000)\n    show(current_gen, w, h);\n\n  gettimeofday(&start, 0);\n  evolve(current_gen, next_gen, w, h);\n  swap(&current_gen, &next_gen);\n  gettimeofday(&end, 0);\n  tot_time += (double) elapsed_wtime(start, end);\n  if (x > 1000)\n    printf(\"Iteration %d is : %f ms\\n\", z, (double) elapsed_wtime(start, end));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LazyRacc00n/HPC-project/Project/OpenMP/experiment03/4"}
{"code": "for (int i = 0; i < n; i++)\n  score_sum += p[i] * dp[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/30"}
{"code": "for (unsigned int i = 0; i < N; i++)\n{\n  d_Data[i] = val;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_teams(globalWorkSize/wgSize) thread_limit(wgSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particles-omp/particles/0"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  double *array = &data0[1 * n_op];\n  *array = 0.0;\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/zero_1d_array_kernel_omp4kernel_func/0"}
{"code": "for (int i = 0; i < n; ++i)\n  arr[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP For/merge_final_working/3"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  __sync_fetch_and_add(&edgeListPtr[tmpEdgeList[i].head + 1], 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/9"}
{"code": "for (c2 = 0; c2 <= 127; c2++)\n{\n  for (c5 = 0; c5 <= 127; c5++)\n  {\n    E[c1][c2] += A[c1][c5] * B[c5][c2];\n  }\n\n  for (c5 = 0; c5 <= 127; c5++)\n  {\n    G[c1][c5] += E[c1][c2] * F[c2][c5];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c5 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/104"}
{"code": "for (int row = 0; row < rows; row++)\n{\n  mean += dataSet->at(row)->getFeatures()->at(col);\n}\n\n", "pragma": "    #pragma omp parallel for shared(dataSet, mean, rows, col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-Hybrid-OpenMP-MPI/MPI:OpenMP/StandardScaler/0"}
{"code": "for (int in = i; in < m; in++, k++)\n  C[k] = array1[in];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/0"}
{"code": "for (int z = 0; z < 5; z++)\n{\n  int i = getRandomNumber() % chromo_length;\n  int j = getRandomNumber() % chromo_length;\n  int k = getRandomNumber() % (popl_size - ((20 * popl_size) / 100));\n  int temp = pop[((20 * popl_size) / 100) + k].genes[j];\n  pop[((20 * popl_size) / 100) + k].genes[j] = pop[((20 * popl_size) / 100) + k].genes[i];\n  pop[((20 * popl_size) / 100) + k].genes[i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/18"}
{"code": "for (int i = 0; i < W; i++)\n{\n  for (int j = 0; j < H; j++)\n  {\n    kval = (buffer[k] + buffer[k + 1]) + buffer[k + 2];\n    output1[i][j] = kval;\n    k += 3;\n    pixels[i][j].rgbtBlue = kval;\n    pixels[i][j].rgbtGreen = kval;\n    pixels[i][j].rgbtRed = kval;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anw10/FRecogRPI/cameraci_control/2"}
{"code": "for (int i = 0; i < var->N; ++i)\n  var->p[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_07/0"}
{"code": "for (int i = 0; i < data.conf.input_length; ++i)\n{\n  sum += p_array[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += i;\n  printf(\"%d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/openmp/0"}
{"code": "for (int i = 0; i < taskEachNode; ++i)\n{\n  maxInLines[i] = *max_element(weights[i], weights[i] + sizeOfItems);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-action-based/1"}
{"code": "for (int j = 0; j < 1000; j++)\n{\n  generateExecTasks();\n  runTasks_1();\n  runTasks_2();\n  runTasks_3();\n  runTasks_4();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p2/task/1"}
{"code": "for (j = 1; j < (y - 1); j++)\n{\n  for (k = 1; k < (z - 1); k++)\n  {\n    if ((with_one_pulse == 1) && (counter == 0))\n    {\n      if (soundemitter[i - 1][j - 1][k - 1] != 1)\n        pre[i - 1][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j][k - 1] != 1)\n        pre[i - 1][j][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k - 1] != 1)\n        pre[i - 1][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j - 1][k] != 1)\n        pre[i - 1][j - 1][k] = pressure;\n\n      if (soundemitter[i - 1][j][k] != 1)\n        pre[i - 1][j][k] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k] != 1)\n        pre[i - 1][j + 1][k] = pressure;\n\n      if (soundemitter[i - 1][j - 1][k + 1] != 1)\n        pre[i - 1][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i - 1][j][k + 1] != 1)\n        pre[i - 1][j][k + 1] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k + 1] != 1)\n        pre[i - 1][j + 1][k + 1] = pressure;\n\n      if (soundemitter[i][j - 1][k - 1] != 1)\n        pre[i][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i][j][k - 1] != 1)\n        pre[i][j][k - 1] = pressure;\n\n      if (soundemitter[i][j + 1][k - 1] != 1)\n        pre[i][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i][j - 1][k] != 1)\n        pre[i][j - 1][k] = pressure;\n\n      if (soundemitter[i][j + 1][k] != 1)\n        pre[i][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i][j - 1][k + 1] != 1)\n        pre[i][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i][j][k + 1] != 1)\n        pre[i][j][k + 1] = pressure;\n\n      if (soundemitter[i][j + 1][k + 1] != 1)\n        pre[i][j + 1][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k - 1] != 1)\n        pre[i + 1][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j][k - 1] != 1)\n        pre[i + 1][j][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k - 1] != 1)\n        pre[i + 1][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k] != 1)\n        pre[i + 1][j - 1][k] = pressure;\n\n      if (soundemitter[i + 1][j][k] != 1)\n        pre[i + 1][j][k] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k] != 1)\n        pre[i + 1][j + 1][k] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k + 1] != 1)\n        pre[i + 1][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j][k + 1] != 1)\n        pre[i + 1][j][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k + 1] != 1)\n        pre[i + 1][j + 1][k + 1] = pressure;\n\n    }\n\n    if (with_one_pulse == 0)\n    {\n      if (soundemitter[i - 1][j - 1][k - 1] != 1)\n        pre[i - 1][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j][k - 1] != 1)\n        pre[i - 1][j][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k - 1] != 1)\n        pre[i - 1][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i - 1][j - 1][k] != 1)\n        pre[i - 1][j - 1][k] = pressure;\n\n      if (soundemitter[i - 1][j][k] != 1)\n        pre[i - 1][j][k] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k] != 1)\n        pre[i - 1][j + 1][k] = pressure;\n\n      if (soundemitter[i - 1][j - 1][k + 1] != 1)\n        pre[i - 1][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i - 1][j][k + 1] != 1)\n        pre[i - 1][j][k + 1] = pressure;\n\n      if (soundemitter[i - 1][j + 1][k + 1] != 1)\n        pre[i - 1][j + 1][k + 1] = pressure;\n\n      if (soundemitter[i][j - 1][k - 1] != 1)\n        pre[i][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i][j][k - 1] != 1)\n        pre[i][j][k - 1] = pressure;\n\n      if (soundemitter[i][j + 1][k - 1] != 1)\n        pre[i][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i][j - 1][k] != 1)\n        pre[i][j - 1][k] = pressure;\n\n      if (soundemitter[i][j + 1][k] != 1)\n        pre[i][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i][j - 1][k + 1] != 1)\n        pre[i][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i][j][k + 1] != 1)\n        pre[i][j][k + 1] = pressure;\n\n      if (soundemitter[i][j + 1][k + 1] != 1)\n        pre[i][j + 1][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k - 1] != 1)\n        pre[i + 1][j - 1][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j][k - 1] != 1)\n        pre[i + 1][j][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k - 1] != 1)\n        pre[i + 1][j + 1][k - 1] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k] != 1)\n        pre[i + 1][j - 1][k] = pressure;\n\n      if (soundemitter[i + 1][j][k] != 1)\n        pre[i + 1][j][k] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k] != 1)\n        pre[i + 1][j + 1][k] = pressure;\n\n      if (soundemitter[i + 1][j - 1][k + 1] != 1)\n        pre[i + 1][j - 1][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j][k + 1] != 1)\n        pre[i + 1][j][k + 1] = pressure;\n\n      if (soundemitter[i + 1][j + 1][k + 1] != 1)\n        pre[i + 1][j + 1][k + 1] = pressure;\n\n    }\n\n    if ((dom[i][j][k] == 1) && (soundemitter[i][j][k] == 0))\n    {\n      if (dom[i - 1][j - 1][k - 1] != 1)\n        pressure_on_solid[i - 1][j - 1][k - 1] = fabs(pre[i - 1][j - 1][k - 1] - pre_old[i - 1][j - 1][k - 1]);\n\n      if (dom[i - 1][j][k - 1] != 1)\n        pressure_on_solid[i - 1][j][k - 1] = fabs(pre[i - 1][j][k - 1] - pre_old[i - 1][j][k - 1]);\n\n      if (dom[i - 1][j + 1][k - 1] != 1)\n        pressure_on_solid[i - 1][j + 1][k - 1] = fabs(pre[i - 1][j + 1][k - 1] - pre_old[i - 1][j + 1][k - 1]);\n\n      if (dom[i - 1][j - 1][k] != 1)\n        pressure_on_solid[i - 1][j - 1][k] = fabs(pre[i - 1][j - 1][k] - pre_old[i - 1][j - 1][k]);\n\n      if (dom[i - 1][j][k] != 1)\n        pressure_on_solid[i - 1][j][k] = fabs(pre[i - 1][j][k] - pre_old[i - 1][j][k]);\n\n      if (dom[i - 1][j + 1][k] != 1)\n        pressure_on_solid[i - 1][j + 1][k] = fabs(pre[i - 1][j + 1][k] - pre_old[i - 1][j + 1][k]);\n\n      if (dom[i - 1][j - 1][k + 1] != 1)\n        pressure_on_solid[i - 1][j - 1][k + 1] = fabs(pre[i - 1][j - 1][k + 1] - pre_old[i - 1][j - 1][k + 1]);\n\n      if (dom[i - 1][j][k + 1] != 1)\n        pressure_on_solid[i - 1][j][k + 1] = fabs(pre[i - 1][j][k + 1] - pre_old[i - 1][j][k + 1]);\n\n      if (dom[i - 1][j + 1][k + 1] != 1)\n        pressure_on_solid[i - 1][j + 1][k + 1] = fabs(pre[i - 1][j + 1][k + 1] - pre_old[i - 1][j + 1][k + 1]);\n\n      if (dom[i][j - 1][k - 1] != 1)\n        pressure_on_solid[i][j - 1][k - 1] = fabs(pre[i][j - 1][k - 1] - pre_old[i][j - 1][k - 1]);\n\n      if (dom[i][j][k - 1] != 1)\n        pressure_on_solid[i][j][k - 1] = fabs(pre[i][j][k - 1] - pre_old[i][j][k - 1]);\n\n      if (dom[i][j + 1][k - 1] != 1)\n        pressure_on_solid[i][j + 1][k - 1] = fabs(pre[i][j + 1][k - 1] - pre_old[i][j + 1][k - 1]);\n\n      if (dom[i][j - 1][k] != 1)\n        pressure_on_solid[i][j - 1][k] = fabs(pre[i][j - 1][k] - pre_old[i][j - 1][k]);\n\n      if (dom[i][j + 1][k] != 1)\n        pressure_on_solid[i][j + 1][k - 1] = fabs(pre[i][j + 1][k - 1] - pre_old[i][j + 1][k - 1]);\n\n      if (dom[i][j - 1][k + 1] != 1)\n        pressure_on_solid[i][j - 1][k + 1] = fabs(pre[i][j - 1][k + 1] - pre_old[i][j - 1][k + 1]);\n\n      if (dom[i][j][k + 1] != 1)\n        pressure_on_solid[i][j][k + 1] = fabs(pre[i][j][k + 1] - pre_old[i][j][k + 1]);\n\n      if (dom[i][j + 1][k + 1] != 1)\n        pressure_on_solid[i][j + 1][k + 1] = fabs(pre[i][j + 1][k + 1] - pre_old[i][j + 1][k + 1]);\n\n      if (dom[i + 1][j - 1][k - 1] != 1)\n        pressure_on_solid[i + 1][j - 1][k - 1] = fabs(pre[i + 1][j - 1][k - 1] - pre_old[i + 1][j - 1][k - 1]);\n\n      if (dom[i + 1][j][k - 1] != 1)\n        pressure_on_solid[i + 1][j][k - 1] = fabs(pre[i + 1][j][k - 1] - pre_old[i + 1][j][k - 1]);\n\n      if (dom[i + 1][j + 1][k - 1] != 1)\n        pressure_on_solid[i + 1][j + 1][k - 1] = fabs(pre[i + 1][j + 1][k - 1] - pre_old[i + 1][j + 1][k - 1]);\n\n      if (dom[i + 1][j - 1][k] != 1)\n        pressure_on_solid[i + 1][j - 1][k] = fabs(pre[i + 1][j - 1][k] - pre_old[i + 1][j - 1][k]);\n\n      if (dom[i + 1][j][k] != 1)\n        pressure_on_solid[i + 1][j][k] = fabs(pre[i + 1][j][k] - pre_old[i + 1][j][k]);\n\n      if (dom[i + 1][j + 1][k] != 1)\n        pressure_on_solid[i + 1][j + 1][k] = fabs(pre[i + 1][j + 1][k] - pre_old[i + 1][j + 1][k]);\n\n      if (dom[i + 1][j - 1][k + 1] != 1)\n        pressure_on_solid[i + 1][j - 1][k + 1] = fabs(pre[i + 1][j - 1][k + 1] - pre_old[i + 1][j - 1][k + 1]);\n\n      if (dom[i + 1][j][k + 1] != 1)\n        pressure_on_solid[i + 1][j][k + 1] = fabs(pre[i + 1][j][k + 1] - pre_old[i + 1][j][k + 1]);\n\n      if (dom[i + 1][j + 1][k + 1] != 1)\n        pressure_on_solid[i + 1][j + 1][k + 1] = fabs(pre[i + 1][j + 1][k + 1] - pre_old[i + 1][j + 1][k + 1]);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/noise_generator/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/39"}
{"code": "for (k = 0; k < size2; k = k + 2)\n{\n  velx[k] += accelx[k];\n  vely[k] += accely[k];\n  velz[k] += accelz[k];\n  posx[k] += velx[k] * 0.1;\n  posy[k] += vely[k] * 0.1;\n  posz[k] += velz[k] * 0.1;\n  velx[k + 1] += accelx[k + 1];\n  vely[k + 1] += accely[k + 1];\n  velz[k + 1] += accelz[k + 1];\n  posx[k + 1] += velx[k + 1] * 0.1;\n  posy[k + 1] += vely[k + 1] * 0.1;\n  posz[k + 1] += velz[k + 1] * 0.1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/3"}
{"code": "for (i = 0; i < V; i++)\n{\n  if (vertices[i].visited == false)\n  {\n    int c = findEdgeWeight(u, vertices[i], edges, weights);\n    path_length[vertices[i].label] = min(path_length[vertices[i].label], path_length[u.label] + c);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dhanya-Abhirami/Parallel-Dijkstra-Algorithm/par_dij/5"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  in3[i] = 0.0;\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/3"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  D.zeros();\n  assignew = Assign(data_proc, D, P, n, cov_num, strt_num, level_num, omega, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Lp;\n  TL = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (diff_data - Lp);\n  mupdate = ((diff_data - Lp) > (2 * (diff_data - Lm))) || ((diff_data - Lp) < ((diff_data - Lm) * 0.5));\n  Lp = (TL < (diff_data - ((Lp * n1c) / n))) ? (Lp + ((c * alpha) / m)) : (Lp - ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Lm = (mupdate) ? (Lp) : (Lm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/15"}
{"code": "for (int p = 0; p < in.particles; p++)\n{\n  int *num_nucs = aml_replicaset_hwloc_local_replica(SD.num_nucs_replica);\n  double *concs = aml_replicaset_hwloc_local_replica(SD.concs_replica);\n  double *unionized_energy_array = aml_replicaset_hwloc_local_replica(SD.unionized_energy_array_replica);\n  int *index_grid = aml_replicaset_hwloc_local_replica(SD.index_grid_replica);\n  NuclideGridPoint *nuclide_grid = aml_replicaset_hwloc_local_replica(SD.nuclide_grid_replica);\n  uint64_t seed = STARTING_SEED;\n  seed = fast_forward_LCG(seed, ((p * in.lookups) * 2) * 5);\n  double p_energy = LCG_random_double(&seed);\n  int mat = pick_mat(&seed);\n  for (int i = 0; i < in.lookups; i++)\n  {\n    double macro_xs_vector[5] = {0};\n    calculate_macro_xs(p_energy, mat, in.n_isotopes, in.n_gridpoints, num_nucs, concs, unionized_energy_array, index_grid, nuclide_grid, SD.mats, macro_xs_vector, in.grid_type, in.hash_bins, SD.max_num_nucs);\n    double max = -1.0;\n    int max_idx = 0;\n    for (int j = 0; j < 5; j++)\n    {\n      if (macro_xs_vector[j] > max)\n      {\n        max = macro_xs_vector[j];\n        max_idx = j;\n      }\n\n    }\n\n    verification += max_idx + 1;\n    uint64_t n_forward = 0;\n    for (int j = 0; j < 5; j++)\n      if (macro_xs_vector[j] > 1.0)\n      n_forward++;\n\n\n    if (n_forward > 0)\n      seed = fast_forward_LCG(seed, n_forward);\n\n    p_energy = LCG_random_double(&seed);\n    mat = pick_mat(&seed);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 100) reduction(+:verification)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/XSBench/openmp-threading/Simulation/4"}
{"code": "for (int i = 1; i < (width + 1); ++i)\n{\n  a[0][i] = a[height][i];\n  a[height + 1][i] = a[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexSofienko/Game_of_life/life_modulator/2"}
{"code": "for (i = 0; i < 4; i++)\n{\n  features[i] = atof(array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/43"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  cudaStatus = cudaMemcpy(coordsClusters[i], allClusters[i].virutalCenter.coordinates, sizeof(double *), cudaMemcpyDeviceToHost);\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaClusters);\n  cudaFree(allClusters[i].virutalCenter.coordinates);\n  allClusters[i].virutalCenter.coordinates = coordsClusters[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/22"}
{"code": "for (int i = 0; i < 210; i++)\n{\n  result += (i * 2) + 1;\n}\n\n", "pragma": "        #pragma omp for reduction(+ : result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task14/0"}
{"code": "for (k = 0; k < 100; k++)\n  a[k] = k;\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-parforsimd/test/0"}
{"code": "for (long j = i1; j < i2; j++)\n{\n  int sgn = 1;\n  for (long i = 0; i < M; i++)\n  {\n    for (long k = 0; k < M; k++)\n    {\n      local_val += (sgn * (j + i)) * (j + k);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/magland/openmp_performance_test/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i][pvector[i]] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/1"}
{"code": "for (k = 0; k < 1024; k++)\n  C[i][j] += A[i][k] * B[k][j];\n\n", "pragma": "omp parallel for private(k) schedule(dynamic) reduction(+:C[i][j])", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiannisChouliaras/Parallel_Systems_and_Programming--MYE023/first_set/thirdFor/0"}
{"code": "for (i = 0; i < num; i++)\n  fscanf(fp, \"%f \", &x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arnav-kansal/parallel_linsolver/source/gs/2"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = b[i] * c[i];\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB070-simd1-orig-no/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  C[A[i] - min] += 1;\n}\n\n", "pragma": "omp parallel for private(i) shared(n, A, min, lenC) reduction(+ : C[:lenC])", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/duinobot2/OMPCountingSort/ProjectCountingSortFinal1/src/countingsort/2"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  parent_nodes_results_matrix[(0 * 40000) + i] = parent_nodes_array[i];\n  distance_results_matrix[(0 * 40000) + i] = node_distance_array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/2"}
{"code": "for (int x = 0; x < n; x++)\n{\n  for (int y = 0; y < n; y++)\n  {\n    newMatrix[x][y] = myMatrix[y][x];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/doddapanenipurna/GaussianProcessRegression/gpr/12"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    vijk = vs[i][j][k];\n    vp1 = vs[i][j + 1][k];\n    vm1 = vs[i][j - 1][k];\n    rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n    rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n    rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n    rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n    rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(vijk, vp1, vm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/62"}
{"code": "for (frame_num = 1; frame_num <= Nf; frame_num++)\n{\n  printf(\"\\rProcessing frame %d / %d\", frame_num, Nf);\n  fflush(stdout);\n  MAT *I = get_frame(video, frame_num, 0, 1);\n  int Ih = I->m;\n  int Iw = I->n;\n  for (i = 0; i < Nc; i++)\n  {\n    xc[i][frame_num] = xc[i][frame_num - 1];\n    yc[i][frame_num] = yc[i][frame_num - 1];\n    for (j = 0; j < Np; j++)\n    {\n      r[i][j][frame_num] = r[i][j][frame_num - 1];\n    }\n\n  }\n\n  for (cell_num = 0; cell_num < Nc; cell_num++)\n  {\n    double xci = xc[cell_num][frame_num];\n    double yci = yc[cell_num][frame_num];\n    double *ri = (double *) malloc((sizeof(double)) * Np);\n    for (j = 0; j < Np; j++)\n    {\n      ri[j] = r[cell_num][j][frame_num];\n    }\n\n    double ycavg = 0.0;\n    for (i = (frame_num > 10) ? (frame_num - 10) : (0); i < frame_num; i++)\n    {\n      ycavg += yc[cell_num][i];\n    }\n\n    ycavg = ycavg / ((double) ((frame_num > 10) ? (10) : (frame_num)));\n    int u1 = max((xci - (4.0 * R)) + 0.5, 0);\n    int u2 = min((xci + (4.0 * R)) + 0.5, Iw - 1);\n    int v1 = max((yci - (2.0 * R)) + 1.5, 0);\n    int v2 = min((yci + (2.0 * R)) + 1.5, Ih - 1);\n    MAT *Isub = m_get((v2 - v1) + 1, (u2 - u1) + 1);\n    for (i = v1; i <= v2; i++)\n    {\n      for (j = u1; j <= u2; j++)\n      {\n        m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n      }\n\n    }\n\n    MAT *Ix = gradient_x(Isub);\n    MAT *Iy = gradient_y(Isub);\n    MAT *IE = m_get(Isub->m, Isub->n);\n    for (i = 0; i < Isub->m; i++)\n    {\n      for (j = 0; j < Isub->n; j++)\n      {\n        double temp_x = m_get_val(Ix, i, j);\n        double temp_y = m_get_val(Iy, i, j);\n        m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n      }\n\n    }\n\n    long long MGVF_start_time = get_time();\n    MAT *IMGVF = MGVF(IE, 1, 1);\n    MGVF_time += get_time() - MGVF_start_time;\n    xci = xci - ((double) u1);\n    yci = yci - ((double) (v1 - 1));\n    ycavg = ycavg - ((double) (v1 - 1));\n    long long snake_start_time = get_time();\n    ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n    snake_time += get_time() - snake_start_time;\n    xci = xci + u1;\n    yci = yci + (v1 - 1);\n    xc[cell_num][frame_num] = xci;\n    yc[cell_num][frame_num] = yci;\n    for (j = 0; j < Np; j++)\n    {\n      r[cell_num][j][frame_num] = ri[j];\n      x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n      y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n    }\n\n    m_free(IMGVF);\n    free(ri);\n  }\n\n  if (frame_num == Nf)\n  {\n    FILE *pFile;\n    pFile = fopen(\"result.txt\", \"w+\");\n    for (cell_num = 0; cell_num < Nc; cell_num++)\n      fprintf(pFile, \"\\n%d,%f,%f\", cell_num, xc[cell_num][Nf], yc[cell_num][Nf]);\n\n    fclose(pFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/openmp/leukocyte/OpenMP/track_ellipse/0"}
{"code": "for (unsigned int i = 0; i < n; i++)\n{\n  init[i] = distr(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guyez/Simple-Sparsely-Connected-NN/OpenMP/src/NeuralNet/3"}
{"code": "for (int c = 0; c < columnas(); c++)\n{\n  arr[c] = num(ins, c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kunkkaharden/Proyecto-de-tesis/source/utiles/matrix/6"}
{"code": "for (j = 0; j < d[1]; j++)\n{\n  for (i = 0; i < fftblock; i++)\n  {\n    xout[k][j][i + ii].real = y0[j][i].real;\n    xout[k][j][i + ii].imag = y0[j][i].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,ii ,x ,fftblock ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/10"}
{"code": "for (i = 2; i < (nx - 2); i++)\n{\n  double r = x[i];\n  temp1 = ((((((s2_np1[i] - s2_n[i]) / dt) - ((2 * ((((1.0 / 4.0) * (s1_np1[i + 1] - s1_np1[i - 1])) / dr) + (((1.0 / 4.0) * (s1_n[i + 1] - s1_n[i - 1])) / dr))) / r)) - (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s1_np1[i + 2]) - ((1.0 / 12.0) * s1_np1[i - 2])) + ((4.0 / 3.0) * s1_np1[i + 1])) + ((4.0 / 3.0) * s1_np1[i - 1])) - ((5.0 / 2.0) * s1_np1[i]))) / (dr * dr))) - (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s1_n[i + 2]) - ((1.0 / 12.0) * s1_n[i - 2])) + ((4.0 / 3.0) * s1_n[i + 1])) + ((4.0 / 3.0) * s1_n[i - 1])) - ((5.0 / 2.0) * s1_n[i]))) / (dr * dr))) + (((1.0 / 2.0) * V_np1[i]) * s1_np1[i])) + (((1.0 / 2.0) * V_n[i]) * s1_n[i]);\n  temp2 = ((((((s1_np1[i] - s1_n[i]) / dt) + ((2 * ((((1.0 / 4.0) * (s2_np1[i + 1] - s2_np1[i - 1])) / dr) + (((1.0 / 4.0) * (s2_n[i + 1] - s2_n[i - 1])) / dr))) / r)) + (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s2_np1[i + 2]) - ((1.0 / 12.0) * s2_np1[i - 2])) + ((4.0 / 3.0) * s2_np1[i + 1])) + ((4.0 / 3.0) * s2_np1[i - 1])) - ((5.0 / 2.0) * s2_np1[i]))) / (dr * dr))) + (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s2_n[i + 2]) - ((1.0 / 12.0) * s2_n[i - 2])) + ((4.0 / 3.0) * s2_n[i + 1])) + ((4.0 / 3.0) * s2_n[i - 1])) - ((5.0 / 2.0) * s2_n[i]))) / (dr * dr))) - (((1.0 / 2.0) * V_np1[i]) * s2_np1[i])) - (((1.0 / 2.0) * V_n[i]) * s2_n[i]);\n  temp3 = ((((V_np1[i + 1] - V_np1[i - 1]) / (r * dr)) + (((((((-(1.0 / 12.0)) * V_np1[i + 2]) - ((1.0 / 12.0) * V_np1[i - 2])) + ((4.0 / 3.0) * V_np1[i + 1])) + ((4.0 / 3.0) * V_np1[i - 1])) - ((5.0 / 2.0) * V_np1[i])) / (dr * dr))) - (s1_np1[i] * s1_np1[i])) - (s2_np1[i] * s2_np1[i]);\n  res += ((temp1 * temp1) + (temp2 * temp2)) + (temp3 * temp3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/17"}
{"code": "for (i = current_row; i < (order + 1); i++)\n{\n  row_array[i] = row_array[i] / pivo;\n}\n\n", "pragma": "omp parallel for shared(row_array, pivo) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/command/0"}
{"code": "for (unsigned i = 0; i < 64; ++i)\n{\n  a[i] = i;\n  b[i] = 64 - i;\n  c[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/motonacciu/clomp/test/inputs/omp_arrayadd/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    double z_val = m_get_val(z, i, j) * v;\n    double H_val = (one_over_pi * atan(z_val * one_over_e)) + 0.5;\n    m_set_val(H, i, j, H_val);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/11"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydro_data->gamma[i] = gamma_infinity;\n  hydro_data->dens[i] = ddensity;\n  hydro_data->dens_lab[i] = lab_dens;\n  hydro_data->pres[i] = (A_RAD * pow(t_comov, 4.0)) / 3;\n  hydro_data->temp[i] = t_comov;\n  hydro_data->v0[i] = 0;\n  hydro_data->v1[i] = vel;\n  hydro_data->v0[i] = vel * cos(hydro_data->r1[i]);\n  hydro_data->v1[i] = (-vel) * sin(hydro_data->r1[i]);\n  hydro_data->v2[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/9"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  cell(ci).verletVelocityUpdate(dt);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/48"}
{"code": "for (int ti = 0; ti < SortBands.size(); ti++)\n{\n  if (nocced < N_gs_orbs)\n  {\n    if (SortBands[ti].MakeTwoCopies && ((N_gs_orbs - nocced) > 1))\n    {\n      nocced += 2;\n      ntoshift++;\n      gsOcc[ti] = 2;\n    }\n    else\n      if ((SortBands[ti].MakeTwoCopies && ((N_gs_orbs - nocced) == 1)) || (!SortBands[ti].MakeTwoCopies))\n    {\n      nocced += 1;\n      ntoshift++;\n      gsOcc[ti] = 1;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderESHDF.fft/5"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    total += speed0[ii + (jj * params.nx)];\n    total += speed1[ii + (jj * params.nx)];\n    total += speed2[ii + (jj * params.nx)];\n    total += speed3[ii + (jj * params.nx)];\n    total += speed4[ii + (jj * params.nx)];\n    total += speed5[ii + (jj * params.nx)];\n    total += speed6[ii + (jj * params.nx)];\n    total += speed7[ii + (jj * params.nx)];\n    total += speed8[ii + (jj * params.nx)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bkazi/lattice-boltzmann/d2q9-bgk/9"}
{"code": "for (int i = 0; i < ctx->level; i++)\n{\n  int option = ctx->chosen_options[i];\n  printf(\"+ %d : \", option);\n  print_option(instance, option);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/3"}
{"code": "for (j = 0; j < npxy; j++)\n{\n  dsum1 += part[2 + (idimp * j)];\n  dsum2 += part[3 + (idimp * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/8"}
{"code": "for (int i = 0; i < ROWA; i++)\n  for (int j = 0; j < COLA; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_mm/0"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    const double smvp = SMVP(u);\n    r[index] = u0[index] - smvp;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_solver_methods/1"}
{"code": "for (i = (500 / 250) - 1; i < 500; i += 500 / 250)\n{\n  init(i, vector, selected_cpu);\n  k_nearest_cpu(i, vector, selected_cpu);\n  order_points(i, vector, selected_cpu);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/other-nearest/src/other-nearest_gpu/6"}
{"code": "for (size_t i = r.begin(); i < r.end(); ++i)\n{\n  for (size_t j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n      goto not_a_prime;\n\n  }\n\n  buffer.push_back(i);\n  not_a_prime:\n  ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stride-Apollo/proto-TBB/proto1/3"}
{"code": "for (i = 0; i < pdf->total_size; i++)\n  theintegral += pdf->PDF[i];\n\n", "pragma": "omp for reduction(+:theintegral)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/2"}
{"code": "for (int i = 0; i < threads; i++)\n{\n  tabuleiro[i] = (int *) aligned_alloc(64, rainhas * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brendonhps/parallel-nqueens/codigos_c/recursivo_paralelo/2"}
{"code": "for (int i = 0; i < 8; ++i)\n{\n  fprintf(stdout, \"+\\n\");\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/4"}
{"code": "for (int i = 0; i < 10; i++)\n  a[i] = computeValue(i);\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture5/Loop_construct_implicit_barrier/Loop_construct_implicit_barrier/0"}
{"code": "for (uint64_t i = 0; i < gridM; i++)\n{\n  for (uint64_t j = 0; j < gridM; j++)\n  {\n    double xDistancePart = gridPosition[i] - predictionPointX;\n    xDistancePart = xDistancePart * xDistancePart;\n    double yDistancePart = gridPosition[j] - predictionPointY;\n    yDistancePart = yDistancePart * yDistancePart;\n    double totalDistance = yDistancePart + xDistancePart;\n    double kValue = exp(-totalDistance);\n    kTranspose[(i * gridM) + j] = kValue;\n  }\n\n}\n\n", "pragma": "        #pragma omp for nowait ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_GaussianProcessRegression/gpr/8"}
{"code": "for (int i = 0; i < pointsSize; ++i)\n{\n  if ((cluster[i] != clusterTmp[i]) || ((clusterTmp[i] != cloudSize) && (distance(&freqTable, centers[cluster[i]], centers[clusterTmp[i]]) > eps)))\n  {\n    if (removeFromCenters(clouds, cluster[i], i))\n    {\n      cluster[i] = clusterTmp[i];\n      addToCenters(clouds, clusterTmp[i], i);\n      changed = true;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/11"}
{"code": "for (i = 0; i < (*maxI); i++)\n{\n  for (j = 0; j < (*maxJ); j++)\n  {\n    fscanf(f, \"%lf\", &arr[(i * (*maxJ)) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  h_c[i] = h_a[i] * h_b[i];\n}\n\n", "pragma": "omp parallel for simd schedule(dynamic, 32) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/minicurso-openmp-wscad-2017/src/example-for-loop-simd/example-for-loop-simd/2"}
{"code": "for (i = start; i <= limit; i++)\n{\n  if ((is_prime[i] && ((i % 3) != 0)) && ((i % 5) != 0))\n  {\n    printf(\", %d\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OlegShatin/openmp-homework/15/main/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (arr[i] > max_val)\n  {\n    max_val = arr[i];\n    index = i;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(cntThreads) reduction(max : max_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Onyaxoxo/OpenMP-FEFU-/5/2"}
{"code": "for (row = 0; row < gray_img->height; row++)\n{\n  const uchar *ptr = (const uchar *) (gray_img->imageData + (row * gray_img->widthStep));\n  for (col = 0; col < gray_img->width; col++)\n  {\n    in[count] = *(ptr++);\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0rky/CWT/cwt/2"}
{"code": "for (i = 1; i <= seq1len; i++)\n  M[i][0] = M[i - 1][0] + gap;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alperencubuk/Sequence-Alignment-with-NW-Algorithm/SequenceAlignment/2"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  a[(i * 500) + j] = 10;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/application_kernels/mmm_target_parallel_for_simd/1"}
{"code": "for (j = 0; j < 100; j++)\n{\n  a[i][j] = i;\n  b[i][j] = i;\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB113-default-orig-no/1"}
{"code": "for (int i = 0; i < spmatrix->hsize; i++)\n{\n  msum += spmatrix->iia[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/matrixio/2"}
{"code": "for (idx = 0; idx < 5; idx++)\n  if (arr[(4 * 5) + idx] != (idx < 4))\n  abort();\nelse\n  arr[(4 * 5) + idx] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-12/10"}
{"code": "for (j = 1; j < (procCoords.y_cells_num - 1); j++)\n{\n  delta_f[(j * procCoords.x_cells_num) + i] = (((f[(j * procCoords.x_cells_num) + i] - f[((j * procCoords.x_cells_num) + i) - 1]) - (recv_message_rl[j] - f[(j * procCoords.x_cells_num) + i])) / hx2) + (((f[(j * procCoords.x_cells_num) + i] - f[((j - 1) * procCoords.x_cells_num) + i]) - (f[((j + 1) * procCoords.x_cells_num) + i] - f[(j * procCoords.x_cells_num) + i])) / hy2);\n}\n\n", "pragma": "                #pragma omp for schedule (static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/8"}
{"code": "for (int i = 0; i < N; i++)\n{\n  r[i] = s->Mat_3d[1][i] * x[i];\n  if (sN > 2)\n  {\n    if ((i - 1) >= 0)\n      r[i] += s->Mat_3d[5][i] * x[i - 1];\n\n    if ((i + 1) < N)\n      r[i] += s->Mat_3d[6][i] * x[i + 1];\n\n  }\n\n  if (_M > 2)\n  {\n    if ((i - (sN + 2)) >= 0)\n      r[i] += s->Mat_3d[3][i] * x[i - (sN + 2)];\n\n    if ((i + (sN + 2)) < N)\n      r[i] += s->Mat_3d[4][i] * x[i + (sN + 2)];\n\n  }\n\n  if (K > 2)\n  {\n    if ((i - ((sN + 2) * (_M + 2))) >= 0)\n      r[i] += s->Mat_3d[0][i] * x[i - ((sN + 2) * (_M + 2))];\n\n    if ((i + ((sN + 2) * (_M + 2))) < N)\n      r[i] += s->Mat_3d[2][i] * x[i + ((sN + 2) * (_M + 2))];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/136"}
{"code": "for (int j = run; j < len; j = 2 * j)\n{\n  for (int beg = 0; beg < len; beg = beg + (2 * j))\n  {\n    int mid = min((beg + j) - 1, len - 1);\n    int end = min((beg + (2 * j)) - 1, len - 1);\n    merge(arr, beg, mid, end);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SayaliThorat17/TimSort-Algorithm-Using-OpenMP/timsort/3"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  tmp_res += (f(start + (i * dx)) + f(start + ((i + 1) * dx))) / 2;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail189/MPI_OpenMP/openmp_3/0"}
{"code": "for (int i = graph->nodeCount - 1; i >= 0; i--)\n{\n  int sum = 0;\n  for (int j = 0; j < graph->nodeCount; j++)\n  {\n    if (dist[i][j] == 2147483647)\n    {\n      printf(\"Disconnected subgraph detected, solution undefined\\n\");\n      exit(1);\n    }\n\n    sum += dist[i][j];\n  }\n\n  if (sum < champ)\n  {\n    champ = sum;\n    centres->value = i;\n    centres->length = 1;\n    if (centres->next != 0)\n    {\n      free_list(centres->next);\n      centres->next = 0;\n    }\n\n  }\n  else\n    if (sum == champ)\n  {\n    ListNode *next = malloc(sizeof(ListNode));\n    next->value = i;\n    next->next = centres;\n    next->length = centres->length + 1;\n    centres = next;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mgtlake/parallel-graph-centrality/main/4"}
{"code": "for (int i = 0; i < nrow; ++i)\n{\n  row_offset[i + 1] += row_offset[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/121"}
{"code": "for (i = 0; i <= nsub; i++)\n{\n  printf(\"  %8d  %8d\\n\", i, indx[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/18"}
{"code": "for (int k = 0; k < (0x01 << 16); k++)\n{\n  dx[k] = genrand_real2();\n  dy[k] = genrand_real2();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/05.adaptive_antialiasing/02.cpu_vector/mandelbrot/2"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      lhs[n][i][j][k] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/1"}
{"code": "for (int i = 1; i < max_rows; i++)\n{\n  input_itemsets_cpu[i * max_cols] = (-i) * penalty;\n  input_itemsets_gpu[i * max_cols] = (-i) * penalty;\n  for (int j = 1; j < max_cols; j++)\n  {\n    input_itemsets_cpu[j] = (-j) * penalty;\n    input_itemsets_gpu[j] = (-j) * penalty;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/nw/src/needle/5"}
{"code": "for (int t = 0; t < niters; ++t)\n{\n  MPI_Ineighbor_alltoallv(local_image, halo_counts, halo_send_displs, (MPI_Datatype) 0x4c00040a, local_image, halo_counts, halo_recv_displs, (MPI_Datatype) 0x4c00040a, CART_COMM_WORLD, &request);\n  stencil(local_nx - 2, local_ny, local_cols, local_rows, local_image + local_rows, local_tmp_image + local_rows);\n  MPI_Waitall(1, &request, &status);\n  #pragma vector aligned\n  for (j = 1; j < (ny + 1); ++j)\n  {\n    local_tmp_image[j + local_rows] = (local_image[j + local_rows] * 0.6f) + ((((local_image[(j - 1) + local_rows] + local_image[(j + 1) + local_rows]) + local_image[j + (2 * local_rows)]) + local_image[j]) * 0.1f);\n  }\n\n  #pragma vector aligned\n  for (j = 1; j < (ny + 1); ++j)\n  {\n    local_tmp_image[j + ((local_cols - 2) * local_rows)] = (local_image[j + ((local_cols - 2) * local_rows)] * 0.6f) + ((((local_image[(j - 1) + ((local_cols - 2) * local_rows)] + local_image[(j + 1) + ((local_cols - 2) * local_rows)]) + local_image[j + ((local_cols - 3) * local_rows)]) + local_image[j + ((local_cols - 1) * local_rows)]) * 0.1f);\n  }\n\n  MPI_Ineighbor_alltoallv(local_tmp_image, halo_counts, halo_send_displs, (MPI_Datatype) 0x4c00040a, local_tmp_image, halo_counts, halo_recv_displs, (MPI_Datatype) 0x4c00040a, CART_COMM_WORLD, &request);\n  stencil(local_nx - 2, local_ny, local_cols, local_rows, local_tmp_image + local_rows, local_image + local_rows);\n  MPI_Waitall(1, &request, &status);\n  #pragma vector aligned\n  for (j = 1; j < (ny + 1); ++j)\n  {\n    local_image[j + local_rows] = (local_tmp_image[j + local_rows] * 0.6f) + ((((local_tmp_image[(j - 1) + local_rows] + local_tmp_image[(j + 1) + local_rows]) + local_tmp_image[j + (2 * local_rows)]) + local_tmp_image[j]) * 0.1f);\n  }\n\n  #pragma vector aligned\n  for (j = 1; j < (ny + 1); ++j)\n  {\n    local_image[j + ((local_cols - 2) * local_rows)] = (local_tmp_image[j + ((local_cols - 2) * local_rows)] * 0.6f) + ((((local_tmp_image[(j - 1) + ((local_cols - 2) * local_rows)] + local_tmp_image[(j + 1) + ((local_cols - 2) * local_rows)]) + local_tmp_image[j + ((local_cols - 3) * local_rows)]) + local_tmp_image[j + ((local_cols - 1) * local_rows)]) * 0.1f);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/MPI/stencil/2"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n{\n  for (int k = 0; k < r; k++)\n  {\n    sum += a[(i * r) + k] * b[(k * m) + j];\n    mult++;\n  }\n\n  c[(i * m) + j] = sum;\n  sum = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/2"}
{"code": "for (int j = 0; j < size; j++)\n{\n  if ((j % 2) == 0)\n  {\n    for (int i = 0; i < (size / 2); ++i)\n    {\n      if (T[2 * i] > T[(2 * i) + 1])\n      {\n        echanger(T, 2 * i, (2 * i) + 1);\n      }\n\n    }\n\n  }\n  else\n  {\n    for (int i = 0; i < ((size / 2) - 1); ++i)\n    {\n      if (T[(2 * i) + 1] > T[(2 * i) + 2])\n      {\n        echanger(T, (2 * i) + 1, (2 * i) + 2);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/bubble/2"}
{"code": "for (j = 0; j <= 99; j += 1)\n{\n  a[i][j] = a[i][j] + 1;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB046-doall2-orig-no/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < n; i++)\n  {\n    seed = (3125 * seed) % 65536;\n    value = (((float) seed) - 32768.0) / 16384.0;\n    a[i + (j * lda)] = value;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/9"}
{"code": "for (int jj = internal_ystart; jj <= internal_ystop; jj++)\n{\n  for (int ji = internal_xstart; ji <= (internal_xstop - 1); ji++)\n  {\n    momentum_u_code(ji, jj, width, ua, un, vn, hu, hv, ht, ssha_u, sshn_t, sshn_u, sshn_v, tmask, dx_u, dx_v, dx_t, dy_u, dy_t, area_u, gphiu, rdt, cbfr, visc, omega, d2r, g);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/1"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * ((u[i_imopVar110][j_imopVar111 - 2][k_imopVar112][m_imopVar113] - (4. * u[i_imopVar110][j_imopVar111 - 1][k_imopVar112][m_imopVar113])) + (5. * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/20"}
{"code": "for (i = 0; i < n; i++)\n{\n  score2 = minmax_ab(T[i], -1, niv - 1, score, beta, nb_noeuds, nb_coupes);\n  if (score2 > score)\n    score = score2;\n\n  if (score > beta)\n  {\n    *nb_coupes += 1;\n    return beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/25"}
{"code": "for (int i = chunk_size; i < n; i++)\n{\n  if (((i % chunk_size) == 0) && (curr_owner < (num_procs - 1)))\n    curr_owner++;\n\n  owner[i] = curr_owner;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/8"}
{"code": "for (int i = 0; i < (POP_SIZE / 2); i++)\n{\n  for (int j = 0; j < (POP_SIZE / 2); j++)\n  {\n    if (fitness(offspring[i]) < fitness(p.pop[j]))\n    {\n      p.pop[j] = offspring[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/18"}
{"code": "for (int i = 0; i < len; i++)\n{\n  for (int j = 0; j < len; j++)\n  {\n    float t = 0;\n    for (int k = 0; k < len; k++)\n      t += a[k + (j * len)] * b[i + (k * len)];\n\n    x[i + (j * len)] = t;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/matmul/2"}
{"code": "for (i = 2; i < n; i++)\n{\n  for (j = 2; j < n; j++)\n  {\n    count = 0;\n    for (k = i - 1; k <= (i + 1); k++)\n    {\n      for (l = j - 1; l <= (j + 1); l++)\n      {\n        if ((k != i) || (l != j))\n        {\n          if (cur[k][l] == '1')\n          {\n            count++;\n          }\n\n        }\n\n      }\n\n    }\n\n    if ((count < 2) || (count > 3))\n    {\n      next[i][j] = '0';\n    }\n    else\n      if (count == 3)\n    {\n      next[i][j] = '1';\n    }\n    else\n      if (cur[i][j] == '1')\n    {\n      next[i][j] = '1';\n    }\n    else\n    {\n      next[i][j] = '0';\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dimitris-Mpou/Parallel-GOL/functions/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nshul/High_Performance_Computing/openMP/prefixsum/2"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  dtemp = ((double) i) / ((double) 10000000);\n  j = (unsigned long) (dtemp * ((double) imax_num_mesh));\n  X[i] = dtemp;\n  MC_ind[j]++;\n  MC[(20 * j) + MC_ind[j]] = i;\n  Ind_MC[i] = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/DEM/C/dem/4"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n{\n  for (int j = 1; j < (ny - 1); j++)\n  {\n    rhs_x[i][j] = (f_t[i - 1][j] + f_t[i + 1][j]) - (2 * f_t[i][j]);\n    rhs_y[i][j] = (((-2) * f_t[i][j]) + f_t[i][j + 1]) + f_t[i][j - 1];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mircuz/travelling_wave/travelling_wave/support/9"}
{"code": "for (int i = 0; i < g_extended_image_dim_y; i++)\n{\n  for (int j = 0; j < g_extended_image_dim_x; j++)\n  {\n    pix_coordinate[0]->operator()(i, j) = j;\n    pix_coordinate[1]->operator()(i, j) = i;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/7"}
{"code": "for (int i = 0; i < n_size; i++)\n{\n  for (int j = 0; j < n_size; j++)\n  {\n    printf(\"%d \\t\", matriz[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leandrosfj/OpenMP_Matrix/C\u00f3digos/paralelo_matriz_omp1/4"}
{"code": "for (int i = 0; i < nHash; i++)\n{\n  if (randValuesPtr[i] != 0)\n    free(randValuesPtr[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringMultiHashMaxMin/5"}
{"code": "for (i = N - 2; i >= 1; i--)\n{\n  for (j = i + 2; j <= N; j++)\n  {\n    for (k = i; k <= (j - l); k++)\n    {\n      ck[i][j] += (ck[i][j - 1] + paired(k, j)) ? (ck[i][k - 1] + ck[k + 1][j - 1]) : (0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/counting/counting/1"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  dest[i] = src[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/1"}
{"code": "for (j = 0; j < 700; j++)\n{\n  mean = (mean + w[700 - 1][j]) + w[0][j];\n}\n\n", "pragma": "omp for schedule(runtime) reduction ( + : mean )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/hated_plate_local/5"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    uu[i][j] = u[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/laplace/4"}
{"code": "for (i = 0; i < sizeOfTheMatrix; i++)\n{\n  MatrixC[i] = (double *) malloc((sizeof(double)) * sizeOfTheMatrix);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/praveenChauhan686/Strassen-Algorithm-Java-And-OpenMp/Assignment 2_21261912/Source Code/OpenMp C/strassens_algorithm/10"}
{"code": "for (j = 0; j < m; j++)\n{\n  printf(\"b[%d][%d]=%f\\n\", i, j, b[i][j]);\n}\n\n", "pragma": "omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB031-truedepfirstdimension-orig-yes/2"}
{"code": "for (index = 0; index < particle_number; ++index)\n{\n  if ((((((particles[index].x > (mean_particle.x - x_range)) && (particles[index].x < (mean_particle.x + x_range))) && (particles[index].y > (mean_particle.y - y_range))) && (particles[index].y < (mean_particle.y + y_range))) && (particles[index].z > (mean_particle.z - z_range))) && (particles[index].z < (mean_particle.z + z_range)))\n  {\n    stx += particles[index].x;\n    sty += particles[index].y;\n    stz += particles[index].z;\n    stvx += particles[index].vx;\n    stvy += particles[index].vy;\n    stvz += particles[index].vz;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+:stx) reduction(+:sty) reduction(+:stz) reduction(+:stvx) reduction(+:stvy) reduction(+:stvz)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chivier/ompfuns/bottom/aos/2"}
{"code": "for (int i = 0; i < (popl_size / 2); i++)\n{\n  do\n  {\n    nb = getRandomNumber() % (popl_size / 2);\n  }\n  while ((nb == i) && (percentage_of_difference(pop[i], pop[nb]) < 70));\n  create_ChildV2(pop[i], pop[nb], &pop[(popl_size / 2) + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/17"}
{"code": "for (; (i + 3) < n; i += 4)\n{\n  xv[0] = _mm256_loadu_pd(&x[i + 0]);\n  _mm256_storeu_pd(&y[i + 0], xv[0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/23"}
{"code": "for (int i = 0; i < nRows; i++)\n{\n  for (int j = 0; j < nCols; j++)\n  {\n    arrayC[i][j] = 0.0f;\n    for (int k = 0; k < nCols; k++)\n    {\n      arrayC[i][j] += arrayA[i][k] * arrayB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/MatrixOperations/MatrixOperations/MatrixMult/1"}
{"code": "for (long i = 0; i < size; i++)\n{\n  second_matrix[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Multiplication_Serial_Parallel/2"}
{"code": "for (int i = 0; i < siz; i++)\n{\n  for (int j = 0; j < siz; j++)\n  {\n    grid_n[i][j] = grid[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/1"}
{"code": "for (int i = 0; i < A.nrows; i++)\n{\n  K.val[i] = 1 / A.val[i];\n  K.indi[i] = A.indi[i];\n  K.indj[i] = A.indj[i];\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/7"}
{"code": "for (int i = 0; i < me; i++)\n{\n  offset += lncs[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/rebuild/6"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 0; j < 20; j++)\n  A[i][j] = A[i - 1][j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/5.race2/0"}
{"code": "for (i = 0; i < ncols; i++)\n{\n  for (ncand = 0, j = colptr[i]; j < colptr[i + 1]; j++, ncand++)\n  {\n    cand[ncand].val = colind[j];\n    cand[ncand].key = colval[j];\n  }\n\n  gk_fkvsortd(ncand, cand);\n  k = gk_min(topk, ncand);\n  for (j = 0; j < k; j++)\n  {\n    nrowind[nrowptr[cand[j].val]] = i;\n    nrowval[nrowptr[cand[j].val]] = cand[j].key;\n    nrowptr[cand[j].val]++;\n  }\n\n  for (; j < ncand; j++)\n  {\n    if (cand[j].key < keepval)\n      break;\n\n    nrowind[nrowptr[cand[j].val]] = i;\n    nrowval[nrowptr[cand[j].val]] = cand[j].key;\n    nrowptr[cand[j].val]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/23"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  aij = ai;\n  jx = kx;\n  #pragma code_align(16)\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  y[iy] = sum;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum) shared(a_i,x_i,y_i) private(i,aij,jx,j,a_elem,x_elem,prod,ai,yi)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv_x/8"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      vijk = vs[i][j][k];\n      vp1 = vs[i][j + 1][k];\n      vm1 = vs[i][j - 1][k];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(vijk, vp1, vm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/61"}
{"code": "for (long i = 0; i < N; i++)\n{\n  for (long j = 0; j < M; j++)\n  {\n    data[(i * M) + j] = i + j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/magland/openmp_performance_test/main/5"}
{"code": "for (i = 0; i < ((2048 / NODESX) + 2); i++)\n{\n  for (j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    ii = ((((i + j) % 2) * ((2048 / NODESX) + 2)) + i) / 2;\n    if (ii < (((2048 / NODESX) + 2) / 2))\n    {\n      whites[ii][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / 5) + 2) - 1)))\n        whites[ii][j].isGhost = 2;\n      else\n        whites[ii][j].isGhost = 1;\n\n    }\n    else\n      if (ii >= (((2048 / NODESX) + 2) / 2))\n    {\n      blacks[ii - (((2048 / NODESX) + 2) / 2)][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / 5) + 2) - 1)))\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 2;\n      else\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 1;\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/104"}
{"code": "for (size_t ix = 1; ix < (szx - 1); ++ix)\n{\n  for (size_t iy = 1; iy < (szy - 1); ++iy)\n  {\n    temp[iy + (ix * szy)] = (int) ((0.25 * ((float) (((image[iy + ((ix + 1) * szy)] + image[iy + ((ix - 1) * szy)]) + image[(iy - 1) + (ix * szy)]) + image[(iy + 1) + (ix * szy)]))) + 0.5);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WarwickRSE/OpenMPExamples/FromSlides/C/15_blur_parallel/0"}
{"code": "for (i = 0; i < ARCHnodes; i++)\n{\n  c0[0] = ARCHcoord[i][0];\n  c0[1] = ARCHcoord[i][1];\n  c0[2] = ARCHcoord[i][2];\n  d1 = distance(c0, Src.xyz);\n  d2 = distance(c0, Src.epixyz);\n  if (d1 < bigdist1[my_cpu_id])\n  {\n    bigdist1[my_cpu_id] = d1;\n    temp1[my_cpu_id] = i;\n  }\n\n  if (d2 < bigdist2[my_cpu_id])\n  {\n    bigdist2[my_cpu_id] = d2;\n    temp2[my_cpu_id] = i;\n  }\n\n}\n\n", "pragma": "omp for private(i,d1,d2,c0) firstprivate(ARCHnodes,bigdist1,bigdist2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/0"}
{"code": "for (i = 0; i < 15; i++)\n{\n  for (j = 0; j < 7; j++)\n  {\n    b[i][j] = i * j;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_mm/1"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_fwd, 0);\n    gettimeofday(&s_bck_out, 0);\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_hid, 0);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/18"}
{"code": "for (int i = 0; i < 10; ++i)\n  argc = x;\n\n", "pragma": "omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/tools/clang/test/OpenMP/distribute_parallel_for_simd_misc_messages/0"}
{"code": "for (int i = N / 2; i < ((N / 4) * 3); i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n  {\n    total *= sp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/6"}
{"code": "for (unsigned cf = 0; cf < FtCount; cf++)\n  if (FtObjs[cf].usechrono)\n  ChronoObjects->SetFtData(FtObjs[cf].mkbound, FtoForces[cf].face, FtoForces[cf].fomegaace);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src_mphase/DSPH_v5.0_NNewtonian/source/JSphCpuSingle/0"}
{"code": "for (int i = 2500001; i <= 5000000; i++)\n  funcsum[1] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/1"}
{"code": "for (i = 0; i < size; i++)\n  board[i] = (cell_t *) malloc((sizeof(cell_t)) * size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/jogo_da_vida/paralell_life/3"}
{"code": "for (int i = binf; i < bsup; i++)\n{\n  y[i] = 0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n  {\n    int j = Aj[u];\n    double A_ij = Ax[u];\n    y[i] += A_ij * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP/cg/0"}
{"code": "for (x = 1; x < (maxXcount - 1); x++)\n{\n  double f = ((((-alpha) * fx_thing[x - 1]) * fy_thing[maxYcount - 3]) - (2.0 * fx_thing[x - 1])) - (2.0 * fy_thing[maxYcount - 3]);\n  double updateVal = (((((u_old[((maxYcount - 2) * maxXcount) + (x - 1)] + u_old[((maxYcount - 2) * maxXcount) + (x + 1)]) * cx) + ((u_old[((maxYcount - 3) * maxXcount) + x] + u_old[((maxYcount - 1) * maxXcount) + x]) * cy)) + (u_old[((maxYcount - 2) * maxXcount) + x] * cc)) - f) / cc;\n  u[((maxYcount - 2) * maxXcount) + x] = u_old[((maxYcount - 2) * maxXcount) + x] - (relax * updateVal);\n  local_square_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:local_square_error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MediaBilly/Poisson-Equation-Parallel-Solver/HybridMPI/jacobi_hybrid_mpi/4"}
{"code": "for (i = 0; i < n3; i++)\n{\n  x[i] += vh[i] + f[i];\n  if (x[i] < 0.0)\n    x[i] += side;\n\n  if (x[i] > side)\n    x[i] -= side;\n\n  vh[i] += f[i];\n  f[i] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD2_OMP/MolDyn/correction/solQ4/domove/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (grid_de_neuronios[i / largura][i % largura].getDistancia() < menor_distancia)\n  {\n    menor_distancia = grid_de_neuronios[i / largura][i % largura].getDistancia();\n    menor_index_x = i / largura;\n    menor_index_y = i % largura;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruteee/Kohhonen/Rede/2"}
{"code": "for (int j = 0; j < num_edges; j++)\n{\n  int source = find_parent(ufind_sets, edges[j].source);\n  int dest = find_parent(ufind_sets, edges[j].dest);\n  if (source == dest)\n  {\n    continue;\n  }\n  else\n  {\n    if ((cheap[source] == (-1)) || (edges[cheap[source]].weight > edges[j].weight))\n    {\n      cheap[source] = j;\n    }\n\n    if ((cheap[dest] == (-1)) || (edges[cheap[dest]].weight > edges[j].weight))\n    {\n      cheap[dest] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_par_openmp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    u[i][j] = 0.0;\n    if (i == j)\n      l[i][j] = 1.0;\n    else\n      l[i][j] = 0.0;\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) num_threads(T) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anandcse2018/LU-Decomposition/OMP/0"}
{"code": "for (int i = 2 * chunk; i < (3 * chunk); i++)\n{\n  if ((first_array.at(i) != 0) && (second_array.at(i) != 0))\n  {\n    sum = sum + (first_array[i] + second_array[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vladislavhgtech/openMp/OpenMpAll/OpenMpAll/OpenMpAll/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d executes loop iteration %d\\n\", omp_get_thread_num(), i);\n  b[i] = 2 * a[i];\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.12-two-for-loops/1"}
{"code": "for (int i = 1; i < (m + 1); i++)\n{\n  for (int j = 1; j < (n + 1); j++)\n  {\n    if (A[i - 1] == B[j - 1])\n    {\n      DP[i][j] = DP[i - 1][j - 1] + 1;\n    }\n    else\n    {\n      DP[i][j] = (DP[i - 1][j] > DP[i][j - 1]) ? (DP[i - 1][j]) : (DP[i][j - 1]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/hybrid/row_wise_v2/row_wise_v2/4"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n{\n  if ((tID % (2 * offset)) == 0)\n    localBins[tID][i] += localBins[tID + offset][i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/8"}
{"code": "for (i = 0; i < ncols; i++)\n{\n  cscale[i] = (collen[i] > 0) ? (log((1.0 * nrows) / collen[i])) : (0.0);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/12"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  val = i;\n  insertion(val);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Bigtable-in-C/B-tree/1"}
{"code": "for (int i = 1; i <= height; i++)\n  for (int j = 1; j <= height; j++)\n  randomizeCell(i, j, fMin, fMax);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/2/Matrix/1"}
{"code": "for (int count = 0; count < (V - 1); count++)\n{\n  int u = minDistance(dist, sptSet, V);\n  sptSet[u] = 1;\n  for (int v = 0; v < V; v++)\n    if ((((!sptSet[v]) && graph[u][v]) && (dist[u] != 2147483647)) && ((dist[u] + graph[u][v]) < dist[v]))\n    dist[v] = dist[u] + graph[u][v];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/3"}
{"code": "for (int k = 0; k < 10; ++k)\n{\n  for (int x = 0; x < 10; ++x)\n    foo();\n\n}\n\n", "pragma": "  #pragma omp for reduction(+:i)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/simd_private_messages/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int k = 0; k < 3; ++k)\n  {\n    v[i][k] = 1 - ((((float) rand()) / ((float) 32767)) * 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/11"}
{"code": "for (uint32_t i = 0; i < new_mAdjVertex.size(); i++)\n  m_mAdjVertex[i].insert(m_mAdjVertex[i].end(), new_mAdjVertex[i].begin(), new_mAdjVertex[i].end());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  fOffDiagonalSum = 0.0;\n  for (j = 0; j < n; j++)\n    if (j != i)\n    fOffDiagonalSum += fabs(A[i][j]);\n\n\n  if (A[i][i] > 0.0)\n    A[i][i] += fOffDiagonalSum;\n  else\n    A[i][i] -= fOffDiagonalSum;\n\n  if (fabs(A[i][i]) < 0.005)\n  {\n    if (A[i][i] >= 0.0)\n      A[i][i] += 2.0;\n    else\n      A[i][i] -= 2.0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/5"}
{"code": "for (int i = 0; i < colors; i++)\n{\n  input |= balls << (i * 8);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/omp10/1"}
{"code": "for (int k = 0; k < this->nrow_; ++k)\n{\n  marker[k] = 0;\n  nd[k] = (this->mat_.row_offset[k + 1] - this->mat_.row_offset[k]) - 1;\n  if (nd[k] > maxdeg)\n  {\n    maxdeg = nd[k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/75"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  for (int j = 0; j < 20; j++)\n  {\n    input[i][j] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gokaytitrek/openmp-gameoflife/main/1"}
{"code": "for (int solver_it = 0; solver_it < 40000; solver_it++)\n{\n  for (int i = 1; i < (domain.ni - 1); i++)\n  {\n    double g = 0.5 * ((phi[i - 1] + phi[i + 1]) + ((dx2 * rho[i]) / EPS_0));\n    phi[i] = phi[i] + (1.4 * (g - phi[i]));\n  }\n\n  if ((solver_it % 25) == 0)\n  {\n    double sum = 0;\n    for (int i = 1; i < (domain.ni - 1); i++)\n    {\n      double R = ((-rho[i]) / EPS_0) - (((phi[i - 1] - (2 * phi[i])) + phi[i + 1]) / dx2);\n      sum += R * R;\n    }\n\n    L2 = sqrt(sum) / domain.ni;\n    if (L2 < 1e-4)\n    {\n      return true;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sheath-omp/main/12"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    for (int k = 0; k < n; ++k)\n    {\n      c[j + (n * i)] += a[k + (i * n)] * b[j + (k * n)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonibofarull/mini-openmp/miniomp/test/tfinal/4"}
{"code": "for (int i = 0; i < lookups; i++)\n{\n  rands[2 * i] = ((double) rand()) / ((double) 32767);\n  rands[(2 * i) + 1] = ((double) rand()) / ((double) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/xsbench-mp4/src/Main/1"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n  for (int k = 0; k < N; k++)\n{\n  c[i][j] += a[i][k] * b[k][j];\n  int myID = omp_get_thread_num();\n  int threads = omp_get_num_threads();\n  ((((cout << \"Num of thread is \") << myID) << \" from \") << threads) << endl;\n}\n\n\n\n", "pragma": "#pragma omp parallel for shared(a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/matrix_matrix_multiplication/2"}
{"code": "for (int i = 0; i < arrLen; i++)\n{\n  oldval[i] = sin(i * 0.02);\n  values[i] = sin((i + shift) * 0.02);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pa-ling/pasys17wave/src/openmp/core/1"}
{"code": "for (i = 0; i < diag_len; i++)\n{\n  (*diag)[i] = -4;\n  stencil(n, i + 1, &low_fill, &up_fill);\n  if (i > 0)\n    (*l_upper_band)[i - 1] = low_fill;\n\n  if (i < mid_band_len)\n    (*u_lower_band)[i] = up_fill;\n\n  if (i < outer_band_len)\n  {\n    (*l_lower_band)[i] = 1;\n    (*u_upper_band)[i] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(low_fill, up_fill)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adeel1234/Capstone/src/OpenMP/gen_laplace_mat/0"}
{"code": "for (int i = 0; i < count; ++i)\n  ScheduleTask(lRunTask, GetTaskInfo(baseIndex + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/2"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  this->vec_[i + dst_offset] = (alpha * this->vec_[i + dst_offset]) + (beta * cast_x->vec_[i + src_offset]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/16"}
{"code": "for (int i = 0; i < xelem; i++)\n{\n  sclr.p[i].resize(yelem);\n  sclr.u[i].resize(yelem);\n  sclr.v[i].resize(yelem);\n  sclr.phi[i].resize(yelem);\n  sclr.rho[i].resize(yelem);\n  sclr.mu[i].resize(yelem);\n  for (int j = 0; j < yelem; j++)\n  {\n    sclr.p[i][j].resize(zelem, 0.0);\n    sclr.u[i][j].resize(zelem, 0.0);\n    sclr.v[i][j].resize(zelem, 0.0);\n    sclr.phi[i][j].resize(zelem, 0.0);\n    sclr.rho[i][j].resize(zelem, rhof);\n    sclr.mu[i][j].resize(zelem, muf);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jichenglee/INS_LevelSet/NE577/main/2"}
{"code": "for (i = 1; i <= NODESX; i++)\n{\n  for (j = 1; j <= NODESY; j++)\n  {\n    if (myrank == TOPO[i][j])\n    {\n      V[0] = TOPO[i - 1][j];\n      V[1] = TOPO[i + 1][j];\n      V[2] = TOPO[i][j - 1];\n      V[3] = TOPO[i][j + 1];\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/132"}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  for (j = 0; j < matrix_size; j++)\n  {\n    double *c_sum = (matrix_c + (i * matrix_size)) + j;\n    for (k = 0; k < matrix_size; k++)\n    {\n      *c_sum += (*((matrix_a + (i * matrix_size)) + k)) * (*((matrix_b + (j * matrix_size)) + k));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/malogulko/matrix_dot_omp_mpi_hybrid/matrix_dot_omp_mpi/0"}
{"code": "for (int i = 0; i < numprocs; i++)\n{\n  row_sendcount[i] = 0;\n  col_sendcount[i] = 0;\n  row_disp[i] = 0;\n  col_disp[i] = 0;\n  row_start[i] = 0;\n  row_end[i] = 0;\n  col_start[i] = 0;\n  col_end[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/7"}
{"code": "for (i = i_inicial, j = j_inicial; (i >= 0) && (j < yblocks); i--, j++)\n{\n  indi[size] = i;\n  indj[size] = j;\n  size++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/filtro-bloques/1"}
{"code": "for (int i = 0; i < boroughNum; i++)\n{\n  BorList *ptr = borFind(boroughNames[i].boroughName, localBorList);\n  if (ptr != 0)\n  {\n    MPI_Reduce(ptr->accidents, globalBorList[i].accidents, weeksNo, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000003, root, (MPI_Comm) 0x44000000);\n    MPI_Reduce(&ptr->lethals, &globalBorList[i].lethals, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000003, root, (MPI_Comm) 0x44000000);\n  }\n  else\n  {\n    int *acc = initializeEmptyAccidentArray();\n    int temp = 0;\n    MPI_Reduce(acc, globalBorList[i].accidents, weeksNo, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000003, root, (MPI_Comm) 0x44000000);\n    MPI_Reduce(&temp, &globalBorList[i].lethals, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000003, root, (MPI_Comm) 0x44000000);\n    free(acc);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/16"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  a[i] += *b;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/27"}
{"code": "for (i = iend; i >= ist; i--)\n{\n  if (i != iend)\n  {\n    while (flag[i + 1] == 0)\n    {\n      ;\n    }\n\n  }\n\n  if (i != ist)\n  {\n    while (flag[i] == 1)\n    {\n      ;\n    }\n\n  }\n\n  for (j = jend; j >= jst; j--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[i][j][m] = tv[i][j][m] + (omega * ((((((((((udy[i][j][m][0] * v[i][j + 1][k][0]) + (udx[i][j][m][0] * v[i + 1][j][k][0])) + (udy[i][j][m][1] * v[i][j + 1][k][1])) + (udx[i][j][m][1] * v[i + 1][j][k][1])) + (udy[i][j][m][2] * v[i][j + 1][k][2])) + (udx[i][j][m][2] * v[i + 1][j][k][2])) + (udy[i][j][m][3] * v[i][j + 1][k][3])) + (udx[i][j][m][3] * v[i + 1][j][k][3])) + (udy[i][j][m][4] * v[i][j + 1][k][4])) + (udx[i][j][m][4] * v[i + 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    tv[i][j][1] = tv[i][j][1] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][3] * tmp);\n    tv[i][j][4] = tv[i][j][4] / tmat[4][4];\n    tv[i][j][3] = tv[i][j][3] - (tmat[3][4] * tv[i][j][4]);\n    tv[i][j][3] = tv[i][j][3] / tmat[3][3];\n    tv[i][j][2] = (tv[i][j][2] - (tmat[2][3] * tv[i][j][3])) - (tmat[2][4] * tv[i][j][4]);\n    tv[i][j][2] = tv[i][j][2] / tmat[2][2];\n    tv[i][j][1] = ((tv[i][j][1] - (tmat[1][2] * tv[i][j][2])) - (tmat[1][3] * tv[i][j][3])) - (tmat[1][4] * tv[i][j][4]);\n    tv[i][j][1] = tv[i][j][1] / tmat[1][1];\n    tv[i][j][0] = (((tv[i][j][0] - (tmat[0][1] * tv[i][j][1])) - (tmat[0][2] * tv[i][j][2])) - (tmat[0][3] * tv[i][j][3])) - (tmat[0][4] * tv[i][j][4]);\n    tv[i][j][0] = tv[i][j][0] / tmat[0][0];\n    v[i][j][k][0] = v[i][j][k][0] - tv[i][j][0];\n    v[i][j][k][1] = v[i][j][k][1] - tv[i][j][1];\n    v[i][j][k][2] = v[i][j][k][2] - tv[i][j][2];\n    v[i][j][k][3] = v[i][j][k][3] - tv[i][j][3];\n    v[i][j][k][4] = v[i][j][k][4] - tv[i][j][4];\n  }\n\n  if (i != iend)\n    flag[i + 1] = 0;\n\n  if (i != ist)\n    flag[i] = 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/7"}
{"code": "for (i = 0; i < 3; i++)\n{\n  xstart[i] = 1;\n  xend[i] = NX;\n  ystart[i] = 1;\n  yend[i] = NY;\n  zstart[i] = 1;\n  zend[i] = NZ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/FT/ft/9"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  sumx += x0;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(tofrom: sumx) reduction(+:sumx)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/data_enter_issue01/data_enter_issue01/0"}
{"code": "for (xx = xmin; xx < xmax; xx++)\n{\n  for (yy = ymin; yy < ymax; yy++)\n  {\n    avgB = (avgG = (avgR = (ile = 0)));\n    for (x = xx; (x < hp->width) && (x < (xx + blurSize)); x++)\n    {\n      for (y = yy; (y < hp->height) && (y < (yy + blurSize)); y++)\n      {\n        avgB += data[((x * 3) + ((y * hp->width) * 3)) + 0];\n        avgG += data[((x * 3) + ((y * hp->width) * 3)) + 1];\n        avgR += data[((x * 3) + ((y * hp->width) * 3)) + 2];\n        ile++;\n      }\n\n    }\n\n    avgB /= ile;\n    avgG /= ile;\n    avgR /= ile;\n    data[((xx * 3) + ((yy * hp->width) * 3)) + 0] = avgB;\n    data[((xx * 3) + ((yy * hp->width) * 3)) + 1] = avgG;\n    data[((xx * 3) + ((yy * hp->width) * 3)) + 2] = avgR;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afforeroc/blur-effect-posix-openmp/blur-effect-openmp/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (graph[i][j] != (9223372036854775807L - 101))\n    {\n      fprintf(out, \"%ld \", graph[i][j]);\n    }\n    else\n    {\n      fprintf(out, \"X \");\n    }\n\n  }\n\n  fprintf(out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avisenna01/Djikstra-OpenMP/src/dijkstra_omp/1"}
{"code": "for (int i = 0; i < M; i++)\n  Num[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/1"}
{"code": "for (i = 1; i <= dim; i++)\n{\n  x[i - 1] = b[i - 1];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivC_OpenMP/5"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int k = 0; k < 100; k++)\n  {\n    float sum = 0;\n    int cr = ((i * 100) + k) * 960;\n    for (int j = 0; j < 960; j++)\n    {\n      sum += mat[cr + j];\n    }\n\n    res[(i * 100) + k] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(16)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savoptik/summation_of_matrix_rows_in_OpenMP/summation_of_matrix_rows_in_OpenMP/main/5"}
{"code": "for (i_y = 0; i_y < i_y_max; i_y++)\n{\n  c_y = c_y_min + (i_y * pixel_height);\n  if (fabs(c_y) < (pixel_height / 2))\n  {\n    c_y = 0.0;\n  }\n\n  ;\n  for (i_x = 0; i_x < i_x_max; i_x++)\n  {\n    c_x = c_x_min + (i_x * pixel_width);\n    z_x = 0.0;\n    z_y = 0.0;\n    z_x_squared = 0.0;\n    z_y_squared = 0.0;\n    for (iteration = 0; (iteration < iteration_max) && ((z_x_squared + z_y_squared) < escape_radius_squared); iteration++)\n    {\n      z_y = ((2 * z_x) * z_y) + c_y;\n      z_x = (z_x_squared - z_y_squared) + c_x;\n      z_x_squared = z_x * z_x;\n      z_y_squared = z_y * z_y;\n    }\n\n    ;\n    update_rgb_buffer(iteration, i_x, i_y);\n  }\n\n  ;\n}\n\n", "pragma": "omp parallel for default(shared) private(iteration, i_x, z_x, z_y, z_x_squared, z_y_squared, c_x, c_y) schedule(dynamic) num_threads(n_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP1/src/mandelbrot_omp/0"}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *data_temp = PyArray_GETPTR2(array_temp, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++data_temp, ++node_type)\n  {\n    if ((*data) == 5)\n    {\n      *data_temp = 10;\n    }\n    else\n      if ((*data) == 10)\n    {\n      *data_temp = 5;\n    }\n    else\n    {\n      *data_temp = *data;\n    }\n\n\n    if ((-1) == (*node_type))\n    {\n      *data_temp = reverse4(*data_temp);\n    }\n\n    if ((-2) == (*node_type))\n    {\n      double r = ((double) rand()) / ((double) 32767);\n      if (r < 0.8)\n      {\n        int n = rand() % 16;\n        *data_temp = n;\n        continue;\n      }\n\n    }\n\n    if ((*data) == 0)\n    {\n      *data_temp = 0;\n      continue;\n    }\n\n    if ((-3) == (*node_type))\n    {\n      *data_temp = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(array, array_temp, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kallus/Lattice-gas-automata/c_module/0"}
{"code": "for (int j = 0; j < n; j++)\n{\n  if ((t4 >> j) & 1)\n  {\n    p2 = 1 << j;\n    int t = recur(2, t1 | p2, (t2 | p2) << 1, (t3 | p2) >> 1, mask);\n    sum += t;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, chunk) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yatin2410/HPC_N_QUEENS/Codes/3/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  n = fscanf(arq, \"%lf %lf %lf %lf %lf\", &mass[i], &x[i], &y[i], &u[i], &v[i]);\n  if (n != 5)\n  {\n    printf(\"Error: Some reading won't work at line %d (%d).\\n\", i + 1, n);\n    fclose(arq);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OsvaldoBecker/BarnesHut-OpenMP/barnes_hut/0"}
{"code": "for (m = 0; m < nkernels; m++)\n{\n  for (w = 0; w < width; w++)\n  {\n    for (h = 0; h < height; h++)\n    {\n      double sum = 0.0;\n      for (c = 0; c < nchannels; c++)\n      {\n        for (x = 0; x < kernel_order; x++)\n        {\n          for (y = 0; y < kernel_order; y++)\n          {\n            sum += image[w + x][h + y][c] * kernels[m][c][x][y];\n          }\n\n        }\n\n        output[m][w][h] = (float) sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saisankp/Concurrent-Systems/Lab-2-Parallel-Multichannel-Multikernel-Convolution/conv-harness/2"}
{"code": "for (int x = proc_x_indices.first; x < proc_x_indices.second; ++x)\n{\n  a_matrix_x[x] = A_x;\n  c_matrix_x[x] = C_x;\n  b_matrix_x[x] = -B_x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/2"}
{"code": "for (i = 0; i < j; i++)\n  for (j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/28"}
{"code": "for (int num_thd = 1; num_thd < (max_thd + 1); num_thd++)\n{\n  if (num_thd == 1)\n  {\n    one = computeParams(N, mat, num_of_time_samples, num_thd);\n    (cout << 1) << endl;\n  }\n  else\n    if ((num_thd % 2) != 0)\n    continue;\n\n\n  (cout << (one / computeParams(N, mat, num_of_time_samples, num_thd))) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ngc436/Parallel-Programming-openMP1/matrix/Parallel_task1/3"}
{"code": "for (int j = startIndex; j < (arrLength - 1); j += 2)\n{\n  if (isLeftToRight && (arr[j] > arr[j + 1]))\n  {\n    SwapIntegersInArray(j, j + 1, arr);\n  }\n  else\n    if ((!isLeftToRight) && (arr[j] < arr[j + 1]))\n  {\n    SwapIntegersInArray(j, j + 1, arr);\n  }\n\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(nThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/ShearSort_Comprehension/C++_Code/Main/0"}
{"code": "for (uint vertex_ind = 0; vertex_ind < unvisited_vertices_tail; vertex_ind++)\n{\n  const uint vertex = unvisited_vertices[vertex_ind];\n  colors[vertex] = getNextColor(vertex);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/7"}
{"code": "for (int i = 0; i < r; i++)\n{\n  for (int j = 0; j < c; j++)\n    printf(\"%d \", M[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/5"}
{"code": "for (unsigned int i = 0; i < ((population_size * 2) / 10); i++)\n{\n  unsigned int person = get_random_int(population_size, rand);\n  population[person] = population[person] + get_random(-0.125, 0.125, rand);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RenaLL-N/OpenMP/OpenMP/OpenMP/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  int char_code = (unsigned char) line[i];\n  local_count[char_code] += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  nnz_entries[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/25"}
{"code": "for (j = 1; j < (columns - 1); j++)\n{\n  matrixResult[j] = -1;\n  matrixResult[((rows - 1) * columns) + j] = -1;\n}\n\n", "pragma": "omp for nowait, schedule(static), private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/parallel-scan-sky/openmp/src/ScanSky_openmp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 0;\n  b[i] = 0;\n  c[i] = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/clone_array/0"}
{"code": "for (int l = 0; l < numVertices; l++)\n{\n  randomGraph[l][l] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JFcoZC/PrimMSTParallelOpenMP/PrimSTPOpenMP/4"}
{"code": "for (int i = 0; i < n; i++)\n  p[i] = z[i] + (beta * p[i]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/OMP/cg/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%i %i\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Felcks/matriz_openmp/open/0"}
{"code": "for (i = 0; i < ilength; i++)\n{\n  corr += mixingPos[i] * compare[i];\n  norm += mixingPos[i] * mixingPos[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/TDStretch/12"}
{"code": "for (i = 0; i <= lastI; i++)\n{\n  if (patternLoc >= 0)\n  {\n    continue;\n  }\n  else\n  {\n    k = i;\n    j = 0;\n    while (((j < patternLength) && (breakSearch == 0)) && (patternLoc == (-1)))\n    {\n      localComparisons++;\n      if (textData[k] == patternData[j])\n      {\n        k++;\n        j++;\n      }\n      else\n      {\n        breakSearch = 1;\n      }\n\n    }\n\n    if ((j == patternLength) && (patternLoc == (-1)))\n    {\n      patternLoc = i;\n    }\n    else\n    {\n      breakSearch = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+: localComparisons) shared(patternLoc) private(j, k) firstprivate(breakSearch) num_threads(thread_count) schedule(runtime)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Altadsa/HPC-Sequential-Searching-using-OpenMP/src/40178464/assignment-1b/source/searching_OMP_1/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_tiger_context ctx;\n  sph_tiger_init(&ctx);\n  sph_tiger(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_tiger_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/tiger_fmt_plug/0"}
{"code": "for (int i = 0; i <= 5; i++)\n{\n  fileout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DFTheory/Water-system-openMP/water_system/13"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_test_nest_lock())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/lock/omp_test_nest_lock/0"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((((x[i] < xmin) || (x[i] >= xmax)) || (y[i] < ymin)) || (y[i] >= ymax))\n    continue;\n\n  bx = calc_bin(x[i], edgesx);\n  by = calc_bin(y[i], edgesy);\n  bin = by + (nby * bx);\n  values_ot[bin]++;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/48"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  for (y = 0; y < countOnes; y++)\n  {\n    indX = roundDouble(arrayX[x]) + objxy[(y * 2) + 1];\n    indY = roundDouble(arrayY[x]) + objxy[y * 2];\n    ind[(x * countOnes) + y] = fabs((double) ((((indX * IszY) * Nfr) + (indY * Nfr)) + k));\n    if (ind[(x * countOnes) + y] >= max_size)\n      ind[(x * countOnes) + y] = 0;\n\n  }\n\n  likelihood[x] = 0;\n  for (y = 0; y < countOnes; y++)\n    likelihood[x] += (pow(I[ind[(x * countOnes) + y]] - 100, 2) - pow(I[ind[(x * countOnes) + y]] - 228, 2)) / 50.0;\n\n  likelihood[x] = likelihood[x] / ((double) countOnes);\n}\n\n", "pragma": "omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.ref/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  if ((!item_in_bin[wu[i]]) || (space_left_on_bin[i] < 0))\n  {\n    check = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sg0/bin-packing/direct/bin_packing_omp_par/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  b = 100;\n  d = 10;\n  printf(\"Thread %d, iteration %d: b = %d, c = %d, d = %d, m = %d\\n\", omp_get_thread_num(), i, b, c, d, m);\n  a[i] = omp_get_thread_num();\n  b = omp_get_thread_num();\n  c = omp_get_thread_num();\n  d = omp_get_thread_num();\n  m = omp_get_thread_num();\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i,b) firstprivate(c) lastprivate(d) shared(a,m) schedule(dynamic, 3) num_threads(1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeesooxkim/parallel-programming/main/1"}
{"code": "for (int i = 0; i < Nt; i++)\n{\n  for (int j = 0; j < Ns; j++)\n  {\n    x[0] = i;\n    x[1] = j;\n    sum += I[sx(x, k, a) + 2] / I[sx(x, k, a)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  result[i] = a[i] + b[i];\n  printf(\"Thread id: %d is working on index %d\\n\", threadid, i);\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tr0j4n034/HPC-2019/Examples/OpenMP/for/1"}
{"code": "for (int i = 0; i < N_ROW; i++)\n{\n  Yval[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/matxvec_sparse/matxvec_sparse/0"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  int begin = i * distributecol;\n  int end = begin + distributecol;\n  if (i == (numprocs - 1))\n    end = n;\n\n  MPI_Datatype block;\n  MPI_Type_vector(n, end - begin, n, MPI_FLOAT, &block);\n  MPI_Type_commit(&block);\n  MPI_Recv((void *) (A[0] + begin), 1, block, i, 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/MPI_omp_col/2"}
{"code": "for (iPE = 0; iPE < nPEs; iPE++)\n  times[iPE] = malloc(NITER * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  tmp = u000ijk[m] - u[i][j][k][m];\n  errnm[m] = errnm[m] + (tmp * tmp);\n}\n\n", "pragma": "omp parallel for firstprivate(ist ,tmp ,m ,jst ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/41"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] += alpha * p[i];\n  r_new[i] = r[i] - (alpha * Ax[i]);\n  Error += r_new[i] * r_new[i];\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static) reduction(+:Error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yilehu/CG_OpenMP/main/1"}
{"code": "for (w = 0; w <= W; w++)\n{\n  if ((i == 0) || (w == 0))\n    K[w] = 0;\n  else\n    if (wt[i - 1] <= w)\n    K[w] = max(val[i - 1] + Kp[w - wt[i - 1]], Kp[w]);\n  else\n    K[w] = Kp[w];\n\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaiKarthik2000/OpenMP-Parallelization-of-Dynamic-Programming-and-Greedy-Algorithms/0-1 Knapsack/01knapser/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", data[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/sorting/radixsort/2"}
{"code": "for (int i = mpiBegin; i < mpiEnd; i++)\n{\n  lIA[i - mpiBegin] = 0;\n  lIA[(i + 1) - mpiBegin] = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maqayum/Hybrid/main/0"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    float sum = 0.0;\n    for (int k = 0; k < COLUMNS; k++)\n    {\n      sum = sum + (matrix_a[i][k] * matrix_b[k][j]);\n    }\n\n    matrix_r[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/2"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  npoff = (idimp * nppmx) * l;\n  nboff = (idimp * npbmx) * l;\n  isum = 0;\n  for (j = 0; j < 26; j++)\n  {\n    ist = ncl[j + (26 * l)];\n    ncl[j + (26 * l)] = isum;\n    isum += ist;\n  }\n\n  nh = ihole[(2 * (ntmax + 1)) * l];\n  ip = 0;\n  for (j = 0; j < nh; j++)\n  {\n    j1 = ihole[2 * ((j + 1) + ((ntmax + 1) * l))] - 1;\n    ist = ihole[1 + (2 * ((j + 1) + ((ntmax + 1) * l)))];\n    ii = ncl[(ist + (26 * l)) - 1];\n    if (ii < npbmx)\n    {\n      for (i = 0; i < idimp; i++)\n      {\n        ppbuff[(ii + (npbmx * i)) + nboff] = ppart[(j1 + (nppmx * i)) + npoff];\n      }\n\n    }\n    else\n    {\n      ip = 1;\n    }\n\n    ncl[(ist + (26 * l)) - 1] = ii + 1;\n  }\n\n  if (ip > 0)\n    *irc = ncl[25 + (26 * l)];\n\n}\n\n", "pragma": "omp parallel for private(i,j,l,npoff,nboff,isum,ist,nh,ip,j1,ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/15"}
{"code": "for (i = 0; i < num_procs; i++)\n{\n  bucket_size[i] = (INT_TYPE *) alloc_mem((sizeof(INT_TYPE)) * (1 << 9));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/6"}
{"code": "for (i = 0; i < 400; i++)\n{\n  histogramT[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/5"}
{"code": "for (i = 1; i < numOfProcs; i++)\n{\n  MPI_Send(points, numOfPoints * numOfDimensions, MPI_DOUBLE, i, POINTS_TAG, MPI_COMM_WORLD);\n  MPI_Send(pointGroups, numOfPoints, MPI_INT, i, POINTS_GROUPS_TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danrol/Parallel_Perceptron_MPI_CUDA_openMP/CudaMPIOpenMP_onVDI/MPIAndOpenMPMethods/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    fprintf(stderr, DATA_PRINTF_MODIFIER, C[i][j]);\n    if ((i % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/utilities/template-for-new-benchmark/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    mat[i][j] = (rand() % 10) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maturocha/multiplication-matrix/src/openmp_multiplication/5"}
{"code": "for (int i = 1; i < nbv; i++)\n{\n  if (ec._Val[i] < ec._Val[imin])\n  {\n    imin = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/14"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  delete(result[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = 0;\n  m[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/required/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < (i + 1); j++)\n  {\n    double s = 0;\n    for (int k = 0; k < j; k++)\n      s += L[(i * n) + k] * L[(j * n) + k];\n\n    {\n      L[(i * n) + j] = (i == j) ? (sqrt(A[(i * n) + i] - s)) : ((1.0 / L[(j * n) + j]) * (A[(i * n) + j] - s));\n    }\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicoTolly/stage_openmp/cholesky/cholesky-for/0"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    user_matrix[i][j] = minus_one;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/8"}
{"code": "for (i = 0; i < ngtot; i++)\n{\n  arr_new[i] = arr_old[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/init/4"}
{"code": "for (i = iLeft; i <= iRight; i++)\n{\n  for (j = 1; j <= jmax; j++)\n  {\n    if (((i + j) % 2) != rb)\n    {\n      continue;\n    }\n\n    if (flag[i][j] == (C_F | B_NSEW))\n    {\n      p[i][j] = ((1. - omega) * p[i][j]) - (beta_2 * ((((p[i + 1][j] + p[i - 1][j]) * rdx2) + ((p[i][j + 1] + p[i][j - 1]) * rdy2)) - rhs[i][j]));\n    }\n    else\n      if (flag[i][j] & C_F)\n    {\n      beta_mod = (-omega) / (((eps_E + eps_W) * rdx2) + ((eps_N + eps_S) * rdy2));\n      p[i][j] = ((1. - omega) * p[i][j]) - (beta_mod * (((((eps_E * p[i + 1][j]) + (eps_W * p[i - 1][j])) * rdx2) + (((eps_N * p[i][j + 1]) + (eps_S * p[i][j - 1])) * rdy2)) - rhs[i][j]));\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(beta_mod)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/6"}
{"code": "for (unsigned int i = 1; i <= n; i++)\n{\n  for (unsigned int j = 2 - (i % 2); j <= n; j += 2)\n  {\n    x[j + ((n + 2) * i)] = (x0[j + ((n + 2) * i)] + (a * (((x[(j - 1) + ((n + 2) * i)] + x[(j + 1) + ((n + 2) * i)]) + x[j + ((n + 2) * (i - 1))]) + x[j + ((n + 2) * (i + 1))]))) / c;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo2a/solver/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    printf(\"%d\\t\", sum[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/matrix_sum/4"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 200; j++)\n  {\n    O[i][j] = 0;\n    for (k = 0; k < 200; k++)\n    {\n      O[i][j] = O[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/CAB401-OpenMP/matMult-comparison/0"}
{"code": "for (int p = 0; p < Population; p++)\n  solver.GetStateArr()[p] = ((float) (rand() % 20000)) - 10000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orthopteroid/psychic-sniffle/src/quadratic/main/0"}
{"code": "for (i = 0; i < arraysize; i++)\n{\n  serialsum = serialsum + array_A[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPforClause/4"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  A[(i * N) + j] = i + j;\n  B[(i * N) + j] = i - j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/Openmp/Mmul/1"}
{"code": "for (int col = OFFSET; col < (width - OFFSET); col++)\n{\n  for (int row = OFFSET; row < (height - OFFSET); row++)\n  {\n    int pixel_index = col + (row * width);\n    if ((((row == OFFSET) || (col == OFFSET)) || (col == ((width - OFFSET) - 1))) || (row == ((height - OFFSET) - 1)))\n    {\n      output_image[pixel_index] = 0;\n      continue;\n    }\n\n    switch (gradient_direction[pixel_index])\n    {\n      case 1:\n        if ((gradient_magnitude[pixel_index - 1] >= gradient_magnitude[pixel_index]) || (gradient_magnitude[pixel_index + 1] > gradient_magnitude[pixel_index]))\n        output_image[pixel_index] = 0;\n\n        break;\n\n      case 2:\n        if ((gradient_magnitude[pixel_index - (width - 1)] >= gradient_magnitude[pixel_index]) || (gradient_magnitude[pixel_index + (width - 1)] > gradient_magnitude[pixel_index]))\n        output_image[pixel_index] = 0;\n\n        break;\n\n      case 3:\n        if ((gradient_magnitude[pixel_index - width] >= gradient_magnitude[pixel_index]) || (gradient_magnitude[pixel_index + width] > gradient_magnitude[pixel_index]))\n        output_image[pixel_index] = 0;\n\n        break;\n\n      case 4:\n        if ((gradient_magnitude[pixel_index - (width + 1)] >= gradient_magnitude[pixel_index]) || (gradient_magnitude[pixel_index + (width + 1)] > gradient_magnitude[pixel_index]))\n        output_image[pixel_index] = 0;\n\n        break;\n\n      default:\n        output_image[pixel_index] = 0;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashsm79/parallel-canny-edge-detector/src/canny/2"}
{"code": "for (int i = 0; i < n; i++)\n  pthread_join(threads[i], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kielfriedt/Multithreading/Pthreads/Pthread_MatrixMult/2"}
{"code": "for (i = 0; i < n; i++)\n  norms[i] = gk_fdot(ptr[i + 1] - ptr[i], val + ptr[i], 1, val + ptr[i], 1);\n\n", "pragma": "omp parallel for if (ptr[n] > OMPMINOPS) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/13"}
{"code": "for (int i = start_index; i < finish_index; i++)\n{\n  sum += arr[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum) num_threads(num_threads)\t", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oboris/openMpDemoCPP/openMpDemo/Source/1"}
{"code": "for (i = 0; i < 16; i++)\n{\n  if (n != 6)\n    ++x;\n\n  n = i;\n}\n\n", "pragma": "omp parallel for num_threads (16) firstprivate (n) lastprivate (n) schedule (static, 1) reduction (+: x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr26943-1/0"}
{"code": "for (int i = 1; i < comSize; i++)\n{\n  MPI_Isend(startH, 9, (MPI_Datatype) 0x4c00080b, i, 10, 1, &sendHArray);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiannisKalopisis/Parallel-image-filter-convolution/src/Project_Parallhla/2"}
{"code": "for (i = 2; i < n; i++)\n{\n  for (j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      break;\n    }\n\n  }\n\n  if (i == j)\n  {\n    cnt++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) reduction(+:cnt)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adwaita1/OpenMP/prime/0"}
{"code": "for (i = 0; i < bwidth; i++)\n  for (j = 0; j < bwidth; j++)\n  for (k = 0; k < bwidth; k++)\n  *((C + (i * p)) + j) = (*((C + (i * p)) + j)) + ((*((A + (i * n)) + k)) * (*((B + (j * n)) + k)));\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/mmult/mm_funcs/4"}
{"code": "for (int iter = 0; iter < numOuterIters; iter++)\n{\n  {\n    threadNum = omp_get_thread_num();\n    numThreads = omp_get_num_threads();\n    if (1 == 1)\n      printf(\"Thread [%d] : iter = %d executing a chunk \\n\", threadNum, iter);\n\n    {\n      for (i = 0; i < m; i++)\n      {\n        y = ((((double) (i - 1)) * y_max) + (((double) (m - i)) * y_min)) / ((double) (m - 1));\n        for (j = 0; j < n; j++)\n        {\n          x = ((((double) (j - 1)) * x_max) + (((double) (n - j)) * x_min)) / ((double) (n - 1));\n          count[i][j] = 0;\n          x1 = x;\n          y1 = y;\n          for (k = 1; k <= count_max; k++)\n          {\n            x2 = ((x1 * x1) - (y1 * y1)) + x;\n            y2 = ((2 * x1) * y1) + y;\n            if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n            {\n              count[i][j] = k;\n              break;\n            }\n\n            x1 = x2;\n            y1 = y2;\n          }\n\n          if ((count[i][j] % 2) == 1)\n          {\n            r[i][j] = 255;\n            g[i][j] = 255;\n            b[i][j] = 255;\n          }\n          else\n          {\n            c = (int) (255.0 * sqrt(sqrt(sqrt(((double) count[i][j]) / ((double) count_max)))));\n            r[i][j] = (3 * c) / 5;\n            g[i][j] = (3 * c) / 5;\n            b[i][j] = c;\n          }\n\n        }\n\n      }\n\n    }\n  }\n}\n\n", "pragma": "omp for schedule(guided, chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/examples/appTwoFor_omp-lols/0"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  printf(\"%u -> %u \\n\", edgeList->edges_array_src[i], edgeList->edges_array_dest[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/11"}
{"code": "for (int j = k; j < N; j++)\n{\n  sumk_plus1 += ((j - k) + 5) * fabs((u[j] * u[j]) / (d[j] - lambda_j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Secular_Equation_Solvers_In_OpenMP/gragg/15"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x;\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/2-integral/IntegralParallel_v4/IntegralParallel_v4/Origem/0"}
{"code": "for (int j_x = 0; j_x < num_x_global_pts; j_x++)\n{\n  x_curr = x_left + (dx * (1 + j_x));\n  potential_future = linear_potential_func(x_curr, dimensional_frequency) + (potential_scaling * (g_coeff * pow(cabs(z_psi_future_approx[j_x]), 2.0)));\n  za_main_diag_l[j_x] = (((double) 1.0) + (((double) 2.0) * z_alpha)) + (z_beta * potential_future);\n}\n\n", "pragma": "omp parallel for private(x_curr, potential_future)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-richards/HPC_Code/3d_hybrid/1"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = i; j < (2 * N); j++)\n  {\n    tmpsum += (j + cos(x + j)) / (((2 * i) * j) - 1);\n  }\n\n  sum += 1 / tmpsum;\n  tmpsum = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/15"}
{"code": "for (long i = 0; i < n; i++)\n{\n  R[i] = 0;\n  for (long j = 0; j < m; j++)\n  {\n    R[i] += V[j] * A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task8/4"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < n; i++)\n  {\n    rhs[i] += a[i + (j * n)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/8"}
{"code": "for (i = 0; i < str_len; ++i)\n{\n  encoded[i] = rotations[i][str_len - 1];\n  free(rotations[i]);\n}\n\n", "pragma": "omp parallel for shared(i,str_len,rotations,encoded) schedule(static) num_threads(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DragosUnguru/ParallelFrameworksAnalyze/parallel_encoder/1"}
{"code": "for (i = 0; i < (*size); i++)\n{\n  scanf(\"%d\", &data[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IdoZada/Parallel_Programs/cFunctions/3"}
{"code": "for (int i = 0; i < 4; i++)\n  arr[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/array/main/0"}
{"code": "for (int i = startGene; i < endGene; ++i)\n{\n  child.cities.push_back(p1.cities[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/6"}
{"code": "for (int t = time_m; t <= time_M; t++)\n  for (int x = x_m; x <= x_M; x++)\n  for (int y = y_m; y <= y_M; y++)\n  for (int z = z_m; z <= z_M; z++)\n  printf(\"%d \", u[t][x][y][z]);\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/devito_prob1/devito_prob1/2"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testnextWhole(80000000000, i);\n  printf(\"testnextWho | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc(), stop(), stopt() / 8e10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/2"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  MPI_Send(&simple, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/7"}
{"code": "for (i = 0; i < n; i++)\n  for (j = i; j < n; j++)\n  A[i][j] = generateNumber();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Backward-Substitution/parallel/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = 9;\n}\n\n", "pragma": "omp for schedule(dynamic,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/subteam2/1"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  double ee = (s1->U[i] - s2->U[i]) * (s1->U[i] - s2->U[i]);\n  if (s1->s_is_c)\n    ee += (s1->C[i] - s2->C[i]) * (s1->C[i] - s2->C[i]);\n\n  if (s1->s_is_t)\n    ee += (s1->T[i] - s2->T[i]) * (s1->T[i] - s2->T[i]);\n\n  err += ee;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/165"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    for (k = 0; k < N; k++)\n    {\n      ans++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ami-GS/openMP_practice/collaps/0"}
{"code": "for (i = 1; i < n; i++)\n{\n  x = rand();\n  x = x / 32767;\n  x = x1 + (x * (x2 - x1));\n  y = rand();\n  y = y / 32767;\n  y = y1 + (y * (y2 - y1));\n  SqPoints++;\n  if (sqrt((x * x) + (y * y)) <= 1.0)\n  {\n    CiPoints++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UniversityProjects/Cineca_Parallel_Computing/OpenMP_Code/pi_monte_carlo/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    double temp = m_get_val(I, i, j);\n    if (temp > Imax)\n    {\n      Imax = temp;\n    }\n    else\n      if (temp < Imin)\n    {\n      Imin = temp;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/leukocyte/OpenMP/track_ellipse.ref/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (var[i] != i)\n  {\n    printf(\"Data Race Present\");\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB155-missingordered-orig-gpu-no/2"}
{"code": "for (it = 0; it <= STEPS; it++)\n{\n  MPI_Startall(4, reqs_send[old]);\n  MPI_Startall(4, reqs_rcv[old]);\n  for (i = xoffset + 2; i < (xoffset + myxsize); i++)\n  {\n    for (j = yoffset + 2; j < (yoffset + myysize); j++)\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  MPI_Waitall(4, reqs_rcv[old], (MPI_Status *) 1);\n  start = xoffset + 1;\n  end = (xoffset + myxsize) + 1;\n  for (i = start; i < end; i++)\n  {\n    j = yoffset + 1;\n    if (((((i - 1) != 0) && (i != 20)) && ((j - 1) != 0)) && (j != 20))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n    j = yoffset + myysize;\n    if (((((i - 1) != 0) && (i != 20)) && ((j - 1) != 0)) && (j != 20))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  start = yoffset + 2;\n  end = yoffset + myysize;\n  for (j = start; j < end; j++)\n  {\n    i = xoffset + 1;\n    if (((((i - 1) != 0) && (i != 20)) && ((j - 1) != 0)) && (j != 20))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n    i = xoffset + myxsize;\n    if (((((i - 1) != 0) && (i != 20)) && ((j - 1) != 0)) && (j != 20))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  MPI_Waitall(4, reqs_send[old], (MPI_Status *) 1);\n  old = 1 - old;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/9"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm512_set1_epi32(noff);\n  v_moff = _mm512_set1_epi32(moff);\n  v_loff = _mm512_set1_epi32(loff);\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  v_edgelx = _mm512_set1_ps(edgelx);\n  v_edgely = _mm512_set1_ps(edgely);\n  v_edgelz = _mm512_set1_ps(edgelz);\n  v_edgerx = _mm512_set1_ps(edgerx);\n  v_edgery = _mm512_set1_ps(edgery);\n  v_edgerz = _mm512_set1_ps(edgerz);\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  nps = 4 * (nn / 4);\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &fxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &fxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sfxyz[m], v_at);\n        _mm512_packstorehi_ps(&sfxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &bxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &bxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sbxyz[m], v_at);\n        _mm512_packstorehi_ps(&sbxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  memset((void *) (&ncl[26 * l]), 0, 26 * (sizeof(int)));\n  nps = 16 * (npp / 16);\n  sum1 = 0.0;\n  v_sum1 = _mm512_set1_pd(0.0);\n  for (j = 0; j < nps; j += 16)\n  {\n    v_x = _mm512_load_ps(&ppart[j + npoff]);\n    v_y = _mm512_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_z = _mm512_load_ps(&ppart[(j + (2 * nppmx)) + npoff]);\n    v_nn = _mm512_cvtfxpnt_round_adjustps_epi32(v_x, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_mm = _mm512_cvtfxpnt_round_adjustps_epi32(v_y, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_ll = _mm512_cvtfxpnt_round_adjustps_epi32(v_z, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_nn, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_sub_ps(v_x, v_dxp);\n    v_dyp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_mm, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dyp = _mm512_sub_ps(v_y, v_dyp);\n    v_dzp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_ll, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dzp = _mm512_sub_ps(v_z, v_dzp);\n    v_nn = _mm512_sub_epi32(v_nn, v_noff);\n    v_mm = _mm512_sub_epi32(v_mm, v_moff);\n    v_ll = _mm512_sub_epi32(v_ll, v_loff);\n    v_it = _mm512_mullo_epi32(v_mxyv4, v_ll);\n    v_it = _mm512_add_epi32(v_it, _mm512_mullo_epi32(v_mxv4, v_mm));\n    v_nm = _mm512_add_epi32(_mm512_slli_epi32(v_nn, 2), v_it);\n    v_amx = _mm512_sub_ps(v_one, v_dxp);\n    v_amy = _mm512_sub_ps(v_one, v_dyp);\n    v_amz = _mm512_sub_ps(v_one, v_dzp);\n    v_dx1 = _mm512_mul_ps(v_dxp, v_dyp);\n    v_dyp = _mm512_mul_ps(v_amx, v_dyp);\n    v_amx = _mm512_mul_ps(v_amx, v_amy);\n    v_amy = _mm512_mul_ps(v_dxp, v_amy);\n    _mm512_store_epi32(kk, v_nm);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_mul_ps(v_amx, a);\n    v_dx = _mm512_fmadd_ps(v_amy, p, v_dx);\n    v_dy = _mm512_mul_ps(v_amx, b);\n    v_dy = _mm512_fmadd_ps(v_amy, q, v_dy);\n    v_dz = _mm512_mul_ps(v_amx, c);\n    v_dz = _mm512_fmadd_ps(v_amy, r, v_dz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_fmadd_ps(v_dyp, a, v_dx);\n    v_dx = _mm512_fmadd_ps(v_dx1, p, v_dx);\n    v_dx = _mm512_mul_ps(v_amz, v_dx);\n    v_dy = _mm512_fmadd_ps(v_dyp, b, v_dy);\n    v_dy = _mm512_fmadd_ps(v_dx1, q, v_dy);\n    v_dy = _mm512_mul_ps(v_amz, v_dy);\n    v_dz = _mm512_fmadd_ps(v_dyp, c, v_dz);\n    v_dz = _mm512_fmadd_ps(v_dx1, r, v_dz);\n    v_dz = _mm512_mul_ps(v_amz, v_dz);\n    v_nn = _mm512_add_epi32(v_nm, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_dx = _mm512_fmadd_ps(v_dzp, v_vx, v_dx);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_dy = _mm512_fmadd_ps(v_dzp, v_vy, v_dy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_dz = _mm512_fmadd_ps(v_dzp, v_vz, v_dz);\n    _mm512_store_epi32(kk, v_nm);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_ox = _mm512_mul_ps(v_amx, a);\n    v_ox = _mm512_fmadd_ps(v_amy, p, v_ox);\n    v_oy = _mm512_mul_ps(v_amx, b);\n    v_oy = _mm512_fmadd_ps(v_amy, q, v_oy);\n    v_oz = _mm512_mul_ps(v_amx, c);\n    v_oz = _mm512_fmadd_ps(v_amy, r, v_oz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_ox = _mm512_fmadd_ps(v_dyp, a, v_ox);\n    v_ox = _mm512_fmadd_ps(v_dx1, p, v_ox);\n    v_ox = _mm512_mul_ps(v_amz, v_ox);\n    v_oy = _mm512_fmadd_ps(v_dyp, b, v_oy);\n    v_oy = _mm512_fmadd_ps(v_dx1, q, v_oy);\n    v_oy = _mm512_mul_ps(v_amz, v_oy);\n    v_oz = _mm512_fmadd_ps(v_dyp, c, v_oz);\n    v_oz = _mm512_fmadd_ps(v_dx1, r, v_oz);\n    v_oz = _mm512_mul_ps(v_amz, v_oz);\n    v_nn = _mm512_add_epi32(v_nm, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sbxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sbxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sbxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sbxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_ox = _mm512_fmadd_ps(v_dzp, v_vx, v_ox);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_oy = _mm512_fmadd_ps(v_dzp, v_vy, v_oy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_oz = _mm512_fmadd_ps(v_dzp, v_vz, v_oz);\n    v_dx = _mm512_mul_ps(v_dx, v_qtmh);\n    v_dy = _mm512_mul_ps(v_dy, v_qtmh);\n    v_dz = _mm512_mul_ps(v_dz, v_qtmh);\n    a = _mm512_add_ps(v_dx, _mm512_load_ps(&ppart[(j + (3 * nppmx)) + npoff]));\n    b = _mm512_add_ps(v_dy, _mm512_load_ps(&ppart[(j + (4 * nppmx)) + npoff]));\n    c = _mm512_add_ps(v_dz, _mm512_load_ps(&ppart[(j + (5 * nppmx)) + npoff]));\n    v_at = _mm512_fmadd_ps(b, b, _mm512_mul_ps(a, a));\n    v_at = _mm512_fmadd_ps(c, c, v_at);\n    v_gami = _mm512_sqrt_ps(_mm512_fmadd_ps(v_at, v_ci2, v_one));\n    v_gami = _mm512_div_ps(v_one, v_gami);\n    v_at = _mm512_mul_ps(v_gami, v_at);\n    v_at = _mm512_div_ps(v_at, _mm512_add_ps(v_one, v_gami));\n    v_sum1 = _mm512_add_pd(v_sum1, _mm512_cvtpslo_pd(v_at));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_at, 78));\n    v_sum1 = _mm512_add_pd(v_sum1, v_d);\n    v_at = _mm512_mul_ps(v_qtmh, v_gami);\n    e = _mm512_mul_ps(v_at, v_ox);\n    f = _mm512_mul_ps(v_at, v_oy);\n    g = _mm512_mul_ps(v_at, v_oz);\n    v_vx = _mm512_mul_ps(e, e);\n    v_vy = _mm512_mul_ps(f, f);\n    v_vz = _mm512_mul_ps(g, g);\n    v_at = _mm512_add_ps(_mm512_add_ps(v_vx, v_vy), v_vz);\n    d = _mm512_div_ps(v_two, _mm512_add_ps(v_one, v_at));\n    h = _mm512_mul_ps(v_half, _mm512_sub_ps(v_one, v_at));\n    v_vx = _mm512_mul_ps(_mm512_add_ps(h, v_vx), a);\n    v_vy = _mm512_mul_ps(_mm512_add_ps(h, v_vy), b);\n    v_vz = _mm512_mul_ps(_mm512_add_ps(h, v_vz), c);\n    h = _mm512_mul_ps(e, f);\n    v_vx = _mm512_fmadd_ps(_mm512_add_ps(h, g), b, v_vx);\n    v_vy = _mm512_fmadd_ps(_mm512_sub_ps(h, g), a, v_vy);\n    h = _mm512_mul_ps(e, g);\n    v_vx = _mm512_fmadd_ps(_mm512_sub_ps(h, f), c, v_vx);\n    v_vz = _mm512_fmadd_ps(_mm512_add_ps(h, f), a, v_vz);\n    h = _mm512_mul_ps(f, g);\n    v_vy = _mm512_fmadd_ps(_mm512_add_ps(h, e), c, v_vy);\n    v_vz = _mm512_fmadd_ps(_mm512_sub_ps(h, e), b, v_vz);\n    v_vx = _mm512_fmadd_ps(v_vx, d, v_dx);\n    v_vy = _mm512_fmadd_ps(v_vy, d, v_dy);\n    v_vz = _mm512_fmadd_ps(v_vz, d, v_dz);\n    v_at = _mm512_fmadd_ps(v_vy, v_vy, _mm512_mul_ps(v_vx, v_vx));\n    v_at = _mm512_fmadd_ps(v_vz, v_vz, v_at);\n    v_at = _mm512_sqrt_ps(_mm512_fmadd_ps(v_at, v_ci2, v_one));\n    v_at = _mm512_div_ps(v_dtc, v_at);\n    v_dx = _mm512_fmadd_ps(v_vx, v_at, v_x);\n    v_dy = _mm512_fmadd_ps(v_vy, v_at, v_y);\n    v_dz = _mm512_fmadd_ps(v_vz, v_at, v_z);\n    v_mm = _mm512_setzero_epi32();\n    msk1 = _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dx;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_1, v_1);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dx, v_anx, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dx, v_anx);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_1);\n        msk2 = _mm512_cmp_ps_mask(v_dx, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dx, v_anx);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anx, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dy;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_3, v_3);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dy, v_any, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dy, v_any);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_3);\n        msk2 = _mm512_cmp_ps_mask(v_dy, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dy, v_any);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_any, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dz;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_9, v_9);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dz, v_anz, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dz, v_anz);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_9);\n        msk2 = _mm512_cmp_ps_mask(v_dz, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dz, v_anz);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anz, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n    }\n\n    _mm512_store_ps(&ppart[j + npoff], v_dx);\n    _mm512_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm512_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_dz);\n    _mm512_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vx);\n    _mm512_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vy);\n    _mm512_store_ps(&ppart[(j + (5 * nppmx)) + npoff], v_vz);\n    _mm512_store_epi32(kk, v_mm);\n    for (i = 0; i < 16; i++)\n    {\n      mm = kk[i];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + i) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = dx + ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm);\n    vy = dy + ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm);\n    vz = dz + ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm);\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  _mm512_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,ii,noff,moff,loff,npp,npoff,nps,nn,mm,ll,nm,ih,nh,x, y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz, omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, edgelx,edgely,edgelz,edgerx,edgery,edgerz,p2,gami,qtmg,dtg,sum1,v_noff, v_moff,v_loff,v_nn,v_mm,v_ll,v_nm,v_it,v_x,v_y,v_z,v_dxp,v_dyp,v_dzp, v_amx,v_amy,v_amz,v_dx1,v_dx,v_dy,v_dz,v_vx,v_vy,v_vz,v_ox,v_oy,v_oz, v_gami,v_at,v_edgelx,v_edgely,v_edgelz,v_edgerx,v_edgery,v_edgerz,v_d, v_sum1,a,b,c,d,e,f,g,h,p,q,r,s,msk1,msk2,kk,dd,sfxyz,sbxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/3"}
{"code": "for (i = m - 1; i <= (m + 1); i += 2)\n{\n  for (j = n - 1; j <= (n + 1); j++)\n  {\n    if (matrix[(i * col) + j] == 1)\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielevensen/Conways-Game-of-Life/version4/1"}
{"code": "for (k = 1; k <= NC; k++)\n{\n  t[*new][1][k] = 0.25 * (((t[old][2][k] + t[old][0][k]) + t[old][1][k + 1]) + t[old][1][k - 1]);\n  t[*new][nrl][k] = 0.25 * (((t[old][nrl + 1][k] + t[old][nrl - 1][k]) + t[old][nrl][k + 1]) + t[old][nrl][k - 1]);\n  d = (fabs(t[*new][1][k] - t[old][1][k]) > d) ? (fabs(t[*new][1][k] - t[old][1][k])) : (d);\n  d = (fabs(t[*new][nrl][k] - t[old][nrl][k]) > d) ? (fabs(t[*new][nrl][k] - t[old][nrl][k])) : (d);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/12"}
{"code": "for (i = 0; i < (nmol - 1); i++)\n{\n  for (j = i + 1; j < nmol; j++)\n  {\n    energy = energy + energy12(i, j);\n    npairs++;\n  }\n\n}\n\n", "pragma": "omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Energy-Calculation-for-a-box-of-water-molecules/waters_openmp/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  z[i] = y;\n}\n\n", "pragma": "omp for firstprivate(y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.24.1/0"}
{"code": "for (j = 1; j < numOfProcs; j++)\n{\n  MPI_Send(allClusters, numOfClusters, ClusterMPIType, j, MASTER, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result[i][j] = A[i][j] - B[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frank11158/PL_Matrix_Multiplication/Strassen/Strassen/4"}
{"code": "for (i = 0; i < row_each; i++)\n  MPI_Recv(local_arr[i], 4, (MPI_Datatype) 0x4c000405, 0, -1, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/matrix-dot-product/hybridparallel/11"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  foo();\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/sections_messages/0"}
{"code": "for (int i = 0; i < size; i++)\n  suma[i] = vect1[i] + vect2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/7"}
{"code": "for (index = 0; index < count; index++)\n{\n  generate_hash((unsigned char *) saved_key[index], saved_salt, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/SybasePROP_fmt_plug/0"}
{"code": "for (i = 0; i < EMISSION_COLS; i++)\n  free(abMat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/20"}
{"code": "for (int i = 0; i < 30; i++)\n{\n  if (a[i] == 1)\n  {\n    decimal += 1 << i;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+: decimal)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dimanaux/itis-omp/13/0"}
{"code": "for (int to = 0; to < vertices; to++)\n{\n  if (((from != to) && (from != via)) && (to != via))\n  {\n    dist[from][to] = min(dist[from][to], dist[from][via] + dist[via][to]);\n  }\n\n}\n\n", "pragma": "                  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahzebp/floyd_warshall_parallel/openmp/iterative1/1"}
{"code": "for (i = 1; i < (matrix.rows + 1); i++)\n{\n  int elements = matrix.ia[i] - matrix.ia[i - 1];\n  if (elements == 0)\n  {\n    continue;\n  }\n\n  int pos = matrix.ia[i - 1];\n  while ((pos - matrix.ia[i - 1]) <= elements)\n  {\n    if (matrix.ja[pos] == (i - 1))\n    {\n      trace += matrix.nnz.f[pos];\n      break;\n    }\n    else\n      if (matrix.ja[pos] > (i - 1))\n    {\n      break;\n    }\n\n\n    pos++;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:trace) shared(matrix) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/3"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  printf(\"Entrez le coefficient a(%d,%d)=\", i + 1, j + 1);\n  scanf(\"%lf\", &a[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BorhaneddineHamadou/Gausse-Jordan-Algorithm/openmp/2"}
{"code": "for (i = 0; i < n; i++)\n  B[i] = (double *) calloc(n, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/1"}
{"code": "for (int jj = 0; jj < _chunk.y; ++jj)\n{\n  for (int kk = 0; kk < _chunk.x; ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    p[index] = 0.0;\n    r[index] = 0.0;\n    u[index] = energy[index] * density[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_cg_kernel/0"}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  if (last_threadnr == tids[i])\n  {\n    determined_chunksize++;\n  }\n  else\n  {\n    chunksizes[global_chunknr] = determined_chunksize;\n    global_chunknr++;\n    local_chunknr[last_threadnr]++;\n    last_threadnr = tids[i];\n    determined_chunksize = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_guided/2"}
{"code": "for (i = 0; i < len; i++)\n{\n  ipad[index][i] ^= key[i];\n  opad[index][i] ^= key[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/hmacMD5_fmt_plug/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  vec[i] = size - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pengjintao/OpenMP/07_odd_even_sort/0"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%d\\t%lld\\n\", i, fibo[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_fibo/1"}
{"code": "for (int k = 0; k < WEEK_ARRAY_DIM; k++)\n{\n  temp->weekAccidentsCounter[k] += iter->second->weekAccidentsCounter[k];\n  temp->weekLethal[k] += iter->second->weekLethal[k];\n}\n\n", "pragma": "\t\t\t\t#pragma omp parallel for shared(temp, iter)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/borough/2"}
{"code": "for (i = 0; i < subprob_size; i++)\n  slcbuff[i] = a[i][subprob_size - 1];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/6"}
{"code": "for (k = 0; k < SIZE; k++)\n{\n  for (i = k + 1; i < SIZE; i++)\n  {\n    l[i][k] = u[i][k] / u[k][k];\n    for (j = k; j < SIZE; j++)\n    {\n      u[i][j] = u[i][j] - (l[i][k] * u[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/Matrix-inverse-LUP/inverse_non_parallelized/1"}
{"code": "for (unsigned int i = 0; i < my_list.size(); i++)\n{\n  my_list.attr(\"pop\")();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DemStructuresCouplingApplication/custom_utilities/post_process_utilities/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  h_c[i] = h_a[i] + h_b[i];\n}\n\n", "pragma": "omp parallel for num_threads (4) schedule (dynamic, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-multiple-omp-parallel-for-combined-schedule-dynamic-chunk-value/1"}
{"code": "for (int i = 0; i < n; i++)\n  rsum += f((i + s) * deltaX) * deltaX;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/USING-OPENMP/riemman_sum/1"}
{"code": "for (i = 0; i < (*h); i++)\n{\n  for (j = 0; j < (*w); j++)\n  {\n    if (j == ((*w) - 1))\n      fscanf(f, \"%hhu %hhu %hhu\\n\", &rgb[(i * (*w)) + j].red, &rgb[(i * (*w)) + j].green, &rgb[(i * (*w)) + j].blue);\n    else\n      fscanf(f, \"%hhu %hhu %hhu\\t\", &rgb[(i * (*w)) + j].red, &rgb[(i * (*w)) + j].green, &rgb[(i * (*w)) + j].blue);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wutaosamuel/mosaic_OpenMP-CUDA/src/mosaic/5"}
{"code": "for (x = 0; x < ((512 * 512) * 128); x++)\n{\n  input_array[x] = x % 2048;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adiggo/openmp/source/filterOP/3"}
{"code": "for (i = 0; i < max; i++)\n{\n  oldPageRank[i] = newPageRank[i];\n}\n\n", "pragma": "            #pragma omp for schedule (static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srinivasbalaji-1/openmpProject/facebookEgo/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  s += i + 1;\n  f += i + 1.0f;\n}\n\n", "pragma": "omp simd for reduction(+:s,t)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/success_simd_07_reduction_parallel/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_merge_sort1(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting(optimized) of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/6"}
{"code": "for (int i = 0; i < n_threads; i++)\n{\n  if (pthread_create(&pool.threads[i], 0, start_routine, &pool))\n    return -1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dunder-Muffin/parallelProgramming/problem5/run/2"}
{"code": "for (int i = 0; i < (nx + 2); i++)\n{\n  temperature(i, 0) = 20.0;\n  temperature(i, ny + 1) = 70.0;\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/hybrid/heat-equation/cpp/solution-coarse/heat/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  cin >> val[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/OddEvenSorting/1"}
{"code": "for (int n = 0; n < ITERATION; n++)\n{\n  for (int i = 0; i < num; i++)\n  {\n    present_rounds(h_plain + (i * 8), h_key + (i * 10), rounds, h_cipher + (i * 8));\n    for (int k = 0; k < 8; k++)\n      h_checksum += h_cipher[(i * 8) + k];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/present-omp/main/2"}
{"code": "for (i = 0; i < n; i++)\n  x[i] = 1.0;\n\n", "pragma": "omp parallel for shared(n) num_threads(thread)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thesaurabhkumar/ParallelDenseMatrixOpenMP/Submission/matrix_par/6"}
{"code": "for (int ij = 0; ij < (n * n); ++ij)\n{\n  int i = ij / n;\n  int j = ij % n;\n  b[i] = vec[i];\n  A[i][j] = matr[i][j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/3"}
{"code": "for (int i = 0; i < k; i++)\n{\n  genes_length[i] = genes[i].length();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel1/3"}
{"code": "for (int i = 1; i < (DIM - 1); i++)\n  for (int j = 1; j < (DIM - 1); j++)\n  cur_img(i, j) = (random() & 01) ? (couleur) : (0);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/13"}
{"code": "for (i = 2147483647; i >= (-2000000000); i -= 50000000)\n{\n  b_known_value++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/worksharing/for/omp_for_bigbounds/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  timeStart = omp_get_wtime();\n  AxB(masA, M, N, masB, N, K, masC);\n  timeEnd = omp_get_wtime();\n  time += timeEnd - timeStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/Matr/2"}
{"code": "for (int k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    yvel0[FTNREF2D(1 - j, k, x_max + 5, x_min - 2, y_min - 2)] = yvel0[FTNREF2D(1 + j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/38"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a = ((double) rand()) / 1000000;\n    matA[i][j] = a;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KasunEdward/OpenMP_Project/OV_Parallel/8"}
{"code": "for (i = 0; i < limit; i++)\n{\n  if ((burst_time[i] >= max_val) && (arrival_time[i] <= time))\n  {\n    smallest = i;\n    max_val = burst_time[smallest];\n  }\n\n}\n\n", "pragma": "omp parallel for shared(i) reduction(max : max_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shanky1947/Parallel-Job-Scheduling-Algorithms-using-OpenMP/LJF_Parallel/0"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n{\n  printf(\"%g\", A[i * M]);\n  for (j = 1; j < M; j++)\n  {\n    printf(\" %g\", A[(i * M) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/7"}
{"code": "for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixin/0"}
{"code": "for (i = 0; i < size; i++)\n  a[i] = malloc(size * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/matrix_sum_omp/1"}
{"code": "for (i = 1, len2 = 0; i <= m; i++)\n{\n  char c = seq_array[sj + 1][i];\n  if ((c != gap_pos1) && (c != gap_pos2))\n    len2++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/alignment/src/alignment_ompi/1"}
{"code": "for (int i = 0; i < N; i++)\n  printf(\"%d \", host_arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/device_ptr/main/1"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      const int index = (((ii * _chunk.x) * _chunk.y) + (jj * _chunk.x)) + kk;\n      const double smvp = SMVP(u);\n      w[index] = smvp;\n      r[index] = u0[index] - w[index];\n      p[index] = r[index] / (*theta);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_cheby_kernel/1"}
{"code": "for (int i = 0; i < maxIter; i++)\n{\n  kMeansIteration();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucabindini/KMeansClustering_OpenMP/KMeans/2"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  out_degree = graph->inverse_vertices[v].out_degree;\n  if (graph->parents[v] < 0)\n  {\n    edge_idx = graph->inverse_vertices[v].edges_idx;\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      u = graph->inverse_sorted_edges_array[j].dest;\n      if (getBit(bitmapCurr, u))\n      {\n        graph->parents[v] = u;\n        setBitAtomic(bitmapNext, v);\n        nf++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(out_degree,edge_idx,u,j) reduction(+:nf)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shreyas097/Parallel-BFS-with-Push-Pull-operation-using-queue-bitmap-using-OpenMP/code/src/bfs/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum = 0.0;\n  for (j = 0; j <= i; j++)\n    sum = sum + (x[j] * a[i][j]);\n\n  if (fabsf(sum - b[i]) > 0.00001)\n  {\n    printf(\"%f != %f\\n\", sum, b[i]);\n    printf(\"Validation Failed...\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SotirisSotiriou/high-performance-computing/OpenMP/backsub/backsub_parallel/3"}
{"code": "for (int i = 0; i < 12; ++i)\n{\n  if (i == 0)\n    printf(\"Number of threads: %d\\n\", omp_get_num_threads());\n\n  c[i] = a[i] + b[i];\n  printf(\"Thread #%d: \\t c[%d]=%d \\n\", omp_get_thread_num(), i, i, c[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task7/1"}
{"code": "for (int i = 0; i < threadsCount; i++)\n{\n  iterationCount[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/karlosos/obliczenia_wielkiej_mocy/lab_7_mandelbrot_openmp/openmp/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  j = 3 * bv[i];\n  Ce[j] = Ce[j] + (((prop->cs * prop->den) * area) / 3.0);\n  Ce[j + 1] = Ce[j + 1] + (((prop->cs * prop->den) * area) / 3.0);\n  Ce[j + 2] = Ce[j + 2] + (((prop->cp * prop->den) * area) / 3.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/17"}
{"code": "for (i = 0; i < n; ++i)\n  scanf(\"%d \", &x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/BubbleSort/main/1"}
{"code": "for (int i = 0; i < vec.size(); i++)\n  vec[i] = RAND_FLOAT();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchParallel/3"}
{"code": "for (i = 1; i < max; i++)\n{\n  for (j = i; j < max; j++)\n  {\n    a = a + (((double) (i + j)) / ((double) (i * j)));\n  }\n\n}\n\n", "pragma": "omp for reduction(+:a) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter5/fs/0"}
{"code": "for (i = 0; i < 4096; i++)\n  for (j = 0; j < 4096; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc/matmult-toy/matmult-toy/1"}
{"code": "for (int i = 0; i < NB; i++)\n  for (int j = 0; j < BS; j++)\n  Om[(1 + (i * BS)) + j] += (mult * Da) * time_summing(i, j, old, U_);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/88"}
{"code": "for (j = 13; j >= 1; j--)\n{\n  if (size[j] == '.')\n  {\n    size[j] = ' ';\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/EP/ep/1"}
{"code": "for (int i = 1; i < mpi_tot_id; i++)\n  MPI_Recv(&g_bodies[shares[i].first], (shares[i].second - shares[i].first) * 7, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/mpi+openmp/src/nbody_mpi+openmp/5"}
{"code": "for (i = 0; i < nRegions; i++)\n{\n  matrix_delete(regions[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/10"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  jsum = 0;\n  for (j = 0; j < numParticles; j++)\n  {\n    if (i == j)\n      continue;\n\n    jsum += calcDistanceInverseSquared(p[i], p[j]);\n  }\n\n  isum += jsum / (numParticles - 1);\n}\n\n", "pragma": "omp for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/8"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = malloc(sizeof(payload));\n  data->present = 1;\n  data->in_mis = 0;\n  data->r = 0;\n  cur->data = data;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mis/4"}
{"code": "for (i = 0; i < simu_opts->numKD; i++)\n{\n  sprintf(KDIDname, \"%d\", simu_opts->KDID[i]);\n  strcat(fsname[cnt - 1], \"_\");\n  strcat(fsname[cnt - 1], KDIDname);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/57"}
{"code": "for (int i = 0; i < NUM_THREADS; ++i)\n{\n  thread_range[i].first = _str;\n  thread_range[i].second = (_str += div + ((rem--) > 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/gauss_elim/4"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = i; j < n; ++j)\n  {\n    ltm[j][i] = mat[j][i];\n    for (int k = 0; k < i; ++k)\n    {\n      ltm[j][i] -= ltm[j][k] * utm[k][i];\n    }\n\n  }\n\n  utm[i][i] = 1;\n  for (int j = i + 1; j < n; ++j)\n  {\n    utm[i][j] = mat[i][j];\n    for (int k = 0; k < i; ++k)\n    {\n      utm[i][j] -= ltm[i][k] * utm[k][j];\n    }\n\n    utm[i][j] /= ltm[i][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/4"}
{"code": "for (i = 0; i < dim; i++)\n{\n  vec[i] = ((double) rand()) / ((double) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc1/matmul/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  A[i] = i & 3;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/4"}
{"code": "for (int i = 0; i < (MAX * MAX); i++)\n{\n  a.push_back(rand() % 15);\n  b.push_back(rand() % 20);\n  c.push_back(rand() % 30);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/ordered/0"}
{"code": "for (int i = 0; i < 992; i++)\n  pA[i] = (pC[i] + pD[i]) + omp_is_initial_device();\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/nt-target-map-ptr/test/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/139"}
{"code": "for (i = 0; i < N; i++)\n  S += c[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoecheverria/openmp-lab/masterOMP/9"}
{"code": "for (int iCell = 1; iCell <= nCells; ++iCell)\n{\n  int id = (int) m_routingLayers[iLayer][iCell];\n  FlowInSoil(id);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/IKW_IF/InterFlow_IKW/2"}
{"code": "for (i = 0; i < BLOWFISH_ROUNDS; ++i)\n{\n  Xl = Xl ^ P[i];\n  Xr = F(S, Xl) ^ Xr;\n  temp = Xl;\n  Xl = Xr;\n  Xr = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zagorskid/blowfish-omp/blowfish-omp/blowfish-omp/0"}
{"code": "for (i = 0; i < rows; ++i)\n{\n  for (j = 0; j < columns; ++j)\n  {\n    board[i][j] = (rand() % 2) ? (' ') : ('x');\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bernardoduarte/PPD/OpenMP/assignments/02_game_of_life/prog/3"}
{"code": "for (i = 0; i < k; i++)\n{\n  buffer[i] = i;\n  buffer_values[i] = v_scores[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/4"}
{"code": "for (size_t i = 0; i < num_threads; ++i)\n{\n  file_id_map.insert(file_id_maps[i].begin(), file_id_maps[i].end());\n  dictionary.insert(dictionaries[i].begin(), dictionaries[i].end());\n  file_word_count_map.insert(word_count_maps[i].begin(), word_count_maps[i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/colby-j-wise/cpptext/src/processor/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (!((a_arr[i] == b_arr[i]) && (a_arr[i] == c_arr[i])))\n  {\n    ok = false;\n    break;\n  }\n\n  printf(\"%f\\t%f\\t%f\\n\", a_arr[i], b_arr[i], c_arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gitsebste/openmpDoubleintegral/doubleIntegral/doubleIntegral/doubleIntegral/3"}
{"code": "for (int i = 0; i < ROWS_A; i++)\n  for (int j = 0; j < COLUMNS_A; j++)\n  A[i][j] = (((double) rand()) / RAND_MAX) + 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/p3732/HybridModelsOnClusters/MM_MPI_opemp_hybrid/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 100; j++)\n  {\n    WL2[i][j] += WL2delta[i][j] / 10000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn06/6"}
{"code": "for (unsigned int i = 0; i < (2048 / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < 2048; j++)\n  {\n    spin_old = write[i][j];\n    spin_neigh_x = read[i][j];\n    spin_neigh_y = read[i][((j + 1) + 2048) % 2048];\n    spin_neigh_z = read[i][((j - 1) + 2048) % 2048];\n    spin_neigh_w = read[((i + ((2 * (color ^ (j % 2))) - 1)) + (2048 / 2)) % (2048 / 2)][j];\n    h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n    spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n    h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n    delta_E = h_after - h_before;\n    float p = rand_MWC_co(&x_l, &a_l);\n    if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n    {\n      write[i][j] = spin_new;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/0"}
{"code": "for (int i = 0; i < (size * size); i++)\n{\n  A[i] = rand() / (RAND_MAX / 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/lu-utils/2"}
{"code": "for (unsigned int i = 0; i < n_nodal_neighs; ++i)\n{\n  for (unsigned int d = 0; d < n_relevant_terms; ++d)\n  {\n    if (mCalculatingGradientAndLaplacian)\n    {\n      if (d > 2)\n      {\n        normalization = h_inv * h_inv;\n      }\n      else\n      {\n        normalization = h_inv;\n      }\n\n    }\n\n    nodal_weights((n_relevant_terms * i) + d) = AtransAinvAtrans(relevant_terms[d], i) * normalization;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/derivative_recovery/3"}
{"code": "for (i = 0; i < (w * h); i++)\n{\n  if ((i % w) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\"%u \", imageArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrchowmein/Cuda_Comparison/openMPBlur/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  d.set(i, i);\n  d.atomic(i);\n  array2[i] += d.get(i);\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hpc-sandbox/graph-dev/test-class-instance-offload/test/1"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  for (int is = 0; is < ns; is++)\n  {\n    if (DriftSpecies[is])\n      rhons[is][i][j][k] = (rhoINIT[is] / (cosh((grid->getYN(i, j, k) - (Ly / 2)) / delta) * cosh((grid->getYN(i, j, k) - (Ly / 2)) / delta))) / FourPI;\n    else\n      rhons[is][i][j][k] = rhoINIT[is] / FourPI;\n\n  }\n\n  Ex[i][j][k] = 0.0;\n  Ey[i][j][k] = 0.0;\n  Ez[i][j][k] = 0.0;\n  Bxn[i][j][k] = B0x * tanh((grid->getYN(i, j, k) - (Ly / 2)) / delta);\n  Byn[i][j][k] = B0y;\n  xpert = grid->getXN(i, j, k) - (Lx / 2);\n  ypert = grid->getYN(i, j, k) - (Ly / 2);\n  exp_pert = exp(((-(xpert / delta)) * (xpert / delta)) - ((ypert / delta) * (ypert / delta)));\n  Bxn[i][j][k] += ((B0x * pertX) * exp_pert) * ((((((-cos(((M_PI * xpert) / 10.0) / delta)) * cos(((M_PI * ypert) / 10.0) / delta)) * 2.0) * ypert) / delta) - (((cos(((M_PI * xpert) / 10.0) / delta) * sin(((M_PI * ypert) / 10.0) / delta)) * M_PI) / 10.0));\n  Byn[i][j][k] += ((B0x * pertX) * exp_pert) * (((((cos(((M_PI * xpert) / 10.0) / delta) * cos(((M_PI * ypert) / 10.0) / delta)) * 2.0) * xpert) / delta) + (((sin(((M_PI * xpert) / 10.0) / delta) * cos(((M_PI * ypert) / 10.0) / delta)) * M_PI) / 10.0));\n  Bzn[i][j][k] = B0z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/60"}
{"code": "for (iter = 0; iter < N; iter++)\n{\n  x = (rand() / ((float) 32767)) * side;\n  y = (rand() / ((float) 32767)) * side;\n  (sqrt(pow(x - radius, 2) + pow(y - radius, 2)) <= radius) && (n++);\n}\n\n", "pragma": "omp parallel for reduction(+:n)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP2.2/Shashank_CP2.2_11110094_Report+Codes/Shashank_CP2.2_11110094_Report+Codes/Codes for OpenMP_Shashank/Q2/Monte_Carlo_pi/0"}
{"code": "for (int y = 0; y < BLOCK_HEIGHT; y++)\n{\n  for (int x = 0; x < BLOCK_WIDTH; x++)\n  {\n    double vec[BLOCK_DIM];\n    memset(vec, 0, BLOCK_DIM * (sizeof(double)));\n    for (int j = 0; j < BLOCK_Y; j++)\n    {\n      for (int i = 0; i < BLOCK_X; i++)\n      {\n        for (int d = 0; d < CELL_BIN; d++)\n        {\n          int index = ((j * (BLOCK_X * CELL_BIN)) + (i * CELL_BIN)) + d;\n          vec[index] = hist[x + i][y + j][d];\n        }\n\n      }\n\n    }\n\n    double norm = 0.0;\n    for (int i = 0; i < BLOCK_DIM; i++)\n    {\n      norm += vec[i] * vec[i];\n    }\n\n    for (int i = 0; i < BLOCK_DIM; i++)\n    {\n      vec[i] /= sqrt(norm + 1.0);\n    }\n\n    for (int i = 0; i < BLOCK_DIM; i++)\n    {\n      int index = (((y * BLOCK_WIDTH) * BLOCK_DIM) + (x * BLOCK_DIM)) + i;\n      feat[index] = vec[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/noritsuna/HandDetectorOpenMP/jni/HandDetector/1"}
{"code": "for (i = 0; i < num_tasks; i++)\n{\n  {\n    if (ompt_get_thread_id() != master_thread_id)\n    {\n      serialwork(2);\n    }\n    else\n    {\n      serialwork(0);\n    }\n\n  }\n}\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPToolsInterface/ompt-test-suite/regression/mandatory/inquiry_functions/test_ompt_get_state/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  pointsOut[i].x = sclX * (pointsIn[i].x - minPoint.x);\n  pointsOut[i].y = sclY * (pointsIn[i].y - minPoint.y);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/norm/0"}
{"code": "for (int z = 4; z < (nz - 4); z++)\n{\n  for (int y = 4; y < (ny - 4); y++)\n  {\n    for (int x = 4; x < (nx - 4); x++)\n    {\n      float div = ((((a[0] * current_s[indexTo1D(x, y, z)]) + (a[1] * (((((current_s[indexTo1D(x + 1, y, z)] + current_s[indexTo1D(x - 1, y, z)]) + current_s[indexTo1D(x, y + 1, z)]) + current_s[indexTo1D(x, y - 1, z)]) + current_s[indexTo1D(x, y, z + 1)]) + current_s[indexTo1D(x, y, z - 1)]))) + (a[2] * (((((current_s[indexTo1D(x + 2, y, z)] + current_s[indexTo1D(x - 2, y, z)]) + current_s[indexTo1D(x, y + 2, z)]) + current_s[indexTo1D(x, y - 2, z)]) + current_s[indexTo1D(x, y, z + 2)]) + current_s[indexTo1D(x, y, z - 2)]))) + (a[3] * (((((current_s[indexTo1D(x + 3, y, z)] + current_s[indexTo1D(x - 3, y, z)]) + current_s[indexTo1D(x, y + 3, z)]) + current_s[indexTo1D(x, y - 3, z)]) + current_s[indexTo1D(x, y, z + 3)]) + current_s[indexTo1D(x, y, z - 3)]))) + (a[4] * (((((current_s[indexTo1D(x + 4, y, z)] + current_s[indexTo1D(x - 4, y, z)]) + current_s[indexTo1D(x, y + 4, z)]) + current_s[indexTo1D(x, y - 4, z)]) + current_s[indexTo1D(x, y, z + 4)]) + current_s[indexTo1D(x, y, z - 4)]));\n      next_s[indexTo1D(x, y, z)] = ((2 * current_s[indexTo1D(x, y, z)]) - next_s[indexTo1D(x, y, z)]) + (vsq[indexTo1D(x, y, z)] * div);\n      div = ((((a[0] * current_r[indexTo1D(x, y, z)]) + (a[1] * (((((current_r[indexTo1D(x + 1, y, z)] + current_r[indexTo1D(x - 1, y, z)]) + current_r[indexTo1D(x, y + 1, z)]) + current_r[indexTo1D(x, y - 1, z)]) + current_r[indexTo1D(x, y, z + 1)]) + current_r[indexTo1D(x, y, z - 1)]))) + (a[2] * (((((current_r[indexTo1D(x + 2, y, z)] + current_r[indexTo1D(x - 2, y, z)]) + current_r[indexTo1D(x, y + 2, z)]) + current_r[indexTo1D(x, y - 2, z)]) + current_r[indexTo1D(x, y, z + 2)]) + current_r[indexTo1D(x, y, z - 2)]))) + (a[3] * (((((current_r[indexTo1D(x + 3, y, z)] + current_r[indexTo1D(x - 3, y, z)]) + current_r[indexTo1D(x, y + 3, z)]) + current_r[indexTo1D(x, y - 3, z)]) + current_r[indexTo1D(x, y, z + 3)]) + current_r[indexTo1D(x, y, z - 3)]))) + (a[4] * (((((current_r[indexTo1D(x + 4, y, z)] + current_r[indexTo1D(x - 4, y, z)]) + current_r[indexTo1D(x, y + 4, z)]) + current_r[indexTo1D(x, y - 4, z)]) + current_r[indexTo1D(x, y, z + 4)]) + current_r[indexTo1D(x, y, z - 4)]));\n      next_r[indexTo1D(x, y, z)] = ((2 * current_r[indexTo1D(x, y, z)]) - next_r[indexTo1D(x, y, z)]) + (vsq[indexTo1D(x, y, z)] * div);\n      image[indexTo1D(x, y, z)] = next_s[indexTo1D(x, y, z)] * next_r[indexTo1D(x, y, z)];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/rtm8-omp/rtm8/0"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  int start = g_graph_nodes[vid].starting;\n  int no_of_edges = g_graph_nodes[vid].no_of_edges;\n  int end = start + no_of_edges;\n  int my_cost = g_cost[vid];\n  int new_cost = my_cost + 1;\n  for (int i = start; i < end; i++)\n  {\n    int id = g_graph_edges[i];\n    if (stale_mode == 0)\n    {\n      if (atomicMin(g_cost + id, new_cost))\n      {\n        *g_over = true;\n      }\n\n    }\n    else\n    {\n      int neighbor_cost = g_cost_ind[i];\n      if (neighbor_cost > new_cost)\n      {\n        atomicMin(g_cost + id, new_cost);\n        *g_over = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/BFS/kernel/2"}
{"code": "for (j = 0; j < NB; j++)\n{\n  float sum = C[(i * NB) + j];\n  for (k = 0; k < NB; k++)\n  {\n    sum += A[(i * NB) + k] * B[(k * NB) + j];\n  }\n\n  C[(i * NB) + j] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/1"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  for (j = i + 1; j < n; j++)\n  {\n    A[i][n] = A[i][n] - (A[i][j] * A[j][n]);\n  }\n\n  A[i][n] = A[i][n] / A[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sfyzsr/Gaussian-Elimination-OpenMP-MPI/gauss_OpenMP/4"}
{"code": "for (j = 1; j < N; j++)\n{\n  for (k = from; k < (to - j); k++)\n  {\n    if (column[k].value < column[k + 1].value)\n    {\n      auxCelda = column[k];\n      column[k] = column[k + 1];\n      column[k + 1] = aux;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/10"}
{"code": "for (int i = 0; i < 250; i++)\n{\n  for (int j = 0; j < 250; j++)\n  {\n    printf(\"%d \", E[j][i]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-HW/3/code/1.2/1"}
{"code": "for (i = 1; i <= 4; i++)\n{\n  vis[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/tsp_ppt/4"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  partial_new_centers_len[i] = (int *) omp_target_alloc(nclusters * (sizeof(int)), -100);\n  partial_new_centers[i] = (float **) omp_target_alloc(nclusters * (sizeof(float *)), -100);\n  total_size += nclusters * (sizeof(int));\n  total_size += nclusters * (sizeof(float *));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/kmeans/kmeans_openmp/kmeans_clustering/6"}
{"code": "for (middle = 0; middle < 1200; middle++)\n{\n  int *dm = dist[middle];\n  for (src = 0; src < 1200; src++)\n  {\n    int *ds = dist[src];\n    for (dst = 0; dst < 1200; dst++)\n    {\n      ds[dst] = (ds[dst] < (ds[middle] + dm[dst])) ? (ds[dst]) : (ds[middle] + dm[dst]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jackson211/Floyd-Warshall-OpenMP/fw_3/2"}
{"code": "for (int id = 0; id < ((source_height * source_width) * source_nchannel); id++)\n{\n  if (boundary_array[id] == INSIDE_MASK)\n  {\n    outimg[id] = targetimg[id];\n  }\n  else\n  {\n    outimg[id] = srcimg[id];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, CHUNKSIZE1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/9"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  nppp = kpic[k];\n  ne = nppp + npoff;\n  if (ne > npmax)\n    ierr = (ierr > (ne - npmax)) ? (ierr) : (ne - npmax);\n\n  if (ierr > 0)\n    nppp = 0;\n\n  for (j = 0; j < nppp; j++)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      part[i + (idimp * (j + npoff))] = ppart[i + (idimp * (j + (nppmx * k)))];\n    }\n\n  }\n\n  npoff += nppp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/44"}
{"code": "for (int i = 0; i < n2; ++i)\n{\n  for (int j = 0; j < n3; ++j)\n  {\n    (file << global_w2[i][j]) << \" \";\n  }\n\n  file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  double tmp = getValueAtIJ(A, n, a, i + 1);\n  setValueAtIJ(A, n, a, i + 1, getValueAtIJ(A, n, b, i + 1));\n  setValueAtIJ(A, n, b, i + 1, tmp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ktzsh/lu_decomposition/openmp/LUDecomp/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  for (j = 0; j < 256; j++)\n    fprintf(fp, \"%d \", (i * 256) + j);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/PKU-HPC/Testing on Intel Xeon E5 CPUs/ProblemScale/256*256/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (int i = 0; i < ncouls; i++)\n  vcoul[i] = i * 0.025;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gpp-omp/main/2"}
{"code": "for (i = 0; i < cores; i++)\n{\n  if (i < (cores - 1))\n    bs(i * mid, (i + 1) * mid, 1, 0, i, 0);\n  else\n    bs(i * mid, terms, 1, 0, i, 0);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/an31146/source_code/pi/pchudnovsky/0"}
{"code": "for (n = 0; n < len; ++n)\n  dst[n] = (atoi16[ARCH_INDEX(src[n * 2])] << 4) | atoi16[ARCH_INDEX(src[(n * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/EPI_fmt_plug/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  b[i] = (rand() % MAX_RAND_DOUBLE) / 4.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/3"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  if (i < j)\n  {\n    tx = x[i];\n    ty = y[i];\n    x[i] = x[j];\n    y[i] = y[j];\n    x[j] = tx;\n    y[j] = ty;\n  }\n\n  k = i2;\n  while (k <= j)\n  {\n    j -= k;\n    k >>= 1;\n  }\n\n  j += k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prithvipatl/Parallelizing-2D-FFT/Approach_1/parallel_iter/5"}
{"code": "for (int i = 0; i < (N * N); i++)\n{\n  if (c[i] != validate[i])\n  {\n    if (flag == (-1))\n      printf(\"First fail: c[%d](%d) != validate[%d](%d)\\n\", i, c[i], i, validate[i]);\n\n    flag = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/omp5/loop/loop/2"}
{"code": "for (int n = 0; n < n_time_steps; n++)\n{\n  calculate_centers_of_mass(grid_size);\n  send_recv_centers_of_mass();\n  calculate_new_iteration(grid_size);\n  send_recv_particles();\n  memset(cells[0], 0, ((sizeof(cell_t)) * size_local_cell_matrix[0]) * size_local_cell_matrix[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/18"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < 16; j = j + i)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/34"}
{"code": "for (int ix = 1; ix < (DATAXSIZE - 1); ix++)\n{\n  for (int iy = 1; iy < (DATAYSIZE - 1); iy++)\n  {\n    for (int iz = 1; iz < (DATAZSIZE - 1); iz++)\n    {\n      unew[ix][iy][iz] = (uold[ix][iy][iz] + (0.5 * (phinew[ix][iy][iz] - phiold[ix][iy][iz]))) + ((dt * D) * Laplacian(uold, dx, dy, dz, ix, iy, iz));\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-omp/main/3"}
{"code": "for (j = 0; j < 10000000; j++)\n{\n  if (((((c[j] / cj) - 1.0) >= 0) ? ((c[j] / cj) - 1.0) : (-((c[j] / cj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Common_Core/C/stream/9"}
{"code": "for (index = 0; index < n; index++)\n{\n  if (PointAssignCluster[index] == clusterIndex)\n  {\n    if (j < clusterPointsSize)\n    {\n      omp_set_lock(&lock);\n      clusterPoints[j].x = points[index].x;\n      clusterPoints[j].y = points[index].y;\n      clusterPoints[j].z = points[index].z;\n      clusterPoints[j].vX = points[index].vX;\n      clusterPoints[j].vY = points[index].vY;\n      clusterPoints[j].vZ = points[index].vZ;\n      j++;\n      omp_unset_lock(&lock);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(j)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YanivBir/K-Means/kmeans/8"}
{"code": "for (i = 0; i < MP1; i++)\n  for (j = 0; j < NP1; j++)\n{\n  PSI[i][j] = (A * sin((i + .5) * DI)) * sin((j + .5) * DJ);\n  P[i][j] = (PCF * (cos((2.0 * i) * DI) + cos((2.0 * j) * DJ))) + 50000.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/11"}
{"code": "for (n = 0; n < 1000; n++)\n{\n  if (1000 == (n + 1))\n    my_sleep(0.0005);\n\n  tids[n] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static_3/0"}
{"code": "for (i = 0; i < N; i++)\n  b[i] = b_block + (i * N);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidbejarcaceres/OpenMP-Matrix-Multiplication/mmOMP/4"}
{"code": "for (i = first; i < (first + npoints); i++)\n  results[i - 1] = values[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lk-2020/CFiles/concurrent_offload/3"}
{"code": "for (int i = 0; i < number_words; i++)\n{\n  d[i] = val;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cfd-omp/euler3d/3"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  L[i] = (double *) malloc((sizeof(double)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JaiJaveria/Parallel_Crout_Decomposition/crout/3"}
{"code": "for (int i = 0; i < obj.len; i++)\n  printf(\"%d \", obj.arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/alloc/main_nested/3"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      Dxu[pp] = (((u[pp - 2] - (8.0 * u[pp - 1])) + (8.0 * u[pp + 1])) - u[pp + 2]) * idx_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/1"}
{"code": "for (int ip = 0; ip < np; ++ip)\n{\n  for (int k = 0, kk = ip * howmany; k < howmany; ++k, ++kk)\n  {\n    transpose_block(in_t, *in[kk], ip, np, k, howmany);\n    fft_xy[ip]->fft_backward(in[kk]->data());\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/benchmark/fft2d_pfor/4"}
{"code": "for (int x = 0; x < num_bins; ++x)\n{\n  hist_counts[x] += hist_counts_priv[x];\n  hist_collect_q_tet[x] += hist_collect_q_tet_priv[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/2"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if (m_olWtrEroSed[i] < 1.e-4f)\n    m_olWtrEroSed[i] = 0.f;\n\n  m_enratio[i] = CalEnrichmentRatio(m_olWtrEroSed[i], m_surfRf[i], m_cellArea);\n  if (m_cbnModel == 0)\n  {\n    OrgNRemovedInRunoffStaticMethod(i);\n  }\n  else\n    if (m_cbnModel == 1)\n  {\n    OrgNRemovedInRunoffCFarmOneCarbonModel(i);\n  }\n  else\n    if (m_cbnModel == 2)\n  {\n    OrgNRemovedInRunoffCenturyModel(i);\n  }\n\n\n\n  OrgPAttachedtoSed(i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrSED/NutrientTransportSediment/1"}
{"code": "for (unsigned long long tid = start; tid < end; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (unsigned long long i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      unsigned long long id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "          #pragma omp target teams distribute parallel for device(d) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_mulgpu/0"}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  hist[i] = 0;\n  omp_init_lock(&lock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/04_locks/1"}
{"code": "for (int i = 0; i < sim->N; i++)\n{\n  x = nrand48(xsubi) % sim->L;\n  y = nrand48(xsubi) % sim->LANES;\n  while (grid[(sim->L * y) + x] != (-1))\n  {\n    x = nrand48(xsubi) % sim->L;\n    y = nrand48(xsubi) % sim->LANES;\n  }\n\n  grid[(sim->L * y) + x] = i;\n  cars[i].x = x;\n  cars[i].y = y;\n  cars[i].v = 0;\n  cars[i].v_d = sim->v_max;\n  cars[i].lane_change_now = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/11"}
{"code": "for (int j = 0; j < height; ++j)\n{\n  double y0 = (j * vert_int) + lower;\n  for (int i = rank; i < width; i += proc_size)\n  {\n    double x0 = (i * hori_int) + left;\n    int repeats = 0;\n    double x = 0;\n    double y = 0;\n    double length_squared = 0;\n    while ((repeats < 100000) && (length_squared < 4))\n    {\n      double temp = ((x * x) - (y * y)) + x0;\n      y = ((2 * x) * y) + y0;\n      x = temp;\n      length_squared = (x * x) + (y * y);\n      ++repeats;\n    }\n\n    image_loc[(j * width) + i] = repeats;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aalty/MPI-OpenMP-Mandlebrot-Set/ms_hybrid/3"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  ((((cout << \"distance of \") << i) << \" is \") << dist[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/bfs/bfs/1"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  matrix[i] = (double *) calloc(cols, sizeof(double *));\n  if (matrix[i] == 0)\n  {\n    printf(\"ERROR: Can't allocate memory for matrix!\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/2"}
{"code": "for (i = 0; i < (*lin); i++)\n{\n  matriz[i] = malloc((*col) * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoborgesdeoliveira/Matrix-Multiplication-and-Sum-with-OpenMP-and-PThreads/Matrizes OpenMP/matriz2d/3"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  a[i] = 2 * i;\n  b[i] = 1 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lephin/C-parallel-programming.-OpenMP/Hello/1"}
{"code": "for (p = 0; p < M; p++)\n{\n  temp[(2 * M) + p] = Board(1, p);\n}\n\n", "pragma": "omp parallel for private(p) shared(temp,board) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (array[i] == find)\n  {\n    found = i + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/caolanb10/Concurrent-Systems/parallelsearch/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (nza = 0; nza < arow[i]; nza++)\n  {\n    j = acol[i][nza] + 1;\n    rowstr[j] = rowstr[j] + arow[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nctu-homeworks/PP-hw2/cg/12"}
{"code": "for (i = 0; i < cache->num_buckets; ++i)\n{\n  cache->thresholds_avgDegrees[i] = quantize_8(thresholds_avgDegrees[i], rDivD_params.scale, rDivD_params.zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/42"}
{"code": "for (i = 0; i < n; i++)\n{\n  data[i] += thread_num;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gjbex/training-material/OpenMP/Allocation/allocation/1"}
{"code": "for (int nt = 0; nt < numThreads; nt++)\n{\n  privLsum[nt] = create_matrix_double(nUsers, nFeatures);\n  privRTsum[nt] = create_matrix_double(nItems, nFeatures);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matFact-omp/2"}
{"code": "for (unsigned int i = 0; i < N; i++)\n{\n  for (unsigned int j = 0; j < N; j++)\n  {\n    printf(\"%lf \", A[(i * N) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariakhaetskaya/Parallel-Programming/OpenMP-SLE-Solver/main/4"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  (cout << arr[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/main/0"}
{"code": "for (int ip = 0; ip < nthreads; ip++, vt_it += shape[1])\n{\n  (vector < uint_type) > c(vt_it, vt_it + shape[1]);\n  Children[ip]->load(c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/OhmmsApp/RandomNumberControl/7"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < M; j++)\n  cont = cont + 1;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bernardoduarte/PPD/OpenMP/examples/ex5/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    X[i][j] = rand() / 50000.0;\n  }\n\n  y[i] = rand() / 50000.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rushitpandya/Gaussian-Elimination-Using-Pthread-and-OpenMP/gauss_openmp/2"}
{"code": "for (i = 0; i < 256; ++i)\n  permutations[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ftes/de.uni-potsdam.hpi.kpp.worley-openmp-c/main/0"}
{"code": "for (int y = kern_cent_Y; y < (data_size_Y - kern_cent_Y); y++)\n{\n  int x = kern_cent_X;\n  int offset = y * data_size_X;\n  for (x = kern_cent_X; x < ((((data_size_X - kern_cent_X) / 12) * 12) - 12); x += 12)\n  {\n    int outpos = x + offset;\n    int result1 = _mm_set1_ps(0);\n    int result2 = _mm_set1_ps(0);\n    int result3 = _mm_set1_ps(0);\n    for (int j = -kern_cent_Y; j <= kern_cent_Y; j++)\n    {\n      int temp = (y + j) * data_size_X;\n      int temp1 = (kern_cent_Y - j) * 3;\n      for (int i = -kern_cent_X; i <= kern_cent_X; i++)\n      {\n        int kerpos = (kern_cent_X - i) + temp1;\n        int ref = (x + i) + temp;\n        int kerval1 = _mm_set1_ps(kernel[kerpos]);\n        int inval1 = _mm_loadu_ps(in + ref);\n        int kerval2 = _mm_set1_ps(kernel[kerpos]);\n        int inval2 = _mm_loadu_ps((in + ref) + 4);\n        int kerval3 = _mm_set1_ps(kernel[kerpos]);\n        int inval3 = _mm_loadu_ps((in + ref) + 8);\n        result1 = _mm_add_ps(_mm_mul_ps(inval1, kerval1), result1);\n        result2 = _mm_add_ps(_mm_mul_ps(inval2, kerval2), result2);\n        result3 = _mm_add_ps(_mm_mul_ps(inval3, kerval3), result3);\n      }\n\n    }\n\n    _mm_storeu_ps(out + outpos, result1);\n    _mm_storeu_ps((out + outpos) + 4, result2);\n    _mm_storeu_ps((out + outpos) + 8, result3);\n  }\n\n  for (; x < (data_size_X - kern_cent_X); x++)\n  {\n    for (int i = -kern_cent_X; i <= kern_cent_X; i++)\n    {\n      for (int j = -kern_cent_Y; j <= kern_cent_Y; j++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kt9302/ImageConvolution/part2/0"}
{"code": "for (j = 0; j < VERYBIG; j++)\n{\n  private_sum += 1;\n  sumx = 0.0;\n  for (k = 0; k < j; k++)\n    sumx = sumx + ((double) k);\n\n  sumy = 0.0;\n  for (k = j; k > 0; k--)\n    sumy = sumy + ((double) k);\n\n  if (sumx > 0.0)\n  {\n    private_total = private_total + (1.0 / sqrt(sumx));\n  }\n\n  if (sumy > 0.0)\n  {\n    private_total = private_total + (1.0 / sqrt(sumy));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZahraY10/Parallel-Programming-OpenMP/Lab 1/OMP Parallel/0"}
{"code": "for (int kk = 0; kk < N; kk++)\n{\n  for (int jj = 0; jj < N; jj++)\n  {\n    for (int ii = 0; ii < N; ii++)\n    {\n      result = evaluate_array3d(array3d_1, N, ii, jj, kk) + evaluate_array3d(array3d_2, N, ii, jj, kk);\n      fill_array3d(output, N, ii, jj, kk, result);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(result)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/array3d/10"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    nb_links += pages[(i * n) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/page-rank-omp/main/4"}
{"code": "for (int i = 0; i < _nth; ++i)\n{\n  pthread_join(thread[i], NULL);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/mat_mult/3"}
{"code": "for (c1 = (nj > nk) ? (nj) : (nk); c1 <= (((ni + (-1)) < (nm + (-1))) ? (ni + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/15"}
{"code": "for (int i = 0; i < SDMGeom->HALO_Node(); ++i)\n{\n  ux_dx[i] = f;\n  ux_dy[i] = f;\n  ux_dz[i] = f;\n  uy_dx[i] = f;\n  uy_dy[i] = f;\n  uy_dz[i] = f;\n  uz_dx[i] = f;\n  uz_dy[i] = f;\n  uz_dz[i] = f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/4"}
{"code": "for (i = 0; i < 10000; i++)\n  pdot += a[i] * b[i];\n\n", "pragma": "omp parallel for schedule(dynamic,500)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/dot_product_openmp/0"}
{"code": "for (int i = 0; i < K; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    C[i][j] = 0;\n    for (int k = 0; k < L; k++)\n    {\n      x = A[i][k] * B[k][j];\n      C[i][j] += x;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_num) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shikhashah2627/Python_Performance/OMP_Matrix_Multiplication/0"}
{"code": "for (int i = 0; i < testCount; i++)\n{\n  resTime += TestBruteForceMatch(matrix1, matrix2, res1, N, M);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brelok-the-pok/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/7"}
{"code": "for (int i = start_index; i < (start_index + num_loops); i++)\n{\n  sum += data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_basic_sum/2"}
{"code": "for (double t = INITIAL_TEMP; t > 0.001; t *= 0.98)\n{\n  for (i = 0; i < 100000; i++)\n  {\n    get_new_solution(&current_solution, seed);\n    calculate_length(&current_solution, length_table);\n    if (accept(best_solution, current_solution, t, seed))\n    {\n      memcpy(&best_solution, &current_solution, sizeof(current_solution));\n    }\n    else\n    {\n      memcpy(&current_solution, &best_solution, sizeof(best_solution));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebaMederos/TSP-OpenMP/sim-ann/SA/8"}
{"code": "for (i = 0; i < 32; i++)\n{\n  for (j = 0; j < 32; j++)\n  {\n    a[i][j] = i + j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reissmann/openmp_talk/matrix/1"}
{"code": "for (i = 0; i < num; i++)\n{\n  g = randpg(minP, maxP);\n  k = randpg(minK, maxK);\n  A[i] = g / k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/37"}
{"code": "for (i = 1; i < (nx + 1); i++)\n{\n  for (j = 1; j <= 5; j++)\n  {\n    D1V[i][j] = D1V[i][j] + (-stim);\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/LRd2000-model/2D model/FDM02_LRd00_CCL_openmp/5"}
{"code": "for (int i = 0; i < col; i++)\n{\n  int temp = kernel.pixels[row1][i];\n  kernel.pixels[row1][i] = kernel.pixels[row2][i];\n  kernel.pixels[row2][i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/0"}
{"code": "for (int _i0 = 2; _i0 < R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 2; _i1 < C; _i1 = _i1 + 1)\n  {\n    Sxy[(_i0 * (2 + C)) + _i1] = (((((((Ixy[(((-1) + _i0) * (2 + C)) + ((-1) + _i1)] + Ixy[(((-1) + _i0) * (2 + C)) + _i1]) + Ixy[(((-1) + _i0) * (2 + C)) + (1 + _i1)]) + Ixy[(_i0 * (2 + C)) + ((-1) + _i1)]) + Ixy[(_i0 * (2 + C)) + _i1]) + Ixy[(_i0 * (2 + C)) + (1 + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + ((-1) + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + _i1]) + Ixy[((1 + _i0) * (2 + C)) + (1 + _i1)];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/6"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    MatrixA[i][j] = 0.0;\n    MatrixB[i][j] = 0.0;\n    ResultMat[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lamyaraed/Parallel-Processing/MatrixAddition(OMP)/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = i; j < n; j++)\n  {\n    srand48(time(0));\n    R[i][j] = drand48();\n    sum += R[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yinglyu/openmp-matrix-inversion/ir_openmp/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (!(A[i] % 2))\n  {\n    total += B[i] + C[i];\n  }\n  else\n    if (!((A[i] == 1) || (B[i] == 1)))\n  {\n    total += B[i] - A[i];\n  }\n\n\n}\n\n", "pragma": "\t\t\t#pragma omp for reduction ( +: total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VGol-Git/OpenMP/OpenMP/LAB6_2/0"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  test_communicateGhostP2G(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/14"}
{"code": "for (int k = 0; k < argc; ++k)\n{\n  i = k;\n  v += i;\n}\n\n", "pragma": "#pragma omp for firstprivate(i) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_firstprivate_messages/0"}
{"code": "for (i2 = 0; i2 < l->ny; i2++)\n{\n  for (i1 = 0; i1 < l->nx; i1++)\n  {\n    fprintf(f, \"%d\\n\", l->u0[((i1 + l->nx) % l->nx) + (((i2 + l->ny) % l->ny) * l->nx)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leonshting/mipt-openmp-mpi/openmp-mpi/11/life2d/1"}
{"code": "for (int j = 0; j < 256; j++)\n{\n  count_r[j] += private_count_r[j];\n  count_g[j] += private_count_g[j];\n  count_b[j] += private_count_b[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/8"}
{"code": "for (i = 0; i < n; ++i)\n  sums[j] += u[i] + v[i];\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex3-dot-product-openmp-sta/0"}
{"code": "for (k = id * workload_number; k < ((id * workload_number) + workload_number); k++)\n{\n  RamerDouglasPeucker(AllPolylines[k], epsilon, SimplifiedAllPolylines[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aristidis13/Parallellization-with-OpenMP-Framework/Static/Static/1"}
{"code": "for (int i = 0; i < sizeOfTableOutput; ++i)\n{\n  nbErrorFind[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/25"}
{"code": "for (uint i = 0; i < blockHistograms.size(); ++i)\n{\n  uint ind = i % numBuckets;\n  globalHisto[ind] += blockHistograms[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sahityamantravadi/cme213-sp18/hw1code/main_q2/0"}
{"code": "for (size_t i = 0; i < A.get_nnz(); i++)\n{\n  this->precond.M.data()[i] = A.val.data()[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/equation/ic/0"}
{"code": "for (int k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    int index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    field[FTNREF2D(x_min - j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = left_rcv_buffer[FTNREF1D(index, 1)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_pack/1"}
{"code": "for (i = 0; i < totalPattern; i++)\n{\n  FILE *f;\n  char fileName[1000];\n  sprintf(fileName, \"%s/pattern%d.txt\", \"inputs\", i);\n  f = fopen(fileName, \"r\");\n  if (f == 0)\n    exit(0);\n\n  readFromFile(f, &patternData[i], &patternLength[i]);\n  fclose(f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amckenna41/OMP-MPI-parallel-programming/omp/project_OMP/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  omp_set_lock(&l);\n  fib(10);\n  omp_unset_lock(&l);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenMPToolsInterface/ompt-test-suite/test/locktest-2/0"}
{"code": "for (n = 0; n < 27; n++)\n  CommunicateThisDir[n] = faces[n];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/17"}
{"code": "for (row = i - radius; row <= (i + radius); row++)\n{\n  for (col = j - radius; col <= (j + radius); col++)\n  {\n    int x = setBoundary(col, 0, width - 1);\n    int y = setBoundary(row, 0, height - 1);\n    int tempPos = (y * width) + x;\n    double square = ((col - j) * (col - j)) + ((row - i) * (row - i));\n    double sigma = radius * radius;\n    double weight = exp((-square) / (2 * sigma)) / ((3.14 * 2) * sigma);\n    redSum += red[tempPos] * weight;\n    weightSum += weight;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,100) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manogna-mujje/Image-Processing/OpenMP/max_paralleize_openmp/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpa06rhb5g.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/unibas-dmi-hpc/LB4OMP/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i += incX + 2, j += incY + 2)\n{\n  o1 = _mm_set_ps(0 - (*((XP + i) + 1)), 0 - (*((XP + i) + 1)), *(XP + i), *(XP + i));\n  o2 = _mm_set_ps(*(YP + j), *((YP + j) + 1), *((YP + j) + 1), *(YP + j));\n  m = _mm_mul_ps(o1, o2);\n  r = _mm_addsub_ps(m, _mm_shuffle_ps(m, m, _MM_SHUFFLE(0, 1, 3, 2)));\n  _mm_store_ps(fdot, r);\n  temp->REEL = temp->REEL + fdot[0];\n  temp->IMAG = temp->IMAG + fdot[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/dot/11"}
{"code": "for (i = myid + 1; i <= N; i += incresment)\n{\n  x = (((double) i) - 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(i, x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ququwork/MPI-pi/6mpiopenmp/0"}
{"code": "for (int i = 0; i < range; ++i)\n  counts[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kvitnat/Parallel-programming-lab/OpenMP/omp/4"}
{"code": "for (i = 1; i < ((int) n); i++)\n  sum += 2.0 * func(from + (i * h));\n\n", "pragma": "omp parallel for reduction(+:sum) shared(h,i)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Trapezium/0"}
{"code": "for (int i = 0; i < (70 * 1); i += 1)\n  printf(\" B[%d] = %g\\n\", i, B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/vasp1/vasp1/3"}
{"code": "for (int p = 0; p < numPoints; p++)\n  (((myfile << dataset[p].id) << \", \") << clusters[globalMembership[p]].id) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/17"}
{"code": "for (unsigned v = 0; v < ndv; v++)\n{\n  float val = Population[(minDex * ndv) + v];\n  printf(\"%f, \", val);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feildawproton/Genetic-Algorithm-with-OpenMP/GA/GA/11"}
{"code": "for (ci = 0; ci < num_clusters; ci++)\n{\n  cx = ((double) DIST_SCALE) * (((double) rand()) / ((double) 32767));\n  cy = ((double) DIST_SCALE) * (((double) rand()) / ((double) 32767));\n  for (bi = ci * bodies_per_cluster; bi < ((ci + 1) * bodies_per_cluster); bi++)\n  {\n    if (bi < num_bodies)\n    {\n      ox = ((double) cluster_offset_scale) * (((((double) rand()) / ((double) 32767)) * 2.0) - 1.0);\n      oy = ((double) cluster_offset_scale) * (((((double) rand()) / ((double) 32767)) * 2.0) - 1.0);\n      body_t b;\n      b.m = ((double) INIT_MASS) + (((double) MASS_RANGE) * (((((double) rand()) / ((double) 32767)) * 2.0) - 1.0));\n      b.x = cx + ox;\n      b.vx = 0.0;\n      b.hvx = 0.0;\n      b.ax = 0.0;\n      b.y = cy + oy;\n      b.vy = 0.0;\n      b.hvy = 0.0;\n      b.ay = 0.0;\n      b.work = 1;\n      bodies[bi] = b;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexcpatel/gsim/gsim-barneshut/src/gsim/6"}
{"code": "for (int i = omp_get_thread_num(); i < x.size(); i += threadCount)\n{\n  if (x[i] > maxValues[omp_get_thread_num()])\n  {\n    maxValues[omp_get_thread_num()] = x[i];\n    maxIndices[omp_get_thread_num()] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/christophstach/openmp-emboss/task/0"}
{"code": "for (i = 0; i < DIM; i++)\n  for (i = 0; i < DIM; i++)\n{\n  c[i][j] = i + j;\n  ck[i][j] = i + j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/counting/counting/4"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  splatt_free(tt->ind[m]);\n  splatt_free(tt->indmap[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/11"}
{"code": "for (t2 = lbp; t2 <= ubp; t2++)\n{\n  for (t4 = 16 * t2; t4 <= ((((16 * t2) + 15) < ((t1 - t2) - 1)) ? ((16 * t2) + 15) : ((t1 - t2) - 1)); t4++)\n  {\n    for (t5 = (t1 - t2) + 1; t5 <= (N - 2); t5++)\n    {\n      for (t6 = t5 + 1; t6 <= (N - 1); t6++)\n      {\n        Pbp[t1 - t2][t5] += ((((Pbp[t4][t6] * ERT) * Q[t4 + 1][t1 - t2]) * Qbp[t1 - t2][t5]) * Q[t5 + 1][t6 - 1]) / ((Qbp[t4][t6] == 0) ? (1) : (Qbp[t4][t6]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(lbv,ubv,t3,t4,t5,t6)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_pb_traco/1"}
{"code": "for (i = 0; i < (16 + 2); i += 2)\n{\n  L0 ^= salt->salt[i & 2];\n  R0 ^= salt->salt[(i & 2) + 1];\n  L0 ^= BF_current.P[0];\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[0 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[1 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[2 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[3 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[4 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[5 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[6 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[7 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[8 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[9 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[10 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[11 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[12 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[13 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u1 = L0 & 0xFF;\n  u1 <<= 2;\n  u2 = L0 >> 6;\n  u2 &= 0x3FC;\n  u3 = L0 >> 14;\n  u3 &= 0x3FC;\n  u4 = L0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  R0 ^= BF_current.P[14 + 1];\n  u3 += u1;\n  R0 ^= u3;\n  ;\n  u1 = R0 & 0xFF;\n  u1 <<= 2;\n  u2 = R0 >> 6;\n  u2 &= 0x3FC;\n  u3 = R0 >> 14;\n  u3 &= 0x3FC;\n  u4 = R0 >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n  u3 ^= u2;\n  L0 ^= BF_current.P[15 + 1];\n  u3 += u1;\n  L0 ^= u3;\n  ;\n  u4 = R0;\n  R0 = L0;\n  L0 = u4 ^ BF_current.P[16 + 1];\n  ;\n  BF_current.P[i] = L0;\n  BF_current.P[i + 1] = R0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    r = 0;\n    g = 0;\n    b = 0;\n    tot = 0;\n    for (k = (0 > (i - radio)) ? (0) : (i - radio); k <= (((n - 1) < (i + radio)) ? (n - 1) : (i + radio)); k++)\n    {\n      for (l = (0 > (j - radio)) ? (0) : (j - radio); l <= (((m - 1) < (j + radio)) ? (m - 1) : (j + radio)); l++)\n      {\n        v = ppdBloque[(k - i) + radio][(l - j) + radio];\n        r += ppsImagenOrg[k][l].r * v;\n        g += ppsImagenOrg[k][l].g * v;\n        b += ppsImagenOrg[k][l].b * v;\n        tot += v;\n      }\n\n    }\n\n    r /= tot;\n    g /= tot;\n    b /= tot;\n    ppsImagenDst[i][j].r = r;\n    ppsImagenDst[i][j].g = g;\n    ppsImagenDst[i][j].b = b;\n  }\n\n}\n\n", "pragma": "omp parallel for private(r, g, b, tot, v, l, k, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PelaezLink/OpenMP_MPI/prac1/imagenesv1/0"}
{"code": "for (long i = 0; i < last_idx; i++)\n{\n  (cout << sequence.at(i)) << \", \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mithradatha/collatz-conjecture/auto/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for_sum += a[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanTrofimov/parallel-programming/code/iterable/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  phi[i] = tmp + (i * m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiackAloZ/OPoly/benchmarks/src/omp-gauss-seidel-2d/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total += data[(i * n) + 6];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/13"}
{"code": "for (j = 0; j < nclr[(3 * mx1) - 1]; j++)\n{\n  for (i = 0; i < idimp; i++)\n  {\n    rbufl[i + (idimp * j)] = sbufr[i + (idimp * j)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpplib2/14"}
{"code": "for (tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == 1)\n  {\n    h_graph_mask[tid] = 0;\n    for (int i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/bfs/src/bfs-AI-AI/6"}
{"code": "for (int i = 0; i < 10000; i++)\n  for (int j = 0; j < 10000; j++)\n  C[j][i] = A[j][i] + B[j][i];\n\n\n", "pragma": "omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/unnikrishnan-c/hpcshiksha-openmp/Part2_Unni/matrixadd/matrixadd_column/0"}
{"code": "for (int i = 0; i < rmdr; i++)\n  chunk_sizes[i] += columns;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SilverSoldier/game-of-life/gol/8"}
{"code": "for (ii = 0; ii < (params.ny * params.nx); ii++)\n{\n  if (!obstacles[ii])\n  {\n    double *current_speed = cells[ii].speeds;\n    double u_x = (((current_speed[1] + current_speed[5]) + current_speed[8]) - ((current_speed[3] + current_speed[6]) + current_speed[7])) / ((((((((current_speed[0] + current_speed[1]) + current_speed[2]) + current_speed[3]) + current_speed[4]) + current_speed[5]) + current_speed[6]) + current_speed[7]) + current_speed[8]);\n    double u_y = (((current_speed[2] + current_speed[5]) + current_speed[6]) - ((current_speed[4] + current_speed[7]) + current_speed[8])) / ((((((((current_speed[0] + current_speed[1]) + current_speed[2]) + current_speed[3]) + current_speed[4]) + current_speed[5]) + current_speed[6]) + current_speed[7]) + current_speed[8]);\n    double u = (u_x * u_x) + (u_y * u_y);\n    local_u += sqrt(u);\n  }\n  else\n    ++local_cells;\n\n}\n\n", "pragma": "omp for private(ii, jj) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk/2"}
{"code": "for (i = 3; i <= (grid_points[0] - 4); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/6"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  d = opendir(train_dir[i]);\n  while (((dir = readdir(d)) != NULL) && (count < img_n))\n  {\n    if ((strcmp(dir->d_name, \"..\") != 0) && (strcmp(dir->d_name, \".\") != 0))\n    {\n      strcpy(img_files[count], train_dir[i]);\n      strcat(img_files[count], dir->d_name);\n      for (int j = 0; j < n_classes; j++)\n      {\n        if (j == i)\n        {\n          y->vals[(count * n_classes) + j] = 1;\n        }\n        else\n        {\n          y->vals[(count * n_classes) + j] = 0;\n        }\n\n      }\n\n      count++;\n    }\n\n  }\n\n  closedir(d);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  L[i] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/25"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  out[i] = ((0.25 * in[i - 1]) + (0.5 * in[i])) + (0.25 * in[i + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Archangel2153/HeatDiffusion-OpenMP-MPI/Task 2/OpenMP - Implementation Process/openmp1/2"}
{"code": "for (i = a, l1 = nWdn * i, kp = out + i; i < b; i++, l1 += nWdn, kp++)\n{\n  jp = in + i;\n  {\n    double r1_0;\n    double i1_0;\n    double r1_1;\n    double i1_1;\n    r1_0 = jp[0 * m].re;\n    i1_0 = jp[0 * m].im;\n    wr = W[1 * l1].re;\n    wi = W[1 * l1].im;\n    tmpr = jp[1 * m].re;\n    tmpi = jp[1 * m].im;\n    r1_1 = (wr * tmpr) - (wi * tmpi);\n    i1_1 = (wi * tmpr) + (wr * tmpi);\n    kp[0 * m].re = r1_0 + r1_1;\n    kp[0 * m].im = i1_0 + i1_1;\n    kp[1 * m].re = r1_0 - r1_1;\n    kp[1 * m].im = i1_0 - i1_1;\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int bnum = (int) (((float) m) * (((float) (list[i] - minval)) / range));\n  if (bnum > 0)\n    --bnum;\n\n  omp_set_lock(&Lock[bnum]);\n  bucket[bnum][countbucket[bnum]++] = list[i];\n  omp_unset_lock(&Lock[bnum]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/BucketSort/6"}
{"code": "for (i = 0; i < nsites; i++)\n{\n  for (k = 0; k < nfields; k++)\n  {\n    tmpbuf2[(i * nfields) + k] = tmpbuf[(k * nsites) + i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/Ludwig/targetDP/targetDP_C/8"}
{"code": "for (i = 0; i < len; i++)\n  cs->salt[i] = (atoi16[ARCH_INDEX(ciphertext[2 * i])] << 4) | atoi16[ARCH_INDEX(ciphertext[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/net_md5_fmt_plug/1"}
{"code": "for (int i = 0; i < y.length; i++)\n{\n  y.val[i] = a * b.val[i];\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/6"}
{"code": "for (i = 0; i < NumberOfProcecess; i++)\n{\n  vetorQuantidades[i] = proporcao * orderOfMatrix;\n  vetorDisplacements[i] = (proporcao * orderOfMatrix) * i;\n  vetorQuantidadesB[i] = proporcao;\n  vetorDisplacementsB[i] = proporcao * i;\n}\n\n", "pragma": "omp parallel for private(i) num_threads(numberOfThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/1"}
{"code": "for (int j = 0; j < num_devices; j++)\n{\n  if (j != (num_devices - 1))\n  {\n    bufA[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * NNZ_PER_DEVICE) * order, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufA[j], CL_FALSE, 0, ((sizeof(int)) * NNZ_PER_DEVICE) * order, X.index + ((j * NNZ_PER_DEVICE) * order), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufB[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * NNZ_PER_DEVICE, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufB[j], CL_FALSE, 0, (sizeof(float)) * NNZ_PER_DEVICE, X.value + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufF[j] = clCreateBuffer(context, CL_MEM_READ_WRITE, (sizeof(float)) * NNZ_PER_DEVICE, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufF[j], CL_FALSE, 0, (sizeof(float)) * NNZ_PER_DEVICE, Error_T + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n  }\n  else\n  {\n    bufA[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * last) * order, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufA[j], CL_FALSE, 0, ((sizeof(int)) * last) * order, X.index + ((j * NNZ_PER_DEVICE) * order), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufB[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * last, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufB[j], CL_FALSE, 0, (sizeof(float)) * last, X.value + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufF[j] = clCreateBuffer(context, CL_MEM_READ_WRITE, (sizeof(float)) * last, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufF[j], CL_FALSE, 0, (sizeof(float)) * last, Error_T + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n  }\n\n  bufC[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * Core_N) * order, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufC[j], CL_FALSE, 0, ((sizeof(int)) * Core_N) * order, CoreT.index, 0, NULL, NULL);\n  CHECK_ERROR(err);\n  bufD[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * Core_N, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufD[j], CL_FALSE, 0, (sizeof(float)) * Core_N, CoreT.value, 0, NULL, NULL);\n  CHECK_ERROR(err);\n  bufE[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (((sizeof(float)) * order) * max_dim) * rrank, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufE[j], CL_FALSE, 0, (((sizeof(float)) * order) * max_dim) * rrank, X.FactorM, 0, NULL, NULL);\n  CHECK_ERROR(err);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/22"}
{"code": "for (i = 0; i < ncommpartner; i++)\n{\n  const int dest = commpartner[i];\n  const int sendcount = comap->sendcount[dest];\n  if (sendcount > 0)\n    MPI_Isend(sendbuf[i], ncols * sendcount, (MPI_Datatype) 0x4c00080b, dest, tag, comm, (request + nrequest) + i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/exchange_matrix/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (5.0 * u[m][i][j][k])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/130"}
{"code": "for (int jj = 0; jj < cols; jj++)\n{\n  a[jj] = (((Rho * c0) * c0) / gamma) * (pow(rho[jj] / Rho, gamma) - 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/14"}
{"code": "for (i = 0; i < matSize; i++)\n{\n  for (j = 0; j < matSize; j++)\n  {\n    mat[(i * matSize) + j] = drand48() * 100;\n  }\n\n  vec[i] = drand48() * 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/MatrixVector/CDParallelism/utils/0"}
{"code": "for (int i = 0; i < globalLen; i++)\n{\n  for (int j = row[globalQueue[i]]; j < row[globalQueue[i] + 1]; j++)\n  {\n    int u = col[j];\n    if (distance[u] < 0)\n    {\n      distance[u] = level + 1;\n      localQueue[localLen++] = u;\n      improvement = true;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for reduction(||:improvement) schedule(guided, 32)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/qbfs/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  tempmapptr = (edgemapptr - (y[i] * cols)) + x[i];\n  tempmagptr = (edgemagptr - (y[i] * cols)) + x[i];\n  if (((*tempmapptr) == 128) && ((*tempmagptr) > lowval))\n  {\n    *tempmapptr = (unsigned char) 0;\n    follow_edges(tempmapptr, tempmagptr, lowval, cols);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/9"}
{"code": "for (j = 0; j < my_width_incr_2; j++)\n{\n  my_image_before[0][j] = my_image_before[1][j];\n  my_image_before[my_height_incr_1][j] = my_image_before[my_height][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/4"}
{"code": "for (int j = n_nodes - 1; j >= 0; j--)\n{\n  for (int i = 0; i < n_nodes; i++)\n  {\n    (sol_file << (((double) j) / ((double) (n_nodes - 1)))) << \" \";\n  }\n\n  sol_file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/9"}
{"code": "for (iterator IT = Types.begin(), ET = Types.end(); IT != ET; ++IT, ++IC, ++II, ++IR)\n{\n  Data.push_back(ReductionData(*IT, *IR, *IC, *II));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/3"}
{"code": "for (int k = 0; k < n; k++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (output[(i * n) + j] > (output[(i * n) + k] + output[(k * n) + j]))\n      {\n        output[(i * n) + j] = output[(i * n) + k] + output[(k * n) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/floyd_warshall/2"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    if (image[i][j] == 1)\n    {\n      points.pb(mp(i, j));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/A1P2_solution/4"}
{"code": "for (int i = 0; i < 32; ++i)\n{\n  out[i] = (in >> i) & 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/grn/sw/src/main/0"}
{"code": "for (k = curr_body + 1; k < n; k++)\n{\n  force_qk[0] = bodies[curr_body].s[0] - bodies[k].s[0];\n  force_qk[1] = bodies[curr_body].s[1] - bodies[k].s[1];\n  dist = sqrt((force_qk[0] * force_qk[0]) + (force_qk[1] * force_qk[1]));\n  dist = (dist * dist) * dist;\n  force_qk[0] *= (((-G) * bodies[curr_body].m) * bodies[k].m) / dist;\n  force_qk[1] *= (((-G) * bodies[curr_body].m) * bodies[k].m) / dist;\n  omp_set_lock(&locks[curr_body]);\n  forces[curr_body][0] += force_qk[0];\n  forces[curr_body][1] += force_qk[1];\n  omp_unset_lock(&locks[curr_body]);\n  omp_set_lock(&locks[k]);\n  forces[k][0] -= force_qk[0];\n  forces[k][1] -= force_qk[1];\n  omp_unset_lock(&locks[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/omp-nbody-solver/3"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  noffp = k / mx1;\n  moffp = my * noffp;\n  noffp = mx * (k - (mx1 * noffp));\n  nppp = kpic[k];\n  nn = nx - noffp;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = nyp - moffp;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noffp;\n  edgerx = noffp + nn;\n  edgely = noff + moffp;\n  edgery = (noff + moffp) + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  mnoff = moffp + noff;\n  npoff = nppmx * k;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[(3 * i) + (mxv3 * j)] = fxy[3 * ((i + noffp) + (nxv * (j + moffp)))];\n      sfxy[(1 + (3 * i)) + (mxv3 * j)] = fxy[1 + (3 * ((i + noffp) + (nxv * (j + moffp))))];\n      sfxy[(2 + (3 * i)) + (mxv3 * j)] = fxy[2 + (3 * ((i + noffp) + (nxv * (j + moffp))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[(3 * i) + (mxv3 * j)] = bxy[3 * ((i + noffp) + (nxv * (j + moffp)))];\n      sbxy[(1 + (3 * i)) + (mxv3 * j)] = bxy[1 + (3 * ((i + noffp) + (nxv * (j + moffp))))];\n      sbxy[(2 + (3 * i)) + (mxv3 * j)] = bxy[2 + (3 * ((i + noffp) + (nxv * (j + moffp))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < nppp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = (3 * (nn - noffp)) + (mxv3 * (mm - mnoff));\n    amx = 1.0 - dxp;\n    amy = 1.0 - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += mxv3;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += mxv3;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[2 + (idimp * (j + npoff))] + dx;\n    acy = ppart[3 + (idimp * (j + npoff))] + dy;\n    acz = ppart[4 + (idimp * (j + npoff))] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0 / sqrtf(1.0 + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0 + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0 / (1.0 + omt);\n    omt = 0.5 * (1.0 - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[2 + (idimp * (j + npoff))] = dx;\n    ppart[3 + (idimp * (j + npoff))] = dy;\n    ppart[4 + (idimp * (j + npoff))] = dz;\n    p2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (dx * dtg);\n    dy = y + (dy * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noffp,moffp,nppp,npoff,nn,mm,nm,ih,nh,mnoff,x,y,dxp,dyp, amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1, rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery, p2,gami,qtmg,dtg,sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/4"}
{"code": "for (c = 0; c < 8; c++)\n{\n  soma = soma + v[c];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francisneibl/processamento_paralelo_imagens/fitroMedia/3"}
{"code": "for (int j = 1 << l; j < step_max; j++)\n{\n  tablo->tab[(2 * j) + 1] = tablo->tab[2 * j] + tablo->tab[j];\n  tablo->tab[2 * j] = tablo->tab[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/6"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a[i] = i * 1.5;\n  b[i] = i + 22.35;\n  c[i] = (d[i] = 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/omp_workshare2/0"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  result_local[i].count = 0;\n  result_local[i].elements = allocate((matrix.count + matrix2.count) * (sizeof(struct ELEMENT)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/10"}
{"code": "for (layer18_index = 0; layer18_index < Layer_CH_Num; layer18_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data19[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data19[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data19[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv18_data[(((layer18_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv19[(((((layer19_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer18_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv19_data[(((layer19_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data19[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/70"}
{"code": "for (i = 0; i < 20; i++)\n  cs->mac[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/putty_fmt_plug/0"}
{"code": "for (int i = 0; i < 64; i++)\n{\n  if (var[i] != 100)\n  {\n    printf(\"%d\\n\", var[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB163-simdmissinglock1-orig-gpu-no/2"}
{"code": "for (int i = 0, index = p_index; i < p_length; i++, index++)\n{\n  local_sum += (p_array[index] - p_mean) * (p_array[index] - p_mean);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/12"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  randA[i] = rand() % 1000;\n  randB[i] = rand() % 100;\n  randC[i] = (rand() % 10) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/loop_optimizations/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    matrix[i][j] = val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/icecr4ck/parallel-programming/openmp/labo2/2"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  double **sample_outputs = layer_outputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = sample_outputs[l - 1];\n    double *output = sample_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_fwd, 0);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU1/8"}
{"code": "for (unsigned int i = 0; i < _torsioncalculations.size(); ++i)\n  _torsioncalculations[i].SetupPointers();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/20"}
{"code": "for (unsigned int i = smaller; i < bigger; ++i)\n{\n  daughter[i] = daughter_mutation.at(index);\n  son[i] = son_mutation.at(index);\n  ++index;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/4"}
{"code": "for (int k = 0; k < N; k++)\n{\n  a[k] = b[k];\n  foo(k);\n}\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-1/no_loop_1/2"}
{"code": "for (i = 0; i < constraint_num; i++)\n{\n  if (i != min.index)\n  {\n    simplex_pivot2 = -standard_simplex_tableau[i][max.index];\n    for (j = 0; j <= column_num; j++)\n    {\n      standard_simplex_tableau[i][j] = (simplex_pivot2 * standard_simplex_tableau[min.index][j]) + standard_simplex_tableau[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arkaprabha10/Simplex-Algorithm/Algorithm/openmp_final/3"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(logFile, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(logFile, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(logFile, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(logFile, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_static/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double AynTmp = 0.0;\n  for (int j = 0; j < n; ++j)\n  {\n    AynTmp += A[j + (i * n)] * yn[j];\n  }\n\n  tn1 += yn[i] * AynTmp;\n  tn2 += AynTmp * AynTmp;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) reduction(+: tn1, tn2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/7"}
{"code": "for (i = 1; i < (height - 1); i++)\n{\n  mainField[0][i].present = LifeorDeath(mainField[0][i], mainField[0][i - 1], mainField[0][i + 1], mainField[1][i], mainField[1][i - 1], mainField[1][i + 1], mainField[width - 1][i], mainField[width - 1][i - 1], mainField[width - 1][i + 1]);\n  mainField[width - 1][i].present = LifeorDeath(mainField[width - 1][i], mainField[width - 1][i - 1], mainField[width - 1][i + 1], mainField[width - 2][i], mainField[width - 2][i - 1], mainField[width - 2][i + 1], mainField[0][i], mainField[0][i - 1], mainField[0][i + 1]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/lgame/1"}
{"code": "for (int j = 0; j < 10; j++)\n{\n  if (random)\n  {\n    for (int i = 0; i < 10000; i++)\n    {\n      A[i] = rand() % ((10000 - 1) + 1);\n    }\n\n  }\n  else\n  {\n    for (int i = 10000 - 1; i >= 0; i--)\n    {\n      A[i] = 10000 - i;\n    }\n\n  }\n\n  double start_omp_time = omp_get_wtime();\n  couting_sort_parallel(A, B, C);\n  double end_omp_time = omp_get_wtime();\n  double time_taken_parallel = end_omp_time - start_omp_time;\n  printf(\"%g segundos para executar o couting sort paralelo\\n\", time_taken_parallel);\n  mean += time_taken_parallel;\n  for (int i = 0; i < ((10000 - 1) + 1); i++)\n  {\n    C[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feperessim/counting-sort-parallel-openmp/counting_sort_parallel/3"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_teams_distribute_parallel_for); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/18"}
{"code": "for (i = 0; i < nd; i++)\n{\n  matrix[i] = malloc(nd * (sizeof(double)));\n  for (j = 0; j < nd; j++)\n  {\n    matrix[i][j] = distance(datapoints[i], datapoints[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/13"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  czekaj(1);\n  for (int j = 0; j < SIZE; j++)\n  {\n    for (int k = 0; k < SIZE; k++)\n    {\n      AB_0[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WikGru/ParallelOpenMP/zad1+/zad1+/1"}
{"code": "for (size_t i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < ITERS; j++)\n  {\n    C[i] = A[i] + B[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for is_device_ptr(A,B,C)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/usm/OmpHipMallocManaged/OmpHipMallocManaged/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    ex[i][j] = (((double) i) * (j + 1)) / nx;\n    ey[i][j] = (((double) i) * (j + 2)) / ny;\n    hz[i][j] = (((double) i) * (j + 3)) / nx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Fedor1533/FDTD-2D-solution-openMP-/fdtd-2d/5"}
{"code": "for (i = 0; i < (strlen(Q) + 1); i++)\n{\n  scoreTable[i] = (int *) calloc(Dc + 1, sizeof(int));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z1skgr/OpenMP-pthreads-parallelComputing/OMPa/5"}
{"code": "for (j = 0; j < nelem; j++)\n{\n  actg = listag[i].elemg[j];\n  for (k = j + 1; k < nelem; k++)\n  {\n    othg = listag[i].elemg[k];\n    acum += gendist(elem[actg], elem[othg]);\n    cont += 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k, actg, othg) reduction(+ : acum, cont) schedule(dynamic,2) num_threads(32)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/fun_p/1"}
{"code": "for (int i = 0; i < k; i++)\n{\n  char buffer[max_gene_len];\n  MPI_Bcast(buffer, local_genes_len[i], MPI_CHAR, root, comm);\n  buffer[local_genes_len[i]] = '\\0';\n  local_genes[i] = string(buffer, local_genes_len[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel4/2"}
{"code": "for (i = 0; i < NUM_OF_NODES; i++)\n{\n  fprintf(f, \"%f\\n\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anapt/PageRank/src/parallel/11"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (i = 0; i <= (grid_points[0] - 1); i += 1)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j += 1)\n    {\n      for (k = 0; k <= (grid_points[2] - 1); k += 1)\n      {\n        forcing[m][i][j][k] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/6"}
{"code": "for (; t < size; i++)\n{\n  block[t] = 1;\n  t += i << 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amosunov/polymult-1.3/init/5"}
{"code": "for (int k = 0; k < (counts[size - 1] + displs[size - 1]); k++)\n  alldata[k] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VulovicDanilo/PatternMatching/PatternMatcher/9"}
{"code": "for (k = 0; k < n; k++)\n{\n  for (j = k + 1; j < n; j++)\n  {\n    a[k + (j * stride)] /= a[k + (k * stride)];\n    alpha = -a[k + (j * stride)];\n    daxpy(&a[(k + 1) + (j * stride)], &a[(k + 1) + (k * stride)], (n - k) - 1, alpha);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n}\n\n", "pragma": "#pragma omp for reduction(- : fl)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/task_in_reduction_message/0"}
{"code": "for (int i = 0; i < 1; ++i)\n{\n  printf(\"ptr=%p\\n\", ptr);\n}\n\n", "pragma": "  #pragma omp target parallel for simd is_device_ptr(ptr) if(true)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kotsaloscv/target_offload_snippets/openmp_clause_ordering/openmp_target_offload_clause_ordering/0"}
{"code": "for (; vj < nvtxs; vj++)\n{\n  if (1 || ((xadj[vj + 1] - xadj[vj]) < ((nvtxs - vj) - 1)))\n  {\n    for (ej = (ejstart = xadj[vj]), ejend = xadj[vj + 1]; ej < ejend; ej++)\n      tmap[adjncy[ej]] = ej - ejstart;\n\n    for (ej = txadj[vj], ejend = txadj[vj + 1]; ej < ejend; ej += 2)\n    {\n      vi = tadjncy[ej];\n      for (nlocal = 0, ei = xadj[vi] + tadjncy[ej + 1], eiend = xadj[vi + 1]; ei < eiend; ei++)\n      {\n        if (tmap[adjncy[ei]] != (-1))\n        {\n          adjwgt[ei]++;\n          adjwgt[ejstart + tmap[adjncy[ei]]]++;\n          nlocal++;\n        }\n\n      }\n\n      if (nlocal > 0)\n      {\n        ntriangles += nlocal;\n        assert(adjncy[(xadj[vi] + tadjncy[ej + 1]) - 1] == vj);\n        adjwgt[(xadj[vi] + tadjncy[ej + 1]) - 1] += nlocal;\n      }\n\n    }\n\n    for (ej = xadj[vj], ejend = xadj[vj + 1]; ej < ejend; ej++)\n      tmap[adjncy[ej]] = -1;\n\n  }\n  else\n  {\n    tnc++;\n    for (nlocal = 0, ej = txadj[vj], ejend = txadj[vj + 1]; ej < ejend; ej += 2)\n    {\n      vi = tadjncy[ej];\n      nlocal += (xadj[vi + 1] - xadj[vi]) - tadjncy[ej + 1];\n    }\n\n    ntriangles += nlocal;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/16"}
{"code": "for (int i = 0; i < 102400; i++)\n{\n  sum += vecC[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/gpu-openmp/gpu-functions/sum/1"}
{"code": "for (int i = 0; i < line.size(); ++i)\n{\n  int pointI = line[i].i + di;\n  if ((0 <= pointI) && (pointI < height))\n    ++lineSize;\n  else\n    if (lineSize > 0)\n    break;\n\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muji-4ok/pixel-sort-qt5/sorter/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  R[i] = 0;\n  t[i] = 0;\n  for (j = i; j < N; j++)\n  {\n    t[i] += (d * M[i][j]) * last_R[j];\n  }\n\n}\n\n", "pragma": "omp for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/0"}
{"code": "for (wJ = wI; wJ < (wI + (BIGN / 4)); wJ++)\n{\n  aVect3[wJ] = aVect1[wJ] + aVect2[wJ];\n}\n\n", "pragma": "omp parallel for firstprivate(wI) private(wJ)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vectb/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (arr[i] > min)\n  {\n    buffer_send[send_counter + 1] = arr[i];\n    send_counter++;\n  }\n  else\n  {\n  }\n\n}\n\n", "pragma": "omp parallel for shared(arr, min, send_counter) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/bitonic-sort-project/src/hybrid/bitonic_sort_hybrid/0"}
{"code": "for (int i = 2; i < rangeSQRT; i += 1)\n{\n  if (primes[i] == 1)\n  {\n    for (int j = i * i; j < range; j += i)\n    {\n      primes[j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided,7)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code-mj12/Multithreaded-Codes/OpenMP/q1b/1"}
{"code": "for (i = 1; i <= 10000000; i = i + 1)\n{\n  buyerIndex = rand() % 100000;\n  bidPrice = (rand() % Buyers[buyerIndex].value) + 1;\n  sellerIndex = rand() % 100000;\n  askPrice = Sellers[sellerIndex].value + (rand() % ((20 - Sellers[sellerIndex].value) + 1));\n  if (((Buyers[buyerIndex].quantityHeld == 0) && (Sellers[sellerIndex].quantityHeld == 1)) && (bidPrice >= askPrice))\n  {\n    transactionPrice = askPrice + (rand() % ((bidPrice - askPrice) + 1));\n    Buyers[buyerIndex].price = transactionPrice;\n    Sellers[sellerIndex].price = transactionPrice;\n    Buyers[buyerIndex].quantityHeld = 1;\n    Sellers[sellerIndex].quantityHeld = 0;\n  }\n\n  ;\n}\n\n", "pragma": "omp parallel for private(buyerIndex, bidPrice, sellerIndex, askPrice, transactionPrice) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp2/0"}
{"code": "for (i = 0; i < 400; i++)\n{\n  r = (i * 97) % 400;\n  for (j = 0; j < r; j++)\n  {\n    m = (((j * 1021) * 71) % (400 * 400)) + 1;\n    matrix[(i * 400) + j] = m;\n    if (i == j)\n    {\n      matrix[(i * 400) + j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/floyd/src/floyd_gpu/2"}
{"code": "for (i = 0; i < distributed_particles; i++)\n{\n  for (j = 0; j < ((int) nDimensions); j++)\n  {\n    a = x_min + ((x_max - x_min) * gsl_rng_uniform(r));\n    b = x_min + ((x_max - x_min) * gsl_rng_uniform(r));\n    positions[i][j] = a;\n    pBestPositions[i][j] = a;\n    velocities[i][j] = (a - b) / 2.;\n  }\n\n  pBestFitness[i] = ackley(positions[i], (int) nDimensions);\n  if (pBestFitness[i] < gBestFitness)\n  {\n    gBestFitness = pBestFitness[i];\n    memmove((void *) gBestPosition, (void *) (&positions[i]), (sizeof(double)) * nDimensions);\n  }\n\n}\n\n", "pragma": "omp parallel for private(a,b) reduction(min:gBestFitness)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/omp/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  if (fscanf(fp, \"%d\", &mat[(i * n) + j]) == EOF)\n{\n  fclose(fp);\n  return -1;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gzachos/parallel-course-uoi/hw2/ex1/matmul_parallel_l0/1"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  isum = 0;\n  for (j = 0; j < 8; j++)\n  {\n    ist = ncl[j + (8 * k)];\n    ncl[j + (8 * k)] = isum;\n    isum += ist;\n  }\n\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ip = 0;\n  for (j = 0; j < nh; j++)\n  {\n    j1 = ihole[2 * ((j + 1) + ((ntmax + 1) * k))] - 1;\n    ist = ihole[1 + (2 * ((j + 1) + ((ntmax + 1) * k)))];\n    ii = ncl[(ist + (8 * k)) - 1];\n    if (ii < npbmx)\n    {\n      for (i = 0; i < idimp; i++)\n      {\n        ppbuff[i + (idimp * (ii + (npbmx * k)))] = ppart[i + (idimp * (j1 + (nppmx * k)))];\n      }\n\n    }\n    else\n    {\n      ip = 1;\n    }\n\n    ncl[(ist + (8 * k)) - 1] = ii + 1;\n  }\n\n  if (ip > 0)\n    *irc = ncl[7 + (8 * k)];\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,isum,ist,nh,ip,j1,ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/6"}
{"code": "for (i = low; i <= high; i++)\n{\n  if ((i == 1) || (i == 0))\n    continue;\n\n  flag = 1;\n  for (j = 2; j <= (i / 2); ++j)\n  {\n    if ((i % j) == 0)\n    {\n      flag = 0;\n      break;\n    }\n\n  }\n\n  double etime = omp_get_wtime() - stime;\n  if (flag == 1)\n    printf(\"\\n%d\\ttime for tid number %d: %f \", i, omp_get_thread_num(), etime);\n\n}\n\n", "pragma": "omp parallel for reduction(+:flag)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/primes/0"}
{"code": "for (i = 0; i < 100; i++)\n  B[i] = A[i] * 10;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLSTS/ThreadProgramming/OpenMP_ArrayMultiplies/0"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  Rprime[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReordering/2"}
{"code": "for (i = 1; i < (n + 1); i++)\n{\n  for (j = 1; j < (n + 1); j++)\n  {\n    u_new[(i * (n + 2)) + j] = 0.25 * ((((u_old[((i - 1) * (n + 2)) + j] + u_old[((i + 1) * (n + 2)) + j]) + u_old[((i * (n + 2)) + j) - 1]) + u_old[((i * (n + 2)) + j) + 1]) + ((h * h) * f[(i * (n + 2)) + j]));\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terkelbo/OpenMP-Poisson-Problem/src/jacobi_openmp1/0"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%d\\n\", b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/for_section/1"}
{"code": "for (j = 0; j < (W + 2); j++)\n{\n  harta[0][j] = 0;\n  harta_aux[0][j] = 0;\n  harta[H + 1][j] = 0;\n  harta_aux[H + 1][j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anaMirela/Tema1-APD/tema1/4"}
{"code": "for (size_t i = 0; i < cameras.size(); ++i)\n  cameras[i].R = rmats[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Abylay019/stitching_omp/stitching_omp/stitching_omp/4"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (fac1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/163"}
{"code": "for (i = 0; i < m; i++)\n  count[m] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HardiChandra/Parallel-Programming-Projects/Project4 Bucket Sort/Project4-BucketSort/Project4-BucketSortBackup/Project4-BucketSortBackup/1"}
{"code": "for (int i = 0; i < untill; i++)\n{\n  int work_for = (level * (i + 1)) - 1;\n  int get = work_for - (level / 2);\n  int temp = prefix[work_for][0];\n  prefix[work_for][0] += prefix[get][0];\n  prefix[get][0] = temp;\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/prefix_sum_2/2"}
{"code": "for (i = 0; i < npoints; i++)\n{\n  index = find_nearest_point(feature[i], nfeatures, clusters, nclusters);\n  if (membership[i] != index)\n    delta += 1.0;\n\n  membership[i] = index;\n  local_new_centers_len[tid][index]++;\n  for (j = 0; j < nfeatures; j++)\n    local_new_centers[tid][index][j] += feature[i][j];\n\n}\n\n", "pragma": "omp for private(i,j,index) firstprivate(npoints,nfeatures,nclusters) schedule(static) reduction(+:delta)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ubivam/OpenMP-Examples/kmeans/kmeans_clustering/0"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 10; j++)\n{\n  c[i][j] = a[i][j] + b[i][j];\n  k[i][j] = omp_get_thread_num();\n}\n\n\n", "pragma": "omp for schedule(static,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terbos/HPC-OPENMP/nested1/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    fprintf(fpc, \"%d \", C[i][j]);\n  }\n\n  fprintf(fpc, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment1/Asgn11/5"}
{"code": "for (i = 1; i < (500 - 1); i++)\n{\n  for (j = 1; j < (500 - 1); j++)\n  {\n    w[i][j] = (((u[i - 1][j] + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]) / 4.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/8"}
{"code": "for (j_imopVar121 = 1; j_imopVar121 < (grid_points[1] - 1); j_imopVar121++)\n{\n  for (k_imopVar122 = 1; k_imopVar122 < (grid_points[2] - 1); k_imopVar122++)\n  {\n    for (i_imopVar120 = 0; i_imopVar120 < grid_points[0]; i_imopVar120++)\n    {\n      tmp1 = 1.0 / u[i_imopVar120][j_imopVar121][k_imopVar122][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][0][0] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][0][1] = 1.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][0][2] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][0][3] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][0][4] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][1][0] = (-((u[i_imopVar120][j_imopVar121][k_imopVar122][1] * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][1])) + (((c2 * 0.50) * (((u[i_imopVar120][j_imopVar121][k_imopVar122][1] * u[i_imopVar120][j_imopVar121][k_imopVar122][1]) + (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * u[i_imopVar120][j_imopVar121][k_imopVar122][2])) + (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * u[i_imopVar120][j_imopVar121][k_imopVar122][3]))) * tmp2);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][1][1] = (2.0 - c2) * (u[i_imopVar120][j_imopVar121][k_imopVar122][1] / u[i_imopVar120][j_imopVar121][k_imopVar122][0]);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][1][2] = (-c2) * (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * tmp1);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][1][3] = (-c2) * (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * tmp1);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][1][4] = c2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][2][0] = (-(u[i_imopVar120][j_imopVar121][k_imopVar122][1] * u[i_imopVar120][j_imopVar121][k_imopVar122][2])) * tmp2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][2][1] = u[i_imopVar120][j_imopVar121][k_imopVar122][2] * tmp1;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][2][2] = u[i_imopVar120][j_imopVar121][k_imopVar122][1] * tmp1;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][2][3] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][2][4] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][3][0] = (-(u[i_imopVar120][j_imopVar121][k_imopVar122][1] * u[i_imopVar120][j_imopVar121][k_imopVar122][3])) * tmp2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][3][1] = u[i_imopVar120][j_imopVar121][k_imopVar122][3] * tmp1;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][3][2] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][3][3] = u[i_imopVar120][j_imopVar121][k_imopVar122][1] * tmp1;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][3][4] = 0.0;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][4][0] = (((c2 * (((u[i_imopVar120][j_imopVar121][k_imopVar122][1] * u[i_imopVar120][j_imopVar121][k_imopVar122][1]) + (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * u[i_imopVar120][j_imopVar121][k_imopVar122][2])) + (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * u[i_imopVar120][j_imopVar121][k_imopVar122][3]))) * tmp2) - (c1 * (u[i_imopVar120][j_imopVar121][k_imopVar122][4] * tmp1))) * (u[i_imopVar120][j_imopVar121][k_imopVar122][1] * tmp1);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][4][1] = ((c1 * u[i_imopVar120][j_imopVar121][k_imopVar122][4]) * tmp1) - (((0.50 * c2) * ((((3.0 * u[i_imopVar120][j_imopVar121][k_imopVar122][1]) * u[i_imopVar120][j_imopVar121][k_imopVar122][1]) + (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * u[i_imopVar120][j_imopVar121][k_imopVar122][2])) + (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * u[i_imopVar120][j_imopVar121][k_imopVar122][3]))) * tmp2);\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][4][2] = ((-c2) * (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * u[i_imopVar120][j_imopVar121][k_imopVar122][1])) * tmp2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][4][3] = ((-c2) * (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * u[i_imopVar120][j_imopVar121][k_imopVar122][1])) * tmp2;\n      fjac[i_imopVar120][j_imopVar121][k_imopVar122][4][4] = c1 * (u[i_imopVar120][j_imopVar121][k_imopVar122][1] * tmp1);\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][0][0] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][0][1] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][0][2] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][0][3] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][0][4] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][1][0] = (((-con43) * c3c4) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][1];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][1][1] = (con43 * c3c4) * tmp1;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][1][2] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][1][3] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][1][4] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][2][0] = ((-c3c4) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][2];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][2][1] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][2][2] = c3c4 * tmp1;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][2][3] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][2][4] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][3][0] = ((-c3c4) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][3];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][3][1] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][3][2] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][3][3] = c3c4 * tmp1;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][3][4] = 0.0;\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][4][0] = (((((-((con43 * c3c4) - c1345)) * tmp3) * (u[i_imopVar120][j_imopVar121][k_imopVar122][1] * u[i_imopVar120][j_imopVar121][k_imopVar122][1])) - (((c3c4 - c1345) * tmp3) * (u[i_imopVar120][j_imopVar121][k_imopVar122][2] * u[i_imopVar120][j_imopVar121][k_imopVar122][2]))) - (((c3c4 - c1345) * tmp3) * (u[i_imopVar120][j_imopVar121][k_imopVar122][3] * u[i_imopVar120][j_imopVar121][k_imopVar122][3]))) - ((c1345 * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][4]);\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][4][1] = (((con43 * c3c4) - c1345) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][1];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][4][2] = ((c3c4 - c1345) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][2];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][4][3] = ((c3c4 - c1345) * tmp2) * u[i_imopVar120][j_imopVar121][k_imopVar122][3];\n      njac[i_imopVar120][j_imopVar121][k_imopVar122][4][4] = c1345 * tmp1;\n    }\n\n    for (i_imopVar120 = 1; i_imopVar120 < (grid_points[0] - 1); i_imopVar120++)\n    {\n      tmp1 = dt * tx1;\n      tmp2 = dt * tx2;\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][0][0] = (((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][0]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][0])) - (tmp1 * dx1);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][0][1] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][1]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][0][2] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][2]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][0][3] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][3]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][0][4] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][4]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][0][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][1][0] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][0]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][1][1] = (((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][1]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][1])) - (tmp1 * dx2);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][1][2] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][2]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][1][3] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][3]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][1][4] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][4]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][1][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][2][0] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][0]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][2][1] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][1]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][2][2] = (((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][2]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][2])) - (tmp1 * dx3);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][2][3] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][3]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][2][4] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][4]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][2][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][3][0] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][0]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][3][1] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][1]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][3][2] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][2]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][3][3] = (((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][3]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][3])) - (tmp1 * dx4);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][3][4] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][4]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][3][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][4][0] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][0]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][4][1] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][1]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][4][2] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][2]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][4][3] = ((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][3]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][0][4][4] = (((-tmp2) * fjac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][4]) - (tmp1 * njac[i_imopVar120 - 1][j_imopVar121][k_imopVar122][4][4])) - (tmp1 * dx5);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][0][0])) + ((tmp1 * 2.0) * dx1);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][0][1] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][0][1];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][0][2] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][0][2];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][0][3] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][0][3];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][0][4] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][0][4];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][1][0] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][1][0];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][1][1])) + ((tmp1 * 2.0) * dx2);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][1][2] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][1][2];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][1][3] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][1][3];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][1][4] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][1][4];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][2][0] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][2][0];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][2][1] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][2][1];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][2][2])) + ((tmp1 * 2.0) * dx3);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][2][3] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][2][3];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][2][4] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][2][4];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][3][0] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][3][0];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][3][1] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][3][1];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][3][2] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][3][2];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][3][3])) + ((tmp1 * 2.0) * dx4);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][3][4] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][3][4];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][4][0] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][4][0];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][4][1] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][4][1];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][4][2] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][4][2];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][4][3] = (tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][4][3];\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][1][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i_imopVar120][j_imopVar121][k_imopVar122][4][4])) + ((tmp1 * 2.0) * dx5);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][0][0] = ((tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][0]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][0])) - (tmp1 * dx1);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][0][1] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][1]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][0][2] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][2]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][0][3] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][3]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][0][4] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][4]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][0][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][1][0] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][0]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][1][1] = ((tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][1]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][1])) - (tmp1 * dx2);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][1][2] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][2]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][1][3] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][3]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][1][4] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][4]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][1][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][2][0] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][0]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][2][1] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][1]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][2][2] = ((tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][2]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][2])) - (tmp1 * dx3);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][2][3] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][3]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][2][4] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][4]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][2][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][3][0] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][0]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][3][1] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][1]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][3][2] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][2]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][3][3] = ((tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][3]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][3])) - (tmp1 * dx4);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][3][4] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][4]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][3][4]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][4][0] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][0]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][0]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][4][1] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][1]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][1]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][4][2] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][2]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][2]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][4][3] = (tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][3]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][3]);\n      lhs[i_imopVar120][j_imopVar121][k_imopVar122][2][4][4] = ((tmp2 * fjac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][4]) - (tmp1 * njac[i_imopVar120 + 1][j_imopVar121][k_imopVar122][4][4])) - (tmp1 * dx5);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/28"}
{"code": "for (int i = 0; i < rowCount; i++)\n{\n  for (int j = row_ptr[i]; j < row_ptr[i + 1]; j++)\n    x[k + 1][i] += values[j] * x[k][col_ind[j]];\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/0"}
{"code": "for (size_t l_ve = 0; l_ve < l_vePerm.size(); l_ve++)\n{\n  l_vePerm[l_ve] = l_ve;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/io/Gmsh/0"}
{"code": "for (iterator CIter = C.begin(); CIter != C.end(); CIter++)\n{\n  elements.push_back(&(*CIter));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BaoVo96/Apriori/apriori_v2_omp_final/10"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n  work_buff[key_buff_ptr2[i]]++;\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/2"}
{"code": "for (cn = num_outgoing.begin(); cn != num_outgoing.end(); cn++)\n{\n  (cout << (*cn)) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/pagerank/src/omp_pagerank_v1/0"}
{"code": "form[0] = format(nb.tasks)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/smoothing/1"}
{"code": "for (unsigned int i = 0; i < g.nchunks_to_process; ++i)\n{\n  if (i > 0)\n    msg << \", \";\n\n  ((((msg << \"<\") << g.chunks_to_process[i].in_bitmap_index) << \" -> \") << g.chunks_to_process[i].out_bitmap_index) << \">\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/17"}
{"code": "for (n = 0; n < pp.np; n++)\n{\n  ix = (Xdots * pp.x[n]) / Dx;\n  if ((ix >= (Xdots - 1)) || (ix <= 0))\n    continue;\n\n  iy = (Ydots * pp.y[n]) / Dy;\n  if ((iy >= (Ydots - 1)) || (iy <= 0))\n    continue;\n\n  wv = pp.weight[n] - rmin;\n  wp = (10.0 * wv) / wint;\n  pgrid->Values[ix + (iy * Xdots)] = wp;\n  pgrid->Values[(ix - 1) + (iy * Xdots)] = wp;\n  pgrid->Values[(ix + 1) + (iy * Xdots)] = wp;\n  pgrid->Values[ix + ((iy - 1) * Xdots)] = wp;\n  pgrid->Values[ix + ((iy + 1) * Xdots)] = wp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/7"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  v_it = _mm512_set1_epi32(k);\n  v_dky = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dky = _mm512_mul_ps(v_dny, v_dky);\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  dky2 = dky * dky;\n  v_dkyz2 = _mm512_mul_ps(v_dky, v_dky);\n  v_dk = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(3084), v_dky);\n  for (j = 0; j < nxhs; j += 2)\n  {\n    v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n    v_dkx = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dkx = _mm512_mul_ps(v_dnx, v_dkx);\n    v_at1 = _mm512_fmadd_ps(v_dkx, v_dkx, v_dkyz2);\n    v_at1 = _mm512_div_ps(v_one, v_at1);\n    v_dk = _mm512_mask_mov_ps(v_dk, _mm512_int2mask(771), v_dkx);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + kj)]));\n    v_zt1 = _mm512_mul_ps(v_dk, v_zt2);\n    v_at = (int) _mm512_shuffle_epi32((int) v_zt1, 78);\n    v_zt1 = _mm512_add_ps(v_at, v_zt1);\n    v_at = _mm512_permute4f128_ps(v_zt1, 177);\n    v_zt1 = _mm512_mul_ps(v_at1, _mm512_add_ps(v_at, v_zt1));\n    if (j == 0)\n    {\n      v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n    }\n\n    v_zt2 = _mm512_sub_ps(v_zt2, _mm512_mul_ps(v_dk, v_zt1));\n    _mm512_store_ps((float *) (&cu[4 * (j + kj)]), v_zt2);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + k1)]));\n    v_as = _mm512_mask_sub_ps(v_dk, _mm512_int2mask(3084), v_zero, v_dk);\n    v_zt1 = _mm512_mul_ps(v_as, v_zt2);\n    v_at = (int) _mm512_shuffle_epi32((int) v_zt1, 78);\n    v_zt1 = _mm512_add_ps(v_at, v_zt1);\n    v_at = _mm512_permute4f128_ps(v_zt1, 177);\n    v_zt1 = _mm512_mul_ps(v_at1, _mm512_add_ps(v_at, v_zt1));\n    if (j == 0)\n    {\n      v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n      ;\n    }\n\n    v_zt2 = _mm512_sub_ps(v_zt2, _mm512_mul_ps(v_as, v_zt1));\n    _mm512_store_ps((float *) (&cu[4 * (j + k1)]), v_zt2);\n    _mm512_store_ps((float *) (&cu[4 * ((j + kj) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&cu[4 * ((j + k1) + l1)]), v_zero);\n  }\n\n  for (j = itn; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1.0 / ((dkx * dkx) + dky2);\n    zt1 = at1 * ((dkx * cu[4 * (j + kj)]) + (dky * cu[1 + (4 * (j + kj))]));\n    cu[4 * (j + kj)] -= dkx * zt1;\n    cu[1 + (4 * (j + kj))] -= dky * zt1;\n    zt1 = at1 * ((dkx * cu[4 * (j + k1)]) - (dky * cu[1 + (4 * (j + k1))]));\n    cu[4 * (j + k1)] -= dkx * zt1;\n    cu[1 + (4 * (j + k1))] += dky * zt1;\n    cu[4 * ((j + kj) + l1)] = zero;\n    cu[1 + (4 * ((j + kj) + l1))] = zero;\n    cu[2 + (4 * ((j + kj) + l1))] = zero;\n    cu[4 * ((j + k1) + l1)] = zero;\n    cu[1 + (4 * ((j + k1) + l1))] = zero;\n    cu[2 + (4 * ((j + k1) + l1))] = zero;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kj,dky,dky2,dkx,at1,zt1,v_it,v_dk,v_dkx,v_dky,v_dkyz2, v_at1,v_zt1,v_zt2,v_at,v_as)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/18"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double next_x = b[i];\n  for (int j = 0; j < n; ++j)\n  {\n    if (i != j)\n    {\n      next_x -= A[i][j] * x[j];\n    }\n\n  }\n\n  next_x /= A[i][i];\n  norm = max(fabs(x[i] - next_x), norm);\n  x[i] = next_x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/8"}
{"code": "for (int k = 0; k < model->no_clusters; k++)\n{\n  for (int c = 0; c < model->columns; c++)\n  {\n    if (cluster_count[k] != 0)\n      model->centroids[(k * model->columns) + c] = sum_cluster_columns[(k * model->columns) + c] / ((float) cluster_count[k]);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajshrestha86/kmeans-clusterize/openmp/kmeans_omp/3"}
{"code": "for (int jj = internal_ystart - 1; jj < (internal_ystop + 1); jj++)\n{\n  for (int ji = internal_xstart - 1; ji <= (internal_xstop + 1); ji++)\n  {\n    int idx = (jj * width) + ji;\n    un[idx] = ua[idx];\n    vn[idx] = va[idx];\n    sshn_t[idx] = ssha_t[idx];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    *((q + (j * n)) + i) = *((d + (j * n)) + i);\n  }\n\n  for (int j = 0; j < n; j++)\n  {\n    if (j < i)\n    {\n      float dotp = subtractProjOnUnitVecFromRes(q + i, q + j, d + i, m, n);\n      *((r + (j * n)) + i) = dotp;\n    }\n    else\n    {\n      *((r + (j * n)) + i) = 0.0;\n    }\n\n  }\n\n  float norm = 0.0;\n  for (int j = 0; j < m; j++)\n  {\n    norm += (*((q + (j * n)) + i)) * (*((q + (j * n)) + i));\n  }\n\n  norm = sqrt(norm);\n  *((r + (i * n)) + i) = norm;\n  for (int j = 0; j < m; j++)\n  {\n    *((q + (j * n)) + i) /= norm;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/5"}
{"code": "for (i = 0; i < COUNT; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "#pragma omp parallel for shared(sum)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest08/simple_test_08/0"}
{"code": "for (j = 0; j < n; j++)\n  flag[j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PushenGao/Parallel-Computing-/GA_Queens_OpenMp/9"}
{"code": "for (int i = 1; i < n; i++)\n{\n  if (dp[m - 1][i] == INT_MAX)\n    continue;\n\n  if ((dp[m - 1][i] + d[i][0]) < ans)\n  {\n    if ((dp[m - 1][i] + d[i][0]) < ans)\n    {\n      ans = dp[m - 1][i] + d[i][0];\n      st = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurbaaz27/CS433A-Design-Exercises/assignment1/Q1/3"}
{"code": "for (int i = 0; i < s2->tau.size(); i++)\n  tau.push_back(s2->tau[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/117"}
{"code": "for (int i = 0; i < N; ++i)\n  sum += hst_ptr[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/test/api/omp_host_pinned_memory/2"}
{"code": "for (int i = 0; i < len; i++)\n{\n  v_i[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tlqtangok/openmp_demo/06_mix/main/0"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  res[i] += carry;\n  carry = res[i] / 10;\n  res[i] %= 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mlchkhn/parallel_algorithms/multiplication/9"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double factor = prefactRef[box][i] * ((sumRref[box][i] * sumRref[box][i]) + (sumIref[box][i] * sumIref[box][i]));\n  wT11 += factor * (1.0 - (((2.0 * (constVal + (1.0 / hsqrRef[box][i]))) * kxRef[box][i]) * kxRef[box][i]));\n  wT22 += factor * (1.0 - (((2.0 * (constVal + (1.0 / hsqrRef[box][i]))) * kyRef[box][i]) * kyRef[box][i]));\n  wT33 += factor * (1.0 - (((2.0 * (constVal + (1.0 / hsqrRef[box][i]))) * kzRef[box][i]) * kzRef[box][i]));\n}\n\n", "pragma": "  #pragma omp parallel for default(none) shared(box, constVal) reduction(+:wT11, wT22, wT33)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/24"}
{"code": "for (i = 0; i < generation_size; i++)\n{\n  temp_d = 0;\n  for (j = 1; j < (num_cities + 1); j++)\n  {\n    temp_d = temp_d + calculate_distance(generation[i].gene[j % num_cities].x_coordinate, generation[i].gene[(j - 1) % num_cities].x_coordinate, generation[i].gene[j % num_cities].y_coordinate, generation[i].gene[(j - 1) % num_cities].y_coordinate);\n  }\n\n  generation[i].distance = temp_d;\n}\n\n", "pragma": "\t#pragma omp parallel for private(j, temp_d) shared(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prachi220/Parallel-Programming/Travelling Salesman Problem/tsp_2014CS50289/3"}
{"code": "for (int i = 0; i < edge_list_size; i++)\n{\n  h_graph_edges[i] = idd[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_test/3"}
{"code": "for (int a = r; a < (r + window); a++)\n{\n  for (int b = c; b < (c + window); b++)\n  {\n    mat[a][b] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/5"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if (((m != centre) && (m != ind1)) && (m != ind2))\n  {\n    if ((min3 == (-1.0)) || (dist_list[m] < min3))\n    {\n      min3 = dist_list[m];\n      ind3 = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/17"}
{"code": "for (i = 0; i < (R * C); i++)\n{\n  if (new_eco[i].type == RABBIT)\n  {\n    new_eco[i].gen_proc++;\n    new_eco[i].temp_type = RABBIT;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/3"}
{"code": "for (int i = 0; i < 6; ++i)\n{\n  for (int j = 0; j < 8; ++j)\n  {\n    d[i][j] = rand() % randMax;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/18"}
{"code": "for (int j = sv; j < arr.size(); j += 2)\n{\n  if (arr[j] > arr[j - 1])\n  {\n    t = arr[j];\n    arr[j] = arr[j - 1];\n    arr[j - 1] = t;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/bubble_sort_openmp/0"}
{"code": "for (i = 0; i < 2000; i++)\n  for (j = 0; j < 2000; j++)\n  im[i][j] = fgetc(img);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment2/Asgn2/2"}
{"code": "for (int i = 0; i < number_of_images; ++i)\n{\n  for (int r = 0; r < n_rows; ++r)\n  {\n    for (int c = 0; c < n_cols; ++c)\n    {\n      unsigned char temp = 0;\n      file.read((char *) (&temp), sizeof(temp));\n      if (temp == 0)\n      {\n        mnist_training_data[i][(n_rows * r) + c] = (double) temp;\n      }\n      else\n      {\n        mnist_training_data[i][(n_rows * r) + c] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  x2[i] = (y[i] + x2[i]) / 7;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment9/Task1/Dependency/1"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if ((cycleID[i] % 2) == 0)\n  {\n    ret[i] = p2[i];\n    ret[dim + i] = p1[i];\n  }\n  else\n  {\n    ret[i] = p1[i];\n    ret[dim + i] = p2[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/12"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET(errors, d[i] != ((((10 + 1) + i) * 2) * i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_firstprivate/3"}
{"code": "for (int i = 0; i < nRows; i++)\n{\n  for (int j = 0; j < nRows; j++)\n  {\n    a[(i * nRows) + j] = rand();\n    b[(i * nRows) + j] = rand();\n    cOpenMp[(i * nRows) + j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/popandopulogeo/RibbonMatrixMultiplication/OpenMP/OpenMP/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  graph[i] = (GraphNode **) malloc((sizeof(GraphNode *)) * size);\n  for (j = 0; j < size; j++)\n  {\n    graph[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/5"}
{"code": "for (register int i = 0; i < nxn; i++)\n  for (register int j = 0; j < nyn; j++)\n  for (register int k = 0; k < nzn; k++)\n{\n  Jx[i][j][k] = 0.0;\n  Jxh[i][j][k] = 0.0;\n  Jy[i][j][k] = 0.0;\n  Jyh[i][j][k] = 0.0;\n  Jz[i][j][k] = 0.0;\n  Jzh[i][j][k] = 0.0;\n  rhon[i][j][k] = 0.0;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/49"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double Se;\n  double _theta;\n  double _psi;\n  double lambda;\n  double m;\n  lambda = n - 1.0;\n  m = lambda / n;\n  _psi = psi[i] * 100;\n  if (_psi < 0)\n    _theta = ((theta_S - theta_R) / pow(1.0 + pow(alpha * (-_psi), n), m)) + theta_R;\n  else\n    _theta = theta_S;\n\n  theta[i] = _theta;\n  Se = (_theta - theta_R) / (theta_S - theta_R);\n  K[i] = ((Ksat[i] * sqrt(Se)) * (1.0 - pow(1.0 - pow(Se, 1.0 / m), m))) * (1.0 - pow(1.0 - pow(Se, 1.0 / m), m));\n  if (_psi < 0)\n    C[i] = (((((100 * alpha) * n) * ((1.0 / n) - 1.0)) * pow(alpha * abs(_psi), n - 1)) * (theta_R - theta_S)) * pow(pow(alpha * abs(_psi), n) + 1, (1.0 / n) - 2.0);\n  else\n    C[i] = 0.0;\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vanGenuchten-omp/main/0"}
{"code": "for (int i = 0; i < nPoints; i++)\n{\n  fprintf(f, \"%d %lf %lf\\n\", points[i].clusterID, points[i].x, points[i].y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/Parallel_implementation_K_Means/Parallel_implementation_K_Means/Main/14"}
{"code": "for (int i = 1; i < (COLUMN - 1); i++)\n{\n  for (int j = 1; j < (ROW - 1); j++)\n  {\n    f >> currentGeneration[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rzaaeeff/GameofLife-OpenMP/GoLParallel/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 27) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    int failed = 0;\n    switch ('S')\n    {\n      case 'S':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'W':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 2)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'D':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n    }\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/22"}
{"code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  i1 = nxhd * nyh;\n  i0 = i1 + ll;\n  i1 += l1;\n  t1 = f[i1];\n  f[i1] = 0.5 * (cimagf(f[i0] + t1) + (crealf(f[i0] - t1) * _Complex_I));\n  f[i0] = 0.5 * (crealf(f[i0] + t1) + (cimagf(f[i0] - t1) * _Complex_I));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/59"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (max_serial < arr[i])\n  {\n    max_serial = arr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/max/0"}
{"code": "for (int i = 0; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    a[i][j] = distribution(generator);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sahilbansal17/Parallel-Programs/OpenMP/Matrix Multiplication/matrixMultiplication/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  const unsigned char color[] = {(unsigned char) (m[i] / SQRT_MAX_WEIGHT), 255, (unsigned char) (((int) m[i]) % SQRT_MAX_WEIGHT)};\n  img.draw_point(x[i], y[i], color);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brabemi/ctu-fit-mi-pap-mod/main/0"}
{"code": "for (i = 0; i < diff; i++)\n{\n  int v;\n  v = 0;\n  for (j = 0; j < 500; j++)\n  {\n    if (frase[i + j] != palavra[j])\n    {\n      v = 1;\n    }\n\n  }\n\n  if (v == 0)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/str-matching/src/str-matching_gpu/5"}
{"code": "for (x = 0; x < MATRIX_SIZE; x++)\n  for (y = MATRIX_SIZE - (MATRIX_SIZE % (numOfThreads - 1)); y < MATRIX_SIZE; y++)\n{\n  for (z = 0; z < MATRIX_SIZE; z++)\n  {\n    matrixResult[y][x] += matrixOne[y][z] * matrixTwo[z][x];\n  }\n\n}\n\n\n", "pragma": "\t\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AhmadMamduhh/ParallelMatrixMultiplicationRepo/MatrixMultiplicationHybrid/3"}
{"code": "for (i = 0; i < 160; i++)\n  for (j = 0; j < 90; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "omp for ordered schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_8/Ejercicio_2/matrixMulti_openmp/2"}
{"code": "for (i = 0; i < numOfProc; i++)\n{\n  disp[i] = counter;\n  if (i == root)\n  {\n    counts[i] = rootDatabaseSize;\n    counter += rootDatabaseSize;\n  }\n  else\n  {\n    counts[i] = salveDatabaseSize;\n    counter += salveDatabaseSize;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/MPI_Kmeans/5"}
{"code": "for (long i = 0; i < n_unionized_grid_points; i++)\n  energy_grid[i].xs_ptrs = n_isotopes * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/xsbench-mp4/src/GridInit/5"}
{"code": "for (int i = 0; i < num_conflicts; ++i)\n{\n  for (int j = 0; j < (maxd + 1); ++j)\n  {\n    forbidden[i][j] = false;\n  }\n\n  int v = conflicts[i];\n  for (int j = 0; j < m[v]; ++j)\n  {\n    int u = adj_list[v][j];\n    if (colors[u] >= 0)\n      forbidden[i][colors[u]] = true;\n\n  }\n\n  for (int j = 0; j < (maxd + 1); ++j)\n  {\n    if (forbidden[i][j] == false)\n    {\n      colors[v] = j;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Vertex-Coloring/parallel-omp/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/104"}
{"code": "for (j = 0; j < num_snakes; j++)\n{\n  if (collision == 1)\n  {\n    world[snakes[j].head.line][snakes[j].head.col] = 0;\n    world[tail[j].line][tail[j].col] = snakes[j].encoding;\n    if ((snakes[j].head.line != 0) && (world[snakes[j].head.line - 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line -= 1;\n    }\n    else\n      if ((snakes[j].head.line == 0) && (world[num_lines - 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line = num_lines - 1;\n    }\n    else\n      if ((snakes[j].head.col != 0) && (world[snakes[j].head.line][snakes[j].head.col - 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col -= 1;\n    }\n    else\n      if ((snakes[j].head.col == 0) && (world[snakes[j].head.line][num_cols - 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col = num_cols - 1;\n    }\n    else\n      if ((snakes[j].head.line != (num_lines - 1)) && (world[snakes[j].head.line + 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line += 1;\n    }\n    else\n      if ((snakes[j].head.line == (num_lines - 1)) && (world[0][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line = 0;\n    }\n    else\n      if ((snakes[j].head.col != (num_cols - 1)) && (world[snakes[j].head.line][snakes[j].head.col + 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col += 1;\n    }\n    else\n      if ((snakes[j].head.col == (num_cols - 1)) && (world[snakes[j].head.line][0] == snakes[j].encoding))\n    {\n      snakes[j].head.col = 0;\n    }\n\n\n\n\n\n\n\n\n  }\n  else\n    if (collision == 0)\n  {\n    if ((tail[j].line != 0) && (world[tail[j].line - 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line -= 1;\n    }\n    else\n      if ((tail[j].line == 0) && (world[num_lines - 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line = num_lines - 1;\n    }\n    else\n      if ((tail[j].col != 0) && (world[tail[j].line][tail[j].col - 1] == snakes[j].encoding))\n    {\n      tail[j].col -= 1;\n    }\n    else\n      if ((tail[j].col == 0) && (world[tail[j].line][num_cols - 1] == snakes[j].encoding))\n    {\n      tail[j].col = num_cols - 1;\n    }\n    else\n      if ((tail[j].line != (num_lines - 1)) && (world[tail[j].line + 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line += 1;\n    }\n    else\n      if ((tail[j].line == (num_lines - 1)) && (world[0][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line = 0;\n    }\n    else\n      if ((tail[j].col != (num_cols - 1)) && (world[tail[j].line][tail[j].col + 1] == snakes[j].encoding))\n    {\n      tail[j].col += 1;\n    }\n    else\n      if ((tail[j].col == (num_cols - 1)) && (world[tail[j].line][0] == snakes[j].encoding))\n    {\n      tail[j].col = 0;\n    }\n\n\n\n\n\n\n\n\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yanxiaojing16/Parallel-Snake---OpenMP/parallel_snake/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (i == 0)\n  {\n    teams1 = omp_get_num_teams();\n    threads1 = omp_get_num_threads();\n    if (DEBUG)\n      printf(\"  num teams %d, num thread %d\\n\", teams1, threads1);\n\n  }\n\n  A[i] = 2 * i;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(teams1, threads1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/xt-nums-in-teams-par-for-default/test/0"}
{"code": "for (int i = 0; i < a.size(); i++)\n{\n  first = true;\n  for (int j = 0; j < a[0].size(); j++)\n  {\n    if (!first)\n    {\n      cout << \", \";\n    }\n\n    first = false;\n    printf(\"%8.20f\", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/Instrumental/0"}
{"code": "for (j = 0; j < 4; j++)\n{\n  ((((cout << \"j  Threads:\") << omp_get_num_threads()) << \"  ThreadID:\") << omp_get_thread_num()) << \"\\n\";\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gnnnn/openmp-/OpenMPdemo/\u5d4c\u5957\u5e76\u884c/\u5d4c\u5957\u5e76\u884c/NestingTest/1"}
{"code": "for (i = 0; i < max_cpu; ++i)\n{\n  int cpu = i;\n  if (affinity_mask_isset(mask, cpu))\n  {\n    int j;\n    int found = 0;\n    for (j = 0; j < num_procs; ++j)\n    {\n      if (ids[j] == cpu)\n      {\n        found = 1;\n        break;\n      }\n\n    }\n\n    if (!found)\n      return 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/root-threads-affinity/1"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  mean = (mean + w[i][0]) + w[i][N - 1];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:mean)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 4/heated-plate-parallel/4"}
{"code": "for (int32_t i = 0; i < 10; i++)\n  assert(sum[i] == (i + 1));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_08/1"}
{"code": "for (int i = 0; i < n_local; i++)\n  p_local[i] = z_local[i] + (beta * p_local[i]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/8"}
{"code": "for (int l = 0; l < CVT_INT(m_nSoilLyrs[i]); l++)\n{\n  m_soilRsd[i][l] += tmp_rtfr[i][l] * rtresnew;\n  m_soilFrshOrgN[i][l] += (tmp_rtfr[i][l] * ff2) * (m_pltN[i] - yieldn);\n  m_soilFrshOrgP[i][l] += (tmp_rtfr[i][l] * ff2) * (m_pltP[i] - yieldp);\n  if (m_cbnModel == 2)\n  {\n    if (l == 1)\n    {\n      sf = 0.05f;\n    }\n    else\n    {\n      sf = 0.1f;\n    }\n\n    sol_min_n = m_soilNO3[i][l] + m_soilNH4[i][l];\n    resnew = tmp_rtfr[i][l] * rtresnew;\n    resnew_n = (tmp_rtfr[i][l] * ff2) * (m_pltN[i] - yieldn);\n    resnew_ne = resnew_n + (sf * sol_min_n);\n    RLN = (resnew * CLG) / (resnew_n + 1.e-5f);\n    RLR = Min(0.8f, ((resnew * CLG) / 1000.f) / ((resnew / 1000.f) + 1.e-5f));\n    LMF = 0.85f - (0.018f * RLN);\n    if (LMF < 0.01f)\n    {\n      LMF = 0.01f;\n    }\n    else\n      if (LMF > 0.7f)\n      LMF = 0.7f;\n\n\n    LSF = 1.f - LMF;\n    m_soilLM[i][l] += LMF * resnew;\n    m_soilLS[i][l] += LSF * resnew;\n    m_soilLSL[i][l] += (RLR * LSF) * resnew;\n    m_soilLSC[i][l] += (0.42f * LSF) * resnew;\n    m_soilLSLC[i][l] += ((RLR * 0.42f) * LSF) * resnew;\n    m_soilLSLNC[i][l] = m_soilLSC[i][l] - m_soilLSLC[i][l];\n    if (resnew_ne > (((0.42f * LSF) * resnew) / 150.f))\n    {\n      m_soilLSN[i][l] += ((0.42f * LSF) * resnew) / 150.f;\n      m_soilLMN[i][l] += (resnew_ne - (((0.42f * LSF) * resnew) / 150.f)) + 1.e-25f;\n    }\n    else\n    {\n      m_soilLSN[i][l] += resnew_ne;\n      m_soilLMN[i][l] += 1.e-25f;\n    }\n\n    m_soilLMC[i][l] += (0.42f * LMF) * resnew;\n    m_soilNO3[i][l] *= 1.f - sf;\n    m_soilNH4[i][l] *= 1.f - sf;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/management/PLTMGT_SWAT/managementOperation_SWAT/6"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].print_layer_info();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    fac2 = 1. / lhs[n + 2][i][j1][k];\n    rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/57"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  tmp1 = dt * tz1;\n  tmp2 = dt * tz2;\n  lhs[i][j][k][0][0][0] = (((-tmp2) * fjac[i][j][k - 1][0][0]) - (tmp1 * njac[i][j][k - 1][0][0])) - (tmp1 * dz1);\n  lhs[i][j][k][0][0][1] = ((-tmp2) * fjac[i][j][k - 1][0][1]) - (tmp1 * njac[i][j][k - 1][0][1]);\n  lhs[i][j][k][0][0][2] = ((-tmp2) * fjac[i][j][k - 1][0][2]) - (tmp1 * njac[i][j][k - 1][0][2]);\n  lhs[i][j][k][0][0][3] = ((-tmp2) * fjac[i][j][k - 1][0][3]) - (tmp1 * njac[i][j][k - 1][0][3]);\n  lhs[i][j][k][0][0][4] = ((-tmp2) * fjac[i][j][k - 1][0][4]) - (tmp1 * njac[i][j][k - 1][0][4]);\n  lhs[i][j][k][0][1][0] = ((-tmp2) * fjac[i][j][k - 1][1][0]) - (tmp1 * njac[i][j][k - 1][1][0]);\n  lhs[i][j][k][0][1][1] = (((-tmp2) * fjac[i][j][k - 1][1][1]) - (tmp1 * njac[i][j][k - 1][1][1])) - (tmp1 * dz2);\n  lhs[i][j][k][0][1][2] = ((-tmp2) * fjac[i][j][k - 1][1][2]) - (tmp1 * njac[i][j][k - 1][1][2]);\n  lhs[i][j][k][0][1][3] = ((-tmp2) * fjac[i][j][k - 1][1][3]) - (tmp1 * njac[i][j][k - 1][1][3]);\n  lhs[i][j][k][0][1][4] = ((-tmp2) * fjac[i][j][k - 1][1][4]) - (tmp1 * njac[i][j][k - 1][1][4]);\n  lhs[i][j][k][0][2][0] = ((-tmp2) * fjac[i][j][k - 1][2][0]) - (tmp1 * njac[i][j][k - 1][2][0]);\n  lhs[i][j][k][0][2][1] = ((-tmp2) * fjac[i][j][k - 1][2][1]) - (tmp1 * njac[i][j][k - 1][2][1]);\n  lhs[i][j][k][0][2][2] = (((-tmp2) * fjac[i][j][k - 1][2][2]) - (tmp1 * njac[i][j][k - 1][2][2])) - (tmp1 * dz3);\n  lhs[i][j][k][0][2][3] = ((-tmp2) * fjac[i][j][k - 1][2][3]) - (tmp1 * njac[i][j][k - 1][2][3]);\n  lhs[i][j][k][0][2][4] = ((-tmp2) * fjac[i][j][k - 1][2][4]) - (tmp1 * njac[i][j][k - 1][2][4]);\n  lhs[i][j][k][0][3][0] = ((-tmp2) * fjac[i][j][k - 1][3][0]) - (tmp1 * njac[i][j][k - 1][3][0]);\n  lhs[i][j][k][0][3][1] = ((-tmp2) * fjac[i][j][k - 1][3][1]) - (tmp1 * njac[i][j][k - 1][3][1]);\n  lhs[i][j][k][0][3][2] = ((-tmp2) * fjac[i][j][k - 1][3][2]) - (tmp1 * njac[i][j][k - 1][3][2]);\n  lhs[i][j][k][0][3][3] = (((-tmp2) * fjac[i][j][k - 1][3][3]) - (tmp1 * njac[i][j][k - 1][3][3])) - (tmp1 * dz4);\n  lhs[i][j][k][0][3][4] = ((-tmp2) * fjac[i][j][k - 1][3][4]) - (tmp1 * njac[i][j][k - 1][3][4]);\n  lhs[i][j][k][0][4][0] = ((-tmp2) * fjac[i][j][k - 1][4][0]) - (tmp1 * njac[i][j][k - 1][4][0]);\n  lhs[i][j][k][0][4][1] = ((-tmp2) * fjac[i][j][k - 1][4][1]) - (tmp1 * njac[i][j][k - 1][4][1]);\n  lhs[i][j][k][0][4][2] = ((-tmp2) * fjac[i][j][k - 1][4][2]) - (tmp1 * njac[i][j][k - 1][4][2]);\n  lhs[i][j][k][0][4][3] = ((-tmp2) * fjac[i][j][k - 1][4][3]) - (tmp1 * njac[i][j][k - 1][4][3]);\n  lhs[i][j][k][0][4][4] = (((-tmp2) * fjac[i][j][k - 1][4][4]) - (tmp1 * njac[i][j][k - 1][4][4])) - (tmp1 * dz5);\n  lhs[i][j][k][1][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dz1);\n  lhs[i][j][k][1][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n  lhs[i][j][k][1][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n  lhs[i][j][k][1][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n  lhs[i][j][k][1][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n  lhs[i][j][k][1][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n  lhs[i][j][k][1][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dz2);\n  lhs[i][j][k][1][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n  lhs[i][j][k][1][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n  lhs[i][j][k][1][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n  lhs[i][j][k][1][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n  lhs[i][j][k][1][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n  lhs[i][j][k][1][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dz3);\n  lhs[i][j][k][1][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n  lhs[i][j][k][1][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n  lhs[i][j][k][1][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n  lhs[i][j][k][1][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n  lhs[i][j][k][1][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n  lhs[i][j][k][1][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dz4);\n  lhs[i][j][k][1][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n  lhs[i][j][k][1][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n  lhs[i][j][k][1][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n  lhs[i][j][k][1][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n  lhs[i][j][k][1][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n  lhs[i][j][k][1][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dz5);\n  lhs[i][j][k][2][0][0] = ((tmp2 * fjac[i][j][k + 1][0][0]) - (tmp1 * njac[i][j][k + 1][0][0])) - (tmp1 * dz1);\n  lhs[i][j][k][2][0][1] = (tmp2 * fjac[i][j][k + 1][0][1]) - (tmp1 * njac[i][j][k + 1][0][1]);\n  lhs[i][j][k][2][0][2] = (tmp2 * fjac[i][j][k + 1][0][2]) - (tmp1 * njac[i][j][k + 1][0][2]);\n  lhs[i][j][k][2][0][3] = (tmp2 * fjac[i][j][k + 1][0][3]) - (tmp1 * njac[i][j][k + 1][0][3]);\n  lhs[i][j][k][2][0][4] = (tmp2 * fjac[i][j][k + 1][0][4]) - (tmp1 * njac[i][j][k + 1][0][4]);\n  lhs[i][j][k][2][1][0] = (tmp2 * fjac[i][j][k + 1][1][0]) - (tmp1 * njac[i][j][k + 1][1][0]);\n  lhs[i][j][k][2][1][1] = ((tmp2 * fjac[i][j][k + 1][1][1]) - (tmp1 * njac[i][j][k + 1][1][1])) - (tmp1 * dz2);\n  lhs[i][j][k][2][1][2] = (tmp2 * fjac[i][j][k + 1][1][2]) - (tmp1 * njac[i][j][k + 1][1][2]);\n  lhs[i][j][k][2][1][3] = (tmp2 * fjac[i][j][k + 1][1][3]) - (tmp1 * njac[i][j][k + 1][1][3]);\n  lhs[i][j][k][2][1][4] = (tmp2 * fjac[i][j][k + 1][1][4]) - (tmp1 * njac[i][j][k + 1][1][4]);\n  lhs[i][j][k][2][2][0] = (tmp2 * fjac[i][j][k + 1][2][0]) - (tmp1 * njac[i][j][k + 1][2][0]);\n  lhs[i][j][k][2][2][1] = (tmp2 * fjac[i][j][k + 1][2][1]) - (tmp1 * njac[i][j][k + 1][2][1]);\n  lhs[i][j][k][2][2][2] = ((tmp2 * fjac[i][j][k + 1][2][2]) - (tmp1 * njac[i][j][k + 1][2][2])) - (tmp1 * dz3);\n  lhs[i][j][k][2][2][3] = (tmp2 * fjac[i][j][k + 1][2][3]) - (tmp1 * njac[i][j][k + 1][2][3]);\n  lhs[i][j][k][2][2][4] = (tmp2 * fjac[i][j][k + 1][2][4]) - (tmp1 * njac[i][j][k + 1][2][4]);\n  lhs[i][j][k][2][3][0] = (tmp2 * fjac[i][j][k + 1][3][0]) - (tmp1 * njac[i][j][k + 1][3][0]);\n  lhs[i][j][k][2][3][1] = (tmp2 * fjac[i][j][k + 1][3][1]) - (tmp1 * njac[i][j][k + 1][3][1]);\n  lhs[i][j][k][2][3][2] = (tmp2 * fjac[i][j][k + 1][3][2]) - (tmp1 * njac[i][j][k + 1][3][2]);\n  lhs[i][j][k][2][3][3] = ((tmp2 * fjac[i][j][k + 1][3][3]) - (tmp1 * njac[i][j][k + 1][3][3])) - (tmp1 * dz4);\n  lhs[i][j][k][2][3][4] = (tmp2 * fjac[i][j][k + 1][3][4]) - (tmp1 * njac[i][j][k + 1][3][4]);\n  lhs[i][j][k][2][4][0] = (tmp2 * fjac[i][j][k + 1][4][0]) - (tmp1 * njac[i][j][k + 1][4][0]);\n  lhs[i][j][k][2][4][1] = (tmp2 * fjac[i][j][k + 1][4][1]) - (tmp1 * njac[i][j][k + 1][4][1]);\n  lhs[i][j][k][2][4][2] = (tmp2 * fjac[i][j][k + 1][4][2]) - (tmp1 * njac[i][j][k + 1][4][2]);\n  lhs[i][j][k][2][4][3] = (tmp2 * fjac[i][j][k + 1][4][3]) - (tmp1 * njac[i][j][k + 1][4][3]);\n  lhs[i][j][k][2][4][4] = ((tmp2 * fjac[i][j][k + 1][4][4]) - (tmp1 * njac[i][j][k + 1][4][4])) - (tmp1 * dz5);\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,k) firstprivate (tz1,tz2,dz1,dz2,dz3,dz4,dz5,dt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/67"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/30"}
{"code": "for (size = 0; size < matSize; size += stride)\n{\n  openMPVersion(vec, mat, res, size);\n  start = rdtsc();\n  for (j = 0; j < repets; j++)\n  {\n    openMPVersion(vec, mat, res, size);\n  }\n\n  resC = rdtsc() - start;\n  fprintf(fd, \"%u %lu\\n\", size, resC / repets);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/MatrixVector/CDParallelism/utils/6"}
{"code": "for (thread = 0; thread < thread_count; thread++)\n{\n  pthread_join(thread_handles[thread], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/7"}
{"code": "for (int i = 0; i < TF_idx; i++)\n{\n  for (int j = 0; j < 32; j++)\n  {\n    if ((unique_words[j].numDocsWithWord != (-1)) && (!strcmp(TFIDF[i].word, unique_words[j].word)))\n    {\n      TFIDF[i].numDocsWithWord = unique_words[j].numDocsWithWord;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lkmokadam/TFIDF_MPI_OpenMP/TFIDF_extra/1"}
{"code": "for (int j = 0; j < n; j++)\n  b[i][j] = a[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr39154/1"}
{"code": "for (size_t i = 0; i < data_size; ++i)\n{\n  size_t nearest_cluster = FindNearestCentroid(centroids, data[i]);\n  if (clusters[i] != nearest_cluster)\n  {\n    clusters[i] = nearest_cluster;\n    converged = false;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/4"}
{"code": "for (j = RADIUS; j < (n - RADIUS); j++)\n  for (i = RADIUS; i < (n - RADIUS); i++)\n  out[i + (j * n)] = (float) 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Stencil/stencil/1"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n  reach[i][j] = graph[i][j];\n\n\n", "pragma": "omp parallel for default(private)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/transitive_closure/0"}
{"code": "for (i = 0; i < (1 << 20); i++)\n  omp_destroy_lock(&lock[key]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Locks_critical_sections_omp-atomic/atomic_sec/2"}
{"code": "for (int i = 0; i < 16; ++i)\n  for (int j = 0; j < 16; ++j)\n  ;\n\n\n", "pragma": "#pragma omp distribute parallel for collapse(2) collapse(3) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-5.0.0/llvm/tools/clang/test/OpenMP/distribute_parallel_for_messages/0"}
{"code": "for (j = 0; j < HIgh_w; j++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    summation_data[(i * HIgh_w) + j] = (conv20_data[(i * HIgh_w) + j] + (bicubic_Y[(i * HIgh_w) + j] / 255)) * 255;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/75"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = i % 120;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB047-doallchar-orig-no/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  buffer[i] = i;\n  buffer_values[i] = v_scores[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/45"}
{"code": "for (int step = 0; step < INTERVAL_LEN; step++)\n{\n  t0 = time_in_seconds();\n  for (idx = 0; idx < boxdim; idx++)\n  {\n    for (idy = 0; idy < boxdim; idy++)\n    {\n      for (idz = 0; idz < boxdim; idz++)\n      {\n        b[idx][idy][idz].head = -1;\n      }\n\n    }\n\n  }\n\n  t_init_cells += time_in_seconds() - t0;\n  t0 = time_in_seconds();\n  for (i = 0; i < npos; i++)\n  {\n    if (pos_orig[3 * i] >= 0)\n    {\n      pos[3 * i] = fmod(pos_orig[3 * i], L);\n    }\n    else\n    {\n      pos[3 * i] = L - fmod((-1) * pos_orig[3 * i], L);\n    }\n\n    if (pos_orig[(3 * i) + 1] >= 0)\n    {\n      pos[(3 * i) + 1] = fmod(pos_orig[(3 * i) + 1], L);\n    }\n    else\n    {\n      pos[(3 * i) + 1] = L - fmod((-1) * pos_orig[(3 * i) + 1], L);\n    }\n\n    if (pos_orig[(3 * i) + 2] >= 0)\n    {\n      pos[(3 * i) + 2] = fmod(pos_orig[(3 * i) + 2], L);\n    }\n    else\n    {\n      pos[(3 * i) + 2] = L - fmod((-1) * pos_orig[(3 * i) + 2], L);\n    }\n\n    if (pos[3 * i] < 0)\n    {\n      printf(\"pos_orig = %lf pos defect = %lf and i = %d and L =%lf\\n\", pos_orig[3 * i], pos[3 * i], i, L);\n    }\n\n    next[i] = -1;\n    forces[(3 * i) + 0] = 0;\n    forces[(3 * i) + 1] = 0;\n    forces[(3 * i) + 2] = 0;\n    idx = (int) ((pos[3 * i] / L) * boxdim);\n    idy = (int) ((pos[(3 * i) + 1] / L) * boxdim);\n    idz = (int) ((pos[(3 * i) + 2] / L) * boxdim);\n    bp = &b[idx][idy][idz];\n    next[i] = bp->head;\n    bp->head = i;\n  }\n\n  t_assign_to_cells += time_in_seconds() - t0;\n  t0 = time_in_seconds();\n  for (index = 0; index < (boxdim * box2); index++)\n  {\n    idz = index % boxdim;\n    ib2 = index % box2;\n    idx = (index - ib2) / box2;\n    idy = (ib2 - idz) / boxdim;\n    bp = &b[idx][idy][idz];\n    for (j = 0; j < 14; j++)\n    {\n      neigh_idx = ((idx + box_neighbors[j][0]) + boxdim) % boxdim;\n      neigh_idy = ((idy + box_neighbors[j][1]) + boxdim) % boxdim;\n      neigh_idz = ((idz + box_neighbors[j][2]) + boxdim) % boxdim;\n      neigh_bp = &b[neigh_idx][neigh_idy][neigh_idz];\n      double xoffset = 0.;\n      double yoffset = 0.;\n      double zoffset = 0.;\n      if ((idx + box_neighbors[j][0]) == (-1))\n        xoffset = -L;\n\n      if ((idy + box_neighbors[j][1]) == (-1))\n        yoffset = -L;\n\n      if ((idz + box_neighbors[j][2]) == (-1))\n        zoffset = -L;\n\n      if ((idx + box_neighbors[j][0]) == boxdim)\n        xoffset = L;\n\n      if ((idy + box_neighbors[j][1]) == boxdim)\n        yoffset = L;\n\n      if ((idz + box_neighbors[j][2]) == boxdim)\n        zoffset = L;\n\n      p1 = neigh_bp->head;\n      while (p1 != (-1))\n      {\n        p2 = bp->head;\n        while (p2 != (-1))\n        {\n          dx = (pos[(3 * p1) + 0] - pos[(3 * p2) + 0]) + xoffset;\n          dy = (pos[(3 * p1) + 1] - pos[(3 * p2) + 1]) + yoffset;\n          dz = (pos[(3 * p1) + 2] - pos[(3 * p2) + 2]) + zoffset;\n          d2 = (((dx * dx) + (dy * dy)) + (dz * dz)) + 0.000000001;\n          if (d2 < (4.0 * a_sq))\n          {\n            s = sqrt(d2);\n            f = krepul * ((2 * a) - s);\n            forces[(3 * p1) + 0] += (f * dx) / s;\n            forces[(3 * p1) + 1] += (f * dy) / s;\n            forces[(3 * p1) + 2] += (f * dz) / s;\n            forces[(3 * p2) + 0] -= (f * dx) / s;\n            forces[(3 * p2) + 1] -= (f * dy) / s;\n            forces[(3 * p2) + 2] -= (f * dz) / s;\n          }\n\n          p2 = next[p2];\n        }\n\n        p1 = next[p1];\n      }\n\n    }\n\n  }\n\n  t_force += time_in_seconds() - t0;\n  t0 = time_in_seconds();\n  for (int p1 = 0; p1 < (((3 * npos) * 3) * npos); p1++)\n  {\n    au[p1] = 0;\n  }\n\n  rpy_ewald(npos, au, pos, L, rad, xi, nr, nk);\n  t_hd += time_in_seconds() - t0;\n  t0 = time_in_seconds();\n  LAPACKE_dpotrf(LAPACK_ROW_MAJOR, 'U', 3 * npos, au, 3 * npos);\n  t_cho += time_in_seconds() - t0;\n  t0 = time_in_seconds();\n  vdRngGaussian(VSL_RNG_METHOD_GAUSSIAN_BOXMULLER, stream, 3 * npos, buf, 0., 1.);\n  cblas_dgemm(CblasRowMajor, CblasTrans, CblasTrans, 3 * npos, 1, 3 * npos, 1, au, 3 * npos, buf, 3 * npos, 0, hd_vec, 1);\n  for (int i = 0; i < (3 * npos); i++)\n  {\n    pos_orig[i] += (forces[i] * DELTAT) + (f_const * hd_vec[i]);\n  }\n\n  t_update_pos += time_in_seconds() - t0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/final/bd_serial/0"}
{"code": "for (int a = 0; a < ((int) edges.size()); a++)\n{\n  if (edges[a].tree == change)\n  {\n    edges[a].tree = edges[tmpAdjacency->node1].tree;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glaucomunsberg/hyperspace/openmp/GraphOpen/0"}
{"code": "for (uint32_t i = 0; i < rows; i++)\n{\n  for (uint32_t idCol = csrF.pointer[i], j = 0; idCol < csrF.pointer[i + 1]; idCol++)\n  {\n    j = csrF.indices[idCol];\n    idStartCol = csrA.pointer[i + pointerOffsetA];\n    idEndCol = csrA.pointer[(i + pointerOffsetA) + 1];\n    if (idStartCol == idEndCol)\n    {\n      break;\n    }\n\n    idStartRow = cscB.pointer[j + pointerOffsetB];\n    idEndRow = cscB.pointer[(j + pointerOffsetB) + 1];\n    bool isCommon = hasCommon(csrA.indices.begin() + idStartCol, csrA.indices.begin() + idEndCol, cscB.indices.begin() + idStartRow, cscB.indices.begin() + idEndRow);\n    if (isCommon)\n    {\n      mulResult.indices.push_back(j);\n      nnz++;\n    }\n\n  }\n\n  mulResult.pointer[i + 1] = nnz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thodkatz/sparse-bmm/src/spgemm/2"}
{"code": "for (j = 0; j < n; j += 32)\n  for (i = 0; i < n; i += 32)\n  for (k = 0; k < n; k += 32)\n  dgemm_blocking(n, i, j, k, A, B, C);\n\n\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkhorrow/parallel-computing-material/exercise_6/dgemm_multithread_parallel_ss/0"}
{"code": "for (int ind1 = 0; ind1 < (N + 2); ind1++)\n{\n  for (int ind2 = 0; ind2 < (N + 2); ind2++)\n  {\n    fill_array3d(array3d, N, ind2, 0, ind1, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t\t#pragma omp for schedule(dynamic, chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  row_sum = 0;\n  for (int k = 0; k < N; k++)\n  {\n    row_sum += A[j][k] * x[k];\n  }\n\n  result_vector[j] = row_sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/benzjakk/ComArch_Final/Parallelized-Gaussian-Elimination/openmp/0"}
{"code": "for (int q = 0; q < 500; q++)\n{\n  pos[q][1] += 0.05 * vel[q][1];\n  pos[q][2] += 0.05 * vel[q][2];\n  vel[q][1] += (0.05 / masses[q]) * forces[q][1];\n  vel[q][2] += (0.05 / masses[q]) * forces[q][2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-2/parallel/3"}
{"code": "for (ii = 1; ii <= nzrow; ii++)\n{\n  i = nzloc[ii];\n  mark[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/26"}
{"code": "for (size_t idx = count; idx < (count * 2); ++idx)\n{\n  size_t body_idx = m_body_n[idx];\n  m_mass_center[idx] = nbvertex_t(rx[body_idx], ry[body_idx], rz[body_idx]);\n  m_box_min[idx] = m_mass_center[idx];\n  m_box_max[idx] = m_mass_center[idx];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_space_heap/1"}
{"code": "for (int i = 0; i < 20; ++i)\n{\n  initialize(array);\n  start = omp_get_wtime();\n  odd_even_sort_parallel(array);\n  end = omp_get_wtime();\n  time += end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohorka/HPCS/openMP/Sort(ex.5)/4"}
{"code": "for (int ii = 0; ii < npcelx; ii++)\n  for (int jj = 0; jj < npcely; jj++)\n  for (int kk = 0; kk < npcelz; kk++)\n{\n  double u;\n  double v;\n  double w;\n  double q;\n  double x;\n  double y;\n  double z;\n  sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n  x = ((ii + sample_u_double()) * dx_per_pcl) + cell_low_x;\n  y = ((jj + sample_u_double()) * dy_per_pcl) + cell_low_y;\n  z = ((kk + sample_u_double()) * dz_per_pcl) + cell_low_z;\n  create_new_particle(u, v, w, q_per_particle, x, y, z);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    qT[(j * n) + i] = q[(i * n) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/first-steps/omp-matmul/1"}
{"code": "for (int i = 0; i < piv; i++)\n{\n  s = ((double) M[i][piv]) / M[piv][piv];\n  for (int j = 0; j < dim; j++)\n  {\n    D[i][j] -= ((float) s) * D[piv][j];\n    if (j <= piv)\n      M[i][j] -= s * M[piv][j];\n\n  }\n\n}\n\n", "pragma": "      #pragma omp parallel for private(i,j,s)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tecnarca/CPU-GPU-speed-comparison/src/openmp/1"}
{"code": "for (i = T_bench; i < T_last; i++)\n{\n  t = timer_read(i);\n  if (i == T_resid2)\n  {\n    t = timer_read(T_resid) - t;\n    printf(\"    --> %8s:%9.3f  (%6.2f%%)\\n\", \"mg-resid\", t, (t * 100.) / tmax);\n  }\n  else\n  {\n    printf(\"  %-8s:%9.3f  (%6.2f%%)\\n\", t_names[i], t, (t * 100.) / tmax);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/10"}
{"code": "for (i = 1; i <= n; i++)\n{\n  x = h * ((double) ((2 * i) - 1));\n  sum2 = sum2 + (1.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejetzer/test_openmp/compute_pi_openmp/1"}
{"code": "for (i = 0; i < the_index; i++)\n{\n  int j;\n  for (j = 0; j < the_index; j++)\n  {\n    int k;\n    for (k = 0; k < the_index; k++)\n    {\n      simple_mult((double (*)[1024]) (&C[i * blocksize][j * blocksize]), (double (*)[1024]) (&A[i * blocksize][k * blocksize]), (double (*)[1024]) (&B[k * blocksize][j * blocksize]), blocksize);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/msagor/parallel_matrix_block_multiplication/matrix_block_multiplication_in_parallel_using_openMP/mult/5"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  vet[i] = i;\n}\n\n", "pragma": "omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/max/0"}
{"code": "for (int i = 0; i < (x + 100); i++)\n{\n  (((cout << i) << \" Thread: \") << omp_get_thread_num()) << endl;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/parallel2/0"}
{"code": "for (int j = 0; j < 5; ++j)\n{\n  sleep(1);\n  printf(\"wake %d, %d\\n\", j, omp_get_thread_num());\n}\n\n", "pragma": "         #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPToolsInterface/ompt-test-suite/examples/parallelsections/1"}
{"code": "for (j = 0; j < (100 + 2); j++)\n{\n  U[100 + 1][j] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/6"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (d = 0; d <= 2; d++)\n  {\n    rms[m] = rms[m] / ((double) (grid_points[d] - 2));\n  }\n\n  rms[m] = sqrt(rms[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/53"}
{"code": "for (size_t i = 1; i < n; ++i)\n{\n  idx_t b = a[i];\n  size_t j = i;\n  while ((j > 0) && (a[j - 1] > b))\n  {\n    --j;\n  }\n\n  memmove(a + (j + 1), a + j, (sizeof(*a)) * (i - j));\n  a[j] = b;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/19"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (d = 0; d < NDIM; d++)\n    cell(ci).setCForce(d, 0.0);\n\n  for (vi = 0; vi < cell(ci).getNV(); vi++)\n  {\n    for (d = 0; d < NDIM; d++)\n      cell(ci).setVForce(vi, d, 0.0);\n\n    cell(ci).setUInt(vi, 0.0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/42"}
{"code": "for (int i = 0; i < elements; i++)\n{\n  forward(i, start, step, alpha, beta, gamma, F);\n}\n\n", "pragma": "omp parallel for num_threads(threads) shared(alpha, beta, gamma, F, elements, start, step)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/cyclic_reduction/main/3"}
{"code": "for (i = numEdges - 1; i >= 0; i--)\n{\n  temp = edges[i].src;\n  temp /= (int) pow(10.0, ((double) j) - 1);\n  temp %= 10;\n  edges_sorted[count[temp] - 1] = edges[i];\n  count[temp]--;\n}\n\n", "pragma": "omp parallel for default(none) shared(numEdges, j, edges, edges_sorted, count) private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JasonNCSU/openMP/src/sort/0"}
{"code": "for (int jj = internal_ystart; jj <= (internal_ystop - 1); jj++)\n{\n  for (int ji = internal_xstart; ji <= internal_xstop; ji++)\n  {\n    next_sshv_code(ji, jj, width, sshn_v, sshn_t, tmask, area_t, area_v);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/10"}
{"code": "for (int j = 0; j < threads_cnt; ++j)\n{\n  (ASSERT_EQ(err_counters[j], 0) << \"multithreading test failure\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/gtests/rand_core_test/2"}
{"code": "for (i = 0; i < primesCounter; ++i)\n{\n  int p = primes[i];\n  for (int j = p * p; j <= MAX; j += p)\n    if (j >= MIN)\n    if (privPrimes[thread][j])\n    privPrimes[thread][j] = false;\n\n\n\n}\n\n", "pragma": "#pragma omp for schedule(static, 1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/5"}
{"code": "for (p = &buf[53]; p > (&buf[9]); --p)\n  *p = 5;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-5/4"}
{"code": "for (int i = 0; i < this->fields.size(); ++i)\n  omp_destroy_lock(&fields[i].lock);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/2/gameOfLife/GameOfLife/4"}
{"code": "for (unsigned int row = 1; row < (height - 1); ++row)\n{\n  for (unsigned long col = 1; col < (width - 1); ++col)\n  {\n    i = (unsigned long) ((row * width) + col);\n    if (image[i] == 255)\n    {\n      switch (edgeDir[i])\n      {\n        case 0:\n          suppressNonMax(1, 0, row, col, 0);\n          break;\n\n        case 45:\n          suppressNonMax(1, -1, row, col, 45);\n          break;\n\n        case 90:\n          suppressNonMax(0, 1, row, col, 90);\n          break;\n\n        case 135:\n          suppressNonMax(1, 1, row, col, 135);\n          break;\n\n        default:\n          break;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) shared(width,height,image,edgeDir,gradient) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thu105/PhotoMosaic/main/6"}
{"code": "for (int i = 0; i < subsize; i++)\n  for (int j = 0; j < subsize; j++)\n  sum += get(mat, size, v[j], h[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/mpi-openmp-sparse-matrix/mpi-openmp-sparse-matrix/main/1"}
{"code": "for (int i = start; i < stop; i++)\n  for (int j = start; j < stop; j++)\n  temp[h++] = mat1[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TeoGavrilescu31/Parallel-Programming-Project-OPENMP/proiect/5"}
{"code": "for (int i = 0; i < 100; i++)\n  vec1.mul(vec2, vec3);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector/mul/1"}
{"code": "for (int i = 0; i < x_size; i++)\n{\n  x_vals[i] = grid[i][y_size - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bergerom/nw_parallel/nw-openmp/3"}
{"code": "for (k = 0; k <= (nz - 1); k++)\n{\n  flux[i][j][k][0] = rsd[i][j][k][3];\n  u41 = rsd[i][j][k][3] / rsd[i][j][k][0];\n  q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n  flux[i][j][k][1] = rsd[i][j][k][1] * u41;\n  flux[i][j][k][2] = rsd[i][j][k][2] * u41;\n  flux[i][j][k][3] = (rsd[i][j][k][3] * u41) + (C2 * (rsd[i][j][k][4] - q));\n  flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u41;\n}\n\n", "pragma": "omp parallel for firstprivate(nz ,ist ,jst ,u41 ,q ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/34"}
{"code": "for (int i = 0; i < N; ++i)\n  rand_num[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/taeguk/dist-prog-assignment/assignment-3/p2/example2_myschd/1"}
{"code": "for (i = 1; i < n; i++)\n{\n  double x = a + (i * h);\n  sumOfPeaks += calculateValueOfFunction(fun, names, x);\n}\n\n", "pragma": "        #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kozub/OpenMP-TrapezoidalRule-Integral/integral_omp/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_set_schedule_0())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/worksharing/for/bug_set_schedule_0/0"}
{"code": "for (i = 0; i < primesCounter; ++i)\n{\n  int p = primes[i];\n  for (int j = p * p; j <= MAX; j += p)\n    if ((j >= MIN) && isPrimeNumber)\n    isPrimeNumber[j] = false;\n\n\n}\n\n", "pragma": "#pragma omp for nowait private(i) schedule(static, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/4"}
{"code": "for (i = 0; i < 100000; i++)\n  if (a[i] != b[i])\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.50.1/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    int num = 0;\n    for (int k = 0; k < N; k++)\n    {\n      num += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = num;\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tidjungs/01204434-Parallel/openmp/matrix_mul_parallel/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x[i] = value;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/2"}
{"code": "for (j = 1; j <= n; j++)\n{\n  while (b[i][j - 1] == 0)\n    ;\n\n  diag = c[i - 1][j - 1] + ((X[i - 1] == Y[j - 1]) ? (+1) : (-1));\n  up = c[i - 1][j] + (-3);\n  left = c[i][j - 1] + (-3);\n  if ((diag >= up) && (diag >= left))\n  {\n    c[i][j] = diag;\n    b[i][j] = '\\\\';\n  }\n  else\n    if (up >= left)\n  {\n    c[i][j] = up;\n    b[i][j] = '|';\n  }\n  else\n  {\n    c[i][j] = left;\n    b[i][j] = '_';\n  }\n\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/auriza/pairwise-openmp/columnwise/0"}
{"code": "for (s5 = 0; s5 < 64; s5++)\n  ;\n\n", "pragma": "omp distribute parallel for lastprivate (s5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/distribute-1/1"}
{"code": "for (i = 0; i < 2000000; i++)\n{\n  arr[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GUPTASHUBH057/openmp-programs/openmp_prog1/1"}
{"code": "for (cantEjecuciones = 0; cantEjecuciones < 5; cantEjecuciones++)\n{\n  tiempoInicial = clock();\n  for (i = 0; i < (tamanioMatriz * 2); i++)\n  {\n    matrizCampo[i].fila = -5;\n    matrizAux[i].fila = -5;\n    matrizAux[i].color = 10;\n    matrizCampo[i].color = 10;\n  }\n\n  for (i = tamanioMatriz * 2; i < (tamanioFinal - (2 * tamanioMatriz)); i++)\n  {\n    random = rand() % 101;\n    matrizCampo[i].semanasInfectado = 0;\n    matrizAux[i].semanasInfectado = 0;\n    matrizCampo[i].semanasTotales = 0;\n    matrizAux[i].semanasTotales = 0;\n    matrizCampo[i].semanasPodado = 0;\n    matrizAux[i].semanasPodado = 0;\n    if (random < 65)\n    {\n      matrizCampo[i].color = 5;\n      matrizAux[i].color = 5;\n    }\n    else\n    {\n      if ((random >= 65) && (random < 70))\n      {\n        matrizCampo[i].color = 3;\n        matrizAux[i].color = 3;\n      }\n      else\n      {\n        if ((random >= 70) && (random < 80))\n        {\n          matrizCampo[i].color = 4;\n          matrizAux[i].color = 4;\n        }\n        else\n        {\n          if ((random >= 80) && (random <= 100))\n          {\n            matrizCampo[i].color = 2;\n            matrizAux[i].color = 2;\n          }\n\n        }\n\n      }\n\n    }\n\n    if (random < 30)\n    {\n      matrizCampo[i].edad = 52;\n      matrizAux[i].edad = 52;\n    }\n    else\n    {\n      if ((random >= 30) && (random < 80))\n      {\n        matrizCampo[i].edad = 157;\n        matrizAux[i].edad = 157;\n      }\n      else\n      {\n        if ((random >= 80) && (random <= 100))\n        {\n          matrizCampo[i].edad = 1821;\n          matrizAux[i].edad = 1821;\n        }\n\n      }\n\n    }\n\n    if ((i % tamanioMatriz) == 0)\n    {\n      fila++;\n    }\n\n    matrizCampo[i].fila = fila;\n    matrizAux[i].fila = fila;\n    matrizCampo[i].heridas = 0;\n    matrizAux[i].heridas = 0;\n  }\n\n  for (i = tamanioFinal - (2 * tamanioMatriz); i < tamanioFinal; i++)\n  {\n    matrizCampo[i].fila = tamanioMatriz + 5;\n    matrizAux[i].fila = tamanioMatriz + 5;\n    matrizAux[i].color = 10;\n    matrizCampo[i].color = 10;\n  }\n\n  for (semana = 0; semana < cantidadSemanas; semana++)\n  {\n    for (indice = tamanioMatriz * 2; indice < (tamanioFinal - (2 * tamanioMatriz)); indice++)\n    {\n      arbolesContagiando = 0;\n      vecinosVisitados = 0;\n      if (matrizCampo[indice - 1].fila == matrizCampo[indice].fila)\n      {\n        if (matrizCampo[indice - 1].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice - 1].fila >= 0)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if (matrizCampo[indice - 2].fila == matrizCampo[indice].fila)\n      {\n        if (matrizCampo[indice - 2].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice - 2].fila >= 0)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if (matrizCampo[indice + 1].fila == matrizCampo[indice].fila)\n      {\n        if (matrizCampo[indice + 1].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + 1].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if (matrizCampo[indice + 2].fila == matrizCampo[indice].fila)\n      {\n        if (matrizCampo[indice + 2].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + 2].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - tamanioMatriz].fila)\n      {\n        if (matrizCampo[indice - tamanioMatriz].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice - tamanioMatriz].fila >= 0)\n        {\n          vecinosVisitados += 1;\n          ;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - (tamanioMatriz - 1)].fila)\n      {\n        if (matrizCampo[indice - (tamanioMatriz - 1)].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice - (tamanioMatriz - 1)].fila >= 0)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - (tamanioMatriz + 1)].fila)\n      {\n        if (matrizCampo[(indice - tamanioMatriz) + 1].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[(indice - tamanioMatriz) + 1].fila >= 0)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila - 2) == matrizCampo[indice - (2 * tamanioMatriz)].fila)\n      {\n        if (matrizCampo[indice - (2 * tamanioMatriz)].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice - (2 * tamanioMatriz)].fila >= 0)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + tamanioMatriz].fila)\n      {\n        if (matrizCampo[indice + tamanioMatriz].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + tamanioMatriz].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + (tamanioMatriz - 1)].fila)\n      {\n        if (matrizCampo[indice + (tamanioMatriz - 1)].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + (tamanioMatriz - 1)].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + (tamanioMatriz + 1)].fila)\n      {\n        if (matrizCampo[indice + (tamanioMatriz + 1)].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + (tamanioMatriz + 1)].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if ((matrizCampo[indice].fila + 2) == matrizCampo[indice + (2 * tamanioMatriz)].fila)\n      {\n        if (matrizCampo[indice + (2 * tamanioMatriz)].color == 3)\n        {\n          arbolesContagiando += 1;\n        }\n\n        if (matrizCampo[indice + (2 * tamanioMatriz)].fila < tamanioMatriz)\n        {\n          vecinosVisitados += 1;\n        }\n\n      }\n\n      if (matrizCampo[indice].edad < 157)\n      {\n        if (matrizCampo[indice].heridas == 1)\n        {\n          susceptibilidad = 0.35 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.35;\n        }\n\n      }\n\n      if ((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821))\n      {\n        if (matrizCampo[indice].heridas == 1)\n        {\n          susceptibilidad = 0.17 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.17;\n        }\n\n      }\n\n      if (matrizCampo[indice].edad >= 1821)\n      {\n        if (matrizCampo[indice].heridas == 1)\n        {\n          susceptibilidad = 0.63 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.63;\n        }\n\n      }\n\n      matrizAux[indice].edad += 1;\n      if (matrizCampo[indice].color == 4)\n      {\n        matrizAux[indice].semanasInfectado += 1;\n        matrizAux[indice].semanasTotales++;\n      }\n\n      if (matrizCampo[indice].semanasInfectado == 3)\n      {\n        matrizAux[indice].color = 3;\n      }\n\n      if (matrizCampo[indice].color == 3)\n      {\n        matrizAux[indice].semanasTotales++;\n        if ((rand() % 100) <= 85)\n        {\n          matrizAux[indice].color = 2;\n          matrizAux[indice].semanasInfectado = 0;\n          matrizAux[indice].semanasTotales += 1;\n        }\n\n      }\n\n      if (matrizCampo[indice].color == 2)\n      {\n        if (matrizCampo[indice].semanasTotales <= 8)\n        {\n          matrizAux[indice].semanasTotales++;\n        }\n        else\n        {\n          if (matrizCampo[indice].edad < 157)\n          {\n            if ((rand() % 100) > 3)\n            {\n              matrizAux[indice].color = 5;\n              matrizAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizAux[indice].color = 1;\n              matrizAux[indice].semanasTotales = 0;\n            }\n\n          }\n\n          if ((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821))\n          {\n            if ((rand() % 100) > 15)\n            {\n              matrizAux[indice].color = 5;\n              matrizAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizAux[indice].color = 1;\n              matrizAux[indice].semanasTotales = 0;\n            }\n\n          }\n\n          if (matrizCampo[indice].edad >= 1821)\n          {\n            if ((rand() % 100) > 53)\n            {\n              matrizAux[indice].color = 5;\n              matrizAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizAux[indice].color = 5;\n              matrizAux[indice].semanasTotales = 0;\n              matrizAux[indice].edad = 57;\n            }\n\n          }\n\n        }\n\n      }\n\n      if (matrizCampo[indice].color == 1)\n      {\n        if (matrizCampo[indice].semanasPodado <= 12)\n        {\n          matrizAux[indice].semanasPodado++;\n        }\n        else\n        {\n          matrizAux[indice].color = 5;\n          matrizAux[indice].semanasPodado = 0;\n        }\n\n      }\n\n      if (matrizCampo[indice].color == 5)\n      {\n        porcentajeEnfermos = arbolesContagiando / vecinosVisitados;\n        probabilidadContagio = ((porcentajeEnfermos + susceptibilidad) * 0.60) + 0.07;\n        if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n        {\n          matrizAux[indice].color = 4;\n        }\n\n      }\n\n      if (semana > 0)\n      {\n        probHeridas = rand() % 101;\n        if ((matrizCampo[indice].edad < 157) && (probHeridas < 23))\n        {\n          matrizAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizAux[indice].heridas = 0;\n        }\n\n        if (((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821)) && (probHeridas < 8))\n        {\n          matrizAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizAux[indice].heridas = 0;\n        }\n\n        if ((matrizCampo[indice].edad >= 1821) && (probHeridas < 37))\n        {\n          matrizAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizAux[indice].heridas = 0;\n        }\n\n      }\n\n    }\n\n    for (cambio = tamanioMatriz * 2; cambio < (tamanioFinal - (2 * tamanioMatriz)); cambio++)\n    {\n      matrizCampo[cambio].color = matrizAux[cambio].color;\n      matrizCampo[cambio].edad = matrizAux[cambio].edad;\n      matrizCampo[cambio].heridas = matrizAux[cambio].heridas;\n      matrizCampo[cambio].semanasInfectado = matrizAux[cambio].semanasInfectado;\n      matrizCampo[cambio].semanasTotales = matrizAux[cambio].semanasTotales;\n      matrizCampo[cambio].semanasPodado = matrizAux[cambio].semanasPodado;\n    }\n\n  }\n\n  tiempoFinal = clock();\n  double segundos = ((double) (tiempoFinal - tiempoInicial)) / CLOCKS_PER_SEC;\n  printf(\"EL TIEMPO DE EJECUCION DE UNA VUELTA FUE: %f\\n\", segundos);\n  tiempototal += tiempoFinal - tiempoInicial;\n  fila = -1;\n}\n\n", "pragma": "omp parallel for private(i,random) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalOPM1500/0"}
{"code": "for (int i = -radius; i <= radius; i++)\n  for (int j = -radius; j <= radius; j++)\n{\n  kernel[i + radius][j + radius] = exp((-((i * i) + (j * j))) / ((2 * sigma) * sigma));\n  norm += kernel[i + radius][j + radius];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rodimkov/Lab_openmp/parallel_programming/Source/0"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  outputData = inputData;\n  storedData = outputData;\n  outputData = _mm256_mulhi_epu16(ascii_magic_1_16, outputData);\n  outputData = _mm256_srai_epi16(outputData, 2);\n  inputData = outputData;\n  outputData = _mm256_mullo_epi16(ten_16, outputData);\n  outputData = _mm256_sub_epi16(storedData, outputData);\n  outputData = _mm256_add_epi16(ascii_magic_2_16, outputData);\n  oNumString[4 - i] = outputData.m256i_i16[0];\n  oNumString[10 - i] = outputData.m256i_i16[1];\n  oNumString[16 - i] = outputData.m256i_i16[2];\n  oNumString[22 - i] = outputData.m256i_i16[3];\n  oNumString[28 - i] = outputData.m256i_i16[4];\n  oNumString[34 - i] = outputData.m256i_i16[5];\n  oNumString[40 - i] = outputData.m256i_i16[6];\n  oNumString[46 - i] = outputData.m256i_i16[7];\n  oNumString[52 - i] = outputData.m256i_i16[8];\n  oNumString[58 - i] = outputData.m256i_i16[9];\n  oNumString[64 - i] = outputData.m256i_i16[10];\n  oNumString[70 - i] = outputData.m256i_i16[11];\n  oNumString[76 - i] = outputData.m256i_i16[12];\n  oNumString[82 - i] = outputData.m256i_i16[13];\n  oNumString[88 - i] = outputData.m256i_i16[14];\n  oNumString[94 - i] = outputData.m256i_i16[15];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/7"}
{"code": "for (int i = 0; i < n; i++)\n  scanf(\"%d\", &a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/08_omp_odd_even1/3"}
{"code": "for (int i = 1; i <= Q; i++)\n  arr[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tratitude/eight-queen-problem/eight_queen/2"}
{"code": "for (int i = 0; i < 8; i++)\n  for (int j = 0; j < 8; j++)\n{\n  c = c + (b != ((7 + (2 * j)) + ((2 * 8) * i)));\n  b = b + 2;\n}\n\n\n", "pragma": "omp parallel for simd collapse (2) schedule (static, 4) linear(b:2) reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-16/2"}
{"code": "for (layer14_index = 0; layer14_index < Layer_CH_Num; layer14_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (layer13_index = 0; layer13_index < Layer_CH_Num; layer13_index++)\n  {\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        temp_data14[(((layer13_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n      }\n\n    }\n\n    for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n    {\n      for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n      {\n        for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n        {\n          for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n          {\n            temp_data14[(((layer13_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data14[(((layer13_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv13_data[(((layer13_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv14[(((((layer14_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer13_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data14[(((layer13_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv14[layer14_index];\n      if (conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n        conv14_data[(((layer14_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/54"}
{"code": "for (int i = 0; i < 8000; i++)\n{\n  if (A[i][i] == 0)\n  {\n    int i_index = i;\n    while (A[i_index][i] == 0)\n    {\n      i_index++;\n    }\n\n    for (int j = 0; j < 8000; j++)\n    {\n      swap(&A[i][j], &A[i_index][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzunny97/LU-OpenMP/LU_decomposition/2"}
{"code": "for (int i = 0; i < DIM; i++)\n  C[0][i] = 0.5;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/EE/VMCRenyiOMP/3"}
{"code": "for (int j = 0; j < x_size; j++)\n{\n  for (int k = 0; k < y_size; k++)\n  {\n    printf(\"%.4f \", u[(j * x_size) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/2gpu_wave_propagation/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/jacobi/1"}
{"code": "for (int ipT = 0; ipT < pT_tab_length; ipT++)\n  pTValues[ipT] = pT_tab->get(1, ipT + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_polzn_kernels/1"}
{"code": "for (int i = 0, word_len = incoming_word.size(); i < word_len; i++)\n{\n  if (ispunct(incoming_word[i]))\n  {\n    incoming_word.erase(i--, 1);\n    word_len = incoming_word.size();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramachav/Map-Reduce-Multi-Threaded/Map_Reduce_Code/map_reduce/3"}
{"code": "for (int p = 0; p < itt; p++)\n  Avg += AvgM();\n\n", "pragma": "\t#pragma omp parallel for reduction(+:Avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/k21226/omptst/main/1"}
{"code": "for (i = 0; i < max_prime; i++)\n{\n  if (static_prime_array[i] != dynamic_prime_array[i])\n  {\n    printf(\"Unequal arrays at %lld\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lukas783/ParallelPrimes/Sieves/2"}
{"code": "for (layer7_index = 0; layer7_index < Layer_CH_Num; layer7_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data8[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data8[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data8[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv8[(((((layer8_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer7_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data8[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/37"}
{"code": "for (i = 0; i < LOOPCOUNT; i++)\n{\n  logics[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_for_reduction/8"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  clusterWeightInternal[i] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/parallelLouvainMethodScale/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a = i + 1;\n  printf(\" Thread %d has a value of a = %d for i = %d\\n\", omp_get_thread_num(), a, i);\n  if (i == (n - 1))\n    a_shared = a;\n\n}\n\n", "pragma": "omp parallel for private(i,a) shared(a_shared)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/010_lastprivate_clause/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  acumm_W[j] += W[(i * K) + j];\n}\n\n", "pragma": "\t\t\t#pragma omp target teams distribute parallel for simd reduction(+:acumm_W[j]) map(to:j)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artecs-group/nmf-openmp/src/main/15"}
{"code": "for (int freq = 0; freq < 5; freq++)\n{\n  double time = gemm_transpose_block(a, b, c, size);\n  counts.push_back(time);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_block_transpose/3"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][2];\n      u31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = rsd[i][j][k][1] * u31;\n      flux[i][j][k][2] = (rsd[i][j][k][2] * u31) + (0.40e+00 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][3] = rsd[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((1.40e+00 * rsd[i][j][k][4]) - (0.40e+00 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/2"}
{"code": "for (int i = 0; i < 500; ++i)\n{\n  queue.add(i);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muatik/openmp-examples/linkedlist/main/0"}
{"code": "for (int i = 0; i < N; i++)\n  a[i] += (b[i] + (k * c[i])) + (l * z[i]);\n\n", "pragma": "    #pragma omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-target-nowait-dep-implicit/test/1"}
{"code": "for (i = 0; i < ISIZ1; i++)\n{\n  for (j = 0; j < ISIZ2; j++)\n  {\n    for (k = 0; k < 5; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        a[i][j][k][m] = 0.0;\n        b[i][j][k][m] = 0.0;\n        c[i][j][k][m] = 0.0;\n        d[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/26"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%f\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/16"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (int jlo = 0; jlo < width; jlo = jlo + 4)\n  {\n    int jhi = min(jlo + 4, width);\n    for (j = jlo; j < jhi; j++)\n    {\n      ((((((img << \"  \") << values[i][j]) << \"  \") << abs(255 - values[i][j])) << \"  \") << abs(255 - (values[i][j] / 2))) << \"\\n\";\n    }\n\n    img << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/renafsouza/cpp-parallel-fractal-generator/fractal/0"}
{"code": "for (j = jj; j < (((jj + bsize) < 5000) ? (jj + bsize) : (5000)); j++)\n{\n  for (h = 0; h < loop_unroll_limit; h++)\n  {\n    B[i + h][j] = A[j][i + h];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/TiledTranspose/tiled_transpose_with_loop_unroll_parallel_for_j/0"}
{"code": "for (i = 0; i < nsize; i++)\n  printf(\"%6.5f %5.5f\\n\", B[i], C[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaowei-su/ParallelGaussianElimination/gaussOPENMP/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    assert(c[i][j] == d[i][j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shafaet/OpenMP-Examples/Parallel Matrix Multiplication/1"}
{"code": "for (long int i = 0; i < snpCount; i++)\n  configure[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/10"}
{"code": "for (int yy = 0; yy < _settings._size; ++yy)\n  for (int xx = 0; xx < _settings._size; ++xx)\n{\n  if (_settings._buffer[(yy * _settings._size) + xx] == _settings._iter)\n    injectPoint(xx, yy);\n  else\n    injectPoint(xx, yy, 2 + floor(inc * _settings._buffer[(yy * _settings._size) + xx]));\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GuillaumeBouchetEpitech/Qt-OpenMP-Fractales/src/Fractale/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    A[i][j] = 1.0 / (1.0 + abs(i - j));\n\n}\n\n", "pragma": "omp parallel for shared(n, A) private(i) num_threads(thread)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thesaurabhkumar/ParallelDenseMatrixOpenMP/Submission/matrix_par/7"}
{"code": "for (i = 8; i < 52; i++)\n{\n  j = i % 8;\n  if (j < 6)\n  {\n    key[i] = ((key[i - 7] >> 9) | (key[i - 6] << 7)) & 0xffff;\n    continue;\n  }\n\n  if (j == 6)\n  {\n    key[i] = ((key[i - 7] >> 9) | (key[i - 14] << 7)) & 0xffff;\n    continue;\n  }\n\n  key[i] = ((key[i - 15] >> 9) | (key[i - 14] << 7)) & 0xffff;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/frobino/openmp_introduction/Examples/crypt/crypt_omp_adv/2"}
{"code": "for (int i = 0; i < Size_element; i++)\n{\n  sqr_dist_i = 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    l.nM[i][j] = X_p.nV[i] - Elem_p_Coordinates.nM[i][j];\n    sqr_dist_i += DSQR(l.nM[i][j]);\n  }\n\n  Norm_l.nV[i] = sqr_dist_i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/7"}
{"code": "for (int i = 0; i < ans.size(); i++)\n{\n  double err = fabs(val[i] - ans[i]) / fabs(ans[i]);\n  if (err > tol)\n  {\n    printf(\"ans[%d] = %e, data[%d] = %e, err = %e\\n\", i, ans[i], i, val[i], err);\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/matrix/spmv/1"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  free(mat1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pradeepsinngh/practice-parallel-programming/openmp/matrix_multiplication_openmp/8"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (score[i][j] > max_score)\n    {\n      max_score = score[i][j];\n      max_row = i;\n      max_col = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/smith-waterman/smith_waterman_par/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  v[i][j][k][m] = v[i][j][k][m] - (omega * (((((ldz[i][j][m][0] * v[i][j][k - 1][0]) + (ldz[i][j][m][1] * v[i][j][k - 1][1])) + (ldz[i][j][m][2] * v[i][j][k - 1][2])) + (ldz[i][j][m][3] * v[i][j][k - 1][3])) + (ldz[i][j][m][4] * v[i][j][k - 1][4])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (k,omega)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/2"}
{"code": "for (int y = 0; y < wym; y++)\n{\n  for (int x = 0; x < row_per_proc; x++)\n  {\n    smallslice[y + (x * wym)] = lastslice[y][x];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aenyewedien/GameOfLife/game/7"}
{"code": "for (int j = 0; j < l; ++j)\n{\n  A[j] = 3 * A[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-20-ParallelForCallFuncParallelFor/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = (float *) malloc((sizeof(float *)) * (n + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/1.Gaussian_Elimination/gausstest/5"}
{"code": "for (i = 0; i < count; i++)\n{\n  MD4_CTX ctx;\n  MD4_Init(&ctx);\n  MD4_Update(&ctx, (unsigned char *) saved_key[i], saved_len[i]);\n  MD4_Final((unsigned char *) crypt_key[i], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/nt2_fmt_plug/0"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 1); k++)\n  {\n    forcing[m][i][j][k] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/6"}
{"code": "for (int i = 0; i < NUM; i++)\n{\n  v1[i] = sqrt((double) i);\n  v2[i] = sqrt((double) i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ssssmiyassss/openmp_test/test00/0"}
{"code": "for (i = 0; i < Reps; i++)\n{\n  assignew = DoptBCDOne(data_proc.rows(0, cov_num - 1), n, cov_num);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  diff(i) = ((-sum(data_proc.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data_proc.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/28"}
{"code": "for (int i = 0; i < dividePoint; i++)\n{\n  if (lowA >= lenA)\n  {\n    totalAr[i] = arrB[lowB];\n    lowB++;\n  }\n  else\n    if (lowB >= lenB)\n  {\n    totalAr[i] = arrA[lowA];\n    lowA++;\n  }\n  else\n  {\n    if (arrA[lowA] <= arrB[lowB])\n    {\n      totalAr[i] = arrA[lowA];\n      lowA++;\n    }\n    else\n    {\n      totalAr[i] = arrB[lowB];\n      lowB++;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/mergeSort/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/195"}
{"code": "for (i = 0; i < tam; i++)\n  if (vetor[i] == 0)\n  totalPrimos++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 2/Quest\u00e3o 3/Q3_NRec/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i <= j)\n      m[i][j] = 1;\n    else\n      m[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp3/ejer7/pmtv-OpenMP/2"}
{"code": "for (int i = 0; i < 102400; i++)\n{\n  vecA[i] = pow(r, i);\n  vecB[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ENCCS/openmp-gpu/content/exercise/ex02/solution/ex02/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/84"}
{"code": "for (int channel = 0; channel < NUM_CHANNELS; channel++)\n{\n  frame[x][y][channel] = (unsigned char) ((alpha * getOverlay(x, y, channel)) + ((1 - alpha) * frame[x][y][channel]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/VideoOutput/0"}
{"code": "for (int a = 0; a < N; ++a)\n{\n  position[a].first += velocity[a].first * dt;\n  while (!((position[a].first >= 0) && (position[a].first <= XMAX)))\n  {\n    if (position[a].first > XMAX)\n      position[a].first = (2 * XMAX) - position[a].first;\n    else\n      if (position[a].first < 0)\n      position[a].first = (-1) * position[a].first;\n\n\n  }\n\n  position[a].second += velocity[a].second * dt;\n  while (!((position[a].second >= 0) && (position[a].second <= YMAX)))\n  {\n    if (position[a].second > YMAX)\n      position[a].second = (2 * YMAX) - position[a].second;\n    else\n      if (position[a].second < 0)\n      position[a].second = (-1) * position[a].second;\n\n\n  }\n\n  position[a].third += velocity[a].third * dt;\n  while (!((position[a].third >= 0) && (position[a].third <= ZMAX)))\n  {\n    if (position[a].third > ZMAX)\n      position[a].third = (2 * ZMAX) - position[a].third;\n    else\n      if (position[a].third < 0)\n      position[a].third = (-1) * position[a].third;\n\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(guided) shared(position,velocity)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task2/src/v0.0/pathGen/3"}
{"code": "for (int i = startIA; i < endI; i++)\n{\n  if (indexA >= lenA)\n  {\n    arr[i] = arrB[indexB];\n    indexB++;\n  }\n  else\n    if (indexB >= lenB)\n  {\n    arr[i] = arrA[indexA];\n    indexA++;\n  }\n  else\n  {\n    if (arrA[indexA] <= arrB[indexB])\n    {\n      arr[i] = arrA[indexA];\n      indexA++;\n    }\n    else\n    {\n      arr[i] = arrB[indexB];\n      indexB++;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/mergeSort/4"}
{"code": "for (k = 0; k < 3000; k++)\n{\n  lines[k] = (char *) malloc(256 * (sizeof(char)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/word_count/2"}
{"code": "for (int z = 1; z < i; z++)\n{\n  for (int j = 0; j < 16; j++)\n  {\n    ris = (l[j] & 127) || (p[z - 1][j] & 127);\n    p[z][j] = (l[j] + carry) + p[z - 1][j];\n    if ((ris == 1) && ((p[z][j] & 127) == 0))\n      carry = 1;\n    else\n      carry = 0;\n\n  }\n\n  carry = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/6"}
{"code": "for (int i = 0; i < MAX_THREADS; i++)\n{\n  sum[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TNielsen92pro/Programming-with-OpenMP/OpenMP/exercise_2/src/sum/1"}
{"code": "for (int k = kini; k < kend; k++)\n{\n  for (int l = lini; l < lend; l++)\n  {\n    res += source(k, l) * mat[k - kini][l - lini];\n    total += mat[k - kini][l - lini];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/convOMP/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_devices/1"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  const T scalar = SCALAR;\n  b[i] = scalar * c[i];\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd thread_limit(TBSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/babelstream-omp/main/1"}
{"code": "for (c = 0; c < 4; c++)\n{\n  int clusterSize = clusters[c].numDatapoints;\n  double *distances = malloc(clusterSize * (sizeof(double)));\n  for (i = 0; i < clusterSize; i++)\n  {\n    distances[i] = 0.0;\n    for (j = 0; j < clusterSize; j++)\n    {\n      distances[i] += distance(*clusters[c].datapoints[i], *clusters[c].datapoints[j]);\n    }\n\n  }\n\n  int medoidIndex = indexOfSmallestElement(distances, clusterSize);\n  clusters[c].medoid = clusters[c].datapoints[medoidIndex];\n  free(distances);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/28"}
{"code": "for (int i = 0; i < x; i++)\n  arr[i] = pow(i, 1. / 3.);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hoyajigi/openmp/omp_run/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/0"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  if (((i == 0) || (i == 10)) || (i == 20))\n    printGrid(maingrid);\n\n  stepGame(maingrid, backgrid);\n  swapGrid(&maingrid, &backgrid);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mvhv/gol-openmp/gol_collapse/3"}
{"code": "for (int j = 0; j < 2; ++j)\n{\n  sum_two += vector_vector[0][j];\n  printf(\"\\nadding %d\", vector_vector[0][j]);\n}\n\n", "pragma": "        #pragma omp parallel for shared(vector_vector) reduction(+: sum_two)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/0scari/Parralel-programmin-pratice/p6/ompbase/0"}
{"code": "for (i = 0; i < cs.encrypted_len; i++)\n  cs.encrypted[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dpapimk_fmt_plug/2"}
{"code": "for (j = 1; j < (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nctu-homeworks/PP-hw2/cg/13"}
{"code": "for (i = 0; i < 1000; i++)\n  check(accum(i), accum_ref(i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.4/2"}
{"code": "for (l = 0; l < parts; l++)\n{\n  final_result.numerator += fraction_results[i].numerator;\n  final_result.denominator *= fraction_results[i].denominator;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akshatd/cs3211-openmp-mpi/integralMP/3"}
{"code": "for (j = 2; j < (block_dim - 2); j++)\n{\n  neighbors = 0;\n  neighbors += (((((((a[0][j - 1] - '0') + (a[1][j - 1] - '0')) + (a[2][j - 1] - '0')) + (a[2][j] - '0')) + (a[2][j + 1] - '0')) + (a[1][j + 1] - '0')) + (a[0][j + 1] - '0')) + (a[0][j] - '0');\n  if ((a[1][j] == '0') && (neighbors == 3))\n  {\n    b[1][j] = '1';\n  }\n  else\n    if (a[1][j] == '1')\n  {\n    if (neighbors < 2)\n    {\n      b[1][j] = '0';\n    }\n    else\n      if (neighbors < 4)\n    {\n      b[1][j] = '1';\n    }\n    else\n    {\n      b[1][j] = '0';\n    }\n\n\n  }\n  else\n    b[1][j] = '0';\n\n\n}\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoRouv/game-of-life/GOLOpenMP/golOpenMP/3"}
{"code": "for (int i = 0; i < NX; i++)\n{\n  vecA[i] = 1.0 / ((double) (NX - i));\n  vecB[i] = vecA[i] * vecA[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/hybrid/work-sharing/solution/vector-addition/0"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < M; j++)\n  MFUNC(i, j, (A + (i * M)) + j);\n\n\n", "pragma": "omp parallel for num_threads(4) collapse(2) if(N*M>100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OmpCommonCore/Book/C/Fig_10.4_loopCollapse/0"}
{"code": "for (int i = 1; i <= Size; i++)\n{\n  number_of_primes += pEratos[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:number_of_primes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Prime Numbers/Parallelization/main/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (omp_in_parallel())\n      printf(\"parallel code\\n\");\n\n    b[i][j] = a[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/paratranspose/3"}
{"code": "for (int i = 0; i < DIM; i++)\n{\n  for (int j = 0; j < DIM; j++)\n  {\n    A[(i * DIM) + j] = rand() / ((float) 32767);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinosofrancisco/problema-reduccion-paralela/SolucionMemoriaCompartida/ompDosDimensionesReduccion/2"}
{"code": "for (i = 0; i < (righeC * colonneC); i++)\n  printf(\"%f \", C[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dani7B/CPD/KronecherOpenMP/1"}
{"code": "for (i = 0; i < buckets_count; i++)\n{\n  int j;\n  for (j = 0; j < N; j++)\n  {\n    int bucket_num = (int) (tab[j] * buckets_count);\n    if (bucket_num == i)\n      buckets[bucket_num][bucket_sizes[bucket_num]++] = tab[j];\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrycz/c-parallel-programming/openmp/openmp_bucket_sort/0"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  minn = (float) 2147483647;\n  d = 0;\n  for (int j = 0; j < 8; ++j)\n  {\n    float temp1[4];\n    res = _mm_setzero_ps();\n    for (int k = 4 - 4; k >= 0; k -= 4)\n    {\n      int t1;\n      int t2;\n      t1 = _mm_loadu_ps(point[i].elements + k);\n      t2 = _mm_loadu_ps(mean[j].elements + k);\n      t2 = _mm_sub_ps(t1, t2);\n      t2 = _mm_mul_ps(t2, t2);\n      res = _mm_add_ps(res, t2);\n    }\n\n    _mm_storeu_ps(temp1, res);\n    for (int k = (4 % 4) - 1; k >= 0; --k)\n    {\n      d += (point[i].elements[k] - mean[j].elements[k]) * (point[i].elements[k] - mean[j].elements[k]);\n    }\n\n    d += ((temp1[0] + temp1[1]) + temp1[2]) + temp1[3];\n    if (d < minn)\n    {\n      minn = d;\n      center[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(minn,d,res),schedule(dynamic,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/2"}
{"code": "for (j3 = 1; j3 < (m3j - 1); j3++)\n{\n  i3 = (2 * j3) - d3;\n  for (j2 = 1; j2 < (m2j - 1); j2++)\n  {\n    i2 = (2 * j2) - d2;\n    for (j1 = 1; j1 < m1j; j1++)\n    {\n      i1 = (2 * j1) - d1;\n      x1[i1] = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      y1[i1] = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n    }\n\n    for (j1 = 1; j1 < (m1j - 1); j1++)\n    {\n      i1 = (2 * j1) - d1;\n      y2 = ((r[i3][i2][i1 + 1] + r[i3 + 2][i2][i1 + 1]) + r[i3][i2 + 2][i1 + 1]) + r[i3 + 2][i2 + 2][i1 + 1];\n      x2 = ((r[i3 + 1][i2][i1 + 1] + r[i3 + 1][i2 + 2][i1 + 1]) + r[i3][i2 + 1][i1 + 1]) + r[i3 + 2][i2 + 1][i1 + 1];\n      s[j3][j2][j1] = (((0.5 * r[i3 + 1][i2 + 1][i1 + 1]) + (0.25 * ((r[i3 + 1][i2 + 1][i1] + r[i3 + 1][i2 + 1][i1 + 2]) + x2))) + (0.125 * ((x1[i1] + x1[i1 + 2]) + y2))) + (0.0625 * (y1[i1] + y1[i1 + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/12"}
{"code": "for (i = 0; i < (s + 2); i++)\n  filter->array[i] = (int *) my_malloc((s + 2) * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/filter_OMP/3"}
{"code": "for (int x = x_m; x < (x_M / 2); x += 1)\n{\n  for (int y = y_m; y < y_M; y += 1)\n  {\n    u[y + (x * GRID_SIZE)] = u[y + (x * GRID_SIZE)] + 1;\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/omp-par-for/0"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_nCellsSubbasin[(int) m_subbasin[i]] += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/GW_RSVR/GWaterReservoir/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  ue[m][k] = dtemp[m];\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/24"}
{"code": "for (i = 0; i < 100; i++)\n{\n  A[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gapgag55/OpenMP-Excercise/2.SumReductionClause/openmp/1"}
{"code": "for (dimension = 0; dimension < N; dimension++)\n{\n  dur = 0.0;\n  for (i = 0; i < VECES; i++)\n  {\n    tini = omp_get_wtime();\n    sumSecuencial = 0;\n    for (j = 0; j < n[dimension]; j++)\n    {\n      sumSecuencial += 4 * (pow(-1, j) / ((2 * j) + 1));\n    }\n\n    dur += omp_get_wtime() - tini;\n  }\n\n  sumPromSecuencial[dimension] = sumSecuencial;\n  durSecuencial[dimension] = dur / VECES;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HaslerUNMSM/PI-OpenMP/CalculoPI/0"}
{"code": "for (dest = 1; dest < proc_n; dest++)\n{\n  if (extra > 0)\n  {\n    rows = averow + 1;\n    extra--;\n  }\n  else\n  {\n    rows = averow;\n  }\n\n  MPI_Send(&kill_flag, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);\n  MPI_Send(&offset, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);\n  MPI_Send(&rows, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);\n  offset = offset + rows;\n  last_sched_offset = offset;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Diogo45/OpenMPI/mandelbrot/0"}
{"code": "for (int i = 0; i < _num_formulas; i++)\n  destroy_formula(&_formulas[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/breiters/papi_omp_util/src/papi_util/6"}
{"code": "for (i = 0; i < (M * 2); i = i + 1)\n{\n  for (j = 0; j < (M * 2); j += 2)\n  {\n    for (l = 0; l < M; l = l + 4)\n    {\n      Bcol[l] = BP[(l * M) + j];\n      Bcol[l + 1] = BP[((l * M) + j) + 1];\n      Bcol[l + 2] = BP[((l + 2) * M) + j];\n      Bcol[l + 3] = BP[(((l + 2) * M) + j) + 1];\n    }\n\n    for (int e = 0; e < (M * 2); e++)\n    {\n    }\n\n    r = 0.0;\n    indice_ligne = i * M;\n    for (k = 0; k < (M * 2); k = k + 4)\n    {\n      float4 t;\n      t[0] = AP[(indice_ligne + k) + 0];\n      t[1] = AP[(indice_ligne + k) + 1];\n      t[2] = AP[(indice_ligne + k) + 2];\n      t[3] = AP[(indice_ligne + k) + 3];\n      av4 = _mm_load_ps(t);\n      bv4 = _mm_load_ps(Bcol + k);\n      dot = _mm_dp_ps(av4, bv4, 0xFF);\n      _mm_store_ps(R4, dot);\n      r = r + R4[0];\n    }\n\n    rv = _mm_set_ps(r, r, r, r);\n    int ar = _mm_mul_ps(alphav, rv);\n    ar = _mm_addsub_ps(ar, _mm_shuffle_ps(ar, ar, _MM_SHUFFLE(0, 0, 3, 2)));\n    float4 cl;\n    cl[0] = (cl[1] = CP[indice_ligne + j]);\n    cl[2] = (cl[3] = CP[(indice_ligne + j) + 1]);\n    int cv = _mm_load_ps(cl);\n    int bc = _mm_mul_ps(betav, cv);\n    bc = _mm_addsub_ps(bc, _mm_shuffle_ps(bc, bc, _MM_SHUFFLE(0, 0, 3, 2)));\n    CP[indice_ligne + j] = ar[0] + bc[0];\n    CP[(indice_ligne + j) + 1] = ar[1] + bc[1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/rendu/gemm/0"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  a[j] = (j * 10) + 1;\n  b[j] = (j * 20) + 2;\n  c[j] = (j * 30) + 3;\n  d[j] = (j * 40) + 4;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vibhatha/OpenMP/code/exp1/OpenMPExamples/5"}
{"code": "for (i = 0; i < 800; i++)\n{\n  for (j = 0; j < 800; j++)\n  {\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/6"}
{"code": "for (uint i = 1; i < numBuckets; ++i)\n{\n  exScanHisto[i] = exScanHisto[i - 1] + histogramRadixFrequency[i - 1];\n  histogramRadixFrequency[i - 1] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/7"}
{"code": "for (i = 0; i < 2500; i++)\n{\n  for (j = 0; j < 2500; j++)\n  {\n    a[(i * 2500) + j] = i + j;\n  }\n\n}\n\n", "pragma": "omp for simd nowait collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/par_mm/0"}
{"code": "for (; (last_i + 63) < n; last_i += 64)\n{\n  _mm256_store_ps(&y[last_i + 0], _mm256_load_ps(&x[last_i + 0]));\n  _mm256_store_ps(&y[last_i + 8], _mm256_load_ps(&x[last_i + 8]));\n  _mm256_store_ps(&y[last_i + 16], _mm256_load_ps(&x[last_i + 16]));\n  _mm256_store_ps(&y[last_i + 24], _mm256_load_ps(&x[last_i + 24]));\n  _mm256_store_ps(&y[last_i + 32], _mm256_load_ps(&x[last_i + 32]));\n  _mm256_store_ps(&y[last_i + 40], _mm256_load_ps(&x[last_i + 40]));\n  _mm256_store_ps(&y[last_i + 48], _mm256_load_ps(&x[last_i + 48]));\n  _mm256_store_ps(&y[last_i + 56], _mm256_load_ps(&x[last_i + 56]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/14"}
{"code": "for (int j = fim_fragmento; j >= inicio_fragmento; j--)\n{\n  sequencia_inversa[thread] += sequencia[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  tryPositions(i, 0, 0, 0, 0);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krummelur/n-queens_openMP/n-queens/0"}
{"code": "for (i = 0; i < width; i++)\n  for (j = 0; j < height; j++)\n{\n  helpMassive[i][j].present = mainField[i][j].past;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/lgame/7"}
{"code": "for (i = 0; i < 8; i++)\n{\n  q = sol->r[i];\n  idiag = i - 1;\n  offset = 1;\n  while (idiag > 0)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag--;\n  }\n\n  idiag = i + 1;\n  offset = 1;\n  while (idiag < 8)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      printf(\"downdiags false!\\n\");\n      return 0;\n    }\n\n    offset++;\n    idiag++;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    q2 = sol->r[j];\n    if (j == i)\n    {\n      continue;\n    }\n\n    if (q2 == q)\n    {\n      printf(\"cols false!\\n\");\n      return 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonaut/8queensOpenMP/hw3/5"}
{"code": "for (i = 0; i < r; i++)\n  for (j = 0; j < c; j++)\n  for (k = 0; k < r; k++)\n  a3[i][j] += a1[i][k] * a2[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog2_MatrixMul_opemmp/5"}
{"code": "for (int w = 0; w < divider; w++)\n{\n  if (w == dy)\n    break;\n\n  for (int m = 0; m < divider; m++)\n  {\n    if (m == dx)\n      break;\n\n    sum += *((matrixdata + ((x * divider) + m)) + (((y * divider) + w) * DtCol));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/34"}
{"code": "for (i = 0; i < ISIZ1; i++)\n{\n  for (j = 0; j < ISIZ2; j++)\n  {\n    for (k = 0; k < 5; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        a[i][j][k][m] = 0.0;\n        b[i][j][k][m] = 0.0;\n        c[i][j][k][m] = 0.0;\n        d[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/49"}
{"code": "for (int i = 0; i < size; i++)\n{\n  input_file.read((char *) (&p.x), sizeof(float));\n  input_file.read((char *) (&p.y), sizeof(float));\n  input_file.read((char *) (&p.z), sizeof(float));\n  input_file.read((char *) (&p.r), sizeof(uint8_t));\n  input_file.read((char *) (&p.g), sizeof(uint8_t));\n  input_file.read((char *) (&p.b), sizeof(uint8_t));\n  cloud->push_back(p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/10"}
{"code": "for (int ci = 0; ci < NCELLS; ci++)\n{\n  for (int vi = 0; vi < cell(ci).getNV(); vi++)\n  {\n    for (int d = 0; d < NDIM; d++)\n    {\n      v_temp = cell(ci).vvel(vi, d) - (system_p[d] / system_mass);\n      cell(ci).setVVel(vi, d, v_temp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/91"}
{"code": "for (register unsigned int j = 0; j < (N * 2); j += incY + 2)\n{\n  YP[j] = XP[j];\n  YP[j + 1] = XP[j + 1];\n  YP[j + 2] = XP[j + 2];\n  YP[j + 3] = XP[j + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/10"}
{"code": "for (int i = da; i < a; ++i)\n{\n  for (int j = 0; j < input->d; ++j)\n  {\n    x_new[j] = input->x[(i * input->d) + j] + (((input->r[(sup->r_i + (i * input->d)) + j] * 2) - 1) * sup->stepind_curr);\n  }\n\n  double f_new_i = evaluate_f(x_new, input->c, 0, input->d);\n  double delta_f_i = f_new_i - sup->f_curr[i];\n  if (delta_f_i < 0)\n  {\n    sup->delta_f[i] = delta_f_i;\n    sup->f_curr[i] = f_new_i;\n    for (int j = 0; j < input->d; ++j)\n    {\n      sup->delta_x[(i * input->d) + j] = x_new[j] - input->x[(i * input->d) + j];\n      input->x[(i * input->d) + j] = x_new[j];\n    }\n\n  }\n  else\n  {\n    for (int j = 0; j < input->d; ++j)\n      sup->delta_x[(i * input->d) + j] = 0;\n\n    sup->delta_f[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss64comp/7"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    colidx[k] = (colidx[k] - firstcol) + 1;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  u[0][j] = 0.0;\n  u[m - 1][j] = 100.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/InitGrid/1"}
{"code": "for (unsigned int j = 0; j < ((unsigned int) (np / 2)); j++)\n{\n  if (j != 0)\n  {\n    int info1[] = {(np / 2) + j, -1};\n    MPI_Send((void *) info1, 2, MPI_INT, j, TAG_TRANSFER_INFO, MPI_COMM_WORLD);\n  }\n\n  int info2[] = {-1, j};\n  MPI_Send((void *) info2, 2, MPI_INT, (np / 2) + j, TAG_TRANSFER_INFO, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/12"}
{"code": "for (r = 0; r < row; r++)\n{\n  for (c = 0; c < col; c++)\n  {\n    temp[(r * col) + c] = result[(r * col) + c];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(result, temp) private(r, c) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_hotspot/hotspot_openmp/1"}
{"code": "for (i = 0; i < j; i++)\n  e++;\n\n", "pragma": "omp parallel for reduction(+:e)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr38650/2"}
{"code": "for (int j = 0; j < numHidden1Nodes; ++j)\n{\n  double err = 0.0;\n  for (int k = 0; k < numHidden2Nodes; ++k)\n  {\n    err -= h2_err[k] * layer2_weights[k][j];\n  }\n\n  h1_err[j] = err * act_d(layer1[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/10"}
{"code": "for (idx = 0; idx < size; idx++)\n  packed_buf[idx] = buf[get_pack_index(idx, face, remain_dim)];\n\n", "pragma": "omp for schedule(dynamic, 16) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  func_param = a + ((i + 0.5) * temp);\n  sum += f2(func_param, intensity) * temp;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic,granularity) reduction(+:sum)     ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akarsh3007/Parallel-Computing/Assignment-4/openmp/numint/1"}
{"code": "for (int j = 2; j < sqrt(number + 1); j++)\n{\n  if (A[j] != 0)\n  {\n    int t = j * j;\n    while (t < (number + 1))\n    {\n      A[t] = 0;\n      t = t + j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/3"}
{"code": "for (i = 0; i < 48; i++)\n{\n  for (j = 0; j < 48; j++)\n  {\n    printf(\"%.lf \", dist[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/demiurgo64/ant_colony_openMP/Multi/AntOMP/8"}
{"code": "for (i = 0; i < Iters; i++)\n  CountConvgV[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/83"}
{"code": "for (l = 0; l <= (ub - 1); l += 1)\n{\n  int l8 = l * 8;\n  real8 h1 = m[((t1 + l8) * 4) + 1];\n  real8 h2 = m[((t1 + l8) * 4) + 2];\n  real8 h3 = m[((t1 + l8) * 4) + 3];\n  nel = nell[l];\n  p[nell[l]] += (((h1 * (((d11[l] * h1) + ((d12[l] * 2.) * h2)) + ((d13[l] * 2.) * h3))) + (h2 * ((d22[l] * h2) + ((d23[l] * 2.) * h3)))) + ((h3 * d33[l]) * h3)) * 64.;\n}\n\n", "pragma": "omp parallel for private (nel,l) firstprivate (ub,t1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_livenessTest/1"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (unsigned int j = 2 - (i % 2); j <= n; j += 2)\n  {\n    x[j + ((n + 2) * i)] = (x0[j + ((n + 2) * i)] + (a * (((x[(j - 1) + ((n + 2) * i)] + x[(j + 1) + ((n + 2) * i)]) + x[j + ((n + 2) * (i - 1))]) + x[j + ((n + 2) * (i + 1))]))) / c;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo1a/solver/1"}
{"code": "for (int x = 1; x <= len; x++)\n{\n  column[0] = x;\n  lastdiag = x - 1;\n  for (int y = 1; y <= len; y++)\n  {\n    olddiag = column[y];\n    column[y] = ((column[y] + 1) < (column[y - 1] + 1)) ? (((column[y] + 1) < (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) ? (column[y] + 1) : (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) : (((column[y - 1] + 1) < (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) ? (column[y - 1] + 1) : (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1))));\n    lastdiag = olddiag;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmOMP/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (!(A[i] % 2))\n  {\n    omp_set_lock(&lock);\n    if (!(A[i] % 2))\n      total += B[i] + C[i];\n\n    omp_unset_lock(&lock);\n  }\n  else\n    if (!((A[i] == 1) || (B[i] == 1)))\n  {\n    omp_set_lock(&lock);\n    if (!((A[i] == 1) || (B[i] == 1)))\n      total += B[i] - A[i];\n\n    omp_unset_lock(&lock);\n  }\n\n\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VGol-Git/OpenMP/OpenMP/LAB6_1/1"}
{"code": "for (j = 0; j < 2; j++)\n{\n  row_sum += (*((array + (i * 2)) + j)) * (*(vector + j));\n}\n\n", "pragma": "omp parallel for reduction(+ : row_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1b_MatrixVectorMult_OpenMP_approach1/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"\\n\\t x(%d) = %.1f \", i + 1, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CaillaRose/OpenMP/threadGauss/4"}
{"code": "for (int i = 0; i < node; i++)\n{\n  R = fmax(R, fabs(b[i] - x[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/Instrumental/1"}
{"code": "for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n  for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/2"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  char y[50];\n  __builtin_strcpy(y, x[i]);\n  __builtin_strcat(y, \"foo\");\n  bar(y);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr66820/0"}
{"code": "for (i = 0; i < length; i++)\n  sum += *(a + i);\n\n", "pragma": "omp parallel for default(none) firstprivate(a, length) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MetalRain/learn-openmp/prod_cons/0"}
{"code": "for (int x = 1; x < (MAP_SIZE - 1); ++x)\n{\n  for (int y = 1; y < (MAP_SIZE - 1); ++y)\n  {\n    currentWaveIntensity[x][y] = (islandMap[x][y] >= LAND_THRESHOLD) ? (0.0f) : (clamp(lastWaveIntensity[x][y] + (((lastWaveIntensity[x][y] - secondLastWaveIntensity[x][y]) + (ATTACK_FACTOR * ((((lastWaveIntensity[x][y - 1] + lastWaveIntensity[x - 1][y]) + lastWaveIntensity[x + 1][y]) + lastWaveIntensity[x][y + 1]) - (4 * lastWaveIntensity[x][y])))) * clamp(ENERGY_PRESERVATION_FACTOR * (LAND_THRESHOLD - (0.1f * islandMap[x][y])), 0.0f, 1.0f)), 0.0f, 1.0f));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(4) schedule(static, 256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stanley-chang/Parallel-Computing/OpenMP_Captain_Sparrow's_Return_to_Port_Royal/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  ist = kpic[k];\n  npx = (npx > ist) ? (npx) : (ist);\n  isum += ist;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/28"}
{"code": "for (i = 1; i <= 5; ++i)\n{\n  {\n    a += i;\n    b *= i;\n  }\n}\n\n", "pragma": "omp for reduction(task, +: a) reduction(task, *: b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/tasking/task_reduction2/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    b[i][j] = m[(100 * k) + i][(100 * l) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/igrishaev/vsu-prp/matrix_fox_omp/5"}
{"code": "for (i = 0; i < 4; i++)\n{\n  if (rmat[0][i] > avail[0][i])\n  {\n    printf(\"\\n ******Resources unavailable*****\\n\");\n    exit(0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephloochunhoe/parallel-computing/A1/Parallel_Bankers_Algorithm/6"}
{"code": "for (int i = 0; i < N; i++)\n{\n  queenPlaced[0] = i;\n  result += search(queenPlaced, N, 1);\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ValentinDeguil/n-queen-OpenMP/queenParallel/0"}
{"code": "for (i = 1; i < (N - 1); i++)\n  for (j = 1; j < (M - 1); j += 2)\n{\n  shift = shift0[i];\n  unew[i][j + shift] = ((1.0 - omega) * uold[i][j + shift]) + ((0.25 * omega) * ((((uold[i + 1][j + shift] + uold[i][(j + shift) + 1]) + uold[i - 1][j + shift]) + uold[i][(j + shift) - 1]) - ((dx * dx) * ((-10.0) * (((x[i] * x[i]) + (y[j + shift] * y[j + shift])) + 5.0)))));\n}\n\n\n", "pragma": "omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/6"}
{"code": "for (i = 0; i < (duzina * broj_niti); i++)\n{\n  if ((i % 2) != 0)\n  {\n    niz[i] = 10;\n  }\n  else\n  {\n    niz[i] = 20;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static) shared(niz) if(duzina*broj_niti>1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aminadd/Srednja_vrednost_OpenMP/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  GaussEliNd2(MT, r, i);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/GaussEli/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_soilET[i] = 0.0f;\n  if (m_soilTemp[i] <= m_soilFrozenTemp)\n  {\n    continue;\n  }\n\n  float etDeficiency = ((m_pet[i] - m_IntcpET[i]) - m_deprStoET[i]) - m_maxPltET[i];\n  for (int j = 0; j < CVT_INT(m_nSoilLyrs[i]); j++)\n  {\n    if (etDeficiency <= 0.f)\n      break;\n\n    float et2d = 0.f;\n    if (m_soilWtrSto[i][j] >= m_soilFC[i][j])\n    {\n      et2d = etDeficiency;\n    }\n    else\n      if (m_soilWtrSto[i][j] >= 0.f)\n    {\n      et2d = (etDeficiency * m_soilWtrSto[i][j]) / m_soilFC[i][j];\n    }\n    else\n    {\n      et2d = 0.0f;\n    }\n\n\n    if (et2d > m_soilWtrSto[i][j])\n    {\n      et2d = m_soilWtrSto[i][j];\n      m_soilWtrSto[i][j] = 0.f;\n    }\n    else\n    {\n      m_soilWtrSto[i][j] -= et2d;\n    }\n\n    if (m_soilWtrSto[i][j] < 0.f)\n    {\n      ((((cout << \"SET_LM: moisture is less than zero\") << m_soilWtrSto[i][j]) << \"\\t\") << et2d) << endl;\n      errCount++;\n    }\n\n    etDeficiency -= et2d;\n    m_soilET[i] += et2d;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: errCount)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SET_LM/SET_LM/0"}
{"code": "for (int i = beginpos; i < endpos; i++)\n  if (a[i] != b[i])\n{\n  different = 1;\n}\n\n\n", "pragma": "      #pragma omp parallel for reduction(|:different)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jonguan/cmpe275-lab1/matrix/src/matrix/1"}
{"code": "for (int i = 0; i < Metabolic_Error_Precision; i++)\n{\n  sum_metabolic_error += abs(gridcell_->environment_target[i] - metabolic_error[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nathan-K-/PC-optimisation/src/Organism/1"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixMul/matrixMul_openMP/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  BinSizes[i] += HelpArray[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/radix_sort/1"}
{"code": "for (int y = y0; y < y1; y++)\n{\n  int yLine = WORLD_WIDTH * y;\n  for (int x = x0; x < x1; x++)\n  {\n    int cnt = 0;\n    int group = 0;\n    for (int yy = y - 1; yy <= (y + 1); yy++)\n    {\n      for (int xx = x - 1; xx <= (x + 1); xx++)\n      {\n        if (m_matSrc[(WORLD_WIDTH * yy) + xx].age != CELL_DEAD)\n        {\n          cnt++;\n          group += m_matSrc[(WORLD_WIDTH * yy) + xx].group;\n        }\n\n      }\n\n    }\n\n    updateCell(x, yLine, cnt, group);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iwatake2222/FastGameOfLife/GameOfLife/LogicGroup/2"}
{"code": "for (j = 0; j < num_particles; j++)\n{\n  for (i = 0; i < dimension; i++)\n  {\n    velocity[i + (j * dimension)] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPC-Project/openMp/openmp/6"}
{"code": "for (int k = 1; k <= ((int) m_flowInIndex[id][0]); ++k)\n{\n  int flowInID = (int) m_flowInIndex[id][k];\n  Qin += m_Qkin[flowInID];\n  Sin += m_Qsn[flowInID];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/KinWavSed_OL/KinWavSed_OL/3"}
{"code": "for (int i = 1; i < nOfLayers; i++)\n{\n  for (int j = 0; j < copys[n][i].nOfNeurons; j++)\n  {\n    for (int k = 0; k < (copys[n][i - 1].nOfNeurons + 1); k++)\n    {\n      if (copys[n][i].neurons[j].deltaW != NULL)\n      {\n        copys[n][i].neurons[j].deltaW[k] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/19"}
{"code": "for (int i = 0; i < mpi_size; i++)\n  if (i != mpi_rank)\n{\n  _MPI_Wait(&rqs[(2 * i) + 0], &st);\n  _MPI_Wait(&rqs[(2 * i) + 1], &st);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/114"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"%d\\n\", i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/02_typecalc_cxx.dg/success_650/0"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  const T scalar = SCALAR;\n  a[i] = b[i] + (scalar * c[i]);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd thread_limit(TBSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/babelstream-omp/main/2"}
{"code": "for (int i = n - 2; i >= 0; i--)\n  x[i] = d[i] - (c[i] * x[i + 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/11"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  r[i] = i * M_PI;\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/BICG/bicg/5"}
{"code": "for (int n = 0; n < N; n++)\n{\n  out_real[n] = in_real[n];\n  out_imag[n] = in_imag[n];\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit (BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lsqt-omp/vector/2"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  C_orig[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForGraphClustering/1"}
{"code": "for (int i = 0; i < FRAMES_PER_BUFFER; i++)\n{\n  if (fabs(apOut[i]) > max)\n  {\n    max = fabs(apOut[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SurturTawers/OpenMP-ReverbDSP/reverbParalelo/4"}
{"code": "for (j = x_min - 2; j <= (x_max + 3); j++)\n{\n  vertexx[FTNREF1D(j, x_min - 2)] = min_x + (d_x * ((double) (j - x_min)));\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/initialise_chunk_kernel_c/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  int index = 0;\n  for (j = 0; j < i; j++)\n    index = index + count[(i - j) - 1];\n\n  for (j = 0; j < count[i]; j++)\n    final[index + j] = bucket[i][j];\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HardiChandra/Parallel-Programming-Projects/Project4 Bucket Sort/Project4-BucketSort/Project4-BucketSortBackup/Project4-BucketSortBackup/4"}
{"code": "for (p = 2; p <= sqrt_limit; p++)\n{\n  if (get_bit(array, p) == 0)\n  {\n    for (i = p * p; i <= n; i += p)\n    {\n      if (get_bit(array, i) == 0)\n        toggle_bit(array, i);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) num_threads(NUM_THREAD) shared(array, sqrt_limit, n) private(p, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabiopereira96/crivo-eratostenes-paralelo/sieve/0"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  node_distance_array[i] = 2147483647;\n  parent_nodes_array[i] = -1;\n  visited_nodes_array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/11"}
{"code": "for (gridpoint[0] = lower[0], u = 0; u <= tot_ev_per_dim[0]; gridpoint[0] += dx[0], u++)\n{\n  int HalfPosition = (((gridpoint[0] - x0[0]) / dx[0]) * pdf->pdfcumsize[0]) + (((gridpoint[2] - x0[2]) / dx[2]) * pdf->pdfcumsize[2]);\n  #pragma simd private(PCdot) assert\n  for (v = 0; v <= tot_ev_per_dim[1]; v++)\n  {\n    PCdot[0] = ((eigenvectors->me[0][0] * gridpoint[0]) + (eigenvectors->me[0][1] * (lower[1] + (dx[1] * v)))) + (eigenvectors->me[0][2] * gridpoint[2]);\n    PCdot[1] = ((eigenvectors->me[1][0] * gridpoint[0]) + (eigenvectors->me[1][1] * (lower[1] + (dx[1] * v)))) + (eigenvectors->me[1][2] * gridpoint[2]);\n    PCdot[2] = ((eigenvectors->me[2][0] * gridpoint[0]) + (eigenvectors->me[2][1] * (lower[1] + (dx[1] * v)))) + (eigenvectors->me[2][2] * gridpoint[2]);\n    temp = ((((PC[0] - PCdot[0]) * (PC[0] - PCdot[0])) + ((PC[1] - PCdot[1]) * (PC[1] - PCdot[1]))) + ((PC[2] - PCdot[2]) * (PC[2] - PCdot[2]))) / h2;\n    densPosition[v] = HalfPosition + ((((lower[1] + (dx[1] * v)) - x0[1]) / dx[1]) * pdf->pdfcumsize[1]);\n    densValues[v] = (((0.5 / cd) * (3 + 2.)) * (1. - temp)) * (fabs(temp) < 1.);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  sd_asum = sd_asum + ((a[i] - mean_a) * (a[i] - mean_a));\n  sd_bsum = sd_bsum + ((b[i] - mean_b) * (b[i] - mean_b));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/knal1992/Pearson-Correlation-OpenMP/OMP/4"}
{"code": "for (j = 0; j < VERYBIG; j++)\n{\n  sum += 1;\n  sumx = 0.0;\n  for (k = 0; k < j; k++)\n    sumx = sumx + ((double) k);\n\n  sumy = 0.0;\n  for (k = j; k > 0; k--)\n    sumy = sumy + ((double) k);\n\n  if (sumx > 0.0)\n  {\n    total = total + (1.0 / sqrt(sumx));\n  }\n\n  if (sumy > 0.0)\n  {\n    total = total + (1.0 / sqrt(sumy));\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/Lab1/Lab-1-1/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i].arrival_time = arr[i];\n  p[i].burst_time = bur[i];\n  burst_remaining[i] = p[i].burst_time;\n  p[i].pid = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/rr_parallel/0"}
{"code": "for (int j = 1; j < (eq_Nx - 1); j++)\n  eq_inv_m[j] = (eq_inv_m[((eq_Nx - 1) * eq_Nx) + j] = 0.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/15"}
{"code": "for (i = 0; i < 5; ++i)\n{\n  sum = 0.0;\n  for (j = 0; j < num; ++j)\n  {\n    S1[j] = 0;\n    for (k = 0; k < num; ++k)\n    {\n      S1[j] += H[(j * num) + k] * S[k];\n    }\n\n    sum += S1[j];\n  }\n\n  sum = 1.0 / (sum + 0.0001);\n  for (j = 0; j < num; ++j)\n  {\n    S[j] = S1[j] * sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/18"}
{"code": "for (long i = 0; i < I->segments; i++)\n{\n  int QSR_id = rand_r(&seed) % I->source_3D_regions;\n  QSR_id_arr[i] = QSR_id;\n  int FAI_id = rand_r(&seed) % I->fine_axial_intervals;\n  FAI_id_arr[i] = FAI_id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/16"}
{"code": "for (i = 0; i < N; i++)\n{\n  A[i] = (REAL) (lower + ((((REAL) rand()) / ((REAL) 32767)) * (upper - lower)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/bm2d/bm2d/1"}
{"code": "for (int i = 1; i < nodesNum; ++i)\n{\n  ((cout << \"\\t collecting data from node \") << i) << \" ...\\n\";\n  {\n    if (i != (nodesNum - 1))\n    {\n      for (int j = 0; j < taskEachNode; ++j)\n      {\n        MPI_Status status;\n        MPI_Recv(recvBuff, sizeOfItems, MPI_DOUBLE, i, ((i - 1) * taskEachNode) + j, MPI_COMM_WORLD, &status);\n        memcpy(weights + ((((i - 1) * taskEachNode) + j) * sizeOfItems), recvBuff, sizeOfItems);\n      }\n\n    }\n    else\n    {\n      int lines = sizeOfItems - (taskEachNode * (nodesNum - 2));\n      for (int j = 0; j < lines; ++j)\n      {\n        MPI_Status status;\n        MPI_Recv(recvBuff, sizeOfItems, MPI_DOUBLE, i, ((i - 1) * taskEachNode) + j, MPI_COMM_WORLD, &status);\n        memcpy(weights + ((((i - 1) * taskEachNode) + j) * sizeOfItems), recvBuff, sizeOfItems);\n      }\n\n    }\n\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-action-based/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int tno = omp_get_thread_num();\n  int temp = lineDist(l, r, P[i]);\n  int k = findSide(l, r, P[i]);\n  if ((k == side) && (temp > max_dist))\n  {\n    max_dist = temp;\n    ind = i;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aman33459/ParallelConvexHull/quickHull/quickhullpara/5"}
{"code": "for (int x = 0; x < width; x++)\n{\n  for (int y = 0; y < height; y++)\n  {\n    result[(y * width) + x] = ((0.2126 * img[((y * width) + x) * channels]) + (0.7152 * img[(((y * width) + x) * channels) + 1])) + (0.0722 * img[(((y * width) + x) * channels) + 2]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiangRongLin/grayscale-conversion/cpu/algorithms/openmp_baseline/0"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/0"}
{"code": "for (j = 0; j < num_rows; j++)\n{\n  for (k = i + 1; k < (n + 1); k++)\n  {\n    sub_a[(j * (n + 1)) + k] = sub_a[(j * (n + 1)) + k] - (sub_a[(j * (n + 1)) + i] * row[k]);\n  }\n\n  sub_a[(j * (n + 1)) + i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/4"}
{"code": "for (i = 0; i < M; i += 18)\n{\n  for (j = 0; j < N; j += 18)\n  {\n    for (p = i; (p < (i + 18)) && (p < M); p++)\n    {\n      for (q = j; (q < (j + 18)) && (q < N); q++)\n      {\n        if (p == q)\n        {\n          temp = A[p][p];\n        }\n        else\n        {\n          B[p][q] = A[q][p];\n        }\n\n      }\n\n      if (i == j)\n      {\n        B[p][p] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/praateekmahajan/parallel-adaboost/c++/time_transpose/2"}
{"code": "for (int m = 0; m < 8; m++)\n{\n  printf(\"%lux%lu:\\t\", matrixSizes[m], matrixSizes[m]);\n  printf(\"%.9f \\n\", sequentialTimings[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/dot_product/dot_product_benchmarking/5"}
{"code": "for (int i = start; i < (start + no_of_elements); ++i)\n  if (ord == (arr[i] > arr[i + no_of_elements]))\n  swap(arr[i], arr[i + no_of_elements]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhinav-vaishya/Parallel-Computing---MPI-OpenMP-CUDA/codes/Q3_omp/0"}
{"code": "for (int i = 0; i < 100; i++)\n  for (int j = 0; j < 100; j++)\n{\n  ma[i][j] = -1;\n  mb[i][j] = i;\n  mc[i][j] = 2 * i;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/6"}
{"code": "for (i = 0; i < nv; i++)\n  for (j = i; j < nv; j++)\n{\n  if (j == i)\n    ohd[(i * nv) + i] = 0;\n  else\n  {\n    ohd[(nv * i) + j] = rand() % 200;\n    ohd[(nv * j) + i] = ohd[(nv * i) + j];\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/2"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 3; j < (grid_points[1] - 3); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n      {\n        rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * ((((u[i][j - 2][k][m_imopVar133] - (4.0 * u[i][j - 1][k][m_imopVar133])) + (6.0 * u[i][j][k][m_imopVar133])) - (4.0 * u[i][j + 1][k][m_imopVar133])) + u[i][j + 2][k][m_imopVar133]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/67"}
{"code": "for (int i = 0; i < TEST_EXAMPLES; i++)\n{\n  activate_NN(TEST_DATA[i]);\n  max = OL2[0];\n  predicted_class = 0;\n  for (int j = 1; j < L2_NEURONS; j++)\n  {\n    if (OL2[j] > max)\n    {\n      max = OL2[j];\n      predicted_class = j;\n    }\n\n  }\n\n  if (predicted_class == TEST_CLASS[i])\n    correct++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/9"}
{"code": "for (i = 0; i < 6; i++)\n{\n  printf(\"%d \", nums[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wibeck/c-edu/ParallelTest/ForExample/1"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    d[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanTrofimov/parallel-programming/code/syncronized/0"}
{"code": "for (int i = 0; i < HEIGHT; ++i)\n{\n  field[i] = malloc(WIDTH * (sizeof(float)));\n  for (int j = 0; j < WIDTH; ++j)\n  {\n    field[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/5"}
{"code": "for (i = 0; i < points->num; i++)\n{\n  if (points->p[i].assign != i)\n  {\n    relweight = points->p[points->p[i].assign].weight + points->p[i].weight;\n    relweight = points->p[i].weight / relweight;\n    for (ii = 0; ii < points->dim; ii++)\n    {\n      points->p[points->p[i].assign].coord[ii] *= 1.0 - relweight;\n      points->p[points->p[i].assign].coord[ii] += points->p[i].coord[ii] * relweight;\n    }\n\n    points->p[points->p[i].assign].weight += points->p[i].weight;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/25"}
{"code": "for (k = 0; k < size; ++k)\n  X[k] = Au[index[k]][size] / Au[index[k]][k];\n\n", "pragma": "omp for schedule(static, 64) private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abidrahman/Discovering-OpenMP/static/2"}
{"code": "for (unsigned long i = 0; counter < n; i++)\n{\n  this->primes[counter] = i;\n  if (mpz_probab_prime_p(this->primes[counter].get_mpz_t(), 25) == 2)\n  {\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vamartid/NSK-birthday-attack/parallel/Ns/0"}
{"code": "for (i = 1; i < n; i++)\n  area = area + ((5 * (a + (i * h))) * (a + (i * h)));\n\n", "pragma": "omp parallel for reduction(+:area)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_2/Trapezoidal/Approach 2/parallel/0"}
{"code": "for (int i = 0; i < ((3 * 640) * 480); i++)\n  image[i] = 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/aobench/ao/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n  if ((*(dist + i)) > md)\n{\n  for (int j = 0; j < d; j++)\n    *((outer + (outer_n * j)) + outer_counter) = *((X + (n * j)) + i);\n\n  *(outer_idx + outer_counter) = *(idx_list + i);\n  outer_counter++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thanosmanolis/vptree/src/vptree_openmp/6"}
{"code": "for (i = 0; i < 180; i++)\n  for (j = 0; j < 180; j++)\n  solution_matrix[i][j] = (sinh(((double) j) * h) * sin(((double) i) * h)) / sinh(M_PI);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/6"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    if (dom[i][j][k] == 0)\n    {\n      tmp = fabs(pre_old[i][j][k] - pre[i][j][k]) * perfect_sinus_emitter;\n      if (tmp < 2.0e-5)\n        tmp = 0.0;\n\n      if (tmp > pressure_integrated[i][j][k])\n        pressure_integrated[i][j][k] = tmp;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/noise_generator/8"}
{"code": "for (i = 0; i < a_r; i++)\n{\n  for (j = 0; j < a_c; j++)\n  {\n    printf(\"A[%d][%d]\", i, j);\n    scanf(\"%d\", &a[i][j]);\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejaswiParuchuri/ParalleProcessing/addmp/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  fprintf(fptr, \"%f \", sum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_1/5"}
{"code": "for (int i = 0; i < sum; i++)\n{\n  if (i < buffer_arr[2])\n  {\n    level.push_back(new_buffer[i]);\n  }\n  else\n    if (i < (buffer_arr[2] + buffer_arr[3]))\n  {\n    index.push_back(new_buffer[i]);\n  }\n  else\n    if (i < ((buffer_arr[2] + buffer_arr[3]) + buffer_arr[4]))\n  {\n    indptr.push_back(new_buffer[i]);\n  }\n  else\n  {\n    level_offset.push_back(new_buffer[i]);\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/2"}
{"code": "for (uint8 y = 0; y < 120; y++)\n{\n  temp = features->layer5[y][0][0];\n  temp += ((((((((((((((((((((((((features->layer4[15][0][0] * net->weight4_5[15][y][0][0]) + (features->layer4[15][0][1] * net->weight4_5[15][y][0][1])) + (features->layer4[15][0][2] * net->weight4_5[15][y][0][2])) + (features->layer4[15][0][3] * net->weight4_5[15][y][0][3])) + (features->layer4[15][0][4] * net->weight4_5[15][y][0][4])) + (features->layer4[15][1][0] * net->weight4_5[15][y][1][0])) + (features->layer4[15][1][1] * net->weight4_5[15][y][1][1])) + (features->layer4[15][1][2] * net->weight4_5[15][y][1][2])) + (features->layer4[15][1][3] * net->weight4_5[15][y][1][3])) + (features->layer4[15][1][4] * net->weight4_5[15][y][1][4])) + (features->layer4[15][2][0] * net->weight4_5[15][y][2][0])) + (features->layer4[15][2][1] * net->weight4_5[15][y][2][1])) + (features->layer4[15][2][2] * net->weight4_5[15][y][2][2])) + (features->layer4[15][2][3] * net->weight4_5[15][y][2][3])) + (features->layer4[15][2][4] * net->weight4_5[15][y][2][4])) + (features->layer4[15][3][0] * net->weight4_5[15][y][3][0])) + (features->layer4[15][3][1] * net->weight4_5[15][y][3][1])) + (features->layer4[15][3][2] * net->weight4_5[15][y][3][2])) + (features->layer4[15][3][3] * net->weight4_5[15][y][3][3])) + (features->layer4[15][3][4] * net->weight4_5[15][y][3][4])) + (features->layer4[15][4][0] * net->weight4_5[15][y][4][0])) + (features->layer4[15][4][1] * net->weight4_5[15][y][4][1])) + (features->layer4[15][4][2] * net->weight4_5[15][y][4][2])) + (features->layer4[15][4][3] * net->weight4_5[15][y][4][3])) + (features->layer4[15][4][4] * net->weight4_5[15][y][4][4]);\n  features->layer5[y][0][0] = temp;\n  temp += net->bias4_5[y];\n  if (temp < 0)\n    temp = 0;\n\n  features->layer5[y][0][0] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NegarNd/CNN-Inference-Acceleration/main_omp/6"}
{"code": "for (int i = 0; i < n_size; i++)\n{\n  drand48_r(&buffer, &num_aleatorio);\n  sol_corrente[i] = (2.0 * num_aleatorio) - 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leandrosfj/OpenMP_CSA/C\u00f3digos/OMP_CSA/0"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  printf(\"Hi from %d iteration %d \\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/learn_openmp/OpenMP ECP ESP Workshop/examples/parallel_for/0"}
{"code": "for (int i = start; i <= end; i++)\n{\n  for (int j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      flag = false;\n    }\n\n  }\n\n  if (flag)\n  {\n    (cout << i) << \" \";\n  }\n\n  flag = true;\n}\n\n", "pragma": "        #pragma omp for firstprivate(flag)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task15/0"}
{"code": "for (int col = 0; col < n; col++)\n  sum += A_row[col] * V[col];\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/hands-on/gemv/04-gemv-omp-target-reduction/gemv-omp-target-reduction/0"}
{"code": "for (c1 = nk; c1 <= (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nk; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/11"}
{"code": "for (i = ist; i <= L2; i += 1)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21i = tmp * rsd[i][j][k][1];\n  u31i = tmp * rsd[i][j][k][2];\n  u41i = tmp * rsd[i][j][k][3];\n  u51i = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i - 1][j][k][0];\n  u21im1 = tmp * rsd[i - 1][j][k][1];\n  u31im1 = tmp * rsd[i - 1][j][k][2];\n  u41im1 = tmp * rsd[i - 1][j][k][3];\n  u51im1 = tmp * rsd[i - 1][j][k][4];\n  flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n  flux[i][j][k][2] = tx3 * (u31i - u31im1);\n  flux[i][j][k][3] = tx3 * (u41i - u41im1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((1.40e+00 * 1.40e+00) * tx3) * (u51i - u51im1));\n}\n\n", "pragma": "omp parallel for private (u21im1,u31im1,u41im1,u51im1,tmp,u21i,u31i,u41i,u51i,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/24"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a = a + 3;\n  b = b + 4;\n}\n\n", "pragma": "omp for private(a, b)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_03/0"}
{"code": "for (int i = omp_get_thread_num() + 1; i < N; i += 8)\n{\n  for (int j = 1; j < i; j++)\n  {\n    tmpsum4 += (j + sin(x + j)) / (((2 * i) * j) - 1);\n  }\n\n  if (tmpsum4 != 0)\n  {\n    sum += 1 / tmpsum4;\n  }\n\n  tmpsum4 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/6"}
{"code": "for (uint64_t i = 0; i < (n - k); i++)\n{\n  m += (uint64_t) ((buffer[i] >> NthB) & 1);\n  for (uint64_t j = 0; j < k; j++)\n  {\n    rk[j] += (uint64_t) (((buffer[i] & buffer[i + j]) >> NthB) & 1);\n  }\n\n}\n\n", "pragma": "omp for reduction(+:m), reduction(+:rk[:k])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/2"}
{"code": "for (m = 0; m < 5; m++)\n{\n  double _imopVarPre412;\n  double _imopVarPre413;\n  _imopVarPre412 = (xcr[m] - xcrref[m]) / xcrref[m];\n  _imopVarPre413 = fabs(_imopVarPre412);\n  xcrdif[m] = _imopVarPre413;\n  double _imopVarPre415;\n  double _imopVarPre416;\n  _imopVarPre415 = (xce[m] - xceref[m]) / xceref[m];\n  _imopVarPre416 = fabs(_imopVarPre415);\n  xcedif[m] = _imopVarPre416;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/27"}
{"code": "for (i = 0; i < 64; i++)\n  j++;\n\n", "pragma": "omp parallel for linear(j:1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/_Atomic-2/1"}
{"code": "for (int i = 0; i < Size; i++)\n  printf(\"%7.4f \", pData[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hellennway/openMPbubbleSort/openMP/0"}
{"code": "for (next = 0; next < num_vertices; next++)\n{\n  new_dist = node_dist[curr_node] + graph[(curr_node * num_vertices) + next];\n  if (((visited_node[next] != 1) && (graph[(curr_node * num_vertices) + next] != ((data_t) 0))) && (new_dist < node_dist[next]))\n  {\n    node_dist[next] = new_dist;\n    parent_node[next] = curr_node;\n  }\n\n}\n\n", "pragma": "omp for private(new_dist,next)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/1"}
{"code": "for (int i = 1; i < argc; ++i)\n  this->tokens.push_back(string(argv[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexander-mipt/OpenMP/matrix/matrix/0"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    printf(\"%d\\t\", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/MatricesCREW/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  arr[i] = (double) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/npersson001/Parallel-Quick-Sort/quick_sort_parallel_final/8"}
{"code": "for (int i = 0; i < 65536; i++)\n{\n  if (hist_h[i] != hist_d[i])\n  {\n    max_diff = max(max_diff, abs(hist_h[i] - hist_d[i]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/spm-omp/main/7"}
{"code": "for (int j = 0; j < numParticles; j++)\n{\n  struct vec3 fN;\n  fN.x = 0, fN.y = 0, fN.z = 0;\n  for (int k = 0; k < numParticles; k++)\n  {\n    if (k == j)\n      continue;\n\n    float distSq = lenSquared(diff(posN[k], posN[j]));\n    struct vec3 dir = normalize(diff(posN[k], posN[j]));\n    struct vec3 force = constMul(dir, (M * M) / distSq);\n    fN = sum(fN, force);\n  }\n\n  struct vec3 vHalf = sum(velN[j], constMul(fN, delT / (2 * M)));\n  posN1[j] = sum(posN[j], constMul(vHalf, delT));\n  velNhalf[j] = vHalf;\n  velNhalf[j] = checkBounds(posN1[j], velNhalf[j], xSize, ySize, zSize, bodyRadius);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/10Kaiser10/n-body-simulation-openMP/src/simulation/0"}
{"code": "for (i = 0; i < X; i++)\n{\n  a[i] = (T) 0;\n}\n\n", "pragma": "    #pragma omp teams distribute parallel for simd safelen(4) aligned(a) linear(i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/teams_distribute_parallel_for_simd_codegen/0"}
{"code": "for (int k = 0; k < s.a.a; ++k)\n  ++s.a.a;\n\n", "pragma": "#pragma omp for private(a) private(this->a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_ast_print/1"}
{"code": "for (unsigned int i = 0; i < population_size; i++)\n{\n  double father = population[i];\n  double mother = population[get_random_int(population_size, rand)];\n  population.push_back((father + mother) / 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RenaLL-N/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  src[i] = permV[src[i]];\n  dest[i] = permV[dest[i]];\n  if ((i % size) == rank)\n    rank_m[rank] = (i / size) + 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rinriko/OpenMPI_SSCA2.2/genScalData/3"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"%.0lf \", v2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica2/src/pmv-OpenMP-a/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = omp_get_thread_num();\n  b[i] = a;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/Untitled Folder/diff/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  int row_sum = 0;\n  for (int j = 0; j < N; j++)\n  {\n    if (i != j)\n      row_sum += abs(A[i][j]);\n\n  }\n\n  if (abs(A[i][i]) <= row_sum)\n    flag = 0;\n\n}\n\n", "pragma": "omp for schedule(static, num_of_lines)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Coursal/OpenMP-Strictly-Diagonally-Dominant/sdd/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    DyDyu[IDX(i, 3, k)] = ((((2.0 * u[IDX(i, 3, k)]) - (5.0 * u[IDX(i, 4, k)])) + (4.0 * u[IDX(i, 5, k)])) - u[IDX(i, 6, k)]) * idy_sqrd;\n    DyDyu[IDX(i, 4, k)] = ((u[IDX(i, 3, k)] - (2.0 * u[IDX(i, 4, k)])) + u[IDX(i, 5, k)]) * idy_sqrd;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/18"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"|%lf|\\n\", Z[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rushitpandya/Gaussian-Elimination-Using-Pthread-and-OpenMP/gauss_openmp/1"}
{"code": "for (col = 0; col <= (public.in2_pad_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_pad_rows - 1); row += 1)\n  {\n    if ((((row > (public.in2_pad_add_rows - 1)) && (row < (public.in2_pad_add_rows + public.in2_rows))) && (col > (public.in2_pad_add_cols - 1))) && (col < (public.in2_pad_add_cols + public.in2_cols)))\n    {\n      ori_row = row - public.in2_pad_add_rows;\n      ori_col = col - public.in2_pad_add_cols;\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = private.d_in2[(ori_col * public.in2_rows) + ori_row];\n    }\n    else\n    {\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/14"}
{"code": "for (ix = 0; ix <= (nx - 1); ix++)\n{\n  for (iy = 0; iy <= (ny - 1); iy++)\n  {\n    *((u + (ix * y)) + iy) = (float) ((((ix * ((nx - ix) - 1)) * iy) * ((ny - iy) - 1)) + 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/spirosdelviniotis/parallel_programming/OpenMP/OpenMP_main/4"}
{"code": "for (int i = 0; i < 16; i++)\n  printf(\" %02X\", (unsigned char) L[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/clientcrush/2"}
{"code": "for (int i = 0; i < res2.size(); i++)\n{\n  good = (res2[i] == res1[i]) ? (good + 1) : (good);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savoptik/summation_of_matrix_rows_in_OpenMP/summation_of_matrix_rows_in_OpenMP/main/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  Y_parallel[i] = 0.0;\n  for (int j = 0; j < n; j++)\n  {\n    Y_parallel[i] += A[i][j] * X[j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture7/MatrixVectorMultiplication/MatrixVectorMultiplication/1"}
{"code": "for (i = 0; i < steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "\t#pragma omp parallel for private(x) reduction(+:sum) ", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/add19/Parallel-Programming/piIntegrate/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  d[i] = a[i] * b[i];\n}\n\n", "pragma": "      #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/compparalela/openmp/omp6/nowait/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"loop_0[%d]: %lu, loop_1[%d]: %lu\\n\", i, loop_0[i], i, loop_1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/parallel-region-with-multiple-loops/parallel-region-with-multiple-loops/5"}
{"code": "for (i = 0; i < n_size; i++)\n{\n  for (j = 0; j < n_size; j++)\n  {\n    for (r = 0; r < n_size; r++)\n    {\n      C[i][j] += A[i][r] * B[r][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leandrosfj/OpenMP_Matrix/C\u00f3digos/paralelo_matriz_omp1/1"}
{"code": "for (j = 0; j < 64; j++)\n  if ((unsigned int) ((ran >> j) & 1))\n  temp ^= m2[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Random/random/6"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < num_rows[i]; j++)\n  {\n    err = clEnqueueReadBuffer(command_queue[i][2], output[i][j], CL_TRUE, 0, DB_OUT_SIZE, (void *) (idx + ((cum_rows[i] + j) * DB_OUT_COUNT)), 1, kernel_event[i] + j, read_event[i] + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sum += roundAngle(ds[i]->getAngle());\n}\n\n", "pragma": "\t#pragma omp parallel for reduction (+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/zad6/DSEnsemble/1"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-i\") == 0)\n  {\n    maxiter = atoi(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-w\") == 0)\n  {\n    width = atoi(argv[++i]);\n    height = width;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    size = atof(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-o\") == 0)\n  {\n    if ((fp = fopen(\"mandel.out\", \"wb\")) == 0)\n    {\n      fprintf(stderr, \"Unable to open file\\n\");\n      return 1;\n    }\n\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    x0 = atof(argv[++i]);\n    y0 = atof(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-i maxiter -w windowsize -c x0 y0 -s size]\\n\", argv[0]);\n    fprintf(stderr, \"       -i to specify maximum number of iterations at each point (default 1000)\\n\");\n    fprintf(stderr, \"       -w to specify the size of the image to compute (default 800x800 elements)\\n\");\n    fprintf(stderr, \"       -c to specify the center x0+iy0 of the square to compute (default origin)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the square to compute (default 2, i.e. size 4 by 4)\\n\");\n    return 1;\n  }\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab3/mandel-omp/2"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  board->nextRound();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t3rmian/Life/life/7"}
{"code": "for (i = 0; i < thread_count; i++)\n{\n  execution_time_array[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chander2207/Dijkstra-openmp/omp_dijkstra/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  v = a[i];\n  printf(\"thread %d v=%d / \", omp_get_thread_num(), v);\n}\n\n", "pragma": "omp parallel for lastprivate(v)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/codigosBP2/lastprivate-clause/0"}
{"code": "for (j = 0; j < i; j++)\n  x[j] = x[j] - (U[j][i] * x[i]);\n\n", "pragma": "omp parallel for num_threads(thread) private(j) shared(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thesaurabhkumar/ParallelDenseMatrixOpenMP/Submission/matrix_par/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  u_new[i][0] = 0.5 * (u_new[i][1] + u_new[i][N - 2]);\n  u_new[0][i] = 0.5 * (u_new[1][i] + u_new[N - 2][i]);\n  u_new[N - 1][i] = u_new[0][i];\n  u_new[i][N - 1] = u_new[i][0];\n  v_new[i][0] = 0.5 * (v_new[i][1] + v_new[i][N - 2]);\n  v_new[0][i] = 0.5 * (v_new[1][i] + v_new[N - 2][i]);\n  v_new[N - 1][i] = v_new[0][i];\n  v_new[i][N - 1] = v_new[i][0];\n  p_new[i][0] = 0.5 * (p_new[i][1] + p_new[i][N - 2]);\n  p_new[0][i] = 0.5 * (p_new[1][i] + p_new[N - 2][i]);\n  p_new[N - 1][i] = p_new[0][i];\n  p_new[i][N - 1] = p_new[i][0];\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/Backward-Facing-Step/C++/src/main/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  int rank = EigenVals[i].second;\n  MatrixAssign(E + (rank * N), V_T + (i * N), 1, N);\n  SIGMA[i] = EigenVals[i].first;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/15"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  for (j = x_min - 1; j <= (x_max + 1); j++)\n  {\n    if (node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] < 0.0)\n    {\n      upwind = j + 2;\n      donor = j + 1;\n      downwind = j;\n      dif = donor;\n    }\n    else\n    {\n      upwind = j - 1;\n      donor = j;\n      downwind = j + 1;\n      dif = upwind;\n    }\n\n    sigma = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)];\n    width = celldx[FTNREF1D(j, x_min - 2)];\n    vdiffuw = vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(upwind, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffdw = vel1[FTNREF2D(downwind, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)];\n    limiter = 0.0;\n    if ((vdiffuw * vdiffdw) > 0.0)\n    {\n      auw = fabs(vdiffuw);\n      adw = fabs(vdiffdw);\n      wind = 1.0;\n      if (vdiffdw <= 0.0)\n        wind = -1.0;\n\n      limiter = wind * MIN((width * ((((2.0 - sigma) * adw) / width) + (((1.0 + sigma) * auw) / celldx[FTNREF1D(dif, x_min - 2)]))) / 6.0, MIN(auw, adw));\n    }\n\n    advec_vel_s = vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)] + ((1.0 - sigma) * limiter);\n    mom_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = advec_vel_s * node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(upwind,downwind,donor,dif,sigma,width,limiter,vdiffuw,vdiffdw,auw,adw,wind,j,advec_vel_s)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/7"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (init_num_threads_dev[i] > 1)\n  {\n    raiseWarningDevice += 1;\n  }\n\n  if (init_num_threads_host[i] > 1)\n  {\n    raiseWarningHost += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_if_no_modifier/4"}
{"code": "for (j = 1; j < (o.n - 1); ++j)\n  u[j] = 0.5 * ((u0[j - 1] + u0[j + 1]) + ((o.dx * o.dx) * rho[j]));\n\n", "pragma": "omp parallel for default(none) shared(u0,u,rho,o) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex8-poisson-openmp/2"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  BF_current.P[0] ^= BF_exp_key[index][0];\n  BF_current.P[1] ^= BF_exp_key[index][1];\n  BF_current.P[2] ^= BF_exp_key[index][2];\n  BF_current.P[3] ^= BF_exp_key[index][3];\n  BF_current.P[4] ^= BF_exp_key[index][4];\n  BF_current.P[5] ^= BF_exp_key[index][5];\n  BF_current.P[6] ^= BF_exp_key[index][6];\n  BF_current.P[7] ^= BF_exp_key[index][7];\n  BF_current.P[8] ^= BF_exp_key[index][8];\n  BF_current.P[9] ^= BF_exp_key[index][9];\n  BF_current.P[10] ^= BF_exp_key[index][10];\n  BF_current.P[11] ^= BF_exp_key[index][11];\n  BF_current.P[12] ^= BF_exp_key[index][12];\n  BF_current.P[13] ^= BF_exp_key[index][13];\n  BF_current.P[14] ^= BF_exp_key[index][14];\n  BF_current.P[15] ^= BF_exp_key[index][15];\n  BF_current.P[16] ^= BF_exp_key[index][16];\n  BF_current.P[17] ^= BF_exp_key[index][17];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/19"}
{"code": "for (i = 0; i < count; i++)\n  fscanf(fp, \"%f\", &series->data[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/8"}
{"code": "for (n = 0; n < NPOIs; n++)\n  fprintf(fp, \"   %s\", idPOI[n]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/19"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  printf(\"db[%ld]\\n\", i);\n  for (size_t j = 0; j < k; j++)\n  {\n    printf(\"%.2f|\", *((*(db + i)) + j));\n  }\n\n  printf(\"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/13"}
{"code": "for (int i = 3 * (10000 / 4); i < 10000; i++)\n{\n  task1(gl_taskData.intArrays[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p1/task/5"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  eval_multi_UBspline_3d_s_vgh(multi_spline, x, y, z, multi_vals, multi_grads, multi_hess);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/4"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  if (x[i] > maxvals[id])\n  {\n    maxvals[id] = x[i];\n    maxlocs[id] = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-3/parallel_not_critical/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  if (histogram[i] != 0)\n    printf(\"%d:     %d \\n\", i, histogram[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kerenrachev/CUDA_MPI_OpenMP_Histogram/histogram/9"}
{"code": "for (i = 1; i <= NODESX; i++)\n  TOPO[i][0] = TOPO[i][5];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/101"}
{"code": "for (int i = 0; i < n; i++)\n  perm[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manolismih/sparseMatPerm/parallel/3"}
{"code": "for (int i = 0; i < type_seqs.size(); ++i)\n{\n  rseqs[i] = type_seqs[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/14"}
{"code": "for (uint i = 0; i < keys.size(); ++i)\n{\n  uint key = (keys[i] >> startBit) & mask;\n  uint localOffset = histogramRadixFrequency[key]++;\n  uint globalOffset = exScanHisto[key] + localOffset;\n  keys_radix[globalOffset] = keys[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/8"}
{"code": "for (splatt_blas_int i = 0; i < N; ++i)\n{\n  for (splatt_blas_int j = 0; j < i; ++j)\n  {\n    neqs[j + (i * N)] = neqs[i + (j * N)];\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < graph->nodes[i]->degree; j++)\n  {\n    array[((n * i) + graph->nodes[i]->neighbours[j]->label) - 1] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z3y50n/ReverseCuthillMcKee/src/functions/6"}
{"code": "for (int i = 0; i < coord.size(); ++i)\n  convert(coord[i], coord_s[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/SandBox/einspline_io/2"}
{"code": "for (uint64_t j = 0; j < k; j++)\n{\n  bk = 0;\n  for (uint64_t l = n - j; l < n; l++)\n  {\n    bk += (buffer[l] >> NthB) & 1;\n  }\n\n  for (uint64_t l = 0; l < j; l++)\n  {\n    bk += (buffer[l] >> NthB) & 1;\n  }\n\n  mpfr_set_uj(K, j, MPFR_RNDN);\n  mpfr_set_uj(Rk, rk[j], MPFR_RNDN);\n  mpfr_set_uj(Bk, bk, MPFR_RNDN);\n  calc_corr(R, Rk, M, N, K, Bk, MPFR_RNDN);\n  if (j == 0)\n  {\n    mpfr_set(V, R, MPFR_RNDN);\n  }\n\n  mpfr_div(R, R, V, MPFR_RNDN);\n  r[j] = mpfr_get_d(R, MPFR_RNDN);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/12"}
{"code": "for (int x = 0; x < (boardSize / tileSize); x++)\n{\n  for (int y = 0; y < (boardSize / tileSize); y++)\n  {\n    done = checkBoard(x, y, boardSize, tileSize, colorDen);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qazwse/RedBlueOpenMP/orbs/2"}
{"code": "for (int i = 0; i < path_length; ++i)\n{\n  add_node(path[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marianhlavac/mi-pdp-jes/src/main/1"}
{"code": "for (i = 0; i < N; ++i)\n{\n  printf(\"c[%1$d] = %$2f, d[%1$d] = %3$f\\n\", i, c[i], d[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elyaishere/sk_high_performance_computing/openmp/ParSec/0"}
{"code": "for (int i = (n / 2) - 1; i >= 0; i--)\n  heapify(arr, n, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/taya92413/Algorithm-openmp/test/2"}
{"code": "for (i = 0; i < nparts; i++)\n{\n  w[i] = particles[i].w;\n  wsum += w[i];\n  wsumsq += w[i] * w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/fast-slam/simulator/5"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  if (count_ones[j])\n  S[i][j] = (B[i][j] * damp) / count_ones[j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/5"}
{"code": "for (i = 0; i < dim1; i++)\n{\n  result[i] = 0;\n  for (j = 0; j < dim2; j++)\n  {\n    result[i] += mat[i][j] * vec[i];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc1/matmul/0"}
{"code": "for (j = 0; j < N; j++)\n{\n  for (k = 0; k < (N - i); k++)\n  {\n    C[((j * N) + k) + i] = C2[(j * N) + k];\n  }\n\n}\n\n", "pragma": "omp parallel for private(k) shared (N,i,C2,C)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/9"}
{"code": "for (i = 4; i < 846; i++)\n{\n  largeIndex = indexOfLargestElement(buffer_values, 4);\n  largeValue = buffer_values[largeIndex];\n  if (v_scores[i] < largeValue)\n  {\n    buffer[largeIndex] = i;\n    buffer_values[largeIndex] = v_scores[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/36"}
{"code": "for (long long idx = 0; idx < M11; idx++)\n{\n  upper_tri[idx] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/11"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  a = 2;\n}\n\n", "pragma": "  #pragma omp parallel for ordered(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_ast_print/3"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  Queues[i].Links = malloc(sizeof(mst_link_t));\n  Queues[i].Length = 0;\n  Queues[i].size = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/19"}
{"code": "for (i = c + 1; i < 150; i++)\n{\n  e[1][i] = a1[2][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/4"}
{"code": "for (i = 0; i < 9; ++i)\n  for (j = 0; j < 9; ++j)\n{\n  cpyPz[i][j] = puzzle[i][inBlock[blocks[j / 3]][j % 3]];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blu-J/sudoku-openmp/sudoku/7"}
{"code": "for (i = 0; i < my_num_people; i++)\n{\n  if (my_states[i] != DEAD)\n  {\n    x_dir = (random() % 3) - 1;\n    y_dir = (random() % 3) - 1;\n    if (((((my_xs[i] + x_dir) >= 0) && ((my_xs[i] + x_dir) < env_width)) && ((my_ys[i] + y_dir) >= 0)) && ((my_ys[i] + y_dir) < env_height))\n    {\n      my_xs[i] += x_dir;\n      my_ys[i] += y_dir;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, x_dir, y_dir)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/4"}
{"code": "for (i = 0; i < 16; ++i)\n  for (int j = 0; j < 16; ++j)\n{\n  for (int k = 0; k < 16; ++k)\n    i += j;\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/simd_misc_messages/0"}
{"code": "for (int i = 0; i < data->bN; i++)\n{\n  free(board[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daudich/RBOpenMP/orbs/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  result += x[i * inc_x] * y[i * inc_y];\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/1"}
{"code": "for (i = 0; i < h; i++)\n{\n  for (j = 0; j < (w / 4); j++)\n  {\n    sa = a0 + (i * da);\n    sb = b0 + ((j * db) * 4);\n    a = _mm_setr_ps(sa, sa + da, sa + (2 * da), sa + (3 * da));\n    b = _mm_set1_ps(sb);\n    iter = mandelbrot_simd(a, b, max_iter);\n    M[i][j] = iter;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/201"}
{"code": "for (i = deb + 1; i <= fin; i++)\n{\n  if (T[i] < pivot)\n  {\n    compt++;\n    echanger(T, compt, i);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/qsort/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"thread id = %d and i = %d\\n\", omp_get_thread_num(), i);\n  if (a[i] < minimum)\n  {\n    minimum = a[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(min : minimum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/avg min max SD of  numbers/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (node_parent[i] != (-1))\n  {\n    node_level[i] = 1;\n    if (node_parent[i] != start_point)\n    {\n      next_level_list.push_back(node_parent[i]);\n    }\n\n  }\n  else\n  {\n    node_level[i] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/18"}
{"code": "for (i = 0; i < series->count; i++)\n{\n  sum += var[i];\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/3"}
{"code": "for (int cp = 0; cp < n; cp++)\n{\n  const unsigned p = plist[cp];\n  if (IdZone == CODE_GetIzoneFluidInout(code[p]))\n    velrhop[p].z = 0;\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule (static) if(n>OMP_LIMIT_COMPUTELIGHT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOutVel/1"}
{"code": "for (i_imopVar110 = 0; i_imopVar110 < grid_points[0]; i_imopVar110++)\n{\n  for (j_imopVar111 = 0; j_imopVar111 < grid_points[1]; j_imopVar111++)\n  {\n    for (k_imopVar112 = 0; k_imopVar112 < grid_points[2]; k_imopVar112++)\n    {\n      for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n      {\n        rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = forcing[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/8"}
{"code": "for (i = 0; i < nlines; i++)\n{\n  tdat[i] = indat[(colno * nlines) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/14"}
{"code": "for (int i = k + 1; i < MATRIX_SIZE; i++)\n{\n  double operand1 = (*lower[i])[k];\n  for (int j = k + 1; j < MATRIX_SIZE; j++)\n    (*mat[i])[j] -= operand1 * temp_sub_vector_upper_kth_row[j - (k + 1)];\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivamshuklama/Parallelization-of-LU-DECOMPOSITION/luopenmp/luopenmp/6"}
{"code": "for (j = 0x7fffffff; j > (0x7fffffff - 1); j--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr43893/6"}
{"code": "for (int iBox = 0; iBox < s->boxes->nLocalBoxes; iBox++)\n{\n  int nIBox = s->boxes->nAtoms[iBox];\n  for (int jTmp = 0; jTmp < nNbrBoxes; jTmp++)\n  {\n    int jBox = s->boxes->nbrBoxes[iBox][jTmp];\n    assert(jBox >= 0);\n    int nJBox = s->boxes->nAtoms[jBox];\n    for (int iOff = MAXATOMS * iBox; iOff < ((iBox * MAXATOMS) + nIBox); iOff++)\n    {\n      for (int jOff = jBox * MAXATOMS; jOff < ((jBox * MAXATOMS) + nJBox); jOff++)\n      {\n        real3 dr;\n        real_t r2 = 0.0;\n        for (int m = 0; m < 3; m++)\n        {\n          dr[m] = s->atoms->r[iOff][m] - s->atoms->r[jOff][m];\n          r2 += dr[m] * dr[m];\n        }\n\n        if ((r2 <= rCut2) && (r2 > 0.0))\n        {\n          r2 = 1.0 / r2;\n          real_t r6 = s6 * ((r2 * r2) * r2);\n          real_t eLocal = (r6 * (r6 - 1.0)) - eShift;\n          s->atoms->U[iOff] += 0.5 * eLocal;\n          ePot += 0.5 * eLocal;\n          real_t fr = ((((-4.0) * epsilon) * r6) * r2) * ((12.0 * r6) - 6.0);\n          for (int m = 0; m < 3; m++)\n          {\n            s->atoms->f[iOff][m] -= dr[m] * fr;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:ePot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/ljForce/1"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  approx += f(i);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: approx) schedule(auto)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/10_omp_sin_sum/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  for (j = 0; j < nxhs; j += 2)\n  {\n    v_at1 = _mm512_mask_loadunpacklo_ps(v_zero, _mm512_int2mask(15), (float *) (&ffc[j + kk]));\n    v_at1 = _mm512_mask_loadunpackhi_ps(v_at1, _mm512_int2mask(15), (float *) (&ffc[(j + kk) + 8]));\n    v_at1 = _mm512_permute4f128_ps(v_at1, 0);\n    v_at1 = (int) _mm512_mask_shuffle_epi32((int) v_at1, _mm512_int2mask(13260), (int) v_at1, 78);\n    v_at1 = (int) _mm512_mask_shuffle_epi32((int) v_at1, _mm512_int2mask(21845), (int) v_at1, 177);\n    v_zt1 = _mm512_load_ps((float *) (&exyz[4 * (j + kj)]));\n    v_zt2 = _mm512_mul_ps(v_zt1, v_at1);\n    _mm512_store_ps((float *) (&fxyz[4 * (j + kj)]), v_zt2);\n    v_zt1 = _mm512_load_ps((float *) (&exyz[4 * (j + k1)]));\n    v_zt2 = _mm512_mul_ps(v_zt1, v_at1);\n    _mm512_store_ps((float *) (&fxyz[4 * (j + k1)]), v_zt2);\n    v_zt1 = _mm512_load_ps((float *) (&exyz[4 * ((j + kj) + l1)]));\n    v_zt2 = _mm512_mul_ps(v_zt1, v_at1);\n    _mm512_store_ps((float *) (&fxyz[4 * ((j + kj) + l1)]), v_zt2);\n    v_zt1 = _mm512_load_ps((float *) (&exyz[4 * ((j + k1) + l1)]));\n    v_zt2 = _mm512_mul_ps(v_zt1, v_at1);\n    _mm512_store_ps((float *) (&fxyz[4 * ((j + k1) + l1)]), v_zt2);\n  }\n\n  for (j = itn; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    fxyz[4 * (j + kj)] = exyz[4 * (j + kj)] * at1;\n    fxyz[1 + (4 * (j + kj))] = exyz[1 + (4 * (j + kj))] * at1;\n    fxyz[2 + (4 * (j + kj))] = exyz[2 + (4 * (j + kj))] * at1;\n    fxyz[4 * (j + k1)] = exyz[4 * (j + k1)] * at1;\n    fxyz[1 + (4 * (j + k1))] = exyz[1 + (4 * (j + k1))] * at1;\n    fxyz[2 + (4 * (j + k1))] = exyz[2 + (4 * (j + k1))] * at1;\n    fxyz[4 * ((j + kj) + l1)] = exyz[4 * ((j + kj) + l1)] * at1;\n    fxyz[1 + (4 * ((j + kj) + l1))] = exyz[1 + (4 * ((j + kj) + l1))] * at1;\n    fxyz[2 + (4 * ((j + kj) + l1))] = exyz[2 + (4 * ((j + kj) + l1))] * at1;\n    fxyz[4 * ((j + k1) + l1)] = exyz[4 * ((j + k1) + l1)] * at1;\n    fxyz[1 + (4 * ((j + k1) + l1))] = exyz[1 + (4 * ((j + k1) + l1))] * at1;\n    fxyz[2 + (4 * ((j + k1) + l1))] = exyz[2 + (4 * ((j + k1) + l1))] * at1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,at1,v_at1,v_zt1,v_zt2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/26"}
{"code": "for (i = 0; i < nclusters; i++)\n{\n  for (j = 0; j < nchannels; j++)\n  {\n    c[i][j] = (counts[i]) ? (c1[i][j] / counts[i]) : (c1[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kyeongan/k-means-function/omp/2"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    if (dom[i][j][k] == 0)\n    {\n      velocity_x += rho[i][j][k] * vx[i][j][k];\n      velocity_y += rho[i][j][k] * vy[i][j][k];\n      velocity_z += rho[i][j][k] * vz[i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/data_explorer/0"}
{"code": "for (int i = 0; i <= 3; i++)\n{\n  res[i + 6] = 0;\n  res[i + 30] = 0;\n  res[i + 46] = 0;\n  res[i + 50] = 0;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tastypeanut/uc3m-ca-openmp/img-par/0"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < columns; ++j)\n  {\n    (oss << \"\\t\") << m[(i * columns) + j];\n  }\n\n  oss << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/contrerasmiguel/matrix-multiplication/openmp/main/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    if (betax[IDX(ie - 3, j, k)] < 0.0)\n    {\n      Dxu[IDX(ie - 3, j, k)] = ((((-3.0) * u[IDX(ie - 3, j, k)]) + (4.0 * u[IDX(ie - 2, j, k)])) - u[IDX(ie - 1, j, k)]) * idx_by_2;\n    }\n    else\n    {\n      Dxu[IDX(ie - 3, j, k)] = (((((-u[IDX(ie - 6, j, k)]) + (6.0 * u[IDX(ie - 5, j, k)])) - (18.0 * u[IDX(ie - 4, j, k)])) + (10.0 * u[IDX(ie - 3, j, k)])) + (3.0 * u[IDX(ie - 2, j, k)])) * idx_by_12;\n    }\n\n    if (betax[IDX(ie - 2, j, k)] > 0.0)\n    {\n      Dxu[IDX(ie - 2, j, k)] = ((-u[IDX(ie - 3, j, k)]) + u[IDX(ie - 1, j, k)]) * idx_by_2;\n    }\n    else\n    {\n      Dxu[IDX(ie - 2, j, k)] = ((u[IDX(ie - 4, j, k)] - (4.0 * u[IDX(ie - 3, j, k)])) + (3.0 * u[IDX(ie - 2, j, k)])) * idx_by_2;\n    }\n\n    Dxu[IDX(ie - 1, j, k)] = ((u[IDX(ie - 3, j, k)] - (4.0 * u[IDX(ie - 2, j, k)])) + (3.0 * u[IDX(ie - 1, j, k)])) * idx_by_2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/27"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    printf(\"%f\\t\", C[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/4"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      tmp1 = dt * ty1;\n      tmp2 = dt * ty2;\n      lhs[i][j][k][0][0][0] = (((-tmp2) * fjac[i][j - 1][k][0][0]) - (tmp1 * njac[i][j - 1][k][0][0])) - (tmp1 * dy1);\n      lhs[i][j][k][0][0][1] = ((-tmp2) * fjac[i][j - 1][k][0][1]) - (tmp1 * njac[i][j - 1][k][0][1]);\n      lhs[i][j][k][0][0][2] = ((-tmp2) * fjac[i][j - 1][k][0][2]) - (tmp1 * njac[i][j - 1][k][0][2]);\n      lhs[i][j][k][0][0][3] = ((-tmp2) * fjac[i][j - 1][k][0][3]) - (tmp1 * njac[i][j - 1][k][0][3]);\n      lhs[i][j][k][0][0][4] = ((-tmp2) * fjac[i][j - 1][k][0][4]) - (tmp1 * njac[i][j - 1][k][0][4]);\n      lhs[i][j][k][0][1][0] = ((-tmp2) * fjac[i][j - 1][k][1][0]) - (tmp1 * njac[i][j - 1][k][1][0]);\n      lhs[i][j][k][0][1][1] = (((-tmp2) * fjac[i][j - 1][k][1][1]) - (tmp1 * njac[i][j - 1][k][1][1])) - (tmp1 * dy2);\n      lhs[i][j][k][0][1][2] = ((-tmp2) * fjac[i][j - 1][k][1][2]) - (tmp1 * njac[i][j - 1][k][1][2]);\n      lhs[i][j][k][0][1][3] = ((-tmp2) * fjac[i][j - 1][k][1][3]) - (tmp1 * njac[i][j - 1][k][1][3]);\n      lhs[i][j][k][0][1][4] = ((-tmp2) * fjac[i][j - 1][k][1][4]) - (tmp1 * njac[i][j - 1][k][1][4]);\n      lhs[i][j][k][0][2][0] = ((-tmp2) * fjac[i][j - 1][k][2][0]) - (tmp1 * njac[i][j - 1][k][2][0]);\n      lhs[i][j][k][0][2][1] = ((-tmp2) * fjac[i][j - 1][k][2][1]) - (tmp1 * njac[i][j - 1][k][2][1]);\n      lhs[i][j][k][0][2][2] = (((-tmp2) * fjac[i][j - 1][k][2][2]) - (tmp1 * njac[i][j - 1][k][2][2])) - (tmp1 * dy3);\n      lhs[i][j][k][0][2][3] = ((-tmp2) * fjac[i][j - 1][k][2][3]) - (tmp1 * njac[i][j - 1][k][2][3]);\n      lhs[i][j][k][0][2][4] = ((-tmp2) * fjac[i][j - 1][k][2][4]) - (tmp1 * njac[i][j - 1][k][2][4]);\n      lhs[i][j][k][0][3][0] = ((-tmp2) * fjac[i][j - 1][k][3][0]) - (tmp1 * njac[i][j - 1][k][3][0]);\n      lhs[i][j][k][0][3][1] = ((-tmp2) * fjac[i][j - 1][k][3][1]) - (tmp1 * njac[i][j - 1][k][3][1]);\n      lhs[i][j][k][0][3][2] = ((-tmp2) * fjac[i][j - 1][k][3][2]) - (tmp1 * njac[i][j - 1][k][3][2]);\n      lhs[i][j][k][0][3][3] = (((-tmp2) * fjac[i][j - 1][k][3][3]) - (tmp1 * njac[i][j - 1][k][3][3])) - (tmp1 * dy4);\n      lhs[i][j][k][0][3][4] = ((-tmp2) * fjac[i][j - 1][k][3][4]) - (tmp1 * njac[i][j - 1][k][3][4]);\n      lhs[i][j][k][0][4][0] = ((-tmp2) * fjac[i][j - 1][k][4][0]) - (tmp1 * njac[i][j - 1][k][4][0]);\n      lhs[i][j][k][0][4][1] = ((-tmp2) * fjac[i][j - 1][k][4][1]) - (tmp1 * njac[i][j - 1][k][4][1]);\n      lhs[i][j][k][0][4][2] = ((-tmp2) * fjac[i][j - 1][k][4][2]) - (tmp1 * njac[i][j - 1][k][4][2]);\n      lhs[i][j][k][0][4][3] = ((-tmp2) * fjac[i][j - 1][k][4][3]) - (tmp1 * njac[i][j - 1][k][4][3]);\n      lhs[i][j][k][0][4][4] = (((-tmp2) * fjac[i][j - 1][k][4][4]) - (tmp1 * njac[i][j - 1][k][4][4])) - (tmp1 * dy5);\n      lhs[i][j][k][1][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dy1);\n      lhs[i][j][k][1][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n      lhs[i][j][k][1][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n      lhs[i][j][k][1][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n      lhs[i][j][k][1][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n      lhs[i][j][k][1][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n      lhs[i][j][k][1][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dy2);\n      lhs[i][j][k][1][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n      lhs[i][j][k][1][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n      lhs[i][j][k][1][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n      lhs[i][j][k][1][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n      lhs[i][j][k][1][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n      lhs[i][j][k][1][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dy3);\n      lhs[i][j][k][1][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n      lhs[i][j][k][1][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n      lhs[i][j][k][1][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n      lhs[i][j][k][1][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n      lhs[i][j][k][1][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n      lhs[i][j][k][1][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dy4);\n      lhs[i][j][k][1][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n      lhs[i][j][k][1][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n      lhs[i][j][k][1][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n      lhs[i][j][k][1][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n      lhs[i][j][k][1][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n      lhs[i][j][k][1][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dy5);\n      lhs[i][j][k][2][0][0] = ((tmp2 * fjac[i][j + 1][k][0][0]) - (tmp1 * njac[i][j + 1][k][0][0])) - (tmp1 * dy1);\n      lhs[i][j][k][2][0][1] = (tmp2 * fjac[i][j + 1][k][0][1]) - (tmp1 * njac[i][j + 1][k][0][1]);\n      lhs[i][j][k][2][0][2] = (tmp2 * fjac[i][j + 1][k][0][2]) - (tmp1 * njac[i][j + 1][k][0][2]);\n      lhs[i][j][k][2][0][3] = (tmp2 * fjac[i][j + 1][k][0][3]) - (tmp1 * njac[i][j + 1][k][0][3]);\n      lhs[i][j][k][2][0][4] = (tmp2 * fjac[i][j + 1][k][0][4]) - (tmp1 * njac[i][j + 1][k][0][4]);\n      lhs[i][j][k][2][1][0] = (tmp2 * fjac[i][j + 1][k][1][0]) - (tmp1 * njac[i][j + 1][k][1][0]);\n      lhs[i][j][k][2][1][1] = ((tmp2 * fjac[i][j + 1][k][1][1]) - (tmp1 * njac[i][j + 1][k][1][1])) - (tmp1 * dy2);\n      lhs[i][j][k][2][1][2] = (tmp2 * fjac[i][j + 1][k][1][2]) - (tmp1 * njac[i][j + 1][k][1][2]);\n      lhs[i][j][k][2][1][3] = (tmp2 * fjac[i][j + 1][k][1][3]) - (tmp1 * njac[i][j + 1][k][1][3]);\n      lhs[i][j][k][2][1][4] = (tmp2 * fjac[i][j + 1][k][1][4]) - (tmp1 * njac[i][j + 1][k][1][4]);\n      lhs[i][j][k][2][2][0] = (tmp2 * fjac[i][j + 1][k][2][0]) - (tmp1 * njac[i][j + 1][k][2][0]);\n      lhs[i][j][k][2][2][1] = (tmp2 * fjac[i][j + 1][k][2][1]) - (tmp1 * njac[i][j + 1][k][2][1]);\n      lhs[i][j][k][2][2][2] = ((tmp2 * fjac[i][j + 1][k][2][2]) - (tmp1 * njac[i][j + 1][k][2][2])) - (tmp1 * dy3);\n      lhs[i][j][k][2][2][3] = (tmp2 * fjac[i][j + 1][k][2][3]) - (tmp1 * njac[i][j + 1][k][2][3]);\n      lhs[i][j][k][2][2][4] = (tmp2 * fjac[i][j + 1][k][2][4]) - (tmp1 * njac[i][j + 1][k][2][4]);\n      lhs[i][j][k][2][3][0] = (tmp2 * fjac[i][j + 1][k][3][0]) - (tmp1 * njac[i][j + 1][k][3][0]);\n      lhs[i][j][k][2][3][1] = (tmp2 * fjac[i][j + 1][k][3][1]) - (tmp1 * njac[i][j + 1][k][3][1]);\n      lhs[i][j][k][2][3][2] = (tmp2 * fjac[i][j + 1][k][3][2]) - (tmp1 * njac[i][j + 1][k][3][2]);\n      lhs[i][j][k][2][3][3] = ((tmp2 * fjac[i][j + 1][k][3][3]) - (tmp1 * njac[i][j + 1][k][3][3])) - (tmp1 * dy4);\n      lhs[i][j][k][2][3][4] = (tmp2 * fjac[i][j + 1][k][3][4]) - (tmp1 * njac[i][j + 1][k][3][4]);\n      lhs[i][j][k][2][4][0] = (tmp2 * fjac[i][j + 1][k][4][0]) - (tmp1 * njac[i][j + 1][k][4][0]);\n      lhs[i][j][k][2][4][1] = (tmp2 * fjac[i][j + 1][k][4][1]) - (tmp1 * njac[i][j + 1][k][4][1]);\n      lhs[i][j][k][2][4][2] = (tmp2 * fjac[i][j + 1][k][4][2]) - (tmp1 * njac[i][j + 1][k][4][2]);\n      lhs[i][j][k][2][4][3] = (tmp2 * fjac[i][j + 1][k][4][3]) - (tmp1 * njac[i][j + 1][k][4][3]);\n      lhs[i][j][k][2][4][4] = ((tmp2 * fjac[i][j + 1][k][4][4]) - (tmp1 * njac[i][j + 1][k][4][4])) - (tmp1 * dy5);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k,tmp1,tmp2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/3"}
{"code": "for (nncols = 0, i = 0; i < ncols; i++)\n{\n  if (clens[i].key > 0)\n    colmap[clens[i].val] = nncols++;\n  else\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/26"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    transpose2[i][j] = matrix2[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Joseph-18-analyst/Large_Matrix_Multiplication_OpenMP/Efficient_matrix_Multiplication/2"}
{"code": "for (i = 0; i < 10; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-10/0"}
{"code": "for (t = 0; t < n; t += 3)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    int i;\n    memcpy(BF_current[index].S, BF_init_state.S, sizeof(BF_current[index].S));\n    memcpy(BF_current[index].P, BF_init_key[index], sizeof(BF_current[index].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_current[index].P[i] = L0;\n      BF_current[index].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[index].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[index].S[3][0xFF]));\n  }\n\n  count = 1 << salt->rounds;\n  do\n  {\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current[index].P[0] ^= BF_exp_key[index][0];\n      BF_current[index].P[1] ^= BF_exp_key[index][1];\n      BF_current[index].P[2] ^= BF_exp_key[index][2];\n      BF_current[index].P[3] ^= BF_exp_key[index][3];\n      BF_current[index].P[4] ^= BF_exp_key[index][4];\n      BF_current[index].P[5] ^= BF_exp_key[index][5];\n      BF_current[index].P[6] ^= BF_exp_key[index][6];\n      BF_current[index].P[7] ^= BF_exp_key[index][7];\n      BF_current[index].P[8] ^= BF_exp_key[index][8];\n      BF_current[index].P[9] ^= BF_exp_key[index][9];\n      BF_current[index].P[10] ^= BF_exp_key[index][10];\n      BF_current[index].P[11] ^= BF_exp_key[index][11];\n      BF_current[index].P[12] ^= BF_exp_key[index][12];\n      BF_current[index].P[13] ^= BF_exp_key[index][13];\n      BF_current[index].P[14] ^= BF_exp_key[index][14];\n      BF_current[index].P[15] ^= BF_exp_key[index][15];\n      BF_current[index].P[16] ^= BF_exp_key[index][16];\n      BF_current[index].P[17] ^= BF_exp_key[index][17];\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current[index].P[0] ^= u1;\n      BF_current[index].P[1] ^= u2;\n      BF_current[index].P[2] ^= u3;\n      BF_current[index].P[3] ^= u4;\n      BF_current[index].P[4] ^= u1;\n      BF_current[index].P[5] ^= u2;\n      BF_current[index].P[6] ^= u3;\n      BF_current[index].P[7] ^= u4;\n      BF_current[index].P[8] ^= u1;\n      BF_current[index].P[9] ^= u2;\n      BF_current[index].P[10] ^= u3;\n      BF_current[index].P[11] ^= u4;\n      BF_current[index].P[12] ^= u1;\n      BF_current[index].P[13] ^= u2;\n      BF_current[index].P[14] ^= u3;\n      BF_current[index].P[15] ^= u4;\n      BF_current[index].P[16] ^= u1;\n      BF_current[index].P[17] ^= u2;\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[index].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/29"}
{"code": "for (int i = 1, j = size - 2; i < size; i++, j--)\n{\n  partial_result1[i] = (partial_result1[i] > partial_result1[i - 1]) ? (partial_result1[i]) : (partial_result1[i - 1]);\n  partial_result2[j] = (partial_result2[j] > partial_result2[j + 1]) ? (partial_result2[j]) : (partial_result2[j + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/4"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%d\\n\", m_pParticleData->m_vLPFOrderLeft[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/47"}
{"code": "for (i = 0; i < MatrixDim; i++)\n{\n  for (j = 0; j < MatrixDim; j++)\n    fprintf(fa, \"%f \", A[i][j]);\n\n  fprintf(fa, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_lud/tools/gen_input/5"}
{"code": "for (int i = 1; i < (m + 1); i++)\n{\n  for (int j = 1; j < (n + 1); j++)\n  {\n    if (A[i - 1] == B[j - 1])\n    {\n      DP[j] = prev_row[j - 1] + 1;\n    }\n    else\n    {\n      DP[j] = (prev_row[j] > DP[j - 1]) ? (prev_row[j]) : (DP[j - 1]);\n    }\n\n  }\n\n  for (int j = 0; j < (n + 1); j++)\n  {\n    prev_row[j] = DP[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Tool/find_lcs/1"}
{"code": "formula.append((\"- \" + number((-1) * gg)) + \"x \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/101"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    printf(\"%f \", ELEM(A, an, i, j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/non-automated/strassen/strassen/0"}
{"code": "for (i = 0; i < block_height; i++)\n{\n  p(i, block_width - 1) = phi(x(i, start_i), y(block_width - 1, start_j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/17"}
{"code": "for (int i = 0; i < intervalNum; ++i)\n{\n  double x = h * i;\n  area += sin(x + ((x * x) * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Koshman-Nikita/OpenMPI/OpenMPI/0"}
{"code": "for (int i = 2; i < N; i++)\n{\n  if (list[i] != (-1))\n  {\n    fprintf(fp, \"%d\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibrahim65432/GeneratingPrimeNumbers_using_OpenMP/genprimes/1"}
{"code": "for (i = 0; i <= lenA; ++i)\n{\n  for (j = 0; j <= lenB; ++j)\n  {\n    if (SWArray[i][j] > HiScore)\n    {\n      HiScore = SWArray[i][j];\n      HiScorePos[0] = i;\n      HiScorePos[1] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/10"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    if (grid[i][j] == 1)\n    {\n      num_cells = num_cells + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) reduction(+: num_cells) num_threads(MAX_THREADS)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patricia-souza/JogoVidaOpenMP/Reduction/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j <= i; j++)\n  {\n    lower[j][i] = 0.0f;\n    lower[i][j] = a[i][j];\n    upper[i][j] = 0.0f;\n    upper[j][i] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/5"}
{"code": "for (int k = 0; k < ndr; k++)\n  b(0, k) = beta_hat(k + 1, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_local_solver/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  t[i] = 0;\n  R[i] = ((double) 1) / N;\n  last_R[i] = ((double) 1) / N;\n  v[i][0] = rand() % 50;\n  last_v[i][0] = 10;\n  for (j = 0; j < N; j++)\n  {\n    E[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/5"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Send(set_of_points + offset, chunk_size, *Point_MPI_type, i, 0, MPI_COMM_WORLD);\n  offset += chunk_size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/2"}
{"code": "for (int i = 0; i < numTests; ++i)\n{\n  test[i] = (double *) malloc(((sizeof(double)) * numInputs) + 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/1"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      for (n = 0; n <= 4; n += 1)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/138"}
{"code": "for (j = RADIUS; j < (n - RADIUS); j++)\n  for (i = RADIUS; i < (n - RADIUS); i++)\n{\n  norm += (double) ABS(out[i + (j * n)]);\n}\n\n\n", "pragma": "omp for reduction(+:norm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Stencil/stencil/8"}
{"code": "for (size_t i = 0; i < 20; i++)\n  assert(array[i] == (4 * i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_02/4"}
{"code": "for (i = ist; i <= iend; i += 1)\n{\n  for (j = jst; j <= jend; j += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      v[i][j][k][m] = v[i][j][k][m] - (omega * (((((ldz[i][j][m][0] * v[i][j][k - 1][0]) + (ldz[i][j][m][1] * v[i][j][k - 1][1])) + (ldz[i][j][m][2] * v[i][j][k - 1][2])) + (ldz[i][j][m][3] * v[i][j][k - 1][3])) + (ldz[i][j][m][4] * v[i][j][k - 1][4])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/0"}
{"code": "for (; it != moves_list.end(); ++it)\n  if ((*it) != chosen_move)\n  delete * it;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sphurti/Laserchess/trees/AlphaBetaParallel/1"}
{"code": "for (int i = 0; i < F->Size; i++)\n{\n  int TemporalRank = (i % (NThreads - 1)) + 1;\n  MPI_Send(&FLAG, 1, (MPI_Datatype) 0x4c000405, TemporalRank, TAG_FLAG, (MPI_Comm) 0x44000000);\n  MPI_Send(&i, 1, (MPI_Datatype) 0x4c000405, TemporalRank, TAG_INDEX_VARIABLE, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joelchaconcastillo/SolverMontecarlo_MAO/SolverSistemaEcuacionesOpenMPI/MonteCarlo/1"}
{"code": "for (position = pos_ori; position <= ((pos_ori + public.in2_pad_rows) - 1); position = position + 1)\n{\n  private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n  sum = private.d_in2_pad[position];\n}\n\n", "pragma": "omp parallel for private (position) firstprivate (pos_ori)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/5"}
{"code": "for (i = 0; i <= (fftblock - 1); i += 1)\n{\n  y0[j][i].real = x[k][j][i + ii].real;\n  y0[j][i].imag = x[k][j][i + ii].imag;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/10"}
{"code": "for (j = jst; j <= L2; j += 1)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21j = tmp * rsd[i][j][k][1];\n  u31j = tmp * rsd[i][j][k][2];\n  u41j = tmp * rsd[i][j][k][3];\n  u51j = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i][j - 1][k][0];\n  u21jm1 = tmp * rsd[i][j - 1][k][1];\n  u31jm1 = tmp * rsd[i][j - 1][k][2];\n  u41jm1 = tmp * rsd[i][j - 1][k][3];\n  u51jm1 = tmp * rsd[i][j - 1][k][4];\n  flux[i][j][k][1] = ty3 * (u21j - u21jm1);\n  flux[i][j][k][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n  flux[i][j][k][3] = ty3 * (u41j - u41jm1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((1.40e+00 * 1.40e+00) * ty3) * (u51j - u51jm1));\n}\n\n", "pragma": "omp parallel for private (u21jm1,u31jm1,u41jm1,u51jm1,tmp,u21j,u31j,u41j,u51j,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/37"}
{"code": "for (j = 0; j < stream_size; j++)\n{\n  a[j] = 0.0;\n  b[j] = 2.0;\n  c[j] = 2.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Refcount/refcount/1"}
{"code": "for (int l = 0; l < p; l++)\n{\n  int pos = (l == 0) ? (data_chunk * l) : ((data_chunk * l) + mod_part);\n  int size = (l == 0) ? (data_chunk + mod_part) : (data_chunk);\n  disps[l] = pos;\n  recvcounts[l] = size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/ass3_6/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  A[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMPsearchCLV/1"}
{"code": "for (i = 0; i < 800; i++)\n{\n  free(b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/9"}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/18"}
{"code": "for (i = 0; i < NI;)\n{\n  for (j = 0; j < NK;)\n  {\n    A[i][j] = (((double) i) * j) / NI;\n    j++;\n  }\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdruix/OMP2MPI/trans/test/11"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpkhictzxy.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MJChku/openmp_source/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (int i = 0; i < count; i++)\n{\n  Position collision_vector;\n  collision_vector.x = all_pos[collide[i]].x - p->x;\n  collision_vector.y = all_pos[collide[i]].y - p->y;\n  collision_vector.z = all_pos[collide[i]].z - p->z;\n  normalize(&collision_vector);\n  double dotV1 = dot(nv, &collision_vector);\n  double dotV2 = dot(&all_velo[collide[i]], &collision_vector);\n  change(nv, dotV1, dotV2, &collision_vector);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/9"}
{"code": "for (vj = nvtxs - 1; vj >= (nvtxs - maxhmsize); vj--)\n{\n  if (((xadj[vj + 1] - uxadj[vj]) == 1) || (xadj[vj] == uxadj[vj]))\n    continue;\n\n  nlocal = 0;\n  if ((xadj[vj + 1] - uxadj[vj]) == (nvtxs - vj))\n  {\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (ei = uxadj[vi]; adjncy[ei] > vj; ei++)\n        ;\n\n      nlocal += ei - uxadj[vi];\n      nprobes += ei - uxadj[vi];\n    }\n\n  }\n  else\n  {\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 1;\n\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (ei = uxadj[vi]; adjncy[ei] > vj; ei++)\n        nlocal += hmap[adjncy[ei]];\n\n      nprobes += ei - uxadj[vi];\n    }\n\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 0;\n\n  }\n\n  if (nlocal > 0)\n    ntriangles += nlocal;\n\n}\n\n", "pragma": "omp for schedule(dynamic,DBSIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/4"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  if (result_local[i].count != 0)\n  {\n    memcpy(&result.elements[result.count], result_local[i].elements, result_local[i].count * (sizeof(struct ELEMENT)));\n    result.count += result_local[i].count;\n  }\n\n  free(result_local[i].elements);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/11"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (thread_num[i] != (i % MAX_THREADS_PER_TEAM))\n    recordError(&errors, \"THREAD NUMBER\", i, thread_num, 0);\n\n  if ((i % MAX_THREADS_PER_TEAM) == 0)\n  {\n    correctTeamNum++;\n    correctTeamNum = correctTeamNum % MAX_TEAMS;\n  }\n\n  if (team_num[i] != correctTeamNum)\n    recordError(&errors, \"TEAM NUMBER\", i, team_num, 0);\n\n  if (default_dev[i] != (-1))\n    recordError(&errors, \"DEVICE NUMBER\", i, default_dev, 0);\n\n  if ((i % WARP_SIZE) == 0)\n  {\n    correctWarpId++;\n    correctWarpId = correctWarpId % (MAX_THREADS_PER_TEAM / WARP_SIZE);\n  }\n\n  if (warp_id[i] != correctWarpId)\n    recordError(&errors, \"WARP NUMBER\", i, warp_id, 0);\n\n  if (lane_id[i] != (i % WARP_SIZE))\n    recordError(&errors, \"LANE NUMBER\", i, lane_id, 0);\n\n  if (master_thread_id[i] != 0)\n    recordError(&errors, \"MASTER THREAD NUMBER\", i, master_thread_id, 0);\n\n  if (is_spmd_mode[i] != SPMD)\n    recordError(&errors, \"SPMD NUMBER\", i, is_spmd_mode, 0);\n\n  if (num_threads[i] > MAX_THREADS_PER_TEAM)\n    recordError(&errors, \"NUM THREADS\", i, num_threads, 0);\n\n  if ((N % MAX_THREADS_PER_TEAM) != 0)\n    correctNumTeams = (N + num_threads[i]) / num_threads[i];\n  else\n    correctNumTeams = N / MAX_THREADS_PER_TEAM;\n\n  if (num_teams[i] != correctNumTeams)\n    recordError(&errors, \"NUM TEAMS\", i, num_teams, 0);\n\n  remainder = 0;\n  mask = 0;\n  if (N < (WARP_SIZE + 1))\n  {\n    remainder = N % WARP_SIZE;\n  }\n  else\n    remainder = (N % MAX_THREADS_PER_TEAM) % WARP_SIZE;\n\n  if (i < (N - remainder))\n  {\n    if (WARP_SIZE == 64)\n      mask = 0xffffffffffffffff;\n    else\n      mask = 0xffffffff;\n\n  }\n  else\n  {\n    mask = 0;\n    for (int j = 0; j < remainder; j++)\n    {\n      mask = mask << 1;\n      mask = mask + 1;\n    }\n\n  }\n\n  if (active_mask[i] != mask)\n  {\n    recordError(&errors, \"ACTIVE MASK\", i, 0, active_mask);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/aomp_mappings_newrt/aomp_mappings_newrt/3"}
{"code": "for (c2 = (((nj > nk) ? (nj) : (nk)) > nl) ? ((nj > nk) ? (nj) : (nk)) : (nl); c2 <= (nm + (-1)); c2++)\n{\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/14"}
{"code": "for (uint16_t i = 0; i < h; i++)\n{\n  for (uint16_t j = 0; j < w; j++)\n  {\n    (((((output << ((((uint16_t) image[i][j]) + 1) * 4)) << ' ') << 0) << ' ') << 0) << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SantonioTheFirst/MandelbrotSetCPP/Mandelbrot/1"}
{"code": "for (unsigned int i = 0; i < path.size(); ++i)\n{\n  (cout << path.at(i)) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/16"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    r = r + 1;\n    p = q;\n    dosomething(a, n, p + q);\n  }\n\n  p = q;\n  s = i * 10;\n}\n\n", "pragma": "omp target teams distribute parallel for device (n + 1) num_teams (n + 4) if (n != 6)map (from: n) map (alloc: a[2:o-2]) default(shared) private (p) firstprivate (q) shared (n) reduction (+: r) thread_limit (n * 2) dist_schedule (static, 4) num_threads (n + 4) proc_bind (master) lastprivate (s) schedule (static, 8)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr61486-2/1"}
{"code": "for (int i = 0; i < ite_clen; i++)\n{\n  pre_sum += ele_in_col[i];\n  ele_in_col[i] = pre_sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prakharg24/openmpi_openmp_2d_sort/2d_sort/8"}
{"code": "for (numOfThreads = 1; numOfThreads <= 16; ++numOfThreads)\n{\n  C = ProductLine(A, B, heightA, size, lengthB, true);\n  printf(\"%f\\n\", runtime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task4test/0"}
{"code": "for (int i = start_i; i < ((int) max_y); i++)\n{\n  for (int j = start_j; j < ((int) max_x); j++)\n  {\n    if ((*resImg)(i, j) == 0)\n    {\n      if (((i + 1) < max_y) && (copyRes(i + 1, j) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j);\n      }\n      else\n        if (((i - 1) >= fmax(min_y, 0)) && (copyRes(i - 1, j) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j);\n      }\n      else\n        if (((j + 1) < max_x) && (copyRes(i, j + 1) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i, j + 1);\n      }\n      else\n        if (((j - 1) >= fmax(min_x, 0)) && (copyRes(i, j - 1) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i, j - 1);\n      }\n      else\n        if ((((i + 1) < max_y) && ((j + 1) < max_x)) && copyRes(i + 1, j + 1))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j + 1);\n      }\n      else\n        if ((((i - 1) >= fmax(min_y, 0)) && ((j + 1) < max_x)) && copyRes(i - 1, j + 1))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j + 1);\n      }\n      else\n        if ((((i + 1) < max_y) && ((j - 1) >= fmax(min_x, 0))) && copyRes(i + 1, j - 1))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j - 1);\n      }\n      else\n        if ((((i - 1) >= fmax(min_y, 0)) && ((j - 1) >= fmax(min_x, 0))) && copyRes(i - 1, j - 1))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j - 1);\n      }\n\n\n\n\n\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_pure_openmp/image_stitching/1"}
{"code": "for (int i = 0; i < n; i++)\n  B[i] = merge_array[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarshiniKoduru/OpenMp/mergesort/mergesort/2"}
{"code": "for (i = 1; i <= NLon; i++)\n{\n  for (j = 1; j <= NLat; j++)\n  {\n    m = idx(j, i);\n    if (Node(m, iD) == 0.0f)\n      continue;\n\n    dtLoc = My_min(dtLoc, (0.8 * (Dx * cosdeg(getLat(j)))) / sqrt(Gravity * Node(m, iD)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/exam-prep/exam16/3"}
{"code": "for (int i = j + 1; i < n; i++)\n{\n  double sum = 0;\n  for (int k = 0; k < j; k++)\n  {\n    sum = sum + (L[i][k] * U[k][j]);\n  }\n\n  L[i][j] = A[i][j] - sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/3"}
{"code": "for (mj = 0; mj < 1; ++mj)\n  yn[mj] += 1;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/monellz/libgomp-aid/gcc/testsuite/gcc.dg/gomp/pr88415/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < (M / P); j++)\n  {\n    array2[(i * (M / P)) + j] = (unsigned char) ((array[(i * (M / P)) + j] * 255) / globalmax);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/12"}
{"code": "for (i = k + 1; i < N; i++)\n{\n  b[i] = b[i] - (A[i][k] * y[k]);\n  A[i][k] = 0.0;\n}\n\n", "pragma": "omp parallel for num_threads(NUMB_CORES) schedule(dynamic, chunksize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/gaussian_openmp/2"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  c[i] = a[i] + b[i];\n  (cout << (((((((\"Thread \" + to_string(omp_get_thread_num())) + \". Total threads \") + to_string(omp_get_num_threads())) + \". c[\") + to_string(i)) + \"] = \") + to_string(c[i]))) << endl;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block2/task7/1"}
{"code": "for (int i = rank * chunk; i < ((rank + 1) * chunk); i++)\n  local_sum += f(((double) i) / 1000000);\n\n", "pragma": "omp for schedule(dynamic) reduction(+:local_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture15/hybrid_pi/0"}
{"code": "for (int blockid_row = 0; blockid_row < howmany; ++blockid_row)\n{\n  for (int blockid_col = 0; blockid_col < howmany; ++blockid_col)\n  {\n    int i_start = lowerb(blockid_row, howmany, sizex);\n    int i_end = upperb(blockid_row, howmany, sizex);\n    int j_start = lowerb(blockid_col, howmany, sizey);\n    int j_end = upperb(blockid_col, howmany, sizey);\n    for (int i = max(1, i_start); i <= min(sizex - 2, i_end); i++)\n    {\n      for (int j = max(1, j_start); j <= min(sizey - 2, j_end); j++)\n      {\n        unew = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n        diff = unew - u[(i * sizey) + j];\n        sum += diff * diff;\n        u[(i * sizey) + j] = unew;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for ordered(2) private(unew, diff) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ToniCifre/Parallelism/Jacobi and Gauss-Seidel/solver-omp/0"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (k = 0; k < nz; k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][k][m] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(nx ,m ,k ,j ,nz ,ny ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/9"}
{"code": "for (frame_num = 1; frame_num <= Nf; frame_num++)\n{\n  printf(\"\\rProcessing frame %d / %d\", frame_num, Nf);\n  fflush(stdout);\n  MAT *I = get_frame(video, frame_num, 0, 1);\n  int Ih = I->m;\n  int Iw = I->n;\n  for (i = 0; i < Nc; i++)\n  {\n    xc[i][frame_num] = xc[i][frame_num - 1];\n    yc[i][frame_num] = yc[i][frame_num - 1];\n    for (j = 0; j < Np; j++)\n    {\n      r[i][j][frame_num] = r[i][j][frame_num - 1];\n    }\n\n  }\n\n  for (cell_num = 0; cell_num < Nc; cell_num++)\n  {\n    double xci = xc[cell_num][frame_num];\n    double yci = yc[cell_num][frame_num];\n    double *ri = (double *) malloc((sizeof(double)) * Np);\n    for (j = 0; j < Np; j++)\n    {\n      ri[j] = r[cell_num][j][frame_num];\n    }\n\n    double ycavg = 0.0;\n    for (i = (frame_num > 10) ? (frame_num - 10) : (0); i < frame_num; i++)\n    {\n      ycavg += yc[cell_num][i];\n    }\n\n    ycavg = ycavg / ((double) ((frame_num > 10) ? (10) : (frame_num)));\n    int u1 = max((xci - (4.0 * R)) + 0.5, 0);\n    int u2 = min((xci + (4.0 * R)) + 0.5, Iw - 1);\n    int v1 = max((yci - (2.0 * R)) + 1.5, 0);\n    int v2 = min((yci + (2.0 * R)) + 1.5, Ih - 1);\n    MAT *Isub = m_get((v2 - v1) + 1, (u2 - u1) + 1);\n    for (i = v1; i <= v2; i++)\n    {\n      for (j = u1; j <= u2; j++)\n      {\n        m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n      }\n\n    }\n\n    MAT *Ix = gradient_x(Isub);\n    MAT *Iy = gradient_y(Isub);\n    MAT *IE = m_get(Isub->m, Isub->n);\n    for (i = 0; i < Isub->m; i++)\n    {\n      for (j = 0; j < Isub->n; j++)\n      {\n        double temp_x = m_get_val(Ix, i, j);\n        double temp_y = m_get_val(Iy, i, j);\n        m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n      }\n\n    }\n\n    long long MGVF_start_time = get_time();\n    MAT *IMGVF = MGVF(IE, 1, 1);\n    MGVF_time += get_time() - MGVF_start_time;\n    xci = xci - ((double) u1);\n    yci = yci - ((double) (v1 - 1));\n    ycavg = ycavg - ((double) (v1 - 1));\n    long long snake_start_time = get_time();\n    ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n    snake_time += get_time() - snake_start_time;\n    xci = xci + u1;\n    yci = yci + (v1 - 1);\n    xc[cell_num][frame_num] = xci;\n    yc[cell_num][frame_num] = yci;\n    for (j = 0; j < Np; j++)\n    {\n      r[cell_num][j][frame_num] = ri[j];\n      x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n      y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n    }\n\n    m_free(IMGVF);\n    free(ri);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/26"}
{"code": "for (i = 0; i < n; i++)\n{\n  setValueAtIJ(l, n, i + 1, i + 1, 1.0);\n  double sum_u = 0.0;\n  double sum_l = 0.0;\n  for (k = 0; k < i; k++)\n  {\n    sum_u += getValueAtIJ(u, n, k + 1, i + 1) * getValueAtIJ(l, n, i + 1, k + 1);\n  }\n\n  setValueAtIJ(u, n, i + 1, i + 1, getValueAtIJ(A, n, i + 1, i + 1) - sum_u);\n  for (j = 0; j < (2 * ((n - i) - 1)); j++)\n  {\n    if (j < ((n - i) - 1))\n    {\n      sum_u = 0.0;\n      for (k = 0; k < i; k++)\n      {\n        sum_u += getValueAtIJ(u, n, k + 1, (j + i) + 2) * getValueAtIJ(l, n, i + 1, k + 1);\n      }\n\n      setValueAtIJ(u, n, i + 1, (j + i) + 2, getValueAtIJ(A, n, i + 1, (j + i) + 2) - sum_u);\n    }\n    else\n    {\n      m = j % ((n - i) - 1);\n      sum_l = 0.0;\n      for (k = 0; k < i; k++)\n      {\n        sum_l += getValueAtIJ(u, n, k + 1, i + 1) * getValueAtIJ(l, n, (m + i) + 2, k + 1);\n      }\n\n      double divd = getValueAtIJ(u, n, i + 1, i + 1);\n      if (divd == 0.0)\n        flag = -1;\n\n      setValueAtIJ(l, n, (m + i) + 2, i + 1, (getValueAtIJ(A, n, (m + i) + 2, i + 1) - sum_l) / divd);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ktzsh/lu_decomposition/openmp/LUDecomp/3"}
{"code": "for (j = 0; j < array_num; j++)\n{\n  if (((dim_switch_3d == 0) && (fabs(ph_x - (*(x + j))) < block_dist)) && (fabs(ph_y - (*(y + j))) < block_dist))\n  {\n    dist = pow(pow(ph_x - (*(x + j)), 2.0) + pow(ph_y - (*(y + j)), 2.0), 0.5);\n    if (dist < dist_min)\n    {\n      dist_min = dist;\n      min_index = j;\n    }\n\n  }\n  else\n    if ((((dim_switch_3d == 1) && (fabs(ph_x - (*(x + j))) < block_dist)) && (fabs(ph_y - (*(y + j))) < block_dist)) && (fabs(ph_z - (*(z + j))) < block_dist))\n  {\n    dist = pow((pow(ph_x - (*(x + j)), 2.0) + pow(ph_y - (*(y + j)), 2.0)) + pow(ph_z - (*(z + j)), 2.0), 0.5);\n    if (dist < dist_min)\n    {\n      dist_min = dist;\n      min_index = j;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/12"}
{"code": "for (int ieta = 0; ieta < eta_pts; ieta++)\n{\n  etaValues[ieta] = eta_tab->get(1, ieta + 1);\n  etaWeights[ieta] = eta_tab->get(2, ieta + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/2"}
{"code": "for (threadIdx; threadIdx < numThreadSizes; threadIdx++)\n{\n  int threadCount = threadSizes[threadIdx];\n  printf(\"\\n\\nRunning Test %d using %d threads\\n\", testNumber, threadCount);\n  long timeStart;\n  long timeEnd;\n  timeStart = getNanos();\n  processData(threadCount);\n  timeEnd = getNanos();\n  long elapsedNsec = timeEnd - timeStart;\n  printf(\"\\nTest %d elapsed wall clock time = %ld\\n\", testNumber, (long) (elapsedNsec / 1.0e9));\n  printf(\"Test %d elapsed CPU time = %.09f\\n\\n\", testNumber, ((double) elapsedNsec) / 1.0e9);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Altadsa/HPC-Sequential-Searching-using-OpenMP/src/40178464/assignment-1b/source/searching_OMP_0/3"}
{"code": "for (int i = c; i >= 0; i--)\n{\n  if ((newPos->_Cases[j][i] == 2) || (newPos->_Cases[j][i] == 3))\n  {\n    newPos->_PionsPris[joueur] += newPos->_Cases[j][i];\n    newPos->_Cases[j][i] = 0;\n  }\n  else\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/10"}
{"code": "for (i = 0; i < (filesize - 1); i++)\n{\n  if ((number[i] == '1') || (number[i] == '0'))\n  {\n    full_Universe[(k * (columns + 2)) + (j++)] = number[i] - '0';\n    if ((j % (columns + 1)) == 0)\n    {\n      j = 1;\n      k++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajdangwal/Game-of-Life/GameOfLife/3"}
{"code": "for (col = 0; col < LX1; col++)\n{\n  temp[0][col] = tx[0][col];\n  j = 0;\n  bottom[col] = 0.0;\n  for (i = 1; i < (LX1 - 1); i++)\n  {\n    bottom[col] = bottom[col] + (qbnew[0][j][i - 1] * tx[i][col]);\n  }\n\n  for (j = 1; j < LX1; j++)\n  {\n    for (i = 1; i < (LX1 - 1); i++)\n    {\n      temp[j][col] = temp[j][col] + (qbnew[0][j][i - 1] * tx[i][col]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/21"}
{"code": "for (int diag = nbx - 1; diag >= 0; diag--)\n{\n  for (int I = nbx - 1; I >= (nbx - diag); I--)\n  {\n    int ii = nby - I;\n    int jj = nby - ii;\n    ii += (nbx - 1) - diag;\n    for (int i = 1 + (ii * bx); i <= ((((ii + 1) * bx) < (sizex - 2)) ? ((ii + 1) * bx) : (sizex - 2)); i++)\n      for (int j = 1 + (jj * by); j <= ((((jj + 1) * by) < (sizey - 2)) ? ((jj + 1) * by) : (sizey - 2)); j++)\n    {\n      unew = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n      diff = unew - u[(i * sizey) + j];\n      sum += diff * diff;\n      u[(i * sizey) + j] = unew;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/him-28/OpenMP-Test/lab-02-heat-d/.config/solver-omp/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  x[i] = 0 + (i * dx);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe1/Tsouros_exe1/0"}
{"code": "for (int i = 1; i < (grid.shape[0] - 1); ++i)\n{\n  for (int j = 1; j < (grid.shape[1] - 1); ++j)\n  {\n    for (int k = 1; k < (grid.shape[2] - 1); ++k)\n    {\n      grid(i, j, k) = ((2.0 * previous_1(i, j, k)) - previous_2(i, j, k)) + (sqr(tau) * laplacian(previous_1, i, j, k));\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/CpuSolver/3"}
{"code": "for (int i = 0; i < lines; ++i)\n{\n  MPI_Send(weightsBuffer + (i * sizeOfItems), sizeOfItems, MPI_DOUBLE, 0, i + ((rank - 1) * taskEachNode), MPI_COMM_WORLD);\n  if (i == 0)\n  {\n    printf(\"node %d in %s sending weights to master...\\n\", rank, processorName);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-action-based/7"}
{"code": "for (int i = 0; i < (ifog.size() / 4); ++i)\n{\n  for (int j = 0; j < ifog[0].size(); ++j)\n  {\n    i_t[i][j] = ifog[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_1/2"}
{"code": "for (d = 0; d < (n - 1); d++)\n{\n  calc_hairpin_stack_exterior_multibranch(d, n, p->seq, p->base_can_pair, p->v, x, p->w5, p->w3, par);\n  calc_internal(d, n, p->seq, p->base_can_pair, p->v, par);\n  calc_coaxial(d, n, p->seq, p->base_can_pair, p->v, y, p->w5, p->w3, par);\n  calc_wl(d, n, p->seq, p->base_can_pair, p->v, z, wq, w, wl, par);\n  calc_xl(d, n, z, yl, xl);\n  calc_z(d, n, p->seq, p->base_can_pair, p->v, z, xl, wq, par);\n  calc_x(d, n, yl, y, w, wl, xl, x, par);\n  calc_w5_and_w3(d, n, p->w5, p->w3, wq);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/prna-omp/prna/3"}
{"code": "for (k = 0; k < N; ++k)\n{\n  for (i = start_i; i <= end_i; ++i)\n  {\n    for (j = 0; j < unroll_end; j += 4)\n    {\n      int ij_values = _mm_load_si128(&(*dist)[i][j]);\n      int ik_values = _mm_set1_epi32((*dist)[i][k]);\n      int kj_values = _mm_load_si128(&(*dist)[k][j]);\n      int sums = _mm_add_epi32(ik_values, kj_values);\n      int results = _mm_min_epi32(sums, ij_values);\n      _mm_store_si128(&(*dist)[i][j], results);\n    }\n\n    for (l = l_start; l < N; ++l)\n    {\n      int sum = (*dist)[i][k] + (*dist)[k][l];\n      (*dist)[i][l] = (sum < (*dist)[i][l]) ? (sum) : ((*dist)[i][l]);\n    }\n\n  }\n\n  pthread_barrier_wait(&bar);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/4"}
{"code": "for (int r = 0; r < SIZE; r++)\n  result_serial[r] = (int *) malloc(SIZE * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nehabhoi/openMP/openmp/6"}
{"code": "for (i = 0; i < nTHREADS; i++)\n{\n  if (i == (nTHREADS - 1))\n  {\n    partialAddition(vector + (i * subvector_size), last_subvector_size);\n  }\n  else\n  {\n    partialAddition(vector + (i * subvector_size), subvector_size);\n  }\n\n  if (0)\n    printf(\"I'm thread n\u00ba %d, I process the section %d.\\n\", omp_get_thread_num(), i);\n\n}\n\n", "pragma": "omp parallel for num_threads(nTHREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/sum_vector/0"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  r[j] = d;\n}\n\n", "pragma": "omp parallel for private(d)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tclin914/ConjugateGradient_openmp/CG_openmp/cg/3"}
{"code": "for (int i = 0; i < input->nRegions; i++)\n{\n  for (int j = 0; j < input->nCities; j++)\n  {\n    measures->city[i][1][j] = find_max(regions[i][j], input->nStudents);\n  }\n\n  measures->region[1][i] = find_max_double(measures->city[i][1], input->nCities);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/1"}
{"code": "for (long i = 0; i < n; i++)\n{\n  x[i] = i + 1;\n  y[i] = 2.0 / (i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NYU-HPC19/lecture4/02-omp-reduction/1"}
{"code": "for (int i = YlowerLimit; i <= YupperLimit; i++)\n{\n  for (int j = XlowerLimit; j <= XupperLimit; j++)\n  {\n    ans += rgb_image[i][j][color];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/boxFilterOpenMP/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (5.0 * u[m][i][j][k])));\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/150"}
{"code": "for (i = 0; i < num_elements_per_proc; i++)\n{\n  local_sum += rand_nums[i];\n}\n\n", "pragma": "omp parallel for reduction(+: local_sum) num_threads(n)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/Combining OpenMP and MPI/standardDeviation/0"}
{"code": "for (int i = 0; i < 11000; i++)\n{\n  free(input[i]);\n  free(occurrences_map[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par2/6"}
{"code": "for (int i = (rang * n) / nbp; i < (((rang + 1) * n) / nbp); i++)\n{\n  d[i] = 0.0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n    if (i == Aj[u])\n    d[i] += Ax[u];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/15"}
{"code": "for (i = kxpi - 1; i < kxpt; i++)\n{\n  koff = (ndim * nyv) * i;\n  for (k = 0; k < ny; k++)\n  {\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      for (jj = 0; jj < ndim; jj++)\n      {\n        t1 = g[(jj + (ndim * k1)) + koff];\n        g[(jj + (ndim * k1)) + koff] = g[(jj + (ndim * k)) + koff];\n        g[(jj + (ndim * k)) + koff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indy; m++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = sct[kmr * j];\n        for (jj = 0; jj < ndim; jj++)\n        {\n          t1 = s * g[(jj + (ndim * j2)) + koff];\n          g[(jj + (ndim * j2)) + koff] = g[(jj + (ndim * j1)) + koff] - t1;\n          g[(jj + (ndim * j1)) + koff] += t1;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,jj,j1,j2,koff,s,t1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpdpic2/mpdpush2/12"}
{"code": "for (int i = n - 1; i >= 0; i--)\n{\n  sol[i] = a[i][n];\n  for (int j = i + 1; j < n; j++)\n    sol[i] -= a[i][j] * sol[j];\n\n  sol[i] = sol[i] / a[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/1.Gaussian_Elimination/gausstest/2"}
{"code": "for (i = 0; i <= (672 + 1); i++)\n{\n  for (j = 0; j <= (672 + 1); j++)\n  {\n    Temperature_last[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/2"}
{"code": "for (i = 0; i <= num; i++)\n  c[i] = a[i] * b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/VectorDotProduct/0"}
{"code": "for (pi = 0; pi < state->thread_cnt; pi++)\n{\n  partition_t *p = &partitions[pi];\n  free(p->pbodies);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexcpatel/gsim/gsim-barneshut/src/gsim/0"}
{"code": "for (i = 0; i < nsub; i++)\n{\n  xquad[i] = 0.5 * (xn[i] + xn[i + 1]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/11"}
{"code": "for (i = 0; i < 256; ++i)\n{\n  histo[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_atomic/0"}
{"code": "for (uint32_t i = 0; i < nPoints; i++)\n{\n  double xPart = pointX[i] - 0.5;\n  xPart = xPart * xPart;\n  double yPart = pointY[i] - 0.5;\n  yPart = yPart * yPart;\n  double xyDependentPart = xPart + yPart;\n  result[i] = 1 - xyDependentPart;\n  result[i] += get5HundredthsRandom();\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogether/0"}
{"code": "for (int i = 0; i < (interactionSize - newP); i++)\n{\n  results.push_back(knownEncounter(id));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rskim47/disease-propagation/simulation/3"}
{"code": "for (i = 0; i < m1->numFilas; i++)\n{\n  ;\n  for (j = 0; j < m2->numColumnas; j++)\n  {\n    temporal = 0.0;\n    for (k = 0; k < m1->numColumnas; k++)\n    {\n      temporal += m1->datos[i][j] * m2->datos[k][j];\n    }\n\n    m3->datos[i][j] = temporal;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaelmanzanorivera/matrix-dot-prod-optimization-OpenMP/matricesOmp/9"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  changement = 0;\n  for (int y = 0; y < DIM; y += TILE_SIZE)\n    for (int x = 0; x < DIM; x += TILE_SIZE)\n  {\n    do_tile(x + (x == 0), y + (y == 0), TILE_SIZE - (((x + TILE_SIZE) == DIM) + (x == 0)), TILE_SIZE - (((y + TILE_SIZE) == DIM) + (y == 0)), 0);\n  }\n\n\n  if (changement == 0)\n    return it;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/35"}
{"code": "for (int i = 0; i < (numParticles * 3); i++)\n{\n  acc[i] = 0.0;\n  accStar[i] = 0.0;\n  npcdDeviation[i] = 0.0;\n  gradConcentration[i] = 0.0;\n  correcMatrixRow1[i] = 0.0;\n  correcMatrixRow2[i] = 0.0;\n  correcMatrixRow3[i] = 0.0;\n  normal[i] = 0.0;\n  dvelCollision[i] = 0.0;\n  particleAtWallPos[i] = 0.0;\n  mirrorParticlePos[i] = 0.0;\n  wallParticleForce1[i] = 0.0;\n  wallParticleForce2[i] = 0.0;\n  polygonNormal[i] = 0.0;\n  forceWall[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/4"}
{"code": "for (int ii = 1; ii < (params.ny - 1); ++ii)\n{\n  sendbuf[((params.lx * 3) + (params.ly * 3)) + ((ii - 1) * 3)] = cells[(ii * params.nx) + line].speeds[6];\n  sendbuf[(((params.lx * 3) + (params.ly * 3)) + ((ii - 1) * 3)) + 1] = cells[(ii * params.nx) + line].speeds[3];\n  sendbuf[(((params.lx * 3) + (params.ly * 3)) + ((ii - 1) * 3)) + 2] = cells[(ii * params.nx) + line].speeds[7];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/14"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  compact_cell_centric(q, cc, ccc, argc, argv);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-sycl/multimat/0"}
{"code": "for (int i = 0; i < EDGE_COUNT; i++)\n{\n  printf(\"%s\", (i == 0) ? (\"{\") : (\", \"));\n  printf(\"%d\", state->edges[i]);\n  if ((i + 1) == EDGE_COUNT)\n    printf(\"}\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/5"}
{"code": "for (i = 0; i < 4; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp parallel for num_threads(2) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ehsan1222/parallel-processing-cheats/open-mp-examples/example10/0"}
{"code": "for (unsigned I = 0, E = MapTypeModifiers.size(); I < E; ++I)\n{\n  if ((MapTypeModifiers[I] != OMPC_MAP_MODIFIER_unknown) && (find(Modifiers, MapTypeModifiers[I]) != end(Modifiers)))\n  {\n    Diag(MapTypeModifiersLoc[I], err_omp_duplicate_map_type_modifier);\n    continue;\n  }\n\n  assert((Count < NumberOfModifiers) && \"Modifiers exceed the allowed number of map type modifiers\");\n  Modifiers[Count] = MapTypeModifiers[I];\n  ModifiersLoc[Count] = MapTypeModifiersLoc[I];\n  ++Count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/lib/Sema/SemaOpenMP/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1.0 / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i1][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = fac2 * rhs[m][i1][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/47"}
{"code": "for (i = 1; i < iters; i++)\n{\n  dx = 1.0 / ((double) iters);\n  x = ((double) i) * dx;\n  y = sqrt(((double) 1.0) - pow(x, 2));\n  area += dx * y;\n}\n\n", "pragma": "omp parallel for schedule(dynamic) reduction(+: area) private(x, y, i, dx)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/pi_estimation_integration/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = a[i] - b[i];\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/VecVecRed/0"}
{"code": "for (int i2 = 0; i2 <= str2Len; i2++)\n  d[0][i2] = i2;\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lorenzobucci/Levenshtein-Distance-OpenMP-version/LevenshteinDistance/4"}
{"code": "for (k = (0 > (i - radio)) ? (0) : (i - radio); k <= (((n - 1) < (i + radio)) ? (n - 1) : (i + radio)); k++)\n{\n  for (l = (0 > (j - radio)) ? (0) : (j - radio); l <= (((m - 1) < (j + radio)) ? (m - 1) : (j + radio)); l++)\n  {\n    v = ppdBloque[(k - i) + radio][(l - j) + radio];\n    r += ppsImagenOrg[k][l].r * v;\n    g += ppsImagenOrg[k][l].g * v;\n    b += ppsImagenOrg[k][l].b * v;\n    tot += v;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v, l) reduction(+:r, g, b, tot)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PelaezLink/OpenMP_MPI/prac1/imagenesv3/0"}
{"code": "for (long i = 0; i < 1000; ++i)\n{\n  TEST_ASSERT_IN_RANGE(random_scalar(min, max), min, max);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kwasniok/cpp-raytracing/src/test/cpp_raytracing/random/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  fprintf(f, \"%d\\n\", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deryrahman/if3230-bitonic-sort-openmp/src/bitonic_sort/1"}
{"code": "for (int k = 0; k < iters; ++k)\n{\n  for (int q = 0; q < all_blocks; ++q)\n    vertex_count_tmp[k][q] = 0;\n\n  for (int q = 0; q < blocksize; ++q)\n    vertex_count[k][q] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/9"}
{"code": "for (int mat = (cc.Nmats / 2) + 1; mat < ((cc.Nmats / 2) + 5); mat++)\n{\n  int i = 2;\n  int j = (sizey / 2) + 1;\n  cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 0.0;\n  cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 0.0;\n  cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 0.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    board[i][j] = 0;\n    nextBoard[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t3rmian/Life/life/4"}
{"code": "for (j = 0; j < num; j++)\n{\n  if ((id > 0) && (first[id][j][0] == 1))\n  {\n    first[id][j][0] = 0;\n  }\n  else\n  {\n    tmpvarX[0] = rseedX[0][j];\n    tmpvarX[1] = rseedX[1][j];\n    tmpvarX[2] = rseedX[2][j];\n    tmpvarY[0] = rseedY[0][j];\n    tmpvarY[1] = rseedY[1][j];\n    tmpvarY[2] = rseedY[2][j];\n    matrixMult(1, &m1[0][0], &tmpvarX[0], 1, PMOD1, &tmpvarX[0]);\n    matrixMult(1, &m2[0][0], &tmpvarY[0], 1, PMOD2, &tmpvarY[0]);\n    rseedX[0][j] = tmpvarX[0];\n    rseedX[1][j] = tmpvarX[1];\n    rseedX[2][j] = tmpvarX[2];\n    rseedY[0][j] = tmpvarY[0];\n    rseedY[1][j] = tmpvarY[1];\n    rseedY[2][j] = tmpvarY[2];\n  }\n\n  tmpsum = rseedX[0][j] + rseedY[0][j];\n  mod = tmpsum / PMOD1;\n  tmpsum = tmpsum - (((long double) mod) * ((long double) PMOD1));\n  if (tmpsum < 0.0)\n    tmpsum += (long double) PMOD1;\n\n  ret[j] = tmpsum / ((long double) PMOD1);\n  if (ret[j] < 0)\n    ret[j] = ret[j] + 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prod-feng/CLCG-Parallel-RNG/clcg-parallel-mrg32k3a/2"}
{"code": "for (j = start; j < finish; j++)\n  return_val += sin(j);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DinosKalog/Example-of-Parallel-Computing/Example_Hybrid/1"}
{"code": "for (int i = 0; i < numBuckets; ++i)\n{\n  for (int j = 0; j < num_threads; ++j)\n  {\n    histogramRadixFrequency[i] += local_histogram[(j * numBuckets) + i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = thread_id;\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/Parallel_progr/Day2/ex2/loop_schedule/0"}
{"code": "for (long Qi = 0; Qi < QTail; Qi++)\n{\n  long v = Q[Qi];\n  long adj1 = vtxPtr[v];\n  long adj2 = vtxPtr[v + 1];\n  for (long k = adj1; k < adj2; k++)\n  {\n    long x = vtxInd[k].tail;\n    if (__sync_fetch_and_add(&visited[x], 1) == 0)\n    {\n      long whereInQ = __sync_fetch_and_add(&QtmpTail, 1);\n      Qtmp[whereInQ] = x;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/reverseCuthillMcKee/9"}
{"code": "for (int i = 0; i < v->N; i++)\n{\n  v->data[i] = ((float) rand()) / ((float) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uscheedella/Image-Interpolation/labs/lab07/code/vector/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  bucket[i] = 0;\n  for (j = 0; j < 4; j++)\n    omp_bucket[i][j] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/radixsort/3"}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/indirectaccess1-orig-yes/1"}
{"code": "for (int i = 0; i < C->nnz; i++)\n{\n  buffCOO[i] = C->coo[i].first;\n  buffCOO[end + i] = C->coo[i].second;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kostascc/PDS-Project-4/src/v4/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/33"}
{"code": "for (int i = 0; i < (h * w); i++)\n{\n  img[i] = ycbcr_to_rgb(scale(img[i][0], mn, mx), img[i][1], img[i][2]);\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sw1tcherrr/OpenMP-Luma-Normalizer/normalizer/1"}
{"code": "for (i = 0; i < n; i++)\n  y[i] += alpha * x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/9"}
{"code": "for (int i = s + 1; i < e; i++)\n  input[i] = input[i - 1] + input[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/prefixsum/3"}
{"code": "for (i = 0; i < 32ULL; i++)\n  a[i] = i - 25;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.c-c++-common/pr81875/1"}
{"code": "for (size_t i_edge = 0; i_edge < mNumEdges; i_edge++)\n{\n  if (rCutEdgesRatioVector[i_edge] > (-1))\n  {\n    nodes_0.push_back(rEdgesContainer[i_edge][0]);\n    nodes_1.push_back(rEdgesContainer[i_edge][1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/processes/calculate_discontinuous_distance_to_skin_process/11"}
{"code": "for (i = 0; i < 100; i++)\n  if (A[i] >= 500)\n  count = count + 1;\n\n\n", "pragma": "omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLSTS/ThreadProgramming/OpenMP_ArrayCountGE500/0"}
{"code": "for (int i = claster_start + 1; i <= claster_end; i++)\n{\n  x = ((2.0 * i) - 1) / (2.0 * n);\n  sum += 4.0 / (1 + (x * x));\n}\n\n", "pragma": "#pragma omp parallel for private(x) shared(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EternalNeophyte/mpi-labs/MPILabs/6"}
{"code": "for (j = 0; j < 20; ++j)\n{\n  ddiff -= pow(dt, j);\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(-:ddiff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_reduction/4"}
{"code": "for (int i = 0; i < amount; i++)\n{\n  int cluster_index = cluster_of_points[i];\n  cluster_parallel[cluster_index].size++;\n  cluster_parallel[cluster_index].cluster_points[cluster_parallel[cluster_index].size - 1] = points[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/9"}
{"code": "for (int i = 0; i < repeat_files; i++)\n{\n  int files = get_file_list(file_name_queue, files_dir);\n  if (files == (-1))\n  {\n    printf(\"Error!! Check input directory and rerun! Exiting!\\n\");\n    error_flag += 1;\n  }\n\n  file_count += files;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/map-reduce-word-count-openmp-mpi/parallel_read_map_new/2"}
{"code": "for (size_t ivert = 0; ivert < nverts; ++ivert)\n{\n  m_norms[ivert][0] = m_normsx_GPU[ivert];\n  m_norms[ivert][1] = m_normsy_GPU[ivert];\n  m_norms[ivert][2] = m_normsz_GPU[ivert];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/SurfMeshSmooth/Mesh/5"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  a[i] = omp_get_thread_num();\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StephanPirnbaum/insieme-examples/exp5/exp5/0"}
{"code": "for (k = 1; k <= n; k++)\n{\n  t = sdot(k - 1, (a + 0) + ((k - 1) * lda), 1, b, 1);\n  b[k - 1] = (b[k - 1] - t) / a[(k - 1) + ((k - 1) * lda)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/24"}
{"code": "for (i = 0; i < n; i++)\n{\n  double fSum;\n  double fDiff;\n  fSum = b[i];\n  for (j = 0; j < n; j++)\n    fSum -= A[i][j] * xk[j];\n\n  fSum += A[i][i] * xk[i];\n  xkp1[i] = fSum / A[i][i];\n  fDiff = xkp1[i] - xk[i];\n  fxErr += fDiff * fDiff;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : fxErr)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/2"}
{"code": "for (wJ = wI; wJ < (wI + (SMALLN / 4)); wJ++)\n{\n  aVect2[wJ] = aVect1[wJ] * aScalaire;\n}\n\n", "pragma": "omp parallel for firstprivate(wI) private(wJ)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vects/3"}
{"code": "for (int i = 0; i < B; i++)\n{\n  shuffle = uvec > ((n, distr_param(0, n - 1)));\n  ynew = trans(y(shuffle));\n  D.zeros();\n  assignew = AssignB(data, D, P, n, cov_num, strt_num, level_num, omega, shuffle, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  theta(i) = ((-sum(ynew % (assignew - 2))) / n1) - (sum(ynew % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/18"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    read >> b[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/6"}
{"code": "for (i = 0; i < 6; i++)\n{\n  starttime = omp_get_wtime();\n  fillDataSet(&dataSet);\n  omp_set_num_threads(8);\n  add(dataSet);\n  closeDataSet(dataSet);\n  elapsedtime += omp_get_wtime() - starttime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/ParaLab/OpenMP/matrix-addition/mat_add/2"}
{"code": "for (int i = 1; i < N; ++i)\n{\n  for (int j = 0; j < i; ++j)\n  {\n    double r2 = 0.0;\n    double rij[3];\n    for (int k = 0; k < 3; ++k)\n    {\n      rij[k] = rn[i][k] - rn[j][k];\n      if (rij[k] > L2[k])\n      {\n        rij[k] -= L[k];\n      }\n      else\n        if (rij[k] < (-L2[k]))\n      {\n        rij[k] += L[k];\n      }\n\n\n      r2 += rij[k] * rij[k];\n    }\n\n    double f_r = 0;\n    utot += Potential(r2);\n    f_r = ForceDevByRange(r2);\n    assert((r2 != INFINITY) && (r2 != 0));\n    for (int k = 0; k < 3; ++k)\n    {\n      assert(f_r == f_r);\n      f[i][k] += ((float) f_r) * ((float) rij[k]);\n      f[j][k] -= ((float) f_r) * ((float) rij[k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/4"}
{"code": "for (int i = 0; i < shifts; i++)\n{\n  for (int j = 1; j < 28; j++)\n  {\n    s += k[j];\n  }\n\n  s += k[0];\n  k = s;\n  s = \"\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashishpoudel995/Parallelization-of-DES-Algorithm-Using-Open-MP/Codes/nestedParallelism/1"}
{"code": "for (j = 0; j <= column_num; j++)\n{\n  standard_simplex_tableau[constraint_num][j] = (simplex_pivot3 * standard_simplex_tableau[min.index][j]) + standard_simplex_tableau[constraint_num][j];\n  if ((j < column_num) && (standard_simplex_tableau[constraint_num][j] < 0.0))\n  {\n    count_neg++;\n    if (max.value < (-standard_simplex_tableau[constraint_num][j]))\n    {\n      max.value = -standard_simplex_tableau[constraint_num][j];\n      max.index = j;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for reduction(+             \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arkaprabha10/Simplex-Algorithm/Algorithm/openmp_final/4"}
{"code": "for (unsigned char i = '0'; i <= '9'; ++i)\n  for (x = -10; x < 10; ++x)\n{\n  a[i] = (b[i] * c[i]) * d[i];\n}\n\n\n", "pragma": "  #pragma omp for collapse(2) schedule(runtime) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_codegen/2"}
{"code": "for (i = 0; i < ROWSIZE; i++)\n{\n  for (j = 0; j < COLSIZE; j++)\n  {\n    for (k = 0; k < ROWSIZE; k++)\n    {\n      pC(i, j) += pA(i, k) * pB(k, j);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/OpenMP-tutorial/openmp_tutorial_examples/ex2_mm_gpu_omp_scale/helper/1"}
{"code": "for (col = 0; col <= (public.in2_pad_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_pad_rows - 1); row += 1)\n  {\n    if ((((row > (public.in2_pad_add_rows - 1)) && (row < (public.in2_pad_add_rows + public.in2_rows))) && (col > (public.in2_pad_add_cols - 1))) && (col < (public.in2_pad_add_cols + public.in2_cols)))\n    {\n      ori_row = row - public.in2_pad_add_rows;\n      ori_col = col - public.in2_pad_add_cols;\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = private.d_in2_sqr[(ori_col * public.in2_rows) + ori_row];\n    }\n    else\n    {\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/17"}
{"code": "for (i = 0; i < argc; ++i)\n  si = i + 1;\n\n", "pragma": "#pragma omp for firstprivate(si) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_firstprivate_messages/3"}
{"code": "for (int i = 0; i < row; ++i)\n{\n  for (int j = 0; j < column; ++j)\n  {\n    printf(\"Enter a%d%d: \", i + 1, j + 1);\n    scanf(\"%d\", &matrix[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eliah7/OpenMP-Intro/mat_mul_parallel/0"}
{"code": "for (i = 0; i < currentMatrixSize; i++)\n{\n  B_g[(i * currentMatrixSize) + i] -= Bsum[i];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/subgraph_modularity_matrix/sgmm_benchmarking/2"}
{"code": "for (const_iterator vh = kmerVectMap.begin(); vh != kmerVectMap.end(); vh++)\n{\n  strVect.push_back(vh->first);\n  strInLinesMatrix.push_back(vh->second);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaoqiangzhang/fishermp/fishermp_current/1"}
{"code": "for (int j = 0; j < M; j++)\n{\n  double r = distribution(gen);\n  val += (pow(sqrt(1 - ccov), M - (j + 1)) * r) * P[j][n];\n}\n\n", "pragma": "                #pragma omp prallel for shared(ccov,P) reduction(+:val) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/RmES_omp_alt/4"}
{"code": "for (int i = 0; i < 10000; i++)\n  for (int j = 0; j < 10000; j++)\n  InvPathDepth[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant05/1"}
{"code": "for (int vi = 0; vi < numNodes; ++vi)\n{\n  global_diff += abs(score_new[vi] - solution[vi]);\n  solution[vi] = score_new[vi];\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+:global_diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/karta134033/OpenMP_programming/part2/page_rank/page_rank/3"}
{"code": "for (int i = 0; i < numThreads; i++)\n  fifo_init(&threadQueues[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apollo12221/Parallel-AG-Gen-Docker/c_bfs/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = (0.5 * i) * (i + 1);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Johnstedt/Parallel_Computing/OpenMP/loop_carried_dependence/0"}
{"code": "for (i = 0; i < P; i++)\n{\n  sum_eigenvalues += SIGMA[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/11"}
{"code": "for (i = 0; i < 16; i++)\n{\n  f(i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rescurib/Notas_Computo_Paralelo/MemoriaCompartida/Sec_05/Ejemplo_5_2_OpenMP/0"}
{"code": "for (int j = jb; j < je; j++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    DzDzu[IDX(i, j, 3)] = ((((2.0 * u[IDX(i, j, 3)]) - (5.0 * u[IDX(i, j, 4)])) + (4.0 * u[IDX(i, j, 5)])) - u[IDX(i, j, 6)]) * idz_sqrd;\n    DzDzu[IDX(i, j, 4)] = ((u[IDX(i, j, 3)] - (2.0 * u[IDX(i, j, 4)])) + u[IDX(i, j, 5)]) * idz_sqrd;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/22"}
{"code": "for (int i = y; i < (y + height); i++)\n  for (int j = x; j < (x + width); j += width - 1)\n  change += compute_new_state_stable(i, j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/21"}
{"code": "for (i = 0; i < rowptr[nrows]; i++)\n  clens[rowind[i]].key++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/25"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  if (matrix[(i * (n + 1)) + i] == 0)\n  {\n    for (j = i + i; j < n; j++)\n    {\n      if (matrix[(j * (n + 1)) + i] != 0)\n      {\n        swap_rows(i, j, matrix, n);\n        break;\n      }\n\n    }\n\n  }\n\n  if (matrix[(i * (n + 1)) + i] == 0)\n  {\n    printf(\"Unique solution does not exist\\n\");\n    exit(1);\n  }\n\n  for (j = i + 1; j < n; j++)\n  {\n    mult = matrix[(j * (n + 1)) + i];\n    if (mult != 0)\n    {\n      mult /= matrix[(i * (n + 1)) + i];\n      for (k = i; k < (n + 1); k++)\n      {\n        matrix[(j * (n + 1)) + k] -= mult * matrix[(i * (n + 1)) + k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/5"}
{"code": "for (n = 0; n < 500; n++)\n{\n  fwrite(&VC[n], sizeof(float), 1, a);\n  fwrite(&HC[n], sizeof(float), 1, a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FrancoRivero/Comunicacion-de-procesos-en-computacion-paralela/Multiprocesador/SO2_TP2_multiprocesador_FrancoRivero/4"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    a[i + (j * size)] = (float) (i + j);\n    b[i + (j * size)] = (float) (i - j);\n    c[i + (j * size)] = 0.0f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moreandres/hotspot/tests/examples/matrix/matrix/1"}
{"code": "for (i = 0; i < num_steps; i += 1)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gholomia/ParaLab/OpenMP/pi-number/pi_parallel2/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[k][j][i][m] = u[k][j][i][m] + rhs[k][j][i][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/add/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npoff = (idimp * nppmx) * k;\n  nboff = (idimp * npbmx) * k;\n  for (j = 0; j < 8; j++)\n  {\n    sncl[j] = ncl[j + (8 * k)];\n    ks[j] = j;\n  }\n\n  kxs = 1;\n  while (kxs < 8)\n  {\n    #pragma ivdep\n    for (j = 0; j < 4; j++)\n    {\n      lb = kxs * ks[j];\n      sncl[(j + lb) + kxs] += sncl[((2 * lb) + kxs) - 1];\n      ks[j] >>= 1;\n    }\n\n    kxs <<= 1;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    sncl[j] -= ncl[j + (8 * k)];\n  }\n\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ip = 0;\n  ipp = nh / 16;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = (16 * m) + 1;\n    for (j = 0; j < 16; j++)\n    {\n      n[j] = ihole[2 * ((j + joff) + ((ntmax + 1) * k))] - 1;\n      n[j + 16] = ihole[1 + (2 * ((j + joff) + ((ntmax + 1) * k)))];\n    }\n\n    for (j = 0; j < 16; j++)\n    {\n      ist = n[j + 16];\n      ii = sncl[ist - 1];\n      n[j + 16] = ii;\n      sncl[ist - 1] = ii + 1;\n    }\n\n    for (i = 0; i < idimp; i++)\n    {\n      for (j = 0; j < 16; j++)\n      {\n        j1 = n[j];\n        ii = n[j + 16];\n        if (ii < npbmx)\n        {\n          ppbuff[(ii + (npbmx * i)) + nboff] = ppart[(j1 + (nppmx * i)) + npoff];\n        }\n        else\n        {\n          ip = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  nps = 16 * ipp;\n  for (j = nps; j < nh; j++)\n  {\n    j1 = ihole[2 * ((j + 1) + ((ntmax + 1) * k))] - 1;\n    ist = ihole[1 + (2 * ((j + 1) + ((ntmax + 1) * k)))];\n    ii = sncl[ist - 1];\n    if (ii < npbmx)\n    {\n      for (i = 0; i < idimp; i++)\n      {\n        ppbuff[(ii + (npbmx * i)) + nboff] = ppart[(j1 + (nppmx * i)) + npoff];\n      }\n\n    }\n    else\n    {\n      ip = 1;\n    }\n\n    sncl[ist - 1] = ii + 1;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = sncl[j];\n  }\n\n  if (ip > 0)\n    *irc = ncl[7 + (8 * k)];\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,kxs,lb,npoff,nboff,ist,nh,ip,ipp,nps,joff,j1,ii,sncl, ks,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/13"}
{"code": "for (int i = 0; i < N; i++)\n  S += heavy_work(i);\n\n", "pragma": "omp for schedule(static) reduction(+:S)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/04_scheduling/1"}
{"code": "for (i = first; i < size; i += prime)\n  marked[i] = 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 3/Pgm3/0"}
{"code": "for (int k = 0; k < n; k++)\n  for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/floyd_warshall/2"}
{"code": "for (j = 0; j < s; ++j)\n{\n  for (i = 0; i <= j; ++i)\n  {\n    sum = 0.0;\n    for (k = 0; k < i; ++k)\n    {\n      sum += matrixLU[i][k] * matrixLU[k][j];\n    }\n\n    matrixLU[i][j] = matrixA[i][j] - sum;\n  }\n\n  for (i = j + 1; i < s; ++i)\n  {\n    sum = 0.0;\n    for (k = 0; k < j; ++k)\n    {\n      sum += matrixLU[i][k] * matrixLU[k][j];\n    }\n\n    matrixLU[i][j] = (matrixA[i][j] - sum) / matrixLU[j][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/lu/6"}
{"code": "for (int i = 0; i < thread_num; i++)\n  pthread_join(threads[i], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tratitude/eight-queen-problem/eight_queen/6"}
{"code": "for (i = 0; i <= (2048 - 1); i++)\n  for (j = 0; j <= (2048 - 1); j++)\n{\n  if ((((i == 0) || (i == (2048 - 1))) || (j == 0)) || (j == (2048 - 1)))\n    A[i][j] = 0.;\n  else\n    A[i][j] = (1. + i) + j;\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared(A)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AVasK/SuperPCs_OpenMP/redb_2d_parallel_final/0"}
{"code": "for (k = 0; k < 1; k++)\n{\n  resonant = 0;\n  for (j = 0; j < numf1s; j++)\n  {\n    temp = tds[j][i];\n    tds[j][i] += (g(i) * (f1_layer[o][j].P - tds[j][i])) * delta_t;\n    if (fabs(temp - tds[j][i]) <= er)\n      resonant = 1;\n\n  }\n\n  for (j = 0; j < numf1s; j++)\n  {\n    temp = bus[j][i];\n    bus[j][i] += (g(i) * (f1_layer[o][j].P - bus[j][i])) * delta_t;\n    if ((fabs(temp - bus[j][i]) <= er) && resonant)\n    {\n      resonant = 1;\n    }\n    else\n    {\n      resonant = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/10"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    phi_res[i][j][0] = phi[i][j][0] - 1.0;\n    phi_res[i][j][nz - 1] = phi[i][j][nz - 1] - 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/6"}
{"code": "for (i = 1; i < n; i++)\n{\n  if ((i % 3) == 0)\n  {\n    sum += 2. * func(lower + (i * step));\n  }\n  else\n  {\n    sum += 3. * func(lower + (i * step));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rsnemmen/OpenMP-examples/timewaster_omp/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < i; j++)\n    A[i][j] = 0;\n\n  A[i][i] = 1.0;\n  for (int j = i + 1; j < N; j++)\n    A[i][j] = rand();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/8"}
{"code": "for (i = 1; i < (512 - 1); i++)\n  for (j = 1; j < (512 - 1); j++)\n{\n  diff = uu[i][j] - u[i][j];\n  err += diff * diff;\n}\n\n\n", "pragma": "omp for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/laplace/2"}
{"code": "for (i = 1; i <= nx; i++)\n{\n  for (j = 1; j <= ny; j++)\n  {\n    U[i][j] = Unew[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/ADI-OpenMP-example/Numerical Tests on Simple Systems/No OpenMP Version/baseline00/2"}
{"code": "for (unsigned int i = 0; i < node_no; ++i)\n  stress += node_stress[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/5"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n  in >> resurse[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PetcuAlexandru/OpenMP_parallelization/parallel/2"}
{"code": "for (j = 0; j <= 63; j += 1)\n{\n  for (k = 0; k <= 4; k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      a[i][j][k][m] = 0.0;\n      b[i][j][k][m] = 0.0;\n      c[i][j][k][m] = 0.0;\n      d[i][j][k][m] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/126"}
{"code": "for (int i = 0; i < data_count; i++)\n{\n  if (data[i] < value)\n    value = data[i];\n\n}\n\n", "pragma": "omp parallel for reduction(min: value)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/epielemeier/oc-openmp-histogram/main/1"}
{"code": "for (int i = size / 2; i < size; i++)\n{\n  mult[i] = vect1[i] * vect2[i];\n  printf(\"[Proceso %d] (Multiplicacion) He calculado %f (indice=%d)\\n\", id, mult[i], i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/12"}
{"code": "for (int i = 0; i < N; i++)\n  Z[i] = (a * X[i]) + Y[i];\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/Q3-DAXPY-Loop/0"}
{"code": "for (i = 0; i < cache->sets; i++)\n{\n  if (cache->cacheLines[i])\n    free(cache->cacheLines[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/5"}
{"code": "for (long j = r.begin(); j != r.end(); ++j)\n{\n  V[j] = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/perf_parfor2/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  xkp1[i] *= -Dinv[i];\n  xkp1[i] += C[i];\n}\n\n", "pragma": "omp parallel for schedule(static) private(i) shared(xkp1, Dinv, C, n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/standard/iter/0"}
{"code": "for (i = 0; i < dwg->size; i++)\n{\n  internal_weight_community = (double) dynamic_weighted_graph_self_loop(dwg, i);\n  incoming_weight_community = (double) dynamic_weighted_graph_node_degree(dwg, i);\n  result += internal_weight_community - ((incoming_weight_community * incoming_weight_community) / double_m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/community-computation-weighted/6"}
{"code": "for (int e = start; e < end; e++)\n{\n  int n_op = col_reord[e];\n  int map0idx = map0[n_op + (set_size1 * 0)];\n  double *variable = &data0[5 * map0idx];\n  int *up_scratch = &data1[1 * map0idx];\n  variable[VAR_DENSITY] = 0.0;\n  variable[VAR_MOMENTUM + 0] = 0.0;\n  variable[VAR_MOMENTUM + 1] = 0.0;\n  variable[VAR_MOMENTUM + 2] = 0.0;\n  variable[VAR_DENSITY_ENERGY] = 0.0;\n  *up_scratch = 0;\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/up_pre_kernel_omp4kernel_func/0"}
{"code": "for (c2 = 0; c2 <= (n + (-1)); c2 += 1)\n{\n  X[c1][c2] = ((((double) c1) * (c2 + 1)) + 1) / n;\n  A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n  B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n}\n\n", "pragma": "omp parallel for private (c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB043-adi-parallel-no/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  mult(4000, 10000, 2000, 2, eventSet, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danfergo/cpar/assignment/cpp/matrixprod/7"}
{"code": "for (int i = 0; i < inum; i++)\n{\n  ix[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  iy[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  iz[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aidw-omp/main/2"}
{"code": "for (int i = 0; i < tmp.size(); i++)\n{\n  long patHash = hashCal(tmp[i].c_str(), tmp[i].size(), 0);\n  mapHash[patHash] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/meeraramesh-sjsu/netgpu-master/src/Common/Dissector/4"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (j_imopVar111 = 1; j_imopVar111 < (grid_points[1] - 1); j_imopVar111++)\n  {\n    for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n    {\n      uijk_imopVar137 = us[i_imopVar110][j_imopVar111][k_imopVar112];\n      up1_imopVar138 = us[i_imopVar110 + 1][j_imopVar111][k_imopVar112];\n      um1_imopVar139 = us[i_imopVar110 - 1][j_imopVar111][k_imopVar112];\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][0] = (rhs[i_imopVar110][j_imopVar111][k_imopVar112][0] + (dx1tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][0] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][0])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][0]))) - (tx2 * (u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] - u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1]));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][1] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][1] + (dx2tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][1])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1]))) + ((xxcon2 * con43) * ((up1_imopVar138 - (2.0 * uijk_imopVar137)) + um1_imopVar139))) - (tx2 * (((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] * up1_imopVar138) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1] * um1_imopVar139)) + ((((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] - square[i_imopVar110 + 1][j_imopVar111][k_imopVar112]) - u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]) + square[i_imopVar110 - 1][j_imopVar111][k_imopVar112]) * c2)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][2] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][2] + (dx3tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][2] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][2])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][2]))) + (xxcon2 * ((vs[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * vs[i_imopVar110][j_imopVar111][k_imopVar112])) + vs[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) - (tx2 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][2] * up1_imopVar138) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][2] * um1_imopVar139)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][3] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][3] + (dx4tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][3] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][3])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][3]))) + (xxcon2 * ((ws[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * ws[i_imopVar110][j_imopVar111][k_imopVar112])) + ws[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) - (tx2 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][3] * up1_imopVar138) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][3] * um1_imopVar139)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][4] = ((((rhs[i_imopVar110][j_imopVar111][k_imopVar112][4] + (dx5tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][4])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]))) + (xxcon3 * ((qs[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * qs[i_imopVar110][j_imopVar111][k_imopVar112])) + qs[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) + (xxcon4 * (((up1_imopVar138 * up1_imopVar138) - ((2.0 * uijk_imopVar137) * uijk_imopVar137)) + (um1_imopVar139 * um1_imopVar139)))) + (xxcon5 * (((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] * rho_i[i_imopVar110 + 1][j_imopVar111][k_imopVar112]) - ((2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][4]) * rho_i[i_imopVar110][j_imopVar111][k_imopVar112])) + (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4] * rho_i[i_imopVar110 - 1][j_imopVar111][k_imopVar112])))) - (tx2 * ((((c1 * u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4]) - (c2 * square[i_imopVar110 + 1][j_imopVar111][k_imopVar112])) * up1_imopVar138) - (((c1 * u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]) - (c2 * square[i_imopVar110 - 1][j_imopVar111][k_imopVar112])) * um1_imopVar139)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/9"}
{"code": "for (i = 0; i < row; i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    printf(\"%d \", matrix[(i * col) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielevensen/Conways-Game-of-Life/version4/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/56"}
{"code": "for (int i = 0; i < ((size + 1) / 3); i++)\n{\n  int isEmpty = 0;\n  for (size_t j = 0; j < strlen(file_nodes[i]->str_dependencies); j++)\n  {\n    if (file_nodes[i]->str_dependencies[j] != ' ')\n    {\n      isEmpty++;\n      break;\n    }\n\n  }\n\n  if (isEmpty == 0)\n  {\n    feuilles[count_feuilles] = file_nodes[i];\n    count_feuilles++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elouatih/distributed_make_mpi_openmp/parser/4"}
{"code": "for (i = 0; i < timesteps; ++i)\n{\n  calculate_nbody(particles, forces, num_particles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_39_nbody/8"}
{"code": "for (iteration = 0; iteration < num_iterations; iteration++)\n{\n  manual_omp_module1(startPidx, endPidx);\n  manual_omp_module2(startPidx, endPidx);\n  manual_omp_module3(startPidx, endPidx);\n  manual_omp_module4(startPidx, endPidx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp/13"}
{"code": "for (int t = 0; t < args.thread_count; t++)\n{\n  int data_start = t * dataset_size_per_thread;\n  int data_end = (t + 1) * dataset_size_per_thread;\n  if (t == (args.thread_count - 1))\n  {\n    data_end = (int) data->size();\n  }\n  else\n    if (data_end > data->size())\n  {\n    data_end = (int) data->size();\n  }\n\n\n  changed += compute(centers, new_global_centers, assignments, *data, data_start, data_end);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_parakmeans/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 4; j++)\n    capture_sx >> frame_sx[j];\n\n  sx(frame_sx, canvas_sx, cascade_sx, scale_sx, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/ComputerVision2/ufacedetect/1"}
{"code": "for (iterator it = list.begin(); it != list.end(); it++)\n{\n  add_dependence(*it, directionality);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/nanox-nodecl/tl-outline-info/0"}
{"code": "for (row = my_num_rows + 1; row >= 0; row--)\n{\n  free(next_grid[row]);\n  free(current_grid[row]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/life/4"}
{"code": "for (int j = k + 1; j < i; j++)\n{\n  cblas_dgemm(CblasColMajor, CblasNoTrans, CblasTrans, ts, ts, ts, -1.0, Ah[k][i], ts, Ah[k][j], ts, 1.0, Ah[j][i], ts);\n}\n\n", "pragma": "omp for schedule(dynamic, 1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/1"}
{"code": "for (i = 2; i < (width + 2); i++)\n{\n  for (j = 2; j < (depth + 2); j++)\n  {\n    for (k = 1; k < (height + 1); k++)\n    {\n      data[offset(i, j, k)] = dRand(10, 1000);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petrosgk/Atmospheric-Model-Simulation/AtmModelMPI/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  pthread_join(thread_id[i], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/6"}
{"code": "for (i = 0; i < b->size; i++)\n{\n  if (getBit(b, i))\n  {\n    localFrontierStack->Stack[localFrontierStack->tail] = i;\n    localFrontierStack->tail++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/arrayStack/2"}
{"code": "for (int i = 0; i < 15; ++i)\n{\n  for (int i = 0; i < 15; ++i)\n  {\n    printf(\"%d  \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/mat/0"}
{"code": "for (size_t i = 0; i < M; i++)\n  vec[i] = leftBoard + (rand() % ((rightBoard + 1) - leftBoard));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sncodeGit/openmp_labs/Task3/Task3/0"}
{"code": "for (i = 0; i < ntrain_samples; i++)\n{\n  int cls_label = cvRound(responses->data.fl[i]) - 'A';\n  float *bit_vec = (float *) (new_responses->data.ptr + (i * new_responses->step));\n  for (j = 0; j < class_count; j++)\n    bit_vec[j] = 0.f;\n\n  bit_vec[cls_label] = 1.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/26"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValueY = (pixelValueX = 0);\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = qBlue(srcImage->pixel(jj + j, ii + i));\n        pixelValueY += weight_y[i + 1][j + 1] * blue;\n        pixelValueX += weight_x[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    gradient = sqrt(pow(pixelValueY, 2) + pow(pixelValueX, 2));\n    int newPixel = gradient;\n    if (newPixel > 255)\n      newPixel = 255;\n\n    if (newPixel < 0)\n      newPixel = 0;\n\n    dstImage->setPixel(jj, ii, QColor(newPixel, newPixel, newPixel).rgba());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/sobel/sobel2/2"}
{"code": "for (int i = 0; i < MAX_POINTS; i++)\n{\n  free(points[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Plutone11011/ParallelKMEANS/main/2"}
{"code": "forwardPropagate(n)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/20"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv8[layer8_index];\n    if (conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/38"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < rows; j++)\n  {\n    mu[i][j] = data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/6"}
{"code": "for (int x = 0; x < (n - 1); x++)\n{\n  int iMin = x;\n  for (int y = x + 1; y < n; y++)\n  {\n    if (ilgi[y] > ilgi[iMin])\n      iMin = y;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OsamaTab/openMp/OpenMp/Source/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum = (r[i] * r[i]) + sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/1"}
{"code": "for (long i = 0; i < NV; i++)\n  Counter[i] = 0;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/14"}
{"code": "form.show()\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jonaias/Programacao-concorrente/src/main/11"}
{"code": "for (i = 0; i < ((int) this->current_individuals.size()); i++)\n{\n  total_pop_fitness += this->current_individuals[i].Raw_Fitness();\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) reduction(+: total_pop_fitness) ", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/1"}
{"code": "for (j_imopVar10 = 1; j_imopVar10 < (grid_points[1] - 1); j_imopVar10++)\n{\n  for (k_imopVar11 = 1; k_imopVar11 < (grid_points[2] - 1); k_imopVar11++)\n  {\n    double *_imopVarPre338;\n    double (*_imopVarPre339)[5];\n    double (*_imopVarPre340)[5];\n    _imopVarPre338 = rhs[0][j_imopVar10][k_imopVar11];\n    _imopVarPre339 = lhs[0][j_imopVar10][k_imopVar11][2];\n    _imopVarPre340 = lhs[0][j_imopVar10][k_imopVar11][1];\n    binvcrhs(_imopVarPre340, _imopVarPre339, _imopVarPre338);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/1"}
{"code": "for (j = 0; j < (width * height); j++)\n{\n  int moy;\n  moy = ((pi[j].r + pi[j].g) + pi[j].b) / 3;\n  if (moy < 0)\n    moy = 0;\n\n  if (moy > 255)\n    moy = 255;\n\n  pi[j].r = moy;\n  pi[j].g = moy;\n  pi[j].b = moy;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/grey_filter/0"}
{"code": "for (i = 0; i < (max_rows * max_cols); i++)\n{\n  if (percentDiff(gpu[i], cpu[i]) > ERROR_THRESHOLD)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/nw/src/needle/0"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  BF_current[index].P[0] ^= BF_exp_key[index][0];\n  BF_current[index].P[1] ^= BF_exp_key[index][1];\n  BF_current[index].P[2] ^= BF_exp_key[index][2];\n  BF_current[index].P[3] ^= BF_exp_key[index][3];\n  BF_current[index].P[4] ^= BF_exp_key[index][4];\n  BF_current[index].P[5] ^= BF_exp_key[index][5];\n  BF_current[index].P[6] ^= BF_exp_key[index][6];\n  BF_current[index].P[7] ^= BF_exp_key[index][7];\n  BF_current[index].P[8] ^= BF_exp_key[index][8];\n  BF_current[index].P[9] ^= BF_exp_key[index][9];\n  BF_current[index].P[10] ^= BF_exp_key[index][10];\n  BF_current[index].P[11] ^= BF_exp_key[index][11];\n  BF_current[index].P[12] ^= BF_exp_key[index][12];\n  BF_current[index].P[13] ^= BF_exp_key[index][13];\n  BF_current[index].P[14] ^= BF_exp_key[index][14];\n  BF_current[index].P[15] ^= BF_exp_key[index][15];\n  BF_current[index].P[16] ^= BF_exp_key[index][16];\n  BF_current[index].P[17] ^= BF_exp_key[index][17];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/25"}
{"code": "for (int i = 0; i < r; ++i)\n  if (board[i] == board[r])\n  safe = false;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nqueen-omp/main/3"}
{"code": "for (int i = N - 1; i >= 0; i--)\n  U_[i] = (Al[i + 1] * U_[i + 1]) + Bt[i + 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/99"}
{"code": "for (int j = 0; j < total_values; j++)\n{\n  mean.values[j] /= numPoints;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/23"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < (N - i); j++)\n{\n  c[(i * N) + j] = a[i] * b[j];\n}\n\n\n", "pragma": "omp teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/collapse-nonrectangle/collapse-nonrectangle/0"}
{"code": "for (idx_t j = 0; j < J; ++j)\n{\n  lambda[j] = sqrt(lambda[j]);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/4"}
{"code": "for (int j = 0; j < NNodes; j++)\n{\n  iterator it = it_begin + j;\n  it->GetValue(TARGET_STRESS_Z) = current_target_stress;\n  it->GetValue(REACTION_STRESS_Z) = reaction_stress_estimated[map_index];\n  it->GetValue(SMOOTHED_REACTION_STRESS_Z) = mReactionStress[map_index];\n  it->GetValue(ELASTIC_REACTION_STRESS_Z) = elastic_reaction_stress_estimated[map_index];\n  it->GetValue(SMOOTHED_ELASTIC_REACTION_STRESS_Z) = mElasticReactionStress[map_index];\n  it->GetValue(LOADING_VELOCITY_Z) = mVelocity[map_index];\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/multiaxial_control_module_generalized_2d_utilities/1"}
{"code": "for (int i = 0; i < m->order; i++)\n{\n  for (j = 0; j < (m->order - 1); j++)\n  {\n    fscanf(fp_in, \"%[^,]%*c\", temp);\n    m->SquareMatrix[i][j] = atof(temp);\n  }\n\n  fscanf(fp_in, \"%s\", temp);\n  m->SquareMatrix[i][j] = atof(temp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/experiment-8/Parallel_1.0/1"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_cell_kernel_c/1"}
{"code": "for (int x = 0; x < ScreenWidth(); x++)\n{\n  for (int y = 0; y < ScreenHeight(); y++)\n  {\n    int n = pFractalIterations[(x * ScreenHeight()) + y];\n    double t = ((double) n) / ((double) nMaxIteration);\n    int rr = (int) (((((9 * (1 - t)) * t) * t) * t) * 255);\n    int rg = (int) (((((15 * (1 - t)) * (1 - t)) * t) * t) * 255);\n    int rb = (int) (((((8.5 * (1 - t)) * (1 - t)) * (1 - t)) * t) * 255);\n    Draw(x, y, Pixel(rr, rg, rb, 255));\n  }\n\n}\n\n", "pragma": "                    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucaszm7/Mandel2Us/Application/3"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd4 * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxhs; i += 2)\n      {\n        v_t1 = _mm512_load_ps((float *) (&f[(4 * i) + i1]));\n        v_t2 = _mm512_load_ps((float *) (&f[(4 * i) + i0]));\n        _mm512_store_ps((float *) (&f[(4 * i) + i1]), v_t2);\n        _mm512_store_ps((float *) (&f[(4 * i) + i0]), v_t1);\n      }\n\n      for (i = nxhs; i < nxh; i++)\n      {\n        t1 = f[(4 * i) + i1];\n        t2 = f[(1 + (4 * i)) + i1];\n        t3 = f[(2 + (4 * i)) + i1];\n        f[(4 * i) + i1] = f[(4 * i) + i0];\n        f[(1 + (4 * i)) + i1] = f[(1 + (4 * i)) + i0];\n        f[(2 + (4 * i)) + i1] = f[(2 + (4 * i)) + i0];\n        f[(4 * i) + i0] = t1;\n        f[(1 + (4 * i)) + i0] = t2;\n        f[(2 + (4 * i)) + i0] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = conjf(sct[kmr * j]);\n        v_t1 = _mm512_set4_ps(cimagf(t1), crealf(t1), cimagf(t1), crealf(t1));\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxhs; i += 2)\n        {\n          v_t2 = _mm512_load_ps((float *) (&f[(4 * i) + i1]));\n          v_t3 = (int) _mm512_shuffle_epi32((int) v_t1, 160);\n          v_t3 = _mm512_mul_ps(v_t2, v_t3);\n          v_t2 = (int) _mm512_shuffle_epi32((int) v_t2, 177);\n          v_t4 = (int) _mm512_shuffle_epi32((int) v_t1, 245);\n          v_t4 = _mm512_mul_ps(v_t2, v_t4);\n          v_t4 = _mm512_mask_sub_ps(v_t4, _mm512_int2mask(21845), v_zero, v_t4);\n          v_t2 = _mm512_add_ps(v_t3, v_t4);\n          v_t3 = _mm512_load_ps((float *) (&f[(4 * i) + i0]));\n          v_t4 = _mm512_sub_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[(4 * i) + i1]), v_t4);\n          v_t4 = _mm512_add_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[(4 * i) + i0]), v_t4);\n        }\n\n        for (i = nxhs; i < nxh; i++)\n        {\n          t2 = t1 * f[(4 * i) + i1];\n          t3 = t1 * f[(1 + (4 * i)) + i1];\n          t4 = t1 * f[(2 + (4 * i)) + i1];\n          f[(4 * i) + i1] = f[(4 * i) + i0] - t2;\n          f[(1 + (4 * i)) + i1] = f[(1 + (4 * i)) + i0] - t3;\n          f[(2 + (4 * i)) + i1] = f[(2 + (4 * i)) + i0] - t4;\n          f[(4 * i) + i0] += t2;\n          f[(1 + (4 * i)) + i0] += t3;\n          f[(2 + (4 * i)) + i0] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2,t3, t4,v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/34"}
{"code": "for (int i = 0; i < data_len; ++i)\n{\n  fprintf(fp, \"%f,\", data[i]);\n  for (int imf = 0; imf < mode; ++imf)\n  {\n    if (EMD_success[imf])\n    {\n      fprintf(fp, \"%f,\", result[imf][i]);\n      fprintf(fp, \"%f,\", residual[imf][i]);\n      fprintf(fp, \"%f,\", UpEnvelope[imf][i]);\n      fprintf(fp, \"%f,\", LowEnvelope[imf][i]);\n      fprintf(fp, \"%f,\", MeanEnvelope[imf][i]);\n    }\n\n    if (NDQ_success[imf])\n    {\n      fprintf(fp, \"%f,\", FM[imf][i]);\n      fprintf(fp, \"%f,\", AM[imf][i]);\n      fprintf(fp, \"%f,\", IP[imf][i]);\n      fprintf(fp, \"%f,\", IF[imf][i]);\n    }\n\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/45"}
{"code": "for (j = 0; j < N; ++j)\n  m[j] = j;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/worksharing/for/omp_doacross/8"}
{"code": "for (array2d_iter = array2d_files.begin(); array2d_iter != array2d_files.end(); ++array2d_iter)\n{\n  if (array2d_iter->second.size() == 1)\n  {\n    array1d_files.push_back(array2d_iter->second.at(0));\n    del_var_names.push_back(array2d_iter->first);\n  }\n  else\n  {\n    sort(array2d_iter->second.begin(), array2d_iter->second.end());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/import_raster/import_raster/4"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  b[i] = 0.75 * (B[i] / A[i]);\n  c[i] = 0.50 * (C[i] / A[i]);\n  d[i] = 0.25 * (D[i] / A[i]);\n  Q[i] = (c[i] / 3) - ((b[i] * b[i]) / 9);\n  R[i] = (((b[i] * c[i]) / 6) - (((b[i] * b[i]) * b[i]) / 27)) - (0.5 * d[i]);\n  Q[i] = roundf(Q[i] * 1E5) / 1E5;\n  R[i] = roundf(R[i] * 1E5) / 1E5;\n  Qint[i] = (Q[i] * Q[i]) * Q[i];\n  Rint[i] = R[i] * R[i];\n  del[i] = Rint[i] + Qint[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/qureshizawar/CUDA-quartic-solver/src/cpu_solver/2"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  tmprlt->paras[i + topoinfo->numG] = randpg(topoinfo->prsrandrange[0][i + topoinfo->numG], topoinfo->prsrandrange[1][i + topoinfo->numG]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/72"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  dot_vec[i] = v[i] * w[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/matrix_product/0"}
{"code": "for (int i = 0; i <= m; i++)\n{\n  C[i][0] = 0;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkalyanpurr/openMP/lcs/lcs/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    if (i > j)\n    {\n      l[(i * size) + j] = ((float) rand()) / (((float) 32767) + ((float) 1));\n    }\n    else\n      if (i == j)\n    {\n      l[(i * size) + j] = 1;\n    }\n    else\n    {\n      l[(i * size) + j] = 0;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lud/omp/lud_omp_one_file/1"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        vz = -vz;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,noff,moff,loff,npp,npoff,nn,mm,ll,nm,x,y,z,vx,vy,vz, dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt, omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,p2,gami, qtmg,dtg,sum1,sfxyz,sbxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/4"}
{"code": "for (i = 0; i < non_elite_count; i++)\n{\n  next_individuals.push_back(unused_individuals.back());\n  unused_individuals.pop_back();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/11"}
{"code": "for (unsigned j = 0; j < num_v_neurons; ++j)\n{\n  avg_v += m.Vs[j];\n  avg_bv += m.biasV[j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:avg_v,avg_bv)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/18"}
{"code": "for (int i = 0; i < V; i++)\n{\n  dist[i] = INT_MAX;\n  sptSet[i] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for shared(dist, sptSet)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaiKarthik2000/OpenMP-Parallelization-of-Dynamic-Programming-and-Greedy-Algorithms/dijkstra-path/dijkstras-parallel/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (graph->grid->out_degree[v])\n    riDividedOnDiClause[v] = stats->pageRanks[v] / graph->grid->out_degree[v];\n  else\n    riDividedOnDiClause[v] = 0.0f;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/2"}
{"code": "for (i = low; i < varHigh; i++)\n{\n  for (j = 0; j < varNumF1; j++)\n  {\n    if (i % low)\n    {\n      tds[j][i] = tds[j][0];\n      tds[j][i] = bus[j][0];\n    }\n    else\n    {\n      tds[j][i] = tds[j][1];\n      tds[j][i] = bus[j][1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/44"}
{"code": "for (i = 0; i <= 1000; i++)\n{\n  num_threads = omp_get_num_threads();\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for private(i) if (control==1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_parallel_for_if/0"}
{"code": "for (i = 0; i <= (102 + 1); i++)\n{\n  for (k = 0; k <= (102 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/24"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  DESIRED_OUTPUT[i] = ((float) rand()) / ((float) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex3/ex3/4"}
{"code": "for (int i = 0; i < FRAMES_PER_BUFFER; i++)\n{\n  data->monoDelay[(posActual + i) % DELAY_SIZE] = apIn[i];\n}\n\n", "pragma": "    #pragma omp parallel for shared(posActual, apIn, data)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SurturTawers/OpenMP-ReverbDSP/reverbParalelo/2"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n  for (int k = 1; k < (grid->getNZC() - 1); k++)\n{\n  const double q = q_factor * EMf->getRHOcs(i, j, k, 0);\n  for (int ii = 0; ii < npcelx; ii++)\n    for (int jj = 0; jj < npcely; jj++)\n    for (int kk = 0; kk < npcelz; kk++)\n  {\n    const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n    const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n    const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n    p0 = sqrt(((energy + 1) * (energy + 1)) - 1);\n    const double w = p0 * cos(pitch_angle);\n    pperp0 = p0 * sin(pitch_angle);\n    gyro_phase = ((2 * M_PI) * rand()) / ((double) RAND_MAX);\n    const double u = pperp0 * cos(gyro_phase);\n    const double v = pperp0 * sin(gyro_phase);\n    counter++;\n    create_new_particle(u, v, w, q, x, y, z);\n  }\n\n\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/9"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    double tmp = q[i + (j * m)];\n    q[i + (j * m)] = q[(i * m) + j];\n    q[(i * m) + j] = tmp;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/15"}
{"code": "for (c3 = (0 > (((-N) + c1) + 1)) ? (0) : (((-N) + c1) + 1); c3 <= ((c1 - 1) / 17); c3 += 1)\n  for (c4 = 0; c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    for (c5 = 0; c5 <= c3; c5 += 1)\n      for (c9 = (N - c1) + (17 * c3); c9 <= (((N - 1) < (((N - c1) + (17 * c3)) + 15)) ? (N - 1) : (((N - c1) + (17 * c3)) + 15)); c9 += 1)\n    {\n      if ((c5 == c3) && ((c1 + c9) >= ((N + (17 * c3)) + 1)))\n        Q[((N - c1) + c3) - 1][c9] = Q[((N - c1) + c3) - 1][c9 - 1];\n\n      if ((c5 == c3) && ((c1 + c9) >= ((N + (17 * c3)) + 1)))\n        for (c11 = 0; c11 < (16 * c3); c11 += 1)\n        Q[((N - c1) + c3) - 1][c9] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][c9];\n\n\n      for (c11 = 16 * c5; c11 <= ((((16 * c5) + 15) < ((((-N) + c1) - c3) + c9)) ? ((16 * c5) + 15) : ((((-N) + c1) - c3) + c9)); c11 += 1)\n      {\n        Qbp[c11 + (((N - c1) + c3) - 1)][c9] = (Q[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1] * ERT) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n        if (c5 == c3)\n        {\n          Q[((N - c1) + c3) - 1][c9] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][c9];\n        }\n        else\n          if ((c1 + c9) == (N + (17 * c3)))\n        {\n          Q[((N - c1) + c3) - 1][(N - c1) + (17 * c3)] += Q[((N - c1) + c3) - 1][c11 + (((N - c1) + c3) - 1)] * Qbp[c11 + (((N - c1) + c3) - 1)][(N - c1) + (17 * c3)];\n        }\n\n\n      }\n\n    }\n\n\n  }\n  else\n  {\n    Q[((N - c1) + c3) - 1][(N - c1) + (17 * c3)] = Q[((N - c1) + c3) - 1][((N - c1) + (17 * c3)) - 1];\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1) shared(c1) private(c3,c4,c5,c9,c11)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcc/mcc/0"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n{\n  c[i][j] = 0.0;\n  c2[i][j] = 0.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/matrixmultiply/3"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      tmp1 = dt * tz1;\n      tmp2 = dt * tz2;\n      lhs[i][j][k][0][0][0] = (((-tmp2) * fjac[i][j][k - 1][0][0]) - (tmp1 * njac[i][j][k - 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][0][0][1] = ((-tmp2) * fjac[i][j][k - 1][0][1]) - (tmp1 * njac[i][j][k - 1][0][1]);\n      lhs[i][j][k][0][0][2] = ((-tmp2) * fjac[i][j][k - 1][0][2]) - (tmp1 * njac[i][j][k - 1][0][2]);\n      lhs[i][j][k][0][0][3] = ((-tmp2) * fjac[i][j][k - 1][0][3]) - (tmp1 * njac[i][j][k - 1][0][3]);\n      lhs[i][j][k][0][0][4] = ((-tmp2) * fjac[i][j][k - 1][0][4]) - (tmp1 * njac[i][j][k - 1][0][4]);\n      lhs[i][j][k][0][1][0] = ((-tmp2) * fjac[i][j][k - 1][1][0]) - (tmp1 * njac[i][j][k - 1][1][0]);\n      lhs[i][j][k][0][1][1] = (((-tmp2) * fjac[i][j][k - 1][1][1]) - (tmp1 * njac[i][j][k - 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][0][1][2] = ((-tmp2) * fjac[i][j][k - 1][1][2]) - (tmp1 * njac[i][j][k - 1][1][2]);\n      lhs[i][j][k][0][1][3] = ((-tmp2) * fjac[i][j][k - 1][1][3]) - (tmp1 * njac[i][j][k - 1][1][3]);\n      lhs[i][j][k][0][1][4] = ((-tmp2) * fjac[i][j][k - 1][1][4]) - (tmp1 * njac[i][j][k - 1][1][4]);\n      lhs[i][j][k][0][2][0] = ((-tmp2) * fjac[i][j][k - 1][2][0]) - (tmp1 * njac[i][j][k - 1][2][0]);\n      lhs[i][j][k][0][2][1] = ((-tmp2) * fjac[i][j][k - 1][2][1]) - (tmp1 * njac[i][j][k - 1][2][1]);\n      lhs[i][j][k][0][2][2] = (((-tmp2) * fjac[i][j][k - 1][2][2]) - (tmp1 * njac[i][j][k - 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][0][2][3] = ((-tmp2) * fjac[i][j][k - 1][2][3]) - (tmp1 * njac[i][j][k - 1][2][3]);\n      lhs[i][j][k][0][2][4] = ((-tmp2) * fjac[i][j][k - 1][2][4]) - (tmp1 * njac[i][j][k - 1][2][4]);\n      lhs[i][j][k][0][3][0] = ((-tmp2) * fjac[i][j][k - 1][3][0]) - (tmp1 * njac[i][j][k - 1][3][0]);\n      lhs[i][j][k][0][3][1] = ((-tmp2) * fjac[i][j][k - 1][3][1]) - (tmp1 * njac[i][j][k - 1][3][1]);\n      lhs[i][j][k][0][3][2] = ((-tmp2) * fjac[i][j][k - 1][3][2]) - (tmp1 * njac[i][j][k - 1][3][2]);\n      lhs[i][j][k][0][3][3] = (((-tmp2) * fjac[i][j][k - 1][3][3]) - (tmp1 * njac[i][j][k - 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][0][3][4] = ((-tmp2) * fjac[i][j][k - 1][3][4]) - (tmp1 * njac[i][j][k - 1][3][4]);\n      lhs[i][j][k][0][4][0] = ((-tmp2) * fjac[i][j][k - 1][4][0]) - (tmp1 * njac[i][j][k - 1][4][0]);\n      lhs[i][j][k][0][4][1] = ((-tmp2) * fjac[i][j][k - 1][4][1]) - (tmp1 * njac[i][j][k - 1][4][1]);\n      lhs[i][j][k][0][4][2] = ((-tmp2) * fjac[i][j][k - 1][4][2]) - (tmp1 * njac[i][j][k - 1][4][2]);\n      lhs[i][j][k][0][4][3] = ((-tmp2) * fjac[i][j][k - 1][4][3]) - (tmp1 * njac[i][j][k - 1][4][3]);\n      lhs[i][j][k][0][4][4] = (((-tmp2) * fjac[i][j][k - 1][4][4]) - (tmp1 * njac[i][j][k - 1][4][4])) - (tmp1 * dz5);\n      lhs[i][j][k][1][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dz1);\n      lhs[i][j][k][1][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n      lhs[i][j][k][1][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n      lhs[i][j][k][1][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n      lhs[i][j][k][1][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n      lhs[i][j][k][1][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n      lhs[i][j][k][1][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dz2);\n      lhs[i][j][k][1][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n      lhs[i][j][k][1][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n      lhs[i][j][k][1][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n      lhs[i][j][k][1][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n      lhs[i][j][k][1][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n      lhs[i][j][k][1][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dz3);\n      lhs[i][j][k][1][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n      lhs[i][j][k][1][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n      lhs[i][j][k][1][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n      lhs[i][j][k][1][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n      lhs[i][j][k][1][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n      lhs[i][j][k][1][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dz4);\n      lhs[i][j][k][1][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n      lhs[i][j][k][1][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n      lhs[i][j][k][1][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n      lhs[i][j][k][1][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n      lhs[i][j][k][1][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n      lhs[i][j][k][1][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dz5);\n      lhs[i][j][k][2][0][0] = ((tmp2 * fjac[i][j][k + 1][0][0]) - (tmp1 * njac[i][j][k + 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][2][0][1] = (tmp2 * fjac[i][j][k + 1][0][1]) - (tmp1 * njac[i][j][k + 1][0][1]);\n      lhs[i][j][k][2][0][2] = (tmp2 * fjac[i][j][k + 1][0][2]) - (tmp1 * njac[i][j][k + 1][0][2]);\n      lhs[i][j][k][2][0][3] = (tmp2 * fjac[i][j][k + 1][0][3]) - (tmp1 * njac[i][j][k + 1][0][3]);\n      lhs[i][j][k][2][0][4] = (tmp2 * fjac[i][j][k + 1][0][4]) - (tmp1 * njac[i][j][k + 1][0][4]);\n      lhs[i][j][k][2][1][0] = (tmp2 * fjac[i][j][k + 1][1][0]) - (tmp1 * njac[i][j][k + 1][1][0]);\n      lhs[i][j][k][2][1][1] = ((tmp2 * fjac[i][j][k + 1][1][1]) - (tmp1 * njac[i][j][k + 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][2][1][2] = (tmp2 * fjac[i][j][k + 1][1][2]) - (tmp1 * njac[i][j][k + 1][1][2]);\n      lhs[i][j][k][2][1][3] = (tmp2 * fjac[i][j][k + 1][1][3]) - (tmp1 * njac[i][j][k + 1][1][3]);\n      lhs[i][j][k][2][1][4] = (tmp2 * fjac[i][j][k + 1][1][4]) - (tmp1 * njac[i][j][k + 1][1][4]);\n      lhs[i][j][k][2][2][0] = (tmp2 * fjac[i][j][k + 1][2][0]) - (tmp1 * njac[i][j][k + 1][2][0]);\n      lhs[i][j][k][2][2][1] = (tmp2 * fjac[i][j][k + 1][2][1]) - (tmp1 * njac[i][j][k + 1][2][1]);\n      lhs[i][j][k][2][2][2] = ((tmp2 * fjac[i][j][k + 1][2][2]) - (tmp1 * njac[i][j][k + 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][2][2][3] = (tmp2 * fjac[i][j][k + 1][2][3]) - (tmp1 * njac[i][j][k + 1][2][3]);\n      lhs[i][j][k][2][2][4] = (tmp2 * fjac[i][j][k + 1][2][4]) - (tmp1 * njac[i][j][k + 1][2][4]);\n      lhs[i][j][k][2][3][0] = (tmp2 * fjac[i][j][k + 1][3][0]) - (tmp1 * njac[i][j][k + 1][3][0]);\n      lhs[i][j][k][2][3][1] = (tmp2 * fjac[i][j][k + 1][3][1]) - (tmp1 * njac[i][j][k + 1][3][1]);\n      lhs[i][j][k][2][3][2] = (tmp2 * fjac[i][j][k + 1][3][2]) - (tmp1 * njac[i][j][k + 1][3][2]);\n      lhs[i][j][k][2][3][3] = ((tmp2 * fjac[i][j][k + 1][3][3]) - (tmp1 * njac[i][j][k + 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][2][3][4] = (tmp2 * fjac[i][j][k + 1][3][4]) - (tmp1 * njac[i][j][k + 1][3][4]);\n      lhs[i][j][k][2][4][0] = (tmp2 * fjac[i][j][k + 1][4][0]) - (tmp1 * njac[i][j][k + 1][4][0]);\n      lhs[i][j][k][2][4][1] = (tmp2 * fjac[i][j][k + 1][4][1]) - (tmp1 * njac[i][j][k + 1][4][1]);\n      lhs[i][j][k][2][4][2] = (tmp2 * fjac[i][j][k + 1][4][2]) - (tmp1 * njac[i][j][k + 1][4][2]);\n      lhs[i][j][k][2][4][3] = (tmp2 * fjac[i][j][k + 1][4][3]) - (tmp1 * njac[i][j][k + 1][4][3]);\n      lhs[i][j][k][2][4][4] = ((tmp2 * fjac[i][j][k + 1][4][4]) - (tmp1 * njac[i][j][k + 1][4][4])) - (tmp1 * dz5);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k,tmp1,tmp2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/5"}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  for (j = 0; j < matrix_size; j++)\n  {\n    A[i][j] = rand() % 10;\n    B[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nowke/hpc_lab/2_matrix/matrix/2"}
{"code": "for (i = 0; i < edge_count; i++)\n{\n  printf(\"Node %i <--> Node %i: %i\\n\", edges[i].node1, edges[i].node2, edges[i].distance);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/dijkstra_openmp/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    if (j == p.queen[i])\n    printf(\"@ \");\n  else\n    printf(\"# \");\n\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PushenGao/Parallel-Computing-/GA_Queens_OpenMp/14"}
{"code": "for (int i = 0; i < SIZE; i++)\n  for (int j = 0; j < SIZE; j++)\n  matrixa[i][j] = (matrixb[i][j] = rand() * ((float) 1.1));\n\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/23"}
{"code": "for (int i = 0; i < N; i++)\n  y[i] = (alpha * x[i]) + (beta * z[i]);\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment6/mini_app/linalg/7"}
{"code": "for (i = 1; i < LX1; i++)\n{\n  idmo[iel][face][1][0][i][LX1 - 1] = mor_s_v[0][i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/20"}
{"code": "for (int ind1 = 0; ind1 < (N + 2); ind1++)\n{\n  for (int ind2 = 0; ind2 < (N + 2); ind2++)\n  {\n    fill_array3d(array3d, N, ind2, ind1, 0, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t\t#pragma omp for schedule(dynamic, chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/6"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  if (omp_get_cancellation())\n    abort();\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/cancel-for-1/0"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (k = 0; k < K; ++k)\n  {\n    register float aA = alpha * A[(i * lda) + k];\n    for (j = 0; j < N; ++j)\n    {\n      C[(i * ldc) + j] += aA * B[(k * ldb) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/2"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    forcing[i][j][k][m] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/5"}
{"code": "for (int num = 1; num <= N; num++)\n{\n  if (isSafe(board, row, col, num))\n  {\n    board[row][col] = num;\n    solveSuduko_seq(board, row, col + 1);\n    board[row][col] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huaminghuangtw/tum-parallel-programming-assignments/week-4-homework_Sudoku/student_submission/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n  if ((*(dist + i)) <= md)\n{\n  for (int j = 0; j < d; j++)\n    *((inner + (inner_n * j)) + inner_counter) = *((X + (n * j)) + i);\n\n  *(inner_idx + inner_counter) = *(idx_list + i);\n  inner_counter++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thanosmanolis/vptree/src/vptree_openmp/5"}
{"code": "for (int i = 0; i < 16; i++)\n  L[i] |= zero[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/7"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = m - (m % 4); j < m; j++)\n  {\n    for (int k = 0; k < (n * m); k += m)\n    {\n      *((C + (i * m)) + j) += (*((A + j) + k)) * (*((A + i) + k));\n      if (m != n)\n      {\n        *((C + (j * m)) + i) += (*((A + i) + k)) * (*((A + j) + k));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubhamsinha92/Matrix-Multiplication-Project/sgemm-openmp/1"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  rho = rho + (r[j] * r[j]);\n}\n\n", "pragma": "omp for reduction(+:rho)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/11"}
{"code": "for (bx = 1; bx < (size_x - 1); ++bx)\n{\n  for (by = 1; by < ((size_y - 1) - 16); ++by)\n  {\n    idx = (bx * size_y) + by;\n    grid_current[(((2 * bx) - 1) * (ny + 1)) + ((2 * by) - 1)] = grid_red[idx][0];\n    grid_current[((2 * bx) * (ny + 1)) + (2 * by)] = grid_red[idx][1];\n    grid_current[((2 * bx) * (ny + 1)) + ((2 * by) - 1)] = grid_black[idx][0];\n    grid_current[(((2 * bx) - 1) * (ny + 1)) + (2 * by)] = grid_black[idx][1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bazk/rbgs/rbgs/6"}
{"code": "for (long int i = 0; i < N; ++i)\n{\n  for (long int j = 0; j < N; ++j)\n  {\n    A[(i * N) + j] = dis(gen);\n    B[(j * N) + i] = dis(gen);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP9/tests/matrix/0"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  double *X = X0 + ((i % cX) * rX);\n  double *Y = Y0 + ((i / cX) * rY);\n  double cc = 0.0;\n  double rc = 0.0;\n  size_t nn = 0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double t;\n    double y;\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    y = z - rc;\n    t = cc + y;\n    rc = (t - cc) - y;\n    cc = t;\n    nn++;\n  }\n\n  CC[i] = cc;\n  if (NN != NULL)\n    NN[i] = (double) nn;\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/6"}
{"code": "for (i = 0; i < 10; i++)\n  vec[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/parallel/cluster-system/openmp/reduction-omp-carte/1"}
{"code": "for (int i = 0; i < 5; ++i)\n  sum += a[i] + b[i];\n\n", "pragma": "omp for nowait reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 3/Sections/0"}
{"code": "for (i = 0; i < w_size; i++)\n{\n  final_count += succesful_col[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlexKasapis/OpenMP/Examine/6"}
{"code": "for (k = 0; k < dims[0][2]; k++)\n{\n  x0 = start;\n  vranlc((2 * 64) * dims[0][1], &x0, 1220703125.0, tmp);\n  t = 1;\n  for (j = 0; j < dims[0][1]; j++)\n    for (i = 0; i < 64; i++)\n  {\n    u0[k][j][i].real = tmp[t++];\n    u0[k][j][i].imag = tmp[t++];\n  }\n\n\n  if (k != dims[0][2])\n    dummy = randlc(&start, an);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/37"}
{"code": "for (i = 0; i < N; i++)\n  x[i] = (i + 1) * .000001;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialBase/Mapexp/parallel/mapexp/0"}
{"code": "for (unsigned current = 0; current < set->natoms; current++)\n{\n  calc_t force[3] = {0.0, 0.0, 0.0};\n  THREAD_COUNT = omp_get_num_threads();\n  atom_state[current] = omp_get_thread_num();\n  for (unsigned other = 0; other < set->natoms; other++)\n    if (current != other)\n  {\n    calc_t sq_dist = squared_distance(set, current, other);\n    if (sq_dist < LENNARD_SQUARED_CUTOFF)\n    {\n      calc_t intensity = lennard_jones(sq_dist);\n      force[0] += intensity * (set->pos.x[current] - set->pos.x[other]);\n      force[1] += intensity * (set->pos.x[set->offset + current] - set->pos.x[set->offset + other]);\n      force[2] += intensity * (set->pos.x[(set->offset * 2) + current] - set->pos.x[(set->offset * 2) + other]);\n    }\n\n  }\n\n\n  set->speed.dx[current] += force[0];\n  set->speed.dx[set->offset + current] += force[1];\n  set->speed.dx[(set->offset * 2) + current] += force[2];\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/openmp/0"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    printf(\"%d \", matriz_result[i][j]);\n  }\n\n  printf(\"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/matriz_openmp/3"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  grid[i] = (int *) malloc(2048 * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fad-andrade/GameOfLife/omp_version/2"}
{"code": "for (i = 0; i < N; ++i)\n{\n  v1[i] = i + 1;\n  for (j = 0; j < i; ++j)\n  {\n    m[i][j] = 0;\n  }\n\n  for (j = i; j < N; ++j)\n  {\n    m[i][j] = j + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/7/pvm-secuencial/1"}
{"code": "for (i = 0; i < MAX_SIZE; i++)\n  map_array[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PARCO-LDRD/benchmarks/vecAdd/vecAdd/0"}
{"code": "for (size_t i = 0; i < bloc_size; i++)\n  *(new_b + i) = *((*bloc) + i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    res.push_back(a[i + (j * n)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/netweel/Parallel-programming-OpenMP_TBB_std-thread/OpenMP/umnrazr/2"}
{"code": "for (i = 0, j = 0; j < N; i += 2, j += 2)\n{\n  x1 = _mm_load_pd(X + i);\n  y1 = _mm_load_pd(Y + i);\n  x2 = _mm_mul_pd(x1, alpha1);\n  y2 = _mm_add_pd(y1, x2);\n  _mm_store_pd(Y + i, y2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/axpy/6"}
{"code": "for (int timestep = num_timesteps - 2; timestep >= 0; --timestep)\n{\n  (compute_beta_kernel < NUM_THREADS_PER_BLOCK2) > ((num_paths, payoff, d_svds + (16 * timestep), d_paths + (timestep * num_paths), d_cashflows, d_all_out_of_the_money + timestep, d_temp_storage));\n  (update_cashflow_kernel < NUM_THREADS_PER_BLOCK2) > ((update_cashflow_grid, num_paths, payoff, exp_min_r_dt, d_temp_storage, d_paths + (timestep * num_paths), d_all_out_of_the_money + timestep, d_cashflows));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aop-omp/main/7"}
{"code": "for (block_x = 0; block_x < max_blocks_x; block_x++)\n  for (block_y = 0; block_y < max_blocks_y; block_y++)\n  copy_block(nx, ny, block_x, block_y, u_, unew_, block_size);\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/kastors-1.1/jacobi/src/jacobi-block-for/0"}
{"code": "for (int i = 0; i < 20; ++i)\n{\n  initialize(array);\n  start = omp_get_wtime();\n  odd_even_sort(array);\n  end = omp_get_wtime();\n  time += end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohorka/HPCS/openMP/Sort(ex.5)/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = b[i] + c[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/clang/test/CodeGen/opt-record-1/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_md2_context ctx;\n  sph_md2_init(&ctx);\n  sph_md2(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_md2_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/md2_fmt_plug/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  Nodes[i].p_t0 = 0;\n  Nodes[i].p_t1 = 1;\n  Nodes[i].p_t1 = ((double) Nodes[i].p_t1) / N;\n  sum_P_1 = sum_P_1 + Nodes[i].p_t1;\n  Nodes[i].e = 1;\n  Nodes[i].e = ((double) Nodes[i].e) / N;\n  sum_E_1 = sum_E_1 + Nodes[i].e;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/papadopoulosc/pagerank/1st_parallel/pagerank_openmp/3"}
{"code": "for (i = 1; i < my_height_incr_1; i++)\n  for (j = mult; j < my_width_incr_1; j++)\n  my_image_before[i][j] = rand() % 256;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double t = sqrt((inpR[2 * i] * inpR[2 * i]) + (inpR[(2 * i) + 1] * inpR[(2 * i) + 1]));\n  double delR = maxR - minR;\n  if (t != 0)\n    freq->imageData[(3 * i) + 0] = (char) ((255 * (log(t) - minR)) / delR);\n  else\n    freq->imageData[(3 * i) + 0] = 0;\n\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/15. filter (mkl)/filter/9"}
{"code": "for (int k = 1; k < n; k++)\n{\n  x[k] = x[k - 1] + y[k];\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/15"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets1186Ptr = _checkInCodelets1186(1, 1, this, codeletCounter);\n  (*checkInCodelets1186Ptr).decDep();\n  checkInCodelets1186Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/47"}
{"code": "for (int i = 1; i < (nxn - 1); i++)\n  for (int j = 1; j < (nyn - 1); j++)\n{\n  rhons[is][i][j][1] *= 2;\n  Jxs[is][i][j][1] *= 2;\n  Jys[is][i][j][1] *= 2;\n  Jzs[is][i][j][1] *= 2;\n  pXXsn[is][i][j][1] *= 2;\n  pXYsn[is][i][j][1] *= 2;\n  pXZsn[is][i][j][1] *= 2;\n  pYYsn[is][i][j][1] *= 2;\n  pYZsn[is][i][j][1] *= 2;\n  pZZsn[is][i][j][1] *= 2;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/36"}
{"code": "for (j = i + 1; j < n; j++)\n{\n  mult = matrix[(j * (n + 1)) + i];\n  if (mult != 0)\n  {\n    mult /= matrix[(i * (n + 1)) + i];\n    for (k = i; k < (n + 1); k++)\n    {\n      matrix[(j * (n + 1)) + k] -= mult * matrix[(i * (n + 1)) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k,mult) num_threads(procs)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      vijk = vs[i][j][k];\n      vp1 = vs[i][j + 1][k];\n      vm1 = vs[i][j - 1][k];\n      rhs[i][j][k][0] = (rhs[i][j][k][0] + (dy1ty1 * ((u[i][j + 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j - 1][k][0]))) - (ty2 * (u[i][j + 1][k][2] - u[i][j - 1][k][2]));\n      rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dy2ty1 * ((u[i][j + 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j - 1][k][1]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][1] * vp1) - (u[i][j - 1][k][1] * vm1)));\n      rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dy3ty1 * ((u[i][j + 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j - 1][k][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[i][j + 1][k][2] * vp1) - (u[i][j - 1][k][2] * vm1)) + ((((u[i][j + 1][k][4] - square[i][j + 1][k]) - u[i][j - 1][k][4]) + square[i][j - 1][k]) * c2)));\n      rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dy4ty1 * ((u[i][j + 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j - 1][k][3]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][3] * vp1) - (u[i][j - 1][k][3] * vm1)));\n      rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dy5ty1 * ((u[i][j + 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j - 1][k][4]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[i][j + 1][k][4] * rho_i[i][j + 1][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j - 1][k][4] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[i][j + 1][k][4]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[i][j - 1][k][4]) - (c2 * square[i][j - 1][k])) * vm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/26"}
{"code": "for (int i = 0; i < points.size(); i++)\n{\n  if (sign(points[i], min_p, max_p) < 0)\n    c1.v.push_back(points[i]);\n\n  if (sign(points[i], min_p, max_p) > 0)\n    c2.v.push_back(points[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/quick_3/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  part_sums[tid] += A[i];\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = bt * r3;\n      t2 = 0.5 * (r4 + r5);\n      rhs[0][i][j][k] = -r2;\n      rhs[1][i][j][k] = r1;\n      rhs[2][i][j][k] = bt * (r4 - r5);\n      rhs[3][i][j][k] = (-t1) + t2;\n      rhs[4][i][j][k] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (r1,r2,r3,r4,r5,t1,t2,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/84"}
{"code": "for (jj = kk + 1; jj < bots_arg_size; jj++)\n  if (BENCH[(kk * bots_arg_size) + jj] != 0)\n{\n  {\n    fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n  }\n}\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/sparselu/sparselu_for/sparselu/0"}
{"code": "for (k = (*arr_start)[2] + 1; k < (*arr_end)[2]; k++)\n{\n  for (j = (*arr_start)[1] + 1; j < (*arr_end)[1]; j++)\n  {\n    #pragma ivdep\n    #pragma vector nontemporal(outdata)\n    for (i = (*arr_start)[0] + 1; i < (*arr_end)[0]; i++)\n    {\n      outdata[(i + (j * ni)) + ((k * ni) * nj)] = ((((((indata[(i + (j * ni)) + (((k - 1) * ni) * nj)] + indata[((i - 1) + (j * ni)) + ((k * ni) * nj)]) + indata[(i + ((j - 1) * ni)) + ((k * ni) * nj)]) + indata[(i + (j * ni)) + ((k * ni) * nj)]) + indata[(i + ((j + 1) * ni)) + ((k * ni) * nj)]) + indata[((i + 1) + (j * ni)) + ((k * ni) * nj)]) + indata[(i + (j * ni)) + (((k + 1) * ni) * nj)]) / ((float) 7.0);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(static, 1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/7"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    u[i][j] = uo[i][j] + (nu * ((((uo[i - 1][j] + uo[i + 1][j]) + uo[i][j - 1]) + uo[i][j + 1]) - (4.0 * uo[i][j])));\n  }\n\n}\n\n", "pragma": "omp parallel for default (none) shared (u,uo) private (i,j) firstprivate (nx,ny, nu) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcduta/programming/heat/python/src/c_stepper/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      forcing[m][i][j][k] = (-1.0) * forcing[m][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/37"}
{"code": "for (i = 0; i < ((int) n); i++)\n  sum1 += func((from + (h * i)) + (h / 2.0));\n\n", "pragma": "omp parallel for reduction(+:sum1) shared(h,i)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Simpson/0"}
{"code": "for (j = 0; j < m; j++)\n{\n  result += A[(i * m) + j] * B[(j * n) + k];\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 1/matmul/1"}
{"code": "for (k = 0; k < (M * N); k++)\n{\n  smax = MAX(smax, s[k]);\n  smin = MIN(smin, s[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcduta/programming/reaction-diffusion/src/renderer/0"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    a[i][j] = b[i][j];\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t\t#pragma omp parallel for shared(n,b,a) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dhawal777/OpenMp-Basics/question3/solver-jacobi/1"}
{"code": "for (int i = 0; i < NB_WORDS; i++)\n{\n  printf(\"%s\\n\", array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/mapreduce-openmp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = 1.0;\n  y[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gtrabes/OpenMPExample/openmp_example/0"}
{"code": "for (i = k; i <= n; i++)\n{\n  A[((k - 1) * Alda) + (i - 1)] /= piv;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivR_OpenMP/2"}
{"code": "for (i = 1; i < (xcell + 1); i++)\n  for (j = 1; j < (ycell + 1); j++)\n  locdiff += (u[iz][i][j] - u[1 - iz][i][j]) * (u[iz][i][j] - u[1 - iz][i][j]);\n\n\n", "pragma": "omp parallel for schedule(static,1) collapse(2) default(none) private(i,j) shared (u, iz, xcell, ycell) reduction(+:locdiff)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/10"}
{"code": "for (x = 0; x < 256; x++)\n  lut[x] = CV_CAST_8U(x + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvdistransform/0"}
{"code": "for (i = iLeft; i <= iRight; i++)\n{\n  g[i][0] = v[i][0];\n  g[i][jmax] = v[i][jmax];\n}\n\n", "pragma": "omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/3"}
{"code": "for (size_t i = 0; i < l_weightData.size(); ++i)\n{\n  l_weightData.at(i) -= a_learningRate * l_gradientData.at(i);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/curiousinspiration/Optimizing-Our-Neural-Network-With-BLAS-and-OpenMP/src/linear_layer/0"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = (float) strtod(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->fvsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->ivsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/36"}
{"code": "for (size_t chunk_idx = chunk_offset; (chunk_idx * chunk_len) < word_len_in_bitmap; chunk_idx += chunk_stride)\n{\n  add_event(e_scan_accumulating_assigned_bm, chunk_idx, row, rank_in_row);\n  size_t cur_offset = word_offset_in_bitmap + (chunk_len * chunk_idx);\n  size_t cur_size = min(cur_offset + chunk_len, word_len_in_bitmap) - cur_offset;\n  size_t cur_compressed_size = incoming_compressed_counts[chunk_idx / chunk_stride];\n  unsigned long * restrict oq_bm = g.out_queue[i].bm.get_data(cur_offset, cur_size);\n  unsigned long * restrict assigned_bm = g.my_assigned_targets[i].bm.get_data(cur_offset, cur_size);\n  bitmap_andc_compressed_then_or(assigned_bm, cur_size * BITMAP_ULONG_BITS, oq_bm, cur_size * BITMAP_ULONG_BITS, oql_incoming_compressed.get(chunk_len * (chunk_idx / chunk_stride), cur_compressed_size), cur_compressed_size, cur_size * BITMAP_ULONG_BITS);\n  add_event(e_scan_done_accumulating_assigned_bm, chunk_idx, row, rank_in_row);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/22"}
{"code": "for (int r = 0; r < h; r++)\n{\n  row_start = srcData + (r * w);\n  memcpy(row_buf + gR, row_start, elemSize * w);\n  firstData = *row_start;\n  lastData = *((row_start + w) - 1);\n  for (int i = 0; i < gR; i++)\n  {\n    row_buf[i] = firstData;\n    row_buf[(i + w) + gR] = lastData;\n  }\n\n  prow = row_buf;\n  dstData = (dstData - (w * h)) + 1;\n  for (int c = 0; c < w; c++)\n  {\n    partialSum = 0.0f;\n    coef = coef1d;\n    for (int i = -gR; i <= gR; i++)\n    {\n      partialSum += (*(coef++)) * (*(prow++));\n    }\n\n    prow -= 2 * gR;\n    *dstData = partialSum;\n    dstData += h;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/1"}
{"code": "for (int i = 0; i < M; i++)\n{\n  t = 0;\n  for (int j = 0; j < N; j++)\n  {\n    t = t + pow(U[i][j], 2);\n  }\n\n  t = sqrt(t);\n  for (int j = 0; j < N; j++)\n  {\n    U[i][j] = U[i][j] / t;\n    if (i == j)\n    {\n      S[i][j] = t;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kratikakothari/IPSC_PROJECT_SVD_OPENMP/SVD_parallel/4"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_enter_data); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/5"}
{"code": "for (int j = i; j < fim_fragmento; j++)\n{\n  int numero_aleatorio = (rand() % ((max - min) + 1)) + min;\n  sequencia_aleatoria[thread] += nuc[numero_aleatorio];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/1"}
{"code": "for (i = 0; i < 1024; i += BS)\n{\n  int j;\n  for (j = i; j < (i + BS); j++)\n  {\n    a[j] = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_15/0"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm2_start = wtime();\n  for (int source = 0; source < V; ++source)\n  {\n    sssp_cpu_for_apsp(source, g);\n  }\n\n  btm2_sum = wtime() - btm2_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/1"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float AB = 0.0;\n    for (int k = 0; k < K; k++)\n    {\n      AB += A[(i * K) + k] * B[(k * N) + j];\n    }\n\n    C[(i * M) + j] = (alpha * AB) + (beta * C[(i * M) + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elegaanz/MN-TP2/src/gemm/0"}
{"code": "for (int i = 0; i < numberAVG; i++)\n{\n  isOk = isOk && TestAlgorithm(matA, false);\n  isOk = isOk && TestAlgorithm(matA, true);\n  if (isOk)\n  {\n    AVGsequentTimeWork += sequentTimeWork;\n    AVGparallTimeWork += parallTimeWork;\n    numOK++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/15"}
{"code": "for (iterator I = Types.begin(), E = Types.end(); I != E; ++I, ++IR)\n{\n  if (Context.hasSameType(QTy, *I))\n  {\n    (Diag(Range.getBegin(), err_omp_reduction_redeclared) << (*I)) << Range;\n    Diag(IR->getBegin(), note_previous_declaration) << (*IR);\n    IsValid = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/2"}
{"code": "for (i = 0; i < (strlen(dna) - strlen(rna)); i++)\n{\n  k = 1;\n  strncat(temp, rna, k);\n  temp[k] = '-';\n  temp[k + 1] = '\\0';\n  strcat(temp, rna + k);\n  if (computeOnGPU(scores, dna + i, temp, strlen(temp)) != 0)\n    MPI_Abort((MPI_Comm) 0x44000000, 172);\n\n  firstScore = getScore(scores, result->weight);\n  if (computeOnGPU2(s1, dna + i, rna, result->weight, strlen(rna)) != 0)\n    MPI_Abort((MPI_Comm) 0x44000000, 176);\n\n  if (computeOnGPU2(s2, (dna + i) + 1, rna, result->weight, strlen(rna)) != 0)\n    MPI_Abort((MPI_Comm) 0x44000000, 179);\n\n  otherScore = firstScore;\n  for (k = 1; k < strlen(rna); k++)\n  {\n    x = s1[k];\n    y = s2[k];\n    otherScore = (otherScore + x) - y;\n    if (otherScore > maxScore2)\n    {\n      maxScore2 = otherScore;\n      result->k = k + 1;\n    }\n\n  }\n\n  result->score = maxScore2;\n  if (result->score > maxScore)\n  {\n    maxScore = result->score;\n    result->offset = i;\n  }\n\n}\n\n", "pragma": "omp parallel for ordered private(i, k, firstScore, temp, x, y, otherScore, s1,s2) shared(maxScore, maxScore2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AvivHitman/MPI_OpenMP_CUDA2/main/0"}
{"code": "for (y = width; y < maxRowLimit; y += width)\n  for (x = 1; x < maxColumnLimit; x++)\n{\n  if (((!edge_pix[y + x]) && edge_pix[(y - width) + (x - 1)]) && edge_pix[(y + width) + (x + 1)])\n    edge_pix[y + x] = 255;\n\n  if (((!edge_pix[y + x]) && edge_pix[(y - width) + (x + 1)]) && edge_pix[(y + width) + (x - 1)])\n    edge_pix[y + x] = 255;\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/7"}
{"code": "for (int i = 1; i <= n; i++)\n  primes[i] = false;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/11"}
{"code": "for (int i = 0; i < (numBins * numBins); i++)\n{\n  bins[i].clear();\n}\n\n", "pragma": "#pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosjgm/High-Performance-Computing/N-body-simulation/OpenMP/1"}
{"code": "for (int i = 0; i < 2048; ++i)\n{\n  for (int j = 0; j < 256; ++j)\n  {\n    point[i].elements[j] = rand() % 25;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+kmeans/11"}
{"code": "for (int i = 0; i < len; i++)\n{\n  if (h_in[i] != h_out[h_loc[i]])\n  {\n    res = false;\n    log_warn(\"Incorrect results\");\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/opencl/test/test_scatter/1"}
{"code": "for (c1 = (c0 - ((c0 + 17) / 17)) + 1; c1 <= min(min(N - 3, c0), (c0 + (((-l) + 1) / 16)) + 1); c1 += 1)\n  for (c3 = max(l, ((16 * c0) - (16 * c1)) + 2); c3 <= min(c1 + 2, ((16 * c0) - (16 * c1)) + 17); c3 += 1)\n  for (c4 = ((N - c1) - 2) / 16; c4 <= ((((((-l) + N) - c1) + c3) - 2) / 16); c4 += 1)\n  for (c10 = max((N - c1) - 2, 16 * c4); c10 <= min(((((-l) + N) - c1) + c3) - 2, (16 * c4) + 15); c10 += 1)\n  c[(N - c1) - 2][((N - c1) + c3) - 2] += (c[(N - c1) - 2][(((N - c1) + c3) - 2) - 1] + paired(c10, ((N - c1) + c3) - 2)) ? (c[(N - c1) - 2][c10 - 1] + c[c10 + 1][(((N - c1) + c3) - 2) - 1]) : (0);\n\n\n\n\n", "pragma": "  #pragma omp parallel for shared(c0) private(c1, c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/counting/counting/5"}
{"code": "for (size_t i = 0; i < blocks_.size(); i++)\n{\n  blocks_[i]->Or(bitvector->GetBVBlock(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fzqneo/ByteSlice/src/bitvector/1"}
{"code": "for (i = 1; i <= proc_rows; i++)\n  for (j = 1; j <= proc_columns; j++)\n  matrix[((proc_columns + 2) * i) + j] = DEAD;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yorgosk/game-of-life/MPI_OpenMp/functions_mpi_openmp/5"}
{"code": "for (int i = 5; i <= i; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/49"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  while (edge_degree_array[i] < 512)\n  {\n    int random_index = rand() % 40000;\n    int edge_weight = (rand() % 100000) + 1;\n    if (((graph[(random_index * 40000) + i] == 0) && (graph[(i * 40000) + random_index] == 0)) && (random_index != i))\n    {\n      graph[(random_index * 40000) + i] = edge_weight;\n      graph[(i * 40000) + random_index] = edge_weight;\n      edge_degree_array[i] += 1;\n      edge_degree_array[random_index] += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/8"}
{"code": "for (j = 0; j < verybig; j++)\n{\n  int id = omp_get_thread_num();\n  long k;\n  sum[id] += 1;\n  sumx[id] = 0.0;\n  for (k = 0; k < j; k++)\n    sumx[id] = sumx[id] + ((double) k);\n\n  sumy[id] = 0.0;\n  for (k = j; k > 0; k--)\n    sumy[id] = sumy[id] + ((double) k);\n\n  if (sumx[id] > 0.0)\n    total[id] = total[id] + (1.0 / sqrt(sumx[id]));\n\n  if (sumy[id] > 0.0)\n    total[id] = total[id] + (1.0 / sqrt(sumy[id]));\n\n}\n\n", "pragma": "#pragma omp parallel for private(sumx, sumy, k) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /parallel_for_loop/0"}
{"code": "for (i = 0; i <= (NQ - 1); i++)\n{\n  q[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/EP/ep/3"}
{"code": "for (unsigned int i = 0; i < size; i++)\n  fread(&h_MT[i], sizeof(mt_struct_stripped), 1, fd);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mt-omp/MT/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = rand() % n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/bitonic-sort-project/src/openmp/bitonic_sort_openmp/3"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    mass_flux_x[FTNREF2D(j, y_max + k, x_max + 5, x_min - 2, y_min - 2)] = mass_flux_x[FTNREF2D(j, y_max - k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/49"}
{"code": "for (int i = 0; i < NB_CARS; i++)\n{\n  printf(\"%d \", stoppedCars[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/martamorg/PPAR_openmp/traffic-openmp/3"}
{"code": "for (int i = 1; i < omp_get_max_threads(); i++)\n{\n  result->insert(result->end(), vectors[i].begin(), vectors[i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/NonZeroElements/0"}
{"code": "for (int i = 0; i < plength; ++i)\n{\n  for (int j = 0; j < pwidth; ++j)\n  {\n    for (int k = 0; k < pheight; ++k)\n    {\n      if (surface[(((i * pwidth) + j) * pheight) + k])\n        surfaceVoxels.push(voxel(i, j, k));\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebastiandaberdaku/VoxMeshSurfOpenMP/src/MolecularSurface/MolecularSurface/6"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      const int index = (((ii * _chunk.x) * _chunk.y) + (jj * _chunk.x)) + kk;\n      const double smvp = SMVP(sd);\n      r[index] -= smvp;\n      u[index] += sd[index];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_ppcg_kernel/1"}
{"code": "for (j = 0; j < n; ++j)\n  array[j] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/pi/pi_parallel_array/2"}
{"code": "for (int i = 1; i < (height - 1); i++)\n{\n  for (int j = 1; j < (width - 1); j++)\n  {\n    int sum = ((((((((filter[0][0] * imageData[i - 1][j - 1]) + (filter[0][1] * imageData[i - 1][j])) + (filter[0][2] * imageData[i - 1][j + 1])) + (filter[1][0] * imageData[i][j - 1])) + (filter[1][1] * imageData[i][j])) + (filter[1][2] * imageData[i][j + 1])) + (filter[2][0] * imageData[i + 1][j - 1])) + (filter[2][1] * imageData[i + 1][j])) + (filter[2][2] * imageData[i + 1][j + 1]);\n    int avg = sum / filterSum;\n    if (abs(avg - imageData[i][j]) <= THRESHOLD)\n      processedDataParallel[i][j] = avg;\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MUKUL821/Picturesque--Image-Processing/imageold/3"}
{"code": "for (ii = 0; ii < 10; ii = ii + ii)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/23"}
{"code": "for (int kk = 0; kk < (N + 2); kk += 2)\n{\n  for (int ii = 0; ii < (N + 2); ii += 2)\n  {\n    fill_array3d(new_X, N / 2, ii / 2, 0, kk / 2, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/8"}
{"code": "for (int i = 0; i < NI; i++)\n{\n  B[i] = A[i];\n}\n\n", "pragma": "  #pragma omp parallel for use(hrw) module(loopback)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/loopback/sw/src/main/1"}
{"code": "for (int i = 0; i < imageHeight; i++)\n{\n  fout << output[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /Mandelbrot/for/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  printf(\"[\");\n  for (int j = 0; j < size; j++)\n  {\n    printf(\" %e \", matrix[(i * size) + j]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/absurdistFrank/OpenMPFinal/Matrix/2"}
{"code": "for (int j = 0; j <= i; j++)\n{\n  cout << \">>>>\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nanyuu/Matrix-multiplication-OpenMP/OpenMP/1"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_32 * 1)\n{\n  pbkdf2_md5((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_MDx_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-md5_fmt_plug/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  k = grid_points[2] - 3;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])));\n  k = grid_points[2] - 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (5.0 * ue[k][m])));\n}\n\n", "pragma": "omp parallel for firstprivate(dssp ,k ,m ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/35"}
{"code": "for (i = 0; i < (m - 1); i++)\n{\n  if (ten[i][ind] > ten[i + 1][ind])\n  {\n    temp = ten[i + 1][ind];\n    ten[i + 1][ind] = ten[i][ind];\n    ten[i][ind] = temp;\n    j_temp = j1[i + 1][ind];\n    j1[i + 1][ind] = j1[i][ind];\n    j1[i][ind] = j_temp;\n    j_temp = j2[i + 1][ind];\n    j2[i + 1][ind] = j2[i][ind];\n    j2[i][ind] = j_temp;\n    j_temp = j3[i + 1][ind];\n    j3[i + 1][ind] = j3[i][ind];\n    j3[i][ind] = j_temp;\n  }\n  else\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/28"}
{"code": "for (id = 0; (id < GetNumTuples()) && (infile >> val); id++)\n{\n  SetTuple(id, val);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fzqneo/ByteSlice/src/column/0"}
{"code": "for (int k = 0; k < lda; k += LARGE_K)\n{\n  int K = (LARGE_K < (lda - k)) ? (LARGE_K) : (lda - k);\n  divide_into_small_blocks(weird_A + ((i * lda) + (k * 8)), B + ((j * lda) + k), C + ((j * lda) + i), M, N, K, lda);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/10"}
{"code": "for (int i = 0; i < M; i++)\n{\n  vector[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task9/0"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (4 * nxhd) * i;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 + (4 * j)) + joff]);\n    at2 = crealf(f[(2 + (4 * j)) + joff]);\n    f[(2 + (4 * j)) + joff] = crealf(f[(1 + (4 * j)) + joff]) + (crealf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n    f[(1 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (at1 * _Complex_I);\n    f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(4 * j1) + joff];\n      t2 = f[(1 + (4 * j1)) + joff];\n      t3 = f[(2 + (4 * j1)) + joff];\n      f[(4 * j1) + joff] = f[(4 * j) + joff];\n      f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n      f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n      f[(4 * j) + joff] = t1;\n      f[(1 + (4 * j)) + joff] = t2;\n      f[(2 + (4 * j)) + joff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = sct[kmr * j];\n        t2 = t1 * f[((4 * j) + k2) + joff];\n        t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n        t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n        f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n        f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n        f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n        f[((4 * j) + k1) + joff] += t2;\n        f[((1 + (4 * j)) + k1) + joff] += t3;\n        f[((2 + (4 * j)) + k1) + joff] += t4;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxy / nx;\n  ani = 0.5 / (((float) nx) * ((float) ny));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 3; jj++)\n    {\n      t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n      t1 = f[(jj + (4 * j)) + joff] + t2;\n      t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n      f[(jj + (4 * j)) + joff] = ani * (t1 + t2);\n      f[(jj + (4 * (nxh - j))) + joff] = ani * conjf(t1 - t2);\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (jj = 0; jj < 3; jj++)\n  {\n    f[(jj + (4 * nxhh)) + joff] = ani * conjf(f[(jj + (4 * nxhh)) + joff]);\n    f[jj + joff] = ani * ((crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,at1,at2,ani,t1,t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/23"}
{"code": "for (i = 0; i < point_count; i++)\n{\n  (((debug_out << pnts[2 * i]) << \" \") << pnts[(2 * i) + 1]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qtclustering-omp/QTC/4"}
{"code": "for (int y = 0; y < radius; ++y)\n{\n  {\n    int last_x = circleRows[y];\n    int x = last_x;\n    while (((x * x) + (y * y)) < (radius * radius))\n    {\n      offsets.emplace_back(y, x);\n      ++x;\n    }\n\n    circleRows[y] = x;\n  }\n}\n\n", "pragma": "        #pragma omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muji-4ok/pixel-sort-qt5/sorter/6"}
{"code": "for (int i = 0; i < keys.size(); ++i)\n{\n  cout << sketch_to_json(keys[i], mins[i], sketchlens[i], kmer, sketch_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/1"}
{"code": "for (i = 0; i < nvtxs; i++)\n  gk_i32pqInsert(queue, i, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/7"}
{"code": "for (int kk = 0; (kk < FlowNode2D) < FP, NumEq; kk++)\n{\n  RMS[kk] = 0.;\n  iRMS[kk] = 0;\n  sumDiv[kk] = 0.;\n  DD_max[rank].DD[kk].RMS = 0.;\n  DD_max[rank].DD[kk].iRMS = 0;\n  DD_max[rank].DD[kk].sumDiv = 0;\n  DD_max[rank].DD[kk].DD = 0.;\n  DD_max[rank].DD[kk].i = 0;\n  DD_max[rank].DD[kk].j = 0;\n  DD_local[kk] = 0.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  if (!memcmp(binary, crypt_out[index], (20 - 2) - 2))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/aix_ssha_fmt_plug/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    fac2 = 1. / lhs[n + 2][i1][j][k];\n    rhs[m][i1][j][k] = fac2 * rhs[m][i1][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/171"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    fill_array3d(vector_out, N, ii, 0, kk, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/matvecAv/1"}
{"code": "for (i = 1; i < 3; i++)\n  for (j = 0; j < foo(); j++)\n{\n  globalfloat = ((float) j) / i;\n  float res = b[j] * c[j];\n  a[i] = res * d[i];\n  localint = (int) j;\n}\n\n\n", "pragma": "  #pragma omp for simd collapse(2) private(globalfloat, localint)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/6"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      xvel = us[i][j][k];\n      yvel = vs[i][j][k];\n      zvel = ws[i][j][k];\n      ac = speed[i][j][k];\n      acinv = ainv[i][j][k];\n      ac2u = ac * ac;\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      uzik1 = u[0][i][j][k];\n      btuz = bt * uzik1;\n      t1 = (btuz * acinv) * (r4 + r5);\n      t2 = r3 + t1;\n      t3 = btuz * (r4 - r5);\n      rhs[0][i][j][k] = t2;\n      rhs[1][i][j][k] = ((-uzik1) * r2) + (xvel * t2);\n      rhs[2][i][j][k] = (uzik1 * r1) + (yvel * t2);\n      rhs[3][i][j][k] = (zvel * t2) + t3;\n      rhs[4][i][j][k] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[i][j][k] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(t1 ,t2 ,t3 ,ac ,xvel ,yvel ,zvel ,r1 ,r2 ,r3 ,r4 ,r5 ,btuz ,ac2u ,uzik1 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/92"}
{"code": "for (i = 0; i < 8192; i++)\n  dot += X[i] * Y[i];\n\n", "pragma": "omp parallel for schedule(static) reduction(+ : dot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/1"}
{"code": "for (i = 0; i < 16; ++i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_misc_messages/0"}
{"code": "for (j = 0; j < (strp_rows * ncols); j++)\n{\n  strp_buffer[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/1"}
{"code": "for (i = 0; i < 62; i++)\n{\n  for (j = 0; j < 7; j++)\n  {\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_mm/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  matriz[i] = (float *) malloc((sizeof(float)) * N);\n  for (j = 0; j < N; j++)\n  {\n    matriz[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaquinVillagra/Laboratorio_2_HPC/wave/3"}
{"code": "for (int l = 0; l < DATA_SIZE; l++)\n{\n  fprintf(fp, \"%d\\n\", data[l]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/12"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((((m != centre) && (m != ind1)) && (m != ind2)) && (m != ind3))\n  {\n    if ((min4 == (-1.0)) || (dist_list[m] < min4))\n    {\n      min4 = dist_list[m];\n      ind4 = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/18"}
{"code": "for (c = low; c <= high; c++)\n{\n  my_list2[c - low] = 0;\n}\n\n", "pragma": "omp parallel for private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/sieve/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  imgFloatPtr[i] = ((float) ((unsigned char) imgCharPtr[i])) / 255.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/freesdyla/Math-424-Semester-Project/stereo/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"%2.5f \", A[(i * n) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/final/bd_omp_myc/3"}
{"code": "for (int i = 0; i < num; ++i)\n{\n  float curr_error = fabs((x_new[i] - x[i]) / x_new[i]);\n  if (curr_error > err_round)\n    err_round = curr_error;\n\n  x[i] = x_new[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arnav-kansal/parallel_linsolver/source/gs/7"}
{"code": "for (i = 0; i < NPOINTS; i++)\n{\n  for (j = 0; j < NPOINTS; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) NPOINTS))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) NPOINTS)) + eps;\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(c,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/10Kaiser10/OpenMP-Learn/Exercises/041_Mandel/0"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < n1; i1++)\n    {\n      r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n      r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      u[i3][i2][i1] = ((u[i3][i2][i1] + (c[0] * r[i3][i2][i1])) + (c[1] * ((r[i3][i2][i1 - 1] + r[i3][i2][i1 + 1]) + r1[i1]))) + (c[2] * ((r2[i1] + r1[i1 - 1]) + r1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i1 ,i2 ,i3 ,r1 ,r2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/0"}
{"code": "for (i = 1; i < (500 - 1); i++)\n{\n  for (j = 1; j < (500 - 1); j++)\n  {\n    w[i][j] = mean;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/6"}
{"code": "for (i = 0; i < numtasks; i++)\n{\n  sendcounts[i] = sendcounts[i] - (2 * 3000);\n  displs[i] = offset;\n  offset += sendcounts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/5"}
{"code": "for (k = 1; k <= (n - 1); k++)\n{\n  l = ipvt[k - 1];\n  t = b[l - 1];\n  if (l != k)\n  {\n    b[l - 1] = b[k - 1];\n    b[k - 1] = t;\n  }\n\n  saxpy(n - k, t, (a + k) + ((k - 1) * lda), 1, b + k, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/16"}
{"code": "for (i = 0; i < settings.R; i++)\n{\n  for (j = 0; j < settings.C; j++)\n  {\n    current_idx = (i * settings.C) + j;\n    if (eco[current_idx].type != EMPTY)\n    {\n      fprintf(f, \"%s %d %d\\n\", types_in_string[eco[current_idx].type], i, j);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/13"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA256][32];\n  unsigned char output[4096] = {0};\n  int i;\n  unsigned char *tag = (cur_salt->ct + cur_salt->ctlen) - cur_salt->tag_len;\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n  {\n    memset(output, 0, 4096);\n    aes_ccm_auth_decrypt(master[i], 256, cur_salt->ctlen - cur_salt->tag_len, cur_salt->iv, 13, cur_salt->add, cur_salt->addlen, cur_salt->ct, output, tag, cur_salt->tag_len);\n    if ((cur_salt->ctlen - cur_salt->tag_len) == 2)\n    {\n      if (strncmp((const char *) output, \"[]\", 2) == 0)\n        cracked[index + i] = 1;\n\n    }\n    else\n    {\n      if (output[0] != '[')\n        cracked[index + i] = 0;\n      else\n        if (strstr((const char *) output, \"\\\"updated\\\"\"))\n        cracked[index + i] = 1;\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/padlock_fmt_plug/2"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    D[(i * N) + j] *= d;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/2"}
{"code": "for (i = 0; i < num_snp; i++)\n  for (j = 0; j < PP_zeros; j++)\n{\n  bin_data_zeros_trans[(((j * num_snp) + i) * 2) + 0] = bin_data_zeros[(((i * PP_zeros) + j) * 2) + 0];\n  bin_data_zeros_trans[(((j * num_snp) + i) * 2) + 1] = bin_data_zeros[(((i * PP_zeros) + j) * 2) + 1];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/epistatis-omp/main/9"}
{"code": "for (i = 0; i < N_gas; i++)\n  if (P[i].Ti_endstep == All.Ti_Current)\n{\n  SphP[i].DtEntropy *= GAMMA_MINUS1 / (hubble_a2 * pow(SphP[i].Density, GAMMA_MINUS1));\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/hydra/4"}
{"code": "for (int i = 0; i < maxThreads; i++)\n{\n  vertexSetClear(&threadFrontiers[i]);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/0"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%.2f\\n\", b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/gauss/2"}
{"code": "for (int i = 0; i < num_nodes; i++)\n{\n  shipNodes[i] = i + active_col;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/4"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < HALO.y; j++)\n  {\n    for (int i = 0; i < SDMGeom->L_NodeX(); i++)\n    {\n      indx1 = (i + (j * NodLoc.x)) + ((k * HALO.y) * NodLoc.x);\n      indx2 = ((HALO.x + i) + ((j + HALO.y) * SDMGeom->HALO_NodeX())) + (((k + HALO.z) * SDMGeom->HALO_NodeX()) * SDMGeom->HALO_NodeY());\n      BN[indx1] = DomLoc[indx2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_omp)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/5"}
{"code": "for (z = slice_start; z < slice_end; z++)\n{\n  if (A[z].valid)\n  {\n    if (0 == supersteps)\n    {\n      edge *curr;\n      for (curr = A[z].edge_head; curr != 0; curr = curr->next)\n      {\n        send_message(curr->id, z, A[z].kcore, A);\n      }\n\n    }\n    else\n    {\n      if (1 == (supersteps & 1))\n      {\n        offsets[tid] += process_message(z, A);\n      }\n      else\n      {\n        if (A[z].active)\n        {\n          edge *curr;\n          for (curr = A[z].edge_head; curr != 0; curr = curr->next)\n          {\n            send_message(curr->id, z, A[z].kcore, A);\n            offsets[tid] = 1;\n          }\n\n        }\n        else\n        {\n          printf(\"%d is not active\\n\", z);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tjj5036/kcore-openmp/parallel_kcore/11"}
{"code": "for (int i = 0; i < in.rows; i++)\n{\n  for (int j = 0; j < in.cols; j++)\n  {\n    out.data[(i * out.step) + j] = ((0.114 * in.data[(i * in.step) + (j * 3)]) + (0.587 * in.data[((i * in.step) + (j * 3)) + 1])) + (0.299 * in.data[((i * in.step) + (j * 3)) + 2]);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/main/2"}
{"code": "for (int i = 0; i < numRuns; ++i)\n{\n  double startTime = currentSeconds();\n  printf(\"Sum:%lf \\n\", reduction_serial(size, arr_serial, do_square));\n  double endTime = currentSeconds();\n  minSerial = min(minSerial, endTime - startTime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artalukd/toRustOrNot/C++/reduction/main/3"}
{"code": "for (i = 0; i < 600; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/sum_array_barrier_openmp/0"}
{"code": "for (int i = 0; i < _quentityElement; i++)\n{\n  _vecOne[i].x = (rand() % _quentityElement) + 0;\n  _vecOne[i].y = (rand() % _quentityElement) + 0;\n  _vecSecond[i].x = (rand() % _quentityElement) + 0;\n  _vecSecond[i].y = (rand() % _quentityElement) + 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgavrisyuk/OpenMP/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum_r = sum_r + ((a[i] - mean_a) * (b[i] - mean_b));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/knal1992/Pearson-Correlation-OpenMP/OMP/5"}
{"code": "for (int j = 1; j <= (numBins - 2); j++)\n{\n  bins_apply_force(bins[j], bins[j - 1], &dmin, &davg, &navg);\n  self_bins_apply_force(bins[j], &dmin, &davg, &navg);\n  bins_apply_force(bins[j], bins[j + 1], &dmin, &davg, &navg);\n  bins_apply_force(bins[j], bins[(numBins + j) - 1], &dmin, &davg, &navg);\n  bins_apply_force(bins[j], bins[numBins + j], &dmin, &davg, &navg);\n  bins_apply_force(bins[j], bins[(numBins + j) + 1], &dmin, &davg, &navg);\n}\n\n", "pragma": "#pragma omp for reduction(+:davg) reduction(+:navg) schedule(guided) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosjgm/High-Performance-Computing/N-body-simulation/OpenMP/3"}
{"code": "for (i = startFrom + 1; i <= (startFrom + rowsToReceive); i++)\n{\n  vtemp[i - 1] = A[((i - 1) * Alda) + (k - 1)];\n  A[((i - 1) * Alda) + (k - 1)] = A[((i - 1) * Alda) + (iPiv - 1)];\n  A[((i - 1) * Alda) + (iPiv - 1)] = vtemp[i - 1];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivR_OpenMP_MPI/0"}
{"code": "for (int i = 0; i < SubPtcl.size(); i++)\n  (os << SubPtcl[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/14"}
{"code": "for (int i = 0; i < size; i++)\n{\n  outG[2 * i] = outG[2 * i] * f[i];\n  outG[(2 * i) + 1] = outG[(2 * i) + 1] * f[i];\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/9"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    collen[rowind[j]]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/51"}
{"code": "for (int gid = 0; gid < num; gid++)\n{\n  for (int i = 0; i < dim; ++i)\n  {\n    for (int j = 0; j < dim; ++j)\n    {\n      for (int k = 0; k < dim; ++k)\n      {\n        sigma_out[sigma_imag(i, j)] -= hamiltonian[ham_real(i, k)] * sigma_in[sigma_real(k, j)];\n        sigma_out[sigma_imag(i, j)] += sigma_in[sigma_real(i, k)] * hamiltonian[ham_real(k, j)];\n        sigma_out[sigma_imag(i, j)] += hamiltonian[ham_imag(i, k)] * sigma_in[sigma_imag(k, j)];\n        sigma_out[sigma_imag(i, j)] -= sigma_in[sigma_imag(i, k)] * hamiltonian[ham_imag(k, j)];\n        sigma_out[sigma_real(i, j)] += hamiltonian[ham_real(i, k)] * sigma_in[sigma_imag(k, j)];\n        sigma_out[sigma_real(i, j)] -= sigma_in[sigma_real(i, k)] * hamiltonian[ham_imag(k, j)];\n        sigma_out[sigma_real(i, j)] += hamiltonian[ham_imag(i, k)] * sigma_in[sigma_real(k, j)];\n        sigma_out[sigma_real(i, j)] -= sigma_in[sigma_imag(i, k)] * hamiltonian[ham_real(k, j)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp target teams distribute parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hexciton-omp/main/4"}
{"code": "for (int i = 0; i < LINHAS; ++i)\n{\n  for (int j = 0; j < COLUNAS; ++j)\n  {\n    m1[i][j] = dist6(rng);\n    m2[j][i] = dist6(rng);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hugotomazi/parallelism/Problema1/OpenMP/main/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  dky2 = dky * dky;\n  kj = (4 * nxvh) * k;\n  k1 = ((4 * nxvh) * ny) - kj;\n  #pragma ivdep\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1. / ((dkx * dkx) + dky2);\n    zt1 = at1 * ((dkx * cu[(4 * j) + kj]) + (dky * cu[(1 + (4 * j)) + kj]));\n    cu[(4 * j) + kj] -= dkx * zt1;\n    cu[(1 + (4 * j)) + kj] -= dky * zt1;\n    zt1 = at1 * ((dkx * cu[(4 * j) + k1]) - (dky * cu[(1 + (4 * j)) + k1]));\n    cu[(4 * j) + k1] -= dkx * zt1;\n    cu[(1 + (4 * j)) + k1] += dky * zt1;\n  }\n\n  cu[1 + kj] = zero;\n  cu[k1] = zero;\n  cu[1 + k1] = zero;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kj,dky,dky2,dkx,at1,zt1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/16"}
{"code": "for (vi = nvtxs >> 2; vi < nvtxs; vi++)\n{\n  if (((txadj[vi + 1] - txadj[vi]) << 9) > vi)\n    break;\n\n  if (((xadj[vi + 1] - xadj[vi]) << 4) > (nvtxs - vi))\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/14"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    A[i][j] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/2"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  double *weight_sum = &data0[5 * n_op];\n  double *residual_sum = &data1[1 * n_op];\n  *weight_sum = 0.0;\n  residual_sum[VAR_DENSITY] = 0.0;\n  residual_sum[VAR_MOMENTUM + 0] = 0.0;\n  residual_sum[VAR_MOMENTUM + 2] = 0.0;\n  residual_sum[VAR_MOMENTUM + 1] = 0.0;\n  residual_sum[VAR_DENSITY_ENERGY] = 0.0;\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/down_v2_kernel_pre_omp4kernel_func/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  ru1 = rho_i[i][j][k];\n  uu = us[i][j][k];\n  vv = vs[i][j][k];\n  ww = ws[i][j][k];\n  ac = speed[i][j][k];\n  ac2inv = ainv[i][j][k] * ainv[i][j][k];\n  r1 = rhs[0][i][j][k];\n  r2 = rhs[1][i][j][k];\n  r3 = rhs[2][i][j][k];\n  r4 = rhs[3][i][j][k];\n  r5 = rhs[4][i][j][k];\n  t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n  t2 = (bt * ru1) * ((uu * r1) - r2);\n  t3 = ((bt * ru1) * ac) * t1;\n  rhs[0][i][j][k] = r1 - t1;\n  rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n  rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n  rhs[3][i][j][k] = (-t2) + t3;\n  rhs[4][i][j][k] = t2 + t3;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,ru1 ,uu ,vv ,ww ,ac ,ac2inv ,r1 ,r2 ,r3 ,r4 ,t1 ,t2 ,t3 ,c2 ,bt ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/156"}
{"code": "for (j = 0; j < VERYBIG; j++)\n{\n  int id;\n  id = omp_get_thread_num();\n  sum[id][0] += 1;\n  sumx = 0.0;\n  for (k = 0; k < j; k++)\n    sumx = sumx + ((double) k);\n\n  sumy = 0.0;\n  for (k = j; k > 0; k--)\n    sumy = sumy + ((double) k);\n\n  if (sumx > 0.0)\n    total[id][0] = total[id][0] + (1.0 / sqrt(sumx));\n\n  if (sumy > 0.0)\n    total[id][0] = total[id][0] + (1.0 / sqrt(sumy));\n\n}\n\n", "pragma": "omp parallel for private(k, sumx, sumy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smohammadhejazi/multicore-programming-lab/1/code/3/0"}
{"code": "for (int i = 0; i < ((int) mols.count); i++)\n{\n  SafeDeleteArray(cosMolRef[i]);\n  SafeDeleteArray(sinMolRef[i]);\n  SafeDeleteArray(cosMolBoxRecip[i]);\n  SafeDeleteArray(sinMolBoxRecip[i]);\n}\n\n", "pragma": "  #pragma omp parallel for default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/0"}
{"code": "for (int i = 0; i < my_num_particles; i++)\n{\n  prev_acceleration[i].x = acceleration[i].x;\n  prev_acceleration[i].y = acceleration[i].y;\n  prev_acceleration[i].z = acceleration[i].z;\n  acceleration[i].x = 0;\n  acceleration[i].y = 0;\n  acceleration[i].z = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jankopanski/Three-Body-Problem/body3_mpi_omp/1"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"%d\\n\", tenNums[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shakram02/OpenMPSample/OpenMPSample/OpenMPSample/1"}
{"code": "for (i = 0; i < (2 * n); i++)\n  if (vla[i] != ' ')\n  __builtin_abort();\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.c/pr45784/1"}
{"code": "for (int i = 0; i < threads; i++)\n{\n  timings[i] = get_time();\n  s2_hard += S2_hard_OpenMP_thread(x, y, z, c, segment_size, segments_per_thread, i, low, limit, alpha, factors, pi, primes, mu_sum[i], phi[i]);\n  timings[i] = get_time() - timings[i];\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(threads) reduction(+: s2_hard)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primesum/src/deleglise-rivat/S2_hard/2"}
{"code": "for (k = 0; k < omp_get_max_threads(); k++)\n{\n  dmax_t[k] = 0.0;\n  istart[k] = 1 + (ib * k);\n  iend[k] = (k + 1) * ib;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/7"}
{"code": "for (int i = 0; i < NUM_TEST; i++)\n{\n  srand(124);\n  double **mat = create2DArray(N, N + 1);\n  fill2DArray(mat, N, N + 1);\n  displayMatrix(mat);\n  omp_set_num_threads(NUM_THREADS);\n  startTime = omp_get_wtime();\n  gaussianElimination(mat);\n  endTime = omp_get_wtime() - startTime;\n  printf(\"Test %d: %f seconds\\n\", i + 1, endTime);\n  totalTime += endTime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/koksing456/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/OpenMP/OpenMP/parallel/6"}
{"code": "for (i = 0; i < 16; i++)\n  c[i + 32] = i + 32;\n\n", "pragma": "omp parallel for schedule (nonmonotonic: guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/20"}
{"code": "for (j = 1; j < num_data; j += 2)\n{\n  if (par_data[j - 1] > par_data[j])\n  {\n    par_tmp = par_data[j - 1];\n    par_data[j - 1] = par_data[j];\n    par_data[j] = par_tmp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_sort/0"}
{"code": "for (int j = 0; j < k; j++)\n{\n  findHull(xc[j], yc[j], clust_size[j], con_x, con_y, &con_n);\n  printf(\"\\n\\nCluster %d; tid=%d\\n\", j + 1, omp_get_thread_num());\n  for (int i = 0; i < con_n; i++)\n  {\n    fin_x[fin_n + i] = con_x[i];\n    fin_y[fin_n + i] = con_y[i];\n    printf(\"(%d,%d)\\n\", con_x[i], con_y[i]);\n  }\n\n  fin_n += con_n;\n  printf(\"l_n=%d,g_n=%d\\n\", con_n, fin_n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/serial/pc/1"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  total += myArray[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(myArray) firstprivate(ARRAY_SIZE) reduction(+: total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rookiehpc/rookiehpc.github.io/openmp/docs/reduction/example_1/0"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets729Ptr = _checkInCodelets729(1, 1, this, codeletCounter);\n  (*checkInCodelets729Ptr).decDep();\n  checkInCodelets729Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/21"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  printf(\"%lf \", A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariakhaetskaya/Parallel-Programming/OpenMP-SLE-Solver/main/5"}
{"code": "for (j = jbeg; j <= jfin; j += 1)\n{\n  jglob = j;\n  for (k = ki1; k <= ki2; k += 1)\n  {\n    phi2[j][k] = 0.40e+00 * (u[ifin][j][k][4] - ((0.50 * (((u[ifin][j][k][1] * u[ifin][j][k][1]) + (u[ifin][j][k][2] * u[ifin][j][k][2])) + (u[ifin][j][k][3] * u[ifin][j][k][3]))) / u[ifin][j][k][0]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (jglob,j,k) firstprivate (jfin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/79"}
{"code": "for (i = 1; i < n; i++)\n{\n  j = i;\n  temp_j = start + j;\n  temp_jprev = temp_j - 1;\n  while ((j > 1) && (temp_j->x[dim] < temp_jprev->x[dim]))\n  {\n    swap(start + j, (start + j) - 1);\n    j = j - 1;\n    temp_j = start + j;\n    temp_jprev = temp_j - 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ImolaFodor/kdtree-parallel-construct/kdtree_build_2_tasks_openmp/0"}
{"code": "for (c1 = 0; c1 <= 127; c1++)\n{\n  for (c2 = 0; c2 <= 127; c2++)\n  {\n    E[c1][c2] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/35"}
{"code": "for (unsigned i = 0; i < width; i++)\n{\n  for (unsigned j = 0; j < height; j++)\n  {\n    a[(i * width) + j] = (i * width) + j;\n    b[(i * width) + j] = (i == j) ? (2) : (0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/mm-large/mm-large/3"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (cj = ci + 1; cj < NCELLS; cj++)\n    nc += contacts(ci, cj);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/33"}
{"code": "for (int i = 0; i < levels; i++)\n  for (int j = 2; j < scaleCycles; j++)\n{\n  int scaleCyclesLevel = scaleCycles * i;\n  size_t c = (((scaleCycles - 2) * i) + j) - 2;\n  localWrappers[c] = Wrapper(sp, ap, hessResps[(j + scaleCyclesLevel) - 1], hessResps[j + scaleCyclesLevel], hessResps[(j + scaleCyclesLevel) + 1], blurs[(j + scaleCyclesLevel) - 1], blurs[j + scaleCyclesLevel]);\n  float curSigma = par.sigmas[j];\n  findLevelKeypoints(curSigma, pixelDistances[i], localWrappers[c]);\n  localfindAffineShapeArgs.insert(localfindAffineShapeArgs.end(), localWrappers[c].findAffineShapeArgs.begin(), localWrappers[c].findAffineShapeArgs.end());\n}\n\n\n", "pragma": "\t#pragma omp for collapse(2) schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucaLovagnini/parallelHesaff/src/pyramid/5"}
{"code": "for (int i = 1; i < size; i++)\n{\n  displ_array[i] = dimension_array[i - 1] + displ_array[i - 1];\n  recv_buf_dim += dimension_array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/main/3"}
{"code": "for (size_t l_el = 0; l_el < nEls(); l_el++)\n{\n  io_elChars[l_el].spType |= l_spTypeEl[l_el];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/mesh/EdgeV/12"}
{"code": "for (int i = 0; i < n; i++)\n{\n  qrdecomp_iter_noq(a, m, n, u, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/16"}
{"code": "for (i = 0; i < num_elements; i++)\n  for (j = 0; j < num_elements; j++)\n  U.elements[(num_elements * i) + j] = A.elements[(num_elements * i) + j];\n\n\n", "pragma": "omp parallel for default(none) shared(num_elements,U) private(i, j) schedule(dynamic,32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/gaussian/gauss_eliminate/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  List[i] = (i + 1) * (i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 3/Loop/1"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  if (costarr[i] >= COST_OBS)\n    ntot++;\n\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:ntot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/9"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n{\n  int odd = i & 1;\n  for (int j = 2 - odd; j < (nx - 1); j += 2)\n  {\n    in[(i * nx) + j] = 0.25 * ((((in[((i * nx) + j) + 1] + in[((i * nx) + j) - 1]) + in[((i - 1) * nx) + j]) + in[((i + 1) * nx) + j]) - (hxhy * f[(i * nx) + j]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/jacobi_omp/0"}
{"code": "for (int i = 0; i < 100; i++)\n  if (a[i] != (((-1) + i) + (2 * i)))\n{\n  printf(\"Error at %d: device = %d, host = %d\\n\", i, a[i], ((-1) + i) + (2 * i));\n  fail = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  arr1[i] = i;\n  arr2[i] = i;\n}\n\n", "pragma": "      #pragma omp for schedule(dynamic, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/vector_add/vector_add/0"}
{"code": "for (i = 0; i < nsub; i++)\n{\n  node[0 + (i * 2)] = i;\n  node[1 + (i * 2)] = i + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/12"}
{"code": "for (int k = 0; k < n; k++)\n{\n  int begin = (k + 1) + ((*threadid) * (((n - k) - 1) / thread_count));\n  int end = begin + (((n - k) - 1) / thread_count);\n  if (end > n)\n    end = n;\n\n  int preprocessnumber = ((n - k) - 1) % 8;\n  int begincol = (k + 1) + preprocessnumber;\n  for (int i = begin; i < end; i++)\n  {\n    for (int j = k + 1; j < preprocessnumber; j++)\n    {\n      A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n    }\n\n    A[i][k] = 0;\n  }\n\n  for (int i = begin; i < end; i++)\n  {\n    float head1[8] = {A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k], A[i][k]};\n    t3 = _mm256_loadu_ps(head1);\n    for (int j = begincol; j < n; j += 8)\n    {\n      t1 = _mm256_loadu_ps(A[k] + j);\n      t2 = _mm256_loadu_ps(A[i] + j);\n      t1 = _mm256_mul_ps(t1, t3);\n      t2 = _mm256_sub_ps(t2, t1);\n      _mm256_storeu_ps(A[i] + j, t2);\n    }\n\n    A[i][k] = 0;\n  }\n\n  sem_post(&sem_parent);\n  pthread_barrier_wait(&childbarrier_row);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/16"}
{"code": "for (y = 2; y < (maxYcount - 2); y++)\n{\n  for (x = 2; x < (maxXcount - 2); x++)\n  {\n    double f = ((((-alpha) * fx_thing[x - 1]) * fy_thing[y - 1]) - (2.0 * fx_thing[x - 1])) - (2.0 * fy_thing[y - 1]);\n    double updateVal = (((((u_old[(y * maxXcount) + (x - 1)] + u_old[(y * maxXcount) + (x + 1)]) * cx) + ((u_old[((y - 1) * maxXcount) + x] + u_old[((y + 1) * maxXcount) + x]) * cy)) + (u_old[(y * maxXcount) + x] * cc)) - f) / cc;\n    u[(y * maxXcount) + x] = u_old[(y * maxXcount) + x] - (relax * updateVal);\n    local_square_error += updateVal * updateVal;\n  }\n\n}\n\n", "pragma": "omp for reduction(+:local_square_error) collapse(2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MediaBilly/Poisson-Equation-Parallel-Solver/HybridMPI/jacobi_hybrid_mpi/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if ((i == 0) && (j == 0))\n    {\n      resultado = openmp(L, C, N);\n    }\n\n    MPI_Send(&M[i * N], N, (MPI_Datatype) 0x4c000405, (i * N) + j, 1, 1);\n    for (k = 0; k < N; k++)\n    {\n      MPI_Send(&M[(k * N) + j], 1, (MPI_Datatype) 0x4c000405, (i * N) + j, 2, 1);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BrunoGomesCoelho/open_mpi/ex_aula8/3"}
{"code": "for (unsigned i = 0; i < s.length(); i++)\n{\n  switch (s[i])\n  {\n    case '0':\n      pos = 99;\n      break;\n\n    case 'A':\n      pos = 10;\n      break;\n\n    case 'B':\n      pos = 11;\n      break;\n\n    case 'C':\n      pos = 12;\n      break;\n\n    case 'D':\n      pos = 13;\n      break;\n\n    case 'E':\n      pos = 14;\n      break;\n\n    case 'F':\n      pos = 15;\n      break;\n\n    default:\n      pos = s[i] - '0';\n\n  }\n\n  if (pos != 99)\n    res[pos - 1]++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aleri-a/Parallel-Systems--Frequency-calculation-of-characters-/parallel_project/parallel_project/Source/4"}
{"code": "for (i = 0; i < matrixSize; ++i)\n{\n  sprintf(comma, \"%s\", \"\");\n  for (j = 0; j < matrixSize; ++j)\n  {\n    fprintf(fp2, \"%s%f\", comma, array2[i][j]);\n    sprintf(comma, \"%s\", \",\");\n  }\n\n  fprintf(fp2, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PureDevPer/Distributed-and-Parallel-Computing/openMP/Parallel/hw5Omp/2"}
{"code": "for (int i = 0; i < (j + 4); i++)\n  for (int j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/69"}
{"code": "for (int i = 0; i < RUN_COUNT; i++)\n{\n  fillDataset(&dataset);\n  starttime = omp_get_wtime();\n  mulBlock(dataset);\n  elapsedtime = omp_get_wtime() - starttime;\n  closeDataset(dataset);\n  printf(\"[-] Time Elapsed: %f Secs\\n\", elapsedtime);\n  times_sum += elapsedtime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW3/3DMatMul/0"}
{"code": "for (int i = 0; i < column_size; i++)\n{\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/2"}
{"code": "for (n = block_len - 1; n >= 0; n--)\n{\n  buffer = -INFINITY;\n  for (s = 0; s < chtrellis.stateNb; s++)\n  {\n    B[s + (n * chtrellis.stateNb)] = -INFINITY;\n    for (k = 0; k < chtrellis.numInputSymbols; k++)\n    {\n      sp = chtrellis.nextState[s + (k * chtrellis.stateNb)];\n      in_chips = dec2bin(nb_usr, k);\n      B[s + (n * chtrellis.stateNb)] = max(B[s + (n * chtrellis.stateNb)], (B[sp + ((n + 1) * chtrellis.stateNb)] - (sqr(rec_sig[n] - chtrellis.output[s + (k * chtrellis.stateNb)]) / (2 * sigma2))) + (to_vec(in_chips) * apriori_data.get_col(n)));\n    }\n\n    buffer = max(buffer, B[s + (n * chtrellis.stateNb)]);\n  }\n\n  for (s = 0; s < chtrellis.stateNb; s++)\n  {\n    B[s + (n * chtrellis.stateNb)] -= buffer;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_mud/3"}
{"code": "for (int step = 0; step < conf.nsteps; step++)\n{\n  for (int src = 0; src < conf.nsrcs; src++)\n  {\n    if (conf.srcs[src].t > step)\n      continue;\n\n    int src_offset = POINT_OFFSET(conf.srcs[src].x, conf.srcs[src].y, 0, dimy, dimx, conf.radius);\n    curr[src_offset] = srcs[src][step];\n  }\n\n  fwd(next, curr, vsq, c_coeff, conf.nx, conf.ny, conf.nz, dimx, dimy, dimz, conf.radius);\n  TYPE *tmp = next;\n  next = curr;\n  curr = tmp;\n  update_progress(step + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ijpq/15418/utils/opencv/CodeSamples/lectures_code/iso/src/iso3d/1"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dwilbraham/openmp-tutorial/exercise_4/0"}
{"code": "for (x = 1; x < (height - 1); x++)\n{\n  for (y = 1; y < (width - 1); y++)\n  {\n    G_x = (G_y = 0);\n    for (int i = x - (3 / 2); i < ((x + 3) - (3 / 2)); i++)\n    {\n      for (int j = y - (3 / 2); j < ((y + 3) - (3 / 2)); j++)\n      {\n        G_x += (double) (fmat_x[(i - x) + (3 / 2)][(y - j) + (3 / 2)] * grayscaleData[(i * width) + j]);\n        G_y += (double) (fmat_y[(i - x) + (3 / 2)][(y - j) + (3 / 2)] * grayscaleData[(i * width) + j]);\n      }\n\n    }\n\n    G = sqrt((G_x * G_x) + (G_y * G_y));\n    gradientMagnitudes[(x * width) + y] = G;\n    float angle = atan2(G_y, G_x);\n    if (angle < 0)\n    {\n      angle = fmod(angle + (2 * 3.14159), 2 * 3.14159);\n    }\n\n    if (angle <= (3.14159 / 8))\n    {\n      edgeDirections[(x * width) + y] = 0;\n    }\n    else\n      if (angle <= ((3 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 45;\n    }\n    else\n      if (angle <= ((5 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 90;\n    }\n    else\n      if (angle <= ((7 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 135;\n    }\n    else\n      if (angle <= ((9 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 0;\n    }\n    else\n      if (angle <= ((11 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 45;\n    }\n    else\n      if (angle <= ((13 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 90;\n    }\n    else\n      if (angle <= ((15 * 3.14159) / 8))\n    {\n      edgeDirections[(x * width) + y] = 135;\n    }\n    else\n    {\n      edgeDirections[(x * width) + y] = 0;\n    }\n\n\n\n\n\n\n\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/canny-edge-detection/OpenMP/processor/1"}
{"code": "for (i = 1; i <= 10; i++)\n{\n  int currentThread = omp_get_thread_num();\n  sum += i;\n  printf(\"[%d]: Sum = %d\\n\", currentThread, sum);\n  printf(\"[%d]: calculation of the iteration number %d\\n\", currentThread, i);\n}\n\n", "pragma": "#pragma omp for schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IZIDIA/OpenMP-Testing/Main_OpenMP/1"}
{"code": "for (size_t j = 0, k = 0; j < gridLoc.size(); ++j)\n{\n  if (!gridLoc[j].inGrid)\n    continue;\n\n  Usig(k) = gridLoc[j].u;\n  Vsig(k) = gridLoc[j].v;\n  Wsig(k) = gridLoc[j].w;\n  gridLoc[j].sigIdx = k;\n  ++k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/8"}
{"code": "for (int i = 0; i < filesCount; i++)\n{\n  for (int i2 = 0; i2 < fileFindings[i].used; i2++)\n  {\n    freeFileFindings(&fileFindings[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcingolenia/KMP-using-C-and-OMP/main_omp/4"}
{"code": "for (l = 1; l < nzh; l++)\n{\n  dkz = dnz * ((float) l);\n  ll = nxyhd * l;\n  lj = nxvyh * l;\n  l1 = (nxvyh * nz) - lj;\n  wp = 0.0;\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    for (j = 1; j < nxh; j++)\n    {\n      at2 = (-ci2) * crealf(ffe[(j + kk) + ll]);\n      at1 = at2 * cimagf(ffe[(j + kk) + ll]);\n      at2 = at2 * at2;\n      exyz[3 * ((j + kj) + lj)] = at1 * dcu[3 * ((j + kj) + lj)];\n      exyz[1 + (3 * ((j + kj) + lj))] = at1 * dcu[1 + (3 * ((j + kj) + lj))];\n      exyz[2 + (3 * ((j + kj) + lj))] = at1 * dcu[2 + (3 * ((j + kj) + lj))];\n      exyz[3 * ((j + k1) + lj)] = at1 * dcu[3 * ((j + k1) + lj)];\n      exyz[1 + (3 * ((j + k1) + lj))] = at1 * dcu[1 + (3 * ((j + k1) + lj))];\n      exyz[2 + (3 * ((j + k1) + lj))] = at1 * dcu[2 + (3 * ((j + k1) + lj))];\n      exyz[3 * ((j + kj) + l1)] = at1 * dcu[3 * ((j + kj) + l1)];\n      exyz[1 + (3 * ((j + kj) + l1))] = at1 * dcu[1 + (3 * ((j + kj) + l1))];\n      exyz[2 + (3 * ((j + kj) + l1))] = at1 * dcu[2 + (3 * ((j + kj) + l1))];\n      exyz[3 * ((j + k1) + l1)] = at1 * dcu[3 * ((j + k1) + l1)];\n      exyz[1 + (3 * ((j + k1) + l1))] = at1 * dcu[1 + (3 * ((j + k1) + l1))];\n      exyz[2 + (3 * ((j + k1) + l1))] = at1 * dcu[2 + (3 * ((j + k1) + l1))];\n      wp += at2 * ((((((((((((dcu[3 * ((j + kj) + lj)] * conjf(dcu[3 * ((j + kj) + lj)])) + (dcu[1 + (3 * ((j + kj) + lj))] * conjf(dcu[1 + (3 * ((j + kj) + lj))]))) + (dcu[2 + (3 * ((j + kj) + lj))] * conjf(dcu[2 + (3 * ((j + kj) + lj))]))) + (dcu[3 * ((j + k1) + lj)] * conjf(dcu[3 * ((j + k1) + lj)]))) + (dcu[1 + (3 * ((j + k1) + lj))] * conjf(dcu[1 + (3 * ((j + k1) + lj))]))) + (dcu[2 + (3 * ((j + k1) + lj))] * conjf(dcu[2 + (3 * ((j + k1) + lj))]))) + (dcu[3 * ((j + kj) + l1)] * conjf(dcu[3 * ((j + kj) + l1)]))) + (dcu[1 + (3 * ((j + kj) + l1))] * conjf(dcu[1 + (3 * ((j + kj) + l1))]))) + (dcu[2 + (3 * ((j + kj) + l1))] * conjf(dcu[2 + (3 * ((j + kj) + l1))]))) + (dcu[3 * ((j + k1) + l1)] * conjf(dcu[3 * ((j + k1) + l1)]))) + (dcu[1 + (3 * ((j + k1) + l1))] * conjf(dcu[1 + (3 * ((j + k1) + l1))]))) + (dcu[2 + (3 * ((j + k1) + l1))] * conjf(dcu[2 + (3 * ((j + k1) + l1))])));\n    }\n\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    at2 = (-ci2) * crealf(ffe[kk + ll]);\n    at1 = at2 * cimagf(ffe[kk + ll]);\n    at2 = at2 * at2;\n    exyz[3 * (kj + lj)] = at1 * dcu[3 * (kj + lj)];\n    exyz[1 + (3 * (kj + lj))] = at1 * dcu[1 + (3 * (kj + lj))];\n    exyz[2 + (3 * (kj + lj))] = at1 * dcu[2 + (3 * (kj + lj))];\n    exyz[3 * (k1 + lj)] = zero;\n    exyz[1 + (3 * (k1 + lj))] = zero;\n    exyz[2 + (3 * (k1 + lj))] = zero;\n    exyz[3 * (kj + l1)] = at1 * dcu[3 * (kj + l1)];\n    exyz[1 + (3 * (kj + l1))] = at1 * dcu[1 + (3 * (kj + l1))];\n    exyz[2 + (3 * (kj + l1))] = at1 * dcu[2 + (3 * (kj + l1))];\n    exyz[3 * (k1 + l1)] = zero;\n    exyz[1 + (3 * (k1 + l1))] = zero;\n    exyz[2 + (3 * (k1 + l1))] = zero;\n    wp += at2 * ((((((dcu[3 * (kj + lj)] * conjf(dcu[3 * (kj + lj)])) + (dcu[1 + (3 * (kj + lj))] * conjf(dcu[1 + (3 * (kj + lj))]))) + (dcu[2 + (3 * (kj + lj))] * conjf(dcu[2 + (3 * (kj + lj))]))) + (dcu[3 * (kj + l1)] * conjf(dcu[3 * (kj + l1)]))) + (dcu[1 + (3 * (kj + l1))] * conjf(dcu[1 + (3 * (kj + l1))]))) + (dcu[2 + (3 * (kj + l1))] * conjf(dcu[2 + (3 * (kj + l1))])));\n  }\n\n  k1 = nxvh * nyh;\n  for (j = 1; j < nxh; j++)\n  {\n    at2 = (-ci2) * crealf(ffe[j + ll]);\n    at1 = at2 * cimagf(ffe[j + ll]);\n    at2 = at2 * at2;\n    exyz[3 * (j + lj)] = at1 * dcu[3 * (j + lj)];\n    exyz[1 + (3 * (j + lj))] = at1 * dcu[1 + (3 * (j + lj))];\n    exyz[2 + (3 * (j + lj))] = at1 * dcu[2 + (3 * (j + lj))];\n    exyz[3 * ((j + k1) + lj)] = zero;\n    exyz[1 + (3 * ((j + k1) + lj))] = zero;\n    exyz[2 + (3 * ((j + k1) + lj))] = zero;\n    exyz[3 * (j + l1)] = at1 * dcu[3 * (j + l1)];\n    exyz[1 + (3 * (j + l1))] = at1 * dcu[1 + (3 * (j + l1))];\n    exyz[2 + (3 * (j + l1))] = at1 * dcu[2 + (3 * (j + l1))];\n    exyz[3 * ((j + k1) + l1)] = zero;\n    exyz[1 + (3 * ((j + k1) + l1))] = zero;\n    exyz[2 + (3 * ((j + k1) + l1))] = zero;\n    wp += at2 * ((((((dcu[3 * (j + lj)] * conjf(dcu[3 * (j + lj)])) + (dcu[1 + (3 * (j + lj))] * conjf(dcu[1 + (3 * (j + lj))]))) + (dcu[2 + (3 * (j + lj))] * conjf(dcu[2 + (3 * (j + lj))]))) + (dcu[3 * (j + l1)] * conjf(dcu[3 * (j + l1)]))) + (dcu[1 + (3 * (j + l1))] * conjf(dcu[1 + (3 * (j + l1))]))) + (dcu[2 + (3 * (j + l1))] * conjf(dcu[2 + (3 * (j + l1))])));\n  }\n\n  at2 = (-ci2) * crealf(ffe[ll]);\n  at1 = at2 * cimagf(ffe[ll]);\n  at2 = at2 * at2;\n  exyz[3 * lj] = at1 * dcu[3 * lj];\n  exyz[1 + (3 * lj)] = at1 * dcu[1 + (3 * lj)];\n  exyz[2 + (3 * lj)] = at1 * dcu[2 + (3 * lj)];\n  exyz[3 * (k1 + lj)] = zero;\n  exyz[1 + (3 * (k1 + lj))] = zero;\n  exyz[2 + (3 * (k1 + lj))] = zero;\n  exyz[3 * l1] = zero;\n  exyz[1 + (3 * l1)] = zero;\n  exyz[2 + (3 * l1)] = zero;\n  exyz[3 * (k1 + l1)] = zero;\n  exyz[1 + (3 * (k1 + l1))] = zero;\n  exyz[2 + (3 * (k1 + l1))] = zero;\n  wp += at2 * (((dcu[3 * lj] * conjf(dcu[3 * lj])) + (dcu[1 + (3 * lj)] * conjf(dcu[1 + (3 * lj)]))) + (dcu[2 + (3 * lj)] * conjf(dcu[2 + (3 * lj)])));\n  sum1 += wp;\n}\n\n", "pragma": "omp for nowait private(j,k,l,k1,l1,ll,lj,kk,kj,at1,at2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/10"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char master[32];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt[0], cur_salt->saltlen[0], cur_salt->iterations[0], master, 16, 0);\n  if (akcdecrypt(master, cur_salt->ct[0]) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/agilekeychain_fmt_plug/1"}
{"code": "for (int k = y_min; k <= (y_max + 1); k++)\n{\n  for (int j = x_min - 1; j <= (x_max + 1); j++)\n  {\n    int pos = node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] < 0.0;\n    int upwind = (pos) ? (j + 2) : (j - 1);\n    int donor = (pos) ? (j + 1) : (j);\n    int downwind = (pos) ? (j) : (j + 1);\n    int dif = (pos) ? (donor) : (upwind);\n    double sigma = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)];\n    double width = celldx[FTNREF1D(j, x_min - 2)];\n    double vdiffuw = vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(upwind, k, x_max + 5, x_min - 2, y_min - 2)];\n    double vdiffdw = vel1[FTNREF2D(downwind, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)];\n    double limiter = 0.0;\n    if ((vdiffuw * vdiffdw) > 0.0)\n    {\n      double auw = fabs(vdiffuw);\n      double adw = fabs(vdiffdw);\n      double wind = (vdiffdw <= 0.0) ? (-1.0) : (1.0);\n      limiter = wind * MIN((width * ((((2.0 - sigma) * adw) / width) + (((1.0 + sigma) * auw) / celldx[FTNREF1D(dif, x_min - 2)]))) / 6.0, MIN(auw, adw));\n    }\n\n    double advec_vel_s = ((1.0 - sigma) * limiter) + vel1[FTNREF2D(donor, k, x_max + 5, x_min - 2, y_min - 2)];\n    mom_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = advec_vel_s * node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (first_time == 'y')\n  {\n    tid = omp_get_thread_num();\n    first_time = 'n';\n  }\n\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for shared(a,b,c,n) private(i,tid) schedule(static,chunk) firstprivate(first_time)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/parallel/openMP/omp_workshare4/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = 1.0 * i;\n  b[i] = 2.0 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/static_scheduler/1"}
{"code": "for (int i = 0; i < 100000; ++i)\n{\n  float x1 = rand_decl[i];\n  float x2 = rand_rasc[i];\n  for (int j = 0; j < 100000; ++j)\n  {\n    float y1 = rand_decl[j];\n    float y2 = rand_rasc[j];\n    float tmp = x2 - y2;\n    float temp = (sinf(x1) * sinf(y1)) + ((cosf(x1) * cosf(y1)) * cosf(tmp));\n    if (temp > 1.0f)\n      temp = 1.0f;\n\n    float angle = acosf(temp);\n    angle = angle / degree;\n    histogram_RR[(int) (4.0f * angle)] += 1L;\n  }\n\n}\n\n", "pragma": "omp for reduction(+:histogram_RR)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mabutko/CosmicDarkMatter/galaxy_openmp/1"}
{"code": "for (int thr = 0; thr < nthr; thr++)\n{\n  int node = thr / thr_per_node;\n  multi_start[thr] = get_time();\n  for (int i = 0; i < num_vals; i++)\n  {\n    double rx = drand48();\n    double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n    double ry = drand48();\n    double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n    double rz = drand48();\n    double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n    eval_multi_UBspline_3d_d_vgh(multi_spline[node], x, y, z, multi_vals[thr], multi_grads[thr], multi_hess[thr]);\n  }\n\n  multi_end[thr] = get_time();\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_omp/3"}
{"code": "for (int i = 0; i < (((sN + 2) * (_M + 2)) * (K + 2)); i++)\n  for (int j = 0; j < sum_param; j++)\n  Htmp[i].push_back(0.0);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/75"}
{"code": "for (i = 0; i < global_chunknr; i++)\n{\n  if (expected_chunk_size > 1)\n    expected_chunk_size = (c * openwork) / threads;\n\n  if (abs(chunksizes[i] - expected_chunk_size) >= 2)\n  {\n    result = 0;\n    fprintf(stderr, \"Chunksize differed from expected value: %d instead of %d\\n\", chunksizes[i], expected_chunk_size);\n    return 0;\n  }\n\n  if ((expected_chunk_size - chunksizes[i]) < 0)\n    fprintf(stderr, \"Chunksize did not decrease: %d instead of %d\\n\", chunksizes[i], expected_chunk_size);\n\n  openwork -= chunksizes[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_guided/3"}
{"code": "for (int i = 0; i < forwardValues.size(); i++)\n{\n  for (int j = 0; j < forwardValues[0].size(); j++)\n  {\n    if (i == j)\n      identity[i][j] = 1;\n    else\n      identity[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/7"}
{"code": "for (size_t i = 0; i < n; ++i)\n  sum += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex7-imbalance-openmp/1"}
{"code": "for (size_t dim = 0; dim < _dimensionality; dim++)\n  _internalVector[dim] = vec[dim];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariodematties/MPI_Tests/Sum/1"}
{"code": "for (int ii = 0; ii < nb; ++ii)\n  failures += (x[ii] != X_VAL) || (y[ii] != Y_VAL);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-critical/test/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (k = 0; k < nz; k++)\n  {\n    phi_jac[i][0][k] = 1.0;\n    phi_jac[i][ny - 1][k] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/9"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  printf(\"M\u00e9dia do tempo de execu\u00e7\u00e3o com %d threads: %f \\n\", n_threads[i], elapsed_time_all[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VinniciusC/Mult_matrizes_openMP/mult_matriz/3"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp4nymp82g.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp4nymp82g.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/42"}
{"code": "for (long i = 0; i < NV_in; i++)\n{\n  long adj1 = vtxPtrIn[i];\n  long adj2 = vtxPtrIn[i + 1];\n  for (long j = adj1; j < adj2; j++)\n  {\n    long tail = vtxIndIn[j].tail;\n    assert((C[i] < numUniqueClusters) && (C[tail] < numUniqueClusters));\n    if (C[i] == C[tail])\n    {\n      long location = ((C[i] * (C[i] + 1)) / 2) + C[i];\n      __sync_fetch_and_add(&tmpCounter[location], vtxIndIn[j].weight);\n    }\n    else\n    {\n      if (C[i] > C[tail])\n      {\n        long location = ((C[i] * (C[i] + 1)) / 2) + C[tail];\n        __sync_fetch_and_add(&tmpCounter[location], vtxIndIn[j].weight);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/7"}
{"code": "for (i = 0; i < nx; i++)\n  for (j = 0; j < nx; j++)\n  heatgrid[0][i][j] = (heatgrid[1][i][j] = 0.0);\n\n\n", "pragma": "omp parallel for shared(heatgrid) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juliennelachance/apc524_hw4/heat_omp/1"}
{"code": "for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n{\n  X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/6"}
{"code": "for (i = 0; i < 4; i++)\n{\n  zc[0][i] = 0.0;\n  zc[0][4 + i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/8"}
{"code": "for (int i = 0; i < nbodies; i++)\n{\n  for (int j = i + 1; j < nbodies; j++)\n  {\n    double eij = two_body_energy(i, j);\n    energy += eij;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) reduction(+:energy)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vpasumarthi/openmp/prog-1/0"}
{"code": "for (i = 0; i < xres; i++)\n{\n  int randIndex = rand() % xres;\n  int tmp = x_array[i];\n  x_array[i] = x_array[randIndex];\n  x_array[randIndex] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EvanSkeete/ParallelJulia/julia_omp/4"}
{"code": "for (int i = 0; i < colourNr; ++i)\n{\n  colours.push_back(i);\n  check.push_back(false);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/2"}
{"code": "for (iterator i = all_devices.begin(); i != all_devices.end(); ++i)\n{\n  log_device_info(*i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-neumann/versalignLib/src/Kernels/OpenCL/OpenCLKernel/1"}
{"code": "for (i = 1; i < n; i++)\n  area = area + sqrt(4 - ((a + (i * h)) * (a + (i * h))));\n\n", "pragma": "omp parallel for reduction(+:area)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_2/Calculate Pi/Approach 2/parallel/0"}
{"code": "for (node_t i = 0; i < G->numNodes; i++)\n{\n  clusterednodes[i] = NIL_NODE;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/4"}
{"code": "for (row = 1; row < (NRows + 1); row++)\n{\n  for (col = 1; col < (NCols + 1); col++)\n  {\n    sprintf(buf, \"%*d \", NMaxBurnStepsDigits, Trees[(row * NColsPlusBounds) + col]);\n    fprintf(OutputFile, \"%s\", buf);\n  }\n\n  fprintf(OutputFile, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-omp-examples/fire/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  vec[i] = dist(mt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ngc436/Parallel-Programming-openMP1/matrix/Parallel_task1/0"}
{"code": "for (c2 = 0; c2 <= 499; c2++)\n{\n  X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-parallel-no/2"}
{"code": "for (k = 0; k < n; k++)\n{\n  C[i] = C[i] + (A[(i * n) + k] * B[k]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP2.2/Shashank_CP2.2_11110094_Report+Codes/Shashank_CP2.2_11110094_Report+Codes/Codes for OpenMP_Shashank/Q1/mat-mul/2"}
{"code": "for (int j = 0; j < column; ++j)\n{\n  printf(\"Enter a%d%d: \", i + 1, j + 1);\n  scanf(\"%d\", &matrix[i][j]);\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eliah7/OpenMP-Intro/mat_mul_parallel/1"}
{"code": "for (int i = 0; i < 100000000; i++)\n{\n  input_values[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexandra182/code-optimization-samples/InvOrderBits/0"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] *= temp;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/14"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  set_node(&node->children[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/4"}
{"code": "for (int i = 0; i < length; i++)\n  (cout << seq[i]) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/22"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double result = 0;\n  for (int j = 0; j < o; j++)\n  {\n    result += A[i][j] * b[j];\n  }\n\n  result_vector_block[i] = result;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task3/5"}
{"code": "for (int i = 0; i < smallImageHeight; i++)\n{\n  for (int j = 0; j < smallImageWidth; j++)\n  {\n    if (isPixelMatching(i, j, x + i, y + j))\n    {\n      counter++;\n      if (counter == comp)\n        return true;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aksha/Breast-Tumor-Detection/ravicha_ImageSearch/1"}
{"code": "for (int i = 1; i <= n2; ++i)\n{\n  for (int j = 1; j <= n3; ++j)\n  {\n    int sign = rand() % 2;\n    w2[i][j] = ((double) ((rand() % 10) + 1)) / (10.0 * n3);\n    if (sign == 1)\n    {\n      w2[i][j] = -w2[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/1"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    rho_visc[i][j][k] = rho[i][j][k];\n    vx_visc[i][j][k] = vx[i][j][k];\n    vy_visc[i][j][k] = vy[i][j][k];\n    vz_visc[i][j][k] = vz[i][j][k];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/copy_arrays_for_viscosity/0"}
{"code": "for (int i = 0; i < img.height; i++)\n  for (int j = 0; j < img.width; j++)\n{\n  rayList[(i * img.width) + j] = viewer.pixelToWorld(j, i);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gabriellgpc/raytracing/raytrace/0"}
{"code": "for (j = 1; j <= (naa + 1); j += 1)\n{\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = x[j];\n  p[j] = r[j];\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (naa)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/5"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (j = 0; j < 26; j++)\n  {\n    ncl[j + (26 * l)] = 0;\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      z = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      nn = x;\n      mm = y;\n      ll = z;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      dzp = z - ((float) ll);\n      n[j] = ((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      dx1 = dxp * dyp;\n      dyp = amx * dyp;\n      amx = amx * amy;\n      amz = 1.0f - dzp;\n      amy = dxp * amy;\n      s[j] = amx * amz;\n      s[j + 32] = amy * amz;\n      s[j + (2 * 32)] = dyp * amz;\n      s[j + (3 * 32)] = dx1 * amz;\n      s[j + (4 * 32)] = amx * dzp;\n      s[j + (5 * 32)] = amy * dzp;\n      s[j + (6 * 32)] = dyp * dzp;\n      s[j + (7 * 32)] = dx1 * dzp;\n      t[j] = x;\n      t[j + 32] = y;\n      t[j + (2 * 32)] = z;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = (nn + mxv) - 2;\n      ll = (nn + mxyv) - 4;\n      k = (ll + mxv) - 2;\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      for (i = 0; i < 8; i++)\n      {\n        if (i > 5)\n        {\n          nn = k;\n        }\n        else\n          if (i > 3)\n        {\n          nn = ll;\n        }\n        else\n          if (i > 1)\n        {\n          nn = mm;\n        }\n\n\n\n        dx += sfxyz[4 * (i + nn)] * s[j + (32 * i)];\n        dy += sfxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        dz += sfxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n        ox += sbxyz[4 * (i + nn)] * s[j + (32 * i)];\n        oy += sbxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        oz += sbxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n      s[j + (2 * 32)] = dz;\n      s[j + (3 * 32)] = ox;\n      s[j + (4 * 32)] = oy;\n      s[j + (5 * 32)] = oz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      z = t[j + (2 * 32)];\n      dx = qtmh * s[j];\n      ;\n      dy = qtmh * s[j + 32];\n      dz = qtmh * s[j + (2 * 32)];\n      acx = ppart[((j + joff) + (3 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (4 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (5 * nppmx)) + npoff] + dz;\n      p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n      gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n      qtmg = qtmh * gami;\n      sum1 += (gami * p2) / (1.0f + gami);\n      omxt = qtmg * s[j + (3 * 32)];\n      omyt = qtmg * s[j + (4 * 32)];\n      omzt = qtmg * s[j + (5 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n      dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n      s[j] = x + (vx * dtg);\n      s[j + 32] = y + (vy * dtg);\n      s[j + (2 * 32)] = z + (vz * dtg);\n      s[j + (3 * 32)] = vx;\n      s[j + (4 * 32)] = vy;\n      s[j + (5 * 32)] = vz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      dz = s[j + (2 * 32)];\n      mm = 0;\n      if (dx >= edgerx)\n      {\n        if (dx >= anx)\n          dx = dx - anx;\n\n        mm = 2;\n      }\n      else\n        if (dx < edgelx)\n      {\n        if (dx < 0.0f)\n        {\n          dx += anx;\n          if (dx < anx)\n            mm = 1;\n          else\n            dx = 0.0f;\n\n        }\n        else\n        {\n          mm = 1;\n        }\n\n      }\n\n\n      if (dy >= edgery)\n      {\n        if (dy >= any)\n          dy = dy - any;\n\n        mm += 6;\n      }\n      else\n        if (dy < edgely)\n      {\n        if (dy < 0.0f)\n        {\n          dy += any;\n          if (dy < any)\n            mm += 3;\n          else\n            dy = 0.0f;\n\n        }\n        else\n        {\n          mm += 3;\n        }\n\n      }\n\n\n      if (dz >= edgerz)\n      {\n        if (dz >= anz)\n          dz = dz - anz;\n\n        mm += 18;\n      }\n      else\n        if (dz < edgelz)\n      {\n        if (dz < 0.0f)\n        {\n          dz += anz;\n          if (dz < anz)\n            mm += 9;\n          else\n            dz = 0.0f;\n\n        }\n        else\n        {\n          mm += 9;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = dz;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = s[j + (3 * 32)];\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = s[j + (4 * 32)];\n      ppart[((j + joff) + (5 * nppmx)) + npoff] = s[j + (5 * 32)];\n      n[j] = mm;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      mm = n[j];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + joff) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,ipp,joff,nps,nn,mm,ll,nm,ih, nh,x,y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy, acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8, rot9,p2,gami,qtmg,dtg,edgelx,edgely,edgelz,edgerx,edgery,edgerz,sum1, sfxyz,sbxyz,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/9"}
{"code": "for (int i = 0; i < getNOP(); i++)\n{\n  setU(i, vel);\n  setV(i, 0.);\n  setW(i, 0.);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/1"}
{"code": "for (int i = 1; i < max_rows; i++)\n{\n  input_itemsets_seq[i * max_cols] = (rand() % 10) + 1;\n  input_itemsets_par[i * max_cols] = input_itemsets_seq[i * max_cols];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/3"}
{"code": "for (i = 0; i < tlines2; i++)\n{\n  strcpy(sent2, \"\");\n  for (j = 0; j < h_b[i].nwords; j++)\n  {\n    sprintf(str, \"%d0\", h_b[i].sentence[j]);\n    strcat(sent2, str);\n  }\n\n  strcat(sent2, \"#\");\n  strcpy(h_b[i].wsentence, sent2);\n  fflush(stdout);\n  cout << h_b[i].wsentence;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/hash_mpi/13"}
{"code": "for (long int i = 0; i < (values_count - 1); ++i)\n{\n  a = web[i];\n  b = web[i + 1];\n  prores += ((b - a) * (F(((a + b) / 2.0) - ((b - a) / (2 * sqrt(3)))) + F(((a + b) / 2.0) + ((b - a) / (2 * sqrt(3)))))) / 2;\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/skanerOH/OpenMPLab/OpenMPLab/OpenMPLab/1"}
{"code": "for (int i = 0; i < mu; i++)\n{\n  F[(t + 1) & 1][i] = func(x[i], num);\n}\n\n", "pragma": "        #pragma omp parallel for shared(mu,t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/backup/new_codes/R1ES_omp_alt/6"}
{"code": "for (int i = 0; i < NUM_OF_ELEMENTS; ++i)\n{\n  int r = rand_r(&seed);\n  data[i].key = (long long *) ((((((long long) rand_r(&seed)) << 31) | ((long long) r)) << 2) | ((long long) (r >> 29)));\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/test/2"}
{"code": "for (i = 1; i < 480; i++)\n  bucket[i] += bucket[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/radixsort/radix/3"}
{"code": "for (int i = 0; i < source.rows; i++)\n{\n  for (int j = 0; j < source.cols; j++)\n  {\n    destination(i, j) = knn(i, j, source, ksize, percent);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/knnOMP/3"}
{"code": "for (int i = 0; i < TestN; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    kernel_matrix(i, j) = exp(-sum(pow(TestX.row(i) - X.row(j), 2)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/utilities/4"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  printf(\"Hello World parallel for!\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a2gs/OMP_studies/sample/0"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  for (int j = 0; j < nx; j++)\n  {\n    double *adjacent = malloc(4 * (sizeof(double)));\n    if (adjacent == 0)\n    {\n      fprintf(stderr, \"Malloc did not work.  Now exiting...\\n\");\n      exit(1);\n    }\n\n    if (i == 0)\n    {\n      adjacent[0] = T_x_pi_boundaryconditions(j, nx);\n    }\n    else\n    {\n      adjacent[0] = T[i - 1][j];\n    }\n\n    if (j == (nx - 1))\n    {\n      adjacent[1] = T[i][0];\n    }\n    else\n    {\n      adjacent[1] = T[i][j + 1];\n    }\n\n    if (i == (nx - 1))\n    {\n      adjacent[2] = T_x_0_boundaryconditions(j, nx);\n    }\n    else\n    {\n      adjacent[2] = T[i + 1][j];\n    }\n\n    if (j == 0)\n    {\n      adjacent[3] = T[i][nx - 1];\n    }\n    else\n    {\n      adjacent[3] = T[i][j - 1];\n    }\n\n    T2[i][j] = T[i][j] + ((dt / (dx * dx)) * ((((adjacent[0] + adjacent[1]) + adjacent[2]) + adjacent[3]) - (4. * T[i][j])));\n    free(adjacent);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshuawallace/hw4_scientific_computing/heat_omp/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    result[i][j] = 0;\n    for (s = 0; s < m; s++)\n    {\n      result[i][j] += arr1[i][s] * arr2[s][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(arr1, arr2, result) private(i, j, s) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task2/3"}
{"code": "for (int i = 0; i < n_iters; i++)\n{\n  if ((func_x(a) * func_x(b)) < 0)\n  {\n    c = (a + b) / 2.0;\n    if ((func_x(c) * func_x(a)) < 0)\n    {\n      b = c;\n      count = count + 1;\n    }\n    else\n    {\n      a = c;\n      count = count + 1;\n    }\n\n  }\n\n  if ((func_x(c) == 0) || (((b - a) / 2.0) < tol))\n  {\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:count) lastprivate(c) firstprivate (a,b, n_iters, tol)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/9/Bisection_Method/main/0"}
{"code": "for (size_t i = 1; i < size; i++)\n{\n  if (arr[i] > max)\n    max = arr[i];\n\n  if (arr[i] < min)\n    min = arr[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/final_code/main/1"}
{"code": "for (unsigned i = 0; i < n; i++)\n{\n  for (long j = 0; j < load; j++)\n    sum += i + j;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp-benchmarks/src/benchmark/benchmark/1"}
{"code": "for (size_t s = 0; s < (1 << 18); ++s)\n{\n  for (size_t i = 0; i < (1 << 10); ++i)\n  {\n    float r = rand_MWC_co(&rng_state[i], &rng_const[i]);\n    sum[i] += r / (1 << 18);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/practicos/practico3/overhead/1"}
{"code": "for (int i = SIZE - 2; i >= 0; i--)\n{\n  for (int j = SIZE - 1; j > i; j--)\n  {\n    a1[i][column] = a1[i][column] - (u[i][j] * a1[j][column]);\n  }\n\n  a1[i][column] = a1[i][column] / u[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/Matrix-inverse-LUP/inverse_non_parallelized/4"}
{"code": "for (k = 0; k < matrix_size; ++k)\n{\n  for (l = 0; l < matrix_size; ++l)\n  {\n    resources_prev[k][l] = resources[k][l];\n    prices_prev[k][l] = prices[k][l];\n    budgets_prev[k][l] = budgets[k][l];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marius-avram/Tema-1-APD/paralel/3"}
{"code": "for (int i = 0; i < thread_count; i++)\n{\n  pthread_join(threadID[i], NULL);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/4"}
{"code": "for (int y = 0; y < H; ++y)\n{\n  for (int x = 0; x < W; ++x)\n  {\n    (out << scene.color(fromPoint, x, y).clamp255().ppm()) << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xyproto/spheremover/main/0"}
{"code": "for (size_t i = 0; i < len; i++)\n{\n  printf(\"%lf \", matrix[i]);\n  puts(\"\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/21"}
{"code": "for (int row = 0; row < m; row++)\n{\n  for (int col = 0; col < k; col++)\n  {\n    resultMat[(row * k) + col] = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n      resultMat[(row * k) + col] += leftMat[(row * n) + i] * rightMat[(col * n) + i];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/mpi/matrixMulti/gemm/1"}
{"code": "for (n = 10000; n <= 100000; n += 10000)\n{\n  start = omp_get_wtime();\n  printf(\"%d\\n\", maximum_sum_subsequence(v, n, k));\n  finish = omp_get_wtime();\n  fprintf(stderr, \"%d %lf\\n\", n, finish - start);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/drosa99/t1ProgParalela/T1DanielaAmaralViniciusLima/solParalV4/6"}
{"code": "for (j = 0; j < n; j++)\n  b[j] = (c[j] = (e[j] = j));\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q7/0"}
{"code": "for (int i = 0; i < K; i++)\n{\n  *(cent + (3 * i)) = clusters[i].cx;\n  *((cent + (3 * i)) + 1) = clusters[i].cy;\n  *((cent + (3 * i)) + 2) = clusters[i].cz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/animeshsinghjay/parallel-kmeans/lab1_omp/2"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (2 * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 2; jj++)\n    {\n      t2 = conjf(f[(jj + (2 * (nxh - j))) + joff]);\n      t1 = f[(jj + (2 * j)) + joff] + t2;\n      t2 = (f[(jj + (2 * j)) + joff] - t2) * t3;\n      f[(jj + (2 * j)) + joff] = t1 + t2;\n      f[(jj + (2 * (nxh - j))) + joff] = conjf(t1 - t2);\n    }\n\n  }\n\n  for (jj = 0; jj < 2; jj++)\n  {\n    f[(jj + (2 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (2 * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(2 * j1) + joff];\n      t2 = f[(1 + (2 * j1)) + joff];\n      f[(2 * j1) + joff] = f[(2 * j) + joff];\n      f[(1 + (2 * j1)) + joff] = f[(1 + (2 * j)) + joff];\n      f[(2 * j) + joff] = t1;\n      f[(1 + (2 * j)) + joff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (2 * ns2) * k;\n      k2 = k1 + (2 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = conjf(sct[kmr * j]);\n        t2 = t1 * f[((2 * j) + k2) + joff];\n        t3 = t1 * f[((1 + (2 * j)) + k2) + joff];\n        f[((2 * j) + k2) + joff] = f[((2 * j) + k1) + joff] - t2;\n        f[((1 + (2 * j)) + k2) + joff] = f[((1 + (2 * j)) + k1) + joff] - t3;\n        f[((2 * j) + k1) + joff] += t2;\n        f[((1 + (2 * j)) + k1) + joff] += t3;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 * j) + joff]);\n    f[(2 * j) + joff] = crealf(f[(2 * j) + joff]) + (crealf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n    f[(1 + (2 * j)) + joff] = at1 + (cimagf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,at1,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/6"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    soundspeed[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = soundspeed[FTNREF2D(j, 0 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/24"}
{"code": "for (i = 0; i < size; i++)\n{\n  tmpi = dsecnd_();\n  while ((dsecnd_() - tmpi) < 0.25)\n    ;\n\n  if (((me == 0) && (size > 1)) && (i != 0))\n  {\n    MPI_Send(&itmp, 0, (MPI_Datatype) 0x4c00010d, i, i, (MPI_Comm) 0x44000000);\n  }\n\n  if (((me == i) && (size > 1)) && (i != 0))\n  {\n    MPI_Recv(&itmp, 0, (MPI_Datatype) 0x4c00010d, 0, i, (MPI_Comm) 0x44000000, &status);\n  }\n\n  if (me == i)\n  {\n    fflush(0);\n    printf(\"(%d of %d): \", me, size);\n    printf(\"%c%c lda=%4d ldb=%4d ldc=%4d %1d %1d %1d %08.3f \", transa, transb, lda, ldb, ldc, iaoff, iboff, icoff, high / (1000000.0 * t1));\n    fflush(0);\n    printf(\"LIB2: %08.3f Number of errors=%d Total Error detected=%g \", high / (1000000.0 * t2), nerrs, derr);\n    fflush(0);\n    char hostname[128];\n    int namelen;\n    if (MPI_Get_processor_name(hostname, &namelen) == 0)\n      printf(\"%-.*s\\n\", namelen, hostname);\n\n    fflush(0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/9"}
{"code": "for (int i = 0; i < m1l; i++)\n{\n  for (int j = 0; j < m2c; j++)\n  {\n    for (int k = 0; k < m1l; k++)\n    {\n      matF[i][j] += mat1[i][k] * mat2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artb/Trab2_SO_Paralelismo/Multi_Matriz_Q1/1"}
{"code": "for (int i = 0; i < max_values; ++i)\n{\n  selection = choice(uniform);\n  while (input_vec[selection] == 1)\n    selection = choice(uniform);\n\n  replace = hole2(nor2);\n  while (replace >= 1)\n    replace = hole2(nor2);\n\n  input_vec[selection] = replace;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen/2"}
{"code": "for (Edge *ptr = edges->next; ptr != 0; ptr = ptr->next)\n  if (ptr->cost < best_edge->cost)\n  best_edge = ptr;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lffloyd/prog-paralela-trabalho/src/omp_prim/omp_prim/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    float vv[nb];\n    for (int kb = 0; kb < nb; ++kb)\n    {\n      vv[kb] = infty;\n    }\n\n    for (int ka = 0; ka < na; ++ka)\n    {\n      for (int kb = 0; kb < nb; ++kb)\n      {\n        float x = d[((nab * i) + (ka * nb)) + kb];\n        float y = t[((nab * j) + (ka * nb)) + kb];\n        float z = x + y;\n        vv[kb] = min(vv[kb], z);\n      }\n\n    }\n\n    float v = infty;\n    for (int kb = 0; kb < nb; ++kb)\n    {\n      v = min(vv[kb], v);\n    }\n\n    r[(n * i) + j] = v;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallel-rust-cpp/shortcut-comparison/src/cpp/v2_instr_level_parallelism/step/1"}
{"code": "for (currentColumn = 1; currentColumn < (subProblemSize[1] + 1); ++currentColumn)\n{\n  splitter[0][tempCounter] = 1;\n  splitter[1][tempCounter++] = currentColumn;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/7"}
{"code": "for (i = 3; (i * i) <= n; i = i + 2)\n{\n  if ((n % i) == 0)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment1/lab1_9/1"}
{"code": "for (i = 0; i < V; i++)\n{\n  if (vertices[i].label == root->label)\n    vertices[i].visited = true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arohan-mishra/nav-system-using-openmp/parallel_dijk/0"}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    field[FTNREF2D((x_max + x_inc) + j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = right_rcv_buffer[FTNREF1D(index, 1)];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/pack_kernel_c/3"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  res[omp_get_thread_num()] += a[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesyangc/ECE563-Parallel-Programming/hw3/hw3_b2/0"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at2 = (-ci2) * crealf(ffe[j]);\n  at1 = at2 * cimagf(ffe[j]);\n  at2 = at2 * at2;\n  exyz[3 * j] = at1 * dcu[3 * j];\n  exyz[1 + (3 * j)] = at1 * dcu[1 + (3 * j)];\n  exyz[2 + (3 * j)] = at1 * dcu[2 + (3 * j)];\n  exyz[3 * (j + k1)] = zero;\n  exyz[1 + (3 * (j + k1))] = zero;\n  exyz[2 + (3 * (j + k1))] = zero;\n  exyz[3 * (j + l1)] = zero;\n  exyz[1 + (3 * (j + l1))] = zero;\n  exyz[2 + (3 * (j + l1))] = zero;\n  exyz[3 * ((j + k1) + l1)] = zero;\n  exyz[1 + (3 * ((j + k1) + l1))] = zero;\n  exyz[2 + (3 * ((j + k1) + l1))] = zero;\n  wp += at2 * (((dcu[3 * j] * conjf(dcu[3 * j])) + (dcu[1 + (3 * j)] * conjf(dcu[1 + (3 * j)]))) + (dcu[2 + (3 * j)] * conjf(dcu[2 + (3 * j)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/27"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/3"}
{"code": "for (i = 0; i < model->t_size; ++i)\n{\n  t_val = gsl_matrix_get(model->R_mat, i, 0);\n  sgn = check_slope_R_t(model->r_vec->data[0], model->t_vec->data[i] + slope, t_val, model, eta_interp);\n  for (j = 0; j < model->r_size; ++j)\n  {\n    gsl_matrix_set(R_t, i, j, R_t_analytic_fun(gsl_matrix_get(model->R_mat, i, j), model->M_vec->data[j], model->E_vec->data[j], sgn));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    sum += masC[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/11"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  if (IterArr[i] < (Total / 4))\n    IterArr[i] = (Total / 4) - IterArr[i];\n  else\n    IterArr[i] = IterArr[i] - (Total / 4);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/21"}
{"code": "for (idx = 0; idx < 30; ++idx)\n{\n  c[idx] = a[idx] + b[idx];\n  tid = omp_get_thread_num();\n  printf(\"Thread %2d: c[%2d]=%.2f\\n\", tid, idx, c[idx]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/vec_add/vec_add/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  Stiffmatrix(MX, Ve, No, El, n1, k, h);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Matrixsetup/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  fprintf(op, \"%d\\n\", rand() % 100);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jainpranav/OpenMP_Fun/Project1/Sum/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  printf(\"%d\", matrix[i]);\n  printf((((i + 1) % 16) != 0) ? (\"\\t\") : (\"\\n\"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/icecr4ck/parallel-programming/openmp/labo2/6"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  A[(i * n) + j] = rand();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex6-matrix-max-openmp-wo-cr/1"}
{"code": "for (j = 0; j < ncolumns; j++)\n{\n  for (i = 0; i < nrows; i++)\n    temp[i] = u[index[i]][j];\n\n  for (i = 0; i < nrows; i++)\n    u[i][j] = temp[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/29"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vVelocityW[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/54"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  q[i] = 0.0;\n  for (j = 0; j < SIZE; j++)\n  {\n    q[i] = q[i] + (A[(i * SIZE) + j] * p[j]);\n  }\n\n}\n\n", "pragma": "omp distribute parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/BICG/bicg/1"}
{"code": "for (i = 0; i < local_n1; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < Nf; k++)\n{\n  const int z = (((i * N) + j) * Nf) + k;\n  curlZ[z] = one * ((kx[i + local_1_start] * V_hat[z]) - (kx[j] * U_hat[z]));\n  curlY[z] = one * ((kz[k] * U_hat[z]) - (kx[i + local_1_start] * W_hat[z]));\n  curlX[z] = one * ((kx[j] * W_hat[z]) - (kz[k] * V_hat[z]));\n}\n\n\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/6"}
{"code": "for (p = head; p != NULL; p = p->next)\n  nodelist.push_back(p);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_cpp/0"}
{"code": "for (int i = 0; i < (cells_per_side * cells_per_side); i++)\n{\n  cells[i].pq_within_move = cells[i].particle_quantity;\n  if (cells[i].particle_quantity != 0)\n  {\n    compute_cell(i, cells, dmin, davg, navg);\n  }\n\n}\n\n", "pragma": "#pragma omp for reduction (+:navg) reduction(+:davg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vjeganat/MD_simulations/Openmp_particles_in_bins/openmp/0"}
{"code": "for (j = 1; j < (n - 1); j++)\n{\n  for (i = 1; i < (m - 1); i++)\n  {\n    U_new[j][i] = (0.25f * (((U[j][i + 1] + U[j][i - 1]) + U[j - 1][i]) + U[j + 1][i])) + F[j][i];\n    error = fmaxf(error, fabsf(U_new[j][i] - U[j][i]));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(max: error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/laplace2d_omp_acc/0"}
{"code": "for (i = 0; i < ArraySize; i++)\n{\n  array[i] = Ranf(-1.f, 1.f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tanyakhemani/parallel-programming/project2/project2/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  y[j] = y[j] + (A[j][i] * x[i]);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jar-evans/Krylov_subspace_methods/c_openmp/libeig_pair/1"}
{"code": "for (int i = 0; i < N; i++)\n  mid_array[tester[i]]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/4"}
{"code": "for (u32 i = 0; i < f->len; i += 1)\n{\n  index[i + 1] = (u32) (f->node[i] != SENTINEL);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chibinz/ParallelBFS/src/frontier/2"}
{"code": "for (int i = n - 1; i > 0; i--)\n{\n  int j = randInt(i + 1);\n  temp = str[j];\n  str[j] = str[i];\n  str[i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/0"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i - 2][j][k][m] - (4. * u[i - 1][j][k][m])) + (5.0 * u[i][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/92"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = i; j < n; j++)\n  {\n    random = rand() % 100;\n    if (i == j)\n    {\n      graf[i][i] = 0;\n    }\n    else\n    {\n      graf[i][j] = random;\n      graf[j][i] = random;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/6"}
{"code": "for (; it != it_end; ++it)\n  (*(*it)).DataSetForDerivatives.clear();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/12"}
{"code": "for (i = 0; i < img_in->m; i++)\n{\n  int j;\n  int el_i;\n  int el_j;\n  int x;\n  int y;\n  for (j = 0; j < img_in->n; j++)\n  {\n    double max = 0.0;\n    double temp;\n    for (el_i = 0; el_i < strel->m; el_i++)\n    {\n      for (el_j = 0; el_j < strel->n; el_j++)\n      {\n        y = (i - el_center_i) + el_i;\n        x = (j - el_center_j) + el_j;\n        if (((((y >= 0) && (x >= 0)) && (y < img_in->m)) && (x < img_in->n)) && (m_get_val(strel, el_i, el_j) != 0))\n        {\n          temp = m_get_val(img_in, y, x);\n          if (temp > max)\n            max = temp;\n\n        }\n\n      }\n\n    }\n\n    m_set_val(dilated, i, j, max);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(omp_num_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/1"}
{"code": "for (i = 1; i <= num_interval; i++)\n{\n  id = omp_get_thread_num();\n  x = (i - 0.5) * deltax;\n  sum[id] = sum[id] + ((4.0 / (1.0 + (x * x))) * deltax);\n}\n\n", "pragma": "omp parallel for default(shared) private (id,x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/pi_omp/0"}
{"code": "for (i = 0; i < numDivs; i++)\n{\n  if (Sel == 0)\n    *(bc + i) = (*(vNNMM + i)) - (*(reglin + i));\n  else\n    *(bc + i) = (*((vNNMM + i) + numDivs)) - (*(reglin + i));\n\n  *(m1 + i) = (*(bc + i)) * (*(bc + i));\n  Sum2 += *(m1 + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/11"}
{"code": "for (int i = 0; i < numSteps; i++)\n  Weights[i].resize(IDs[i].size(), 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FRSingleOMP/5"}
{"code": "for (int k = 0; k < N; k += 2)\n{\n  sum += factor / ((2 * k) + 1);\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilev4ik/openmp/main/1"}
{"code": "for (i = k + 1; i <= (startFrom + rowsToReceive); i++)\n{\n  if (i > startFrom)\n  {\n    for (j = k + 1; j <= n; j++)\n    {\n      A[((i - 1) * Alda) + (j - 1)] -= A[((i - 1) * Alda) + (k - 1)] * A[((k - 1) * Alda) + (j - 1)];\n    }\n\n    b[i - 1] -= A[((i - 1) * Alda) + (k - 1)] * b[k - 1];\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivR_OpenMP_MPI/1"}
{"code": "for (i = 0; i < NUMRES; i++)\n  def_aa_xref[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/19"}
{"code": "for (int i = 0; i < 2000000; i++)\n{\n  a[i] = rand() % 2000000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E1/max-noopt/0"}
{"code": "for (int i = 0; i < n_samples_all; i++)\n{\n  for (int j = 0; j < n_features; j++)\n  {\n    X_all[i][j] = data[i][j];\n  }\n\n  y[i] = (int) data[i][n_features];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp[i] = x[i] + ((0.5 * h) * k1[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example4/main/2"}
{"code": "for (unsigned int i = 0; i < nel; i++)\n{\n  for (unsigned int j = 0; j < nel; j++)\n  {\n    if (i < j)\n    {\n      (cout << map[k]) << ' ';\n      k++;\n    }\n    else\n    {\n      cout << \"_ \";\n    }\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/19"}
{"code": "for (i = 0; (i < 20) && (i < Team_num); ++i)\n{\n  if ((Team[i].team_flag == 1) && (Team[i].task.thread_id == team_thread_id))\n    return Team[i].team_num;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaodao90/wrapper/OpenMP/OMP_wrapper/2"}
{"code": "for (int i = 1; i <= numCities; i++)\n{\n  baseStr += i + '0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/15"}
{"code": "for (i = 0; i < len; i++)\n{\n  if (img[i] > strouf)\n    img[i] = 255;\n  else\n    img[i] = 0;\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ikhor/RPDIP/RPDIPDLL/RPDIPDLL/rpdip/0"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    cells->speeds0[ii + (jj * params.nx)] = w0;\n    cells->speeds1[ii + (jj * params.nx)] = w1;\n    cells->speeds2[ii + (jj * params.nx)] = w1;\n    cells->speeds3[ii + (jj * params.nx)] = w1;\n    cells->speeds4[ii + (jj * params.nx)] = w1;\n    cells->speeds5[ii + (jj * params.nx)] = w2;\n    cells->speeds6[ii + (jj * params.nx)] = w2;\n    cells->speeds7[ii + (jj * params.nx)] = w2;\n    cells->speeds8[ii + (jj * params.nx)] = w2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MichaelRol/Lattice-Boltzmann-OpenMP/d2q9-bgk/0"}
{"code": "for (int bin_idex = 0; bin_idex < bin_count; bin_idex++)\n{\n  total_particles += bin_map.at(bin_idex).size();\n  num_of_particles_in_curr_process_local += bin_map.at(bin_idex).size();\n  bin_process_map.push_back(current_process_id);\n  assigned_bin_count++;\n  if (current_process_id == current_process)\n  {\n    process_bins.push_back(bin_idex);\n  }\n\n  if ((assigned_bin_count >= num_bins_per_process) || ((bin_count - 1) == bin_idex))\n  {\n    if (current_process_id == current_process)\n    {\n      num_of_particles_in_curr_process = num_of_particles_in_curr_process_local;\n    }\n\n    assigned_bin_count = 0;\n    num_of_particles_in_curr_process_local = 0;\n    current_process_id++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/urmilas239/Openmp/common/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  array1[i] = array1[i] + array2[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp5/2-array-add/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  q = sol->r[i];\n  idiag = i - 1;\n  offset = 1;\n  while (idiag > 0)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag--;\n  }\n\n  idiag = i + 1;\n  offset = 1;\n  while (idiag < 8)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag++;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    q2 = sol->r[j];\n    if (j == i)\n    {\n      continue;\n    }\n\n    if (q2 == q)\n    {\n      printf(\"cols false!\\n\");\n      return 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonaut/8queensOpenMP/hw3/3"}
{"code": "for (i = 1; i < (block_height - 1); i++)\n{\n  for (j = 1; j < (block_width - 1); j++)\n  {\n    r_laplass(i, j) = DiffScheme(rk, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/20"}
{"code": "for (int i = 0; i < size; i++)\n{\n  data2[i] = data[i];\n}\n\n", "pragma": "\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/mergesort/0"}
{"code": "for (uint32_t i = 0; i < new_polygon_id_list.size(); i++)\n{\n  new_polygon_id_list[i] += start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/13"}
{"code": "for (iter = 1; iter <= NITER; iter++)\n{\n  startTime = MPI_Wtime();\n  if (barrier)\n    MPI_Barrier(1);\n\n  if (EXTRA != 0)\n  {\n    extraCalculations(t);\n  }\n\n  dt = work(t, &new, myPE, request, status);\n  if (reduce)\n    MPI_Reduce(&dt, &dtg, 1, (MPI_Datatype) 0x4c00040a, (MPI_Op) 0x58000001, 0, 1);\n\n  endTime = MPI_Wtime();\n  times[myPE][iter - 1] = endTime - startTime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/3"}
{"code": "for (i = n; i > 0; i--)\n{\n  p_g[i] = p_g[i - 1];\n  p_g_precond[i] = p_g_precond[i - 1];\n  p_d[i] = p_d[i - 1];\n  p_w[i] = p_w[i - 1];\n  c[i] = c[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/39"}
{"code": "for (int i = 0; i < imax;)\n{\n  for (int j = 0; j < jmax; j++, i++)\n    (app_log() << setw(12)) << mySeeds[i];\n\n  app_log() << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/OhmmsApp/RandomNumberControl/4"}
{"code": "for (l = 0; l < 1024; l++)\n{\n  for (l1 = 0; l1 < 1024; l1++)\n  {\n    A[l][l1] = (((float) rand()) / ((float) 32767)) * 3.0;\n    B[l][l1] = (((float) rand()) / ((float) 32767)) * 3.0;\n    C[l][l1] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/6"}
{"code": "for (int i = 0; i < count; i++)\n  NEON_LU_3_omp();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/14"}
{"code": "for (row_idx = 0; row_idx < len; ++row_idx)\n{\n  for (col_idx = 0; col_idx < len; ++col_idx)\n  {\n    matrix[(row_idx * len) + col_idx] = (((double) rand()) / ((double) 32767)) * max_val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ViktorooReps/skpod/openmp/src/tria_det/3"}
{"code": "for (i = 0; i < w; i++)\n{\n  for (j = 0; j < h; j++)\n  {\n    int init = (rand() % cmd_opts.mod_val) ? (1) : (0);\n    M[1][i + (w * j)] = init;\n    M[0][i + (w * j)] = init;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpolitzer/life/omp/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  if (adjacent_processes[i]->cells_buffer_send == 0)\n  {\n    adjacent_processes[i]->cells_buffer_send = (cell_t *) calloc(number_cells_max, sizeof(cell_t));\n  }\n\n  if (adjacent_processes[i]->cells_buffer_recv == 0)\n  {\n    adjacent_processes[i]->cells_buffer_recv = (cell_t *) calloc(number_cells_max, sizeof(cell_t));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/8"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  sum2 = 0.0;\n  aij = ai;\n  jx = kx;\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = head_x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    x_elem = tail_x_i[jx];\n    prod = a_elem * x_elem;\n    sum2 = sum2 + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  tmp1 = sum * alpha_i;\n  tmp2 = sum2 * alpha_i;\n  tmp1 = tmp1 + tmp2;\n  y_elem = y[iy];\n  tmp2 = y_elem * beta_i;\n  tmp1 = tmp1 + tmp2;\n  y[iy] = tmp1;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum,sum2) shared(a_i,head_x_i,tail_x_i,y_i) private(i,aij,jx,a_elem,prod,x_elem,j,ai,iy,tmp1,tmp2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/3"}
{"code": "for (int z = 0; z < n; z++)\n{\n  lhs = lhs || ((int) a[n - 1][z]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/1.Gaussian_Elimination/gausstest/4"}
{"code": "for (int i = 0; i < 8000; i++)\n{\n  for (int j = 0; j < 8000; j++)\n  {\n    original_A[i][j] = A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzunny97/LU-OpenMP/LU_decomposition/1"}
{"code": "for (v = 0; v < cache->numPropertyRegions; ++v)\n{\n  if ((line->addr >= cache->propertyRegions[v].lower_bound) && (line->addr < cache->propertyRegions[v].hot_bound))\n  {\n    result = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/14"}
{"code": "for (int k = 0; k < 8000; k++)\n{\n  for (int i = k + 1; i < 8000; i++)\n    A[i][k] /= A[k][k];\n\n  for (int i = k + 1; i < 8000; i++)\n  {\n    for (int j = k + 1; j < 8000; j++)\n    {\n      A[i][j] -= A[i][k] * A[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzunny97/LU-OpenMP/LU_decomposition/3"}
{"code": "for (int i = 0; i < 80000; ++i)\n{\n  a[i] = i;\n  b[i] = i / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TsingWei/MergeSort_openMP/openmp2/1"}
{"code": "for (i = 7; i >= 0; i--)\n{\n  {\n    printf(\"Hello World!\\t%s %d, %s %d\\n\", TOSTR(omp_get_thread_num), 7 - omp_get_thread_num(), TOSTR(omp_get_num_threads), omp_get_num_threads());\n  }\n}\n\n", "pragma": "#pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Karantir73/OpenMP-lab/task13/0"}
{"code": "for (i = 0; i < divisionsNum; i++)\n{\n  local_sum += integratingFunction(a + (i * dx)) * dx;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherzod-ortiq/parallel_programming/definiteIntegralParallel/0"}
{"code": "for (int i = 0; i < Num_calc; i++)\n  gemv(N, 1.0f, manyA[i], manyV[i], manyVout[i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/hands-on/gemv/51-gemv-omp-many-matrices/gemv-omp-many-matrices/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  I[(i * size) + i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/6"}
{"code": "form[1] = format(nb.commit)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/smoothing/2"}
{"code": "for (int i = 0; i < length; i++)\n{\n  r_kernel[(length - 1) - i] = kernel[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erictu/Image-Processing-Optimization/part2/4"}
{"code": "for (i = 0; i < 512; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 512; j++)\n    for (k = 0; k < 512; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/mm/omp_mm/3"}
{"code": "for (i = 0; i < size; i++)\n  if (scanf(\"%d\", &a[i]) != 1)\n{\n  printf(\"Fail to scan vector a\\n\");\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcksber/CMU_15-418_hw3/examples/loop/1"}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (j + depth) + ((k - 1) * ((x_max + x_inc) + (2 * depth)));\n  bottom_snd_buffer[FTNREF1D(index, 1)] = field[FTNREF2D(j, ((y_min + y_inc) - 1) + k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)];\n}\n\n", "pragma": "omp for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/pack_kernel_c/4"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    aux = cube[x][y];\n    while (aux != 0)\n    {\n      if (aux->status == 1)\n      {\n        fprintf(stdout, \"%d %d %d\\n\", x, y, aux->z);\n      }\n\n      temp = aux->next;\n      free(aux);\n      aux = temp;\n    }\n\n  }\n\n  free(cube[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbsousa01/Game-of-Life3D/life3d-omp/life3d-omp/3"}
{"code": "for (uint64_t index = 0; index < m; index++)\n  if (b[index] != ((index * (index + 1)) / 2))\n  ((((cout << \"error at position \") << index) << \" \") << b[index]) << endl;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JGU-HPC/parallelprogrammingbook/chapter6/matrix_vector/matrix_vector/0"}
{"code": "for (int i = 0; i < ((numP - 1) * num_readers); i++)\n{\n  list_file.push_back(request_termination_message);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ericlamnguyen/Map-Reduce-with-MPI-and-OpenMP/src/main/1"}
{"code": "for (i = 0; i < 10; i++)\n  mn = (mn < a[i]) ? (mn) : (a[i]);\n\n", "pragma": "omp parallel for reduction(min:mn)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/reduction_min_max/0"}
{"code": "for (int i = 0; i < num_elements; i++)\n{\n  float proj_angle = obj[i].getangle();\n  float proj_vel = obj[i].getvelocity();\n  float sin_value = sinf((proj_angle * kPIValue) / 180.0f);\n  float cos_value = cosf((proj_angle * kPIValue) / 180.0f);\n  float total_time = fabsf((2 * proj_vel) * sin_value) / kGValue;\n  float max_range = fabsf((proj_vel * total_time) * cos_value);\n  float max_height = ((((proj_vel * proj_vel) * sin_value) * sin_value) / 2.0f) * kGValue;\n  pObj[i].setRangeandTime(max_range, total_time, proj_angle, proj_vel, max_height);\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/projectile-omp/Projectile/0"}
{"code": "for (int i = 0; i < t; i++)\n{\n  for (int j = 0; j < q; j++)\n  {\n    if (i == 0)\n    {\n      int observation = Y[0];\n      dp1[0][j] = I[j] + B[j][observation];\n      dp2[0][j] = 0;\n    }\n    else\n    {\n      dp1[i][j] = get_rand_float(min_prob, max_prob);\n      dp2[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_hybrid/2"}
{"code": "for (i = 0; i < itr; i++)\n{\n  cross(a, f, fp);\n  mutate(a, f, fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/13"}
{"code": "for (uint i = 1; i < numBuckets; ++i)\n  globalHistoExScan[i] = globalHistoExScan[i - 1] + globalHisto[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/3"}
{"code": "for (size_t q = 0; q < Nqd; q++)\n{\n  PolPol.setZero();\n  PolPol = (quadss(q, 2) * Polt.block(q, 0, 1, k + 1).transpose()) * Poltau.block(q, 0, 1, k + 1);\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, i) = Kdiag(q, i);\n  }\n\n  K += kron(Kdq, PolPol);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/9"}
{"code": "for (int i = 3; i <= n; i += 2)\n{\n  if (IsPrime(i))\n  {\n    out[(int) floor(i / 2)] = i;\n  }\n  else\n  {\n    out[(int) floor(i / 2)] = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule (runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisfrt/openmp-primenumbers/benchmark/0"}
{"code": "for (i = 0; i < strip_size; ++i)\n{\n  for (j = 0; j < gridsize; ++j)\n  {\n    if ((j == 0) || (j == (gridsize - 1)))\n      outer_ptr[i][j] = 1.0;\n    else\n      outer_ptr[i][j] = 0.0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/imsure/parallel-programming/red-black-grid-computation/rb-grid-hybrid/7"}
{"code": "for (int i = 0; i < (alto - 1); i++)\n{\n  for (int j = 0; j < (ancho - 1); j++)\n  {\n    out_arr[(i * ancho) + j].b = my_arr[((i * ancho) + ancho) - j].b;\n    out_arr[(i * ancho) + j].g = my_arr[((i * ancho) + ancho) - j].g;\n    out_arr[(i * ancho) + j].r = my_arr[((i * ancho) + ancho) - j].r;\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/1"}
{"code": "for (m = 0; m < 3; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k])) - (lhs[n + 4][i][j][k] * rhs[m][i2][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/52"}
{"code": "for (i_imopVarPre75 = ist; i_imopVarPre75 <= iend; i_imopVarPre75++)\n{\n  for (j_imopVarPre76 = jst; j_imopVarPre76 <= jend; j_imopVarPre76++)\n  {\n    for (k_imopVarPre77 = 1; k_imopVarPre77 <= (nz0 - 2); k_imopVarPre77++)\n    {\n      sum0 = sum0 + (v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][0] * v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][0]);\n      sum1 = sum1 + (v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][1] * v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][1]);\n      sum2 = sum2 + (v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][2] * v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][2]);\n      sum3 = sum3 + (v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][3] * v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][3]);\n      sum4 = sum4 + (v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][4] * v[i_imopVarPre75][j_imopVarPre76][k_imopVarPre77][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/12"}
{"code": "for (int col = OFFSET; col < (width - OFFSET); col++)\n{\n  for (int row = OFFSET; row < (height - OFFSET); row++)\n  {\n    double grad_x_sum = 0.0;\n    double grad_y_sum = 0.0;\n    int kernel_index = 0;\n    int pixel_index = col + (row * width);\n    for (int krow = -OFFSET; krow <= OFFSET; krow++)\n    {\n      for (int kcol = -OFFSET; kcol <= OFFSET; kcol++)\n      {\n        grad_x_sum += input_image[pixel_index + (kcol + (krow * width))] * Gx[kernel_index];\n        grad_y_sum += input_image[pixel_index + (kcol + (krow * width))] * Gy[kernel_index];\n        kernel_index++;\n      }\n\n    }\n\n    int pixel_direction = 0;\n    if ((grad_x_sum == 0.0) || (grad_y_sum == 0.0))\n    {\n      magnitude[pixel_index] = 0;\n    }\n    else\n    {\n      magnitude[pixel_index] = sqrt((grad_x_sum * grad_x_sum) + (grad_y_sum * grad_y_sum));\n      double theta = atan2(grad_y_sum, grad_x_sum);\n      theta = theta * (360.0 / (2.0 * M_PI));\n      if ((((theta <= 22.5) && (theta >= (-22.5))) || (theta <= (-157.5))) || (theta >= 157.5))\n        pixel_direction = 1;\n      else\n        if (((theta > 22.5) && (theta <= 67.5)) || ((theta > (-157.5)) && (theta <= (-112.5))))\n        pixel_direction = 2;\n      else\n        if (((theta > 67.5) && (theta <= 112.5)) || ((theta >= (-112.5)) && (theta < (-67.5))))\n        pixel_direction = 3;\n      else\n        if (((theta >= (-67.5)) && (theta < (-22.5))) || ((theta > 112.5) && (theta < 157.5)))\n        pixel_direction = 4;\n      else\n        ((cout << \"Wrong direction: \") << theta) << endl;\n\n\n\n\n    }\n\n    direction[pixel_index] = (uint8_t) pixel_direction;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashsm79/parallel-canny-edge-detector/src/canny/1"}
{"code": "for (unsigned int i = 0; i < scan.ranges.size(); i++)\n{\n  if (scan.ranges[i] < scan.range_min)\n    ranges_double[i] = (double) scan.range_max;\n  else\n    ranges_double[i] = (double) scan.ranges[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/slam_gmapping/1"}
{"code": "for (i = 1; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    testaccumulator += m_testmatrix->GetElem(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fpaboim/gpufem/src/Test/SPRmatrixTest/9"}
{"code": "for (int p = 0; p < (NUMPCLS * 8); p++)\n{\n  p2[p] = p1[p];\n}\n\n", "pragma": "  #pragma omp for schedule(static,NUMPCLS*4) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testv2/6"}
{"code": "for (itr = dictionary.begin(); itr != dictionary.end(); ++itr)\n{\n  (((cout << itr->first) << '\\t') << itr->second) << endl;\n  if (i == 9)\n    break;\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasag17/TET-Project2/intentosAnteriores/openmp/1"}
{"code": "for (c = 19; c < argc; c++)\n{\n  if (!strcmp(argv[c], \"-mproj\"))\n  {\n    mproj = 1;\n    mcolrow = 0;\n    mauto = 0;\n    projXwet = atof(argv[c + 1]);\n    projYwet = atof(argv[c + 2]);\n    projXdry = atof(argv[c + 3]);\n    projYdry = atof(argv[c + 4]);\n  }\n\n  if (!strcmp(argv[c], \"-mcolrow\"))\n  {\n    mproj = 0;\n    mcolrow = 1;\n    mauto = 0;\n    col_wet = atoi(argv[c + 1]);\n    row_wet = atoi(argv[c + 2]);\n    col_dry = atoi(argv[c + 3]);\n    row_dry = atoi(argv[c + 4]);\n  }\n\n  if (!strcmp(argv[c], \"-mauto\"))\n  {\n    mproj = 0;\n    mcolrow = 0;\n    mauto = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/4"}
{"code": "for (i = row3; i < (sizeOfTheMatrix + row3); i++)\n{\n  for (j = row3; j < (sizeOfTheMatrix + row3); j++)\n  {\n    resMatrix[i][j] = firstMatrix[(i - row3) + rowFirst][(j - col3) + columnFirst] + secondMatrix[(i - row3) + rowSecond][(j - col3) + columnSecond];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/praveenChauhan686/Strassen-Algorithm-Java-And-OpenMp/Assignment 2_21261912/Source Code/OpenMp C/strassens_algorithm/1"}
{"code": "for (j = 0; j < NTask; j++)\n  nsend_local[j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/density/4"}
{"code": "for (ptrdiff_t i = 0; i < size; ++i)\n{\n  *(data + i) = *(first + i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/5"}
{"code": "for (int v = 0; v < N; v += 4)\n{\n  if ((((visit_p[v] == false) && (dist_p[minNode] != INT_MAX)) && (graph[minNode][v] != 0)) && (dist_p[v] > (dist_p[minNode] + graph[minNode][v])))\n  {\n    dist_p[v] = dist_p[minNode] + graph[minNode][v];\n  }\n\n  if ((v + 1) < N)\n  {\n    if ((((visit_p[v + 1] == false) && (dist_p[minNode] != INT_MAX)) && (graph[minNode][v + 1] != 0)) && (dist_p[v + 1] > (dist_p[minNode] + graph[minNode][v + 1])))\n    {\n      dist_p[v + 1] = dist_p[minNode] + graph[minNode][v + 1];\n    }\n\n  }\n\n  if ((v + 2) < N)\n  {\n    if ((((visit_p[v + 2] == false) && (dist_p[minNode] != INT_MAX)) && (graph[minNode][v + 2] != 0)) && (dist_p[v + 2] > (dist_p[minNode] + graph[minNode][v + 2])))\n    {\n      dist_p[v + 2] = dist_p[minNode] + graph[minNode][v + 2];\n    }\n\n  }\n\n  if ((v + 3) < N)\n  {\n    if ((((visit_p[v + 3] == false) && (dist_p[minNode] != INT_MAX)) && (graph[minNode][v + 3] != 0)) && (dist_p[v + 3] > (dist_p[minNode] + graph[minNode][v + 3])))\n    {\n      dist_p[v + 3] = dist_p[minNode] + graph[minNode][v + 3];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nickpei/EECS224-High-Performance-Computing/Dijkstra_omp_v4/6"}
{"code": "for (int g = 0; g < I->n_egroups; g++)\n{\n  expVal[g] = interpolateTable(params.expTable, tau[g]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/20"}
{"code": "for (register unsigned int j = 0; j < N; j += incY)\n{\n  save = Y[j];\n  Y[j] = X[j];\n  X[j] = save;\n}\n\n", "pragma": "omp for schedule(static) private (save)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/swap/0"}
{"code": "for (int i = 0; i < nEntry; i++)\n{\n  A_aux1 = createNode();\n  fscanf(fp, \"%d %d %lf\", &A_aux1->user, &A_aux1->item, &A_aux1->rate);\n  if (A_user[A_aux1->user] == 0)\n  {\n    A_user[A_aux1->user] = A_aux1;\n    A_user_aux[A_aux1->user] = A_aux1;\n  }\n  else\n  {\n    A_user_aux[A_aux1->user]->nextItem = A_aux1;\n    A_user_aux[A_aux1->user] = A_aux1;\n  }\n\n  if (A_item[A_aux1->item] == 0)\n  {\n    A_item[A_aux1->item] = A_aux1;\n    A_item_aux[A_aux1->item] = A_aux1;\n  }\n  else\n  {\n    A_item_aux[A_aux1->item]->nextUser = A_aux1;\n    A_item_aux[A_aux1->item] = A_aux1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/7"}
{"code": "for (int x = x_m; x <= x_M; x++)\n{\n  for (int y = y_m; y <= y_M; y++)\n  {\n    for (int z = z_m; z <= z_M; z++)\n    {\n      u[t][x][y][z] = u[t][x][y][z] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/devito_prob1/devito_prob1/0"}
{"code": "for (i = 1; i <= 1000; ++i)\n{\n  diff = diff - i;\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(-:diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_reduction/1"}
{"code": "for (int i = 1; i <= omp_get_num_procs(); i++)\n{\n  sleep(4);\n  printf(\"\\n\\e[38;2;0;255;0m \\e[48;2;0;0;0m Algoritmo con pragmas usando %d procesador/es: \\e[0m\\n\\n\", i);\n  for (int j = 0; j < 8; j++)\n  {\n    times_1[j] = pickerMatrix(option, i, size_matrix, matrix_A, matrix_B);\n    times_2[j] = pickerMatrix(option + 2, i, size_matrix, matrix_A, matrix_B);\n    if (option == 2)\n    {\n      times_3[j] = pickerMatrix(option + 4, i, size_matrix, matrix_A, matrix_B);\n      times_4[j] = pickerMatrix(option + 5, i, size_matrix, matrix_A, matrix_B);\n    }\n\n  }\n\n  double avg_1 = getAverage(times_1, 8);\n  double avg_2 = getAverage(times_2, 8);\n  promedio_1[i] = avg_1;\n  devioEstandar_1[i] = getStdDeviation(times_1, avg_1, 8);\n  promedio_2[i] = avg_2;\n  devioEstandar_2[i] = getStdDeviation(times_2, avg_2, 8);\n  if (option == 2)\n  {\n    double avg_3 = getAverage(times_3, 8);\n    double avg_4 = getAverage(times_4, 8);\n    promedio_3[i] = avg_3;\n    devioEstandar_3[i] = getStdDeviation(times_3, avg_3, 8);\n    promedio_4[i] = avg_4;\n    devioEstandar_4[i] = getStdDeviation(times_4, avg_4, 8);\n  }\n\n  if (option == 1)\n  {\n    printf(\"El\\e[38;2;0;0;255m \\e[48;2;0;0;0m \\e[3mdesvio estandar \\e[0m para el  atomic con %d proc: \\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m segundos \", i, devioEstandar_1[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para el  atomic con %d proc: \\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m segundos\\n\\n\", i, promedio_1[i]);\n    printf(\"El\\e[38;2;0;0;255m \\e[48;2;0;0;0m \\e[3mdesvio estandar \\e[0m para el critical con %d proc:\\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m segundos \", i, devioEstandar_2[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para el critical con %d proc:\\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m segundos\\n\\n\", i, promedio_2[i]);\n  }\n  else\n  {\n    printf(\"El \\e[38;2;0;0;255m\\e[48;2;0;0;0m\\e[3m desvio estandar \\e[0m para el Reduction con %d proc: \\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m seg\\t\", i, devioEstandar_1[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para el Reduction con %d proc:\\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m seg\\n\\n\", i, promedio_1[i]);\n    printf(\"El \\e[38;2;0;0;255m\\e[48;2;0;0;0m\\e[3m desvio estandar \\e[0m para Dynamic con %d proc:\\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m seg\\t\\t\", i, devioEstandar_2[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para Dynamic con %d proc:\\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m seg\\n\\n\", i, promedio_2[i]);\n    printf(\"El \\e[38;2;0;0;255m\\e[48;2;0;0;0m\\e[3m desvio estandar \\e[0m para el Guided con %d proc: \\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m seg\\t\\t\", i, devioEstandar_3[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para el Guided con %d proc:\\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m seg\\n\\n\", i, promedio_3[i]);\n    printf(\"El \\e[38;2;0;0;255m\\e[48;2;0;0;0m\\e[3m desvio estandar \\e[0m para Static con %d proc:\\e[38;2;0;0;255m \\e[48;2;0;0;0m %lf \\e[0m seg\\t\\t\", i, devioEstandar_4[i]);\n    printf(\"\\e[38;5;196m \\e[48;2;0;0;0m\\e[3m Promedio \\e[0m de tiempo para Static con %d proc:\\e[38;5;196m \\e[48;2;0;0;0m %lf \\e[0m seg\\n\\n\", i, promedio_4[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/10"}
{"code": "for (int num = 2; num <= ((int) pow(maxRange, 1.0 / 2)); num++)\n{\n  bool flag = true;\n  for (int div = 2; div <= pow(num, 1.0 / 2); div++)\n  {\n    if ((num % div) == 0)\n    {\n      flag = false;\n      break;\n    }\n\n  }\n\n  if (flag)\n  {\n    primesMatrix[i++] = num;\n    *primesCount = (*primesCount) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jedrzej-put/PUT-OpenMP/sieve-parallel-domain/0"}
{"code": "for (int i = 0; i < size; ++i)\n  for (int k = 0; k < size; ++k)\n  for (int j = 0; j < size; ++j)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "#pragma omp parallel for default(none) shared(A,B,C,size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daseibert2/OpenMP_Exercises/target_matrix_mul/1"}
{"code": "for (t = 0; t < 8; t++)\n{\n  int i0 = t * (1024 / 8);\n  int i1 = (t + 1) * (1024 / 8);\n  {\n    {\n      for (int i = i0; i < i1; i++)\n        A[i] = (C[i] + D[i]) + 1;\n\n    }\n  }\n}\n\n", "pragma": "omp parallel for num_threads(T) schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-concurrent-target/test/2"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n  {\n    int neighbor_count = num_neighbors(matrix, i, j, dim);\n    if (neighbor_count == 2)\n    {\n      newGen[i][j] = matrix[i][j];\n    }\n\n    if (neighbor_count == 3)\n    {\n      newGen[i][j] = 1;\n    }\n\n    if ((neighbor_count < 2) || (neighbor_count > 3))\n    {\n      newGen[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sonamt731/PrimeNumbersParallel/primes/0"}
{"code": "for (int ii = 0; ii < params.nx; ii++)\n{\n  if ((((!obstacles[ii + (jj * params.nx)]) && ((cells->speed3[ii + (jj * params.nx)] - w_1) > 0.f)) && ((cells->speed6[ii + (jj * params.nx)] - w_2) > 0.f)) && ((cells->speed7[ii + (jj * params.nx)] - w_2) > 0.f))\n  {\n    cells->speed1[ii + (jj * params.nx)] += w_1;\n    cells->speed3[ii + (jj * params.nx)] -= w_1;\n    cells->speed5[ii + (jj * params.nx)] += w_2;\n    cells->speed6[ii + (jj * params.nx)] -= w_2;\n    cells->speed7[ii + (jj * params.nx)] -= w_2;\n    cells->speed8[ii + (jj * params.nx)] += w_2;\n  }\n\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/openMP/d2q9-bgk/1"}
{"code": "for (int i = 2; i < num; i++)\n{\n  if ((num % i) == 0)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/6_multitasking/multitask/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = (4 * nxvh) * k;\n  k1 = ((4 * nxvh) * ny) - kj;\n  #pragma ivdep\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    fxy[(4 * j) + kj] = exy[(4 * j) + kj] * at1;\n    fxy[(1 + (4 * j)) + kj] = exy[(1 + (4 * j)) + kj] * at1;\n    fxy[(2 + (4 * j)) + kj] = exy[(2 + (4 * j)) + kj] * at1;\n    fxy[(4 * j) + k1] = exy[(4 * j) + k1] * at1;\n    fxy[(1 + (4 * j)) + k1] = exy[(1 + (4 * j)) + k1] * at1;\n    fxy[(2 + (4 * j)) + k1] = exy[(2 + (4 * j)) + k1] * at1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/20"}
{"code": "for (i = 0; i < num_elements; i++)\n{\n  sum += array[i];\n}\n\n", "pragma": "omp parallel for reduction(+: sum) num_threads(10)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/Combining OpenMP and MPI/average/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    fa >> A[(j * n) + i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shorin1/openMP/openMP/openMP/2"}
{"code": "for (int i = 0; i < n_threads; i++)\n  vector[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hachreak/parallel_computing-demo/openmp/03_sum_array/0"}
{"code": "for (k = 0; k < 50; k++)\n{\n  cj = aj;\n  bj = scalar * cj;\n  cj = aj + bj;\n  aj = bj + (scalar * cj);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/Libraries-Benchmarking/likwid/stream-mapi/2"}
{"code": "for (i = 0; i < 64; i++)\n{\n  int k = foo(0);\n  k++;\n  thrglobalvar++;\n  thrlocvar++;\n  foo(i);\n  foo(constvar);\n  foo(*p);\n  (*p)++;\n  bar(p);\n  foo(s);\n  globalvar++;\n  locvar++;\n  l++;\n  for (j = 0; j < 2; j++)\n    ;\n\n}\n\n", "pragma": "omp parallel for default (none) private (p) shared (s)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/sharing-1/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"tid= %d i= %d c[i]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp parallel for private(i) schedule(static,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ksheeraj1161/OpenMP-MPI/OpenMP/program6/0"}
{"code": "for (i = 0; i < ((int) max_iter); ++i)\n{\n  if (!strcmp(crypted, tab))\n  {\n    printf(\">>> Thread n\u00b0%d: password found: %s\\n\", omp_get_thread_num(), tab);\n    ret = i;\n  }\n\n  ++tab[0];\n  for (j = 0; j < (length - 1); ++j)\n  {\n    if (last_char == tab[j])\n    {\n      tab[j] = first_char;\n      ++tab[j + 1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp cancellation point for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Yulypso/Richarallele/OpenMp/Ex3/breaker_for/3"}
{"code": "for (int i = 0; i < ArraySize; ++i)\n{\n  A[i] = i % 3;\n  B[i] = i % 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Smirnov-Mikhail/OpenMP/Task2/Task2/Task2/0"}
{"code": "for (int j = 0; j < ncon; j++)\n{\n  if (ind->constr[j] < 0.0)\n  {\n    ind->constr_violation += ind->constr[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/20"}
{"code": "for (int i = 0; i < V; i++)\n  (cout << a.route[i]) << \"->\";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize_tsp_ga/9"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  add_vectors0(c, a, b);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/10"}
{"code": "for (int i = 0; i < K; i++)\n{\n  (((cout << \"Cluster \") << i) << \" contains: \") << endl;\n  int count = 0;\n  for (int j = 0; j < numPoints; j++)\n  {\n    if (i == globalMembership[j])\n    {\n      ((cout << \"Point \") << dataset[j].id) << endl;\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/19"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    if ((((i == 0) || (i == (nx - 1))) || (j == 0)) || (j == (ny - 1)))\n    {\n      unew[i][j] = f[i][j];\n    }\n    else\n    {\n      unew[i][j] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/7"}
{"code": "for (i = 0; i < 16; i++)\n  free((void *) args[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/7"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int k = 0; k < 3; ++k)\n  {\n    if (r[i][k] > 0)\n    {\n      rn[i][k] = fmod(r[i][k] + L2[k], L[k]) - L2[k];\n    }\n    else\n    {\n      rn[i][k] = fmod(r[i][k] - L2[k], L[k]) + L2[k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/1"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  printf(\"C[%d][%d]= %d\\n\", i, j, matriz_resultante[(i * N) + j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BrunoGomesCoelho/open_mpi/ex_aula8/4"}
{"code": "for (i = 0; i < 20; i++)\n{\n  value = ((((uint32_t) atoi64[ARCH_INDEX(pos[0])]) | (((uint32_t) atoi64[ARCH_INDEX(pos[1])]) << 6)) | (((uint32_t) atoi64[ARCH_INDEX(pos[2])]) << 12)) | (((uint32_t) atoi64[ARCH_INDEX(pos[3])]) << 18);\n  pos += 4;\n  out[i] = value >> 16;\n  out[i + 21] = value >> 8;\n  out[i + 42] = value;\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dragonfly4_fmt_plug/1"}
{"code": "for (unsigned i = 0; i < size_h; i++)\n{\n  for (unsigned j = 0; j < size_v; ++j)\n  {\n    modelRBM.dW[i][j] = (((targetVals[j] - inputRBM.Vs[j]) * inputRBM.Vs[j]) * (1 - inputRBM.Vs[j])) * inputRBM.Hp[i];\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/6"}
{"code": "for (i = 0; i < a; i++)\n{\n  for (j = 0; j < b; j++)\n  {\n    printf(\"%f \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/15"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  lOut[rowcol] = 0.0;\n  for (n = 0; n < nwin; n++)\n  {\n    data1[n] = 0.0;\n    data2[n] = 0.0;\n  }\n\n  if ((rowcol % nwin) == 0)\n  {\n    for (n = 0; n < nwin; n++)\n    {\n      data1[n] = l2[rowcol + n];\n      data2[n] = l3[rowcol + n];\n    }\n\n    lOut[rowcol] = coherenceWindowed(n, data1, data2);\n    for (n = 0; n < nwin; n++)\n    {\n      lOut[rowcol + n] = lOut[rowcol];\n    }\n\n  }\n  else\n  {\n    lOut[rowcol] = -28768;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol,data1,data2,n) shared (N, l2, l3, lOut, nwin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_COH/main/0"}
{"code": "for (int i = 0; i < num_outputs; i++)\n{\n  double diff = desired_values[i] - output_values[i];\n  sum += diff * diff;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ghulette/neural-net-openmp/neuralnet/8"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 0; j <= (m - 1); j += 1)\n  {\n    xx = (-1.0) + (dx * (i - 1));\n    yy = (-1.0) + (dy * (j - 1));\n    temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n    error = error + (temp * temp);\n  }\n\n}\n\n", "pragma": "omp parallel for private (xx,yy,temp,i,j) reduction (+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_firstprivate3/0"}
{"code": "for (c1 = 0; c1 <= ((((nk + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(nk + (-1))) + 16) + 1) / 16)) : (-((((-(nk + (-1))) + 16) - 1) / 16))) : ((nk + (-1)) / 16)); c1++)\n{\n  for (c2 = 0; c2 <= ((((nj + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(nj + (-1))) + 16) + 1) / 16)) : (-((((-(nj + (-1))) + 16) - 1) / 16))) : ((nj + (-1)) / 16)); c2++)\n  {\n    for (c3 = 16 * c1; c3 <= ((((16 * c1) + 15) < (nk + (-1))) ? ((16 * c1) + 15) : (nk + (-1))); c3++)\n    {\n      for (c4 = 16 * c2; c4 <= ((((16 * c2) + 15) < (nj + (-1))) ? ((16 * c2) + 15) : (nj + (-1))); c4++)\n      {\n        B[c3][c4] = (((double) c3) * (c4 + 1)) / nj;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2, c4, c3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-tile-no/7"}
{"code": "for (int i = 74; i < 98; ++i)\n{\n  w[i] *= B3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/16"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    (cout << data.at(i).at(j)) << ' ';\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilya1032/Multithread-course-work-Java-threads-pthreads-OpenMP-/pthreads_OpenMP/src/sources/Matrix/3"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (argv[i][0] == '-')\n  {\n    switch (argv[i][1])\n    {\n      case 'N':\n        sscanf(argv[i + 1], \"%d\", &N);\n        break;\n\n      case 's':\n        sscanf(argv[i + 1], \"%lf\", &x_init);\n        break;\n\n      case 'f':\n        sscanf(argv[i + 1], \"%lf\", &x_fin);\n        break;\n\n      case 't':\n        sscanf(argv[i + 1], \"%d\", &num_t);\n        break;\n\n      case 'p':\n        paral_flag = 1;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe3/Tsouros_num_diff/2"}
{"code": "for (i_imopVar128 = 1; i_imopVar128 < (grid_points[0] - 1); i_imopVar128++)\n{\n  for (j_imopVar129 = 1; j_imopVar129 < (grid_points[1] - 1); j_imopVar129++)\n  {\n    for (k_imopVar130 = 0; k_imopVar130 < grid_points[2]; k_imopVar130++)\n    {\n      tmp1 = 1.0 / u[i_imopVar128][j_imopVar129][k_imopVar130][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][0][0] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][0][1] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][0][2] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][0][3] = 1.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][0][4] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][1][0] = (-(u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][1][1] = u[i_imopVar128][j_imopVar129][k_imopVar130][3] * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][1][2] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][1][3] = u[i_imopVar128][j_imopVar129][k_imopVar130][1] * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][1][4] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][2][0] = (-(u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][2][1] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][2][2] = u[i_imopVar128][j_imopVar129][k_imopVar130][3] * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][2][3] = u[i_imopVar128][j_imopVar129][k_imopVar130][2] * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][2][4] = 0.0;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][3][0] = (-((u[i_imopVar128][j_imopVar129][k_imopVar130][3] * u[i_imopVar128][j_imopVar129][k_imopVar130][3]) * tmp2)) + ((0.50 * c2) * ((((u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][1]) + (u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][2])) + (u[i_imopVar128][j_imopVar129][k_imopVar130][3] * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2));\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][3][1] = ((-c2) * u[i_imopVar128][j_imopVar129][k_imopVar130][1]) * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][3][2] = ((-c2) * u[i_imopVar128][j_imopVar129][k_imopVar130][2]) * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][3][3] = ((2.0 - c2) * u[i_imopVar128][j_imopVar129][k_imopVar130][3]) * tmp1;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][3][4] = c2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][4][0] = (((c2 * (((u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][1]) + (u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][2])) + (u[i_imopVar128][j_imopVar129][k_imopVar130][3] * u[i_imopVar128][j_imopVar129][k_imopVar130][3]))) * tmp2) - (c1 * (u[i_imopVar128][j_imopVar129][k_imopVar130][4] * tmp1))) * (u[i_imopVar128][j_imopVar129][k_imopVar130][3] * tmp1);\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][4][1] = ((-c2) * (u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][4][2] = ((-c2) * (u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2;\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][4][3] = (c1 * (u[i_imopVar128][j_imopVar129][k_imopVar130][4] * tmp1)) - ((0.50 * c2) * ((((u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][1]) + (u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][2])) + ((3.0 * u[i_imopVar128][j_imopVar129][k_imopVar130][3]) * u[i_imopVar128][j_imopVar129][k_imopVar130][3])) * tmp2));\n      fjac[i_imopVar128][j_imopVar129][k_imopVar130][4][4] = (c1 * u[i_imopVar128][j_imopVar129][k_imopVar130][3]) * tmp1;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][0][0] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][0][1] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][0][2] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][0][3] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][0][4] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][1][0] = ((-c3c4) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][1];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][1][1] = c3c4 * tmp1;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][1][2] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][1][3] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][1][4] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][2][0] = ((-c3c4) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][2];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][2][1] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][2][2] = c3c4 * tmp1;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][2][3] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][2][4] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][3][0] = (((-con43) * c3c4) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][3];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][3][1] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][3][2] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][3][3] = ((con43 * c3) * c4) * tmp1;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][3][4] = 0.0;\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][4][0] = (((((-(c3c4 - c1345)) * tmp3) * (u[i_imopVar128][j_imopVar129][k_imopVar130][1] * u[i_imopVar128][j_imopVar129][k_imopVar130][1])) - (((c3c4 - c1345) * tmp3) * (u[i_imopVar128][j_imopVar129][k_imopVar130][2] * u[i_imopVar128][j_imopVar129][k_imopVar130][2]))) - ((((con43 * c3c4) - c1345) * tmp3) * (u[i_imopVar128][j_imopVar129][k_imopVar130][3] * u[i_imopVar128][j_imopVar129][k_imopVar130][3]))) - ((c1345 * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][4]);\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][4][1] = ((c3c4 - c1345) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][1];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][4][2] = ((c3c4 - c1345) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][2];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][4][3] = (((con43 * c3c4) - c1345) * tmp2) * u[i_imopVar128][j_imopVar129][k_imopVar130][3];\n      njac[i_imopVar128][j_imopVar129][k_imopVar130][4][4] = c1345 * tmp1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/39"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  C[A[i]] = C[A[i]] + 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feperessim/counting-sort-parallel-openmp/counting_sort_serial_and_parallel/0"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  outputData = inputData;\n  storedData = outputData;\n  outputData = _mm_mulhi_epi16(ascii_magic_1_8, outputData);\n  outputData = _mm_srai_epi16(outputData, 2);\n  inputData = outputData;\n  outputData = _mm_mullo_epi16(ten_8, outputData);\n  outputData = _mm_sub_epi16(storedData, outputData);\n  outputData = _mm_add_epi16(ascii_magic_2_8, outputData);\n  oNumString[4 - i] = outputData.m128i_i16[0];\n  oNumString[10 - i] = outputData.m128i_i16[1];\n  oNumString[16 - i] = outputData.m128i_i16[2];\n  oNumString[22 - i] = outputData.m128i_i16[3];\n  oNumString[28 - i] = outputData.m128i_i16[4];\n  oNumString[34 - i] = outputData.m128i_i16[5];\n  oNumString[40 - i] = outputData.m128i_i16[6];\n  oNumString[46 - i] = outputData.m128i_i16[7];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/8"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/80"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    for (int k = 0; k < size; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YShoun/matrix-mul/main/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (first)\n  {\n    printf(\"\\tthread %d : &loopcounter is %p\\n\", me, &i);\n    first = 0;\n  }\n\n  S += array[i];\n}\n\n", "pragma": "omp for reduction(+:S)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/01b_array_sum/0"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  C += (A[i] * B[i]) * 1ll;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:C)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wildDoubt/parallel-programming/source/practice5/0"}
{"code": "for (i = 0; i < cube_size; i++)\n{\n  for (j = 0; j < cube_size; j++)\n  {\n    GraphNode **list = &graph[i][j];\n    graphListCleanup(list);\n  }\n\n}\n\n", "pragma": "omp for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/2"}
{"code": "for (int node = 0; node < nnodes; node++)\n{\n  multi_spline[node] = create_multi_UBspline_3d_d(x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_omp/0"}
{"code": "for (i = row3; i < (sizeOfTheMatrix + row3); i++)\n{\n  for (j = col3; j < sizeOfTheMatrix; j++)\n  {\n    resMatrix[i][j] = 0.0;\n    for (k = 0; k < sizeOfTheMatrix; k++)\n    {\n      resMatrix[i][j] += firstMatrix[(i - row3) + rowFirst][k + columnFirst] * secondMatrix[k + rowSecond][(j - col3) + columnSecond];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/praveenChauhan686/Strassen-Algorithm-Java-And-OpenMp/Assignment 2_21261912/Source Code/OpenMp C/strassens_algorithm/6"}
{"code": "for (i = 0; i < N; ++i)\n{\n  avg += i;\n  printf(\"Thread %d executing iteration %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for reduction(+:avg) schedule(auto)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/OpenMP loop scheduling/autoScheduling/0"}
{"code": "for (i = 1; i < n; i += 2)\n{\n  if (x > i)\n  {\n    tempr = data[x];\n    data[x] = data[i];\n    data[i] = tempr;\n    tempr = data[x + 1];\n    data[x + 1] = data[i + 1];\n    data[i + 1] = tempr;\n  }\n\n  m = n >> 1;\n  while ((m >= 2) && (x > m))\n  {\n    x -= m;\n    m >>= 1;\n  }\n\n  x += m;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/william96ming/Openmp-pthreads-implementation-on-FFT/FFT_DIF_omp/3"}
{"code": "for (uint i = 0; i < input_vec.size(); ++i)\n{\n  score[i] = ((score[i] + minscore) / maxscore) * inverse_k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/2"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][j][i][m] = temp[m];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/26"}
{"code": "for (int i = 2; i < (nx + 2); ++i)\n{\n  double x = ((i - 2) - ((nx - 1) / 2.)) * dx;\n  for (int j = 2; j < (ny + 2); ++j)\n  {\n    double y = ((j - 2) - ((ny - 1) / 2.)) * dy;\n    for (int k = 2; k < (nz + 2); ++k)\n    {\n      int s = columnMajorLinearIndex(i, j, k, nx + 4, ny + 4);\n      if (x > 0)\n        e[s] = PRECISION(0.00778147);\n      else\n        e[s] = PRECISION(0.124503);\n\n      p[s] = e[s] / 3;\n      u->ux[s] = 0;\n      u->uy[s] = 0;\n      u->un[s] = 0;\n      u->ut[s] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/rhic/jail/rhic-trunk/src/main/cpp/edu/osu/rhic/trunk/ic/InitialConditions/3"}
{"code": "for (m = 0; m < 5; m++)\n{\n  j = 1;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][j]) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n  j = 2;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][j - 1]) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n}\n\n", "pragma": "omp parallel for firstprivate(dssp ,m ,i ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/25"}
{"code": "for (int jj = HALO_PAD; jj < (yMax - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (HALO_PAD + depth); ++kk)\n  {\n    int bufIndex = (kk - HALO_PAD) + ((jj - HALO_PAD) * depth);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel/0"}
{"code": "for (int i = 0; i < nb_nodes; ++i)\n  task.target[i] = 0;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/3"}
{"code": "for (int i = 0; i < N; i++)\n  uold[i] = (double *) malloc(M * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/11"}
{"code": "for (int i = 0; i < CITIES; i++)\n{\n  if (arr[i] == val)\n  {\n    pos = i;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for default( none ) shared( arr,pos,val)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeffyjahfar/TSP_GeneticAlgorithm_openMP/EvalXOverMutate/2"}
{"code": "for (k = 0; k < NUM_DIM; k = k + 8)\n{\n  t0 = _mm256_load_ps(&x[(a * NUM_DIM) + k]);\n  t1 = _mm256_load_ps(&y[(b * NUM_DIM) + k]);\n  diff = _mm256_sub_ps(t0, t1);\n  pwr = _mm256_mul_ps(diff, diff);\n  sum = _mm256_add_ps(sum, pwr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexandra182/code-optimization-samples/L2/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/clang/test/OpenMP/masked_messages/1"}
{"code": "for (i = 0; i < nf; i++)\n{\n  for (j = fptr[i]; j < fptr[i + 1]; j++)\n    rval[rptr[find[j]]++] = fval[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/30"}
{"code": "for (i = 0; i < count; i++)\n{\n  moveBoids();\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjhenning6/ASCII_boids_OpenMP/boids/8"}
{"code": "for (int i = 0; i < max_threads; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    for (int m = 0; m < temp_clusters[i][j].size(); m++)\n    {\n      clusters[j].push_back(temp_clusters[i][j][m]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/k-means/k-means-2/1"}
{"code": "for (int i = 0; i < SIZE_OF_CNT; ++i)\n{\n  printf(\"%d %zd  %zd\\n\", i, begin_pos[i], group_lens[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/test/5"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((((mat1[rowcol] == (-28768)) || ((mat1[rowcol] * 0.02) <= 250.0)) || ((mat1[rowcol] * 0.02) > 365.0)) || (mat5[rowcol] >= 10000.0)) || (mat5[rowcol] <= 0.0))\n    matOut[rowcol] = -28768;\n  else\n  {\n    e0 = 0.5 * (((mat3[rowcol] * 0.002) + 0.49) + ((mat4[rowcol] * 0.002) + 0.49));\n    kin = k_in(mat2[rowcol], doy, mat7[rowcol] * 0.01);\n    kin24 = k_in24(latitude[rowcol], doy, mat2[rowcol]);\n    sebsevapfr = sebs_evapfr(z_pbl, t_s, p_s, u_s, hr_s, alt_ms, e_act, kin, mat6[rowcol] * 0.001, mat5[rowcol] * 0.0001, ndvi_min, ndvi_max, ndvimedian, e0, mat1[rowcol] * 0.02, mat2[rowcol]);\n    matOut0[rowcol] = sebsevapfr;\n    sebseta = sebs_eta(doy, mat5[rowcol] * 0.0001, ndvi_max, ndvi_min, ndvimedian, u_s, z_pbl, t_s, p_s, alt_ms, e_act, latitude[rowcol], kin24, mat6[rowcol] * 0.001, mat2[rowcol], mat1[rowcol] * 0.02, e0, sebsevapfr);\n    matOut[rowcol] = sebseta;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, sebseta, sebsevapfr, kin, kin24, e0) shared(N, e_act, doy, p_s, t_s, z_pbl, u_s, ndvimedian, ndvi_min, ndvi_max, alt_ms, hr_s, mat1, mat2, mat3, mat4, mat5, mat6, mat7, matOut0, matOut, latitude )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBS/gdal_sebs_eta/4"}
{"code": "for (int i = 1; i < (nx + 1); i++)\n{\n  MPI_Irecv(&b[i][0], 1, MPI_FLOAT, neighbourRankId[BND_BOTTOM], MPI_TAG_OUT_B_TOP, MPI_COMM_WORLD, &recvReqs[BND_BOTTOM]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_DimensionalSplittingMpi/3"}
{"code": "for (uint64_t i = 0; i < size; i++)\n{\n  m += buffer[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/5"}
{"code": "for (i = 0; i < n; i++)\n  count[(arr[i] / exp) % 10]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/4"}
{"code": "for (x = 0; x < 512; x++)\n{\n  for (y = 0; y < 512; y++)\n  {\n    img.data[c] = matriz2[y][x];\n    c++;\n  }\n\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francisneibl/processamento_paralelo_imagens/fitroMedia/2"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    matrizC[i][j] = matrizA[i][j] * matrizB[j][i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucasAlison/threads_parallel/omp_matriz/0"}
{"code": "for (j = 0; j < np; j++)\n{\n  for (i = 0; i < nd; i++)\n  {\n    pos[i + (j * nd)] = (pos[i + (j * nd)] + (vel[i + (j * nd)] * dt)) + (((0.5 * acc[i + (j * nd)]) * dt) * dt);\n    vel[i + (j * nd)] = vel[i + (j * nd)] + ((0.5 * dt) * ((f[i + (j * nd)] * rmass) + acc[i + (j * nd)]));\n    acc[i + (j * nd)] = f[i + (j * nd)] * rmass;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/md_open_mp/1"}
{"code": "for (i = start; i < end; i++)\n{\n  data[i] = data[i] + key;\n  checksum += data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP2/inf8601-lab2-2.1.3/encode/algo/5"}
{"code": "for (i = 0; i < (V * V); i++)\n{\n  output_matrix[i / V][i % V] = h_graph[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/24"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  out_degree = vertices->out_degree[v];\n  if (stats->distances[v] == UINT32_MAX)\n  {\n    edge_idx = vertices->edges_idx[v];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      u = EXTRACT_VALUE(sorted_edges_array[j]);\n      AccessDoubleTaggedCacheUInt32(stats->cache, (uint64_t) (&bitmapCurr->bitarray[word_offset(u)]), 'r', u, EXTRACT_MASK(sorted_edges_array[j]));\n      if (getBit(bitmapCurr, u))\n      {\n        stats->distances[v] = stats->distances[u] + 1;\n        if (stats->distances[v] == (stats->distances[u] + 1))\n        {\n          stats->sigma[v] += stats->sigma[u];\n          stats->predecessors[v].nodes[stats->predecessors[v].degree] = u;\n          stats->predecessors[v].degree++;\n        }\n\n        setBitAtomic(bitmapNext, v);\n        nf++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(j,u,v,out_degree,edge_idx) shared(stats,bitmapCurr,bitmapNext,graph,vertices,sorted_edges_array) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/algorithms/openmp/betweennessCentrality/0"}
{"code": "for (iterator i = distance_value_count.begin(); i != distance_value_count.end(); ++i)\n  (cout << (*i)) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/16"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (int *) malloc((i + 1) * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amir-saadat/Scientific-computing/lab7/matvec_part6/1"}
{"code": "for (ri = 0; ri < s->nrat; ri++)\n{\n  s->rat_position[ri] = fast_next_random_move(s, ri);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WeijiaGao49/Shared-Memory-Parallelism-with-OpenMP/code/sim/11"}
{"code": "for (int i = 0; i < i_t.size(); ++i)\n{\n  for (int j = 0; j < g_t[0].size(); ++j)\n  {\n    temp_iOg[i][j] = i_t[i][j] * g_t[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_3/9"}
{"code": "for (i = 0; i < n; i++)\n  omp_destroy_lock(locks + i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/stacks/main/3"}
{"code": "for (k = 1; k <= (n - 1); k++)\n{\n  l = ipvt[k - 1];\n  t = b[l - 1];\n  if (l != k)\n  {\n    b[l - 1] = b[k - 1];\n    b[k - 1] = t;\n  }\n\n  saxpy(n - k, t, (a + k) + ((k - 1) * lda), 1, b + k, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/22"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    fscanf(myFile, \"%d\", &A[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/12"}
{"code": "for (i = 1; i <= 99; i += 1)\n{\n  for (j = 1; j <= 99; j += 1)\n  {\n    a[i][j] = a[i][j - 1] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_true_l2/0"}
{"code": "for (int i = 0; i < 10000; i++)\n  if (ants[ant].unvisited[i])\n  norm += pow(T[currentCity][i], 3) * pow(1.0 / Distances[currentCity][i], 5);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/TSP/ants_parallel/9"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  tmp[j] += j;\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom : tmp)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MJChku/openmp_source/libomptarget/test/offloading/parallel_offloading_map/1"}
{"code": "for (node_t i = 0; i < G->numNodes; i++)\n{\n  node_t comid = comm[i];\n  commpos[i] = cd[comid].numNodes;\n  cd[comid].numNodes++;\n  for (edge_t e = G->begin[i]; e < G->begin[i + 1]; e++)\n  {\n    node_t end = G->node_idx[e];\n    if (comm[end] == comid)\n      cd[comid].numEdges++;\n    else\n      cd[comid].external++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/11"}
{"code": "for (i = 0; i < E; ++i)\n{\n  int qqq = scanf(\"%d %d %d\", &x, &y, &w);\n  if ((*((matrix + ((x - 1) * V)) + (y - 1))) > w)\n    *((matrix + ((x - 1) * V)) + (y - 1)) = w;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayushsharma-crypto/Floyd-Warshal-Optimization/code/2"}
{"code": "for (int i = 0; i < nvertices; i++)\n{\n  wxcoords[i] = vertices[i]->getX();\n  wycoords[i] = vertices[i]->getY();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Guiming/ParallelRipleysKfunction/spp_mpi/SpatialPointPattern/9"}
{"code": "for (bfs_root_idx = 0; bfs_root_idx < num_bfs_roots; ++bfs_root_idx)\n{\n  int64_t root = bfs_roots[bfs_root_idx];\n  if (rank == 0)\n    fprintf(stderr, \"Running BFS %d\\n\", bfs_root_idx);\n\n  memset(pred, 0, nlocalverts * (sizeof(int64_t)));\n  double bfs_start = MPI_Wtime();\n  run_bfs(root, &pred[0]);\n  double bfs_stop = MPI_Wtime();\n  bfs_times[bfs_root_idx] = bfs_stop - bfs_start;\n  if (rank == 0)\n    fprintf(stderr, \"Time for BFS %d is %f\\n\", bfs_root_idx, bfs_times[bfs_root_idx]);\n\n  if (!getenv(\"SKIP_VALIDATION\"))\n  {\n    if (rank == 0)\n      fprintf(stderr, \"Validating BFS %d\\n\", bfs_root_idx);\n\n    double validate_start = MPI_Wtime();\n    int64_t edge_visit_count;\n    int validation_passed_one = validate_bfs_result(&tg, max_used_vertex + 1, nlocalverts, root, pred, &edge_visit_count);\n    double validate_stop = MPI_Wtime();\n    validate_times[bfs_root_idx] = validate_stop - validate_start;\n    if (rank == 0)\n      fprintf(stderr, \"Validate time for BFS %d is %f\\n\", bfs_root_idx, validate_times[bfs_root_idx]);\n\n    edge_counts[bfs_root_idx] = (double) edge_visit_count;\n    if (rank == 0)\n      fprintf(stderr, \"TEPS for BFS %d is %g\\n\", bfs_root_idx, edge_visit_count / bfs_times[bfs_root_idx]);\n\n    if (!validation_passed_one)\n    {\n      validation_passed = 0;\n      if (rank == 0)\n        fprintf(stderr, \"Validation failed for this BFS root; skipping rest.\\n\");\n\n      break;\n    }\n\n  }\n  else\n  {\n    validate_times[bfs_root_idx] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/topanitanw/graph500_openmp/mpi/main/0"}
{"code": "for (j = 0; j < 80000000; j++)\n  c[j] = a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KonstantinosKr/delta/meta/benchmark/ham7/stream/stream/2"}
{"code": "for (size_t i = 0; i < 1024; ++i)\n  x_d[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/targc-spmd/targc-spmd/1"}
{"code": "for (j = yStart; j < yEnd; j++)\n  for (i = 0; i < XPICR; i++)\n{\n  const float a = (-2.05f) + ((3.00f * ((float) i)) * IXRES);\n  const float b = 1.10f - ((2.24f * ((float) j)) * IYRES);\n  *(buffer++) = IterateMandelbrot(a, b);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sloox/OPENMPIMANDEL/mandle/2"}
{"code": "for (int j = 0; j < 2; j++)\n{\n  diff[i][j] = a[i][j] - b[i][j];\n}\n\n", "pragma": "omp parallel for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Matrix_addition_and_subtraction/3"}
{"code": "for (j = 2 * B; j < (width - (2 * B)); j++)\n{\n  for (i = (height - 1) - B; i > ((height - 1) - (2 * B)); i--)\n  {\n    for (c = 0; c < CHANNELS; c++)\n    {\n      float value = 0.0f;\n      for (p = -B; p <= B; p++)\n        for (q = -B; q <= B; q++)\n        value += input_image[i - p][j - q][c] * filter[p + B][q + B];\n\n\n      output_image[i][j][c] = value;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yannikab/parsys/spmd/common/filter/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float zzz = ran0(z);\n  dum[i] = (int) (((v1 + ((v2 - v1) * zzz)) * ((float) c)) + zzz);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sg0/bin-packing/direct/bin_packing_omp_par/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][2];\n      u31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = rsd[i][j][k][1] * u31;\n      flux[i][j][k][2] = (rsd[i][j][k][2] * u31) + (C2 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][3] = rsd[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/8"}
{"code": "for (uint i = 0; i < vecIn.size(); i++)\n{\n  vecOut[i] = worker(vecIn[i], str);\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/admiswalker/blog_2019_0421_OpenMP/ex1/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result += grid[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j) reduction(+ : result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DAToneli/highlife/pcd_omp_game_of_life/0"}
{"code": "for (int i = 0; i < size; i++)\n  arr[i] = malloc(size * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AYaddaden/matrix-multiplication/main/3"}
{"code": "for (int n_threads = 1; n_threads <= 32; n_threads = (n_threads <= 8) ? (2 * n_threads) : (n_threads + 4))\n{\n  omp_set_num_threads(n_threads);\n  for (int i = 0; i < n_runs; ++i)\n  {\n    start_time = omp_get_wtime();\n    total_sum = omp_sum(x, size);\n    times[i] = omp_get_wtime() - start_time;\n    if (abs(total_sum - warmup_sum) > 0.001)\n      printf(\"Different results in omp_sum with %2d threads: %f\\n\", n_threads, total_sum);\n\n  }\n\n  double avg;\n  double std_dev;\n  compute_statistics(times, n_runs, &avg, &std_dev);\n  printf(\"omp sum (%2d threads) - Average: %fs - Std. deviation: %fs - Sum value: %f\\n\", n_threads, avg, std_dev, total_sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  array[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Binary_Search/1"}
{"code": "for (int i = 0; i < subLength; ++i)\n  subString[i] = 'a' + (rand() % 26);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task5/0"}
{"code": "for (int i = 0; i < len; i++)\n{\n  if (a1[i] != a2[i])\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArthurLCW/Heat-Simulation/codes/csc4005-assignment-4-bonus/csc4005-imgui/src/main/1"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = temp[i];\n\n", "pragma": "omp parallel for shared(a, n, temp) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brenda151295/OpenMP/ejercicio3/1"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/21"}
{"code": "for (int i = 0; i < h; i++)\n{\n  unsigned int PRNG_state = time(0);\n  for (unsigned short j = 0; j < w; j++)\n  {\n    double pixel_radiance[3] = {0, 0, 0};\n    for (int sub_i = 0; sub_i < 2; sub_i++)\n    {\n      for (int sub_j = 0; sub_j < 2; sub_j++)\n      {\n        double subpixel_radiance[3] = {0, 0, 0};\n        for (int s = 0; s < samples; s++)\n        {\n          double r1 = (2 * ((double) rand_r(&PRNG_state))) / 32767;\n          double dx = (r1 < 1) ? (sqrt(r1) - 1) : (1 - sqrt(2 - r1));\n          double r2 = (2 * ((double) rand_r(&PRNG_state))) / 32767;\n          double dy = (r2 < 1) ? (sqrt(r2) - 1) : (1 - sqrt(2 - r2));\n          double ray_direction[3];\n          copy(camera_direction, ray_direction);\n          axpy((((((sub_i + .5) + dy) / 2) + i) / h) - .5, cy, ray_direction);\n          axpy((((((sub_j + .5) + dx) / 2) + j) / w) - .5, cx, ray_direction);\n          normalize(ray_direction);\n          double ray_origin[3];\n          copy(camera_position, ray_origin);\n          axpy(140, ray_direction, ray_origin);\n          double sample_radiance[3];\n          radiance(ray_origin, ray_direction, 0, &PRNG_state, sample_radiance);\n          axpy(1. / samples, sample_radiance, subpixel_radiance);\n        }\n\n        clamp(subpixel_radiance);\n        axpy(0.25, subpixel_radiance, pixel_radiance);\n      }\n\n    }\n\n    copy(pixel_radiance, image + (3 * ((((h - 1) - i) * w) + j)));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_omp/pathtracer_omp/1"}
{"code": "for (i = 1; i < max2; i++)\n{\n  tc11:\n  (*(p + (2 * i)))[0] = 100;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/src/imop/lib/testcases/solverTests/test4/0"}
{"code": "for (i = 0; i < OBSERVES; i++)\n  free(emissionMat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/21"}
{"code": "for (uint64_t i = 0; i <= (size / 2); i += 2 * size_of_chunks)\n{\n  merge(T + i, size_of_chunks);\n}\n\n", "pragma": "omp parallel for default(none), shared(T, size, size_of_chunks)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/qsort/0"}
{"code": "for (int y = 1; y < (rows - 1); y++)\n{\n  grid[y][0] = grid[y][columns - 2];\n  grid[y][columns - 1] = grid[y][1];\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp/2"}
{"code": "for (size_t i = 0; i < taskListSize; ++i)\n{\n  task.shellIndex1 = session.unpackTaskList[i * 4];\n  task.shellIndex2 = session.unpackTaskList[(i * 4) + 1];\n  task.shellIndex3 = session.unpackTaskList[(i * 4) + 2];\n  task.shellIndex4 = session.unpackTaskList[(i * 4) + 3];\n  (*pTaskList)[i] = task;\n}\n\n", "pragma": "#pragma omp parallel for private(task)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfTaskCtrl_Parallel/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    printf(\"%f \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/16"}
{"code": "for (int i = 0; i < k; i++)\n  swap_d(_r1 + i, _r2 + i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/0"}
{"code": "for (int i = 0; i < (input->np - 3); i += 4)\n{\n  sup->W[i] += sup->delta_f[i] / min_delta_f;\n  sup->w_sum += sup->W[i];\n  sup->W[i + 1] += sup->delta_f[i + 1] / min_delta_f;\n  sup->w_sum += sup->W[i + 1];\n  sup->W[i + 2] += sup->delta_f[i + 2] / min_delta_f;\n  sup->w_sum += sup->W[i + 2];\n  sup->W[i + 3] += sup->delta_f[i + 3] / min_delta_f;\n  sup->w_sum += sup->W[i + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/9"}
{"code": "for (c2 = 0; c2 <= 499; c2++)\n{\n  X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-parallel-no/4"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((0.75 - 0.7) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * 1), stat[i].e2 / ((((double) (L * L)) * (L * L)) * 1), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * 1), stat[i].m / 1, stat[i].m2 / 1, stat[i].m4 / 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/47"}
{"code": "for (i = 0; i < (num_cols * num_vectors); i++)\n  y_data[i] *= beta;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/6"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  addedOut[i] = 0;\n  addedIn[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/5"}
{"code": "for (i = 0; i <= n; i++)\n{\n  dp[0][i] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/5"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i += incX + 4, j += incY + 4)\n{\n  YP[j] = XP[i];\n  YP[j + 1] = XP[i + 1];\n  YP[j + 2] = XP[i + 2];\n  YP[j + 3] = XP[i + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/8"}
{"code": "for (int i = 0; i < layer4->outputs; i++)\n{\n  layer4->biases[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/5"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n    printf(\"%d \", board[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/8"}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  omp_destroy_lock(&lock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/04_locks/2"}
{"code": "for (size_t i = 0; i < (nbx * nby); ++i)\n{\n  values_px[i] += values_ot[i];\n  variances_px[i] += variances_ot[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/41"}
{"code": "for (int edge = 0; edge < edge_count; edge++)\n{\n  (*val)[edge] = 1.0 / ((double) outbound_count[(*col_idx)[edge]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/9"}
{"code": "for (exp = 1; number > 0; exp *= 10)\n{\n  number = m / exp;\n  int output[n];\n  int i;\n  int count[10] = {0};\n  for (i = 0; i < n; i++)\n    count[(arr[i] / exp) % 10]++;\n\n  for (i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n\n  for (i = n - 1; i >= 0; i--)\n  {\n    output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n    count[(arr[i] / exp) % 10]--;\n  }\n\n  for (i = 0; i < n; i++)\n    arr[i] = output[i];\n\n}\n\n", "pragma": "omp for schedule(dynamic,100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaheryar3969/OSproject/ompradix/0"}
{"code": "for (i = 0; i < public.mask_conv_elem; i++)\n{\n  if (private.d_mask_conv[i] > fin_max_val)\n  {\n    fin_max_val = private.d_mask_conv[i];\n    fin_max_coo = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/18"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp = a[k][i];\n  a[k][i] = a[k_dash][i];\n  a[k_dash][i] = temp;\n  if (i < k)\n  {\n    temp = l[k][i];\n    l[k][i] = l[k_dash][i];\n    l[k_dash][i] = temp;\n  }\n  else\n  {\n    u[k][i] = a[k][i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp/1"}
{"code": "for (int i = 0; i < (this->nrow_ + 1); ++i)\n{\n  this->mat_.row_offset[i] = row_offsets[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/1"}
{"code": "for (i = 0; i < 32; i++)\n{\n  for (j = 0; j < 32; j++)\n  {\n    fread(&array[i][j], sizeof(double), 1, datafile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lar9482/High-Performance-Computing-Projects/Determinants/LU_Decomposition/4"}
{"code": "for (int i = 0; i < 22740; i++)\n{\n  int tmpnbLine = nbLine;\n  for (tmpnbLine = nbLine; tmpnbLine >= 0; tmpnbLine--)\n  {\n    if (same_hash(&shadow_tab[i], &hash_tab[tmpnbLine]))\n    {\n      result[i] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(hash_tab, shadow_tab, result)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arnicel/CUDA-OpenMP-CharCMP/attackOpenMP/0"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n  scanf(\"%d\", &second[m][n]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/husainhz7/Parallel-OpenMP-PrefixScan-MatrixMult/parallel_matrix/3"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  for (j = 0; j < 2000; j++)\n  {\n    histogram_private[im[i][j]]++;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment2/Asgn2/0"}
{"code": "for (i = 0; i < numbers_size; i++)\n{\n  numbers[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/1"}
{"code": "for (i = 0; i < n; i++)\n  pagerank[i] = 1 / ((double) n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/7"}
{"code": "for (i = 0; i < K_global; i++)\n{\n  if (points_inside_cluster_count[i] == 0)\n  {\n    printf(\"Unlikely situation!\\n\");\n    continue;\n  }\n\n  iterative_centroids_global[(((iter_counter + 1) * K_global) + i) * 3] = ((iterative_centroids_global[(((iter_counter + 1) * K_global) + i) * 3] * iterative_cluster_count_global[iter_counter][i]) + cluster_points_sum[i * 3]) / ((float) (iterative_cluster_count_global[iter_counter][i] + points_inside_cluster_count[i]));\n  iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 1] = ((iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 1] * iterative_cluster_count_global[iter_counter][i]) + cluster_points_sum[(i * 3) + 1]) / ((float) (iterative_cluster_count_global[iter_counter][i] + points_inside_cluster_count[i]));\n  iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 2] = ((iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 2] * iterative_cluster_count_global[iter_counter][i]) + cluster_points_sum[(i * 3) + 2]) / ((float) (iterative_cluster_count_global[iter_counter][i] + points_inside_cluster_count[i]));\n  iterative_cluster_count_global[iter_counter][i] += points_inside_cluster_count[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/4"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      v[i][j][k][m] = v[i][j][k][m] - (omega * ((((((((((ldy[i][j][m][0] * v[i][j - 1][k][0]) + (ldx[i][j][m][0] * v[i - 1][j][k][0])) + (ldy[i][j][m][1] * v[i][j - 1][k][1])) + (ldx[i][j][m][1] * v[i - 1][j][k][1])) + (ldy[i][j][m][2] * v[i][j - 1][k][2])) + (ldx[i][j][m][2] * v[i - 1][j][k][2])) + (ldy[i][j][m][3] * v[i][j - 1][k][3])) + (ldx[i][j][m][3] * v[i - 1][j][k][3])) + (ldy[i][j][m][4] * v[i][j - 1][k][4])) + (ldx[i][j][m][4] * v[i - 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    v[i][j][k][1] = v[i][j][k][1] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][3] * tmp);\n    v[i][j][k][4] = v[i][j][k][4] / tmat[4][4];\n    v[i][j][k][3] = v[i][j][k][3] - (tmat[3][4] * v[i][j][k][4]);\n    v[i][j][k][3] = v[i][j][k][3] / tmat[3][3];\n    v[i][j][k][2] = (v[i][j][k][2] - (tmat[2][3] * v[i][j][k][3])) - (tmat[2][4] * v[i][j][k][4]);\n    v[i][j][k][2] = v[i][j][k][2] / tmat[2][2];\n    v[i][j][k][1] = ((v[i][j][k][1] - (tmat[1][2] * v[i][j][k][2])) - (tmat[1][3] * v[i][j][k][3])) - (tmat[1][4] * v[i][j][k][4]);\n    v[i][j][k][1] = v[i][j][k][1] / tmat[1][1];\n    v[i][j][k][0] = (((v[i][j][k][0] - (tmat[0][1] * v[i][j][k][1])) - (tmat[0][2] * v[i][j][k][2])) - (tmat[0][3] * v[i][j][k][3])) - (tmat[0][4] * v[i][j][k][4]);\n    v[i][j][k][0] = v[i][j][k][0] / tmat[0][0];\n  }\n\n  if (i != ist)\n    flag[i - 1] = 0;\n\n  if (i != iend)\n    flag[i] = 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/104"}
{"code": "for (i = 1; i <= Maze->Radius; i++)\n{\n  Angle = (180.0 * acos(((2.0 * (i * i)) - 1.0) / (2.0 * (i * i)))) / 3.141592;\n  if ((Angle * 2.0f) < Maze->Delta)\n  {\n    Maze->CurrentRingSize *= 2;\n    Maze->Delta = Angle;\n  }\n\n  Maze->Angles[i - 1] = Maze->Delta;\n  Maze->Points[i - 1] = malloc(Maze->CurrentRingSize * (sizeof(int)));\n  Top = Maze->_Size + Maze->CurrentRingSize;\n  for (j = 0; j < Maze->CurrentRingSize; j++)\n    Maze->Points[i - 1][j] = Maze->_Size + j;\n\n  Maze->_Size = Top;\n  Maze->Sections[i - 1] = Maze->CurrentRingSize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/11"}
{"code": "for (int i = 0; i < assignments.size(); i++)\n{\n  intracluster_distance += pairwise_distance(data[i], centers[assignments[i]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par3/2"}
{"code": "for (int j = 0; j < 8; j++)\n{\n  printf(\"%d \", A[0][j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanwbrei/openmp_tutorial/src/lcd/1"}
{"code": "for (int i = 0; i < 28; i++)\n{\n  array[i] = 0.1f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/20"}
{"code": "for (j = f; j < m; j++)\n{\n  mj0 = m * j;\n  t = A + j;\n  c0 = C + mj0;\n  for (k = 0; k < w; k += 6)\n  {\n    km0 = k * m;\n    km1 = (k + 1) * m;\n    km2 = (k + 2) * m;\n    km3 = (k + 3) * m;\n    km4 = (k + 4) * m;\n    km5 = (k + 5) * m;\n    b00 = _mm_load1_ps(t + km0);\n    b01 = _mm_load1_ps(t + km1);\n    b02 = _mm_load1_ps(t + km2);\n    b03 = _mm_load1_ps(t + km3);\n    b04 = _mm_load1_ps(t + km4);\n    b05 = _mm_load1_ps(t + km5);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km1), b01));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km2), b02));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km3), b03));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km4), b04));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km5), b05));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n      *((C + i) + mj0) += (*((A + i) + km1)) * (*(t + km1));\n      *((C + i) + mj0) += (*((A + i) + km2)) * (*(t + km2));\n      *((C + i) + mj0) += (*((A + i) + km3)) * (*(t + km3));\n      *((C + i) + mj0) += (*((A + i) + km4)) * (*(t + km4));\n      *((C + i) + mj0) += (*((A + i) + km5)) * (*(t + km5));\n    }\n\n  }\n\n  for (k = w; k < n; k++)\n  {\n    km0 = k * m;\n    b00 = _mm_load1_ps(t + km0);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(t,s,c0,km0,km1,km2,km3,km4,km5,j,k,i,mj0,c00,b00,b01,b02,b03,b04,b05)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzpanda/CS61C-Proj3-Matrix-Decryption-/proj3-6-6-out/1"}
{"code": "for (i = 0; i < image_dim_x; i++)\n{\n  theta0_M1[i] = fabs((((delta_incidence_angle[0] * M_PI) / 180.) * (i - (image_dim_x / 2))) / ((tan((17.3 * M_PI) / 180.) * focal) / detector_size)) + ((i_angles_center_FOV[0] * M_PI) / 180.);\n  theta0_M2[i] = fabs((((delta_incidence_angle[1] * M_PI) / 180.) * (i - (image_dim_x / 2))) / ((tan((17.3 * M_PI) / 180.) * focal) / detector_size)) + ((i_angles_center_FOV[1] * M_PI) / 180.);\n  theta0_M3[i] = fabs((((delta_incidence_angle[2] * M_PI) / 180.) * (i - (image_dim_x / 2))) / ((tan((17.3 * M_PI) / 180.) * focal) / detector_size)) + ((i_angles_center_FOV[2] * M_PI) / 180.);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/3"}
{"code": "for (int tid = 0; tid < n; tid++)\n{\n  const T data = inp[tid];\n  bool temp = true;\n  for (int o = 1; o < (order + 1); o++)\n  {\n    int plus = tid + o;\n    int minus = tid - o;\n    clip_plus(clip, n, plus);\n    clip_minus(clip, n, minus);\n    temp &= data > inp[plus];\n    temp &= data >= inp[minus];\n  }\n\n  results[tid] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/extrema-omp/main/0"}
{"code": "for (j = 0; j <= (n + 1); j++)\n{\n  grid[0 + (j * (m + 2))] = 0;\n  grid[(m + 1) + (j * (m + 2))] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/plloaao/lifegame_and_openmp/lifegame_omp/7"}
{"code": "for (j = 1; j <= n; j++)\n{\n  t[0][j] = 30.0;\n  t[m + 1][j] = 40.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkerthegeek/ParallelProgramming-OpenMP/jacobi2d_parallel_version/2"}
{"code": "for (int row = 0; row < nel; row++)\n{\n  for (int col = 0; col < nel; col++)\n  {\n    if (row >= col)\n    {\n      continue;\n    }\n\n    int map_row;\n    int map_col;\n    int rank;\n    matrix_to_map_index(row, col, nel, &map_row, &map_col, np);\n    rank = get_map(map, np, map_row, map_col);\n    if (rank == myrank)\n    {\n      int index_part;\n      if (map_row == map_col)\n      {\n        index_part = 0;\n      }\n      else\n        if ((map_row == rank) && (map_col > rank))\n      {\n        index_part = map_col - rank;\n      }\n      else\n        if ((map_col == rank) && (map_row < rank))\n      {\n        index_part = (np - map_col) + map_row;\n      }\n      else\n      {\n        index_part = -1;\n        ((cerr << \"Errore slave_print_global_matrix: \") << \"indici mappa errati\") << endl;\n      }\n\n\n\n      int local_row;\n      int local_col;\n      sim_metric val;\n      if (r == 0)\n      {\n        local_col = col - (q * map_col);\n        local_row = row - (q * map_row);\n        if (index_part == 0)\n        {\n          val = get((*matrix_parts)[index_part], q, local_row, local_col);\n        }\n        else\n        {\n          val = (*matrix_parts)[index_part][(local_row * q) + local_col];\n        }\n\n      }\n      else\n      {\n        local_col = col - (((q + 1) * map_col) - MIN(map_col, np - r));\n        local_row = row - (((q + 1) * map_row) - MIN(map_row, np - r));\n        if (index_part == 0)\n        {\n          val = get((*matrix_parts)[index_part], (map_col < (np - r)) ? (q) : (q + 1), local_row, local_col);\n        }\n        else\n        {\n          val = (*matrix_parts)[index_part][(local_row * ((map_col < (np - r)) ? (q) : (q + 1))) + local_col];\n        }\n\n      }\n\n      MPI_Send(&val, sizeof(sim_metric), MPI_BYTE, 0, TAG_PRINT, MPI_COMM_WORLD);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/22"}
{"code": "for (i = 0; i < 3; i++)\n{\n  xstart[i] = 1;\n  xend[i] = 128;\n  ystart[i] = 1;\n  yend[i] = 128;\n  zstart[i] = 1;\n  zend[i] = 32;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/33"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  atot += cell(ci).area();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/21"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n    for (int k = 0; k < nzn; k++)\n  {\n    pYZsn[is][i][j][k] += invVOL * moments[i][j][k][8];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/10"}
{"code": "for (i = 0; i <= ((len / 2) - 1); i += 1)\n{\n  a[(2 * i) + 1] = a[i] + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB034-truedeplinear-var-yes/0"}
{"code": "for (int i = 0, ii = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n  {\n    fprintf(fp, \"%d \", ii);\n    ii++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/142"}
{"code": "for (; i < ie; i++)\n{\n  Add(hi[i], lo[i], vec1.hi[i], vec1.lo[i], -vec2.hi[i], -vec2.lo[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_sub_dd/0"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    a[i][j] = i;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB073-doall2-orig-yes/0"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (data->phase_discovered > max_distance)\n    max_distance = data->phase_discovered;\n\n  1(\"node_%d: parent = %d, dist = %d\\n\", cur->label, data->parent_label, data->phase_discovered);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/bfs_dijkstra/2"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    uijk = us[i][j][k];\n    up1 = us[i + 1][j][k];\n    um1 = us[i - 1][j][k];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dx1tx1 * ((u[i + 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i - 1][j][k][0]))) - (tx2 * (u[i + 1][j][k][1] - u[i - 1][j][k][1]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dx2tx1 * ((u[i + 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i - 1][j][k][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[i + 1][j][k][1] * up1) - (u[i - 1][j][k][1] * um1)) + ((((u[i + 1][j][k][4] - square[i + 1][j][k]) - u[i - 1][j][k][4]) + square[i - 1][j][k]) * c2)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dx3tx1 * ((u[i + 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i - 1][j][k][2]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][2] * up1) - (u[i - 1][j][k][2] * um1)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dx4tx1 * ((u[i + 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i - 1][j][k][3]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][3] * up1) - (u[i - 1][j][k][3] * um1)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dx5tx1 * ((u[i + 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i - 1][j][k][4]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[i + 1][j][k][4] * rho_i[i + 1][j][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i - 1][j][k][4] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[i + 1][j][k][4]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[i - 1][j][k][4]) - (c2 * square[i - 1][j][k])) * um1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(uijk, up1, um1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/32"}
{"code": "for (i = 0; i < nothreads; i++)\n{\n  a[i] = (rand() % 100) + 1;\n}\n\n", "pragma": "omp parallel for private(i) shared(nothreads) num_threads(nothreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/githubhj/Syncronization_Primitives/Barriers/OpenMP_Barriers/MCS/main/0"}
{"code": "for (i = 0; i < 180; i++)\n  for (j = 0; j < (180 - 1); j++)\n  x[i][j] = (((double) j) * h) * x[i][180 - 1];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_jacobi/safe_sor_jacobi_par/1"}
{"code": "for (int j = 0; j < Time_cell; ++j)\n{\n  for (int i = 0; i < Freq_cell; ++i)\n  {\n    if ((hsa_map[j][i] > 1000000000000.0) || (hsa_map[j][i] < (-1000000000000.0)))\n      continue;\n\n    fprintf(map_fp, \"%f %f %f\\n\", j * HSA_dt, i * HSA_df, hsa_map[j][i]);\n    HSA_map[(i * Time_cell) + j] = hsa_map[j][i] + 0.00000001;\n    if (hsa_map[j][i] > HSA_max)\n      HSA_max = hsa_map[j][i];\n\n    if (hsa_map[j][i] < HSA_min)\n      HSA_min = hsa_map[j][i];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/48"}
{"code": "for (int i = 0; i < graph->size; i++)\n{\n  graph->nodes[i] = (Node *) malloc(sizeof(Node));\n  graph->nodes[i]->neighbours = (Node **) malloc(size * (sizeof(Node)));\n  graph->nodes[i]->degree = 0;\n  graph->nodes[i]->idx = i;\n  graph->nodes[i]->inQ = 0;\n  graph->nodes[i]->inR = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/9"}
{"code": "for (int i = 0; i < 16; i++)\n  for (int j = 0; j < baz(&i); j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/64"}
{"code": "for (int i = 0; i < (max_rows * max_cols); i++)\n{\n  if (traceback_par[i] != traceback_seq[i])\n  {\n    fail = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/8"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    unew[i][j] = ((((uold[i - 1][j] + uold[i + 1][j]) + uold[i][j - 1]) + uold[i][j + 1]) + ((1.0 * h) * h)) / 4.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jzuhusky/HPC_Homework2/jacobi2D-omp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  F[i] = exp((-X[i]) * X[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stu314159/lax_openmp/lax_wave/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 50; j++)\n  {\n    genes[i][j] = RandomInteger2(0, 50 - 1, &seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/5. N-queens problem/gen06/2"}
{"code": "for (size_t i = 0; i < xforces.size(); ++i)\n{\n  double ax = xforces[i] / mass_[i];\n  double ay = yforces[i] / mass_[i];\n  xvel_[i] += ax * dt;\n  yvel_[i] += ay * dt;\n  xpos_[i] += xvel_[i] * dt;\n  ypos_[i] += yvel_[i] * dt;\n  if (xpos_[i] <= 0)\n  {\n    xpos_[i] = 2;\n    xvel_[i] = -xvel_[i];\n  }\n\n  if (xpos_[i] >= w)\n  {\n    xpos_[i] = w - 2;\n    xvel_[i] = -xvel_[i];\n  }\n\n  if (ypos_[i] <= 0)\n  {\n    ypos_[i] = 2;\n    yvel_[i] = -yvel_[i];\n  }\n\n  if (ypos_[i] >= h)\n  {\n    ypos_[i] = h - 2;\n    yvel_[i] = -yvel_[i];\n  }\n\n  assert((0 <= xpos_[i]) && (xpos_[i] <= w));\n  assert((0 <= ypos_[i]) && (ypos_[i] <= h));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jprieto92/parallel-programming-openmp-nbodies/nbody/src/bodiessoa/3"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/105"}
{"code": "for (i = 0; i < (x * y); i++)\n  pointers_to_data[i] = data + (i * z);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/24"}
{"code": "for (int i = 0; i < (nObs - 1); i++)\n  path[i] = (int *) malloc((sizeof(int)) * nState);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hmm-omp/ViterbiCPU/0"}
{"code": "for (int pos = lid; pos < (N / 2); pos += gsz)\n{\n  int i0 = pos << 1;\n  int i1 = i0 + 1;\n  float D0 = s_data[i0];\n  float D1 = s_data[i1];\n  s_data[i0] = D0 + D1;\n  s_data[i1] = D0 - D1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fwt-omp/kernels/2"}
{"code": "for (p_index_ = p_lower_; p_index_ <= p_upper_; p_index_ += 1)\n{\n  _p_is = _p_is + p_index_;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/roseTests/ompLoweringTests/ROSEXOMPReference/rose_lastprivate0/0"}
{"code": "for (i = 0; i < r1; ++i)\n  for (j = 0; j < c1; ++j)\n{\n  printf(\"Enter elements a%d%d -> \", i + 1, j + 1);\n  scanf(\"%d\", &a[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/irajeshegde/OMP-Programs/LA/p6/1"}
{"code": "for (int i = 0; i < p[0]; i++)\n{\n  for (int j = 0; j < p[n - 1]; j++)\n    fprintf(out, \"%f \", a[(i * p[n - 1]) + j]);\n\n  fprintf(out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/4"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/1/shared-clause/1"}
{"code": "for (i = 0; i < m->rows; i++)\n{\n  for (j = 0; j < m->cols; j++)\n  {\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC462-Sistemas_Concurrentes_y_Distribuidos/Labo_1/example/matrix/2"}
{"code": "for (i = 0; i < (NGROUPS / 10); i++)\n{\n  for (j = 0; j < 10; j++)\n    fprintf(f2, \"%9.2f\", compact[(10 * i) + j]);\n\n  fprintf(f2, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/10"}
{"code": "for (size_t p = 0; p < npts_to_proc; p++)\n{\n  for (size_t q = 0; q < nmo; q++)\n  {\n    size_t p_offset = p + offset;\n    mat_cgto[(p_offset * nmo) + q] = 0;\n    for (size_t k = 0; k < nao; k++)\n    {\n      mat_cgto[(p_offset * nmo) + q] += cgto_ao_node[(p * nao) + k] * coeff[(k * nmo) + q];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/loader/loader_qmp2_from_file_mpi/3"}
{"code": "for (j = 0; j < (numOfPoints - 1); j++)\n{\n  for (q = j + 1; q < numOfPoints; q++)\n  {\n    if (allPoints[j].clusterId == allPoints[q].clusterId)\n    {\n      double distance = sqrt((pow(allPoints[q].x - allPoints[j].x, 2) + pow(allPoints[q].y - allPoints[j].y, 2)) + pow(allPoints[q].z - allPoints[j].z, 2));\n      if (allClusters[allPoints[j].clusterId].diameter < distance)\n      {\n        allClusters[allPoints[j].clusterId].diameter = distance;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/5"}
{"code": "for (n = 0; n <= 4; n += 1)\n{\n  lhs[i][j][k][0][m][n] = 0.0;\n  lhs[i][j][k][1][m][n] = 0.0;\n  lhs[i][j][k][2][m][n] = 0.0;\n}\n\n", "pragma": "omp parallel for private (n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/47"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  czekaj(1);\n  for (int j = 0; j < SIZE; j++)\n  {\n    for (int k = 0; k < SIZE; k++)\n    {\n      S3[i][j] += ABC_3[i][k] * D[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WikGru/ParallelOpenMP/zad1+/zad1+/11"}
{"code": "for (int i = 0; i < vectorsize; i++)\n  A[i] = 99.99999999999999999;\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DoodleSchrank/OpenMP-GPU/openmp-example/1"}
{"code": "for (k = row_min; k <= row_max; ++k)\n{\n  int tile_row_start = 1 + ((k - 1) * tile_row_size);\n  int tile_row_end = min(tile_row_start + tile_row_size, m + 1);\n  int tile_col_start = 1 + ((diagonal_index - k) * tile_col_size);\n  int tile_col_end = min(tile_col_start + tile_col_size, n + 1);\n  for (int ii = tile_row_start; ii < tile_row_end; ++ii)\n  {\n    for (int jj = tile_col_start; jj < tile_col_end; ++jj)\n    {\n      if (x[ii - 1] == y[jj - 1])\n      {\n        dp[ii][jj] = dp[ii - 1][jj - 1];\n      }\n      else\n      {\n        dp[ii][jj] = min3(dp[ii - 1][jj - 1] + pxy, dp[ii - 1][jj] + pgap, dp[ii][jj - 1] + pgap);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing11/p1/6"}
{"code": "for (i = 0; i < negLength; i++)\n{\n  if (strcmp(key, negative[i]) == 0)\n    count++;\n\n}\n\n", "pragma": "omp parallel for private(i) schedule(dynamic,2500) reduction(+:count) num_threads(4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/2"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  if ((abs(this->vec_[i]) == infinity()) || (this->vec_[i] != this->vec_[i]))\n  {\n    LOG_VERBOSE_INFO(2, \"*** error: Vector:Check - problems with vector data\");\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/0"}
{"code": "for (p = buf; p < (&buf[8]); p++)\n  for (q = &buf2[0]; q <= (buf2 + 7); q++)\n  sum += ((*p) - '0') + ((*q) - '0');\n\n\n", "pragma": "omp parallel for collapse (2) reduction (+:sum) lastprivate (p, q)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-9/0"}
{"code": "for (i = 0; i < (N - 1); i++)\n{\n  first = i % 2;\n  for (j = first; j < (N - 1); j += 1)\n  {\n    if (A[j] > A[j + 1])\n    {\n      swap(&A[j], &A[j + 1]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dudaeitelven/OpenMp/main/2"}
{"code": "for (int i = 0; i < c_size; i++)\n{\n  sum += X[i] * Y[(c_size - i) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/sobel-filter/src/sobel/3"}
{"code": "for (k = 1; k < 10; k++)\n  if (init_puc_posar(i, j, k, taula))\n{\n  possible_vaules[local_num_possible_vaules] = k;\n  local_num_possible_vaules++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/8"}
{"code": "for (; (last_i + 0) < n; last_i += 1)\n{\n  y[last_i] = x[last_i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/18"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, 9, (MPI_Datatype) 0x4c000406, T, 9, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/30"}
{"code": "for (int y = featureHeight; y < (imageHeight - featureHeight); y++)\n{\n  for (int x = featureWidth; x < (imageWidth - featureWidth); x++)\n  {\n    float minimumSquaredDifference = -1;\n    int minimumDy = 0;\n    int minimumDx = 0;\n    for (int dy = ((-maximumDisplacement) > (featureHeight - y)) ? (-maximumDisplacement) : (featureHeight - y); dy <= ((maximumDisplacement < (((imageHeight - featureHeight) - y) - 1)) ? (maximumDisplacement) : (((imageHeight - featureHeight) - y) - 1)); dy++)\n    {\n      for (int dx = ((-maximumDisplacement) > (featureWidth - x)) ? (-maximumDisplacement) : (featureWidth - x); dx <= ((maximumDisplacement < (((imageWidth - featureWidth) - x) - 1)) ? (maximumDisplacement) : (((imageWidth - featureWidth) - x) - 1)); dx++)\n      {\n        float sqrdDifference = 0;\n        int sqrdDifferenceSum = _mm_setzero_ps();\n        int edges = ((featureWidth % 2) == 0) ? (featureWidth) : (featureWidth - 2);\n        int leftY = 0;\n        int rightY = 0;\n        int leftX = 0;\n        int rightX = 0;\n        for (int boxY = -featureHeight; boxY <= featureHeight; boxY++)\n        {\n          for (int boxX = -featureWidth; boxX < edges; boxX += 4)\n          {\n            leftY = y + boxY;\n            rightY = (y + dy) + boxY;\n            leftX = x + boxX;\n            rightX = (x + dx) + boxX;\n            sqrdDifferenceSum = calc_diff(sqrdDifferenceSum, leftX, leftY, rightX, rightY, imageWidth, left, right);\n          }\n\n          leftX = x + edges;\n          rightX = (x + dx) + edges;\n          leftY = y + boxY;\n          rightY = (y + dy) + boxY;\n          float diff = 0.0;\n          int left_bound = 0;\n          int right_bound = 0;\n          if ((featureWidth % 2) == 0)\n          {\n            diff = left[(leftY * imageWidth) + leftX] - right[(rightY * imageWidth) + rightX];\n            sqrdDifference += diff * diff;\n          }\n          else\n          {\n            left_bound = (leftY * imageWidth) + leftX;\n            right_bound = (rightY * imageWidth) + rightX;\n            diff = left[left_bound] - right[right_bound];\n            sqrdDifference += diff * diff;\n            diff = left[left_bound + 1] - right[right_bound + 1];\n            sqrdDifference += diff * diff;\n            diff = left[left_bound + 2] - right[right_bound + 2];\n            sqrdDifference += diff * diff;\n          }\n\n        }\n\n        float values[4] = {0, 0, 0, 0};\n        _mm_storeu_ps(values, sqrdDifferenceSum);\n        sqrdDifference += ((values[0] + values[1]) + values[2]) + values[3];\n        if ((((minimumSquaredDifference == sqrdDifference) && (displacementNaive(dx, dy) < displacementNaive(minimumDx, minimumDy))) || (minimumSquaredDifference == (-1))) || (minimumSquaredDifference > sqrdDifference))\n        {\n          minimumSquaredDifference = sqrdDifference;\n          minimumDx = dx;\n          minimumDy = dy;\n        }\n\n      }\n\n    }\n\n    if ((minimumSquaredDifference != (-1)) && (maximumDisplacement != 0))\n    {\n      depth[(y * imageWidth) + x] = displacementNaive(minimumDx, minimumDy);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eeshanagarwal/DepthMap/calcDepthOptimized_openMP/0"}
{"code": "for (int i = 0; i < len; i++)\n{\n  input[i] = rand() % len;\n  idx[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/4"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA256][32];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 32);\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n  {\n    JTR_hmac_sha256(master[i], 32, cur_salt->blob, cur_salt->bloblen, (unsigned char *) crypt_out[index + i], 16);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ansible_fmt_plug/2"}
{"code": "for (int tt = 0; tt < params.maxIters; tt += 2)\n{\n  d2q9_bgk(params, tot_cells, cells, obstacles, av_vels, tt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/openmp/d2q9-bgk/5"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  u[i][0] = 0;\n  u[i][39] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/5"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  int a = applymask((long long) data[i].key, digit);\n  data2[bstart[a]] = data[i];\n  bstart[a]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/radixsort/2"}
{"code": "for (int row = (row_start < 0) ? (0) : (row_start); row < ((row_end > rows) ? (rows) : (row_end)); row++)\n{\n  for (int column = (column_start < 0) ? (0) : (column_start); column < ((column_end > columns) ? (columns) : (column_end)); column++)\n  {\n    int row_d = z - abs(hit_row - row);\n    int column_d = z - abs(hit_column - column);\n    if (row_d < column_d)\n    {\n      matrix[row][column] += row_d;\n    }\n    else\n    {\n      matrix[row][column] += column_d;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dargmuesli/parallel-processing/part-1_openmp/a_numbers/2"}
{"code": "for (int i = 0; i < nNodes; i++)\n  addNode(i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joshuaar/MinCut/MinCut/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  s[i] = left + i;\n  tid = omp_get_thread_num();\n  printf(\"Thread number %d allocated s[%d]=%d\\n\", tid, i, s[i]);\n}\n\n", "pragma": "omp parallel for num_threads(n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/search/1"}
{"code": "for (int i = 2; i < n; i += 2)\n{\n  if (arr[i - 1] > arr[i])\n  {\n    swap(&arr[i - 1], &arr[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lewisc4/Parallel-Sorting-Algorithms/Odd Even Sort/oddEvenParallel/0"}
{"code": "for (int i = 0; i < V; i++)\n{\n  for (int j = 0; j < V; j++)\n  {\n    if (dist[i][j] != INF)\n      (((((cout << i) << \" -> \") << j) << \" : \") << dist[i][j]) << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  speed_sqr = (curr[i].v[0] * curr[i].v[0]) + (curr[i].v[1] * curr[i].v[1]);\n  ke += curr[i].m * speed_sqr;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/7"}
{"code": "for (i = 0; i < nb_patterns; i++)\n{\n  printf(\"Number of matches for pattern <%s>: %d\\n\", pattern[i], global_matches[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nordine-marie/hpc-dna-approximate-pattern-matching/apm/apm_omp_mpi/src/apm/3"}
{"code": "for (int i = 0; i < b; i++)\n  Num[i]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/4"}
{"code": "for (i = 0; i < N; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/LoopWorkSharing/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  V2[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KotaIkehara/parallel-matvec/main/2"}
{"code": "for (i = ((-0x7fffffff) - 1) + 6; i > ((-0x7fffffff) - 1); i--)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/2"}
{"code": "for (i = j + 1; i < n; i++)\n{\n  if (a[i] != i)\n    __builtin_abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.hsa.c/gridify-2/1"}
{"code": "for (int i = 2; i <= n; i++)\n{\n  for (int j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      not_primes++;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+: not_primes) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jing2018/OpenMP-programming-in-C/prime_omp_v2/0"}
{"code": "for (int i = 0; i < MAXN; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_reduction/0"}
{"code": "for (i = 0; i < rowsA; ++i)\n{\n  for (j = 0; j < colsB; ++j)\n  {\n    for (k = 0; k < colsA; ++k)\n    {\n      matC[i][j] += matA[i][k] * matB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/2L2CU/ParallelComputing/main/2"}
{"code": "for (int j = 0; j < len_node_ready; ++j)\n{\n  if (file_nodes[index_ready[j]]->is_executed == 1)\n  {\n    if (file_nodes[index_ready[j]]->number_parents != 0)\n    {\n      for (int i = 0; i < file_nodes[index_ready[j]]->number_parents; i++)\n      {\n        if (file_nodes[index_ready[j]]->parents[i] != 0)\n        {\n          file_nodes[index_ready[j]]->parents[i]->isReady++;\n          if (file_nodes[index_ready[j]]->parents[i]->isReady == file_nodes[index_ready[j]]->parents[i]->number_dependencies)\n          {\n            index_ready[len_node_ready + count] = file_nodes[index_ready[j]]->parents[i]->id;\n            count++;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elouatih/distributed_make_mpi_openmp/parser/10"}
{"code": "for (i = 0; i < 150; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    printf(\"%f\\t\", datapoints[i].features[j]);\n  }\n\n  printf(\"%s\\n\", datapoints[i].classification);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/56"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_odd_even_transposition_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/odd-even-transposition/6"}
{"code": "for (k = 2; k <= 10; k++)\n{\n  printf(\"\\nAnalizing for k = %d\", k);\n  sumSil[k - 2] = 0;\n  for (int fold = 0; fold < 10; fold++)\n  {\n    trainingSet.data = (float **) calloc(dataset.dim - (dataset.dim / 10), sizeof(float *));\n    testSet.data = (float **) calloc(dataset.dim / 10, sizeof(float *));\n    datasetSubSets(dataset, fold, &trainingSet, &testSet);\n    sumSil[k - 2] += mainAlgo(trainingSet, testSet, 0);\n    if (fold < (10 - 1))\n    {\n      freeArray(trainingSet.data, trainingSet.dim);\n      freeArray(testSet.data, testSet.dim);\n    }\n\n  }\n\n  sumSil[k - 2] = sumSil[k - 2] / 10;\n  printf(\"\\nSilhouette: %f\", sumSil[k - 2]);\n  if (k == 2)\n    appSIL = sumSil[k - 2];\n\n  if (sumSil[k - 2] > appSIL)\n  {\n    bestk = k;\n    appSIL = sumSil[k - 2];\n  }\n\n  freeArray(trainingSet.data, trainingSet.dim);\n  freeArray(testSet.data, testSet.dim);\n  end = omp_get_wtime();\n  double time_spent = end - begin;\n  printf(\"\\nTime from start: %lf sec \\n------------------------\", time_spent);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/3"}
{"code": "for (i = 2; (i * i) <= n; i++)\n{\n  if (primes[i] == 'y')\n  {\n    for (j = i * i; j <= n; j += i)\n    {\n      primes[j] = 'n';\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/sieve/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#2#0\n  #pragma cetus parallel\n  for (j = 0; j < 100; j++)\n  {\n    b[i][j] = b[i][j] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB113-default-orig-no/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  vect3[i] = vect1[i] + vect2[i];\n}\n\n", "pragma": "\t\t\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (b[i] != validate[i])\n  {\n    if (flag == (-1))\n      printf(\"First fail: b[%d](%d) != validate[%d](%d)\\n\", i, b[i], i, validate[i]);\n\n    flag = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/map_zero_bug/map_zero_bug/2"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int jj = 0; jj < (N + 2); jj++)\n  {\n    fill_array3d(vector_out, N, N + 1, jj, kk, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/matvecAv/2"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      v[i][j][k][m] = v[i][j][k][m] - (omega * ((((((((((ldy[i][j][m][0] * v[i][j - 1][k][0]) + (ldx[i][j][m][0] * v[i - 1][j][k][0])) + (ldy[i][j][m][1] * v[i][j - 1][k][1])) + (ldx[i][j][m][1] * v[i - 1][j][k][1])) + (ldy[i][j][m][2] * v[i][j - 1][k][2])) + (ldx[i][j][m][2] * v[i - 1][j][k][2])) + (ldy[i][j][m][3] * v[i][j - 1][k][3])) + (ldx[i][j][m][3] * v[i - 1][j][k][3])) + (ldy[i][j][m][4] * v[i][j - 1][k][4])) + (ldx[i][j][m][4] * v[i - 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    v[i][j][k][1] = v[i][j][k][1] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    v[i][j][k][2] = v[i][j][k][2] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    v[i][j][k][3] = v[i][j][k][3] - (v[i][j][k][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    v[i][j][k][4] = v[i][j][k][4] - (v[i][j][k][3] * tmp);\n    v[i][j][k][4] = v[i][j][k][4] / tmat[4][4];\n    v[i][j][k][3] = v[i][j][k][3] - (tmat[3][4] * v[i][j][k][4]);\n    v[i][j][k][3] = v[i][j][k][3] / tmat[3][3];\n    v[i][j][k][2] = (v[i][j][k][2] - (tmat[2][3] * v[i][j][k][3])) - (tmat[2][4] * v[i][j][k][4]);\n    v[i][j][k][2] = v[i][j][k][2] / tmat[2][2];\n    v[i][j][k][1] = ((v[i][j][k][1] - (tmat[1][2] * v[i][j][k][2])) - (tmat[1][3] * v[i][j][k][3])) - (tmat[1][4] * v[i][j][k][4]);\n    v[i][j][k][1] = v[i][j][k][1] / tmat[1][1];\n    v[i][j][k][0] = (((v[i][j][k][0] - (tmat[0][1] * v[i][j][k][1])) - (tmat[0][2] * v[i][j][k][2])) - (tmat[0][3] * v[i][j][k][3])) - (tmat[0][4] * v[i][j][k][4]);\n    v[i][j][k][0] = v[i][j][k][0] / tmat[0][0];\n  }\n\n}\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/52"}
{"code": "for (int i = 0; i < taille; i++)\n{\n  printf(\"%d \", tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex6/6"}
{"code": "for (v_can = 1; v_can < D_can_height; v_can++)\n{\n  v = v_can * D_candidate_stepsize;\n  for (u_can = 1; u_can < D_can_width; u_can++)\n  {\n    u = u_can * D_candidate_stepsize;\n    *(D_can + getAddressOffsetImage(u_can, v_can, D_can_width)) = -1;\n    d = computeMatchingDisparity(u, v, I1_desc, I2_desc, false);\n    if (d >= 0)\n    {\n      d2 = computeMatchingDisparity(u - d, v, I1_desc, I2_desc, true);\n      if ((d2 >= 0) && (abs(d - d2) <= lr_threshold))\n        *(D_can + getAddressOffsetImage(u_can, v_can, D_can_width)) = d;\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/8"}
{"code": "for (i = 3; i < (grid_points[0] - 3); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/23"}
{"code": "for (int ll = 0; ll < NUM_VARS; ll++)\n{\n  for (int s = 0; s < sten_size; s++)\n  {\n    int inds = ((((ll * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + s) * (nx + (2 * hs)))) + i) + hs;\n    stencil[s] = state[inds];\n  }\n\n  vals[ll] = ((((-stencil[0]) / 12) + ((7 * stencil[1]) / 12)) + ((7 * stencil[2]) / 12)) - (stencil[3] / 12);\n  d3_vals[ll] = (((-stencil[0]) + (3 * stencil[1])) - (3 * stencil[2])) + stencil[3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-sycl/main/1"}
{"code": "for (int i = 0; i < 10; a[i++] = 2)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shreshthtuli/OpenMP/4-loops/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  free(matrixA[i]);\n  free(matrixB[i]);\n  free(result_serial[i]);\n  free(result_parallel[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nehabhoi/openMP/openmp/8"}
{"code": "for (y = 1; y < block_size; y++)\n{\n  for (x = 1; x < block_size; x++)\n  {\n    int count = 0;\n    count = verifica_vizinho(mat, y, x);\n    if ((mat[i + y][j + x] == 1) && (count < 2))\n    {\n      mat2[i + y][j + x] = 0;\n    }\n    else\n      if ((mat[i + y][j + x] == 1) && (count > 3))\n    {\n      mat2[i + y][j + x] = 0;\n    }\n    else\n      if ((mat[i + y][j + x] == 0) && (count == 3))\n    {\n      mat2[i + y][j + x] = 1;\n    }\n    else\n    {\n      mat2[i + y][j + x] = mat[i + y][j + x];\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(mat,mat2) private (i,j,y,x) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alanhenschel/The-game-of-life-parallel/jogo_da_vida/0"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    if (obstacles[ii + (jj * params.nx)])\n    {\n      u_x = (u_y = (u = 0.f));\n      pressure = params.density * c_sq;\n    }\n    else\n    {\n      local_density = 0.f;\n      for (int kk = 0; kk < 9; kk++)\n      {\n        local_density += cells->speeds[kk][ii + (jj * params.nx)];\n      }\n\n      u_x = (((cells->speeds[1][ii + (jj * params.nx)] + cells->speeds[5][ii + (jj * params.nx)]) + cells->speeds[8][ii + (jj * params.nx)]) - ((cells->speeds[3][ii + (jj * params.nx)] + cells->speeds[6][ii + (jj * params.nx)]) + cells->speeds[7][ii + (jj * params.nx)])) / local_density;\n      u_y = (((cells->speeds[2][ii + (jj * params.nx)] + cells->speeds[5][ii + (jj * params.nx)]) + cells->speeds[6][ii + (jj * params.nx)]) - ((cells->speeds[4][ii + (jj * params.nx)] + cells->speeds[7][ii + (jj * params.nx)]) + cells->speeds[8][ii + (jj * params.nx)])) / local_density;\n      u = sqrtf((u_x * u_x) + (u_y * u_y));\n      pressure = local_density * c_sq;\n    }\n\n    fprintf(fp, \"%d %d %.12E %.12E %.12E %.12E %d\\n\", ii, jj, u_x, u_y, u, pressure, obstacles[(ii * params.nx) + jj]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abcdrm/LBM-OpenMP/d2q9-bgk/6"}
{"code": "for (int k = 0; k < D; k++)\n{\n  for (int i = 0; i < tree->root->child1->data.size(); i++)\n  {\n    dim[k] += tree->root->child1->data.at(i)->dim[k];\n  }\n\n  dim[k] = dim[k] / tree->root->child1->data.size();\n  tree->root->child1->pivot[k] = dim[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/11"}
{"code": "for (i = 0; i < parN; i++)\n{\n  j *= STATE_N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/6"}
{"code": "for (mat_row = 0; mat_row < n; mat_row++)\n{\n  grid_row = mat_row / local_B->n_bar;\n  coords[0] = grid_row;\n  for (grid_col = 0; grid_col < grid->q; grid_col++)\n  {\n    coords[1] = grid_col;\n    MPI_Cart_rank(grid->comm, coords, &source);\n    if (source == 0)\n    {\n      for (mat_col = 0; mat_col < local_B->n_bar; mat_col++)\n        printf(\"%20.15E \", *((local_B->entries + (local_B->n_bar * mat_col)) + mat_row));\n\n    }\n    else\n    {\n      MPI_Recv(temp, local_B->n_bar, (MPI_Datatype) 0x4c00080b, source, 0, grid->comm, &status);\n      for (mat_col = 0; mat_col < local_B->n_bar; mat_col++)\n        printf(\"%20.15E \", temp[mat_col]);\n\n    }\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/10"}
{"code": "for (int n = 0; n < natoms; n++)\n{\n  kPositions.push_back(atoms[n]->position);\n  kCharges.push_back((float) atoms[n]->charge);\n  kVdwRadii.push_back((float) atoms[n]->vdwRadius);\n  kVdwAttractionMagnitudes.push_back((float) atoms[n]->vdwAttractionMagnitude);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmalepati1/Prosim/Prosim/Source/Classical/Energy/0"}
{"code": "for (int x = i_d; x < i_f; ++x)\n{\n  for (int y = j_d; y < j_f; ++y)\n  {\n    pixel_handler(x, y);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pravez/VitaeLabilis/src/compute/6"}
{"code": "for (size_t j = 0; j < (layout[i] - 1); ++j)\n{\n  double sum = 0.0;\n  temporary_layers_values[i - 1][layout[i - 1] - 1] = (bias) ? (1) : (0);\n  for (size_t l = 0; l < layout[i - 1]; ++l)\n  {\n    sum += temporary_layers_values[i - 1][l] * weights[i][j][l];\n  }\n\n  temporary_layers_values[i][j] = activation_func(sum);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Networks/MLP/1"}
{"code": "for (int i = 0; i < n; i++)\n  buf[i] = p1;\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_teams(1024) thread_limit(64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/memtest-omp/kernels/2"}
{"code": "for (i = 0; i < num_runs; i++)\n  axpy_omp_task_driver(N, Y_parallel, X, a, num_threads);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/interop/examples/axpy_omp/6"}
{"code": "for (i = 0; i < NoofRows; i++)\n{\n  for (j = 0; j < NoofCols; j++)\n    printf(\"%f \\t\", Matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/5"}
{"code": "for (int times = 0; times < 100; times++)\n{\n  for (int i = 0; i < len_test; i++)\n  {\n    float distances[len_train];\n    for (int j = 0; j < len_train; j++)\n      distances[j] = distance(X_test[i], X_train[j]);\n\n    int sortDistances[len_train];\n    argsort(distances, len_train, sortDistances);\n    int classCount[N] = {0};\n    for (int j = 0; j < k; j++)\n    {\n      int label = y_train[sortDistances[j]];\n      classCount[label]++;\n    }\n\n    predict[i] = indexOfMax(classCount, N);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/13"}
{"code": "for (i = 0; i < 2; i++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    for (k = 0; k < (nca / 2); k++)\n    {\n      for (int d = 0; d < (nca / 2); d++)\n      {\n        ABC[num + ((((((2 * (nca / 2)) * (nca / 2)) * i) + (((nca / 2) * (nca / 2)) * j)) + ((nca / 2) * k)) + d)] = a[num + (((k + ((nca / 2) * i)) * nca) + (d + ((nca / 2) * j)))];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/3"}
{"code": "for (int i = 0; i < E; i++)\n{\n  int u = graph->edge[i].src;\n  int v = graph->edge[i].dest;\n  int weight = graph->edge[i].weight;\n  if ((dist[u] != INT_MAX) && ((dist[u] + weight) < dist[v]))\n  {\n    printf(\"Graph contains negative weight cycle\");\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/varun2011/openmp/bell/3"}
{"code": "for (i = 0; i < TOTAL_POSSIBLE_COLORS; i++)\n{\n  histogramArray[i] = 0;\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(n_threads) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stevenalbert/parallel-histogram/openmp/main/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  total_mass += node->children[i].mass;\n  total_x += node->children[i].x_center * node->children[i].mass;\n  total_y += node->children[i].y_center * node->children[i].mass;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kawtar921/nbody/nbody_omp/nbody_tools/2"}
{"code": "for (int i = 5000001; i <= 7500000; i++)\n  funcsum[2] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/2"}
{"code": "for (unsigned n = 0; n < set->natoms; n++)\n  set->speed.dy[n] -= g;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/z-openmp/0"}
{"code": "for (i = 0; i < (LX1 - 1); i++)\n{\n  mor_s_v[1][i] = idmo[ntemp3][jjface[face]][0][0][i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/17"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int m = 0; m < 4; ++m)\n  {\n    mean[i].elements[m] = tep[i].elements[m] / (count1[i] * 100000);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/9"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_32 * SIMD_PARA_SHA256)\n{\n  SHA256_CTX ctx;\n  SHA256_Init(&ctx);\n  SHA256_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  SHA256_Update(&ctx, cur_salt->salt, 32);\n  SHA256_Final((unsigned char *) crypt_out[index], &ctx);\n  pwsafe_sha256_iterate(ctx.h, cur_salt->iterations);\n  memcpy(crypt_out[index], ctx.h, 32);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pwsafe_fmt_plug/2"}
{"code": "for (j = 1; j <= ny2; j++)\n{\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k + 1][j][i][m])) + u[k + 2][j][i][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/5"}
{"code": "for (int j = 0; j < numOfClusters; j++)\n{\n  double diameter = allClusters[j].diameter;\n  for (int q = 0; q < numOfClusters; q++)\n  {\n    if (j != q)\n    {\n      double distance = sqrt((pow(allClusters[q].x - allClusters[j].x, 2) + pow(allClusters[q].y - allClusters[j].y, 2)) + pow(allClusters[q].z - allClusters[j].z, 2));\n      diameter /= distance;\n      quality += diameter;\n      countOfVar++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  this_diff = w_ref[i] - w_opt[i];\n  if (fabs(this_diff) > THRESHOLD)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n      maxdiff = this_diff;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gaurav047/High-Performance-Computing---OpenMP/Codes/problem1/1"}
{"code": "for (int i = 0; i < v.size(); i++)\n{\n  v[i]->output();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shcherbakov-Mikhail/Task3-sem4/functions/3"}
{"code": "for (j = 0; j < (n - 1); j++)\n{\n  if (vet[j] > vet[j + 1])\n  {\n    swap(&vet[j], &vet[j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Karnopp/parallel-vector-ordering/ordena/0"}
{"code": "for (int i = 0; i < numberOfInt; i++)\n{\n  fscanf(fp, \"%d\", &tmp->tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aurelienspnll/matrix-mult-ring-rotation/matrix-mult-ring-rotation/2"}
{"code": "for (size_t i = 0; i < 100;)\n{\n  arr[i++] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_TreeSearch_OpenMP/TreeSearch/TreeSearch/MP/1"}
{"code": "for (int j = pow(2, l) - 1; j < upper_bound; j++)\n{\n  *(A + j) = (*((A + (j * 2)) + 1)) + (*((A + (j * 2)) + 2));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/0"}
{"code": "for (int i = 0; i < 8; ++i)\n{\n  if (tempB[0] == 1)\n    Pval = Pval ^ tempA;\n\n  tempB >>= 1;\n  carry = tempA[7];\n  tempA <<= 1;\n  if (carry == 1)\n    tempA = tempA ^ valX;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/12"}
{"code": "for (j = 0; j < ncon; j++)\n{\n  if (ind->constr[j] < 0.0)\n  {\n    ind->constr_violation += ind->constr[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/4"}
{"code": "for (i = 1; i <= NODESX; i++)\n  TOPO[i][(NODESY + 2) - 1] = TOPO[i][1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/131"}
{"code": "for (int i = 0; i < num_rows; i++)\n{\n  for (int j = 0; j < num_cols; j++)\n  {\n    extended[extend_amount + i][extend_amount + j] = img[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hanzallah/parallel-convolution/convolution_omp/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      lwr[i][j] = 1.0;\n    }\n    else\n      if (j > i)\n    {\n      lwr[i][j] = 0.0;\n    }\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clamslam12/LUdecomposition/ludecomp/2"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  beta = ((.5 * qom[is]) * dt) / c;\n  for (int i = 0; i < nxn; i++)\n    for (int j = 0; j < nyn; j++)\n  {\n    omcx = beta * (Bxn[i][j][1] + Bx_ext[i][j][1]);\n    omcy = beta * (Byn[i][j][1] + By_ext[i][j][1]);\n    omcz = beta * (Bzn[i][j][1] + Bz_ext[i][j][1]);\n    denom = ((((((FourPI / 2) * delt) * dt) / c) * qom[is]) * rhons[is][i][j][1]) / (((1.0 + (omcx * omcx)) + (omcy * omcy)) + (omcz * omcz));\n    susxz[i][j] += ((-omcy) + (omcx * omcz)) * denom;\n    susyz[i][j] += (omcx + (omcy * omcz)) * denom;\n    suszz[i][j] += (1.0 + (omcz * omcz)) * denom;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/91"}
{"code": "for (int k = 0; k < ROW; ++k)\n{\n  float32x4_t diver = vld1q_dup_f32(&revmat[k][k]);\n  int j;\n  for (j = k + 1; (j < ROW) && ((ROW - j) & 3); ++j)\n    revmat[j][k] = revmat[j][k] / revmat[k][k];\n\n  for (; j < ROW; j += 4)\n  {\n    float32x4_t divee = vld1q_lane_f32(&revmat[j][k], divee, 0);\n    divee = vld1q_lane_f32(&revmat[j + 1][k], divee, 1);\n    divee = vld1q_lane_f32(&revmat[j + 2][k], divee, 2);\n    divee = vld1q_lane_f32(&revmat[j + 3][k], divee, 3);\n    divee = vdivq_f32(divee, diver);\n    vst1q_lane_f32(&revmat[j][k], divee, 0);\n    vst1q_lane_f32(&revmat[j + 1][k], divee, 1);\n    vst1q_lane_f32(&revmat[j + 2][k], divee, 2);\n    vst1q_lane_f32(&revmat[j + 3][k], divee, 3);\n  }\n\n  revmat[k][k] = 1.0;\n  for (int i = k + 1; i < ROW; i++)\n  {\n    int j;\n    for (j = k + 1; (j < ROW) && ((ROW - j) & 3); j++)\n      revmat[i][j] = revmat[i][j] - (revmat[k][j] * revmat[i][k]);\n\n    for (; j < ROW; j += 4)\n    {\n      float32x4_t subbee;\n      float32x4_t mult1;\n      float32x4_t mult2;\n      subbee = vld1q_f32(&revmat[i][j]);\n      mult1 = vld1q_f32(&revmat[k][j]);\n      mult2 = vld1q_dup_f32(&revmat[i][k]);\n      mult1 = vmulq_f32(mult1, mult2);\n      subbee = vsubq_f32(subbee, mult1);\n      vst1q_f32(&revmat[i][j], subbee);\n    }\n\n  }\n\n  for (int i = k + 1; i < ROW; i++)\n    revmat[k][i] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ching-Yee-Chan/openMP/arm/0"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    w[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_backprop/backprop/5"}
{"code": "for (unsigned i = 0; i < points.size(); i++)\n{\n  points[i] = points[i] * scale;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/operators/mesh/5"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrixC[i][j] = 0;\n    for (k = 0; k < o; k++)\n    {\n      matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekaryaREPO/Concurrent-Programming-with-Java-and-OpenMP/ASSIGNMENT 2-OpenMP/SOURCE CODE AND EXECUTABLES/MatrixMultiplicationUsingThreads/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (5.0 * u[i][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,k ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/129"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (j,n,j1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/196"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  matc[i][j] = mata[i][j] * matb[i][j];\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/comparing/matrix/matrix_prod-omp/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  dxi = 0.0;\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    if (i == colidx[j])\n    {\n      diag = val[j];\n    }\n    else\n      if (i != colidx[j])\n    {\n      dxi += val[j] * x[colidx[j]];\n    }\n\n\n  }\n\n  dx[i] = (dx[i] - dxi) / diag;\n}\n\n", "pragma": "   #pragma omp for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lnugraha/parallelized-sparse-iterative-solvers/new_omp_solvers/9"}
{"code": "for (i = 0; i < lines; i++)\n  free(buffer[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vasilismantz/parallel-programming/ex3/2"}
{"code": "for (i = 1; i < (1 << NUM_BUCKETS_LOG_2); i++)\n{\n  bucket_ptrs[i] = bucket_ptrs[i - 1];\n  for (k = 0; k < myid; k++)\n    bucket_ptrs[i] += bucket_size[k][i];\n\n  for (k = myid; k < num_threads; k++)\n    bucket_ptrs[i] += bucket_size[k][i - 1];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/13"}
{"code": "for (k = 0; k < d3; k++)\n{\n  for (jj = 0; jj <= (d2 - FFTBLOCK); jj += FFTBLOCK)\n  {\n    for (j = 0; j < FFTBLOCK; j++)\n    {\n      for (i = 0; i < d1; i++)\n      {\n        y1[i][j] = x[k][j + jj][i];\n      }\n\n    }\n\n    cfftz(is, logd1, d1, y1, y2);\n    for (j = 0; j < FFTBLOCK; j++)\n    {\n      for (i = 0; i < d1; i++)\n      {\n        xout[k][j + jj][i] = y1[i][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/0"}
{"code": "for (int i = 0; i < u->get_size()[0]; ++i)\n{\n  u->get_values()[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ginkgo-project/ginkgo/examples/custom-matrix-format/custom-matrix-format/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (j = 1 * 3; j <= ((grid_points[1] - 3) - 1); j += 1)\n  {\n    forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/22"}
{"code": "for (int i = 0; i < rotatedOrbitals.size(); i++)\n{\n  for (int j = 0; j < rotatedOrbitals.size(); j++)\n  {\n    for (int ix = 0; ix < nx; ix++)\n      for (int iy = 0; iy < ny; iy++)\n      for (int iz = 0; iz < nz; iz++)\n      allRotatedSplines[i](ix, iy, iz) += rotationMatrix[(i * rotatedOrbitals.size()) + j] * allOriginalSplines[j](ix, iy, iz);\n\n\n\n  }\n\n}\n\n", "pragma": "      #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderESHDF.fft/17"}
{"code": "for (int j = 0; j < max.capa; ++j)\n  task.subset[i][j] = 0;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/partition/0"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/57"}
{"code": "for (int y = y0; y < y1; y++)\n{\n  int yLine = WORLD_WIDTH * y;\n  for (int x = x0; x < x1; x++)\n  {\n    int cnt = 0;\n    for (int yy = y - 1; yy <= (y + 1); yy++)\n    {\n      for (int xx = x - 1; xx <= (x + 1); xx++)\n      {\n        if (m_matSrc[(WORLD_WIDTH * yy) + xx] != CELL_DEAD)\n        {\n          cnt++;\n        }\n\n      }\n\n    }\n\n    updateCell(x, yLine, cnt);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iwatake2222/FastGameOfLife/GameOfLife/LogicNormalMP/1"}
{"code": "for (i = 0; i < 512; i++)\n{\n  #pragma acc loop independent\n  for (j = 0; j < 512; j++)\n  {\n    D[(i * 512) + j] = (((DATA_TYPE) i) * (j + 2)) / 512;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/3mm_AI/3"}
{"code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 250; j++)\n  {\n    for (k = 0; k < 250; k++)\n      C[(i * 250) + j] += A[(i * 250) + k] * B[(k * 250) + j];\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skyrain/openmp/openmp_skyrain/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n  }\n\n  lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,k,m) firstprivate (n,i1,i2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/162"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"\\n BATCHED Iteration %d is done by T%d \", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/V6429/openmp_present/presentation/5.Loop/1"}
{"code": "for (int i = 0; i < number_of_blocks; i++)\n{\n  BlockSort(input, length_of_blocks[i], start_position);\n  start_position += length_of_blocks[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/antonKorobenko/parallel-binsort/binsort_openMp/4"}
{"code": "for (int atom = 0; atom < ((int) currentCoords.Count()); atom++)\n{\n  startMol[atom] = mols.MolStart(particleMol[atom]);\n  lengthMol[atom] = mols.MolLength(particleMol[atom]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/0"}
{"code": "for (r = 3; r < n; r += 2)\n  if ((n % r) == 0)\n  return r;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/1"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x[i], nbins, xmin, xmax, edges);\n  values[bin]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/5"}
{"code": "for (int i = 0; i < xelem; i++)\n{\n  for (int j = 0; j < yelem; j++)\n  {\n    sclr.u[i][j][0] = (PI * (50.0 - y[i][j])) / 314.0;\n    sclr.v[i][j][0] = (PI * (x[i][j] - 50.0)) / 314.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jichenglee/INS_LevelSet/NE577/main/4"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < cols; j++)\n{\n  a = adjacent_to(board, i, j, rows, cols);\n  if (a == 2)\n    newboard[(i * cols) + j] = board[(i * cols) + j];\n\n  if (a == 3)\n    newboard[(i * cols) + j] = 1;\n\n  if (a < 2)\n    newboard[(i * cols) + j] = 0;\n\n  if (a > 3)\n    newboard[(i * cols) + j] = 0;\n\n}\n\n\n", "pragma": "omp parallel for private(i, j, a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosevoul/parallel-game-of-life/src/play/0"}
{"code": "for (int i = myoffset; i < (myoffset + mylength); i++)\n{\n  for (int j = 0; j < nBodies; j++)\n  {\n    if ((j >= myoffset) && (j < (myoffset + mylength)))\n    {\n      if (j < i)\n      {\n        acc_bar(bodies, i, j, accX, accY);\n      }\n\n    }\n    else\n    {\n      acc_foo(bodies, i, j, accX, accY);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:accX,accY)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nelorth/nbody/src/nbody/parallel/4"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/26"}
{"code": "for (I_ = 0; I_ < n; I_ += s)\n{\n  for (J_ = 0; J_ < n; J_ += s)\n  {\n    for (i = 0; i < n; i++)\n    {\n      for (j = I_; j < (((I_ + s) > n) ? (n) : (I_ + s)); j++)\n      {\n        temp = 0;\n        for (k = J_; k < (((J_ + s) > n) ? (n) : (J_ + s)); k++)\n        {\n          temp += b[i][k] * c[k][j];\n        }\n\n        a[i][j] += temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brett-stephen/HP-Matrix-Multiplication/matrix/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < columns; j++)\n  {\n    calculateNextGenState(i, j);\n    updateCell(i, j);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Alakeil/gameoflife/gol/0"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 3; j++)\n  if (taula[pi + i][pj + j] == z)\n  return 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/7"}
{"code": "for (i = 0; i < (N - 1); ++i)\n{\n  if (list[i] > list[i + 1])\n  {\n    int temp = list[i];\n    list[i] = list[i + 1];\n    list[i + 1] = temp;\n    swapped = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_7/programme/wrong_bubble_sort_omp/0"}
{"code": "for (int point = 0; point < n; point++)\n{\n  for (int dim = 0; dim < m; dim++)\n  {\n    phy[dim + (point * m)] = t[dim + (0 * m)];\n    for (int vertex = 1; vertex < (m + 1); vertex++)\n    {\n      phy[dim + (point * m)] = phy[dim + (point * m)] + ((t[dim + (vertex * m)] - t[dim + (0 * m)]) * ref[(vertex - 1) + (point * m)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(n, m, t, ref, phy) OMP_SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task2_simplex/simplex_modified_for_omp/simplex/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (arr[i] > max_val_seq)\n  {\n    max_val_seq = arr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/max_vector_element/1"}
{"code": "for (y = 0; y < data_size_Y; y++)\n{\n  for (x = 0; x < (data_size_X / 4); x++)\n  {\n    resVect = _mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + ((y - 1) * pad_size_X)) + (x * 4)) - 1), kern1);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps(((padin + (pad_size_X + 1)) + ((y - 1) * pad_size_X)) + (x * 4)), kern2), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + ((y - 1) * pad_size_X)) + (x * 4)) + 1), kern3), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + (y * pad_size_X)) + (x * 4)) - 1), kern4), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps(((padin + (pad_size_X + 1)) + (y * pad_size_X)) + (x * 4)), kern5), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + (y * pad_size_X)) + (x * 4)) + 1), kern6), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + ((y + 1) * pad_size_X)) + (x * 4)) - 1), kern7), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps(((padin + (pad_size_X + 1)) + ((y + 1) * pad_size_X)) + (x * 4)), kern8), resVect);\n    resVect = _mm_add_ps(_mm_mul_ps(_mm_loadu_ps((((padin + (pad_size_X + 1)) + ((y + 1) * pad_size_X)) + (x * 4)) + 1), kern9), resVect);\n    _mm_storeu_ps((out + (y * data_size_X)) + (x * 4), resVect);\n  }\n\n  for (x = (data_size_X / 4) * 4; x < data_size_X; x++)\n  {\n    out[x + (y * data_size_X)] += ((((((((flipKernel[0] * padin[((pad_size_X + 1) + (x - 1)) + ((y - 1) * pad_size_X)]) + (flipKernel[1] * padin[((pad_size_X + 1) + x) + ((y - 1) * pad_size_X)])) + (flipKernel[2] * padin[((pad_size_X + 1) + (x + 1)) + ((y - 1) * pad_size_X)])) + (flipKernel[3] * padin[((pad_size_X + 1) + (x - 1)) + (y * pad_size_X)])) + (flipKernel[4] * padin[((pad_size_X + 1) + x) + (y * pad_size_X)])) + (flipKernel[5] * padin[((pad_size_X + 1) + (x + 1)) + (y * pad_size_X)])) + (flipKernel[6] * padin[((pad_size_X + 1) + (x - 1)) + ((y + 1) * pad_size_X)])) + (flipKernel[7] * padin[((pad_size_X + 1) + x) + ((y + 1) * pad_size_X)])) + (flipKernel[8] * padin[((pad_size_X + 1) + (x + 1)) + ((y + 1) * pad_size_X)]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hyeminchocho/ImageProcessingOptimization/part2/2"}
{"code": "for (y = 0; y < bmiHeader.biHeight; y++)\n{\n  for (x = 0; x < bmiHeader.biWidth; x++)\n  {\n    double rSum = 0;\n    double gSum = 0;\n    double bSum = 0;\n    double kSum = 0;\n    for (i = 0; i < filterSize; i++)\n    {\n      for (j = 0; j < filterSize; j++)\n      {\n        pixelPosX = (x + j) - (filterSize / 2);\n        pixelPosY = (y + i) - (filterSize / 2);\n        if (pixelPosX < 0)\n          pixelPosX += filterSize / 2;\n\n        if (pixelPosY < 0)\n          pixelPosY += filterSize / 2;\n\n        if (pixelPosX > bmiHeader.biWidth)\n          continue;\n\n        if (pixelPosY > bmiHeader.biHeight)\n          continue;\n\n        if (pixelPosX == bmiHeader.biWidth)\n          pixelPosX = (bmiHeader.biWidth - (filterSize / 2)) - 1;\n\n        if (pixelPosY == bmiHeader.biHeight)\n          pixelPosY = (bmiHeader.biHeight - (filterSize / 2)) - 1;\n\n        red = temp[pixelPosY][pixelPosX].rgbRed;\n        green = temp[pixelPosY][pixelPosX].rgbGreen;\n        blue = temp[pixelPosY][pixelPosX].rgbBlue;\n        kernelVal = blurArray[i][j];\n        rSum += red * kernelVal;\n        gSum += green * kernelVal;\n        bSum += blue * kernelVal;\n        kSum += kernelVal;\n      }\n\n    }\n\n    if (kSum <= 0)\n      kSum = 1;\n\n    rSum /= kSum;\n    if (rSum < 0)\n      rSum = 0;\n\n    if (rSum > 255)\n      rSum = 255;\n\n    gSum /= kSum;\n    if (gSum < 0)\n      gSum = 0;\n\n    if (gSum > 255)\n      gSum = 255;\n\n    bSum /= kSum;\n    if (bSum < 0)\n      bSum = 0;\n\n    if (bSum > 255)\n      bSum = 255;\n\n    temp[y][x].rgbRed = rSum;\n    temp[y][x].rgbGreen = gSum;\n    temp[y][x].rgbBlue = bSum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(temp,blurArray) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/5"}
{"code": "for (i = 0; i < ROWSIZE; i++)\n{\n  for (j = 0; j < COLSIZE; j++)\n  {\n    printf(\"%f \", pA(i, j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/SREC_workshop/ex5_mpi_reduction/mm/2"}
{"code": "for (i = num * elementsInSeriesPerThread; i < vector_size; i += elementsInSeriesPerThread * count)\n{\n  temp[i] = 0;\n  for (j = i; (j < (i + elementsInSeriesPerThread)) && (j < vector_size); j++)\n  {\n    temp[i] += vector[j] * multiplier_vector[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nrvru/parallel-lab1/RandomVector/3"}
{"code": "for (l = starti; l < finishi; l++)\n{\n  int cost[3];\n  int tmp;\n  cost[0] = prev[l] + 1;\n  cost[1] = pprev[l + 1] + (a[q_i - 1] != b[p_i - 1]);\n  cost[2] = prev[l + 1] + 1;\n  tmp = (cost[0] < cost[1]) ? (cost[0]) : (cost[1]);\n  tmp = (tmp < cost[2]) ? (tmp) : (cost[2]);\n  act[l] = tmp;\n  p_i--;\n  q_i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/9"}
{"code": "for (int i = 0; i < 1; ++i)\n{\n  ((cout << \"lastprivate: chances are this number is 13: \") << var) << endl;\n}\n\n", "pragma": "    #pragma omp parallel for lastprivate(var) num_threads(1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daleksla/learning/tools/openmp/arguments/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n  ;\n}\n\n", "pragma": "omp for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/ordered-3/4"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  if (i < (n - 1))\n  {\n    if (g != 0.0)\n    {\n      for (j = l; j < n; j++)\n        vt[i][j] = (u[i][j] / u[i][l]) / g;\n\n      for (j = l; j < n; j++)\n      {\n        s = 0.0;\n        for (k = l; k < n; k++)\n          s += u[i][k] * vt[j][k];\n\n        for (k = l; k < n; k++)\n          vt[j][k] += s * vt[i][k];\n\n      }\n\n    }\n\n  }\n\n  for (j = l; j < n; j++)\n  {\n    vt[j][i] = 0.0;\n    vt[i][j] = 0.0;\n  }\n\n  vt[i][i] = 1.0;\n  g = rv1[i];\n  l = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/14"}
{"code": "for (int i = 0; i < (dim * dim); i += 2)\n{\n  int Ai = _mm_loadu_pd(self_mat + i);\n  int Bi = _mm_loadu_pd(mat + i);\n  int R1 = _mm_mul_pd(Ai, ai);\n  int R2 = _mm_mul_pd(Bi, bi);\n  int R = _mm_add_pd(R1, R2);\n  _mm_storeu_pd(self_mat + i, R);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirillston/OpenMP-MPI/mpp/matop/1"}
{"code": "for (p_index_ = p_lower_; p_index_ <= p_upper_; p_index_ += stride)\n{\n  a[p_index_] = p_index_ * 2;\n  printf(\"Iteration %2d is carried out by thread %2d\\n\", p_index_, omp_get_thread_num());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/roseTests/ompLoweringTests/ROSEXOMPReference/rose_ompfor2/0"}
{"code": "for (int i = 1; i < 10000; i++)\n{\n  if (vec[i] < vec[i - 1])\n  {\n    printf(\"Vectorul nu este ordonat!\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/florin-alistar/AlistarSerbanFlorin_Tema1_OpenMP/radix/4"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < HALO.y; j++)\n  {\n    for (int i = 0; i < SDMGeom->L_NodeX(); i++)\n    {\n      indx1 = (i + (j * NodLoc.x)) + ((k * HALO.y) * NodLoc.x);\n      indx2 = ((HALO.x + i) + (((j + SDMGeom->HALO_NodeY()) - HALO.y) * SDMGeom->HALO_NodeX())) + (((k + HALO.z) * SDMGeom->HALO_NodeX()) * SDMGeom->HALO_NodeY());\n      DomLoc[indx2] = BN[indx1];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_omp)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/12"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    for (k = 0; k < z; k++)\n    {\n      if (dom[i][j][k] == 0)\n      {\n        tmpdy = zdy[j];\n        tmpdz = zdz[k];\n        min_tmp1 = min_dt_first(tmpdy, tmpdz);\n        tmp = min_dt_first(zdx[i], min_tmp1);\n        svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / zdx[i];\n        xvel = fabs(vx[i][j][k]) / zdx[i];\n        yvel = fabs(vy[i][j][k]) / tmpdy;\n        zvel = fabs(vz[i][j][k]) / tmpdz;\n        max_tmp1 = max_dt_first(xvel, yvel);\n        max_tmp2 = max_dt_first(zvel, svel);\n        max_tmp3 = max_dt_first(max_tmp1, max_tmp2);\n        rdt1 = max_dt_first(max_tmp3, rdt1);\n        if (viscosity_on_off == 1)\n        {\n          temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n          kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n          s_visc = kin_viscosity / (tmp * tmp);\n          rdt1 = max_dt_first(s_visc, rdt1);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc_first/3"}
{"code": "for (int i = 0; i < length; i++)\n{\n  result[i] = __builtin_popcountll(data[i]);\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/8"}
{"code": "for (m = 0; m < ng; m++)\n{\n  fft_data_local[2 * m] = f[i][m][k].Re;\n  fft_data_local[(2 * m) + 1] = f[i][m][k].Im;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/Gpower/fft/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp1 = a[(k * n) + i];\n  a[(k * n) + i] = a[(kd * n) + i];\n  a[(kd * n) + i] = temp1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NisargGB/Multi-threaded-LU-Decomposition/pthread_sections/0"}
{"code": "for (i = -1; i < 50; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/bug/omp_bug1fix/0"}
{"code": "for (i = 0; i < nclusters; i++)\n{\n  for (j = 0; j < nfeatures; j++)\n  {\n    if (new_centers_len[i] > 0)\n      clusters[(i * nfeatures) + j] = new_centers[i][j] / new_centers_len[i];\n\n    new_centers[i][j] = 0.0;\n  }\n\n  new_centers_len[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/kmeans/kmeans_clustering.ref/4"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  if (cur_salt->algo_type == 2)\n  {\n    memcpy(&ctx, &cur_salt->prep_salt, sizeof(MD5_CTX));\n    MD5_Update(&ctx, saved_key[index], saved_len[index]);\n    if (saved_len[index] < 16)\n    {\n      MD5_Update(&ctx, zeropad, 16 - saved_len[index]);\n    }\n\n    if (cur_salt->have_extra_salt)\n    {\n      MD5_Update(&ctx, cur_salt->extra_salt, cur_salt->extra_salt_length);\n    }\n\n    MD5_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n  else\n  {\n    HMAC_SHA256_CTX hctx[1];\n    unsigned char output[32];\n    unsigned char buffer[((1 + 81) + 45) + 1] = {0};\n    buffer[0] = '\\n';\n    memcpy(buffer + 1, saved_key[index], saved_len[index]);\n    memcpy((buffer + 1) + saved_len[index], cur_salt->ip, cur_salt->ip_length);\n    HMAC_SHA256_Init(hctx, buffer, (1 + saved_len[index]) + cur_salt->ip_length);\n    HMAC_SHA256_Update(hctx, cur_salt->salt, cur_salt->length);\n    HMAC_SHA256_Final(output, hctx);\n    memcpy((unsigned char *) crypt_out[index], output, 16);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/eigrp_fmt_plug/0"}
{"code": "for (i = filename.size() - 5; i > 0; i--)\n{\n  if (filename[i] == '/')\n    break;\n\n  dim += filename[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leoaugustoam/PCA-Parallel-OpenMP/pca/10"}
{"code": "for (int i = 1; i <= num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun2011/openmp/pi_2/0"}
{"code": "for (int p = ini; p < fin; p++)\n  Acec[p].y = 0;\n\n", "pragma": "      #pragma omp parallel for schedule (static) if(npf>OMP_LIMIT_COMPUTELIGHT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphCpuSingle/0"}
{"code": "for (iterator itp1 = primes_g.begin(); (itp1 != primes_g.end()) && ((*itp1) <= (n / 2)); ++itp1)\n{\n  if (is_prime(n - (*itp1)))\n    ++ans;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thiagowfx/coc-472-CAD/T2/ex3/goldbach/2"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  int j;\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  SHA512_Update(&ctx, cur_salt->salt, strlen((char *) cur_salt->salt));\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n  for (j = 0; j < 99; j++)\n  {\n    SHA512_CTX ctx;\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, (unsigned char *) crypt_out[index], 64);\n    SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/blackberry_ES10_fmt_plug/0"}
{"code": "for (int i_counter = 4; i_counter <= pnHalfed; i_counter++)\n{\n  if (((*pn) % i_counter) == 0)\n  {\n    primIndicator = false;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/4"}
{"code": "for (i = 0; i < n; i++)\n  y[i] = 0;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/band_matrix/main/0"}
