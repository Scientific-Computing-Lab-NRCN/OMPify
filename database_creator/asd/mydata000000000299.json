{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_pwm_cfg", "code": "\nvoid mdss_dsi_panel_pwm_cfg(struct mdss_dsi_ctrl_pdata *ctrl)\n{\n\tif (ctrl->pwm_pmi)\n\t\treturn;\n\n\tctrl->pwm_bl = pwm_request(ctrl->pwm_lpg_chan, \"lcd-bklt\");\n\tif (ctrl->pwm_bl == NULL || IS_ERR(ctrl->pwm_bl)) {\n\t\tpr_err(\"%s: Error: lpg_chan=%d pwm request failed\",\n\t\t\t\t__func__, ctrl->pwm_lpg_chan);\n\t}\n\tctrl->pwm_enabled = 0;\n}", "llvm": null, "hash": "5fbabb6f1efb769248547790dfcd90620f5a8939ae67678d379cc79710ca907e", "memory": 327}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_bklt_pwm", "code": "\nstatic void mdss_dsi_panel_bklt_pwm(struct mdss_dsi_ctrl_pdata *ctrl, int level)\n#endif\n{\n\tint ret;\n\tu32 duty;\n\tu32 period_ns;\n\n\tif (ctrl->pwm_bl == NULL) {\n\t\tpr_err(\"%s: no PWM\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (level == 0) {\n\t\tif (ctrl->pwm_enabled) {\n\t\t\tret = pwm_config_us(ctrl->pwm_bl, level,\n\t\t\t\t\tctrl->pwm_period);\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: pwm_config_us() failed err=%d.\\n\",\n\t\t\t\t\t\t__func__, ret);\n\t\t\tpwm_disable(ctrl->pwm_bl);\n\t\t}\n\t\tctrl->pwm_enabled = 0;\n\t\treturn;\n\t}\n\n\tduty = level * ctrl->pwm_period;\n\tduty /= ctrl->bklt_max;\n\n\tpr_debug(\"%s: bklt_ctrl=%d pwm_period=%d pwm_gpio=%d pwm_lpg_chan=%d\\n\",\n\t\t\t__func__, ctrl->bklt_ctrl, ctrl->pwm_period,\n\t\t\t\tctrl->pwm_pmic_gpio, ctrl->pwm_lpg_chan);\n\n\tpr_debug(\"%s: ndx=%d level=%d duty=%d\\n\", __func__,\n\t\t\t\t\tctrl->ndx, level, duty);\n\n\tif (ctrl->pwm_period >= USEC_PER_SEC) {\n\t\tret = pwm_config_us(ctrl->pwm_bl, duty, ctrl->pwm_period);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: pwm_config_us() failed err=%d.\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tperiod_ns = ctrl->pwm_period * NSEC_PER_USEC;\n\t\tret = pwm_config(ctrl->pwm_bl,\n\t\t\t\tlevel * period_ns / ctrl->bklt_max,\n\t\t\t\tperiod_ns);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: pwm_config() failed err=%d.\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ctrl->pwm_enabled) {\n\t\tret = pwm_enable(ctrl->pwm_bl);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: pwm_enable() failed err=%d\\n\", __func__,\n\t\t\t\tret);\n\t\tctrl->pwm_enabled = 1;\n\t}\n}", "llvm": null, "hash": "af81033cbdd22763638b86c9b8fdf60e3cf99aebd92cf15829a95fb3a85671aa", "memory": 1408}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_cmd_read", "code": "\nu32 mdss_dsi_panel_cmd_read(struct mdss_dsi_ctrl_pdata *ctrl, char cmd0,\n\t\tchar cmd1, void (*fxn)(int), char *rbuf, int len)\n{\n\tstruct dcs_cmd_req cmdreq;\n\tstruct mdss_panel_info *pinfo;\n\n\tpinfo = &(ctrl->panel_data.panel_info);\n\tif (pinfo->dcs_cmd_by_left) {\n\t\tif (ctrl->ndx != DSI_CTRL_LEFT)\n\t\t\treturn -EINVAL;\n\t}\n\tdcs_cmd[0] = cmd0;\n\tdcs_cmd[1] = cmd1;\n\tmemset(&cmdreq, 0, sizeof(cmdreq));\n\tcmdreq.cmds = &dcs_read_cmd;\n\tcmdreq.cmds_cnt = 1;\n\tcmdreq.flags = CMD_REQ_RX | CMD_REQ_COMMIT;\n\tcmdreq.rlen = len;\n\tcmdreq.rbuf = rbuf;\n\tcmdreq.cb = fxn; /* call back */\n\tmdss_dsi_cmdlist_put(ctrl, &cmdreq);\n\t/*\n\t * blocked here, until call back called\n\t */\n\n\treturn 0;\n}", "llvm": null, "hash": "8cec6a4f2299ce2e382ca0c53b4f28caeece9a3ef4dc2060f5efdd8cdd0a56a9", "memory": 667}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_cmds_send", "code": "\nstatic void mdss_dsi_panel_cmds_send(struct mdss_dsi_ctrl_pdata *ctrl,\n\t\t\tstruct dsi_panel_cmds *pcmds)\n#endif\n{\n\tstruct dcs_cmd_req cmdreq;\n\tstruct mdss_panel_info *pinfo;\n\n\tpinfo = &(ctrl->panel_data.panel_info);\n\tif (pinfo->dcs_cmd_by_left) {\n\t\tif (ctrl->ndx != DSI_CTRL_LEFT)\n\t\t\treturn;\n\t}\n\n\tmemset(&cmdreq, 0, sizeof(cmdreq));\n\tcmdreq.cmds = pcmds->cmds;\n\tcmdreq.cmds_cnt = pcmds->cmd_cnt;\n\tcmdreq.flags = CMD_REQ_COMMIT;\n\n\t/*Panel ON/Off commands should be sent in DSI Low Power Mode*/\n\tif (pcmds->link_state == DSI_LP_MODE)\n\t\tcmdreq.flags  |= CMD_REQ_LP_MODE;\n\telse if (pcmds->link_state == DSI_HS_MODE)\n\t\tcmdreq.flags |= CMD_REQ_HS_MODE;\n\n\tcmdreq.rlen = 0;\n\tcmdreq.cb = NULL;\n\n\tmdss_dsi_cmdlist_put(ctrl, &cmdreq);\n}", "llvm": null, "hash": "2dfde872b117a95c99c954787670b692ad60504b99f5938d0b7762c62c197a2d", "memory": 725}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_bklt_dcs", "code": "\nstatic void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)\n{\n\tstruct dcs_cmd_req cmdreq;\n\tstruct mdss_panel_info *pinfo;\n\n\tpinfo = &(ctrl->panel_data.panel_info);\n\tif (pinfo->dcs_cmd_by_left) {\n\t\tif (ctrl->ndx != DSI_CTRL_LEFT)\n\t\t\treturn;\n\t}\n\n\tpr_debug(\"%s: level=%d\\n\", __func__, level);\n\n\tled_pwm1[1] = (unsigned char)level;\n\n\tmemset(&cmdreq, 0, sizeof(cmdreq));\n\tcmdreq.cmds = &backlight_cmd;\n\tcmdreq.cmds_cnt = 1;\n\tcmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;\n\tcmdreq.rlen = 0;\n\tcmdreq.cb = NULL;\n\n\tmdss_dsi_cmdlist_put(ctrl, &cmdreq);\n}", "llvm": null, "hash": "8e4b947ca654614bae304eb765141b06e5bb164d08bd952bf87e0e75046e3bf1", "memory": 565}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_request_gpios", "code": "\nstatic int mdss_dsi_request_gpios(struct mdss_dsi_ctrl_pdata *ctrl_pdata)\n{\n\tint rc = 0;\n\n\tif (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {\n\t\trc = gpio_request(ctrl_pdata->disp_en_gpio,\n\t\t\t\t\t\t\"disp_enable\");\n\t\tif (rc) {\n\t\t\tpr_err(\"request disp_en gpio failed, rc=%d\\n\",\n\t\t\t\t       rc);\n\t\t\tgoto disp_en_gpio_err;\n\t\t}\n\t}\n\trc = gpio_request(ctrl_pdata->rst_gpio, \"disp_rst_n\");\n\tif (rc) {\n\t\tpr_err(\"request reset gpio failed, rc=%d\\n\",\n\t\t\trc);\n\t\tgoto rst_gpio_err;\n\t}\n\tif (gpio_is_valid(ctrl_pdata->bklt_en_gpio)) {\n\t\trc = gpio_request(ctrl_pdata->bklt_en_gpio,\n\t\t\t\t\t\t\"bklt_enable\");\n\t\tif (rc) {\n\t\t\tpr_err(\"request bklt gpio failed, rc=%d\\n\",\n\t\t\t\t       rc);\n\t\t\tgoto bklt_en_gpio_err;\n\t\t}\n\t}\n\tif (gpio_is_valid(ctrl_pdata->mode_gpio)) {\n\t\trc = gpio_request(ctrl_pdata->mode_gpio, \"panel_mode\");\n\t\tif (rc) {\n\t\t\tpr_err(\"request panel mode gpio failed,rc=%d\\n\",\n\t\t\t\t\t\t\t\trc);\n\t\t\tgoto mode_gpio_err;\n\t\t}\n\t}\n\treturn rc;\n\nmode_gpio_err:\n\tif (gpio_is_valid(ctrl_pdata->bklt_en_gpio))\n\t\tgpio_free(ctrl_pdata->bklt_en_gpio);\nbklt_en_gpio_err:\n\tgpio_free(ctrl_pdata->rst_gpio);\nrst_gpio_err:\n\tif (gpio_is_valid(ctrl_pdata->disp_en_gpio))\n\t\tgpio_free(ctrl_pdata->disp_en_gpio);\ndisp_en_gpio_err:\n\treturn rc;\n}", "llvm": null, "hash": "cd9a1698605ba70168f1d810b17276f9b080cde1a6b53d6114c763571473e0ca", "memory": 1193}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_roi_merge", "code": "\nstatic int mdss_dsi_roi_merge(struct mdss_dsi_ctrl_pdata *ctrl,\n\t\t\t\t\tstruct mdss_rect *roi)\n{\n\tstruct mdss_panel_info *l_pinfo;\n\tstruct mdss_rect *l_roi;\n\tstruct mdss_rect *r_roi;\n\tstruct mdss_dsi_ctrl_pdata *other = NULL;\n\tint ans = 0;\n\n\tif (ctrl->ndx == DSI_CTRL_LEFT) {\n\t\tother = mdss_dsi_get_ctrl_by_index(DSI_CTRL_RIGHT);\n\t\tif (!other)\n\t\t\treturn ans;\n\t\tl_pinfo = &(ctrl->panel_data.panel_info);\n\t\tl_roi = &(ctrl->panel_data.panel_info.roi);\n\t\tr_roi = &(other->panel_data.panel_info.roi);\n\t} else  {\n\t\tother = mdss_dsi_get_ctrl_by_index(DSI_CTRL_LEFT);\n\t\tif (!other)\n\t\t\treturn ans;\n\t\tl_pinfo = &(other->panel_data.panel_info);\n\t\tl_roi = &(other->panel_data.panel_info.roi);\n\t\tr_roi = &(ctrl->panel_data.panel_info.roi);\n\t}\n\n\tif (l_roi->w == 0 && l_roi->h == 0) {\n\t\t/* right only */\n\t\t*roi = *r_roi;\n\t\troi->x += l_pinfo->xres;/* add left full width to x-offset */\n\t} else {\n\t\t/* left only and left+righ */\n\t\t*roi = *l_roi;\n\t\troi->w +=  r_roi->w; /* add right width */\n\t\tans = 1;\n\t}\n\n\treturn ans;\n}", "llvm": null, "hash": "9019af282ee0f51063a9ecb94043b78a692fbc69d8f470cba163351da589c348", "memory": 1001}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_send_col_page_addr", "code": "\nstatic void mdss_dsi_send_col_page_addr(struct mdss_dsi_ctrl_pdata *ctrl,\n\t\t\t\tstruct mdss_rect *roi, int unicast)\n{\n\tstruct dcs_cmd_req cmdreq;\n\n\tcaset[1] = (((roi->x) & 0xFF00) >> 8);\n\tcaset[2] = (((roi->x) & 0xFF));\n\tcaset[3] = (((roi->x - 1 + roi->w) & 0xFF00) >> 8);\n\tcaset[4] = (((roi->x - 1 + roi->w) & 0xFF));\n\tset_col_page_addr_cmd[0].payload = caset;\n\n\tpaset[1] = (((roi->y) & 0xFF00) >> 8);\n\tpaset[2] = (((roi->y) & 0xFF));\n\tpaset[3] = (((roi->y - 1 + roi->h) & 0xFF00) >> 8);\n\tpaset[4] = (((roi->y - 1 + roi->h) & 0xFF));\n\tset_col_page_addr_cmd[1].payload = paset;\n\n\tmemset(&cmdreq, 0, sizeof(cmdreq));\n\tcmdreq.cmds_cnt = 2;\n\tcmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;\n\tif (unicast)\n\t\tcmdreq.flags |= CMD_REQ_UNICAST;\n\tcmdreq.rlen = 0;\n\tcmdreq.cb = NULL;\n\n\tcmdreq.cmds = set_col_page_addr_cmd;\n\tmdss_dsi_cmdlist_put(ctrl, &cmdreq);\n\n#ifdef CONFIG_LGE_PARTIAL_UPDATE\n\tpr_debug(\"%s: [ %d %d %d %d ]\\n\", __func__,\n\t\t\troi->x, roi->y, roi->w, roi->h);\n#endif\n}", "llvm": null, "hash": "a420c1ba7e146290434f671babc2842420cdcd84c1d5e9c83ac9f4699817143b", "memory": 970}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_set_col_page_addr", "code": "\nstatic int mdss_dsi_set_col_page_addr(struct mdss_panel_data *pdata,\n\t\tbool force_send)\n{\n\tstruct mdss_panel_info *pinfo;\n\tstruct mdss_rect roi = {0};\n\tstruct mdss_rect *p_roi;\n\tstruct mdss_rect *c_roi;\n\tstruct mdss_dsi_ctrl_pdata *ctrl = NULL;\n\tstruct mdss_dsi_ctrl_pdata *other = NULL;\n\tint left_or_both = 0;\n\n\tif (pdata == NULL) {\n\t\tpr_err(\"%s: Invalid input data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,\n\t\t\t\tpanel_data);\n\n\tpinfo = &pdata->panel_info;\n\tp_roi = &pinfo->roi;\n\n\t/*\n\t * to avoid keep sending same col_page info to panel,\n\t * if roi_merge enabled, the roi of left ctrl is used\n\t * to compare against new merged roi and saved new\n\t * merged roi to it after comparing.\n\t * if roi_merge disabled, then the calling ctrl's roi\n\t * and pinfo's roi are used to compare.\n\t */\n\tif (pinfo->partial_update_roi_merge) {\n\t\tleft_or_both = mdss_dsi_roi_merge(ctrl, &roi);\n\t\tother = mdss_dsi_get_ctrl_by_index(DSI_CTRL_LEFT);\n\t\tc_roi = &other->roi;\n\t} else {\n\t\tc_roi = &ctrl->roi;\n\t\troi = *p_roi;\n\t}\n\n\t/* roi had changed, do col_page update */\n\tif (force_send || !mdss_rect_cmp(c_roi, &roi)) {\n\t\tpr_debug(\"%s: ndx=%d x=%d y=%d w=%d h=%d\\n\",\n\t\t\t\t__func__, ctrl->ndx, p_roi->x,\n\t\t\t\tp_roi->y, p_roi->w, p_roi->h);\n\n\t\t*c_roi = roi; /* keep to ctrl */\n\t\tif (c_roi->w == 0 || c_roi->h == 0) {\n\t\t\t/* no new frame update */\n\t\t\tpr_debug(\"%s: ctrl=%d, no partial roi set\\n\",\n\t\t\t\t\t\t__func__, ctrl->ndx);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (pinfo->dcs_cmd_by_left) {\n\t\t\tif (left_or_both && ctrl->ndx == DSI_CTRL_RIGHT) {\n\t\t\t\t/* 2A/2B sent by left already */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!mdss_dsi_sync_wait_enable(ctrl)) {\n\t\t\tif (pinfo->dcs_cmd_by_left)\n\t\t\t\tctrl = mdss_dsi_get_ctrl_by_index(\n\t\t\t\t\t\t\tDSI_CTRL_LEFT);\n\t\t\tmdss_dsi_send_col_page_addr(ctrl, &roi, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * when sync_wait_broadcast enabled,\n\t\t\t * need trigger at right ctrl to\n\t\t\t * start both dcs cmd transmission\n\t\t\t */\n\t\t\tother = mdss_dsi_get_other_ctrl(ctrl);\n\t\t\tif (!other)\n\t\t\t\tgoto end;\n\n\t\t\tif (mdss_dsi_is_left_ctrl(ctrl)) {\n\t\t\t\tif (pinfo->partial_update_roi_merge) {\n\t\t\t\t\t/*\n\t\t\t\t\t * roi is the one after merged\n\t\t\t\t\t * to dsi-1 only\n\t\t\t\t\t */\n\t\t\t\t\tmdss_dsi_send_col_page_addr(other,\n\t\t\t\t\t\t\t&roi, 0);\n\t\t\t\t} else {\n\t\t\t\t\tmdss_dsi_send_col_page_addr(ctrl,\n\t\t\t\t\t\t\t&ctrl->roi, 1);\n\t\t\t\t\tmdss_dsi_send_col_page_addr(other,\n\t\t\t\t\t\t\t&other->roi, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pinfo->partial_update_roi_merge) {\n\t\t\t\t\t/*\n\t\t\t\t\t * roi is the one after merged\n\t\t\t\t\t * to dsi-1 only\n\t\t\t\t\t */\n\t\t\t\t\tmdss_dsi_send_col_page_addr(ctrl,\n\t\t\t\t\t\t\t&roi, 0);\n\t\t\t\t} else {\n\t\t\t\t\tmdss_dsi_send_col_page_addr(other,\n\t\t\t\t\t\t\t&other->roi, 1);\n\t\t\t\t\tmdss_dsi_send_col_page_addr(ctrl,\n\t\t\t\t\t\t\t&ctrl->roi, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\treturn 0;\n}", "llvm": null, "hash": "3d899a15f0ed2a96c9ca8490c89a1a3d3ae92c378de714e0c90c15f9e25788c6", "memory": 2721}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_switch_mode", "code": "\nstatic void mdss_dsi_panel_switch_mode(struct mdss_panel_data *pdata,\n\t\t\t\t\t\t\tint mode)\n{\n\tstruct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;\n\tstruct mipi_panel_info *mipi;\n\tstruct dsi_panel_cmds *pcmds;\n\tu32 flags = 0;\n\n\tif (pdata == NULL) {\n\t\tpr_err(\"%s: Invalid input data\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmipi  = &pdata->panel_info.mipi;\n\n\tif (!mipi->dms_mode)\n\t\treturn;\n\n\tctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,\n\t\t\t\tpanel_data);\n\n\tif (mipi->dms_mode != DYNAMIC_MODE_RESOLUTION_SWITCH_IMMEDIATE) {\n\t\tif (mode == SWITCH_TO_CMD_MODE)\n\t\t\tpcmds = &ctrl_pdata->video2cmd;\n\t\telse\n\t\t\tpcmds = &ctrl_pdata->cmd2video;\n\t} else if ((mipi->dms_mode ==\n\t\t\t\tDYNAMIC_MODE_RESOLUTION_SWITCH_IMMEDIATE)\n\t\t\t&& pdata->current_timing\n\t\t\t&& !list_empty(&pdata->timings_list)) {\n\t\tstruct dsi_panel_timing *pt;\n\n\t\tpt = container_of(pdata->current_timing,\n\t\t\t\tstruct dsi_panel_timing, timing);\n\n\t\tpr_debug(\"%s: sending switch commands\\n\", __func__);\n\t\tpcmds = &pt->switch_cmds;\n\t\tflags |= CMD_REQ_DMA_TPG;\n\t} else {\n\t\tpr_warn(\"%s: Invalid mode switch attempted\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmdss_dsi_panel_cmds_send(ctrl_pdata, pcmds);\n}", "llvm": null, "hash": "b6e0b1126bc1b6219eb0c6d22661f9cee021b258e1124437554bd528c6be49f8", "memory": 1131}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_on", "code": "\nstatic int mdss_dsi_panel_on(struct mdss_panel_data *pdata)\n{\n\tstruct mdss_dsi_ctrl_pdata *ctrl = NULL;\n\tstruct mdss_panel_info *pinfo;\n\tstruct dsi_panel_cmds *on_cmds;\n\tstruct dsi_panel_cmds *rsp_nvm_write;\n\n\tif (pdata == NULL) {\n\t\tpr_err(\"%s: Invalid input data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_POWERSUSPEND\n\tset_power_suspend_state_panel_hook(POWER_SUSPEND_INACTIVE);\n#endif\n\n\tpinfo = &pdata->panel_info;\n\tctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,\n\t\t\t\tpanel_data);\n\n\tpr_info(\"%s:+ ctrl=%p ndx=%d\\n\", __func__, ctrl, ctrl->ndx);\n\n\tif (pinfo->dcs_cmd_by_left) {\n\t\tif (ctrl->ndx != DSI_CTRL_LEFT)\n\t\t\tgoto end;\n\t}\n\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_EXTENDED_PANEL)\n\tif (pinfo->lge_pan_info.lge_panel_send_on_cmd == false) {\n\t\tpr_info(\"%s: skip panel  on cmd, ctrl=%p ndx=%d\\n\", __func__, ctrl, ctrl->ndx);\n\t\tgoto end;\n\t}\n#endif\n\n#if defined(CONFIG_LGE_MIPI_P1_INCELL_QHD_CMD_PANEL)\n\tif (pinfo->lge_pan_info.panel_type == LGD_INCELL_CMD_PANEL) {\n\t\trsp_nvm_write = &ctrl->lge_pan_data->rsp_nvm_write;\n\n\t\tif ((rsp_nvm_write->cmd_cnt) && (ctrl->lge_pan_data->do_rsp_nvm_write == true)) {\n\t\t\tmdss_dsi_panel_cmds_send(ctrl, rsp_nvm_write);\n\t\t\tmdelay(1000);\n\t\t\tctrl->lge_pan_data->do_rsp_nvm_write = false;\n\t\t}\n\t}\n#endif\n\n\ton_cmds = &ctrl->on_cmds;\n\n\tif ((pinfo->mipi.dms_mode == DYNAMIC_MODE_SWITCH_IMMEDIATE) &&\n\t\t\t(pinfo->mipi.boot_mode != pinfo->mipi.mode))\n\t\ton_cmds = &ctrl->post_dms_on_cmds;\n\n\tif (on_cmds->cmd_cnt)\n\t\tmdss_dsi_panel_cmds_send(ctrl, on_cmds);\n\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_POWER_SEQUENCE)\n\tif (lge_mdss_dsi.post_mdss_dsi_panel_on)\n\t\tlge_mdss_dsi.post_mdss_dsi_panel_on(pdata);\n#endif\nend:\n\tpinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;\n\tpr_info(\"%s:-\\n\", __func__);\n\treturn 0;\n}", "llvm": null, "hash": "608fc0b11be81d857096e99595828eaa60cda1666c58d56ad5eef32eeaa94982", "memory": 1731}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_off", "code": "\nstatic int mdss_dsi_panel_off(struct mdss_panel_data *pdata)\n{\n\tstruct mdss_dsi_ctrl_pdata *ctrl = NULL;\n\tstruct mdss_panel_info *pinfo;\n\n\tif (pdata == NULL) {\n\t\tpr_err(\"%s: Invalid input data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpinfo = &pdata->panel_info;\n\tctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,\n\t\t\t\tpanel_data);\n\n\tpr_info(\"%s:+ ctrl=%p ndx=%d\\n\", __func__, ctrl, ctrl->ndx);\n\n\tif (pinfo->dcs_cmd_by_left) {\n\t\tif (ctrl->ndx != DSI_CTRL_LEFT)\n\t\t\tgoto end;\n\t}\n\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_EXTENDED_PANEL)\n\tif (pinfo->lge_pan_info.lge_panel_send_off_cmd == false) {\n\t\tpr_info(\"%s: skip panel off cmd, ctrl=%p ndx=%d\\n\", __func__, ctrl, ctrl->ndx);\n\t\tgoto end;\n\t}\n#endif\n\n\tif (ctrl->off_cmds.cmd_cnt)\n\t\tmdss_dsi_panel_cmds_send(ctrl, &ctrl->off_cmds);\n\t\t\n#ifdef CONFIG_POWERSUSPEND\n\tset_power_suspend_state_panel_hook(POWER_SUSPEND_ACTIVE);\n#endif\n\n\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_POWER_SEQUENCE)\n\tif (lge_mdss_dsi.post_mdss_dsi_panel_off)\n\t\tlge_mdss_dsi.post_mdss_dsi_panel_off(pdata);\n#endif\n\nend:\n\tpinfo->blank_state = MDSS_PANEL_BLANK_BLANK;\n\tpr_info(\"%s:-\\n\", __func__);\n\treturn 0;\n}", "llvm": null, "hash": "efd367ce892d06bdf970d2de3b5dd8862dc8de9330b4706bed7577377f8bbae8", "memory": 1113}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_low_power_config", "code": "\nstatic int mdss_dsi_panel_low_power_config(struct mdss_panel_data *pdata,\n\tint enable)\n{\n\tstruct mdss_dsi_ctrl_pdata *ctrl = NULL;\n\tstruct mdss_panel_info *pinfo;\n\n\tif (pdata == NULL) {\n\t\tpr_err(\"%s: Invalid input data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpinfo = &pdata->panel_info;\n\tctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,\n\t\t\t\tpanel_data);\n\n\tpr_info(\"%s: ctrl=%p ndx=%d enable=%d\\n\", __func__, ctrl, ctrl->ndx,\n\t\tenable);\n\n\t/* Any panel specific low power commands/config */\n\tif (enable)\n\t\tpinfo->blank_state = MDSS_PANEL_BLANK_LOW_POWER;\n\telse\n\t\tpinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;\n\n\tpr_info(\"%s:-\\n\", __func__);\n\treturn 0;\n}", "llvm": null, "hash": "cca3dc5639cf8b265b52cd01d934147d87b11812c366e8df141f15121d0a0d1f", "memory": 656}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_lane_swap", "code": "\nstatic void mdss_dsi_parse_lane_swap(struct device_node *np, char *dlane_swap)\n{\n\tconst char *data;\n\n\t*dlane_swap = DSI_LANE_MAP_0123;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-lane-map\", NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"lane_map_3012\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_3012;\n\t\telse if (!strcmp(data, \"lane_map_2301\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_2301;\n\t\telse if (!strcmp(data, \"lane_map_1230\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_1230;\n\t\telse if (!strcmp(data, \"lane_map_0321\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_0321;\n\t\telse if (!strcmp(data, \"lane_map_1032\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_1032;\n\t\telse if (!strcmp(data, \"lane_map_2103\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_2103;\n\t\telse if (!strcmp(data, \"lane_map_3210\"))\n\t\t\t*dlane_swap = DSI_LANE_MAP_3210;\n\t}\n}", "llvm": null, "hash": "1bcb302f2a32ae2b98baced0dafe2babcb7100fec5eff59d026f176ab68ee7f9", "memory": 762}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_trigger", "code": "\nstatic void mdss_dsi_parse_trigger(struct device_node *np, char *trigger,\n\t\tchar *trigger_key)\n{\n\tconst char *data;\n\n\t*trigger = DSI_CMD_TRIGGER_SW;\n\tdata = of_get_property(np, trigger_key, NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"none\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_NONE;\n\t\telse if (!strcmp(data, \"trigger_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_TE;\n\t\telse if (!strcmp(data, \"trigger_sw_seof\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_SEOF;\n\t\telse if (!strcmp(data, \"trigger_sw_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_TE;\n\t}\n}", "llvm": null, "hash": "1fc82101c8b66cbc74a2efb4016906825f685b0022e4f6ec4d5c09d2d2c5e94f", "memory": 518}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_dcs_cmds", "code": "\nstatic int mdss_dsi_parse_dcs_cmds(struct device_node *np,\n\t\tstruct dsi_panel_cmds *pcmds, char *cmd_key, char *link_key)\n#endif\n{\n\tconst char *data;\n\tint blen = 0, len;\n\tchar *buf, *bp;\n\tstruct dsi_ctrl_hdr *dchdr;\n\tint i, cnt;\n\n\tdata = of_get_property(np, cmd_key, &blen);\n\tif (!data) {\n\t\tpr_err(\"%s: failed, key=%s\\n\", __func__, cmd_key);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf = kzalloc(sizeof(char) * blen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, blen);\n\n\t/* scan dcs commands */\n\tbp = buf;\n\tlen = blen;\n\tcnt = 0;\n\twhile (len >= sizeof(*dchdr)) {\n\t\tdchdr = (struct dsi_ctrl_hdr *)bp;\n\t\tdchdr->dlen = ntohs(dchdr->dlen);\n\t\tif (dchdr->dlen > len) {\n\t\t\tpr_err(\"%s: dtsi cmd=%x error, len=%d\",\n\t\t\t\t__func__, dchdr->dtype, dchdr->dlen);\n\t\t\tgoto exit_free;\n\t\t}\n\t\tbp += sizeof(*dchdr);\n\t\tlen -= sizeof(*dchdr);\n\t\tbp += dchdr->dlen;\n\t\tlen -= dchdr->dlen;\n\t\tcnt++;\n\t}\n\n\tif (len != 0) {\n\t\tpr_err(\"%s: dcs_cmd=%x len=%d error!\",\n\t\t\t\t__func__, buf[0], blen);\n\t\tgoto exit_free;\n\t}\n\n\tpcmds->cmds = kzalloc(cnt * sizeof(struct dsi_cmd_desc),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!pcmds->cmds)\n\t\tgoto exit_free;\n\n\tpcmds->cmd_cnt = cnt;\n\tpcmds->buf = buf;\n\tpcmds->blen = blen;\n\n\tbp = buf;\n\tlen = blen;\n\tfor (i = 0; i < cnt; i++) {\n\t\tdchdr = (struct dsi_ctrl_hdr *)bp;\n\t\tlen -= sizeof(*dchdr);\n\t\tbp += sizeof(*dchdr);\n\t\tpcmds->cmds[i].dchdr = *dchdr;\n\t\tpcmds->cmds[i].payload = bp;\n\t\tbp += dchdr->dlen;\n\t\tlen -= dchdr->dlen;\n\t}\n\n\t/*Set default link state to LP Mode*/\n\tpcmds->link_state = DSI_LP_MODE;\n\n\tif (link_key) {\n\t\tdata = of_get_property(np, link_key, NULL);\n\t\tif (data && !strcmp(data, \"dsi_hs_mode\"))\n\t\t\tpcmds->link_state = DSI_HS_MODE;\n\t\telse\n\t\t\tpcmds->link_state = DSI_LP_MODE;\n\t}\n\n\tpr_debug(\"%s: dcs_cmd=%x len=%d, cmd_cnt=%d link_state=%d\\n\", __func__,\n\t\tpcmds->buf[0], pcmds->blen, pcmds->cmd_cnt, pcmds->link_state);\n\n\treturn 0;\n\nexit_free:\n\tkfree(buf);\n\treturn -ENOMEM;\n}", "llvm": null, "hash": "64f90ed0da360c6cc5c7437ff51094908930ed0428150585af0d0afbeef92d18", "memory": 1872}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_panel_get_dst_fmt", "code": "\nint mdss_panel_get_dst_fmt(u32 bpp, char mipi_mode, u32 pixel_packing,\n\t\t\t\tchar *dst_format)\n{\n\tint rc = 0;\n\tswitch (bpp) {\n\tcase 3:\n\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB111;\n\t\tbreak;\n\tcase 8:\n\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB332;\n\t\tbreak;\n\tcase 12:\n\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB444;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (mipi_mode) {\n\t\tcase DSI_VIDEO_MODE:\n\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB565;\n\t\t\tbreak;\n\t\tcase DSI_CMD_MODE:\n\t\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB565;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB565;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 18:\n\t\tswitch (mipi_mode) {\n\t\tcase DSI_VIDEO_MODE:\n\t\t\tif (pixel_packing == 0)\n\t\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB666;\n\t\t\telse\n\t\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB666_LOOSE;\n\t\t\tbreak;\n\t\tcase DSI_CMD_MODE:\n\t\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB666;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (pixel_packing == 0)\n\t\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB666;\n\t\t\telse\n\t\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB666_LOOSE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (mipi_mode) {\n\t\tcase DSI_VIDEO_MODE:\n\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB888;\n\t\t\tbreak;\n\t\tcase DSI_CMD_MODE:\n\t\t\t*dst_format = DSI_CMD_DST_FORMAT_RGB888;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*dst_format = DSI_VIDEO_DST_FORMAT_RGB888;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\treturn rc;\n}", "llvm": null, "hash": "ee06d720a1bb6d28d268dbb9d68cc93ff9f3dfdae8200de9aa9a03acb36ddb7b", "memory": 1339}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_fbc_params", "code": "\nstatic int mdss_dsi_parse_fbc_params(struct device_node *np,\n\t\t\t\tstruct fbc_panel_info *fbc)\n{\n\tint rc, fbc_enabled = 0;\n\tu32 tmp;\n\n\tfbc_enabled = of_property_read_bool(np,\t\"qcom,mdss-dsi-fbc-enable\");\n\tif (fbc_enabled) {\n\t\tpr_debug(\"%s:%d FBC panel enabled.\\n\", __func__, __LINE__);\n\t\tfbc->enabled = 1;\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-bpp\", &tmp);\n\t\tfbc->target_bpp =\t(!rc ? tmp : 24);\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-packing\",\n\t\t\t\t&tmp);\n\t\tfbc->comp_mode = (!rc ? tmp : 0);\n\t\tfbc->qerr_enable = of_property_read_bool(np,\n\t\t\t\"qcom,mdss-dsi-fbc-quant-error\");\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-bias\", &tmp);\n\t\tfbc->cd_bias = (!rc ? tmp : 0);\n\t\tfbc->pat_enable = of_property_read_bool(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-pat-mode\");\n\t\tfbc->vlc_enable = of_property_read_bool(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-vlc-mode\");\n\t\tfbc->bflc_enable = of_property_read_bool(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-bflc-mode\");\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-h-line-budget\",\n\t\t\t\t&tmp);\n\t\tfbc->line_x_budget = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-budget-ctrl\",\n\t\t\t\t&tmp);\n\t\tfbc->block_x_budget = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-block-budget\",\n\t\t\t\t&tmp);\n\t\tfbc->block_budget = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-lossless-threshold\", &tmp);\n\t\tfbc->lossless_mode_thd = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-lossy-threshold\", &tmp);\n\t\tfbc->lossy_mode_thd = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np, \"qcom,mdss-dsi-fbc-rgb-threshold\",\n\t\t\t\t&tmp);\n\t\tfbc->lossy_rgb_thd = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-lossy-mode-idx\", &tmp);\n\t\tfbc->lossy_mode_idx = (!rc ? tmp : 0);\n\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-slice-height\", &tmp);\n\t\tfbc->slice_height = (!rc ? tmp : 0);\n\t\tfbc->pred_mode = of_property_read_bool(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-2d-pred-mode\");\n\t\tfbc->enc_mode = of_property_read_bool(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-ver2-mode\");\n\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-fbc-max-pred-err\", &tmp);\n\t\tfbc->max_pred_err = (!rc ? tmp : 0);\n\t} else {\n\t\tpr_debug(\"%s:%d Panel does not support FBC.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tfbc->enabled = 0;\n\t\tfbc->target_bpp = 24;\n\t}\n\treturn 0;\n}", "llvm": null, "hash": "7854d01eb269ff44d6bce28486f620d53a5b5e19ffbf9d281b39c27e67dbe987", "memory": 2320}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_panel_parse_te_params", "code": "\nstatic void mdss_panel_parse_te_params(struct device_node *np,\n\t\t\t\t       struct mdss_panel_timing *timing)\n{\n\tstruct mdss_mdp_pp_tear_check *te = &timing->te;\n\tu32 tmp;\n\tint rc = 0;\n\t/*\n\t * TE default: dsi byte clock calculated base on 70 fps;\n\t * around 14 ms to complete a kickoff cycle if te disabled;\n\t * vclk_line base on 60 fps; write is faster than read;\n\t * init == start == rdptr;\n\t */\n\tte->tear_check_en =\n\t\t!of_property_read_bool(np, \"qcom,mdss-tear-check-disable\");\n\trc = of_property_read_u32\n\t\t(np, \"qcom,mdss-tear-check-sync-cfg-height\", &tmp);\n\tte->sync_cfg_height = (!rc ? tmp : 0xfff0);\n\trc = of_property_read_u32\n\t\t(np, \"qcom,mdss-tear-check-sync-init-val\", &tmp);\n\tte->vsync_init_val = (!rc ? tmp : timing->yres);\n\trc = of_property_read_u32\n\t\t(np, \"qcom,mdss-tear-check-sync-threshold-start\", &tmp);\n\tte->sync_threshold_start = (!rc ? tmp : 4);\n\trc = of_property_read_u32\n\t\t(np, \"qcom,mdss-tear-check-sync-threshold-continue\", &tmp);\n\tte->sync_threshold_continue = (!rc ? tmp : 4);\n\trc = of_property_read_u32(np, \"qcom,mdss-tear-check-start-pos\", &tmp);\n\tte->start_pos = (!rc ? tmp : te->vsync_init_val);\n\trc = of_property_read_u32\n\t\t(np, \"qcom,mdss-tear-check-rd-ptr-trigger-intr\", &tmp);\n\tte->rd_ptr_irq = (!rc ? tmp : te->vsync_init_val + 1);\n\trc = of_property_read_u32(np, \"qcom,mdss-tear-check-frame-rate\", &tmp);\n\tte->refx100 = (!rc ? tmp : 6000);\n}", "llvm": null, "hash": "183654e9cc5d19e61492f88d0f33cf3a4ad26aae42bfb6426e380819869814cb", "memory": 1376}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_reset_seq", "code": "\nstatic int mdss_dsi_parse_reset_seq(struct device_node *np,\n\t\tu32 rst_seq[MDSS_DSI_RST_SEQ_LEN], u32 *rst_len,\n\t\tconst char *name)\n{\n\tint num = 0, i;\n\tint rc;\n\tstruct property *data;\n\tu32 tmp[MDSS_DSI_RST_SEQ_LEN];\n\t*rst_len = 0;\n\tdata = of_find_property(np, name, &num);\n\tnum /= sizeof(u32);\n\tif (!data || !num || num > MDSS_DSI_RST_SEQ_LEN || num % 2) {\n\t\tpr_debug(\"%s:%d, error reading %s, length found = %d\\n\",\n\t\t\t__func__, __LINE__, name, num);\n\t} else {\n\t\trc = of_property_read_u32_array(np, name, tmp, num);\n\t\tif (rc)\n\t\t\tpr_debug(\"%s:%d, error reading %s, rc = %d\\n\",\n\t\t\t\t__func__, __LINE__, name, rc);\n\t\telse {\n\t\t\tfor (i = 0; i < num; ++i)\n\t\t\t\trst_seq[i] = tmp[i];\n\t\t\t*rst_len = num;\n\t\t}\n\t}\n\treturn 0;\n}", "llvm": null, "hash": "d590dd74345d380a780acf70c4c571af90544d896d4e518a58516c405240181f", "memory": 712}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_gen_read_status", "code": "\nstatic int mdss_dsi_gen_read_status(struct mdss_dsi_ctrl_pdata *ctrl_pdata)\n{\n\tif (!mdss_dsi_cmp_panel_reg(ctrl_pdata->status_buf,\n\t\tctrl_pdata->status_value, 0)) {\n\t\tpr_err(\"%s: Read back value from panel is incorrect\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t} else {\n\t\treturn 1;\n\t}\n}", "llvm": null, "hash": "f92e85bf93dea1300daf60c5472ba57bec39a23be275a8611ee6787f7bdba436", "memory": 286}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_nt35596_read_status", "code": "\nstatic int mdss_dsi_nt35596_read_status(struct mdss_dsi_ctrl_pdata *ctrl_pdata)\n{\n\tif (!mdss_dsi_cmp_panel_reg(ctrl_pdata->status_buf,\n\t\tctrl_pdata->status_value, 0)) {\n\t\tctrl_pdata->status_error_count = 0;\n\t\tpr_err(\"%s: Read back value from panel is incorrect\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t} else {\n\t\tif (!mdss_dsi_cmp_panel_reg(ctrl_pdata->status_buf,\n\t\t\tctrl_pdata->status_value, 3)) {\n\t\t\tctrl_pdata->status_error_count = 0;\n\t\t} else {\n\t\t\tif (mdss_dsi_cmp_panel_reg(ctrl_pdata->status_buf,\n\t\t\t\tctrl_pdata->status_value, 4) ||\n\t\t\t\tmdss_dsi_cmp_panel_reg(ctrl_pdata->status_buf,\n\t\t\t\tctrl_pdata->status_value, 5))\n\t\t\t\tctrl_pdata->status_error_count = 0;\n\t\t\telse\n\t\t\t\tctrl_pdata->status_error_count++;\n\t\t\tif (ctrl_pdata->status_error_count >=\n\t\t\t\t\tctrl_pdata->max_status_error_count) {\n\t\t\t\tctrl_pdata->status_error_count = 0;\n\t\t\t\tpr_err(\"%s: Read value bad. Error_cnt = %i\\n\",\n\t\t\t\t\t __func__,\n\t\t\t\t\tctrl_pdata->status_error_count);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n}", "llvm": null, "hash": "4429130afb1c9d61f73f25700afa1acf24e435f3f0effaf8269c26b96ee58f0c", "memory": 986}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_roi_alignment", "code": "\nstatic void mdss_dsi_parse_roi_alignment(struct device_node *np,\n\t\tstruct mdss_panel_info *pinfo)\n{\n\tint len = 0;\n\tu32 value[6];\n\tstruct property *data;\n\tdata = of_find_property(np, \"qcom,panel-roi-alignment\", &len);\n\tlen /= sizeof(u32);\n\tif (!data || (len != 6)) {\n\t\tpr_debug(\"%s: Panel roi alignment not found\", __func__);\n\t} else {\n\t\tint rc = of_property_read_u32_array(np,\n\t\t\t\t\"qcom,panel-roi-alignment\", value, len);\n\t\tif (rc)\n\t\t\tpr_debug(\"%s: Error reading panel roi alignment values\",\n\t\t\t\t\t__func__);\n\t\telse {\n\t\t\tpinfo->xstart_pix_align = value[0];\n\t\t\tpinfo->width_pix_align = value[1];\n\t\t\tpinfo->ystart_pix_align = value[2];\n\t\t\tpinfo->height_pix_align = value[3];\n\t\t\tpinfo->min_width = value[4];\n\t\t\tpinfo->min_height = value[5];\n\t\t}\n\n\t\tpr_debug(\"%s: ROI alignment: [%d, %d, %d, %d, %d, %d]\",\n\t\t\t\t__func__, pinfo->xstart_pix_align,\n\t\t\t\tpinfo->width_pix_align, pinfo->ystart_pix_align,\n\t\t\t\tpinfo->height_pix_align, pinfo->min_width,\n\t\t\t\tpinfo->min_height);\n\t}\n}", "llvm": null, "hash": "968673d6a0f0744dba2c2c59c8257d98e35bb11615a2e10244584ef2f22fb040", "memory": 968}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_dms_config", "code": "\nstatic void mdss_dsi_parse_dms_config(struct device_node *np,\n\tstruct mdss_dsi_ctrl_pdata *ctrl)\n{\n\tstruct mdss_panel_info *pinfo = &ctrl->panel_data.panel_info;\n\tconst char *data;\n\tbool dms_enabled;\n\n\tdms_enabled = of_property_read_bool(np,\n\t\t\"qcom,dynamic-mode-switch-enabled\");\n\n\tif (!dms_enabled) {\n\t\tpinfo->mipi.dms_mode = DYNAMIC_MODE_SWITCH_DISABLED;\n\t\tgoto exit;\n\t}\n\n\t/* default mode is suspend_resume */\n\tpinfo->mipi.dms_mode = DYNAMIC_MODE_SWITCH_SUSPEND_RESUME;\n\tdata = of_get_property(np, \"qcom,dynamic-mode-switch-type\", NULL);\n\tif (data && !strcmp(data, \"dynamic-resolution-switch-immediate\")) {\n\t\tif (!list_empty(&ctrl->panel_data.timings_list))\n\t\t\tpinfo->mipi.dms_mode =\n\t\t\t\tDYNAMIC_MODE_RESOLUTION_SWITCH_IMMEDIATE;\n\t\telse\n\t\t\tpinfo->mipi.dms_mode =\n\t\t\t\tDYNAMIC_MODE_SWITCH_DISABLED;\n\n\t\tgoto exit;\n\t}\n\n\tif (data && !strcmp(data, \"dynamic-switch-immediate\"))\n\t\tpinfo->mipi.dms_mode = DYNAMIC_MODE_SWITCH_IMMEDIATE;\n\telse\n\t\tpr_debug(\"%s: default dms suspend/resume\\n\", __func__);\n\n\tmdss_dsi_parse_dcs_cmds(np, &ctrl->video2cmd,\n\t\t\"qcom,video-to-cmd-mode-switch-commands\", NULL);\n\n\tmdss_dsi_parse_dcs_cmds(np, &ctrl->cmd2video,\n\t\t\"qcom,cmd-to-video-mode-switch-commands\", NULL);\n\n\tmdss_dsi_parse_dcs_cmds(np, &ctrl->post_dms_on_cmds,\n\t\t\"qcom,mdss-dsi-post-mode-switch-on-command\",\n\t\t\"qcom,mdss-dsi-post-mode-switch-on-command-state\");\n\n\tif (pinfo->mipi.dms_mode == DYNAMIC_MODE_SWITCH_IMMEDIATE &&\n\t\t!ctrl->post_dms_on_cmds.cmd_cnt) {\n\t\tpr_warn(\"%s: No post dms on cmd specified\\n\", __func__);\n\t\tpinfo->mipi.dms_mode = DYNAMIC_MODE_SWITCH_DISABLED;\n\t}\n\n\tif (!ctrl->video2cmd.cmd_cnt || !ctrl->cmd2video.cmd_cnt) {\n\t\tpr_warn(\"%s: No commands specified for dynamic switch\\n\",\n\t\t\t__func__);\n\t\tpinfo->mipi.dms_mode = DYNAMIC_MODE_SWITCH_DISABLED;\n\t}\nexit:\n\tpr_info(\"%s: dynamic switch feature enabled: %d\\n\", __func__,\n\t\tpinfo->mipi.dms_mode);\n\treturn;\n}", "llvm": null, "hash": "5eef77c4f5dce310382a467c579656c8799a1d9be4deb787889ed4664223bf40", "memory": 1864}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_esd_params", "code": "\nstatic void mdss_dsi_parse_esd_params(struct device_node *np,\n\tstruct mdss_dsi_ctrl_pdata *ctrl)\n{\n\tu32 tmp;\n\tint rc;\n\tstruct property *data;\n\tconst char *string;\n\tstruct mdss_panel_info *pinfo = &ctrl->panel_data.panel_info;\n\n\tpinfo->esd_check_enabled = of_property_read_bool(np,\n\t\t\"qcom,esd-check-enabled\");\n\n\tif (!pinfo->esd_check_enabled)\n\t\treturn;\n\n\tmdss_dsi_parse_dcs_cmds(np, &ctrl->status_cmds,\n\t\t\t\"qcom,mdss-dsi-panel-status-command\",\n\t\t\t\t\"qcom,mdss-dsi-panel-status-command-state\");\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-status-read-length\",\n\t\t&tmp);\n\tctrl->status_cmds_rlen = (!rc ? tmp : 1);\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-max-error-count\",\n\t\t&tmp);\n\tctrl->max_status_error_count = (!rc ? tmp : 0);\n\n\tctrl->status_value = kzalloc(sizeof(u32) * ctrl->status_cmds_rlen,\n\t\t\t\tGFP_KERNEL);\n\tif (!ctrl->status_value) {\n\t\tpr_err(\"%s: Error allocating memory for status buffer\\n\",\n\t\t\t__func__);\n\t\tpinfo->esd_check_enabled = false;\n\t\treturn;\n\t}\n\n\tdata = of_find_property(np, \"qcom,mdss-dsi-panel-status-value\", &tmp);\n\ttmp /= sizeof(u32);\n\tif (!data || (tmp != ctrl->status_cmds_rlen)) {\n\t\tpr_debug(\"%s: Panel status values not found\\n\", __func__);\n\t\tmemset(ctrl->status_value, 0, ctrl->status_cmds_rlen);\n\t} else {\n\t\trc = of_property_read_u32_array(np,\n\t\t\t\"qcom,mdss-dsi-panel-status-value\",\n\t\t\tctrl->status_value, tmp);\n\t\tif (rc) {\n\t\t\tpr_debug(\"%s: Error reading panel status values\\n\",\n\t\t\t\t\t__func__);\n\t\t\tmemset(ctrl->status_value, 0, ctrl->status_cmds_rlen);\n\t\t}\n\t}\n\n\tctrl->status_mode = ESD_MAX;\n\trc = of_property_read_string(np,\n\t\t\t\"qcom,mdss-dsi-panel-status-check-mode\", &string);\n\tif (!rc) {\n\t\tif (!strcmp(string, \"bta_check\")) {\n\t\t\tctrl->status_mode = ESD_BTA;\n\t\t} else if (!strcmp(string, \"reg_read\")) {\n\t\t\tctrl->status_mode = ESD_REG;\n\t\t\tctrl->check_read_status =\n\t\t\t\tmdss_dsi_gen_read_status;\n\t\t} else if (!strcmp(string, \"reg_read_nt35596\")) {\n\t\t\tctrl->status_mode = ESD_REG_NT35596;\n\t\t\tctrl->status_error_count = 0;\n\t\t\tctrl->check_read_status =\n\t\t\t\tmdss_dsi_nt35596_read_status;\n\t\t} else if (!strcmp(string, \"te_signal_check\")) {\n\t\t\tif (pinfo->mipi.mode == DSI_CMD_MODE) {\n\t\t\t\tctrl->status_mode = ESD_TE;\n\t\t\t} else {\n\t\t\t\tpr_err(\"TE-ESD not valid for video mode\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"No valid panel-status-check-mode string\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\n\nerror:\n\tkfree(ctrl->status_value);\n\tpinfo->esd_check_enabled = false;\n}", "llvm": null, "hash": "f135c4d25187d92c5a1248007a5f20bf758b1d64c1f2fabb2e936f4cdfff3512", "memory": 2413}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_panel_features", "code": "\nstatic int mdss_dsi_parse_panel_features(struct device_node *np,\n\tstruct mdss_dsi_ctrl_pdata *ctrl)\n{\n\tstruct mdss_panel_info *pinfo;\n\n\tif (!np || !ctrl) {\n\t\tpr_err(\"%s: Invalid arguments\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpinfo = &ctrl->panel_data.panel_info;\n\n\tpinfo->cont_splash_enabled = of_property_read_bool(np,\n\t\t\"qcom,cont-splash-enabled\");\n\n\tpinfo->partial_update_supported = of_property_read_bool(np,\n\t\t\"qcom,partial-update-enabled\");\n\tif (pinfo->mipi.mode == DSI_CMD_MODE) {\n\t\tpinfo->partial_update_enabled = pinfo->partial_update_supported;\n#if !defined(CONFIG_LGE_PARTIAL_UPDATE)\n\t\tpinfo->partial_update_enabled = 0;\n#endif\n\t\tpr_info(\"%s: partial_update_enabled=%d\\n\", __func__,\n\t\t\t\t\tpinfo->partial_update_enabled);\n\t\tctrl->set_col_page_addr = mdss_dsi_set_col_page_addr;\n\t\tif (pinfo->partial_update_enabled) {\n\t\t\tpinfo->partial_update_roi_merge =\n\t\t\t\t\tof_property_read_bool(np,\n\t\t\t\t\t\"qcom,partial-update-roi-merge\");\n\t\t}\n\n\t\tpinfo->dcs_cmd_by_left = of_property_read_bool(np,\n\t\t\t\t\t\t\"qcom,dcs-cmd-by-left\");\n\t}\n\n\tpinfo->ulps_feature_enabled = of_property_read_bool(np,\n\t\t\"qcom,ulps-enabled\");\n\tpr_info(\"%s: ulps feature %s\\n\", __func__,\n\t\t(pinfo->ulps_feature_enabled ? \"enabled\" : \"disabled\"));\n\n\tpinfo->ulps_suspend_enabled = of_property_read_bool(np,\n\t\t\"qcom,suspend-ulps-enabled\");\n\tpr_info(\"%s: ulps during suspend feature %s\", __func__,\n\t\t(pinfo->ulps_suspend_enabled ? \"enabled\" : \"disabled\"));\n\n#if defined(CONFIG_LGE_MIPI_P1_INCELL_QHD_CMD_PANEL)\n\tif(lge_get_panel() == JDI_INCELL_CMD_PANEL) {\n\t\tif (lge_get_boot_mode() == LGE_BOOT_MODE_CHARGERLOGO) {\n\t\t\tpinfo->ulps_suspend_enabled = true;\n\t\t\tpr_info(\"%s:enter chargerlogo, ulps during suspend feature %s\\n\", __func__, \"enabled\");\n\t\t}\n\t}\n#endif\n\n\tmdss_dsi_parse_dms_config(np, ctrl);\n\n\tpinfo->panel_ack_disabled = of_property_read_bool(np,\n\t\t\t\t\"qcom,panel-ack-disabled\");\n\n\tmdss_dsi_parse_esd_params(np, ctrl);\n\n\tif (pinfo->panel_ack_disabled && pinfo->esd_check_enabled) {\n\t\tpr_warn(\"ESD should not be enabled if panel ACK is disabled\\n\");\n\t\tpinfo->esd_check_enabled = false;\n\t}\n\n\tif (ctrl->disp_en_gpio <= 0) {\n\t\tctrl->disp_en_gpio = of_get_named_gpio(\n\t\t\tnp,\n\t\t\t\"qcom,5v-boost-gpio\", 0);\n\n\t\tif (!gpio_is_valid(ctrl->disp_en_gpio))\n\t\t\tpr_err(\"%s:%d, Disp_en gpio not specified\\n\",\n\t\t\t\t\t__func__, __LINE__);\n\t}\n\n\treturn 0;\n}", "llvm": null, "hash": "beb55e0bb8c55cda0c2c8403e7224915e2ac9f8e956118eba59ef1c06466b8db", "memory": 2301}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_panel_horizintal_line_idle", "code": "\nstatic void mdss_dsi_parse_panel_horizintal_line_idle(struct device_node *np,\n\tstruct mdss_dsi_ctrl_pdata *ctrl)\n{\n\tconst u32 *src;\n\tint i, len, cnt;\n\tstruct panel_horizontal_idle *kp;\n\n\tif (!np || !ctrl) {\n\t\tpr_err(\"%s: Invalid arguments\\n\", __func__);\n\t\treturn;\n\t}\n\n\tsrc = of_get_property(np, \"qcom,mdss-dsi-hor-line-idle\", &len);\n\tif (!src || len == 0)\n\t\treturn;\n\n\tcnt = len % 3; /* 3 fields per entry */\n\tif (cnt) {\n\t\tpr_err(\"%s: invalid horizontal idle len=%d\\n\", __func__, len);\n\t\treturn;\n\t}\n\n\tcnt = len / sizeof(u32);\n\n\tkp = kzalloc(sizeof(*kp) * (cnt / 3), GFP_KERNEL);\n\tif (kp == NULL) {\n\t\tpr_err(\"%s: No memory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tctrl->line_idle = kp;\n\tfor (i = 0; i < cnt; i += 3) {\n\t\tkp->min = be32_to_cpu(src[i]);\n\t\tkp->max = be32_to_cpu(src[i+1]);\n\t\tkp->idle = be32_to_cpu(src[i+2]);\n\t\tkp++;\n\t\tctrl->horizontal_idle_cnt++;\n\t}\n\n\tpr_debug(\"%s: horizontal_idle_cnt=%d\\n\", __func__,\n\t\t\t\tctrl->horizontal_idle_cnt);\n}", "llvm": null, "hash": "8e893da8fd3253c8f0e631138c66c29f5d412c3c2d7f289e8eb5ff456fae0034", "memory": 938}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_set_refresh_rate_range", "code": "\nstatic int mdss_dsi_set_refresh_rate_range(struct device_node *pan_node,\n\t\tstruct mdss_panel_info *pinfo)\n{\n\tint rc = 0;\n\trc = of_property_read_u32(pan_node,\n\t\t\t\"qcom,mdss-dsi-min-refresh-rate\",\n\t\t\t&pinfo->min_fps);\n\tif (rc) {\n\t\tpr_warn(\"%s:%d, Unable to read min refresh rate\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t/*\n\t\t * Since min refresh rate is not specified when dynamic\n\t\t * fps is enabled, using minimum as 30\n\t\t */\n\t\tpinfo->min_fps = MIN_REFRESH_RATE;\n\t\trc = 0;\n\t}\n\n\trc = of_property_read_u32(pan_node,\n\t\t\t\"qcom,mdss-dsi-max-refresh-rate\",\n\t\t\t&pinfo->max_fps);\n\tif (rc) {\n\t\tpr_warn(\"%s:%d, Unable to read max refresh rate\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t/*\n\t\t * Since max refresh rate was not specified when dynamic\n\t\t * fps is enabled, using the default panel refresh rate\n\t\t * as max refresh rate supported.\n\t\t */\n\t\tpinfo->max_fps = pinfo->mipi.frame_rate;\n\t\trc = 0;\n\t}\n\n\tpr_info(\"dyn_fps: min = %d, max = %d\\n\",\n\t\t\tpinfo->min_fps, pinfo->max_fps);\n\treturn rc;\n}", "llvm": null, "hash": "2ddb7302328523e38cfeac2de4d3a54c71266f77b9f45949f4f1508d12c8dc56", "memory": 967}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_parse_dfps_config", "code": "\nstatic void mdss_dsi_parse_dfps_config(struct device_node *pan_node,\n\t\t\tstruct mdss_dsi_ctrl_pdata *ctrl_pdata)\n{\n\tconst char *data;\n\tbool dynamic_fps;\n\tstruct mdss_panel_info *pinfo = &(ctrl_pdata->panel_data.panel_info);\n\n\tdynamic_fps = of_property_read_bool(pan_node,\n\t\t\t\"qcom,mdss-dsi-pan-enable-dynamic-fps\");\n\n\tif (!dynamic_fps)\n\t\treturn;\n\n\tpinfo->dynamic_fps = true;\n\tdata = of_get_property(pan_node, \"qcom,mdss-dsi-pan-fps-update\", NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"dfps_suspend_resume_mode\")) {\n\t\t\tpinfo->dfps_update = DFPS_SUSPEND_RESUME_MODE;\n\t\t\tpr_debug(\"dfps mode: suspend/resume\\n\");\n\t\t} else if (!strcmp(data, \"dfps_immediate_clk_mode\")) {\n\t\t\tpinfo->dfps_update = DFPS_IMMEDIATE_CLK_UPDATE_MODE;\n\t\t\tpr_debug(\"dfps mode: Immediate clk\\n\");\n\t\t} else if (!strcmp(data, \"dfps_immediate_porch_mode_hfp\")) {\n\t\t\tpinfo->dfps_update =\n\t\t\t\tDFPS_IMMEDIATE_PORCH_UPDATE_MODE_HFP;\n\t\t\tpr_debug(\"dfps mode: Immediate porch HFP\\n\");\n\t\t} else if (!strcmp(data, \"dfps_immediate_porch_mode_vfp\")) {\n\t\t\tpinfo->dfps_update =\n\t\t\t\tDFPS_IMMEDIATE_PORCH_UPDATE_MODE_VFP;\n\t\t\tpr_debug(\"dfps mode: Immediate porch VFP\\n\");\n\t\t} else {\n\t\t\tpinfo->dfps_update = DFPS_SUSPEND_RESUME_MODE;\n\t\t\tpr_debug(\"default dfps mode: suspend/resume\\n\");\n\t\t}\n\t\tmdss_dsi_set_refresh_rate_range(pan_node, pinfo);\n\t} else {\n\t\tpinfo->dynamic_fps = false;\n\t\tpr_debug(\"dfps update mode not configured: disable\\n\");\n\t}\n\tpinfo->new_fps = pinfo->mipi.frame_rate;\n\n\treturn;\n}", "llvm": null, "hash": "55ae3950e6f14fc8dd2ae4896e7f9050d6dacf6f2cb45cc50438a9ac8e3db766", "memory": 1441}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_timing_switch", "code": "\nint mdss_dsi_panel_timing_switch(struct mdss_dsi_ctrl_pdata *ctrl,\n\t\t\tstruct mdss_panel_timing *timing)\n{\n\tstruct dsi_panel_timing *pt;\n\tstruct mdss_panel_info *pinfo = &ctrl->panel_data.panel_info;\n\tint i;\n\n\tif (!timing)\n\t\treturn -EINVAL;\n\n\tif (timing == ctrl->panel_data.current_timing) {\n\t\tpr_warn(\"%s: panel timing \\\"%s\\\" already set\\n\", __func__,\n\t\t\t\ttiming->name);\n\t\treturn 0; /* nothing to do */\n\t}\n\n\tpr_debug(\"%s: ndx=%d switching to panel timing \\\"%s\\\"\\n\", __func__,\n\t\t\tctrl->ndx, timing->name);\n\n\tmdss_panel_info_from_timing(timing, pinfo);\n\n\tpt = container_of(timing, struct dsi_panel_timing, timing);\n\tpinfo->mipi.t_clk_pre = pt->t_clk_pre;\n\tpinfo->mipi.t_clk_post = pt->t_clk_post;\n\n\tfor (i = 0; i < ARRAY_SIZE(pt->phy_timing); i++)\n\t\tpinfo->mipi.dsi_phy_db.timing[i] = pt->phy_timing[i];\n\n\tctrl->on_cmds = pt->on_cmds;\n\n\tctrl->panel_data.current_timing = timing;\n\tif (!timing->clk_rate)\n\t\tctrl->refresh_clk_rate = true;\n\tmdss_dsi_clk_refresh(&ctrl->panel_data);\n\n\treturn 0;\n}", "llvm": null, "hash": "92a7b121169573356805f61c5f4f0890899e92c5a5e4e7c3e47c59b8631e3f3d", "memory": 990}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_timing_from_dt", "code": "\nstatic int mdss_dsi_panel_timing_from_dt(struct device_node *np,\n\tstruct dsi_panel_timing *pt)\n{\n\tu32 tmp;\n\tint rc, i, len;\n\tconst char *data;\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-width\", &tmp);\n\tif (rc) {\n\t\tpr_err(\"%s:%d, panel width not specified\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tpt->timing.xres = tmp;\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-height\", &tmp);\n\tif (rc) {\n\t\tpr_err(\"%s:%d, panel height not specified\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tpt->timing.yres = tmp;\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-front-porch\", &tmp);\n\tpt->timing.h_front_porch = (!rc ? tmp : 6);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-back-porch\", &tmp);\n\tpt->timing.h_back_porch = (!rc ? tmp : 6);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-pulse-width\", &tmp);\n\tpt->timing.h_pulse_width = (!rc ? tmp : 2);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-sync-skew\", &tmp);\n\tpt->timing.hsync_skew = (!rc ? tmp : 0);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-v-back-porch\", &tmp);\n\tpt->timing.v_back_porch = (!rc ? tmp : 6);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-v-front-porch\", &tmp);\n\tpt->timing.v_front_porch = (!rc ? tmp : 6);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-v-pulse-width\", &tmp);\n\tpt->timing.v_pulse_width = (!rc ? tmp : 2);\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-left-border\", &tmp);\n\tpt->timing.border_left = !rc ? tmp : 0;\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-h-right-border\", &tmp);\n\tpt->timing.border_right = !rc ? tmp : 0;\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-v-top-border\", &tmp);\n\tpt->timing.border_top = !rc ? tmp : 0;\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-v-bottom-border\", &tmp);\n\tpt->timing.border_bottom = !rc ? tmp : 0;\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-framerate\", &tmp);\n\tpt->timing.frame_rate = !rc ? tmp : DEFAULT_FRAME_RATE;\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-panel-clockrate\", &tmp);\n\tpt->timing.clk_rate = !rc ? tmp : 0;\n\n\tdata = of_get_property(np, \"qcom,mdss-dsi-panel-timings\", &len);\n\tif ((!data) || (len != 12)) {\n\t\tpr_err(\"%s:%d, Unable to read Phy timing settings\",\n\t\t       __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < len; i++)\n\t\tpt->phy_timing[i] = data[i];\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-t-clk-pre\", &tmp);\n\tpt->t_clk_pre = (!rc ? tmp : 0x24);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-t-clk-post\", &tmp);\n\tpt->t_clk_post = (!rc ? tmp : 0x03);\n\n\tif (np->name) {\n\t\tpt->timing.name = kstrdup(np->name, GFP_KERNEL);\n\t\tpr_info(\"%s: found new timing \\\"%s\\\" (%p)\\n\", __func__,\n\t\t\t\tnp->name, &pt->timing);\n\t}\n\n\treturn 0;\n}", "llvm": null, "hash": "e709a8e20782873d3494c81c2ad10d7d1be9e5ec47beaad54e548c67f87fc1b9", "memory": 2654}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_config_res_properties", "code": "\nstatic void  mdss_dsi_panel_config_res_properties(struct device_node *np,\n\t\tstruct dsi_panel_timing *pt)\n{\n\tmdss_dsi_parse_dcs_cmds(np, &pt->on_cmds,\n\t\t\t\"qcom,mdss-dsi-on-command\",\n\t\t\t\"qcom,mdss-dsi-on-command-state\");\n\tmdss_dsi_parse_dcs_cmds(np, &pt->switch_cmds,\n\t\t\t\"qcom,mdss-dsi-timing-switch-command\",\n\t\t\t\"qcom,mdss-dsi-timing-switch-command-state\");\n\tmdss_dsi_parse_fbc_params(np, &pt->timing.fbc);\n\tmdss_panel_parse_te_params(np, &pt->timing);\n}", "llvm": null, "hash": "f90b1e4d90b46b0f16205d52c7459467dc465ec5bb7bf3c1fbff261786713a53", "memory": 454}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_parse_display_timings", "code": "\nstatic int mdss_dsi_panel_parse_display_timings(struct device_node *np,\n\t\tstruct mdss_panel_data *panel_data)\n{\n\tstruct mdss_dsi_ctrl_pdata *ctrl;\n\tstruct dsi_panel_timing *modedb;\n\tstruct device_node *timings_np;\n\tstruct device_node *entry;\n\tint num_timings, rc;\n\tint i = 0, active_ndx = 0;\n\n\tctrl = container_of(panel_data, struct mdss_dsi_ctrl_pdata, panel_data);\n\n\tINIT_LIST_HEAD(&panel_data->timings_list);\n\n\ttimings_np = of_get_child_by_name(np, \"qcom,mdss-dsi-display-timings\");\n\tif (!timings_np) {\n\t\tstruct dsi_panel_timing pt;\n\t\tmemset(&pt, 0, sizeof(struct dsi_panel_timing));\n\n\t\t/*\n\t\t * display timings node is not available, fallback to reading\n\t\t * timings directly from root node instead\n\t\t */\n\t\tpr_debug(\"reading display-timings from panel node\\n\");\n\t\trc = mdss_dsi_panel_timing_from_dt(np, &pt);\n\t\tif (!rc) {\n\t\t\tmdss_dsi_panel_config_res_properties(np, &pt);\n\t\t\trc = mdss_dsi_panel_timing_switch(ctrl, &pt.timing);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tnum_timings = of_get_child_count(timings_np);\n\tif (num_timings == 0) {\n\t\tpr_err(\"no timings found within display-timings\\n\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tmodedb = kzalloc(num_timings * sizeof(*modedb), GFP_KERNEL);\n\tif (!modedb) {\n\t\tpr_err(\"unable to allocate modedb\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor_each_child_of_node(timings_np, entry) {\n\t\trc = mdss_dsi_panel_timing_from_dt(entry, modedb + i);\n\t\tif (rc) {\n\t\t\tkfree(modedb);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmdss_dsi_panel_config_res_properties(entry, (modedb + i));\n\n\t\t/* if default is set, use it otherwise use first as default */\n\t\tif (of_property_read_bool(entry,\n\t\t\t\t\"qcom,mdss-dsi-timing-default\"))\n\t\t\tactive_ndx = i;\n\n\t\tlist_add(&modedb[i].timing.list,\n\t\t\t\t&panel_data->timings_list);\n\t\ti++;\n\t}\n\n\t/* Configure default timing settings */\n\trc = mdss_dsi_panel_timing_switch(ctrl, &modedb[active_ndx].timing);\n\tif (rc)\n\t\tpr_err(\"unable to configure default timing settings\\n\");\n\nexit:\n\tof_node_put(timings_np);\n\n\treturn rc;\n}", "llvm": null, "hash": "088bd2a3663f23e18c7a1dfa0d8eccfb4aaa6831711caa613bb7d90fd7b82584", "memory": 1939}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_panel_parse_dt", "code": "\nstatic int mdss_panel_parse_dt(struct device_node *np,\n\t\t\tstruct mdss_dsi_ctrl_pdata *ctrl_pdata)\n{\n\tu32 tmp;\n\tint rc;\n\tconst char *data;\n\tstatic const char *pdest;\n\tstruct mdss_panel_info *pinfo = &(ctrl_pdata->panel_data.panel_info);\n\n\trc = mdss_dsi_panel_parse_display_timings(np,\n\t\t\t\t\t&ctrl_pdata->panel_data);\n\tif (rc)\n\t\treturn rc;\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-pan-physical-width-dimension\", &tmp);\n\tpinfo->physical_width = (!rc ? tmp : 0);\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-pan-physical-height-dimension\", &tmp);\n\tpinfo->physical_height = (!rc ? tmp : 0);\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-bpp\", &tmp);\n\tif (rc) {\n\t\tpr_err(\"%s:%d, bpp not specified\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tpinfo->bpp = (!rc ? tmp : 24);\n\tpinfo->mipi.mode = DSI_VIDEO_MODE;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-panel-type\", NULL);\n\tif (data && !strncmp(data, \"dsi_cmd_mode\", 12))\n\t\tpinfo->mipi.mode = DSI_CMD_MODE;\n\tpinfo->mipi.boot_mode = pinfo->mipi.mode;\n\ttmp = 0;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-pixel-packing\", NULL);\n\tif (data && !strcmp(data, \"loose\"))\n\t\tpinfo->mipi.pixel_packing = 1;\n\telse\n\t\tpinfo->mipi.pixel_packing = 0;\n\trc = mdss_panel_get_dst_fmt(pinfo->bpp,\n\t\tpinfo->mipi.mode, pinfo->mipi.pixel_packing,\n\t\t&(pinfo->mipi.dst_format));\n\tif (rc) {\n\t\tpr_debug(\"%s: problem determining dst format. Set Default\\n\",\n\t\t\t__func__);\n\t\tpinfo->mipi.dst_format =\n\t\t\tDSI_VIDEO_DST_FORMAT_RGB888;\n\t}\n\tpdest = of_get_property(np,\n\t\t\"qcom,mdss-dsi-panel-destination\", NULL);\n\n\tif (pdest) {\n\t\tif (strlen(pdest) != 9) {\n\t\t\tpr_err(\"%s: Unknown pdest specified\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!strcmp(pdest, \"display_1\"))\n\t\t\tpinfo->pdest = DISPLAY_1;\n\t\telse if (!strcmp(pdest, \"display_2\"))\n\t\t\tpinfo->pdest = DISPLAY_2;\n\t\telse {\n\t\t\tpr_debug(\"%s: incorrect pdest. Set Default\\n\",\n\t\t\t\t__func__);\n\t\t\tpinfo->pdest = DISPLAY_1;\n\t\t}\n\t} else {\n\t\tpr_debug(\"%s: pdest not specified. Set Default\\n\",\n\t\t\t\t__func__);\n\t\tpinfo->pdest = DISPLAY_1;\n\t}\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-underflow-color\", &tmp);\n\tpinfo->lcdc.underflow_clr = (!rc ? tmp : 0xff);\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-border-color\", &tmp);\n\tpinfo->lcdc.border_clr = (!rc ? tmp : 0);\n\tdata = of_get_property(np, \"qcom,mdss-dsi-panel-orientation\", NULL);\n\tif (data) {\n\t\tpr_debug(\"panel orientation is %s\\n\", data);\n\t\tif (!strcmp(data, \"180\"))\n\t\t\tpinfo->panel_orientation = MDP_ROT_180;\n\t\telse if (!strcmp(data, \"hflip\"))\n\t\t\tpinfo->panel_orientation = MDP_FLIP_LR;\n\t\telse if (!strcmp(data, \"vflip\"))\n\t\t\tpinfo->panel_orientation = MDP_FLIP_UD;\n\t}\n#if !IS_ENABLED(CONFIG_LGE_DISPLAY_POWER_SEQUENCE)\n\tctrl_pdata->bklt_ctrl = UNKNOWN_CTRL;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-bl-pmic-control-type\", NULL);\n\tif (data) {\n\t\tif (!strncmp(data, \"bl_ctrl_wled\", 12)) {\n\t\t\tled_trigger_register_simple(\"bkl-trigger\",\n\t\t\t\t&bl_led_trigger);\n\t\t\tpr_debug(\"%s: SUCCESS-> WLED TRIGGER register\\n\",\n\t\t\t\t__func__);\n\t\t\tctrl_pdata->bklt_ctrl = BL_WLED;\n\t\t} else if (!strncmp(data, \"bl_ctrl_pwm\", 11)) {\n\t\t\tctrl_pdata->bklt_ctrl = BL_PWM;\n\t\t\tctrl_pdata->pwm_pmi = of_property_read_bool(np,\n\t\t\t\t\t\"qcom,mdss-dsi-bl-pwm-pmi\");\n\t\t\trc = of_property_read_u32(np,\n\t\t\t\t\"qcom,mdss-dsi-bl-pmic-pwm-frequency\", &tmp);\n\t\t\tif (rc) {\n\t\t\t\tpr_err(\"%s:%d, Error, panel pwm_period\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tctrl_pdata->pwm_period = tmp;\n\t\t\tif (ctrl_pdata->pwm_pmi) {\n\t\t\t\tctrl_pdata->pwm_bl = of_pwm_get(np, NULL);\n\t\t\t\tif (IS_ERR(ctrl_pdata->pwm_bl)) {\n\t\t\t\t\tpr_err(\"%s: Error, pwm device\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\t\t\t\tctrl_pdata->pwm_bl = NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = of_property_read_u32(np,\n\t\t\t\t\t\"qcom,mdss-dsi-bl-pmic-bank-select\",\n\t\t\t\t\t\t\t\t &tmp);\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_err(\"%s:%d, Error, lpg channel\\n\",\n\t\t\t\t\t\t\t__func__, __LINE__);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tctrl_pdata->pwm_lpg_chan = tmp;\n\t\t\t\ttmp = of_get_named_gpio(np,\n\t\t\t\t\t\"qcom,mdss-dsi-pwm-gpio\", 0);\n\t\t\t\tctrl_pdata->pwm_pmic_gpio = tmp;\n\t\t\t\tpr_debug(\"%s: Configured PWM bklt ctrl\\n\",\n\t\t\t\t\t\t\t\t __func__);\n\t\t\t}\n\t\t} else if (!strncmp(data, \"bl_ctrl_dcs\", 11)) {\n\t\t\tctrl_pdata->bklt_ctrl = BL_DCS_CMD;\n\t\t\tpr_debug(\"%s: Configured DCS_CMD bklt ctrl\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\t}\n\t}\n#endif\n\trc = of_property_read_u32(np, \"qcom,mdss-brightness-max-level\", &tmp);\n\tpinfo->brightness_max = (!rc ? tmp : MDSS_MAX_BL_BRIGHTNESS);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-bl-min-level\", &tmp);\n\tpinfo->bl_min = (!rc ? tmp : 0);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-bl-max-level\", &tmp);\n\tpinfo->bl_max = (!rc ? tmp : 255);\n\tctrl_pdata->bklt_max = pinfo->bl_max;\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_POWER_SEQUENCE)\n\tif (lge_mdss_dsi.lge_mdss_panel_parse_dt)\n\t\trc = lge_mdss_dsi.lge_mdss_panel_parse_dt(np, ctrl_pdata);\n\tif(rc)\n\t\tgoto error;\n#endif\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-interleave-mode\", &tmp);\n\tpinfo->mipi.interleave_mode = (!rc ? tmp : 0);\n\n\tpinfo->mipi.vsync_enable = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-te-check-enable\");\n\tpinfo->mipi.hw_vsync_mode = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-te-using-te-pin\");\n\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-h-sync-pulse\", &tmp);\n\tpinfo->mipi.pulse_mode_hsa_he = (!rc ? tmp : false);\n\n\tpinfo->mipi.hfp_power_stop = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-hfp-power-mode\");\n\tpinfo->mipi.hsa_power_stop = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-hsa-power-mode\");\n\tpinfo->mipi.hbp_power_stop = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-hbp-power-mode\");\n\tpinfo->mipi.last_line_interleave_en = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-last-line-interleave\");\n\tpinfo->mipi.bllp_power_stop = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-bllp-power-mode\");\n\tpinfo->mipi.eof_bllp_power_stop = of_property_read_bool(\n\t\tnp, \"qcom,mdss-dsi-bllp-eof-power-mode\");\n\tpinfo->mipi.traffic_mode = DSI_NON_BURST_SYNCH_PULSE;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-traffic-mode\", NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"non_burst_sync_event\"))\n\t\t\tpinfo->mipi.traffic_mode = DSI_NON_BURST_SYNCH_EVENT;\n\t\telse if (!strcmp(data, \"burst_mode\"))\n\t\t\tpinfo->mipi.traffic_mode = DSI_BURST_MODE;\n\t}\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-te-dcs-command\", &tmp);\n\tpinfo->mipi.insert_dcs_cmd =\n\t\t\t(!rc ? tmp : 1);\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-wr-mem-continue\", &tmp);\n\tpinfo->mipi.wr_mem_continue =\n\t\t\t(!rc ? tmp : 0x3c);\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-wr-mem-start\", &tmp);\n\tpinfo->mipi.wr_mem_start =\n\t\t\t(!rc ? tmp : 0x2c);\n\trc = of_property_read_u32(np,\n\t\t\"qcom,mdss-dsi-te-pin-select\", &tmp);\n\tpinfo->mipi.te_sel =\n\t\t\t(!rc ? tmp : 1);\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-virtual-channel-id\", &tmp);\n\tpinfo->mipi.vc = (!rc ? tmp : 0);\n\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_RGB;\n\tdata = of_get_property(np, \"qcom,mdss-dsi-color-order\", NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"rgb_swap_rbg\"))\n\t\t\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_RBG;\n\t\telse if (!strcmp(data, \"rgb_swap_bgr\"))\n\t\t\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_BGR;\n\t\telse if (!strcmp(data, \"rgb_swap_brg\"))\n\t\t\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_BRG;\n\t\telse if (!strcmp(data, \"rgb_swap_grb\"))\n\t\t\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_GRB;\n\t\telse if (!strcmp(data, \"rgb_swap_gbr\"))\n\t\t\tpinfo->mipi.rgb_swap = DSI_RGB_SWAP_GBR;\n\t}\n\tpinfo->mipi.data_lane0 = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-lane-0-state\");\n\tpinfo->mipi.data_lane1 = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-lane-1-state\");\n\tpinfo->mipi.data_lane2 = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-lane-2-state\");\n\tpinfo->mipi.data_lane3 = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-lane-3-state\");\n\n#if defined(CONFIG_MACH_LGE)\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-lane-hs\", &tmp);\n\tpinfo->mipi.force_clk_lane_hs = (!rc ? tmp : 0);\n#endif\n\n\tpinfo->mipi.rx_eot_ignore = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-rx-eot-ignore\");\n\tpinfo->mipi.tx_eot_append = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-tx-eot-append\");\n\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-stream\", &tmp);\n\tpinfo->mipi.stream = (!rc ? tmp : 0);\n\n\tdata = of_get_property(np, \"qcom,mdss-dsi-panel-mode-gpio-state\", NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"high\"))\n\t\t\tpinfo->mode_gpio_state = MODE_GPIO_HIGH;\n\t\telse if (!strcmp(data, \"low\"))\n\t\t\tpinfo->mode_gpio_state = MODE_GPIO_LOW;\n\t} else {\n\t\tpinfo->mode_gpio_state = MODE_GPIO_NOT_VALID;\n\t}\n\n\trc = of_property_read_u32(np, \"qcom,mdss-mdp-transfer-time-us\", &tmp);\n\tpinfo->mdp_transfer_time_us = (!rc ? tmp : DEFAULT_MDP_TRANSFER_TIME);\n\n\tpinfo->mipi.lp11_init = of_property_read_bool(np,\n\t\t\t\t\t\"qcom,mdss-dsi-lp11-init\");\n\trc = of_property_read_u32(np, \"qcom,mdss-dsi-init-delay-us\", &tmp);\n\tpinfo->mipi.init_delay = (!rc ? tmp : 0);\n\n\tmdss_dsi_parse_roi_alignment(np, pinfo);\n\n\tmdss_dsi_parse_trigger(np, &(pinfo->mipi.mdp_trigger),\n\t\t\"qcom,mdss-dsi-mdp-trigger\");\n\n\tmdss_dsi_parse_trigger(np, &(pinfo->mipi.dma_trigger),\n\t\t\"qcom,mdss-dsi-dma-trigger\");\n\n\tmdss_dsi_parse_lane_swap(np, &(pinfo->mipi.dlane_swap));\n\n\tmdss_dsi_parse_reset_seq(np, pinfo->rst_seq, &(pinfo->rst_seq_len),\n\t\t\"qcom,mdss-dsi-reset-sequence\");\n\n\tmdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->off_cmds,\n\t\t\"qcom,mdss-dsi-off-command\", \"qcom,mdss-dsi-off-command-state\");\n\n\tpinfo->mipi.force_clk_lane_hs = of_property_read_bool(np,\n\t\t\"qcom,mdss-dsi-force-clock-lane-hs\");\n\n\trc = mdss_dsi_parse_panel_features(np, ctrl_pdata);\n\tif (rc) {\n\t\tpr_err(\"%s: failed to parse panel features\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tmdss_dsi_parse_panel_horizintal_line_idle(np, ctrl_pdata);\n\n\tmdss_dsi_parse_dfps_config(np, ctrl_pdata);\n\n\treturn 0;\n\nerror:\n\treturn -EINVAL;\n}", "llvm": null, "hash": "dd078eafa77c8a19ee57cefc406038f930c21a0898b4db88764d987c847d687f", "memory": 9541}
{"username": "garwedgess", "repo": "android_kernel_lge_g4", "path": "drivers/video/msm/mdss/mdss_dsi_panel.c", "function": "mdss_dsi_panel_init", "code": "\nint mdss_dsi_panel_init(struct device_node *node,\n\tstruct mdss_dsi_ctrl_pdata *ctrl_pdata,\n\tbool cmd_cfg_cont_splash)\n{\n\tint rc = 0;\n\tstatic const char *panel_name;\n\tstruct mdss_panel_info *pinfo;\n\n\tif (!node || !ctrl_pdata) {\n\t\tpr_err(\"%s: Invalid arguments\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpinfo = &ctrl_pdata->panel_data.panel_info;\n\n\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\tpinfo->panel_name[0] = '\\0';\n\tpanel_name = of_get_property(node, \"qcom,mdss-dsi-panel-name\", NULL);\n\tif (!panel_name) {\n\t\tpr_info(\"%s:%d, Panel name not specified\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t} else {\n\t\tpr_info(\"%s: Panel Name = %s\\n\", __func__, panel_name);\n\t\tstrlcpy(&pinfo->panel_name[0], panel_name, MDSS_MAX_PANEL_LEN);\n#if IS_ENABLED(CONFIG_LGE_DISPLAY_POWER_SEQUENCE)\n\t\tif (lge_mdss_dsi.lge_mdss_dsi_panel_init)\n\t\t\trc = lge_mdss_dsi.lge_mdss_dsi_panel_init(node,ctrl_pdata,cmd_cfg_cont_splash);\n#endif\n\t}\n\trc = mdss_panel_parse_dt(node, ctrl_pdata);\n\tif (rc) {\n\t\tpr_err(\"%s:%d panel dt parse failed\\n\", __func__, __LINE__);\n\t\treturn rc;\n\t}\n\n\tif (!cmd_cfg_cont_splash)\n\t\tpinfo->cont_splash_enabled = false;\n\tpr_info(\"%s: Continuous splash %s\\n\", __func__,\n\t\tpinfo->cont_splash_enabled ? \"enabled\" : \"disabled\");\n\n\tpinfo->dynamic_switch_pending = false;\n\tpinfo->is_lpm_mode = false;\n\tpinfo->esd_rdy = false;\n\n\tctrl_pdata->on = mdss_dsi_panel_on;\n\tctrl_pdata->off = mdss_dsi_panel_off;\n\tctrl_pdata->low_power_config = mdss_dsi_panel_low_power_config;\n\tctrl_pdata->panel_data.set_backlight = mdss_dsi_panel_bl_ctrl;\n\tctrl_pdata->switch_mode = mdss_dsi_panel_switch_mode;\n\n\treturn 0;\n}", "llvm": null, "hash": "f4c5113873e1a7785497ae0ec8673387362879b5f4478aac7bc2c5fa3065f68e", "memory": 1576}
