{"code": "for (i = 0; s[i] != '\\0'; i++)\n{\n  for (j = i, k = 0; (t[k] != '\\0') && (s[j] == t[k]); j++, k++)\n    ;\n\n  if ((k > 0) && (t[k] == '\\0'))\n    return i;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/0"}
{"code": "for (i = 0; i < (dim * (*natom)); i++)\n{\n  strncpy(field, line + (20 * (i % dim)), 20);\n  field[20] = '\\0';\n  x[i] = atof(field);\n  if (((i % dim) == (dim - 1)) && (i < ((dim * (*natom)) - 1)))\n    ggets(line, sizeof(line), fp);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/1"}
{"code": "for (i = 0; i < (dim * (*natom)); i += dim)\n{\n  if (dim == 3)\n  {\n    fprintf(fp, \"%20.15f%20.15f%20.15f\\n\", x[i], x[i + 1], x[i + 2]);\n  }\n  else\n  {\n    fprintf(fp, \"%20.15f%20.15f%20.15f%20.15f\\n\", x[i], x[i + 1], x[i + 2], x[i + 3]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/2"}
{"code": "for (i = 0; i < (3 * (*natom)); i++)\n{\n  strncpy(field, line + (12 * (i % 6)), 12);\n  field[12] = '\\0';\n  x[i] = atof(field);\n  if (((i % 6) == 5) && (i < ((3 * (*natom)) - 1)))\n    ggets(line, sizeof(line), fp);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/3"}
{"code": "for (i = 0; i < (3 * (*natom)); i++)\n{\n  strncpy(field, line + (12 * (i % 6)), 12);\n  field[12] = '\\0';\n  v[i] = atof(field);\n  if ((i % 6) == 5)\n    ggets(line, sizeof(line), fp);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/4"}
{"code": "for (i = 0; i < (3 * (*natom)); i++)\n  v[i] = 0.0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/5"}
{"code": "for (i = 0; i < (3 * (*natom)); i += 6)\n{\n  if ((i + 3) < (3 * (*natom)))\n    fprintf(fp, \"%12.7f%12.7f%12.7f%12.7f%12.7f%12.7f\\n\", x[i], x[i + 1], x[i + 2], x[i + 3], x[i + 4], x[i + 5]);\n  else\n    fprintf(fp, \"%12.7f%12.7f%12.7f\\n\", x[i], x[i + 1], x[i + 2]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/6"}
{"code": "for (i = 0; i < (3 * (*natom)); i += 6)\n{\n  if ((i + 3) < (3 * (*natom)))\n    fprintf(fp, \"%12.7f%12.7f%12.7f%12.7f%12.7f%12.7f\\n\", v[i], v[i + 1], v[i + 2], v[i + 3], v[i + 4], v[i + 5]);\n  else\n    fprintf(fp, \"%12.7f%12.7f%12.7f\\n\", v[i], v[i + 1], v[i + 2]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/7"}
{"code": "for (i = 0; i < prm->Natom; i++)\n  numb[i] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/8"}
{"code": "for (i = 0; i < prm->Nbona; i++)\n{\n  at1 = prm->BondAt1[i] / 3;\n  at2 = prm->BondAt2[i] / 3;\n  numb[at1] += 1;\n  numb[at2] += 1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/9"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  atypi[0] = toupper(prm->AtomSym[i * 4]);\n  atypi[1] = toupper(prm->AtomSym[(i * 4) + 1]);\n  atypi[2] = '\\0';\n  if (strncmp(atypi, \"CT\", 2) == 0)\n  {\n    if (numb[i] == 1)\n    {\n      P0[i] = 1.70 + 1.40;\n      P1[i] = 0.7887;\n      P2[i] = -0.28063;\n      P3[i] = -0.0012968;\n      P4[i] = 0.00039328;\n    }\n    else\n      if (numb[i] == 2)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.56482;\n      P2[i] = -0.19608;\n      P3[i] = -0.0010219;\n      P4[i] = 0.0002658;\n    }\n    else\n      if (numb[i] == 3)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.23348;\n      P2[i] = -0.072627;\n      P3[i] = -0.00020079;\n      P4[i] = 0.00007967;\n    }\n    else\n      if (numb[i] == 4)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = (P2[i] = (P3[i] = (P4[i] = 0.0)));\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to CT: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default carbon parameters\\n\");\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.51245;\n      P2[i] = -0.15966;\n      P3[i] = -0.00019781;\n      P4[i] = 0.00016392;\n    }\n  }\n  else\n    if (strncmp(atypi, \"C\", 1) == 0)\n  {\n    if (numb[i] == 2)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.51245;\n      P2[i] = -0.15966;\n      P3[i] = -0.00019781;\n      P4[i] = 0.00016392;\n    }\n    else\n      if (numb[i] == 3)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.070344;\n      P2[i] = -0.019015;\n      P3[i] = -0.000022009;\n      P4[i] = 0.000016875;\n    }\n    else\n      if (numb[i] == 4)\n    {\n      P0[i] = 1.70 + 1.4;\n      P1[i] = (P2[i] = (P3[i] = (P4[i] = 0.0)));\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to C: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default carbon parameters\\n\");\n      P0[i] = 1.70 + 1.4;\n      P1[i] = 0.51245;\n      P2[i] = -0.15966;\n      P3[i] = -0.00019781;\n      P4[i] = 0.00016392;\n    }\n  }\n  else\n    if (strncmp(atypi, \"O \", 2) == 0)\n  {\n    P0[i] = 1.6 + 1.4;\n    P1[i] = 0.68563;\n    P2[i] = -0.1868;\n    P3[i] = -0.00135573;\n    P4[i] = 0.00023743;\n  }\n  else\n    if (strncmp(atypi, \"O2\", 2) == 0)\n  {\n    P0[i] = 1.6 + 1.4;\n    P1[i] = 0.88857;\n    P2[i] = -0.33421;\n    P3[i] = -0.0018683;\n    P4[i] = 0.00049372;\n  }\n  else\n    if (strncmp(atypi, \"O\", 1) == 0)\n  {\n    if (numb[i] == 1)\n    {\n      P0[i] = 1.6 + 1.4;\n      P1[i] = 0.77914;\n      P2[i] = -0.25262;\n      P3[i] = -0.0016056;\n      P4[i] = 0.00035071;\n    }\n    else\n      if (numb[i] == 2)\n    {\n      P0[i] = 1.6 + 1.4;\n      P1[i] = 0.49392;\n      P2[i] = -0.16038;\n      P3[i] = -0.00015512;\n      P4[i] = 0.00016453;\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to O*: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default oxygen parameters\\n\");\n      P0[i] = 1.6 + 1.4;\n      P1[i] = 0.68563;\n      P2[i] = -0.1868;\n      P3[i] = -0.00135573;\n      P4[i] = 0.00023743;\n    }\n  }\n  else\n    if (strncmp(atypi, \"N3\", 2) == 0)\n  {\n    if (numb[i] == 1)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.078602;\n      P2[i] = -0.29198;\n      P3[i] = -0.0006537;\n      P4[i] = 0.00036247;\n    }\n    else\n      if (numb[i] == 2)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.22599;\n      P2[i] = -0.036648;\n      P3[i] = -0.0012297;\n      P4[i] = 0.000080038;\n    }\n    else\n      if (numb[i] == 3)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.051481;\n      P2[i] = -0.012603;\n      P3[i] = -0.00032006;\n      P4[i] = 0.000024774;\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to N3: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default nitrogen parameters\\n\");\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.73511;\n      P2[i] = -0.22116;\n      P3[i] = -0.00089148;\n      P4[i] = 0.0002523;\n    }\n  }\n  else\n    if (strncmp(atypi, \"N\", 1) == 0)\n  {\n    if (numb[i] == 1)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.73511;\n      P2[i] = -0.22116;\n      P3[i] = -0.00089148;\n      P4[i] = 0.0002523;\n    }\n    else\n      if (numb[i] == 2)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.41102;\n      P2[i] = -0.12254;\n      P3[i] = -0.000075448;\n      P4[i] = 0.00011804;\n    }\n    else\n      if (numb[i] == 3)\n    {\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.062577;\n      P2[i] = -0.017874;\n      P3[i] = -0.00008312;\n      P4[i] = 0.000019849;\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to N: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default nitrogen parameters\\n\");\n      P0[i] = 1.65 + 1.4;\n      P1[i] = 0.73511;\n      P2[i] = -0.22116;\n      P3[i] = -0.00089148;\n      P4[i] = 0.0002523;\n    }\n  }\n  else\n    if (strncmp(atypi, \"SH\", 2) == 0)\n  {\n    P0[i] = 1.9 + 1.4;\n    P1[i] = 0.7722;\n    P2[i] = -0.26393;\n    P3[i] = 0.0010629;\n    P4[i] = 0.0002179;\n  }\n  else\n    if (strncmp(atypi, \"S\", 1) == 0)\n  {\n    P0[i] = 1.9 + 1.4;\n    P1[i] = 0.54581;\n    P2[i] = -0.19477;\n    P3[i] = -0.0012873;\n    P4[i] = 0.00029247;\n  }\n  else\n    if (strncmp(atypi, \"P\", 1) == 0)\n  {\n    if (numb[i] == 3)\n    {\n      P0[i] = 1.9 + 1.4;\n      P1[i] = 0.3865;\n      P2[i] = -0.18249;\n      P3[i] = -0.0036598;\n      P4[i] = 0.0004264;\n    }\n    else\n      if (numb[i] == 4)\n    {\n      P0[i] = 1.9 + 1.4;\n      P1[i] = 0.03873;\n      P2[i] = -0.0089339;\n      P3[i] = 0.0000083582;\n      P4[i] = 0.0000030381;\n    }\n    else\n    {\n      fprintf(stdout, \"bad number of bonds to P: %d %d; \", i, numb[i]);\n      fprintf(stdout, \"using default phosphorus parameters\\n\");\n      P0[i] = 1.9 + 1.4;\n      P1[i] = 0.3865;\n      P2[i] = -0.18249;\n      P3[i] = -0.0036598;\n      P4[i] = 0.0004264;\n    }\n  }\n  else\n    if (strncmp(atypi, \"H\", 1) == 0)\n  {\n    P0[i] = 1.40;\n    P1[i] = (P2[i] = (P3[i] = (P4[i] = 0.0)));\n  }\n  else\n  {\n    P0[i] = 1.70 + 1.4;\n    P1[i] = 0.51245;\n    P2[i] = -0.15966;\n    P3[i] = -0.00019781;\n    P4[i] = 0.00016392;\n    if (mytaskid == 0)\n    {\n      fprintf(stdout, \"Using carbon SA parms for atom type %s\\n\", atypi);\n    }\n  }\n  if (P0[i] > 5.0)\n    printf(\"bad p0: %d %12.6f %s\\n\", i, P0[i], atypi);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/10"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  prm->Charges[i] *= scale;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/11"}
{"code": "for (i = 0; i < nold; i++)\n{\n  free_ivector(pairlistnp[i], 0, 1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/12"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  pairlistnp[i] = 0;\n  lpairsnp[i] = (upairsnp[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/13"}
{"code": "for (i = 0; i < nold; i++)\n{\n  free_ivector(pairlist2np[i], 0, 1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/14"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  pairlist2np[i] = 0;\n  lpairs2np[i] = (upairs2np[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/15"}
{"code": "for (i = 0; i < nold; i++)\n{\n  free_ivector(pairlist[i], 0, 1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/16"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  pairlist[i] = 0;\n  lpairs[i] = (upairs[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/17"}
{"code": "for (i = 0; i < nold; i++)\n{\n  free_ivector(N14pearlist[i], 0, 1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/18"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  N14pearlist[i] = 0;\n  if (prm->N14pairs[i] > 0)\n  {\n    N14pearlist[i] = ivector(0, prm->N14pairs[i]);\n    for (j = 0; j < prm->N14pairs[i]; j++)\n    {\n      N14pearlist[i][j] = prm->N14pairlist[npairs + j];\n    }\n\n    npairs += prm->N14pairs[i];\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/19"}
{"code": "for (i = 0; i < nold; i++)\n{\n  free_ivector(IexclAt[i], 0, 1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/20"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  IexclAt[i] = 0;\n  if (prm->Iblo[i] > 0)\n  {\n    IexclAt[i] = ivector(0, prm->Iblo[i]);\n    for (j = 0; j < prm->Iblo[i]; j++)\n    {\n      IexclAt[i][j] = prm->ExclAt[iexcl + j];\n    }\n\n  }\n  iexcl += prm->Iblo[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/21"}
{"code": "for (k = 0, i = 0; i < prm->Natom; i++)\n{\n  am = 1. / prm->Masses[i];\n  minv[k + 0] = am;\n  minv[k + 1] = am;\n  minv[k + 2] = am;\n  if (dim == 4)\n  {\n    minv[k + 3] = am;\n  }\n  k += dim;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/22"}
{"code": "for (i = 0; i < n; i++)\n  minv[i] = invmass;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/23"}
{"code": "for (i = 0; i < n; i++)\n  v[i] = 0.0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/24"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (frozen[i / dim])\n  {\n    v[i] = 0.0;\n  }\n  else\n  {\n    sd = sqrt(((2. * boltz2) * tempi) * minv[i]);\n    v[i] = gauss(&zero, &sd);\n    ekin += (v[i] * v[i]) / minv[i];\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/25"}
{"code": "for (ekin = 0., i = 0; i < n; i++)\n  ekin += (v[i] * v[i]) * minv[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/26"}
{"code": "for (i = 0; i < n; i++)\n{\n  accel[i] = ((-f[i]) * minv[i]) * dt5;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/27"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (frozen[i / dim])\n  {\n    accel[i] = 0.0;\n  }\n  else\n  {\n    sqrmass[i] = 1.0 / sqrt(minv[i]);\n    sd = sdfac * sqrmass[i];\n    accel[i] = (((-f[i]) + gauss(&zero, &sd)) * minv[i]) * dt5;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/28"}
{"code": "for (nstep = 1; nstep <= maxstep; nstep++)\n{\n  if (ekin > 0.01)\n    tscal = sqrt(1. + (dttp * ((ekin0 / ekin) - 1.)));\n  else\n    tscal = 1.0;\n  ekin = 0.0;\n  for (i = 0; i < n; i++)\n    xold[i] = x[i];\n\n  if (gammai == 0.0)\n  {\n    for (i = 0; i < n; i++)\n    {\n      v[i] = (v[i] + accel[i]) * tscal;\n      v[i] = (v[i] > vlimit) ? (vlimit) : (v[i]);\n      v[i] = (v[i] < (-vlimit)) ? (-vlimit) : (v[i]);\n      x[i] += v[i] * dtx;\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < n; i++)\n    {\n      v[i] = (c_explic * v[i]) + accel[i];\n      v[i] = (v[i] > vlimit) ? (vlimit) : (v[i]);\n      v[i] = (v[i] < (-vlimit)) ? (-vlimit) : (v[i]);\n      x[i] += v[i] * dtx;\n    }\n\n  }\n  t2 = seconds();\n  tmd += t2 - t1;\n  epot = (*func)(x, f, &nstep);\n  t1 = seconds();\n  if (gammai == 0.0)\n  {\n    for (i = 0; i < n; i++)\n    {\n      accel[i] = ((-f[i]) * minv[i]) * dt5;\n      v[i] = (v[i] + accel[i]) * tscal;\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < n; i++)\n    {\n      if (!frozen[i / dim])\n      {\n        sd = sdfac * sqrmass[i];\n        accel[i] = (((-f[i]) + gauss(&zero, &sd)) * minv[i]) * dt5;\n        v[i] = (v[i] + accel[i]) * c_implic;\n      }\n    }\n\n  }\n  for (i = 0; i < n; i++)\n    ekin += (v[i] * v[i]) / minv[i];\n\n  ekin *= 0.5;\n  if (gammai > 0.)\n    ekin *= c_ave;\n  etot = ekin + epot;\n  temp = ekin / (boltz2 * rndf);\n  t += dt;\n  if (mytaskid == 0)\n  {\n    if (((nstep % ntpr_md) == 0) || (nstep == 1))\n    {\n      fprintf(nabout, \"md:       %5d %10.3f %10.2f %10.2f %10.2f %10.2f\\n\", nstep, t, ekin, epot, ekin + epot, temp);\n      fflush(nabout);\n    }\n  }\n  if (((ntwx > 0) && ((nstep % ntwx) == 0)) && (binposfp != 0))\n    writebinposfrm(n / 3, x, binposfp);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/sff/29"}
{"code": "for (i = 0; i < n; i++)\n{\n  i34 = dim * s[i];\n  xi = x[i34];\n  yi = x[i34 + 1];\n  zi = x[i34 + 2];\n  if (dim == 4)\n  {\n    wi = x[i34 + 3];\n  }\n  ri = rborn[s[i]] + dradius;\n  ci = kappanp / (ri * ri);\n  sumci += ci;\n  sumcjdij2 = 0.0;\n  for (j = i + 1; j < n; j++)\n  {\n    j34 = dim * s[j];\n    xj = x[j34];\n    yj = x[j34 + 1];\n    zj = x[j34 + 2];\n    xij = xi - xj;\n    yij = yi - yj;\n    zij = zi - zj;\n    dij2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n    if (dim == 4)\n    {\n      wj = x[j34 + 3];\n      wij = wi - wj;\n      dij2 += wij * wij;\n    }\n    rj = rborn[s[j]] + dradius;\n    cj = kappanp / (rj * rj);\n    sumcjdij2 += cj * dij2;\n  }\n\n  sumcicjdij2 += ci * sumcjdij2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/intersect/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  i34 = dim * s[i];\n  xi = x[i34];\n  yi = x[i34 + 1];\n  zi = x[i34 + 2];\n  if (dim == 4)\n  {\n    wi = x[i34 + 3];\n  }\n  ri = rborn[s[i]] + dradius;\n  ci = kappanp / (ri * ri);\n  daix = (daiy = (daiz = (daiw = 0.0)));\n  for (j = i + 1; j < n; j++)\n  {\n    j34 = dim * s[j];\n    xj = x[j34];\n    yj = x[j34 + 1];\n    zj = x[j34 + 2];\n    xij = xi - xj;\n    yij = yi - yj;\n    zij = zi - zj;\n    if (dim == 4)\n    {\n      wj = x[j34 + 3];\n      wij = wi - wj;\n    }\n    rj = rborn[s[j]] + dradius;\n    cj = kappanp / (rj * rj);\n    cicjsci = (ci * cj) * sumci1i;\n    de = (((-2.0) * cicjsci) * vg) * surften;\n    dedx = de * xij;\n    dedy = de * yij;\n    dedz = de * zij;\n    daix += dedx;\n    daiy += dedy;\n    daiz += dedz;\n    f[j34] -= dedx;\n    f[j34 + 1] -= dedy;\n    f[j34 + 2] -= dedz;\n    if (dim == 4)\n    {\n      dedw = de * wij;\n      daiw += dedw;\n      f[j34 + 3] -= dedw;\n    }\n  }\n\n  f[i34] += daix;\n  f[i34 + 1] += daiy;\n  f[i34 + 2] += daiz;\n  if (dim == 4)\n  {\n    f[i34 + 3] += daiw;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/intersect/1"}
{"code": "for (k = 0; k < o; k++)\n{\n  k34 = dim * s[k];\n  xk = x[k34];\n  yk = x[k34 + 1];\n  zk = x[k34 + 2];\n  if (dim == 4)\n  {\n    wk = x[k34 + 3];\n  }\n  sumcjdkj2 = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    if (k == j)\n      continue;\n    j34 = dim * s[j];\n    xj = x[j34];\n    yj = x[j34 + 1];\n    zj = x[j34 + 2];\n    xkj = xk - xj;\n    ykj = yk - yj;\n    zkj = zk - zj;\n    dkj2 = ((xkj * xkj) + (ykj * ykj)) + (zkj * zkj);\n    if (dim == 4)\n    {\n      wj = x[j34 + 3];\n      wkj = wk - wj;\n      dkj2 += wkj * wkj;\n    }\n    rj = rborn[s[j]] + dradius;\n    cj = kappanp / (rj * rj);\n    sumcjdkj2 += cj * dkj2;\n  }\n\n  rk = rborn[s[k]] + dradius;\n  kvgr3ci = (((2.0 * kappanp) * vgs) * sumci1i) / ((rk * rk) * rk);\n  agk = ((sumcjdkj2 - (sumcicjdij2 * sumci1i)) + 1.5) * kvgr3ci;\n  for (i = 0; i < n; i++)\n  {\n    i34 = dim * s[i];\n    xi = x[i34];\n    yi = x[i34 + 1];\n    zi = x[i34 + 2];\n    if (dim == 4)\n    {\n      wi = x[i34 + 3];\n    }\n    ri = rborn[s[i]] + dradius;\n    ci = kappanp / (ri * ri);\n    daix = (daiy = (daiz = (daiw = 0.0)));\n    for (j = i + 1; j < n; j++)\n    {\n      j34 = dim * s[j];\n      xj = x[j34];\n      yj = x[j34 + 1];\n      zj = x[j34 + 2];\n      xij = xi - xj;\n      yij = yi - yj;\n      zij = zi - zj;\n      if (dim == 4)\n      {\n        wj = x[j34 + 3];\n        wij = wi - wj;\n      }\n      rj = rborn[s[j]] + dradius;\n      cj = kappanp / (rj * rj);\n      if (i == k)\n      {\n        de = cj;\n      }\n      else\n        if (j == k)\n      {\n        de = ci;\n      }\n      else\n      {\n        de = 0.0;\n      }\n      cicjsci = (ci * cj) * sumci1i;\n      de -= cicjsci;\n      de *= 2.0 * kvgr3ci;\n      de -= (2.0 * cicjsci) * agk;\n      de *= surften;\n      dedx = de * xij;\n      dedy = de * yij;\n      dedz = de * zij;\n      daix += dedx;\n      daiy += dedy;\n      daiz += dedz;\n      f[j34] -= dedx;\n      f[j34 + 1] -= dedy;\n      f[j34 + 2] -= dedz;\n      if (dim == 4)\n      {\n        dedw = de * wij;\n        daiw += dedw;\n        f[j34 + 3] -= dedw;\n      }\n    }\n\n    f[i34] += daix;\n    f[i34 + 1] += daiy;\n    f[i34 + 2] += daiz;\n    if (dim == 4)\n    {\n      f[i34 + 3] += daiw;\n    }\n  }\n\n  ag += agk;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/intersect/2"}
{"code": "for (j = start; j < finish; j++)\n{\n  if (cull_np_lists)\n  {\n    j34 = dim * setlist[j];\n    xj = x[j34];\n    yj = x[j34 + 1];\n    zj = x[j34 + 2];\n    xij = xi - xj;\n    yij = yi - yj;\n    zij = zi - zj;\n    dij2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n    if (dim == 4)\n    {\n      wj = x[j34 + 3];\n      wij = wi - wj;\n      dij2 += wij * wij;\n    }\n    rj = rborn[setlist[j]] + dradius;\n    if (dij2 > (((ri + rj) + deltar) * ((ri + rj) + deltar)))\n      continue;\n  }\n  setarray[index] = setlist[j];\n  volume = intersect(setarray, x, f, rborn, &area, index + 1, gbsa);\n  totvolume += volume;\n  *surfarea += area;\n  if (use_lower_tri)\n  {\n    if (fabs(((REAL_T) (index + 1)) * volume) < min_volume)\n      continue;\n  }\n  else\n  {\n    if (fabs(volume) < min_volume)\n      continue;\n  }\n  totvolume += atomset(setlist, j + 1, finish, index + 1, gbsa, setarray, x, f, rborn, surfarea, maxdepth);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/intersect/3"}
{"code": "for (k = n / 2; k >= 1; k--)\n  downheap_pairs(a, n, k);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/0"}
{"code": "for (k = n / 2; k >= 1; k--)\n  downheap_index(a, n, k, x, p, dim);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/1"}
{"code": "for (i = middle - 1; i >= start; i--)\n{\n  if (x[((dim * xn[i]) + p) - 1] < median)\n  {\n    break;\n  }\n  else\n  {\n    middle = i;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/2"}
{"code": "for (i = start; i <= end; i++)\n{\n  if (yn[i] != xn[middle])\n  {\n    if (((p == 0) && (yn[i] < imedian)) || ((p != 0) && (x[((dim * yn[i]) + p) - 1] < median)))\n    {\n      tn[++lower] = yn[i];\n    }\n    else\n    {\n      tn[++upper] = yn[i];\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/3"}
{"code": "for (i = start; i <= end; i++)\n{\n  if (zn[i] != xn[middle])\n  {\n    if (((p == 0) && (zn[i] < imedian)) || ((p != 0) && (x[((dim * zn[i]) + p) - 1] < median)))\n    {\n      yn[++lower] = zn[i];\n    }\n    else\n    {\n      yn[++upper] = zn[i];\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/4"}
{"code": "for (i = start; i <= end; i++)\n{\n  if (wn[i] != xn[middle])\n  {\n    if (((p == 0) && (wn[i] < imedian)) || ((p != 0) && (x[((dim * wn[i]) + p) - 1] < median)))\n    {\n      zn[++lower] = wn[i];\n    }\n    else\n    {\n      zn[++upper] = wn[i];\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/5"}
{"code": "for (i = start; i <= end; i++)\n{\n  if (on[i] != xn[middle])\n  {\n    if (((p == 0) && (on[i] < imedian)) || ((p != 0) && (x[((dim * on[i]) + p) - 1] < median)))\n    {\n      wn[++lower] = on[i];\n    }\n    else\n    {\n      wn[++upper] = on[i];\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/6"}
{"code": "for (i = 0; i < natom; i++)\n{\n  xn[i] = (yn[i] = (zn[i] = i));\n  if (dim == 4)\n  {\n    wn[i] = i;\n  }\n  on[i] = i;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/7"}
{"code": "for (i = 0; i < natom; i++)\n{\n  locnt = (upcnt = 0);\n  searchkdtree(root, x, 0, i, &locnt, &upcnt, lopairlist, uppairlist, cutoff, cutoff2, dim, frozen);\n  heapsort_pairs(lopairlist, locnt);\n  heapsort_pairs(uppairlist, upcnt);\n  if ((pearlist[i] == 0) && ((locnt + upcnt) > 0))\n  {\n    pearlist[i] = ivector(0, locnt + upcnt);\n  }\n  else\n    if ((pearlist[i] != 0) && (((locnt + upcnt) > (lpears[i] + upears[i])) || ((4 * (locnt + upcnt)) < (3 * (lpears[i] + upears[i])))))\n  {\n    free_ivector(pearlist[i], 0, lpears[i] + upears[i]);\n    pearlist[i] = ivector(0, locnt + upcnt);\n  }\n  lpears[i] = locnt;\n  upears[i] = upcnt;\n  for (j = 0; j < locnt; j++)\n  {\n    pearlist[i][j] = lopairlist[j];\n  }\n\n  for (j = 0; j < upcnt; j++)\n  {\n    pearlist[i][locnt + j] = uppairlist[j];\n  }\n\n  totpair += locnt + upcnt;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/nblist/8"}
{"code": "for (mti = 1; mti < 624; mti++)\n{\n  mt[mti] = (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30))) + mti;\n  mt[mti] &= 0xffffffffUL;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/specrand/0"}
{"code": "for (; k; k--)\n{\n  mt[i] = ((mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525UL)) + init_key[j]) + j;\n  mt[i] &= 0xffffffffUL;\n  i++;\n  j++;\n  if (i >= 624)\n  {\n    mt[0] = mt[624 - 1];\n    i = 1;\n  }\n  if (j >= key_length)\n    j = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/specrand/1"}
{"code": "for (k = 624 - 1; k; k--)\n{\n  mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941UL)) - i;\n  mt[i] &= 0xffffffffUL;\n  i++;\n  if (i >= 624)\n  {\n    mt[0] = mt[624 - 1];\n    i = 1;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/specrand/2"}
{"code": "for (kk = 0; kk < (624 - 397); kk++)\n{\n  y = (mt[kk] & 0x80000000UL) | (mt[kk + 1] & 0x7fffffffUL);\n  mt[kk] = (mt[kk + 397] ^ (y >> 1)) ^ mag01[y & 0x1UL];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/specrand/3"}
{"code": "for (; kk < (624 - 1); kk++)\n{\n  y = (mt[kk] & 0x80000000UL) | (mt[kk + 1] & 0x7fffffffUL);\n  mt[kk] = (mt[kk + (397 - 624)] ^ (y >> 1)) ^ mag01[y & 0x1UL];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/specrand/4"}
{"code": "for (j = 32 + 7; j >= 0; j--)\n{\n  k = (*seed) / 53668;\n  *seed = (40014 * ((*seed) - (k * 53668))) - (k * 12211);\n  if ((*seed) < 0)\n    *seed += 2147483563;\n  if (j < 32)\n    iv[j] = *seed;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/rand2/0"}
{"code": "for (i = 0; i < 81; i++)\n{\n  if ((j = getc(file)) == EOF)\n  {\n    fprintf(nabout, \"Error: unexpected EOF in %s\\n\", name);\n    ier = -1;\n  }\n  else\n  {\n    string[i] = (char) j;\n    if (string[i] == '\\n')\n    {\n      string[i] = '\\0';\n      break;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/0"}
{"code": "for (i = 0; i < ((prm->Natom / 20) + ((prm->Natom % 20) ? (1) : (0))); i++)\n  preadln(file, \"\", &prm->AtomNames[i * 80]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/1"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Charges[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/2"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %e\", &prm->Masses[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/3"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->Iac[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/4"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->Iblo[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/5"}
{"code": "for (i = 0; i < prm->Ntype2d; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->Cno[i]);\n    if ((prm->Cno[i] < 0) && (!i10_12))\n    {\n      fprintf(nabout, \"     Parameter topology includes 10-12 terms:\\n\");\n      fprintf(nabout, \"     These are assumed to be zero here (e.g. from TIP3P water)\\n\");\n      i10_12 = 1;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/6"}
{"code": "for (i = 0; i < ((prm->Nres / 20) + ((prm->Nres % 20) ? (1) : (0))); i++)\n  preadln(file, \"\", &prm->ResNames[i * 80]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/7"}
{"code": "for (i = 0; i < prm->Nres; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->Ipres[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/8"}
{"code": "for (i = 0; i < prm->Numbnd; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Rk[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/9"}
{"code": "for (i = 0; i < prm->Numbnd; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Req[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/10"}
{"code": "for (i = 0; i < prm->Numang; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Tk[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/11"}
{"code": "for (i = 0; i < prm->Numang; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Teq[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/12"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Pk[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/13"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Pn[i]);\n    if (prm->Pn[i] == 0)\n    {\n      fprintf(stderr, \"Found an invalid periodicity in the prmtop file: %d\\n\", i);\n      exit(1);\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/14"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Phase[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/15"}
{"code": "for (i = 0; i < prm->Natyp; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Solty[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/16"}
{"code": "for (i = 0; i < prm->Nttyp; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Cn1[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/17"}
{"code": "for (i = 0; i < prm->Nttyp; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Cn2[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/18"}
{"code": "for (i = 0; i < prm->Nbonh; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d\", &prm->BondHAt1[i], &prm->BondHAt2[i], &prm->BondHNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/19"}
{"code": "for (i = 0; i < prm->Nbona; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d\", &prm->BondAt1[i], &prm->BondAt2[i], &prm->BondNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/20"}
{"code": "for (i = 0; i < prm->Ntheth; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d %d\", &prm->AngleHAt1[i], &prm->AngleHAt2[i], &prm->AngleHAt3[i], &prm->AngleHNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/21"}
{"code": "for (i = 0; i < prm->Ntheta; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d %d\", &prm->AngleAt1[i], &prm->AngleAt2[i], &prm->AngleAt3[i], &prm->AngleNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/22"}
{"code": "for (i = 0; i < prm->Nphih; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d %d %d\", &prm->DihHAt1[i], &prm->DihHAt2[i], &prm->DihHAt3[i], &prm->DihHAt4[i], &prm->DihHNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/23"}
{"code": "for (i = 0; i < prm->Nphia; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d %d %d %d %d\", &prm->DihAt1[i], &prm->DihAt2[i], &prm->DihAt3[i], &prm->DihAt4[i], &prm->DihNum[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/24"}
{"code": "for (i = 0; i < prm->Nnb; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->ExclAt[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/25"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->HB12[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/26"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->HB10[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/27"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &H[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/28"}
{"code": "for (i = 0; i < ((prm->Natom / 20) + ((prm->Natom % 20) ? (1) : (0))); i++)\n  preadln(file, \"\", &prm->AtomSym[i * 80]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/29"}
{"code": "for (i = 0; i < ((prm->Natom / 20) + ((prm->Natom % 20) ? (1) : (0))); i++)\n  preadln(file, \"\", &prm->AtomTree[i * 80]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/30"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->TreeJoin[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/31"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %d\", &prm->AtomRes[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/32"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if ((i + 1) == prm->Ipres[res + 1])\n    res++;\n  prm->AtomRes[i] = res;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/33"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Rborn[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/34"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  if (get_mytaskid() == 0)\n  {\n    fscanf(file, \" %f\", &prm->Fs[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/35"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  si_tmp = prm->Fs[i] * (prm->Rborn[i] - 0.09);\n  prm->Fsmax = (si_tmp > prm->Fsmax) ? (si_tmp) : (prm->Fsmax);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/36"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  atsymb = prm->AtomNames[4 * i];\n  if (atsymb == 'H')\n  {\n    prm->Fs[i] = 0.85;\n    if (i == 0)\n    {\n      atsymbp = 'O';\n    }\n    else\n    {\n      for (j = 1; j <= 3; j++)\n      {\n        atsymbp = prm->AtomNames[4 * (i - j)];\n        if (atsymbp != 'H')\n          break;\n      }\n\n    }\n    if (atsymbp == 'O')\n      prm->Rborn[i] = 0.8;\n    else\n      if (atsymbp == 'N')\n      prm->Rborn[i] = 1.2;\n    else\n      if (atsymbp == 'C')\n      prm->Rborn[i] = 1.3;\n    else\n      prm->Rborn[i] = 1.2;\n  }\n  else\n    if (atsymb == 'C')\n  {\n    prm->Fs[i] = 0.72;\n    prm->Rborn[i] = 1.70;\n  }\n  else\n    if (atsymb == 'N')\n  {\n    prm->Fs[i] = 0.79;\n    prm->Rborn[i] = 1.55;\n  }\n  else\n    if (atsymb == 'O')\n  {\n    prm->Fs[i] = 0.85;\n    prm->Rborn[i] = 1.50;\n  }\n  else\n    if (atsymb == 'F')\n  {\n    prm->Fs[i] = 0.88;\n    prm->Rborn[i] = 1.47;\n  }\n  else\n    if (atsymb == 'P')\n  {\n    prm->Fs[i] = 0.86;\n    prm->Rborn[i] = 1.85;\n  }\n  else\n    if (atsymb == 'S')\n  {\n    prm->Fs[i] = 0.96;\n    prm->Rborn[i] = 1.80;\n  }\n  else\n    if (atsymb == 'L')\n  {\n    prm->Fs[i] = 0.96;\n    prm->Rborn[i] = 1.00;\n  }\n  else\n    if (atsymb == 'Z')\n  {\n    prm->Fs[i] = 0.96;\n    prm->Rborn[i] = 1.40;\n  }\n  else\n    if (atsymb == 'M')\n  {\n    prm->Fs[i] = 0.96;\n    prm->Rborn[i] = 1.40;\n  }\n  else\n  {\n    if (get_mytaskid() == 0)\n    {\n      fprintf(stderr, \"bad atom symbol: %d, %c\\n\", i, atsymb);\n    }\n    exit(1);\n  }\n  si_tmp = prm->Fs[i] * (prm->Rborn[i] - 0.09);\n  prm->Fsmax = (si_tmp > prm->Fsmax) ? (si_tmp) : (prm->Fsmax);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/37"}
{"code": "for (i = 0; i < prm->Ntypes; i++)\n{\n  iaci = prm->Cno[(prm->Ntypes * i) + i] - 1;\n  if ((prm->Cn1[iaci] == 0.0) || (prm->Cn2[iaci] == 0.0))\n  {\n    atype[i] = 0.0;\n  }\n  else\n  {\n    sigma_iw6 = sigmaw3 * sqrt(prm->Cn1[iaci] / prm->Cn2[iaci]);\n    epsilon_iw = (0.5 * sqrt(0.155 / prm->Cn1[iaci])) * prm->Cn2[iaci];\n    atype[i] = (((((-16.) * 3.141592650) * 0.33428) * epsilon_iw) * sigma_iw6) / 3.;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/38"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  prm->Gvdw[i] = atype[prm->Iac[i] - 1];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/39"}
{"code": "for (i = 0; i < prm->Natom; i++)\n  prm->N14pairs[i] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/40"}
{"code": "for (i = 0; i < prm->Nphih; i++)\n{\n  iat = prm->DihHAt1[i] / 3;\n  kat = prm->DihHAt3[i] / 3;\n  lat = prm->DihHAt4[i] / 3;\n  if ((kat >= 0) && (lat >= 0))\n  {\n    ismall = (iat < lat) ? (iat) : (lat);\n    ibig = (iat > lat) ? (iat) : (lat);\n    iptmp[(12 * ismall) + (prm->N14pairs[ismall]++)] = ibig;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/41"}
{"code": "for (i = 0; i < prm->Mphia; i++)\n{\n  iat = prm->DihAt1[i] / 3;\n  kat = prm->DihAt3[i] / 3;\n  lat = prm->DihAt4[i] / 3;\n  if ((kat >= 0) && (lat >= 0))\n  {\n    ismall = (iat < lat) ? (iat) : (lat);\n    ibig = (iat > lat) ? (iat) : (lat);\n    iptmp[(12 * ismall) + (prm->N14pairs[ismall]++)] = ibig;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/42"}
{"code": "for (i = 0; i < (prm->Natom - 1); i++)\n{\n  for (k = 0; k < prm->N14pairs[i]; k++)\n    prm->N14pairlist[idum++] = iptmp[(12 * i) + k];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/43"}
{"code": "for (ai = 0, a = 0; a = NAB_mnext(mol, a); ai++)\n{\n  a->a_charge = prm->Charges[ai] / 18.2223;\n  a->a_radius = prm->Rborn[ai];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/44"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  strncpy(tmpchar, &prm->AtomNames[i * 4], 4);\n  tmpchar[4] = '\\0';\n  FortranWriteString(tmpchar);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/45"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteDouble(prm->Charges[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/46"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteDouble(prm->Masses[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/47"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteInt(prm->Iac[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/48"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteInt(prm->Iblo[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/49"}
{"code": "for (i = 0; i < prm->Ntype2d; i++)\n{\n  FortranWriteInt(prm->Cno[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/50"}
{"code": "for (i = 0; i < prm->Nres; i++)\n{\n  strncpy(tmpchar, &prm->ResNames[i * 4], 3);\n  tmpchar[3] = ' ';\n  tmpchar[4] = '\\0';\n  FortranWriteString(tmpchar);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/51"}
{"code": "for (i = 0; i < prm->Nres; i++)\n{\n  FortranWriteInt(prm->Ipres[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/52"}
{"code": "for (i = 0; i < prm->Numbnd; i++)\n{\n  FortranWriteDouble(prm->Rk[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/53"}
{"code": "for (i = 0; i < prm->Numbnd; i++)\n{\n  FortranWriteDouble(prm->Req[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/54"}
{"code": "for (i = 0; i < prm->Numang; i++)\n{\n  FortranWriteDouble(prm->Tk[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/55"}
{"code": "for (i = 0; i < prm->Numang; i++)\n{\n  FortranWriteDouble(prm->Teq[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/56"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  FortranWriteDouble(prm->Pk[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/57"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  FortranWriteDouble(prm->Pn[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/58"}
{"code": "for (i = 0; i < prm->Nptra; i++)\n{\n  FortranWriteDouble(prm->Phase[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/59"}
{"code": "for (i = 0; i < prm->Natyp; i++)\n{\n  FortranWriteDouble(0.0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/60"}
{"code": "for (i = 0; i < prm->Nttyp; i++)\n{\n  FortranWriteDouble(prm->Cn1[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/61"}
{"code": "for (i = 0; i < prm->Nttyp; i++)\n{\n  FortranWriteDouble(prm->Cn2[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/62"}
{"code": "for (i = 0; i < prm->Nbonh; i++)\n{\n  FortranWriteInt(prm->BondHAt1[i]);\n  FortranWriteInt(prm->BondHAt2[i]);\n  FortranWriteInt(prm->BondHNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/63"}
{"code": "for (i = 0; i < prm->Nbona; i++)\n{\n  FortranWriteInt(prm->BondAt1[i]);\n  FortranWriteInt(prm->BondAt2[i]);\n  FortranWriteInt(prm->BondNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/64"}
{"code": "for (i = 0; i < prm->Ntheth; i++)\n{\n  FortranWriteInt(prm->AngleHAt1[i]);\n  FortranWriteInt(prm->AngleHAt2[i]);\n  FortranWriteInt(prm->AngleHAt3[i]);\n  FortranWriteInt(prm->AngleHNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/65"}
{"code": "for (i = 0; i < prm->Ntheta; i++)\n{\n  FortranWriteInt(prm->AngleAt1[i]);\n  FortranWriteInt(prm->AngleAt2[i]);\n  FortranWriteInt(prm->AngleAt3[i]);\n  FortranWriteInt(prm->AngleNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/66"}
{"code": "for (i = 0; i < prm->Nphih; i++)\n{\n  FortranWriteInt(prm->DihHAt1[i]);\n  FortranWriteInt(prm->DihHAt2[i]);\n  FortranWriteInt(prm->DihHAt3[i]);\n  FortranWriteInt(prm->DihHAt4[i]);\n  FortranWriteInt(prm->DihHNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/67"}
{"code": "for (i = 0; i < prm->Nphia; i++)\n{\n  FortranWriteInt(prm->DihAt1[i]);\n  FortranWriteInt(prm->DihAt2[i]);\n  FortranWriteInt(prm->DihAt3[i]);\n  FortranWriteInt(prm->DihAt4[i]);\n  FortranWriteInt(prm->DihNum[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/68"}
{"code": "for (i = 0; i < prm->Nnb; i++)\n{\n  FortranWriteInt(prm->ExclAt[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/69"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  FortranWriteDouble(prm->HB12[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/70"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  FortranWriteDouble(prm->HB10[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/71"}
{"code": "for (i = 0; i < prm->Nphb; i++)\n{\n  FortranWriteDouble(0.0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/72"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  strncpy(tmpchar, &prm->AtomSym[i * 4], 2);\n  tmpchar[2] = (tmpchar[3] = ' ');\n  tmpchar[4] = '\\0';\n  FortranWriteString(tmpchar);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/73"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  strncpy(tmpchar, &prm->AtomTree[i * 4], 2);\n  tmpchar[2] = (tmpchar[3] = ' ');\n  tmpchar[4] = '\\0';\n  FortranWriteString(tmpchar);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/74"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteInt(prm->TreeJoin[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/75"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteInt(0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/76"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteDouble(prm->Rborn[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/77"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  FortranWriteDouble(prm->Fs[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/prm/78"}
{"code": "for (i = threadnum; i < prm->Natom; i += numthreads)\n{\n  if (constrained[i])\n  {\n    rx = x[dim * i] - x0[dim * i];\n    ry = x[(dim * i) + 1] - x0[(dim * i) + 1];\n    rz = x[(dim * i) + 2] - x0[(dim * i) + 2];\n    e_cons += wcons * (((rx * rx) + (ry * ry)) + (rz * rz));\n    f[foff + (dim * i)] += (2. * wcons) * rx;\n    f[(foff + (dim * i)) + 1] += (2. * wcons) * ry;\n    f[(foff + (dim * i)) + 2] += (2. * wcons) * rz;\n    if (dim == 4)\n    {\n      rw = x[(dim * i) + 3] - x0[(dim * i) + 3];\n      e_cons += (wcons * rw) * rw;\n      f[(foff + (dim * i)) + 3] += (2. * wcons) * rw;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/0"}
{"code": "for (i = threadnum; i < nbond; i += numthreads)\n{\n  at1 = (dim * a1[i]) / 3;\n  at2 = (dim * a2[i]) / 3;\n  atyp = atype[i] - 1;\n  rx = x[at1] - x[at2];\n  ry = x[at1 + 1] - x[at2 + 1];\n  rz = x[at1 + 2] - x[at2 + 2];\n  r2 = ((rx * rx) + (ry * ry)) + (rz * rz);\n  if (dim == 4)\n  {\n    rw = x[at1 + 3] - x[at2 + 3];\n    r2 += rw * rw;\n  }\n  s = sqrt(r2);\n  r = 2.0 / s;\n  db = s - Req[atyp];\n  df = Rk[atyp] * db;\n  e = df * db;\n  e_bond += e;\n  df *= r;\n  f[(foff + at1) + 0] += rx * df;\n  f[(foff + at1) + 1] += ry * df;\n  f[(foff + at1) + 2] += rz * df;\n  f[(foff + at2) + 0] -= rx * df;\n  f[(foff + at2) + 1] -= ry * df;\n  f[(foff + at2) + 2] -= rz * df;\n  if (dim == 4)\n  {\n    f[(foff + at1) + 3] += rw * df;\n    f[(foff + at2) + 3] -= rw * df;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/1"}
{"code": "for (i = threadnum; i < nang; i += numthreads)\n{\n  at1 = (dim * a1[i]) / 3;\n  at2 = (dim * a2[i]) / 3;\n  at3 = (dim * a3[i]) / 3;\n  atyp = atype[i] - 1;\n  dxi = x[at1] - x[at2];\n  dyi = x[at1 + 1] - x[at2 + 1];\n  dzi = x[at1 + 2] - x[at2 + 2];\n  dxj = x[at3] - x[at2];\n  dyj = x[at3 + 1] - x[at2 + 1];\n  dzj = x[at3 + 2] - x[at2 + 2];\n  ri2 = ((dxi * dxi) + (dyi * dyi)) + (dzi * dzi);\n  rj2 = ((dxj * dxj) + (dyj * dyj)) + (dzj * dzj);\n  if (dim == 4)\n  {\n    dwi = x[at1 + 3] - x[at2 + 3];\n    dwj = x[at3 + 3] - x[at2 + 3];\n    ri2 += dwi * dwi;\n    rj2 += dwj * dwj;\n  }\n  ri = sqrt(ri2);\n  rj = sqrt(rj2);\n  rir = 1. / ri;\n  rjr = 1. / rj;\n  dxir = dxi * rir;\n  dyir = dyi * rir;\n  dzir = dzi * rir;\n  dxjr = dxj * rjr;\n  dyjr = dyj * rjr;\n  dzjr = dzj * rjr;\n  cst = ((dxir * dxjr) + (dyir * dyjr)) + (dzir * dzjr);\n  if (dim == 4)\n  {\n    dwir = dwi * rir;\n    dwjr = dwj * rjr;\n    cst += dwir * dwjr;\n  }\n  if (cst > 1.0)\n    cst = 1.0;\n  if (cst < (-1.0))\n    cst = -1.0;\n  at = acos(cst);\n  da = at - Teq[atyp];\n  df = da * Tk[atyp];\n  e = df * da;\n  e_theta = e_theta + e;\n  df = df + df;\n  at = sin(at);\n  if ((at > 0) && (at < 1.e-3))\n    at = 1.e-3;\n  else\n    if ((at < 0) && (at > (-1.e-3)))\n    at = -1.e-3;\n  df = (-df) / at;\n  xtmp = (df * rir) * (dxjr - (cst * dxir));\n  dxtmp = (df * rjr) * (dxir - (cst * dxjr));\n  ytmp = (df * rir) * (dyjr - (cst * dyir));\n  dytmp = (df * rjr) * (dyir - (cst * dyjr));\n  ztmp = (df * rir) * (dzjr - (cst * dzir));\n  dztmp = (df * rjr) * (dzir - (cst * dzjr));\n  f[(foff + at1) + 0] += xtmp;\n  f[(foff + at3) + 0] += dxtmp;\n  f[(foff + at2) + 0] -= xtmp + dxtmp;\n  f[(foff + at1) + 1] += ytmp;\n  f[(foff + at3) + 1] += dytmp;\n  f[(foff + at2) + 1] -= ytmp + dytmp;\n  f[(foff + at1) + 2] += ztmp;\n  f[(foff + at3) + 2] += dztmp;\n  f[(foff + at2) + 2] -= ztmp + dztmp;\n  if (dim == 4)\n  {\n    wtmp = (df * rir) * (dwjr - (cst * dwir));\n    dwtmp = (df * rjr) * (dwir - (cst * dwjr));\n    f[(foff + at1) + 3] += wtmp;\n    f[(foff + at3) + 3] += dwtmp;\n    f[(foff + at2) + 3] -= wtmp + dwtmp;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/2"}
{"code": "for (i = threadnum; i < nphi; i += numthreads)\n{\n  at1 = (dim * a1[i]) / 3;\n  at2 = (dim * a2[i]) / 3;\n  at3 = (dim * abs(a3[i])) / 3;\n  at4 = (dim * abs(a4[i])) / 3;\n  atyp = atype[i] - 1;\n  ax = x[at2 + 0] - x[at1 + 0];\n  ay = x[at2 + 1] - x[at1 + 1];\n  az = x[at2 + 2] - x[at1 + 2];\n  bx = x[at3 + 0] - x[at2 + 0];\n  by = x[at3 + 1] - x[at2 + 1];\n  bz = x[at3 + 2] - x[at2 + 2];\n  cx = x[at4 + 0] - x[at3 + 0];\n  cy = x[at4 + 1] - x[at3 + 1];\n  cz = x[at4 + 2] - x[at3 + 2];\n  if (dim == 4)\n  {\n    aw = x[at2 + 3] - x[at1 + 3];\n    bw = x[at3 + 3] - x[at2 + 3];\n    cw = x[at4 + 3] - x[at3 + 3];\n    ab = (((ax * bx) + (ay * by)) + (az * bz)) + (aw * bw);\n    bc = (((bx * cx) + (by * cy)) + (bz * cz)) + (bw * cw);\n    ac = (((ax * cx) + (ay * cy)) + (az * cz)) + (aw * cw);\n    aa = (((ax * ax) + (ay * ay)) + (az * az)) + (aw * aw);\n    bb = (((bx * bx) + (by * by)) + (bz * bz)) + (bw * bw);\n    cc = (((cx * cx) + (cy * cy)) + (cz * cz)) + (cw * cw);\n  }\n  else\n  {\n    ab = ((ax * bx) + (ay * by)) + (az * bz);\n    bc = ((bx * cx) + (by * cy)) + (bz * cz);\n    ac = ((ax * cx) + (ay * cy)) + (az * cz);\n    aa = ((ax * ax) + (ay * ay)) + (az * az);\n    bb = ((bx * bx) + (by * by)) + (bz * bz);\n    cc = ((cx * cx) + (cy * cy)) + (cz * cz);\n  }\n  uu = (aa * bb) - (ab * ab);\n  vv = (bb * cc) - (bc * bc);\n  uv = (ab * bc) - (ac * bb);\n  den = 1.0 / sqrt(uu * vv);\n  co = uv * den;\n  co1 = (0.5 * co) * den;\n  a0x = ((-bc) * bx) + (bb * cx);\n  a0y = ((-bc) * by) + (bb * cy);\n  a0z = ((-bc) * bz) + (bb * cz);\n  b0x = ((ab * cx) + (bc * ax)) - ((2. * ac) * bx);\n  b0y = ((ab * cy) + (bc * ay)) - ((2. * ac) * by);\n  b0z = ((ab * cz) + (bc * az)) - ((2. * ac) * bz);\n  c0x = (ab * bx) - (bb * ax);\n  c0y = (ab * by) - (bb * ay);\n  c0z = (ab * bz) - (bb * az);\n  a1x = (2. * uu) * (((-cc) * bx) + (bc * cx));\n  a1y = (2. * uu) * (((-cc) * by) + (bc * cy));\n  a1z = (2. * uu) * (((-cc) * bz) + (bc * cz));\n  b1x = (2. * uu) * ((bb * cx) - (bc * bx));\n  b1y = (2. * uu) * ((bb * cy) - (bc * by));\n  b1z = (2. * uu) * ((bb * cz) - (bc * bz));\n  a2x = ((-2.) * vv) * ((bb * ax) - (ab * bx));\n  a2y = ((-2.) * vv) * ((bb * ay) - (ab * by));\n  a2z = ((-2.) * vv) * ((bb * az) - (ab * bz));\n  b2x = (2. * vv) * ((aa * bx) - (ab * ax));\n  b2y = (2. * vv) * ((aa * by) - (ab * ay));\n  b2z = (2. * vv) * ((aa * bz) - (ab * az));\n  dd1x = (a0x - (a2x * co1)) * den;\n  dd1y = (a0y - (a2y * co1)) * den;\n  dd1z = (a0z - (a2z * co1)) * den;\n  dd2x = (((-a0x) - b0x) - (((a1x - a2x) - b2x) * co1)) * den;\n  dd2y = (((-a0y) - b0y) - (((a1y - a2y) - b2y) * co1)) * den;\n  dd2z = (((-a0z) - b0z) - (((a1z - a2z) - b2z) * co1)) * den;\n  dd3x = ((b0x - c0x) - ((((-a1x) - b1x) + b2x) * co1)) * den;\n  dd3y = ((b0y - c0y) - ((((-a1y) - b1y) + b2y) * co1)) * den;\n  dd3z = ((b0z - c0z) - ((((-a1z) - b1z) + b2z) * co1)) * den;\n  dd4x = (c0x - (b1x * co1)) * den;\n  dd4y = (c0y - (b1y * co1)) * den;\n  dd4z = (c0z - (b1z * co1)) * den;\n  if (dim == 4)\n  {\n    a0w = ((-bc) * bw) + (bb * cw);\n    b0w = ((ab * cw) + (bc * aw)) - ((2. * ac) * bw);\n    c0w = (ab * bw) - (bb * aw);\n    a1w = (2. * uu) * (((-cc) * bw) + (bc * cw));\n    b1w = (2. * uu) * ((bb * cw) - (bc * bw));\n    a2w = ((-2.) * vv) * ((bb * aw) - (ab * bw));\n    b2w = (2. * vv) * ((aa * bw) - (ab * aw));\n    dd1w = (a0w - (a2w * co1)) * den;\n    dd2w = (((-a0w) - b0w) - (((a1w - a2w) - b2w) * co1)) * den;\n    dd3w = ((b0w - c0w) - ((((-a1w) - b1w) + b2w) * co1)) * den;\n    dd4w = (c0w - (b1w * co1)) * den;\n  }\n  if (prm->Nhparm && (a3[i] < 0))\n  {\n    co = (co > 1.0) ? (1.0) : (co);\n    co = (co < (-1.0)) ? (-1.0) : (co);\n    phi = acos(co);\n    ux = (ay * bz) - (az * by);\n    uy = (az * bx) - (ax * bz);\n    uz = (ax * by) - (ay * bx);\n    vx = (by * cz) - (bz * cy);\n    vy = (bz * cx) - (bx * cz);\n    vz = (bx * cy) - (by * cx);\n    dx1 = (uy * vz) - (uz * vy);\n    dy1 = (uz * vx) - (ux * vz);\n    dz1 = (ux * vy) - (uy * vx);\n    dx1 = ((dx1 * bx) + (dy1 * by)) + (dz1 * bz);\n    if (dx1 < 0.0)\n      phi = -phi;\n    delta = phi - Phase[atyp];\n    delta = (delta > pi) ? (pi) : (delta);\n    delta = (delta < (-pi)) ? (-pi) : (delta);\n    df = Pk[atyp] * delta;\n    e = df * delta;\n    e_tors += e;\n    yy = sin(phi);\n    if (fabs(yy) > 0.001)\n    {\n      df = ((-2.0) * df) / yy;\n    }\n    else\n    {\n      if (fabs(delta) < 0.10)\n      {\n        if (Phase[atyp] == 0.0)\n        {\n          df = ((-2.0) * Pk[atyp]) * (1 + ((phi * phi) / 6.0));\n        }\n        else\n        {\n          if (fabs(Phase[atyp]) == pi)\n          {\n            df = (2.0 * Pk[atyp]) * (1 + ((delta * delta) / 6.0));\n          }\n        }\n      }\n      else\n      {\n        if (((phi > 0.0) && (phi < (pi / 2.0))) || ((phi < 0.0) && (phi > ((-pi) / 2.0))))\n          df = df * 1000.;\n        else\n          df = (-df) * 1000.;\n      }\n    }\n  }\n  else\n  {\n    multi_term:\n    if (fabs(Phase[atyp] - 3.142) < 0.01)\n      phase = -1.0;\n    else\n      phase = 1.0;\n\n    ktors = Pk[atyp];\n    switch ((int) fabs(Pn[atyp]))\n    {\n      case 1:\n        e = ktors * (1.0 + (phase * co));\n        df = phase * ktors;\n        break;\n\n      case 2:\n        e = ktors * (1.0 + (phase * (((2. * co) * co) - 1.)));\n        df = ((phase * ktors) * 4.) * co;\n        break;\n\n      case 3:\n        cosq = co * co;\n        e = ktors * (1.0 + ((phase * co) * ((4. * cosq) - 3.)));\n        df = (phase * ktors) * ((12. * cosq) - 3.);\n        break;\n\n      case 4:\n        cosq = co * co;\n        e = ktors * (1.0 + (phase * (((8. * cosq) * (cosq - 1.)) + 1.)));\n        df = ((phase * ktors) * co) * ((32. * cosq) - 16.);\n        break;\n\n      case 6:\n        cosq = co * co;\n        e = ktors * (1.0 + (phase * ((((((32. * cosq) * cosq) * cosq) - ((48. * cosq) * cosq)) + (18. * cosq)) - 1.)));\n        df = ((phase * ktors) * co) * ((((192. * cosq) * cosq) - (192. * cosq)) + 36.);\n        break;\n\n      default:\n        fprintf(stderr, \"bad value for Pn: %d %d %d %d %8.3f\\n\", at1, at2, at3, at4, Pn[atyp]);\n        exit(1);\n\n    }\n\n    e_tors += e;\n  }\n  f[(foff + at1) + 0] += df * dd1x;\n  f[(foff + at1) + 1] += df * dd1y;\n  f[(foff + at1) + 2] += df * dd1z;\n  f[(foff + at2) + 0] += df * dd2x;\n  f[(foff + at2) + 1] += df * dd2y;\n  f[(foff + at2) + 2] += df * dd2z;\n  f[(foff + at3) + 0] += df * dd3x;\n  f[(foff + at3) + 1] += df * dd3y;\n  f[(foff + at3) + 2] += df * dd3z;\n  f[(foff + at4) + 0] += df * dd4x;\n  f[(foff + at4) + 1] += df * dd4y;\n  f[(foff + at4) + 2] += df * dd4z;\n  if (dim == 4)\n  {\n    f[(foff + at1) + 3] += df * dd1w;\n    f[(foff + at2) + 3] += df * dd2w;\n    f[(foff + at3) + 3] += df * dd3w;\n    f[(foff + at4) + 3] += df * dd4w;\n  }\n  if (Pn[atyp] < 0.0)\n  {\n    atyp++;\n    goto multi_term;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/3"}
{"code": "for (i = -1; i < prm->Natom; i++)\n{\n  iexw[i] = -1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/4"}
{"code": "for (i = 0; i < (prm->Natom - 1); i++)\n{\n  npr = upears[i];\n  if (npr <= 0)\n    continue;\n  iaci = prm->Ntypes * (prm->Iac[i] - 1);\n  cgi = eelfaci * prm->Charges[i];\n  dumx = (dumy = (dumz = 0.0));\n  i34 = dim * i;\n  xi = x[i34 + 0];\n  yi = x[i34 + 1];\n  zi = x[i34 + 2];\n  if (dim == 4)\n  {\n    dumw = 0.0;\n    wi = x[i34 + 3];\n  }\n  for (j = 0; j < prm->Iblo[i]; j++)\n  {\n    iexw[IexclAt[i][j] - 1] = i;\n  }\n\n  if (N14 == 0)\n  {\n    lpair = lpears[i];\n  }\n  else\n  {\n    lpair = 0;\n  }\n  for (k = 0; k < npr; k++)\n  {\n    if (pearlist[i] == 0)\n    {\n      fprintf(nabout, \"NULL pair list entry in nbond loop 1, taskid = %d\\n\", mytaskid);\n      fflush(nabout);\n    }\n    j = pearlist[i][lpair + k];\n    j34 = dim * j;\n    if ((N14 != 0) || (iexw[j] != i))\n    {\n      xij = xi - x[j34 + 0];\n      yij = yi - x[j34 + 1];\n      zij = zi - x[j34 + 2];\n      r2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n      if (dim == 4)\n      {\n        wij = wi - x[j34 + 3];\n        r2 += wij * wij;\n      }\n      r2inv = 1.0 / r2;\n      r = sqrt(r2);\n      rinv = r * r2inv;\n      if (dield == (-3))\n      {\n        rs = 0.3 * r;\n        rssq = rs * rs;\n        pow = exp(-rs);\n        eps1 = ((rssq + rs) + rs) + 2.0;\n        epsi = 1.0 / (78.0 - ((38.5 * pow) * eps1));\n        cgijr = ((cgi * prm->Charges[j]) * rinv) * epsi;\n        elec += cgijr;\n        df2 = (-cgijr) * (1.0 + ((((38.5 * pow) * rs) * rssq) * epsi));\n        ic = prm->Cno[(iaci + prm->Iac[j]) - 1] - 1;\n        if (ic >= 0)\n        {\n          r6 = (r2inv * r2inv) * r2inv;\n          f2 = prm->Cn2[ic] * r6;\n          f1 = (prm->Cn1[ic] * r6) * r6;\n          evdw += (f1 - f2) * enbfaci;\n          df = (df2 + (((6.0 * f2) - (12.0 * f1)) * enbfaci)) * rinv;\n        }\n        else\n        {\n          df = df2 * rinv;\n        }\n      }\n      else\n        if (dield == (-4))\n      {\n        rs = (cgi * prm->Charges[j]) * r2inv;\n        df2 = (-2.0) * rs;\n        elec += rs;\n        ic = prm->Cno[(iaci + prm->Iac[j]) - 1] - 1;\n        if (ic >= 0)\n        {\n          r6 = (r2inv * r2inv) * r2inv;\n          f2 = prm->Cn2[ic] * r6;\n          f1 = (prm->Cn1[ic] * r6) * r6;\n          evdw += (f1 - f2) * enbfaci;\n          df = (df2 + (((6.0 * f2) - (12.0 * f1)) * enbfaci)) * rinv;\n        }\n        else\n        {\n          df = df2 * rinv;\n        }\n      }\n      else\n        if (dield == (-5))\n      {\n        dis = r;\n        ic = prm->Cno[(iaci + prm->Iac[j]) - 1] - 1;\n        d0 = prm->Cn2[ic];\n        if (dis < d0)\n        {\n          kij = prm->Cn1[ic];\n          diff = dis - d0;\n          evdw += (kij * diff) * diff;\n          df = (2.0 * kij) * diff;\n        }\n        else\n        {\n          df = 0.0;\n        }\n      }\n      else\n      {\n        if (dield == 0)\n        {\n          rs = (cgi * prm->Charges[j]) * r2inv;\n          df2 = (-2.0) * rs;\n          elec += rs;\n        }\n        else\n          if (dield == 1)\n        {\n          rs = (cgi * prm->Charges[j]) * rinv;\n          df2 = -rs;\n          elec += rs;\n        }\n        else\n          if (dield == (-2))\n        {\n          rs = 0.3 * r;\n          rssq = rs * rs;\n          pow = exp(-rs);\n          eps1 = ((rssq + rs) + rs) + 2.0;\n          epsi = 1.0 / (78.0 - ((38.5 * pow) * eps1));\n          cgijr = ((cgi * prm->Charges[j]) * rinv) * epsi;\n          elec += cgijr;\n          df2 = (-cgijr) * (1.0 + ((((38.5 * pow) * rs) * rssq) * epsi));\n        }\n        ic = prm->Cno[(iaci + prm->Iac[j]) - 1];\n        if ((ic > 0) || (enbfac != 1.0))\n        {\n          if (ic > 0)\n          {\n            ic--;\n          }\n          else\n          {\n            ibig = (prm->Iac[i] > prm->Iac[j]) ? (prm->Iac[i]) : (prm->Iac[j]);\n            isml = (prm->Iac[i] > prm->Iac[j]) ? (prm->Iac[j]) : (prm->Iac[i]);\n            ic = (((ibig * (ibig - 1)) / 2) + isml) - 1;\n          }\n          r6 = (r2inv * r2inv) * r2inv;\n          f2 = prm->Cn2[ic] * r6;\n          f1 = (prm->Cn1[ic] * r6) * r6;\n          evdw += (f1 - f2) * enbfaci;\n          df = (df2 + (((6.0 * f2) - (12.0 * f1)) * enbfaci)) * rinv;\n        }\n        else\n        {\n          ic = (-ic) - 1;\n          r10 = (((r2inv * r2inv) * r2inv) * r2inv) * r2inv;\n          f2 = prm->HB10[ic] * r10;\n          f1 = (prm->HB12[ic] * r10) * r2inv;\n          evdw += (f1 - f2) * enbfaci;\n          df = (df2 + (((10.0 * f2) - (12.0 * f1)) * enbfaci)) * rinv;\n        }\n      }\n      df *= rinv;\n      dedx = df * xij;\n      dedy = df * yij;\n      dedz = df * zij;\n      dumx += dedx;\n      dumy += dedy;\n      dumz += dedz;\n      if (N14 != 0)\n      {\n        f[(foff + j34) + 0] -= dedx;\n        f[(foff + j34) + 1] -= dedy;\n        f[(foff + j34) + 2] -= dedz;\n      }\n      else\n      {\n        f[(foff + j34) + 0] -= dedx;\n        f[(foff + j34) + 1] -= dedy;\n        f[(foff + j34) + 2] -= dedz;\n      }\n      if (dim == 4)\n      {\n        dedw = df * wij;\n        dumw += dedw;\n        if (N14 != 0)\n        {\n          f[(foff + j34) + 3] -= dedw;\n        }\n        else\n        {\n          f[(foff + j34) + 3] -= dedw;\n        }\n      }\n    }\n  }\n\n  f[(foff + i34) + 0] += dumx;\n  f[(foff + i34) + 1] += dumy;\n  f[(foff + i34) + 2] += dumz;\n  if (dim == 4)\n  {\n    f[(foff + i34) + 3] += dumw;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/5"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  xi = x[dim * i];\n  yi = x[(dim * i) + 1];\n  zi = x[(dim * i) + 2];\n  if (dim == 4)\n  {\n    wi = x[(dim * i) + 3];\n  }\n  ri = rborn[i] - 0.09;\n  ri1i = 1. / ri;\n  sumi = 0.0;\n  for (k = 0; k < (lpears[i] + upears[i]); k++)\n  {\n    if (pearlist[i] == 0)\n    {\n      fprintf(nabout, \"NULL pair list entry in egb loop 1, taskid = %d\\n\", mytaskid);\n      fflush(nabout);\n    }\n    j = pearlist[i][k];\n    xij = xi - x[dim * j];\n    yij = yi - x[(dim * j) + 1];\n    zij = zi - x[(dim * j) + 2];\n    r2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n    if (dim == 4)\n    {\n      wij = wi - x[(dim * j) + 3];\n      r2 += wij * wij;\n    }\n    if (r2 > rgbmaxpsmax2)\n      continue;\n    dij1i = 1.0 / sqrt(r2);\n    dij = r2 * dij1i;\n    sj = fs[j] * (rborn[j] - 0.09);\n    sj2 = sj * sj;\n    if (dij > (rgbmax + sj))\n      continue;\n    if (dij > (rgbmax - sj))\n    {\n      uij = 1. / (dij - sj);\n      sumi -= (0.125 * dij1i) * (((1.0 + ((2.0 * dij) * uij)) + (rgbmax2i * ((r2 - ((4.0 * rgbmax) * dij)) - sj2))) + (2.0 * log((dij - sj) * rgbmax1i)));\n    }\n    else\n      if (dij > (4.0 * sj))\n    {\n      dij2i = dij1i * dij1i;\n      tmpsd = sj2 * dij2i;\n      dumbo = 0.33333333333333333333 + (tmpsd * (0.4 + (tmpsd * (0.42857142857142857143 + (tmpsd * (0.44444444444444444444 + (tmpsd * 0.45454545454545454545)))))));\n      sumi -= ((sj * tmpsd) * dij2i) * dumbo;\n    }\n    else\n      if (dij > (ri + sj))\n    {\n      sumi -= 0.5 * ((sj / (r2 - sj2)) + ((0.5 * dij1i) * log((dij - sj) / (dij + sj))));\n    }\n    else\n      if (dij > fabs(ri - sj))\n    {\n      theta = ((0.5 * ri1i) * dij1i) * ((r2 + (ri * ri)) - sj2);\n      uij = 1. / (dij + sj);\n      sumi -= 0.25 * (((ri1i * (2. - theta)) - uij) + (dij1i * log(ri * uij)));\n    }\n    else\n      if (ri < sj)\n    {\n      sumi -= 0.5 * (((sj / (r2 - sj2)) + (2. * ri1i)) + ((0.5 * dij1i) * log((sj - dij) / (sj + dij))));\n    }\n  }\n\n  if (gb == 1)\n  {\n    reff[i] = 1.0 / (ri1i + sumi);\n    if (reff[i] < 0.0)\n      reff[i] = 30.0;\n  }\n  else\n  {\n    psi[i] = (-ri) * sumi;\n    reff[i] = 1.0 / (ri1i - (tanh(((gbalpha - (gbbeta * psi[i])) + ((gbgamma * psi[i]) * psi[i])) * psi[i]) / rborn[i]));\n  }\n  if (gb_debug)\n    fprintf(nabout, \"%d\\t%15.7f\\t%15.7f\\n\", i + 1, rborn[i], reff[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/6"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  sumdeijda[soff + i] = 0.0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/7"}
{"code": "for (i = -1; i < prm->Natom; i++)\n{\n  iexw[eoff + i] = -1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/8"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  ri = reff[i];\n  qi = q[i];\n  if (!frozen[i])\n  {\n    expmkf = exp(((-0.73) * (*kappa)) * ri) / (*diel_ext);\n    dielfac = 1.0 - expmkf;\n    qi2h = (0.5 * qi) * qi;\n    qid2h = qi2h * dielfac;\n    epol += (-qid2h) / ri;\n    vdwterm = 0.0;\n    vdwdenom = 1.0;\n    sumdeijda[soff + i] += (qid2h - ((((0.73 * (*kappa)) * qi2h) * expmkf) * ri)) + vdwterm;\n  }\n  npairs = upears[i];\n  if (npairs <= 0)\n    continue;\n  i34 = dim * i;\n  xi = x[i34];\n  yi = x[i34 + 1];\n  zi = x[i34 + 2];\n  if (dim == 4)\n  {\n    wi = x[i34 + 3];\n  }\n  iaci = prm->Ntypes * (prm->Iac[i] - 1);\n  for (j = 0; j < prm->Iblo[i]; j++)\n  {\n    iexw[(eoff + IexclAt[i][j]) - 1] = i;\n  }\n\n  daix = (daiy = (daiz = (daiw = 0.0)));\n  for (k = lpears[i]; k < (lpears[i] + npairs); k++)\n  {\n    if (pearlist[i] == 0)\n    {\n      fprintf(nabout, \"NULL pair list entry in egb loop 3, taskid = %d\\n\", mytaskid);\n      fflush(nabout);\n    }\n    j = pearlist[i][k];\n    j34 = dim * j;\n    xij = xi - x[j34];\n    yij = yi - x[j34 + 1];\n    zij = zi - x[j34 + 2];\n    r2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n    if (dim == 4)\n    {\n      wij = wi - x[j34 + 3];\n      r2 += wij * wij;\n    }\n    qiqj = qi * q[j];\n    rj = reff[j];\n    rb2 = ri * rj;\n    efac = exp((-r2) / (4.0 * rb2));\n    fgbi = 1.0 / sqrt(r2 + (rb2 * efac));\n    fgbk = ((-(*kappa)) * 0.73) / fgbi;\n    expmkf = exp(fgbk) / (*diel_ext);\n    dielfac = 1.0 - expmkf;\n    epol += ((-qiqj) * dielfac) * fgbi;\n    temp4 = (fgbi * fgbi) * fgbi;\n    temp6 = (qiqj * temp4) * (dielfac + (fgbk * expmkf));\n    de = temp6 * (1.0 - (0.25 * efac));\n    temp5 = ((0.5 * efac) * temp6) * (rb2 + (0.25 * r2));\n    sumdeijda[soff + i] += ri * temp5;\n    sumdeijda[soff + j] += rj * temp5;\n    if (iexw[eoff + j] != i)\n    {\n      rinv = 1. / sqrt(r2);\n      r2inv = rinv * rinv;\n      eel = qiqj * rinv;\n      elec += eel;\n      de -= eel * r2inv;\n      ic = prm->Cno[(iaci + prm->Iac[j]) - 1] - 1;\n      if (ic >= 0)\n      {\n        r6inv = (r2inv * r2inv) * r2inv;\n        f6 = prm->Cn2[ic] * r6inv;\n        f12 = (prm->Cn1[ic] * r6inv) * r6inv;\n        evdw += f12 - f6;\n        de -= ((12. * f12) - (6. * f6)) * r2inv;\n      }\n    }\n    dedx = de * xij;\n    dedy = de * yij;\n    dedz = de * zij;\n    daix += dedx;\n    daiy += dedy;\n    daiz += dedz;\n    if (dim == 4)\n    {\n      dedw = de * wij;\n      daiw += dedw;\n    }\n    f[foff + j34] -= dedx;\n    f[(foff + j34) + 1] -= dedy;\n    f[(foff + j34) + 2] -= dedz;\n    if (dim == 4)\n    {\n      f[(foff + j34) + 3] -= dedw;\n    }\n  }\n\n  f[foff + i34] += daix;\n  f[(foff + i34) + 1] += daiy;\n  f[(foff + i34) + 2] += daiz;\n  if (dim == 4)\n  {\n    f[(foff + i34) + 3] += daiw;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/9"}
{"code": "for (i = 0; i < prm->Natom; i++)\n{\n  npairs = lpears[i] + upears[i];\n  if (frozen[i] || (npairs <= 0))\n    continue;\n  i34 = dim * i;\n  xi = x[i34];\n  yi = x[i34 + 1];\n  zi = x[i34 + 2];\n  if (dim == 4)\n  {\n    wi = x[i34 + 3];\n  }\n  ri = rborn[i] - 0.09;\n  ri1i = 1. / ri;\n  sumda = sumdeijda[i];\n  if (gb > 1)\n  {\n    ri = rborn[i] - 0.09;\n    thi = tanh(((gbalpha - (gbbeta * psi[i])) + ((gbgamma * psi[i]) * psi[i])) * psi[i]);\n    sumda *= ((((gbalpha - ((2.0 * gbbeta) * psi[i])) + (((3.0 * gbgamma) * psi[i]) * psi[i])) * (1.0 - (thi * thi))) * ri) / rborn[i];\n  }\n  daix = (daiy = (daiz = (daiw = 0.0)));\n  for (k = 0; k < npairs; k++)\n  {\n    if (pearlist[i] == 0)\n    {\n      fprintf(nabout, \"NULL pair list entry in egb loop 5, taskid = %d\\n\", mytaskid);\n      fflush(nabout);\n    }\n    j = pearlist[i][k];\n    j34 = dim * j;\n    xij = xi - x[j34];\n    yij = yi - x[j34 + 1];\n    zij = zi - x[j34 + 2];\n    r2 = ((xij * xij) + (yij * yij)) + (zij * zij);\n    if (dim == 4)\n    {\n      wij = wi - x[j34 + 3];\n      r2 += wij * wij;\n    }\n    if (r2 > rgbmaxpsmax2)\n      continue;\n    dij1i = 1.0 / sqrt(r2);\n    dij2i = dij1i * dij1i;\n    dij = r2 * dij1i;\n    sj = fs[j] * (rborn[j] - 0.09);\n    sj2 = sj * sj;\n    if (dij > (rgbmax + sj))\n      continue;\n    if (dij > (rgbmax - sj))\n    {\n      temp1 = 1. / (dij - sj);\n      dij3i = dij1i * dij2i;\n      datmp = (0.125 * dij3i) * (((r2 + sj2) * ((temp1 * temp1) - rgbmax2i)) - (2.0 * log(rgbmax * temp1)));\n    }\n    else\n      if (dij > (4.0 * sj))\n    {\n      tmpsd = sj2 * dij2i;\n      dumbo = 1.33333333333333333333 + (tmpsd * (2.4 + (tmpsd * (3.42857142857142857143 + (tmpsd * (4.44444444444444444444 + (tmpsd * 5.45454545454545454545)))))));\n      datmp = (((tmpsd * sj) * dij2i) * dij2i) * dumbo;\n    }\n    else\n      if (dij > (ri + sj))\n    {\n      temp1 = 1. / (r2 - sj2);\n      datmp = ((temp1 * sj) * (((-0.5) * dij2i) + temp1)) + (((0.25 * dij1i) * dij2i) * log((dij - sj) / (dij + sj)));\n    }\n    else\n      if (dij > fabs(ri - sj))\n    {\n      temp1 = 1. / (dij + sj);\n      dij3i = dij2i * dij1i;\n      datmp = (-0.25) * (((((((-0.5) * ((r2 - (ri * ri)) + sj2)) * dij3i) * ri1i) * ri1i) + ((dij1i * temp1) * (temp1 - dij1i))) - (dij3i * log(ri * temp1)));\n    }\n    else\n      if (ri < sj)\n    {\n      temp1 = 1. / (r2 - sj2);\n      datmp = (-0.5) * ((((sj * dij2i) * temp1) - (((2. * sj) * temp1) * temp1)) - (((0.5 * dij2i) * dij1i) * log((sj - dij) / (sj + dij))));\n    }\n    else\n    {\n      datmp = 0.;\n    }\n    daix += xij * datmp;\n    daiy += yij * datmp;\n    daiz += zij * datmp;\n    if (dim == 4)\n    {\n      daiw += wij * datmp;\n    }\n    datmp *= sumda;\n    f[foff + j34] += xij * datmp;\n    f[(foff + j34) + 1] += yij * datmp;\n    f[(foff + j34) + 2] += zij * datmp;\n    if (dim == 4)\n    {\n      f[(foff + j34) + 3] += wij * datmp;\n    }\n  }\n\n  f[foff + i34] -= sumda * daix;\n  f[(foff + i34) + 1] -= sumda * daiy;\n  f[(foff + i34) + 2] -= sumda * daiz;\n  if (dim == 4)\n  {\n    f[(foff + i34) + 3] -= sumda * daiw;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/10"}
{"code": "for (i = 0; i < (dim * prm->Natom); i++)\n{\n  grad[i] = 0.0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/11"}
{"code": "for (i = 0; i < (dim * prm->Natom); i++)\n{\n  f[i] = grad[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/12"}
{"code": "for (k = 0; k < prm->Natom; k++)\n{\n  if (frozen[k])\n  {\n    f[(dim * k) + 0] = (f[(dim * k) + 1] = (f[(dim * k) + 2] = 0.0));\n    if (dim == 4)\n    {\n      f[(dim * k) + 3] = 0.0;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/13"}
{"code": "for (i = 0; i < (dim * prm->Natom); i++)\n  frms += f[i] * f[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/14"}
{"code": "for (k = 1; k <= 12; k++)\n{\n  ene[0] += ene[k];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/eff/15"}
{"code": "for (r = 0; fgets(line, sizeof(line), fp);)\n{\n  if ((*line) == '#')\n    continue;\n  cnt = sscanf(line, \"%f %f %f %f\", &mat[r][0], &mat[r][1], &mat[r][2], &mat[r][3]);\n  if (cnt != 4)\n  {\n    fprintf(stderr, \"getmatrix: bad row %d: got %d elements, needed 4\\n\", r + 1, cnt);\n    memset(mat, 0, sizeof(mat));\n    err = 1;\n    goto CLEAN_UP;\n  }\n  r++;\n  if (r >= 4)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/0"}
{"code": "for (tr = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n  tr += sp->s_nresidues;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/1"}
{"code": "for (ta = 0, tr = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  aoff[tr] = ta;\n  if (sp->s_nresidues > 0)\n  {\n    ta += sp->s_residues[0]->r_natoms;\n    for (r = 1; r < sp->s_nresidues; r++)\n    {\n      aoff[tr + r] = ta;\n      ta += sp->s_residues[r]->r_natoms;\n    }\n\n    tr += sp->s_nresidues;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/2"}
{"code": "for (tr = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    a = aoff[r + tr];\n    for (b = 0; b < res->r_nintbonds; b++)\n    {\n      fprintf(fp, \"%d %d\\n\", res->r_intbonds[b][0] + a, res->r_intbonds[b][1] + a);\n    }\n\n    for (ebp = res->r_extbonds; ebp; ebp = ebp->eb_next)\n    {\n      if ((rj = ebp->eb_rnum) < (r + 1))\n        continue;\n      ai = aoff[tr + r];\n      aj = aoff[(tr + rj) - 1];\n      fprintf(fp, \"%d %d\\n\", ebp->eb_anum + ai, ebp->eb_ranum + aj);\n    }\n\n  }\n\n  tr += sp->s_nresidues;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/3"}
{"code": "for (sp1 = mol->m_strands; sp1; sp1 = sp1->s_next)\n{\n  sp1->s_attr &= ~AT_SELECTED;\n  sp1->s_attr |= (sp1->s_attr & AT_SELECT) ? (AT_SELECTED) : (0);\n  for (r1 = 0; r1 < sp1->s_nresidues; r1++)\n  {\n    res1 = sp1->s_residues[r1];\n    res1->r_attr &= ~AT_SELECTED;\n    res1->r_attr |= (res1->r_attr & AT_SELECT) ? (AT_SELECTED) : (0);\n    for (a1 = 0, ap1 = res1->r_atoms; a1 < res1->r_natoms; a1++, ap1++)\n    {\n      ap1->a_attr &= ~AT_SELECTED;\n      ap1->a_attr |= (ap1->a_attr & AT_SELECT) ? (AT_SELECTED) : (0);\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/4"}
{"code": "for (tr = 0, sp1 = mol->m_strands; sp1; sp1 = sp1->s_next)\n  tr += sp1->s_nresidues;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/5"}
{"code": "for (r2 = 0, sp1 = mol->m_strands; sp1; sp1 = sp1->s_next)\n{\n  for (r1 = 0; r1 < sp1->s_nresidues; r1++)\n    res[r2++] = sp1->s_residues[r1];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/6"}
{"code": "for (cnt = 0, r1 = 0; r1 < tr; r1++)\n{\n  res1 = res[r1];\n  for (a1 = 0; a1 < res1->r_natoms; a1++)\n  {\n    ap1 = &res1->r_atoms[a1];\n    if (AT_SELECTED & ap1->a_attr)\n    {\n      for (r2 = 0; r2 < tr; r2++)\n      {\n        res2 = res[r2];\n        for (a2 = 0; a2 < res2->r_natoms; a2++)\n        {\n          ap2 = &res2->r_atoms[a2];\n          if (AT_SELECT & ap2->a_attr)\n          {\n            fprintf(fp, \"%3d %-4s %-4s %3d %-4s %4s %8.3f\\n\", r1 + 1, res1->r_resname, ap1->a_atomname, r2 + 1, res2->r_resname, ap2->a_atomname, dist(ap1, ap2));\n            cnt++;\n          }\n        }\n\n      }\n\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/7"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n    fprintf(fp, \" %g\", mat[i][j]);\n\n  fprintf(fp, \"\\n\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/8"}
{"code": "for (nchains = 0, n_atab = 0;;)\n{\n  if (ggets(line, sizeof(line), fp) == 0)\n    break;\n  for (i = strlen(line); i < 80; i++)\n    line[i] = ' ';\n\n  line[80] = '\\0';\n  if ((strncmp(\"ATOM\", line, 4) == 0) || (strncmp(\"HETATM\", line, 6) == 0))\n  {\n    strncpy(aname, &line[12], 4);\n    aname[4] = '\\0';\n    for (np = (np1 = aname); *np; np++)\n    {\n      if ((*np) != ' ')\n        *(np1++) = *np;\n    }\n\n    *np1 = '\\0';\n    if (((aname[0] == '1') || (aname[0] == '2')) || (aname[0] == '3'))\n    {\n      temp = aname[0];\n      for (i = 0; i < (strlen(aname) - 1); i++)\n        aname[i] = aname[i + 1];\n\n      aname[i] = temp;\n    }\n    if (aname[2] == '*')\n      aname[2] = '\\'';\n    if (!strcmp(aname, \"C5M\"))\n      strcpy(aname, \"C7\");\n    strncpy(rname, &line[17], 3);\n    rname[3] = '\\0';\n    for (np = (np1 = rname); *np; np++)\n    {\n      if ((*np) != ' ')\n        *(np1++) = *np;\n    }\n\n    *np1 = '\\0';\n    if (!strcmp(aname, \"O2\\'\"))\n      res.r_kind = RT_RNA;\n    if ((!strcmp(aname, \"H2\\'1\")) && (res.r_kind == RT_RNA))\n      strcpy(aname, \"H2\\'\");\n    if (!strcmp(rname, \"A\"))\n      strcpy(rname, \"ADE\");\n    if (!strcmp(rname, \"C\"))\n      strcpy(rname, \"CYT\");\n    if (!strcmp(rname, \"G\"))\n      strcpy(rname, \"GUA\");\n    if (!strcmp(rname, \"T\"))\n      strcpy(rname, \"THY\");\n    if (!strcmp(rname, \"U\"))\n      strcpy(rname, \"URA\");\n    strncpy(rid, &line[21], 6);\n    rid[6] = '\\0';\n    cid = line[21];\n    sscanf(&line[22], \"%d\", &rnum);\n    strncpy(field, &line[30], 8);\n    field[8] = '\\0';\n    x = atof(field);\n    strncpy(field, &line[38], 8);\n    field[8] = '\\0';\n    y = atof(field);\n    strncpy(field, &line[46], 8);\n    field[8] = '\\0';\n    z = atof(field);\n    if (strstr(loptions, \"-pqr\"))\n    {\n      sscanf(&line[54], \"%f%f\", &q, &r);\n      occ = 1.0;\n      bfact = 0.0;\n    }\n    else\n    {\n      if (!strncmp(aname, \"H\", 1))\n        r = 1.2;\n      else\n        if (!strncmp(aname, \"C\", 1))\n        r = 1.70;\n      else\n        if (!strncmp(aname, \"N\", 1))\n        r = 1.55;\n      else\n        if (!strncmp(aname, \"O\", 1))\n        r = 1.50;\n      else\n        if (!strncmp(aname, \"S\", 1))\n        r = 1.80;\n      else\n        if (!strncmp(aname, \"P\", 1))\n        r = 1.85;\n      else\n        r = 1.7;\n      q = 0.0;\n      strncpy(field, &line[54], 6);\n      field[6] = '\\0';\n      occ = atof(field);\n      strncpy(field, &line[60], 6);\n      field[6] = '\\0';\n      bfact = atof(field);\n    }\n    if (cid != l_cid)\n    {\n      if (n_atab > 0)\n      {\n        strcpy(res.r_resname, l_rname);\n        strcpy(res.r_resid, l_rid);\n        res.r_num = l_rnum;\n        res.r_natoms = n_atab;\n        makebonds(&res);\n        addresidue(mol, sname, &res);\n        initres();\n        n_atab = 0;\n      }\n      nchains++;\n      if (cid == ' ')\n        sprintf(sname, \"%d\", nchains);\n      else\n      {\n        sname[0] = cid;\n        sname[1] = '\\0';\n      }\n      addstrand(mol, sname);\n      {\n        STRAND_T *sp;\n        STRAND_T *spl;\n        for (sp = 0, spl = mol->m_strands; spl; spl = spl->s_next)\n        {\n          if (!strcmp(spl->s_strandname, sname))\n          {\n            sp = spl;\n            break;\n          }\n        }\n\n        sp->s_res_size = 10000;\n        sp->s_residues = (RESIDUE_T **) malloc(sp->s_res_size * (sizeof(RESIDUE_T)));\n        if (sp->s_residues == 0)\n        {\n        }\n      }\n      l_cid = cid;\n      strcpy(l_rname, rname);\n      strcpy(l_rid, rid);\n      l_rnum = rnum;\n    }\n    else\n      if (isnewres(l_rname, rname, l_rnum, rnum))\n    {\n      strcpy(res.r_resname, l_rname);\n      strcpy(res.r_resid, l_rid);\n      res.r_num = l_rnum;\n      res.r_natoms = n_atab;\n      makebonds(&res);\n      addresidue(mol, sname, &res);\n      initres();\n      strcpy(l_rname, rname);\n      strcpy(l_rid, rid);\n      l_rnum = rnum;\n      n_atab = 0;\n    }\n    ap = &atab[n_atab];\n    NAB_initatom(ap, 0);\n    strcpy(ap->a_atomname, aname);\n    ap->a_attr = 0;\n    ap->a_residue = 0;\n    ap->a_pos[0] = x;\n    ap->a_pos[1] = y;\n    ap->a_pos[2] = z;\n    ap->a_charge = q;\n    ap->a_radius = r;\n    ap->a_occ = occ;\n    ap->a_bfact = bfact;\n    n_atab++;\n  }\n  else\n    if (strncmp(\"TER\", line, 3) == 0)\n  {\n    if (n_atab > 0)\n    {\n      strcpy(res.r_resname, l_rname);\n      strcpy(res.r_resid, l_rid);\n      res.r_num = l_rnum;\n      res.r_natoms = n_atab;\n      makebonds(&res);\n      addresidue(mol, sname, &res);\n      initres();\n      n_atab = 0;\n    }\n    l_cid = '\\0';\n    *l_rname = '\\0';\n    *l_rid = '\\0';\n    l_rnum = 0;\n  }\n  else\n    if (strncmp(\"END\", line, 3) == 0)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/9"}
{"code": "for (ap = atab, a = 0; a < 1000; a++, ap++)\n{\n  ap->a_atomname = (char *) malloc(8 * (sizeof(char)));\n  if (ap->a_atomname == 0)\n  {\n    fprintf(stderr, \"init_atab: can't alloc a_atomname.\\n\");\n    exit(1);\n  }\n  *ap->a_atomname = '\\0';\n  ap->a_atomtype = 0;\n  ap->a_element = 0;\n  ap->a_fullname = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/10"}
{"code": "for (a1 = 0; a1 < res->r_natoms; a1++)\n{\n  ap1 = &res->r_atoms[a1];\n  ap1->a_nconnect = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/11"}
{"code": "for (a1 = 0; a1 < (res->r_natoms - 1); a1++)\n{\n  ap1 = &res->r_atoms[a1];\n  if (isdigit(*ap1->a_atomname))\n    ih1 = (ap1->a_atomname[1] == 'H') || (ap1->a_atomname[1] == 'h');\n  else\n    ih1 = ((*ap1->a_atomname) == 'H') || ((*ap1->a_atomname) == 'h');\n  for (a2 = a1 + 1; a2 < res->r_natoms; a2++)\n  {\n    ap2 = &res->r_atoms[a2];\n    if (isdigit(*ap2->a_atomname))\n      ih2 = (ap2->a_atomname[1] == 'H') || (ap2->a_atomname[1] == 'h');\n    else\n      ih2 = ((*ap2->a_atomname) == 'H') || ((*ap2->a_atomname) == 'h');\n    d = dist(ap1, ap2);\n    if (ih1 || ih2)\n    {\n      if (d <= 1.20)\n      {\n        if ((ap1->a_nconnect < A_CONNECT_SIZE) && (ap2->a_nconnect < A_CONNECT_SIZE))\n        {\n          ap1->a_connect[ap1->a_nconnect++] = a2;\n          ap2->a_connect[ap2->a_nconnect++] = a1;\n        }\n      }\n    }\n    else\n      if (d <= 1.85)\n    {\n      if ((ap1->a_nconnect < A_CONNECT_SIZE) && (ap2->a_nconnect < A_CONNECT_SIZE))\n      {\n        ap1->a_connect[ap1->a_nconnect++] = a2;\n        ap2->a_connect[ap2->a_nconnect++] = a1;\n      }\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/12"}
{"code": "for (ta = 0, tr = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  cid = nextcid(cidstate, opt_nocid, opt_allcid, sp);\n  for (r = 0; r < sp->s_nresidues; r++, tr++)\n  {\n    res = sp->s_residues[r];\n    strcpy(rid, (res->r_resid) ? (res->r_resid) : (\"\"));\n    if (opt_brook)\n      mk_brook_rname(rname, res);\n    else\n      if (opt_wwpdb)\n      mk_wwpdb_rname(rname, res);\n    else\n      strcpy(rname, res->r_resname);\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ta++;\n      ap = &res->r_atoms[a];\n      if (opt_brook)\n        mk_brook_aname(aname, ap->a_atomname, rname);\n      else\n        if (opt_wwpdb)\n        mk_wwpdb_aname(aname, ap->a_atomname, rname);\n      else\n        strcpy(aname, ap->a_atomname);\n      if ((!strcmp(rid, \"\")) || opt_tr)\n      {\n        rn = (opt_tr) ? (tr + 1) : (r + 1);\n        if (ta < 100000)\n        {\n          fprintf(fp, \"ATOM  %5d %-4s %-3s %c%4d    %8.3f%8.3f%8.3f\", ta, aname, rname, cid, rn, ap->a_pos[0], ap->a_pos[1], ap->a_pos[2]);\n        }\n        else\n        {\n          fprintf(fp, \"ATOM  %05d %-4s %-3s %c%4d    %8.3f%8.3f%8.3f\", ta % 100000, aname, rname, cid, rn, ap->a_pos[0], ap->a_pos[1], ap->a_pos[2]);\n        }\n      }\n      else\n      {\n        if (ta < 100000)\n        {\n          fprintf(fp, \"ATOM  %5d %-4s %3s %-6s   %8.3f%8.3f%8.3f\", ta, aname, rname, rid, ap->a_pos[0], ap->a_pos[1], ap->a_pos[2]);\n        }\n        else\n        {\n          fprintf(fp, \"ATOM  %05d %-4s %3s %-6s   %8.3f%8.3f%8.3f\", ta % 100000, aname, rname, rid, ap->a_pos[0], ap->a_pos[1], ap->a_pos[2]);\n        }\n      }\n      if (opt_pqr)\n      {\n        fprintf(fp, \"%10.5f%10.5f   \", ap->a_charge, ap->a_radius);\n      }\n      else\n        if (!opt_nobocc)\n      {\n        fprintf(fp, \"%6.2f%6.2f           \", ap->a_occ, ap->a_bfact);\n      }\n      if (((opt_brook || opt_wwpdb) && (!opt_pqr)) && (!opt_nobocc))\n      {\n        fprintf(fp, \"%.1s  \", ap->a_atomname);\n      }\n      fprintf(fp, \"\\n\");\n    }\n\n  }\n\n  fprintf(fp, \"TER\\n\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/13"}
{"code": "for (c = cid->c_next; c <= cid->c_last; c++)\n  cid->c_cids[c] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/14"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (strlen(sp->s_strandname) == 1)\n  {\n    c = *sp->s_strandname;\n    if ((c >= 'A') && (c <= 'Z'))\n      cid->c_cids[c] = 1;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/15"}
{"code": "for (; cid->c_next <= cid->c_last; cid->c_next++)\n{\n  if (!cid->c_cids[cid->c_next])\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/16"}
{"code": "for (++cid->c_next; cid->c_next <= cid->c_last; cid->c_next++)\n{\n  if (!cid->c_cids[cid->c_next])\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/17"}
{"code": "for (ta = 0, tr = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  strandnum++;\n  for (r = 0; r < sp->s_nresidues; r++, tr++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ta++;\n      ap = &res->r_atoms[a];\n      fprintf(fp, \"%5d %-4s %3s %c %4d %8.3f %8.3f %8.3f %3d %4d\\n\", ta, ap->a_atomname, res->r_resname, cid, tr + 1, ap->a_pos[0], ap->a_pos[1], ap->a_pos[2], strandnum, r + 1);\n    }\n\n  }\n\n  if (mol->m_nstrands > 1)\n    cid++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molio/18"}
{"code": "for (ta = 0, sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (AT_SELECT & sp->s_attr)\n  {\n    for (r = 0; r < sp->s_nresidues; r++)\n    {\n      res = sp->s_residues[r];\n      if (AT_SELECT & res->r_attr)\n      {\n        for (a = 0; a < res->r_natoms; a++)\n        {\n          ap = &res->r_atoms[a];\n          if (AT_SELECT & ap->a_attr)\n          {\n            x += ap->a_pos[0];\n            y += ap->a_pos[1];\n            z += ap->a_pos[2];\n            ta++;\n          }\n        }\n\n      }\n    }\n\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/0"}
{"code": "for (aep = aex, n_aep = strchr(aep, '|'); aep;)\n{\n  if (n_aep)\n  {\n    ael = n_aep - aep;\n    n_aep++;\n  }\n  else\n    ael = strlen(aep);\n  if (ael >= 1000)\n  {\n    fprintf(stderr, \"select_atoms: atom-expr too complicated\\n\");\n    return 1;\n  }\n  strncpy(aexpr, aep, ael);\n  aexpr[ael] = '\\0';\n  eval_1_aexpr(mol, aexpr);\n  or_select(mol);\n  aep = n_aep;\n  if (aep)\n    n_aep = strchr(aep, '|');\n  clear_select(mol);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/1"}
{"code": "for (aep = aex, n_aep = strchr(aep, '|'); aep;)\n{\n  if (n_aep)\n  {\n    ael = n_aep - aep;\n    n_aep++;\n  }\n  else\n    ael = strlen(aep);\n  if (ael >= 1000)\n  {\n    fprintf(stderr, \"atom_in_aexpr: atom-expr too complicated\\n\");\n    return 0;\n  }\n  strncpy(aexpr, aep, ael);\n  aexpr[ael] = '\\0';\n  if (atom_in_1_aexpr(ap, aexpr))\n    return 1;\n  aep = n_aep;\n  if (aep)\n    n_aep = strchr(aep, '|');\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/2"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr |= (sp->s_attr & i_attr) ? (attr) : (0);\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr |= (res->r_attr & i_attr) ? (attr) : (0);\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      ap->a_attr |= (ap->a_attr & i_attr) ? (attr) : (0);\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/3"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr &= ~attr;\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr &= ~attr;\n    for (a = 0; a < res->r_natoms; a++)\n      res->r_atoms[a].a_attr &= ~attr;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/4"}
{"code": "for (val = 0, ip = item; isdigit(*ip); ip++)\n  val = ((10 * val) + (*ip)) - '0';\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/5"}
{"code": "for (val = 0; isdigit(*ip); ip++)\n  val = ((10 * val) + (*ip)) - '0';\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/6"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr |= AT_SELECT;\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr |= AT_SELECT;\n    for (a = 0; a < res->r_natoms; a++)\n      res->r_atoms[a].a_attr |= AT_SELECT;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/7"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr &= ~AT_SELECT;\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr &= ~AT_SELECT;\n    for (a = 0; a < res->r_natoms; a++)\n      res->r_atoms[a].a_attr &= ~AT_SELECT;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/8"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr &= ~AT_WORK;\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr &= ~AT_WORK;\n    for (a = 0; a < res->r_natoms; a++)\n      res->r_atoms[a].a_attr &= ~AT_WORK;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/9"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr |= (sp->s_attr & AT_SELECT) ? (AT_WORK) : (0);\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr |= (res->r_attr & AT_SELECT) ? (AT_WORK) : (0);\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      ap->a_attr |= (ap->a_attr & AT_SELECT) ? (AT_WORK) : (0);\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/10"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr |= (sp->s_attr & AT_WORK) ? (AT_SELECT) : (0);\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    res->r_attr |= (res->r_attr & AT_WORK) ? (AT_SELECT) : (0);\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      ap->a_attr |= (ap->a_attr & AT_WORK) ? (AT_SELECT) : (0);\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/11"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  sp->s_attr |= (step(sp->s_strandname, expbuf)) ? (AT_SELECT) : (0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/12"}
{"code": "for (m = 1, sp = mol->m_strands; m <= mol->m_nstrands; m++, sp = sp->s_next)\n{\n  if ((lo <= m) && (m <= hi))\n    sp->s_attr |= AT_SELECT;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/13"}
{"code": "for (m = 1, sp1 = mol->m_strands; m <= mol->m_nstrands; m++, sp1 = sp1->s_next)\n{\n  if (sp == sp1)\n  {\n    if ((lo <= m) && (m <= hi))\n      return 1;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/14"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (AT_SELECT & sp->s_attr)\n  {\n    for (r = 0; r < sp->s_nresidues; r++)\n    {\n      res = sp->s_residues[r];\n      res->r_attr |= (step(res->r_resname, expbuf)) ? (AT_SELECT) : (0);\n    }\n\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/15"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (AT_SELECT & sp->s_attr)\n  {\n    rhi = (hi == UNDEF) ? (sp->s_nresidues) : (hi);\n    for (r = 0; r < sp->s_nresidues; r++)\n    {\n      res = sp->s_residues[r];\n      if ((lo <= (r + 1)) && ((r + 1) <= rhi))\n        res->r_attr |= AT_SELECT;\n    }\n\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/16"}
{"code": "for (r = 0; r < sp->s_nresidues; r++)\n{\n  res1 = sp->s_residues[r];\n  if (res == res1)\n  {\n    if ((lo <= (r + 1)) && ((r + 1) <= rhi))\n      return 1;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/17"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (AT_SELECT & sp->s_attr)\n  {\n    for (r = 0; r < sp->s_nresidues; r++)\n    {\n      res = sp->s_residues[r];\n      if (AT_SELECT & res->r_attr)\n      {\n        for (a = 0; a < res->r_natoms; a++)\n        {\n          ap = &res->r_atoms[a];\n          ap->a_attr |= (step(ap->a_atomname, expbuf)) ? (AT_SELECT) : (0);\n        }\n\n      }\n    }\n\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/18"}
{"code": "for (aep = aexpr; *aep; aep++)\n{\n  if ((*aep) == '*')\n  {\n    *(rep++) = '.';\n    *(rep++) = '*';\n  }\n  else\n    if ((*aep) == '?')\n    *(rep++) = '.';\n  else\n    *(rep++) = *aep;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/select_atoms/19"}
{"code": "for (i = nrl + 1; i <= nrh; i++)\n  m[i] = m[i - 1] + ncol;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/memutil/0"}
{"code": "for (ep = res->r_extbonds; ep; ep = epn)\n{\n  epn = ep->eb_next;\n  free((void *) ep);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/0"}
{"code": "for (ap = res->r_atoms, a = 0; a < res->r_natoms; a++, ap++)\n{\n  if (ap->a_atomname)\n    free((void *) ap->a_atomname);\n  if (ap->a_atomtype)\n    free((void *) ap->a_atomtype);\n  if (ap->a_element)\n    free((void *) ap->a_element);\n  if (ap->a_fullname)\n    free((void *) ap->a_fullname);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/1"}
{"code": "for (sp = mol->m_strands; sp; sp = spn)\n{\n  spn = sp->s_next;\n  if (sp->s_strandname)\n    free((void *) sp->s_strandname);\n  for (r = 0; r < sp->s_nresidues; r++)\n    freeresidue(sp->s_residues[r]);\n\n  if (sp->s_residues)\n    free((void *) sp->s_residues);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/2"}
{"code": "for (sp = mp->m_strands; sp; sp = sp->s_next)\n{\n  if (!strcmp(sp->s_strandname, sname))\n  {\n    fprintf(stderr, \"addstrand: strand %s already in mol\\n\", sname);\n    return 1;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/3"}
{"code": "for (; spl->s_next; spl = spl->s_next)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/4"}
{"code": "for (sp = 0, spl = mp->m_strands; spl; spl = spl->s_next)\n{\n  if (strcmp(spl->s_strandname, sname) == 0)\n  {\n    sp = spl;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/5"}
{"code": "for (r = 0; r < sp->s_nresidues; r++)\n  rap[r] = sp->s_residues[r];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/6"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (strcmp(sp->s_strandname, sname) == 0)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/7"}
{"code": "for (ai = UNDEF, a = 0; a < resi->r_natoms; a++)\n{\n  ap = &resi->r_atoms[a];\n  if (strcmp(ap->a_atomname, ainame) == 0)\n  {\n    ai = a;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/8"}
{"code": "for (aj = UNDEF, a = 0; a < resj->r_natoms; a++)\n{\n  ap = &resj->r_atoms[a];\n  if (strcmp(ap->a_atomname, ajname) == 0)\n  {\n    aj = a;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/9"}
{"code": "for (sp1 = 0, sp = mol1->m_strands; sp; sp = sp->s_next)\n{\n  if (strcmp(sp->s_strandname, strand1) == 0)\n  {\n    sp1 = sp;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/10"}
{"code": "for (sp2 = 0, sp = mol2->m_strands; sp; sp = sp->s_next)\n{\n  if (strcmp(sp->s_strandname, strand2) == 0)\n  {\n    sp2 = sp;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/11"}
{"code": "for (r1 = 0; r1 < sp1->s_nresidues; r1++)\n  rap[r1] = sp1->s_residues[r1];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/12"}
{"code": "for (r2 = 0; r2 < sp2->s_nresidues; r2++)\n{\n  sp1->s_residues[r1 + r2] = copyresidue(sp2->s_residues[r2]);\n  sp1->s_residues[r1 + r2]->r_strand = sp1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/13"}
{"code": "for (r2 = 0; r2 < sp2->s_nresidues; r2++)\n{\n  sp1->s_residues[r1 + r2] = sp2->s_residues[r2];\n  sp1->s_residues[r1 + r2]->r_strand = sp1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/14"}
{"code": "for (r2 = 0; r2 < sp2->s_nresidues; r2++)\n  fixextbonds(sp1->s_residues[r1 + r2], r1);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/15"}
{"code": "for (r1 = sp1->s_nresidues - 1; r1 >= 0; r1--)\n  sp1->s_residues[r2 + r1] = sp1->s_residues[r1];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/16"}
{"code": "for (r2 = 0; r2 < sp2->s_nresidues; r2++)\n{\n  sp1->s_residues[r2] = copyresidue(sp2->s_residues[r2]);\n  sp1->s_residues[r2]->r_strand = sp1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/17"}
{"code": "for (r2 = 0; r2 < sp2->s_nresidues; r2++)\n{\n  sp1->s_residues[r2] = sp2->s_residues[r2];\n  sp1->s_residues[r2]->r_strand = sp1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/18"}
{"code": "for (r1 = 0; r1 < sp1->s_nresidues; r1++)\n{\n  fixextbonds(sp1->s_residues[r2 + r1], r2);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/19"}
{"code": "for (n = 0, sp = m->m_strands; sp; sp = sp->s_next)\n{\n  if (sp->s_attr & AT_SELECT)\n    n++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/20"}
{"code": "for (i = 1, sp = m->m_strands; sp && (i < strandnum); sp = sp->s_next)\n{\n  i++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/21"}
{"code": "for (n = 0, sp = m->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    if (res->r_attr & AT_SELECT)\n      n++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/22"}
{"code": "for (n = 0, sp = m->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n        n++;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/23"}
{"code": "for (sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if ((sp->s_nresidues > 0) && (sp->s_attr & AT_SELECT))\n  {\n    if (five)\n      cvt_p2hb(sp->s_residues[0]);\n    if (three)\n      add_he2o3(sp->s_residues[sp->s_nresidues - 1]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/24"}
{"code": "for (epn = (ep1 = 0), epo = res->r_extbonds; epo; epo = epo->eb_next)\n{\n  if ((ep = (EXTBOND_T *) malloc(sizeof(EXTBOND_T))) == 0)\n  {\n    sprintf(e_msg, \"copied external bonds\");\n    rt_errormsg_s(TRUE, E_NOMEM_FOR_S, e_msg);\n    return 0;\n  }\n  ep->eb_next = 0;\n  ep->eb_anum = epo->eb_anum;\n  ep->eb_rnum = epo->eb_rnum;\n  ep->eb_ranum = epo->eb_ranum;\n  if (epn == 0)\n    epn = ep;\n  if (ep1 != 0)\n    ep1->eb_next = ep;\n  ep1 = ep;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/25"}
{"code": "for (tp = trkind, rp = rkind; *rp; rp++)\n  *(tp++) = (isupper(*rp)) ? (tolower(*rp)) : (*rp);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/26"}
{"code": "for (sp = m->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    if (res->r_attr & AT_SELECT)\n      res->r_kind = rk;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/27"}
{"code": "for (n = 0, sp = (*m)->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        xyz[n][0] = ap->a_pos[0];\n        xyz[n][1] = ap->a_pos[1];\n        xyz[n][2] = ap->a_pos[2];\n        n++;\n      }\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/28"}
{"code": "for (n = 0, sp = (*m)->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        xyzw[(4 * n) + 0] = ap->a_pos[0];\n        xyzw[(4 * n) + 1] = ap->a_pos[1];\n        xyzw[(4 * n) + 2] = ap->a_pos[2];\n        xyzw[(4 * n) + 3] = ap->a_w;\n        n++;\n      }\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/29"}
{"code": "for (n = 0, sp = (*m)->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        ap->a_pos[0] = xyz[(3 * n) + 0];\n        ap->a_pos[1] = xyz[(3 * n) + 1];\n        ap->a_pos[2] = xyz[(3 * n) + 2];\n        n++;\n      }\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/30"}
{"code": "for (n = 0, sp = (*m)->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        ap->a_pos[0] = xyzw[(4 * n) + 0];\n        ap->a_pos[1] = xyzw[(4 * n) + 1];\n        ap->a_pos[2] = xyzw[(4 * n) + 2];\n        ap->a_w = xyzw[(4 * n) + 3];\n        n++;\n      }\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/31"}
{"code": "for (i = 0; i < s; i++)\n  a[i] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/32"}
{"code": "for (i = 0; i < A_CONNECT_SIZE; i++)\n  ap->a_connect[i] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/33"}
{"code": "for (sp = mol->m_strands; sp && (sp->s_nresidues == 0); sp = sp->s_next)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/34"}
{"code": "for (nr = sp->s_nresidues, r = 0; r < sp->s_nresidues; r++)\n{\n  if (sp->s_residues[r] == res)\n  {\n    nr = r + 1;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/35"}
{"code": "for (sp = sp->s_next; sp && (sp->s_nresidues == 0); sp = sp->s_next)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/36"}
{"code": "for (nr = sp->s_nresidues, r = 0; r < sp->s_nresidues; r++)\n{\n  if (sp->s_residues[r] == crp)\n  {\n    nr = r + 1;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/37"}
{"code": "for (r = 0; r < sp->s_nresidues; r++)\n  if (sp->s_residues[r] == res)\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/38"}
{"code": "for (s = 0, sp1 = mp->m_strands; sp1; sp1 = sp1->s_next)\n{\n  s++;\n  if (sp1 == sp)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/39"}
{"code": "for (ta = (tr = (s = 0)), sp = mp->m_strands; sp; s++, sp = sp->s_next)\n{\n  sp->s_strandnum = s + 1;\n  for (a = (r = 0); r < sp->s_nresidues; tr++, r++)\n  {\n    res = sp->s_residues[r];\n    res->r_tresnum = tr + 1;\n    res->r_resnum = r + 1;\n    for (a1 = 0; a1 < res->r_natoms; a1++, ta++, a++)\n    {\n      ap = &res->r_atoms[a1];\n      ap->a_atomnum = a + 1;\n      ap->a_tatomnum = ta + 1;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/40"}
{"code": "for (a = 0; a < nres->r_natoms; a++)\n{\n  ap = &nres->r_atoms[a];\n  for (i = 0; i < 3; i++)\n    xyz[i] = ap->a_pos[i];\n\n  xfm_xyz(xyz, mat, nxyz);\n  for (i = 0; i < 3; i++)\n    ap->a_pos[i] = nxyz[i];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/41"}
{"code": "for (sp = mol->m_strands, k = 0; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        k++;\n        for (i = 0; i < 3; i++)\n          xyz[i] = ap->a_pos[i];\n\n        xfm_xyz(xyz, mat, nxyz);\n        for (i = 0; i < 3; i++)\n          ap->a_pos[i] = nxyz[i];\n\n      }\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/42"}
{"code": "for (i = 0; i < npts; i++)\n  xfm_xyz(pts[i], mat, pts[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/43"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    idmat[i][j] = (i == j) ? (1.0) : (0.0);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/44"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    m3[i][j] = 0.0;\n    for (k = 0; k < 4; k++)\n    {\n      m3[i][j] += m1[i][k] * m2[k][j];\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/45"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n    mnew[i][j] = mold[i][j];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/46"}
{"code": "for (i = 0; i < 3; i++)\n  oxyz4[i] = oxyz[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/47"}
{"code": "for (i = 0; i < 4; i++)\n{\n  nxyz4[i] = 0.0;\n  for (j = 0; j < 4; j++)\n  {\n    nxyz4[i] += oxyz4[j] * mat[j][i];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/48"}
{"code": "for (i = 0; i < 3; i++)\n  nxyz[i] = nxyz4[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/49"}
{"code": "for (ep = res->r_extbonds; ep; ep = ep->eb_next)\n  ep->eb_rnum += roff;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/50"}
{"code": "for (spl = (sprm = 0), sp = mol->m_strands; sp; sp = sp->s_next)\n{\n  if (strcmp(sp->s_strandname, sname) == 0)\n  {\n    sprm = sp;\n    break;\n  }\n  spl = sp;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/51"}
{"code": "for (a = 0, ap = res->r_atoms; a < res->r_natoms; a++, ap++)\n{\n  if (strcmp(ap->a_atomname, aname) == 0)\n    return a;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/52"}
{"code": "for (c = 0; c < ap->a_nconnect; c++)\n{\n  ac = ap->a_connect[c];\n  apc = &res->r_atoms[ac];\n  for (c1 = 0; c1 < apc->a_nconnect; c1++)\n  {\n    if (apc->a_connect[c1] == anum)\n    {\n      for (c2 = c1; c2 < (apc->a_nconnect - 1); c2++)\n      {\n        apc->a_connect[c2] = apc->a_connect[c2 + 1];\n      }\n\n      apc->a_nconnect--;\n      for (c2 = apc->a_nconnect; c2 < A_CONNECT_SIZE; c2++)\n        apc->a_connect[c2] = UNDEF;\n\n      break;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/53"}
{"code": "for (a = anum; a < (res->r_natoms - 1); a++)\n  res->r_atoms[a] = res->r_atoms[a + 1];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/54"}
{"code": "for (a = 0; a < (res->r_natoms - 1); a++)\n{\n  ap = &res->r_atoms[a];\n  for (c = 0; c < ap->a_nconnect; c++)\n  {\n    if (ap->a_connect[c] > anum)\n      ap->a_connect[c]--;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/55"}
{"code": "for (a = 0; a < (na - 1); a++)\n  nap[a] = oap[a];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/56"}
{"code": "for (c = 0; c < A_CONNECT_SIZE; c++)\n  ap->a_connect[c] = UNDEF;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/57"}
{"code": "for (a = 0; a < (na - 1); a++)\n  nai[a] = oai[a];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/58"}
{"code": "for (a = 0; a < na; a++)\n  nai[a] = a;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/59"}
{"code": "for (n = 0, sp = m->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n        frozen[n] = 0;\n      else\n      {\n        frozen[n] = 1;\n        nfrozen++;\n      }\n      n++;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/60"}
{"code": "for (nb = 0, ib = 0; ib < prm->Nbonh; ib++)\n{\n  i = prm->BondHAt1[ib] / 3;\n  j = prm->BondHAt2[ib] / 3;\n  if ((!frozen[i]) || (!frozen[j]))\n  {\n    prm->BondHAt1[nb] = prm->BondHAt1[ib];\n    prm->BondHAt2[nb] = prm->BondHAt2[ib];\n    prm->BondHNum[nb] = prm->BondHNum[ib];\n    nb++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/61"}
{"code": "for (nb = 0, ib = 0; ib < prm->Nbona; ib++)\n{\n  i = prm->BondAt1[ib] / 3;\n  j = prm->BondAt2[ib] / 3;\n  if ((!frozen[i]) || (!frozen[j]))\n  {\n    prm->BondAt1[nb] = prm->BondAt1[ib];\n    prm->BondAt2[nb] = prm->BondAt2[ib];\n    prm->BondNum[nb] = prm->BondNum[ib];\n    nb++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/62"}
{"code": "for (nb = 0, ib = 0; ib < prm->Ntheth; ib++)\n{\n  i = prm->AngleHAt1[ib] / 3;\n  j = prm->AngleHAt2[ib] / 3;\n  k = prm->AngleHAt3[ib] / 3;\n  if (((!frozen[i]) || (!frozen[j])) || (!frozen[k]))\n  {\n    prm->AngleHAt1[nb] = prm->AngleHAt1[ib];\n    prm->AngleHAt2[nb] = prm->AngleHAt2[ib];\n    prm->AngleHAt3[nb] = prm->AngleHAt3[ib];\n    prm->AngleHNum[nb] = prm->AngleHNum[ib];\n    nb++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/63"}
{"code": "for (nb = 0, ib = 0; ib < prm->Ntheta; ib++)\n{\n  i = prm->AngleAt1[ib] / 3;\n  j = prm->AngleAt2[ib] / 3;\n  k = prm->AngleAt3[ib] / 3;\n  if (((!frozen[i]) || (!frozen[j])) || (!frozen[k]))\n  {\n    prm->AngleAt1[nb] = prm->AngleAt1[ib];\n    prm->AngleAt2[nb] = prm->AngleAt2[ib];\n    prm->AngleAt3[nb] = prm->AngleAt3[ib];\n    prm->AngleNum[nb] = prm->AngleNum[ib];\n    nb++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/64"}
{"code": "for (nb = 0, ib = 0; ib < prm->Nphih; ib++)\n{\n  i = prm->DihHAt1[ib] / 3;\n  j = prm->DihHAt2[ib] / 3;\n  k = prm->DihHAt3[ib] / 3;\n  l = prm->DihHAt4[ib] / 3;\n  ka = (k > 0) ? (k) : (-k);\n  la = (l > 0) ? (l) : (-l);\n  if ((((!frozen[i]) || (!frozen[j])) || (!frozen[ka])) || (!frozen[la]))\n  {\n    prm->DihHAt1[nb] = prm->DihHAt1[ib];\n    prm->DihHAt2[nb] = prm->DihHAt2[ib];\n    prm->DihHAt3[nb] = prm->DihHAt3[ib];\n    prm->DihHAt4[nb] = prm->DihHAt4[ib];\n    prm->DihHNum[nb] = prm->DihHNum[ib];\n    nb++;\n    if ((k >= 0) && (l >= 0))\n    {\n      ismall = (i < l) ? (i) : (l);\n      ibig = (i > l) ? (i) : (l);\n      iptmp[(12 * ismall) + (prm->N14pairs[ismall]++)] = ibig;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/65"}
{"code": "for (nb = 0, ib = 0; ib < prm->Nphia; ib++)\n{\n  i = prm->DihAt1[ib] / 3;\n  j = prm->DihAt2[ib] / 3;\n  k = prm->DihAt3[ib] / 3;\n  l = prm->DihAt4[ib] / 3;\n  ka = (k > 0) ? (k) : (-k);\n  la = (l > 0) ? (l) : (-l);\n  if ((((!frozen[i]) || (!frozen[j])) || (!frozen[ka])) || (!frozen[la]))\n  {\n    prm->DihAt1[nb] = prm->DihAt1[ib];\n    prm->DihAt2[nb] = prm->DihAt2[ib];\n    prm->DihAt3[nb] = prm->DihAt3[ib];\n    prm->DihAt4[nb] = prm->DihAt4[ib];\n    prm->DihNum[nb] = prm->DihNum[ib];\n    nb++;\n    if ((k >= 0) && (l >= 0))\n    {\n      ismall = (i < l) ? (i) : (l);\n      ibig = (i > l) ? (i) : (l);\n      iptmp[(12 * ismall) + (prm->N14pairs[ismall]++)] = ibig;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/66"}
{"code": "for (i = 0; i < (prm->Natom - 1); i++)\n{\n  for (k = 0; k < prm->N14pairs[i]; k++)\n    prm->N14pairlist[j++] = iptmp[(12 * i) + k];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/67"}
{"code": "for (n = 0, sp = m->m_strands; sp; sp = sp->s_next)\n{\n  for (r = 0; r < sp->s_nresidues; r++)\n  {\n    res = sp->s_residues[r];\n    for (a = 0; a < res->r_natoms; a++)\n    {\n      ap = &res->r_atoms[a];\n      if (ap->a_attr & AT_SELECT)\n      {\n        cons[n] = 1;\n        ncons++;\n      }\n      else\n      {\n        cons[n] = 0;\n      }\n      n++;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/68"}
{"code": "for (i = 0; i < 3; i++)\n  ab[i] = p2[i] - p1[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/69"}
{"code": "for (i = 0; i < 3; i++)\n  ac[i] = p3[i] - p1[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/70"}
{"code": "for (i = 0; i < 3; i++)\n  bc[i] = p3[i] - p2[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/71"}
{"code": "for (i = 0; i < 3; i++)\n  m_ab[i] = 0.5 * (p1[i] + p2[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/72"}
{"code": "for (i = 0; i < 3; i++)\n  cm[i] = p3[i] - m_ab[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/73"}
{"code": "for (i = 0; i < 3; i++)\n  v[i] = ac[i] - (fac1 * ab[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/74"}
{"code": "for (i = 0; i < 3; i++)\n  pc[i] = m_ab[i] + (fac2 * v[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/molutil/75"}
{"code": "for (i = 0; i < 12; i++)\n  d[i] *= 0.1666666667;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/352.nab/src/chirvol/0"}
{"code": "for (i = 0; i <= (2 * maxReports); i++)\n{\n  tempSeqsI[i] = (tempSeqsJ[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/0"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempScores[i] = B->bestScores[indexB][i];\n  tempStartsI[i] = B->bestStartsI[indexB][i];\n  tempStartsJ[i] = B->bestStartsJ[indexB][i];\n  tempEndsI[i] = B->bestEndsI[indexB][i];\n  tempEndsJ[i] = B->bestEndsJ[indexB][i];\n  length = strlen((char *) B->bestSeqsI[indexB][i]);\n  if (length < 1)\n  {\n    printf(\"mergeAlignment: strlen(B->bestSeqsI[%d] = %d for thread %d\\n\", i, length, indexB);\n    exit(1);\n  }\n  length++;\n  if ((tempSeqsI[i] = (unsigned char *) malloc(length * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"mergeAlignment: cannot allocate tempSeqsI[%d] for thread %d\", i, indexB);\n    exit(1);\n  }\n  tempSeqsI[i] = (unsigned char *) strcpy((char *) tempSeqsI[i], (char *) B->bestSeqsI[indexB][i]);\n  length = strlen((char *) B->bestSeqsJ[indexB][i]);\n  if (length < 1)\n  {\n    printf(\"mergeAlignment: strlen(B->bestSeqsJ[%d] = %d for thread %d\\n\", i, length, indexB);\n    exit(1);\n  }\n  length++;\n  if ((tempSeqsJ[i] = (unsigned char *) malloc(length * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"mergeAlignment: cannot allocate tempSeqsJ[%d] for thread %d\", i, indexB);\n    exit(1);\n  }\n  tempSeqsJ[i] = (unsigned char *) strcpy((char *) tempSeqsJ[i], (char *) B->bestSeqsJ[indexB][i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/1"}
{"code": "for (i = 1; i <= P->numReports[producer]; i++)\n{\n  flag = 0;\n  for (j = 1; j <= numReports; j++)\n  {\n    if ((MAX(abs(tempStartsI[j] - P->bestStartsI[producer][i]), abs(tempStartsJ[j] - P->bestStartsJ[producer][i])) < minSeparation) || (MAX(abs(tempEndsI[j] - P->bestEndsI[producer][i]), abs(tempEndsJ[j] - P->bestEndsJ[producer][i])) < minSeparation))\n    {\n      flag = 1;\n      break;\n    }\n  }\n\n  if (flag == 0)\n  {\n    totalReports++;\n    tempScores[totalReports] = P->bestScores[producer][i];\n    tempStartsI[totalReports] = P->bestStartsI[producer][i];\n    tempStartsJ[totalReports] = P->bestStartsJ[producer][i];\n    tempEndsI[totalReports] = P->bestEndsI[producer][i];\n    tempEndsJ[totalReports] = P->bestEndsJ[producer][i];\n    tempSeqsI[totalReports] = P->bestSeqsI[producer][i];\n    tempSeqsJ[totalReports] = P->bestSeqsJ[producer][i];\n    P->bestSeqsI[producer][i] = (P->bestSeqsJ[producer][i] = 0);\n  }\n  else\n  {\n    if (P->bestSeqsI[producer][i])\n    {\n      free(P->bestSeqsI[producer][i]);\n      P->bestSeqsI[producer][i] = 0;\n    }\n    if (P->bestSeqsJ[producer][i])\n    {\n      free(P->bestSeqsJ[producer][i]);\n      P->bestSeqsJ[producer][i] = 0;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/2"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  scores[i] = tempScores[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/3"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempScores[i] = scores[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/4"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  scores[i] = tempStartsI[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/5"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempStartsI[i] = scores[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/6"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  scores[i] = tempStartsJ[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/7"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempStartsJ[i] = scores[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/8"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  scores[i] = tempEndsI[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/9"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempEndsI[i] = scores[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/10"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  scores[i] = tempEndsJ[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/11"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempEndsJ[i] = scores[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/12"}
{"code": "for (i = 1; i <= (totalReports - numReports); i++)\n{\n  if (tempSeqsI[index[i]])\n  {\n    free(tempSeqsI[index[i]]);\n    tempSeqsI[index[i]] = 0;\n  }\n  if (tempSeqsJ[index[i]])\n  {\n    free(tempSeqsJ[index[i]]);\n    tempSeqsJ[index[i]] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/13"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  sequences[i] = tempSeqsI[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/14"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempSeqsI[i] = sequences[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/15"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  sequences[i] = tempSeqsJ[index[(totalReports - i) + 1]];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/16"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  tempSeqsJ[i] = sequences[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/17"}
{"code": "for (i = numReports + 1; i <= totalReports; i++)\n{\n  tempSeqsI[i] = (tempSeqsJ[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/18"}
{"code": "for (i = 1; i <= numReports; i++)\n{\n  C->finalScores[i] = tempScores[i];\n  C->finalStartsI[i] = tempStartsI[i];\n  C->finalStartsJ[i] = tempStartsJ[i];\n  C->finalEndsI[i] = tempEndsI[i];\n  C->finalEndsJ[i] = tempEndsJ[i];\n  if ((length = strlen((char *) tempSeqsI[i])) < 1)\n  {\n    printf(\"mergeAlignment: strlen(tempSeqsI[%d]) = %d for process %d\\n\", i, length, threadNum);\n    exit(1);\n  }\n  length++;\n  if ((C->finalSeqsI[i] = (unsigned char *) malloc(length * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"mergeAlignment: cannot allocate C->finalSeqsI[%d]\\n\", i);\n    exit(1);\n  }\n  C->finalSeqsI[i] = (unsigned char *) strcpy((char *) C->finalSeqsI[i], (char *) tempSeqsI[i]);\n  free(tempSeqsI[i]);\n  tempSeqsI[i] = 0;\n  if ((length = strlen((char *) tempSeqsJ[i])) < 1)\n  {\n    printf(\"mergeAlignment: strlen(tempSeqsJ[%d]) = %d for process %d\\n\", i, length, threadNum);\n    exit(1);\n  }\n  length++;\n  if ((C->finalSeqsJ[i] = (unsigned char *) malloc(length * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"mergeAlignment: cannot allocate C->finalSeqsJ[%d]\\n\", i);\n    exit(1);\n  }\n  C->finalSeqsJ[i] = (unsigned char *) strcpy((char *) C->finalSeqsJ[i], (char *) tempSeqsJ[i]);\n  free(tempSeqsJ[i]);\n  tempSeqsJ[i] = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/19"}
{"code": "for (i = 0; i <= (2 * maxReports); i++)\n{\n  if (tempSeqsI[i])\n  {\n    free(tempSeqsI[i]);\n    tempSeqsI[i] = 0;\n    count++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/20"}
{"code": "for (i = 0; i <= (2 * maxReports); i++)\n{\n  if (tempSeqsJ[i])\n  {\n    free(tempSeqsJ[i]);\n    tempSeqsJ[i] = 0;\n    count++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/21"}
{"code": "for (i = 1; i <= C->numReports; i++)\n{\n  if (C->finalSeqsI[i])\n  {\n    free(C->finalSeqsI[i]);\n    C->finalSeqsI[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/22"}
{"code": "for (i = 1; i <= C->numReports; i++)\n{\n  if (C->finalSeqsJ[i])\n  {\n    free(C->finalSeqsJ[i]);\n    C->finalSeqsJ[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/mergeAlignment/23"}
{"code": "for (i = 1; i < 7; i++)\n{\n  startArray[i] = (int) ceil((((double) ((*seqLen) + 1)) * ((double) rand())) / ((double) 32767));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/0"}
{"code": "for (i = 1; i < 7; i++)\n{\n  len = strlen(insertionStrings[i]);\n  if ((codSeq = (unsigned char *) malloc(len * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"insertValidation: cannot allocate codSeq\\n\");\n    exit(1);\n  }\n  if (firstLastSelect[i] == 1)\n  {\n    for (j = 0; j < len; j++)\n    {\n      codSeq[j] = simMatrix->encode_first[(int) insertionStrings[i][j]];\n    }\n\n  }\n  else\n  {\n    for (j = 0; j < len; j++)\n    {\n      codSeq[j] = simMatrix->encode[(int) insertionStrings[i][j]];\n    }\n\n  }\n  start = startArray[i];\n  if ((newSeq = (unsigned char *) malloc(((len + (*seqLen)) + 1) * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"insertValidation: cannot allocate newSeq\\n\");\n    exit(1);\n  }\n  for (j = 1; j < start; j++)\n  {\n    newSeq[j] = oldSeq[j];\n  }\n\n  for (j = 0; j < len; j++)\n  {\n    newSeq[j + start] = codSeq[j];\n  }\n\n  for (j = start + len; j <= ((*seqLen) + len); j++)\n  {\n    newSeq[j] = oldSeq[j - len];\n  }\n\n  *seqLen += len;\n  free(oldSeq);\n  free(codSeq);\n  oldSeq = newSeq;\n  for (k = 1; k < 7; k++)\n  {\n    if (startArray[k] >= start)\n    {\n      startArray[k] = startArray[k] + len;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/1"}
{"code": "for (i = 1; i < 7; i++)\n{\n  maxLen = MAX(maxLen, MAX(strlen(mainValidations[i]), strlen(matchValidations[i]))) - 12;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/2"}
{"code": "for (i = 1; i <= mainLen; i++)\n{\n  seqData->main[i] = (unsigned char) (ceil((((double) (simSize - 2)) * ((double) rand())) / ((double) 32767)) + 1);\n  if (seqData->main[i] >= simSize)\n  {\n    printf(\"genScalData 1: seqData->main[%d] = %d\\n\", i, seqData->main[i]);\n  }\n  if (seqData->main[i] <= 0)\n  {\n    printf(\"genScalData 1: seqData->main[%d] = %d\\n\", i, seqData->main[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/3"}
{"code": "for (i = 1; i <= matchLen; i++)\n{\n  seqData->match[i] = (unsigned char) (ceil((((double) (simSize - 2)) * ((double) rand())) / ((double) 32767)) + 1);\n  if (seqData->match[i] >= simSize)\n  {\n    printf(\"genScalData 1: seqData->match[%d] = %d\\n\", i, seqData->match[i]);\n  }\n  if (seqData->match[i] <= 0)\n  {\n    printf(\"genScalData 1: seqData->match[%d] = %d\\n\", i, seqData->match[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/4"}
{"code": "for (i = 1; i <= mainLen; i++)\n{\n  if (seqData->main[i] >= simSize)\n  {\n    printf(\"genScalData 2: seqData->main[%d] = %d\\n\", i, seqData->main[i]);\n  }\n  if (seqData->main[i] <= 0)\n  {\n    printf(\"genScalData 2: seqData->main[%d] = %d\\n\", i, seqData->main[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/5"}
{"code": "for (i = 1; i <= matchLen; i++)\n{\n  if (seqData->match[i] >= simSize)\n  {\n    printf(\"genScalData 2: seqData->match[%d] = %d\\n\", i, seqData->match[i]);\n  }\n  if (seqData->match[i] <= 0)\n  {\n    printf(\"genScalData 2: seqData->match[%d] = %d\\n\", i, seqData->match[i]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genScalData/6"}
{"code": "for (t = 0; t < maxThreads; t++)\n{\n  if (B->numReports[t] != 0)\n  {\n    numReports += B->numReports[t];\n    maxScore = MAX(maxScore, B->bestScores[t][1]);\n    minScore = MIN(minScore, B->bestScores[t][B->numReports[t]]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/verifyAlignment/0"}
{"code": "for (t = 0; t < maxThreads; t++)\n{\n  thread = t;\n  numReports = B->numReports[t];\n  if (numReports == 0)\n  {\n  }\n  else\n  {\n  }\n  for (r = 1; r <= numReports; r++)\n  {\n    main = (char *) B->bestSeqsI[t][r];\n    match = (char *) B->bestSeqsJ[t][r];\n    mainMatch = (matchMatch = 1);\n    score = 0L;\n    for (c = 0; c < strlen(main); c++)\n    {\n      if (main[c] == simMatrix->hyphen)\n      {\n        if (mainMatch)\n        {\n          mainMatch = 0;\n          score -= simMatrix->gapStart;\n        }\n        score -= simMatrix->gapExtend;\n        continue;\n      }\n      if (match[c] == simMatrix->hyphen)\n      {\n        if (matchMatch)\n        {\n          matchMatch = 0;\n          score -= simMatrix->gapStart;\n        }\n        score -= simMatrix->gapExtend;\n        continue;\n      }\n      mainMatch = 1;\n      matchMatch = 1;\n      score += (long long) simMatrix->similarity[(int) main[c]][(int) match[c]];\n    }\n\n  }\n\n  fflush(stdout);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/verifyAlignment/1"}
{"code": "for (r = 1; r <= numReports; r++)\n{\n  main = (char *) C->finalSeqsI[r];\n  match = (char *) C->finalSeqsJ[r];\n  mainMatch = (matchMatch = 1);\n  score = 0L;\n  for (c = 0; c < strlen(main); c++)\n  {\n    if (main[c] == simMatrix->hyphen)\n    {\n      if (mainMatch)\n      {\n        mainMatch = 0;\n        score -= simMatrix->gapStart;\n      }\n      score -= simMatrix->gapExtend;\n      continue;\n    }\n    if (match[c] == simMatrix->hyphen)\n    {\n      if (matchMatch)\n      {\n        matchMatch = 0;\n        score -= simMatrix->gapStart;\n      }\n      score -= simMatrix->gapExtend;\n      continue;\n    }\n    mainMatch = 1;\n    matchMatch = 1;\n    score += (long long) simMatrix->similarity[(int) main[c]][(int) match[c]];\n  }\n\n  if (score != C->finalScores[r])\n  {\n    printf(\"\\nverifyMergeAlignment %d failed; reported %lld vs actual %lld:\", r, C->finalScores[r], score);\n    printf(\"   ---------------------------\\n\");\n    printf(\"%7d  \", C->finalStartsI[r]);\n    for (c = 0; c < strlen(main); c++)\n    {\n      printf(\"%c\", simMatrix->aminoAcid[(int) main[c]]);\n    }\n\n    printf(\"  \");\n    for (c = 0; c < strlen(main); c++)\n    {\n      printf(\"%s\", simMatrix->codon[(int) main[c]]);\n    }\n\n    printf(\"  %7d\\n\", C->finalEndsI[r]);\n    printf(\"%7d  \", C->finalStartsJ[r]);\n    for (c = 0; c < strlen(match); c++)\n    {\n      printf(\"%c\", simMatrix->aminoAcid[(int) match[c]]);\n    }\n\n    printf(\"  \");\n    for (c = 0; c < strlen(match); c++)\n    {\n      printf(\"%s\", simMatrix->codon[(int) match[c]]);\n    }\n\n    printf(\"  %7d\\n\", C->finalEndsJ[r]);\n  }\n  else\n    if (r <= maxDisplay)\n  {\n    printf(\"\\nverifyMergeAlignment %d, succeeded; score %lld\\n\", r, C->finalScores[r]);\n    printf(\"%7d  \", C->finalStartsI[r]);\n    for (c = 0; c < strlen(main); c++)\n    {\n      printf(\"%c\", simMatrix->aminoAcid[(int) main[c]]);\n    }\n\n    printf(\"  \");\n    for (c = 0; c < strlen(main); c++)\n    {\n      printf(\"%s\", simMatrix->codon[(int) main[c]]);\n    }\n\n    printf(\"  %7d\\n\", C->finalEndsI[r]);\n    printf(\"%7d  \", C->finalStartsJ[r]);\n    for (c = 0; c < strlen(match); c++)\n    {\n      printf(\"%c\", simMatrix->aminoAcid[(int) match[c]]);\n    }\n\n    printf(\"  \");\n    for (c = 0; c < strlen(match); c++)\n    {\n      printf(\"%s\", simMatrix->codon[(int) match[c]]);\n    }\n\n    printf(\"  %7d\\n\", C->finalEndsJ[r]);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/verifyMergeAlignment/0"}
{"code": "for (i = 0; i < ENCODE_SIZE; i++)\n{\n  simMatrix->encode[i] = simMatrix->star;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genSimMatrix/0"}
{"code": "for (i = 1; i <= 21; i++)\n{\n  aa = similarities[i][1];\n  for (j = 2; strlen(similarities[i][j]) != 0; j++)\n  {\n    codon = similarities[i][j];\n    ccode = 0;\n    for (k = 0; k < 3; k++)\n    {\n      base = codon[k];\n      switch (base)\n      {\n        case 'a':\n          ccode = 0 + (4 * ccode);\n          break;\n\n        case 'g':\n          ccode = 1 + (4 * ccode);\n          break;\n\n        case 'c':\n          ccode = 2 + (4 * ccode);\n          break;\n\n        case 't':\n          ccode = 3 + (4 * ccode);\n          break;\n\n        default:\n          printf(\"unrecognized base[%d][%d][%d] = %c\\n\", i, j, k, codon[k]);\n\n      }\n\n    }\n\n    ccode = ccode + 1;\n    if (j == 2)\n    {\n      ccode2 = ccode;\n    }\n    simMatrix->codon[ccode] = codon;\n    simMatrix->aminoAcid[ccode] = aa[0];\n  }\n\n  simMatrix->encode[(int) aa[0]] = (unsigned char) ccode;\n  simMatrix->encode_first[(int) aa[0]] = (unsigned char) ccode2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genSimMatrix/1"}
{"code": "for (i = 1; i < simSize; i++)\n{\n  for (j = 1; j < simSize; j++)\n  {\n    simMatrix->similarity[i][j] = (char) dissimilar;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genSimMatrix/2"}
{"code": "for (ccode = 1; ccode < simSize; ccode++)\n{\n  for (i = 1; i < simSize; i++)\n  {\n    if (simMatrix->aminoAcid[i] == simMatrix->aminoAcid[ccode])\n    {\n      simMatrix->similarity[ccode][i] = (char) similar;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genSimMatrix/3"}
{"code": "for (i = 1; i < simSize; i++)\n{\n  simMatrix->similarity[i][i] = (char) exact;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/genSimMatrix/4"}
{"code": "for (i = 1; i <= numThreads; i++)\n{\n  if ((numThreads % i) == 0)\n  {\n    row = i;\n    col = numThreads / i;\n    per = row + col;\n    if (per < minPer)\n    {\n      *npRow = row;\n      *npCol = col;\n      minPer = per;\n    }\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/0"}
{"code": "for (i = right; i >= left; i--)\n{\n  for (j = left + 1; j <= i; j++)\n  {\n    if (b[j - 1] > b[j])\n    {\n      t = b[j - 1];\n      b[j - 1] = b[j];\n      b[j] = t;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/1"}
{"code": "for (i = left; i <= right; i++)\n{\n  b[i] = a[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/2"}
{"code": "for (i = right; i >= left; i--)\n{\n  for (j = left + 1; j <= i; j++)\n  {\n    if (y[j - 1] > y[j])\n    {\n      t = a[j - 1];\n      a[j - 1] = a[j];\n      a[j] = t;\n      lT = y[j - 1];\n      y[j - 1] = y[j];\n      y[j] = lT;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/3"}
{"code": "for (i = 1; i <= n; i++)\n{\n  y[i] = x[i];\n  a[i] = i;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/4"}
{"code": "for (i = 0; i < maxThreads; i++)\n{\n  A->numReports[i] = 0;\n  A->goodScores[i] = 0L;\n  A->goodEndsI[i] = (A->goodEndsJ[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/5"}
{"code": "for (i = 1; i <= sortReports; i++)\n{\n  goodScores[i] = 0L;\n  goodEndsI[i] = (goodEndsJ[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/6"}
{"code": "for (i = iBeg; i <= iEnd; i++)\n{\n  mainSeq[(i - iBeg) + 1] = A->seqData->main[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/7"}
{"code": "for (j = jBeg; j <= jEnd; j++)\n{\n  matchSeq[(j - jBeg) + 1] = A->seqData->match[j];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/8"}
{"code": "for (i = 1; i < SIM_SIZE; i++)\n{\n  if ((weights[i] = (char *) malloc(SIM_SIZE * (sizeof(char)))) == 0)\n  {\n    printf(\"pairwiseAlign: cannot allocate weights[%d] for thread %d\\n\", i, myTaskID);\n    exit(1);\n  }\n  for (j = 1; j < SIM_SIZE; j++)\n  {\n    weights[i][j] = simMatrix->similarity[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/9"}
{"code": "for (j = jBeg; j <= jEnd; j++)\n{\n  V[(j - jBeg) + 1] = 0L;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/10"}
{"code": "for (j = jBeg; j <= jEnd; j++)\n{\n  F[(j - jBeg) + 1] = (long long) (-gapFirst);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/11"}
{"code": "for (i = iBeg; i <= iEnd; i++)\n{\n  G = (long long) weights[mainSeq[(i - iBeg) + 1]][matchSeq[1]];\n  Vp = V[1];\n  V[1] = MAX(0L, MAX(F[1], G));\n  F[1] = MAX(F[1] - gapExtend, V[1] - gapFirst);\n  E = V[1] - gapFirst;\n  for (j = jBeg + 2; j <= jEnd; j++)\n  {\n    W = (long long) weights[mainSeq[(i - iBeg) + 1]][matchSeq[(j - jBeg) + 1]];\n    G = W + Vp;\n    Vp = V[(j - jBeg) + 1];\n    V[(j - jBeg) + 1] = MAX(MAX(0L, E), MAX(F[(j - jBeg) + 1], G));\n    if ((((V[(j - jBeg) + 1] >= llMinScore) && (W > 0L)) && (V[(j - jBeg) + 1] == G)) && (((j == jEnd) || (i == iEnd)) || (weights[mainSeq[(i - iBeg) + 2]][matchSeq[(j - jBeg) + 2]] <= 0)))\n    {\n      for (r = report; r >= 1; r--)\n      {\n        if ((i - goodEndsI[r]) >= minSeparation)\n        {\n          break;\n        }\n        if (abs(j - goodEndsJ[r]) >= minSeparation)\n        {\n          continue;\n        }\n        if (goodScores[r] > V[(j - jBeg) + 1])\n        {\n          goto discardPoint;\n        }\n        for (k = r; k < report; k++)\n        {\n          goodScores[k] = goodScores[k + 1];\n          goodEndsI[k] = goodEndsI[k + 1];\n          goodEndsJ[k] = goodEndsJ[k + 1];\n        }\n\n        report--;\n      }\n\n      report++;\n      goodScores[report] = V[(j - jBeg) + 1];\n      goodEndsI[report] = i;\n      goodEndsJ[report] = j;\n      if (report == sortReports)\n      {\n        qSort_both(scores, index, goodScores, sortReports);\n        worst = (sortReports - maxReports) + 1;\n        llMinScore = scores[worst] + 1L;\n        qSort(best, index, worst, sortReports);\n        for (k = worst; k <= sortReports; k++)\n        {\n          scores[(k - worst) + 1] = goodScores[best[k]];\n        }\n\n        for (k = 1; k <= maxReports; k++)\n        {\n          goodScores[k] = scores[k];\n        }\n\n        for (k = worst; k <= sortReports; k++)\n        {\n          scores[(k - worst) + 1] = goodEndsI[best[k]];\n        }\n\n        for (k = 1; k <= maxReports; k++)\n        {\n          goodEndsI[k] = scores[k];\n        }\n\n        for (k = worst; k <= sortReports; k++)\n        {\n          scores[(k - worst) + 1] = goodEndsJ[best[k]];\n        }\n\n        for (k = 1; k <= maxReports; k++)\n        {\n          goodEndsJ[k] = scores[k];\n        }\n\n        report = maxReports;\n      }\n    }\n    discardPoint:\n    F[(j - jBeg) + 1] = MAX(F[(j - jBeg) + 1] - gapExtend, V[(j - jBeg) + 1] - gapFirst);\n\n    E = MAX(E - gapExtend, V[(j - jBeg) + 1] - gapFirst);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/12"}
{"code": "for (i = report; i >= 1; i--)\n{\n  A->goodScores[threadNum][j] = goodScores[index[i]];\n  A->goodEndsI[threadNum][j] = goodEndsI[index[i]];\n  A->goodEndsJ[threadNum][j] = goodEndsJ[index[i]];\n  j++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/13"}
{"code": "for (i = report; i >= worst; i--)\n{\n  A->goodScores[threadNum][j] = goodScores[index[i]];\n  A->goodEndsI[threadNum][j] = goodEndsI[index[i]];\n  A->goodEndsJ[threadNum][j] = goodEndsJ[index[i]];\n  j++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/14"}
{"code": "for (i = 1; i < SIM_SIZE; i++)\n{\n  free(weights[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/15"}
{"code": "for (i = 0; i < A->numThreads; i++)\n{\n  if (A->goodScores[i])\n  {\n    free(A->goodScores[i]);\n    A->goodScores[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/16"}
{"code": "for (i = 0; i < A->numThreads; i++)\n{\n  if (A->goodEndsI[i])\n  {\n    free(A->goodEndsI[i]);\n    A->goodEndsI[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/17"}
{"code": "for (i = 0; i < A->numThreads; i++)\n{\n  if (A->goodEndsJ[i])\n  {\n    free(A->goodEndsJ[i]);\n    A->goodEndsJ[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/pairwiseAlign/18"}
{"code": "for (i = 1; i <= 2; i++)\n{\n  V[i] = (long long *) malloc((m + 2) * (sizeof(long long)));\n  for (j = 1; j <= (m + 1); j++)\n  {\n    V[i][j] = MINUS_INFINITY;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/0"}
{"code": "for (i = 1; i <= m; i++)\n{\n  E[i] = (F[i] = MINUS_INFINITY);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/1"}
{"code": "for (r = 1; r <= (*bestR); r++)\n{\n  if (MAX(abs(di - bestStartsI[r]), abs(dj - bestStartsJ[r])) < minSeparation)\n  {\n    free(V[1]);\n    free(V[2]);\n    free(V);\n    free(E);\n    free(F);\n    return -10;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/2"}
{"code": "for (i = 0; i < maxThreads; i++)\n{\n  B->numReports[i] = 0;\n  B->bestScores[i] = 0;\n  B->bestStartsI[i] = (B->bestStartsJ[i] = 0);\n  B->bestEndsI[i] = (B->bestEndsJ[i] = 0);\n  B->bestSeqsI[i] = (B->bestSeqsJ[i] = 0);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/3"}
{"code": "for (i = 1; i <= maxReports; i++)\n{\n  bestScores[i] = 0L;\n  bestStartsI[i] = (bestStartsJ[i] = (bestEndsI[i] = (bestEndsJ[i] = 0)));\n  if ((bestSeqsI[i] = (unsigned char *) malloc((matchLimit + 1) * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"scanBackward: cannot allocate bestSeqsI[%d] for thread %d\\n\", i, myTaskID);\n    exit(1);\n  }\n  if ((bestSeqsJ[i] = (unsigned char *) malloc((matchLimit + 1) * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"scanBackward: cannot allocate bestSeqsJ[%d] for thread %d\\n\", i, myTaskID);\n    exit(1);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/4"}
{"code": "for (i = 1; i < SIM_SIZE; i++)\n{\n  if ((weights[i] = (char *) malloc(SIM_SIZE * (sizeof(char)))) == 0)\n  {\n    printf(\"locateSimilar: cannot allocates weights[%d] for thread %d\\n\", i, myTaskID);\n  }\n  for (j = 1; j < SIM_SIZE; j++)\n  {\n    weights[i][j] = A->simMatrix->similarity[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/5"}
{"code": "for (i = 1; i <= sizeT; i++)\n{\n  if ((T[i] = (unsigned char *) malloc((sizeT + 1) * (sizeof(unsigned char)))) == 0)\n  {\n    printf(\"scanBackward: cannot allocate T[%d] for thread %d\\n\", i, myTaskID);\n    exit(1);\n  }\n  for (j = 1; j <= sizeT; j++)\n  {\n    T[i][j] = 0;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/6"}
{"code": "for (r = 1; r <= A->numReports[threadNum]; r++)\n{\n  goal = A->goodScores[threadNum][r];\n  ei = A->goodEndsI[threadNum][r];\n  ej = A->goodEndsJ[threadNum][r];\n  for (i = 1; i <= sizeT; i++)\n  {\n    for (j = 1; j <= sizeT; j++)\n    {\n      T[i][j] = 0;\n    }\n\n  }\n\n  if (doScan(A, T, sizeT, ei, ej, mainSeq, matchSeq, weights, gapFirst, gapExtend, minSeparation, r, goal, iBeg, jBeg, iFin, jFin, iEnd, jEnd, myTaskID, &bestR, bestStartsI, bestStartsJ, bestEndsI, bestEndsJ, bestSeqsI, bestSeqsJ, bestScores) == (-1))\n  {\n    if (doublings >= maxDoublings)\n    {\n      printf(\"\\tscanBackward: sequence %d dropped for thread %d\\n\", r, myTaskID);\n    }\n    else\n    {\n      for (i = 1; i <= sizeT; i++)\n      {\n        free(T[i]);\n      }\n\n      free(T);\n      sizeT *= 2;\n      printf(\"\\tscanBackward: doubling sizeT to %d for thread %d\\n\", sizeT, myTaskID);\n      doublings++;\n      goto retry;\n    }\n  }\n  if (bestR == maxReports)\n  {\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/7"}
{"code": "for (j = 1; j <= bestR; j++)\n{\n  B->bestScores[threadNum][j] = bestScores[j];\n  B->bestStartsI[threadNum][j] = bestStartsI[j];\n  B->bestStartsJ[threadNum][j] = bestStartsJ[j];\n  B->bestEndsI[threadNum][j] = bestEndsI[j];\n  B->bestEndsJ[threadNum][j] = bestEndsJ[j];\n  B->bestSeqsI[threadNum][j] = copyStringR(bestSeqsI[j]);\n  B->bestSeqsJ[threadNum][j] = copyStringR(bestSeqsJ[j]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/8"}
{"code": "for (i = 1; i < B->numReports[threadNum]; i++)\n{\n  if (strlen((char *) B->bestSeqsI[threadNum][i]) < 1)\n  {\n    c++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/9"}
{"code": "for (i = 1; i < B->numReports[threadNum]; i++)\n{\n  if (strlen((char *) B->bestSeqsJ[threadNum][i]) < 1)\n  {\n    c++;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/10"}
{"code": "for (i = 1; i <= maxReports; i++)\n{\n  free(bestSeqsI[i]);\n  free(bestSeqsJ[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/11"}
{"code": "for (i = 1; i <= sizeT; i++)\n{\n  free(T[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/12"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestScores[i])\n  {\n    free(B->bestScores[i]);\n    B->bestScores[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/13"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestStartsI[i])\n  {\n    free(B->bestStartsI[i]);\n    B->bestStartsI[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/14"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestStartsJ[i])\n  {\n    free(B->bestStartsJ[i]);\n    B->bestStartsJ[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/15"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestEndsI[i])\n  {\n    free(B->bestEndsI[i]);\n    B->bestEndsI[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/16"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestEndsJ[i])\n  {\n    free(B->bestEndsJ[i]);\n    B->bestEndsJ[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/17"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestSeqsI[i])\n  {\n    for (j = 1; j <= B->numReports[i]; j++)\n    {\n      if (B->bestSeqsI[i][j])\n      {\n        free(B->bestSeqsI[i][j]);\n        B->bestSeqsI[i][j] = 0;\n      }\n    }\n\n    free(B->bestSeqsI[i]);\n    B->bestSeqsI[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/18"}
{"code": "for (i = 0; i < B->numThreads; i++)\n{\n  if (B->bestSeqsJ[i])\n  {\n    for (j = 1; j <= B->numReports[i]; j++)\n    {\n      if (B->bestSeqsJ[i][j])\n      {\n        free(B->bestSeqsJ[i][j]);\n        B->bestSeqsJ[i][j] = 0;\n      }\n    }\n\n    free(B->bestSeqsJ[i]);\n    B->bestSeqsJ[i] = 0;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/372.smithwa/src/scanBackward/19"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (argv[i][0] == '-')\n  {\n    switch (argv[i][1])\n    {\n      case 'c':\n        argv[i][1] = '*';\n        bots_check_flag = TRUE;\n        break;\n\n      case 'e':\n        argv[i][1] = '*';\n        i++;\n        if (argc == i)\n      {\n        bots_print_usage();\n        exit(100);\n      }\n        strcpy(bots_exec_message, argv[i]);\n        break;\n\n      case 'h':\n        argv[i][1] = '*';\n        bots_print_usage();\n        exit(100);\n\n      case 'o':\n        argv[i][1] = '*';\n        i++;\n        if (argc == i)\n      {\n        bots_print_usage();\n        exit(100);\n      }\n        bots_output_format = atoi(argv[i]);\n        break;\n\n      case 'v':\n        argv[i][1] = '*';\n        i++;\n        if (argc == i)\n      {\n        bots_print_usage();\n        exit(100);\n      }\n        bots_verbose_mode = (bots_verbose_mode_t) atoi(argv[i]);\n        if (bots_verbose_mode > 1)\n      {\n        fprintf(stderr, \"Error: Configure the suite using '--debug' option in order to use a verbose level greather than 1.\\n\");\n        exit(100);\n      }\n        break;\n\n      case 'z':\n        argv[i][1] = '*';\n        bots_print_header = TRUE;\n        break;\n\n      default:\n        fprintf(stderr, \"Error: Unrecognized parameter.\\n\");\n        bots_print_usage();\n        exit(100);\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"Error: Unrecognized parameter.\\n\");\n    bots_print_usage();\n    exit(100);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/common/bots_main/0"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n{\n  for (j = 0; j < bots_arg_size_1; j++)\n  {\n    r_err = M[(i * bots_arg_size_1) + j] - N[(i * bots_arg_size_1) + j];\n    if (r_err < 0.0)\n      r_err = -r_err;\n    r_err = r_err / M[(i * bots_arg_size_1) + j];\n    if (r_err > EPSILON)\n    {\n      bots_message(\"Checking failure: A[%d][%d]=%f  B[%d][%d]=%f; Relative Error=%f\\n\", i, j, M[(i * bots_arg_size_1) + j], i, j, N[(i * bots_arg_size_1) + j], r_err);\n      return FALSE;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/0"}
{"code": "for (ii = 0; ii < bots_arg_size; ii++)\n{\n  for (jj = 0; jj < bots_arg_size; jj++)\n  {\n    null_entry = FALSE;\n    if ((ii < jj) && ((ii % 3) != 0))\n      null_entry = TRUE;\n    if ((ii > jj) && ((jj % 3) != 0))\n      null_entry = TRUE;\n    if ((ii % 2) == 1)\n      null_entry = TRUE;\n    if ((jj % 2) == 1)\n      null_entry = TRUE;\n    if (ii == jj)\n      null_entry = FALSE;\n    if (ii == (jj - 1))\n      null_entry = FALSE;\n    if ((ii - 1) == jj)\n      null_entry = FALSE;\n    if (null_entry == FALSE)\n    {\n      M[(ii * bots_arg_size) + jj] = (float *) malloc((bots_arg_size_1 * bots_arg_size_1) * (sizeof(float)));\n      if (M[(ii * bots_arg_size) + jj] == 0)\n      {\n        bots_message(\"Error: Out of memory\\n\");\n        exit(101);\n      }\n      prow = (p = M[(ii * bots_arg_size) + jj]);\n      for (i = 0; i < bots_arg_size_1; i++)\n      {\n        rowsum = 0.0;\n        for (j = 0; j < bots_arg_size_1; j++)\n        {\n          init_val = (3125 * init_val) % 65536;\n          *p = (float) ((init_val - 32768.0) / 16384.0);\n          rowsum += abs(*p);\n          p++;\n        }\n\n        if (ii == jj)\n          *(prow + i) = (rowsum * ((float) bots_arg_size)) + abs(*(prow + i));\n        prow += bots_arg_size_1;\n      }\n\n    }\n    else\n    {\n      M[(ii * bots_arg_size) + jj] = 0;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/1"}
{"code": "for (ii = 0; ii < bots_arg_size; ii++)\n{\n  for (jj = 0; jj < bots_arg_size; jj++)\n  {\n    if (M[(ii * bots_arg_size) + jj] != 0)\n    {\n      bots_message(\"x\");\n    }\n    else\n      bots_message(\" \");\n  }\n\n  bots_message(\"\\n\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/2"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n  for (j = 0; j < bots_arg_size_1; j++)\n{\n  *p = 0.0;\n  p++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/3"}
{"code": "for (k = 0; k < bots_arg_size_1; k++)\n  for (i = k + 1; i < bots_arg_size_1; i++)\n{\n  diag[(i * bots_arg_size_1) + k] = diag[(i * bots_arg_size_1) + k] / diag[(k * bots_arg_size_1) + k];\n  for (j = k + 1; j < bots_arg_size_1; j++)\n    diag[(i * bots_arg_size_1) + j] = diag[(i * bots_arg_size_1) + j] - (diag[(i * bots_arg_size_1) + k] * diag[(k * bots_arg_size_1) + j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/4"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n  for (k = 0; k < bots_arg_size_1; k++)\n{\n  row[(i * bots_arg_size_1) + k] = row[(i * bots_arg_size_1) + k] / diag[(k * bots_arg_size_1) + k];\n  for (j = k + 1; j < bots_arg_size_1; j++)\n    row[(i * bots_arg_size_1) + j] = row[(i * bots_arg_size_1) + j] - (row[(i * bots_arg_size_1) + k] * diag[(k * bots_arg_size_1) + j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/5"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n  for (j = 0; j < bots_arg_size_1; j++)\n  for (k = 0; k < bots_arg_size_1; k++)\n  inner[(i * bots_arg_size_1) + j] = inner[(i * bots_arg_size_1) + j] - (row[(i * bots_arg_size_1) + k] * col[(k * bots_arg_size_1) + j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/6"}
{"code": "for (j = 0; j < bots_arg_size_1; j++)\n  for (k = 0; k < bots_arg_size_1; k++)\n  for (i = k + 1; i < bots_arg_size_1; i++)\n  col[(i * bots_arg_size_1) + j] = col[(i * bots_arg_size_1) + j] - (diag[(i * bots_arg_size_1) + k] * col[(k * bots_arg_size_1) + j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/7"}
{"code": "for (kk = 0; kk < bots_arg_size; kk++)\n{\n  lu0(BENCH[(kk * bots_arg_size) + kk]);\n  for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    #pragma omp task untied firstprivate(kk, jj) shared(BENCH)\n    {\n      fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n    }\n  }\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n  {\n    #pragma omp task untied firstprivate(kk, ii) shared(BENCH)\n    {\n      bdiv(BENCH[(kk * bots_arg_size) + kk], BENCH[(ii * bots_arg_size) + kk]);\n    }\n  }\n\n  #pragma omp taskwait\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n    for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    #pragma omp task untied firstprivate(kk, jj, ii) shared(BENCH)\n    {\n      if (BENCH[(ii * bots_arg_size) + jj] == 0)\n        BENCH[(ii * bots_arg_size) + jj] = allocate_clean_block();\n      bmod(BENCH[(ii * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj], BENCH[(ii * bots_arg_size) + jj]);\n    }\n  }\n\n\n  #pragma omp taskwait\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/8"}
{"code": "for (kk = 0; kk < bots_arg_size; kk++)\n{\n  lu0(BENCH[(kk * bots_arg_size) + kk]);\n  for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n  }\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n  {\n    bdiv(BENCH[(kk * bots_arg_size) + kk], BENCH[(ii * bots_arg_size) + kk]);\n  }\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n    for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    if (BENCH[(ii * bots_arg_size) + jj] == 0)\n      BENCH[(ii * bots_arg_size) + jj] = allocate_clean_block();\n    bmod(BENCH[(ii * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj], BENCH[(ii * bots_arg_size) + jj]);\n  }\n\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/9"}
{"code": "for (i = 0; i < bots_arg_size; i += 50)\n{\n  for (j = 0; j < bots_arg_size; j += 40)\n  {\n    ok = checkmat1(BENCH[(i * bots_arg_size) + j]);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/10"}
{"code": "for (i = 0; i < bots_arg_size_1; i += 20)\n{\n  for (j = 0; j < bots_arg_size_1; j += 20)\n  {\n    bots_message(\"Output Matrix: A[%d][%d]=%8.12f \\n\", i, j, N[(i * bots_arg_size_1) + j]);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/359.botsspar/src/omp-tasks/sparselu/sparselu_single/sparselu/11"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  if ((n = seqlen_array[si + 1]) != 0)\n  {\n    for (i = 1, len1 = 0; i <= n; i++)\n    {\n      char c = seq_array[si + 1][i];\n      if ((c != gap_pos1) && (c != gap_pos2))\n        len1++;\n    }\n\n    for (sj = si + 1; sj < nseqs; sj++)\n    {\n      if ((m = seqlen_array[sj + 1]) != 0)\n      {\n        #pragma omp task private(i,gg,len2,mm_score) firstprivate(m,n,si,sj,len1) shared(nseqs, bench_output,seqlen_array,seq_array,gap_pos1,gap_pos2,pw_ge_penalty,pw_go_penalty,mat_avscore)\n        {\n          int se1;\n          int se2;\n          int sb1;\n          int sb2;\n          int maxscore;\n          int seq1;\n          int seq2;\n          int g;\n          int gh;\n          int displ[(2 * 5000) + 1];\n          int print_ptr;\n          int last_print;\n          for (i = 1, len2 = 0; i <= m; i++)\n          {\n            char c = seq_array[sj + 1][i];\n            if ((c != gap_pos1) && (c != gap_pos2))\n              len2++;\n          }\n\n          gh = 10 * pw_ge_penalty;\n          gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n          g = (mat_avscore <= 0) ? (20 * gg) : ((2 * mat_avscore) * gg);\n          seq1 = si + 1;\n          seq2 = sj + 1;\n          forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n          reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n          print_ptr = 1;\n          last_print = 0;\n          diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n          mm_score = tracepath(sb1, sb2, &print_ptr, &last_print, displ, seq1, seq2);\n          if ((len1 == 0) || (len2 == 0))\n            mm_score = 0.0;\n          else\n            mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n          bench_output[(si * nseqs) + sj] = mm_score;\n        }\n      }\n    }\n\n  }\n}\n", "pragma": "omp for schedule(dynamic) private(i,n,si,sj,len1,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/0"}
{"code": "for (i = 0; i <= max_aa; i++)\n  for (j = 0; j <= max_aa; j++)\n  matrix[i][j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/1"}
{"code": "for (i = 0; i <= max_aa; i++)\n{\n  ti = xref[i];\n  for (j = 0; j <= i; j++)\n  {\n    tj = xref[j];\n    if ((ti != (-1)) && (tj != (-1)))\n    {\n      k = matptr[ix];\n      if (ti == tj)\n      {\n        matrix[ti][ti] = k * scale;\n        maxres++;\n      }\n      else\n      {\n        matrix[ti][tj] = k * scale;\n        matrix[tj][ti] = k * scale;\n      }\n      ix++;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/2"}
{"code": "for (i = 0; i <= max_aa; i++)\n{\n  for (j = 0; j <= i; j++)\n  {\n    av1 += matrix[i][j];\n    if (i == j)\n      av2 += matrix[i][j];\n    else\n      av3 += matrix[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/3"}
{"code": "for (i = 0; i <= max_aa; i++)\n  for (j = 1; j <= i; j++)\n{\n  if (matrix[i][j] < min)\n    min = matrix[i][j];\n  if (matrix[i][j] > max)\n    max = matrix[i][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/4"}
{"code": "for (i = 0; i < gap_pos1; i++)\n{\n  matrix[i][gap_pos1] = gr_score;\n  matrix[gap_pos1][i] = gr_score;\n  matrix[i][gap_pos2] = gr_score;\n  matrix[gap_pos2][i] = gr_score;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/5"}
{"code": "for (i = 0; i <= m; i++)\n{\n  HH[i] = 0;\n  DD[i] = -g;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/6"}
{"code": "for (i = 1; i <= n; i++)\n{\n  hh = (p = 0);\n  f = -g;\n  for (j = 1; j <= m; j++)\n  {\n    f -= gh;\n    t = (hh - g) - gh;\n    if (f < t)\n      f = t;\n    DD[j] -= gh;\n    t = (HH[j] - g) - gh;\n    if (DD[j] < t)\n      DD[j] = t;\n    hh = p + matrix[(int) ia[i]][(int) ib[j]];\n    if (hh < f)\n      hh = f;\n    if (hh < DD[j])\n      hh = DD[j];\n    if (hh < 0)\n      hh = 0;\n    p = HH[j];\n    HH[j] = hh;\n    if (hh > (*maxscore))\n    {\n      *maxscore = hh;\n      *se1 = i;\n      *se2 = j;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/7"}
{"code": "for (i = se2; i > 0; i--)\n{\n  HH[i] = -1;\n  DD[i] = -1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/8"}
{"code": "for (i = se1; i > 0; i--)\n{\n  hh = (f = -1);\n  if (i == se1)\n    p = 0;\n  else\n    p = -1;\n  for (j = se2; j > 0; j--)\n  {\n    f -= gh;\n    t = (hh - g) - gh;\n    if (f < t)\n      f = t;\n    DD[j] -= gh;\n    t = (HH[j] - g) - gh;\n    if (DD[j] < t)\n      DD[j] = t;\n    hh = p + matrix[(int) ia[i]][(int) ib[j]];\n    if (hh < f)\n      hh = f;\n    if (hh < DD[j])\n      hh = DD[j];\n    p = HH[j];\n    HH[j] = hh;\n    if (hh > cost)\n    {\n      cost = hh;\n      *sb1 = i;\n      *sb2 = j;\n      if (cost >= maxscore)\n        break;\n    }\n  }\n\n  if (cost >= maxscore)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/9"}
{"code": "for (j = 1; j <= N; j++)\n{\n  hh = (calc_score(1, j, A, B, seq1, seq2) - (((N - j) <= 0) ? (0) : (te + (gh * (N - j))))) - (((j - 1) <= 0) ? (0) : (tb + (gh * (j - 1))));\n  if (hh > midh)\n  {\n    midh = hh;\n    midj = j;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/10"}
{"code": "for (j = 1; j <= N; j++)\n{\n  HH[j] = (t = t - gh);\n  DD[j] = t - g;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/11"}
{"code": "for (i = 1; i <= midi; i++)\n{\n  s = HH[0];\n  HH[0] = (hh = (t = t - gh));\n  f = t - g;\n  for (j = 1; j <= N; j++)\n  {\n    if ((hh = (hh - g) - gh) > (f = f - gh))\n      f = hh;\n    if ((hh = (HH[j] - g) - gh) > (e = DD[j] - gh))\n      e = hh;\n    hh = s + calc_score(i, j, A, B, seq1, seq2);\n    if (f > hh)\n      hh = f;\n    if (e > hh)\n      hh = e;\n    s = HH[j];\n    HH[j] = hh;\n    DD[j] = e;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/12"}
{"code": "for (j = N - 1; j >= 0; j--)\n{\n  RR[j] = (t = t - gh);\n  SS[j] = t - g;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/13"}
{"code": "for (i = M - 1; i >= midi; i--)\n{\n  s = RR[N];\n  RR[N] = (hh = (t = t - gh));\n  f = t - g;\n  for (j = N - 1; j >= 0; j--)\n  {\n    if ((hh = (hh - g) - gh) > (f = f - gh))\n      f = hh;\n    if ((hh = (RR[j] - g) - gh) > (e = SS[j] - gh))\n      e = hh;\n    hh = s + calc_score(i + 1, j + 1, A, B, seq1, seq2);\n    if (f > hh)\n      hh = f;\n    if (e > hh)\n      hh = e;\n    s = RR[j];\n    RR[j] = hh;\n    SS[j] = e;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/14"}
{"code": "for (j = 0; j <= N; j++)\n{\n  hh = HH[j] + RR[j];\n  if (hh >= midh)\n    if ((hh > midh) || ((HH[j] != DD[j]) && (RR[j] == SS[j])))\n  {\n    midh = hh;\n    midj = j;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/15"}
{"code": "for (j = N; j >= 0; j--)\n{\n  hh = (DD[j] + SS[j]) + g;\n  if (hh > midh)\n  {\n    midh = hh;\n    midj = j;\n    type = 2;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/16"}
{"code": "for (i = 1; i <= ((*print_ptr) - 1); ++i)\n{\n  if (displ[i] == 0)\n  {\n    char c1 = seq_array[seq1][i1];\n    char c2 = seq_array[seq2][i2];\n    if (((c1 != gap_pos1) && (c1 != gap_pos2)) && (c1 == c2))\n      count++;\n    ++i1;\n    ++i2;\n    ++pos;\n  }\n  else\n    if ((k = displ[i]) > 0)\n  {\n    i2 += k;\n    pos += k;\n  }\n  else\n  {\n    i1 -= k;\n    pos -= k;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/17"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  if ((n = seqlen_array[si + 1]) != 0)\n  {\n    for (i = 1, len1 = 0; i <= n; i++)\n    {\n      char c = seq_array[si + 1][i];\n      if ((c != gap_pos1) && (c != gap_pos2))\n        len1++;\n    }\n\n    for (sj = si + 1; sj < nseqs; sj++)\n    {\n      if ((m = seqlen_array[sj + 1]) != 0)\n      {\n        int se1;\n        int se2;\n        int sb1;\n        int sb2;\n        int maxscore;\n        int seq1;\n        int seq2;\n        int g;\n        int gh;\n        int displ[(2 * 5000) + 1];\n        int print_ptr;\n        int last_print;\n        for (i = 1, len2 = 0; i <= m; i++)\n        {\n          char c = seq_array[sj + 1][i];\n          if ((c != gap_pos1) && (c != gap_pos2))\n            len2++;\n        }\n\n        gh = 10 * pw_ge_penalty;\n        gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n        g = (mat_avscore <= 0) ? (20 * gg) : ((2 * mat_avscore) * gg);\n        seq1 = si + 1;\n        seq2 = sj + 1;\n        forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n        reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n        print_ptr = 1;\n        last_print = 0;\n        diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n        mm_score = tracepath(sb1, sb2, &print_ptr, &last_print, displ, seq1, seq2);\n        if ((len1 == 0) || (len2 == 0))\n          mm_score = 0.0;\n        else\n          mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n        seq_output[(si * nseqs) + sj] = mm_score;\n      }\n    }\n\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/18"}
{"code": "for (i = 0; i < NUMRES; i++)\n  def_aa_xref[i] = -1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/19"}
{"code": "for (i = 0; c1 = amino_acid_order[i]; i++)\n  for (j = 0; c2 = amino_acid_codes[j]; j++)\n  if (c1 == c2)\n{\n  def_aa_xref[i] = j;\n  break;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/20"}
{"code": "for (i = 1; i <= nseqs; i++)\n  bots_debug(\"Sequence %d: %s %6.d aa\\n\", i, names[i], seqlen_array[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/21"}
{"code": "for (i = 0; i < nseqs; i++)\n  for (j = 0; j < nseqs; j++)\n  bench_output[(i * nseqs) + j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/22"}
{"code": "for (i = 0; i < nseqs; i++)\n  for (j = 0; j < nseqs; j++)\n  seq_output[(i * nseqs) + j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/23"}
{"code": "for (i = 0; i < nseqs; i++)\n  for (j = 0; j < nseqs; j++)\n  if (bench_output[(i * nseqs) + j] != 0)\n  bots_debug(\"Benchmark sequences (%d:%d) Aligned. Score: %d\\n\", i + 1, j + 1, (int) bench_output[(i * nseqs) + j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/24"}
{"code": "for (i = 0; i < nseqs; i += 200)\n  for (j = 0; j < nseqs; j++)\n{\n  bots_message(\"Output: Optimized prot. (%3d:%3d)=%5d \\n\", i + 1, j + 1, (int) bench_output[(i * nseqs) + j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/alignment/25"}
{"code": "for (i = 0; i < 128; i++)\n  chartab[i] = 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/0"}
{"code": "for (i = 0; i < 25; i++)\n{\n  char c = amino_acid_codes[i];\n  chartab[(int) c] = (chartab[tolower(c)] = c);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/1"}
{"code": "for (i = 1; i <= l; i++)\n  if (seq[i] == '-')\n{\n  naseq[i] = gap_pos2;\n}\nelse\n{\n  j = 0;\n  c = seq[i];\n  t = amino_acid_codes;\n  naseq[i] = -1;\n  while (t[j])\n  {\n    if (t[j] == c)\n    {\n      naseq[i] = j;\n      break;\n    }\n    j++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/2"}
{"code": "for (i = 0; i < (nseqs + 1); i++)\n{\n  names[i] = (char *) malloc((MAXNAMES + 1) * (sizeof(char)));\n  seq_array[i] = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/3"}
{"code": "for (i = 1; i <= strlen(line); i++)\n  if (line[i] != ' ')\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/4"}
{"code": "for (j = i; j <= strlen(line); j++)\n  if (line[j] == ' ')\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/5"}
{"code": "for (i = 0; i <= MAXLINE; i++)\n{\n  c = line[i];\n  if (((c == '\\n') || (c == EOS)) || (c == '>'))\n    break;\n  if (c == chartab[(int) c])\n  {\n    *len += 1;\n    seq[*len] = c;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/6"}
{"code": "for (i = 1; i <= no_seqs; i++)\n{\n  seq1 = get_seq(names[i], &l1, chartab, fin);\n  seqlen_array[i] = l1;\n  seq_array[i] = (char *) malloc((l1 + 2) * (sizeof(char)));\n  encode(seq1, seq_array[i], l1);\n  free(seq1);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/358.botsalgn/src/omp-tasks/alignment/alignment_for/sequence/7"}
{"code": "for (int i = 0; i < param.numbuckets; ++i)\n{\n  param.buckets[i] = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/0"}
{"code": "for (h = 0; h < imgD->height; ++h)\n{\n  imgD->imagedata[h] = (Pixel *) malloc((sizeof(Pixel)) * imgD->width);\n  for (w = 0; w < imgD->width; ++w)\n  {\n    imgD->imagedata[h][w].blue = 0;\n    imgD->imagedata[h][w].green = 0;\n    imgD->imagedata[h][w].red = 255;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/1"}
{"code": "for (i = 0; i < height; i += 8)\n{\n  wdtloop:\n  for (j = 0; j < width; j += 8)\n  {\n    nx = ((i + 8) > height) ? (height - i) : (8);\n    ny = ((j + 8) > width) ? (width - j) : (8);\n    n = 0;\n    i1_lumas = (double *) malloc(((sizeof(double)) * nx) * ny);\n    i2_lumas = (double *) malloc(((sizeof(double)) * nx) * ny);\n    for (ix = 0; ix < nx; ix++)\n    {\n      for (jx = 0; jx < ny; jx++)\n      {\n        i1_lumas[n] = ((0.299 * img1->imagedata[i + ix][j + jx].red) + (0.587 * img1->imagedata[i + ix][j + jx].green)) + (0.114 * img1->imagedata[i + ix][j + jx].blue);\n        i2_lumas[n] = ((0.299 * img2->imagedata[i + ix][j + jx].red) + (0.587 * img2->imagedata[i + ix][j + jx].green)) + (0.114 * img2->imagedata[i + ix][j + jx].blue);\n        n++;\n      }\n\n    }\n\n    i1_mean = mean(i1_lumas, n);\n    i2_mean = mean(i2_lumas, n);\n    i1_var = variance(i1_lumas, i1_mean, n);\n    i2_var = variance(i2_lumas, i2_mean, n);\n    covar = covariance(i1_lumas, i2_lumas, i1_mean, i2_mean, n);\n    ssim = ((((2 * i1_mean) * i2_mean) + c1) * ((2 * covar) + c2)) / ((((i1_mean * i1_mean) + (i2_mean * i2_mean)) + c1) * ((i1_var + i2_var) + c2));\n    ++cnt;\n    if (param.avg)\n    {\n      sum += ssim;\n    }\n    else\n    {\n      printf(\"(%d,%d)  SSIM = %10.9f\\n\", j, i, ssim);\n    }\n    if (param.numbuckets > 0)\n    {\n      int bucket;\n      bucket = (int) (ssim * ((float) param.numbuckets));\n      if (bucket == param.numbuckets)\n      {\n        bucket = param.numbuckets - 1;\n      }\n      param.buckets[bucket]++;\n    }\n    if ((param.threshold > 0.0) && (ssim < param.threshold))\n    {\n      ++numbelow;\n      if (numbelow > param.maxthresh)\n      {\n        printf(\"The maximum number of SSIM below the threshold has be reached. Aborting\\n\");\n        free(i1_lumas);\n        free(i2_lumas);\n        return -1;\n      }\n    }\n    if (param.dumpdiff)\n    {\n      for (ix = 0; ix < nx; ix++)\n      {\n        for (jx = 0; jx < ny; jx++)\n        {\n          imgD->imagedata[i + ix][j + jx].red = 255.0 * ssim;\n        }\n\n      }\n\n    }\n    free(i1_lumas);\n    free(i2_lumas);\n  }\n\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/2"}
{"code": "for (i = 0; i < param.numbuckets; ++i)\n{\n  float r1;\n  float r2;\n  r1 = ((float) i) / ((float) param.numbuckets);\n  r2 = (((float) i) + 1) / ((float) param.numbuckets);\n  printf(\"%f to %f: %d\\n\", r1, r2, param.buckets[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/3"}
{"code": "for (i = 0; i < n; i++)\n  sum += values[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/4"}
{"code": "for (i = 0; i < n; i++)\n  sum += (values[i] - mean) * (values[i] - mean);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/5"}
{"code": "for (i = 0; i < n; i++)\n  sum += (values1[i] - mean1) * (values2[i] - mean2);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/6"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->colormaporigin |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/7"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->colormaplength |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/8"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->x_origin |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/9"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->y_origin |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/10"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->width |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/11"}
{"code": "for (i = 0; i < ((signed int) (sizeof(unsigned short))); i++)\n  tga->height |= tmpshort[i] << (i * 8);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/12"}
{"code": "for (h = 0; h < tga->height; ++h)\n{\n  tga->imagedata[h] = (Pixel *) malloc((sizeof(Pixel)) * tga->width);\n  for (w = 0; w < tga->width; ++w)\n  {\n    tga->imagedata[h][w].blue = fgetc(fin);\n    tga->imagedata[h][w].green = fgetc(fin);\n    tga->imagedata[h][w].red = fgetc(fin);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/13"}
{"code": "for (h = 0; h < tga->height; ++h)\n{\n  tga->imagedata[h] = (Pixel *) malloc((sizeof(Pixel)) * tga->width);\n  buffer[h] = (unsigned char *) malloc(tga->width * (sizeof(unsigned char)));\n  pixels[h] = (YUV *) malloc(tga->width * (sizeof(YUV)));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/14"}
{"code": "for (i = 0; i < tga->height; i++)\n{\n  nb = fread(buffer[i], 1, tga->width, fin);\n  if (nb < tga->width)\n  {\n    printf(\"Error reading input.  Tried to read %d, got only %d\\n\", tga->width, nb);\n    exit(1);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/15"}
{"code": "for (i = 0; i < tga->height; i++)\n{\n  for (j = 0; j < tga->width; j++)\n  {\n    pixels[i][j].y = buffer[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/16"}
{"code": "for (i = 0; i < (tga->height / 2); i++)\n{\n  nb = fread(buffer[i], 1, tga->width / 2, fin);\n  if (nb < (tga->width / 2))\n  {\n    printf(\"Error reading input.  Tried to read %d, got only %d\\n\", tga->width / 2, nb);\n    exit(1);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/17"}
{"code": "for (i = 0; i < tga->height; i++)\n{\n  j2 = 0;\n  for (j = 0; j < tga->width; j++)\n  {\n    pixels[i][j].u = buffer[i2][j2];\n    if (j % 2)\n      ++j2;\n  }\n\n  if (i % 2)\n    ++i2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/18"}
{"code": "for (i = 0; i < tga->height; i++)\n{\n  j2 = 0;\n  for (j = 0; j < tga->width; j++)\n  {\n    pixels[i][j].v = buffer[i2][j2];\n    if (j % 2)\n      ++j2;\n  }\n\n  if (i % 2)\n    ++i2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/19"}
{"code": "for (i = tga->height - 1; i >= 0; i--)\n{\n  w = 0;\n  for (j = 0; j < tga->width; j++)\n  {\n    int b1 = (1.164 * (pixels[i][j].y - 16)) + (2.018 * (pixels[i][j].u - 128));\n    int g1 = ((1.164 * (pixels[i][j].y - 16)) - (0.812 * (pixels[i][j].v - 128))) - (0.391 * (pixels[i][j].u - 128));\n    int r1 = (1.164 * (pixels[i][j].y - 16)) + (1.596 * (pixels[i][j].v - 128));\n    if (b1 < 16)\n    {\n      b = 16;\n    }\n    else\n      if (b1 > 255)\n    {\n      b = 255;\n    }\n    else\n    {\n      b = b1;\n    }\n    if (r1 < 16)\n    {\n      r = 16;\n    }\n    else\n      if (r1 > 255)\n    {\n      r = 255;\n    }\n    else\n    {\n      r = r1;\n    }\n    if (g1 < 16)\n    {\n      g = 16;\n    }\n    else\n      if (g1 > 255)\n    {\n      g = 255;\n    }\n    else\n    {\n      g = g1;\n    }\n    tga->imagedata[h][w].blue = b;\n    tga->imagedata[h][w].green = g;\n    tga->imagedata[h][w].red = r;\n    ++w;\n  }\n\n  ++h;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/20"}
{"code": "for (i = 0; i < tga->height; i++)\n{\n  for (j = 0; j < tga->width; j++)\n  {\n    if (tga->datatypecode == 2)\n    {\n      fputc(tga->imagedata[i][j].blue, fout);\n      fputc(tga->imagedata[i][j].green, fout);\n    }\n    fputc(tga->imagedata[i][j].red, fout);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/ImageValidator/21"}
{"code": "for (i = 0; i < ((ssize_t) number_wands); i++)\n  clone_wands[i] = ClonePixelWand(wands[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_pixel-wand/0"}
{"code": "for (i = ((ssize_t) number_wands) - 1; i >= 0; i--)\n  wand[i] = DestroyPixelWand(wand[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_pixel-wand/1"}
{"code": "for (i = 0; i < ((ssize_t) number_wands); i++)\n  wands[i] = NewPixelWand();\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_pixel-wand/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket *p;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ConvertRGBToHSB(GetPixelRed(p), GetPixelGreen(p), GetPixelBlue(p), &hue, &saturation, &brightness);\n    brightness *= QuantumRange;\n    brightness_sum_x += brightness;\n    brightness_sum_x2 += brightness * brightness;\n    brightness_sum_x3 += (brightness * brightness) * brightness;\n    brightness_sum_x4 += ((brightness * brightness) * brightness) * brightness;\n    saturation *= QuantumRange;\n    saturation_sum_x += saturation;\n    saturation_sum_x2 += saturation * saturation;\n    saturation_sum_x3 += (saturation * saturation) * saturation;\n    saturation_sum_x4 += ((saturation * saturation) * saturation) * saturation;\n    area++;\n    p++;\n  }\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/filters_analyze/0"}
{"code": "for (; image != ((Image *) 0); image = GetNextImageInList(image))\n{\n  CacheView *image_view;\n  ssize_t y;\n  MagickBooleanType status;\n  brightness_sum_x = 0.0;\n  brightness_sum_x2 = 0.0;\n  brightness_sum_x3 = 0.0;\n  brightness_sum_x4 = 0.0;\n  brightness_mean = 0.0;\n  brightness_standard_deviation = 0.0;\n  brightness_kurtosis = 0.0;\n  brightness_skewness = 0.0;\n  saturation_sum_x = 0.0;\n  saturation_sum_x2 = 0.0;\n  saturation_sum_x3 = 0.0;\n  saturation_sum_x4 = 0.0;\n  saturation_mean = 0.0;\n  saturation_standard_deviation = 0.0;\n  saturation_kurtosis = 0.0;\n  saturation_skewness = 0.0;\n  area = 0.0;\n  status = MagickTrue;\n  image_view = AcquireCacheView(image);\n  #pragma omp parallel for schedule(dynamic,4) shared(status)\n  for (y = 0; y < ((ssize_t) image->rows); y++)\n  {\n    const PixelPacket *p;\n    ssize_t x;\n    if (status == MagickFalse)\n      continue;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n    if (p == ((const PixelPacket *) 0))\n    {\n      status = MagickFalse;\n      continue;\n    }\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    {\n      ConvertRGBToHSB(GetPixelRed(p), GetPixelGreen(p), GetPixelBlue(p), &hue, &saturation, &brightness);\n      brightness *= QuantumRange;\n      brightness_sum_x += brightness;\n      brightness_sum_x2 += brightness * brightness;\n      brightness_sum_x3 += (brightness * brightness) * brightness;\n      brightness_sum_x4 += ((brightness * brightness) * brightness) * brightness;\n      saturation *= QuantumRange;\n      saturation_sum_x += saturation;\n      saturation_sum_x2 += saturation * saturation;\n      saturation_sum_x3 += (saturation * saturation) * saturation;\n      saturation_sum_x4 += ((saturation * saturation) * saturation) * saturation;\n      area++;\n      p++;\n    }\n\n  }\n\n  image_view = DestroyCacheView(image_view);\n  if (area <= 0.0)\n    break;\n  brightness_mean = brightness_sum_x / area;\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", brightness_mean);\n  (void) SetImageProperty(image, \"filter:brightness:mean\", text);\n  brightness_standard_deviation = sqrt((brightness_sum_x2 / area) - (((brightness_sum_x / area) * brightness_sum_x) / area));\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", brightness_standard_deviation);\n  (void) SetImageProperty(image, \"filter:brightness:standard-deviation\", text);\n  if (brightness_standard_deviation != 0)\n    brightness_kurtosis = (((((brightness_sum_x4 / area) - (((4.0 * brightness_mean) * brightness_sum_x3) / area)) + ((((6.0 * brightness_mean) * brightness_mean) * brightness_sum_x2) / area)) - ((((3.0 * brightness_mean) * brightness_mean) * brightness_mean) * brightness_mean)) / (((brightness_standard_deviation * brightness_standard_deviation) * brightness_standard_deviation) * brightness_standard_deviation)) - 3.0;\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", brightness_kurtosis);\n  (void) SetImageProperty(image, \"filter:brightness:kurtosis\", text);\n  if (brightness_standard_deviation != 0)\n    brightness_skewness = (((brightness_sum_x3 / area) - (((3.0 * brightness_mean) * brightness_sum_x2) / area)) + (((2.0 * brightness_mean) * brightness_mean) * brightness_mean)) / ((brightness_standard_deviation * brightness_standard_deviation) * brightness_standard_deviation);\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", brightness_skewness);\n  (void) SetImageProperty(image, \"filter:brightness:skewness\", text);\n  saturation_mean = saturation_sum_x / area;\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", saturation_mean);\n  (void) SetImageProperty(image, \"filter:saturation:mean\", text);\n  saturation_standard_deviation = sqrt((saturation_sum_x2 / area) - (((saturation_sum_x / area) * saturation_sum_x) / area));\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", saturation_standard_deviation);\n  (void) SetImageProperty(image, \"filter:saturation:standard-deviation\", text);\n  if (saturation_standard_deviation != 0)\n    saturation_kurtosis = (((((saturation_sum_x4 / area) - (((4.0 * saturation_mean) * saturation_sum_x3) / area)) + ((((6.0 * saturation_mean) * saturation_mean) * saturation_sum_x2) / area)) - ((((3.0 * saturation_mean) * saturation_mean) * saturation_mean) * saturation_mean)) / (((saturation_standard_deviation * saturation_standard_deviation) * saturation_standard_deviation) * saturation_standard_deviation)) - 3.0;\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", saturation_kurtosis);\n  (void) SetImageProperty(image, \"filter:saturation:kurtosis\", text);\n  if (saturation_standard_deviation != 0)\n    saturation_skewness = (((saturation_sum_x3 / area) - (((3.0 * saturation_mean) * saturation_sum_x2) / area)) + (((2.0 * saturation_mean) * saturation_mean) * saturation_mean)) / ((saturation_standard_deviation * saturation_standard_deviation) * saturation_standard_deviation);\n  (void) FormatLocaleString(text, MaxTextExtent, \"%g\", saturation_skewness);\n  (void) SetImageProperty(image, \"filter:saturation:skewness\", text);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/filters_analyze/1"}
{"code": "for (i = 0; artifact != ((const char *) 0);)\n{\n  if (((*artifact) != '[') && (GlobExpression(artifact, pattern, MagickFalse) != MagickFalse))\n  {\n    if ((i + 1) >= ((ssize_t) length))\n    {\n      length <<= 1;\n      artifacts = (char **) ResizeQuantumMemory(artifacts, length, sizeof(*artifacts));\n      if (artifacts == ((char **) 0))\n      {\n        (void) ThrowMagickException(wand->exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", wand->name);\n        return (char **) 0;\n      }\n    }\n    artifacts[i] = ConstantString(artifact);\n    i++;\n  }\n  artifact = GetNextImageProperty(wand->images);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/0"}
{"code": "for (i = 0; property != ((const char *) 0);)\n{\n  if (((*property) != '[') && (GlobExpression(property, pattern, MagickFalse) != MagickFalse))\n  {\n    if ((i + 1) >= ((ssize_t) length))\n    {\n      length <<= 1;\n      profiles = (char **) ResizeQuantumMemory(profiles, length, sizeof(*profiles));\n      if (profiles == ((char **) 0))\n      {\n        (void) ThrowMagickException(wand->exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", wand->name);\n        return (char **) 0;\n      }\n    }\n    profiles[i] = ConstantString(property);\n    i++;\n  }\n  property = GetNextImageProfile(wand->images);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/1"}
{"code": "for (i = 0; property != ((const char *) 0);)\n{\n  if (((*property) != '[') && (GlobExpression(property, pattern, MagickFalse) != MagickFalse))\n  {\n    if ((i + 1) >= ((ssize_t) length))\n    {\n      length <<= 1;\n      properties = (char **) ResizeQuantumMemory(properties, length, sizeof(*properties));\n      if (properties == ((char **) 0))\n      {\n        (void) ThrowMagickException(wand->exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", wand->name);\n        return (char **) 0;\n      }\n    }\n    properties[i] = ConstantString(property);\n    i++;\n  }\n  property = GetNextImageProperty(wand->images);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/2"}
{"code": "for (i = 0; option != ((const char *) 0);)\n{\n  if (((*option) != '[') && (GlobExpression(option, pattern, MagickFalse) != MagickFalse))\n  {\n    if ((i + 1) >= ((ssize_t) length))\n    {\n      length <<= 1;\n      options = (char **) ResizeQuantumMemory(options, length, sizeof(*options));\n      if (options == ((char **) 0))\n      {\n        (void) ThrowMagickException(wand->exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", wand->name);\n        return (char **) 0;\n      }\n    }\n    options[i] = ConstantString(option);\n    i++;\n  }\n  option = GetNextImageOption(wand->image_info);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/3"}
{"code": "for (p = wand->image_info->sampling_factor; p != ((char *) 0); p = strchr(p, ','))\n{\n  while ((((int) (*p)) != 0) && ((isspace((int) ((unsigned char) (*p))) != 0) || ((*p) == ',')))\n    p++;\n\n  i++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/4"}
{"code": "for (p = wand->image_info->sampling_factor; p != ((char *) 0); p = strchr(p, ','))\n{\n  while ((((int) (*p)) != 0) && ((isspace((int) ((unsigned char) (*p))) != 0) || ((*p) == ',')))\n    p++;\n\n  sampling_factors[i] = InterpretLocaleValue(p, (char **) 0);\n  i++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/5"}
{"code": "for (i = 0; i < ((ssize_t) (number_factors - 1)); i++)\n{\n  (void) FormatLocaleString(sampling_factor, MaxTextExtent, \"%g,\", sampling_factors[i]);\n  (void) ConcatenateString(&wand->image_info->sampling_factor, sampling_factor);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/wand_magick-property/6"}
{"code": "for (p = start; (*p) != '\\0';)\n{\n  while ((isspace((int) ((unsigned char) (*p))) != 0) && ((*p) != '\\0'))\n    p++;\n\n  if ((*p) == '\\0')\n    break;\n  switch (*p)\n  {\n    case '\"':\n\n    case '\\'':\n\n    case '`':\n\n    case '{':\n    {\n      char escape;\n      switch (*p)\n      {\n        case '\"':\n          escape = '\"';\n          break;\n\n        case '\\'':\n          escape = '\\'';\n          break;\n\n        case '`':\n          escape = '\\'';\n          break;\n\n        case '{':\n          escape = '}';\n          break;\n\n        default:\n          escape = *p;\n          break;\n\n      }\n\n      for (p++; (*p) != '\\0'; p++)\n      {\n        if (((*p) == '\\\\') && (((*(p + 1)) == escape) || ((*(p + 1)) == '\\\\')))\n          p++;\n        else\n          if ((*p) == escape)\n        {\n          p++;\n          break;\n        }\n        token[i++] = *p;\n      }\n\n      break;\n    }\n\n    case '/':\n    {\n      token[i++] = *(p++);\n      if (((*p) == '>') || ((*p) == '/'))\n        token[i++] = *(p++);\n      break;\n    }\n\n    default:\n    {\n      char *q;\n      value = InterpretLocaleValue(p, &q);\n      (void) value;\n      if ((p != q) && ((*p) != ','))\n      {\n        for (; (p < q) && ((*p) != ','); p++)\n          token[i++] = *p;\n\n        if ((*p) == '%')\n          token[i++] = *(p++);\n        break;\n      }\n      if ((((((*p) != '\\0') && (isalpha((int) ((unsigned char) (*p))) == 0)) && ((*p) != (*DirectorySeparator))) && ((*p) != '#')) && ((*p) != '<'))\n      {\n        token[i++] = *(p++);\n        break;\n      }\n      for (; (*p) != '\\0'; p++)\n      {\n        if ((((((isspace((int) ((unsigned char) (*p))) != 0) || ((*p) == '=')) || ((*p) == ',')) || ((*p) == ':')) || ((*p) == ';')) && ((*(p - 1)) != '\\\\'))\n          break;\n        if ((i > 0) && ((*p) == '<'))\n          break;\n        token[i++] = *p;\n        if ((*p) == '>')\n          break;\n        if ((*p) == '(')\n          for (p++; (*p) != '\\0'; p++)\n        {\n          token[i++] = *p;\n          if (((*p) == ')') && ((*(p - 1)) != '\\\\'))\n            break;\n        }\n\n      }\n\n      break;\n    }\n\n  }\n\n  break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_token/0"}
{"code": "for (;;)\n{\n  if ((GetUTFCode(pattern) == 0) || (GetUTFCode(pattern) == ']'))\n  {\n    done = MagickTrue;\n    break;\n  }\n  if (GetUTFCode(pattern) == '\\\\')\n  {\n    pattern += GetUTFOctets(pattern);\n    if (GetUTFCode(pattern) == 0)\n    {\n      done = MagickTrue;\n      break;\n    }\n  }\n  if (GetUTFCode(pattern + GetUTFOctets(pattern)) == '-')\n  {\n    c = GetUTFCode(pattern);\n    pattern += GetUTFOctets(pattern);\n    pattern += GetUTFOctets(pattern);\n    if (GetUTFCode(pattern) == ']')\n    {\n      done = MagickTrue;\n      break;\n    }\n    if (GetUTFCode(pattern) == '\\\\')\n    {\n      pattern += GetUTFOctets(pattern);\n      if (GetUTFCode(pattern) == 0)\n      {\n        done = MagickTrue;\n        break;\n      }\n    }\n    if ((GetUTFCode(expression) < c) || (GetUTFCode(expression) > GetUTFCode(pattern)))\n    {\n      pattern += GetUTFOctets(pattern);\n      continue;\n    }\n  }\n  else\n    if (GetUTFCode(pattern) != GetUTFCode(expression))\n  {\n    pattern += GetUTFOctets(pattern);\n    continue;\n  }\n  pattern += GetUTFOctets(pattern);\n  while ((GetUTFCode(pattern) != ']') && (GetUTFCode(pattern) != 0))\n  {\n    if ((GetUTFCode(pattern) == '\\\\') && (GetUTFCode(pattern + GetUTFOctets(pattern)) > 0))\n      pattern += GetUTFOctets(pattern);\n    pattern += GetUTFOctets(pattern);\n  }\n\n  if (GetUTFCode(pattern) != 0)\n  {\n    pattern += GetUTFOctets(pattern);\n    expression += GetUTFOctets(expression);\n  }\n  break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_token/1"}
{"code": "for (p = string; (*p) != '\\0'; p++)\n  if (c == ((int) (*p)))\n  return (ssize_t) (p - string);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_token/2"}
{"code": "for (token_info->offset = 0; ((int) line[*next]) != 0; (*next)++)\n{\n  c = (int) line[*next];\n  i = sindex(c, break_set);\n  if (i >= 0)\n  {\n    switch (token_info->state)\n    {\n      case 0:\n\n      case 1:\n\n      case 3:\n      {\n        (*next)++;\n        *breaker = break_set[i];\n        token[token_info->offset] = '\\0';\n        return 0;\n      }\n\n      case 2:\n      {\n        StoreToken(token_info, token, max_token_length, c);\n        break;\n      }\n\n    }\n\n    continue;\n  }\n  i = sindex(c, quote);\n  if (i >= 0)\n  {\n    switch (token_info->state)\n    {\n      case 0:\n      {\n        token_info->state = 2;\n        token_info->quote = quote[i];\n        *quoted = (char) MagickTrue;\n        break;\n      }\n\n      case 2:\n      {\n        if (quote[i] != token_info->quote)\n          StoreToken(token_info, token, max_token_length, c);\n        else\n        {\n          token_info->state = 3;\n          token_info->quote = '\\0';\n        }\n        break;\n      }\n\n      case 1:\n\n      case 3:\n      {\n        *breaker = (char) c;\n        token[token_info->offset] = '\\0';\n        return 0;\n      }\n\n    }\n\n    continue;\n  }\n  i = sindex(c, white);\n  if (i >= 0)\n  {\n    switch (token_info->state)\n    {\n      case 0:\n\n      case 3:\n        break;\n\n      case 1:\n      {\n        token_info->state = 3;\n        break;\n      }\n\n      case 2:\n      {\n        StoreToken(token_info, token, max_token_length, c);\n        break;\n      }\n\n    }\n\n    continue;\n  }\n  if (c == ((int) escape))\n  {\n    if (line[(*next) + 1] == '\\0')\n    {\n      *breaker = '\\0';\n      StoreToken(token_info, token, max_token_length, c);\n      (*next)++;\n      token[token_info->offset] = '\\0';\n      return 0;\n    }\n    switch (token_info->state)\n    {\n      case 0:\n      {\n        (*next)--;\n        token_info->state = 1;\n        break;\n      }\n\n      case 1:\n\n      case 2:\n      {\n        (*next)++;\n        c = (int) line[*next];\n        StoreToken(token_info, token, max_token_length, c);\n        break;\n      }\n\n      case 3:\n      {\n        token[token_info->offset] = '\\0';\n        return 0;\n      }\n\n    }\n\n    continue;\n  }\n  switch (token_info->state)\n  {\n    case 0:\n      token_info->state = 1;\n\n    case 1:\n\n    case 2:\n    {\n      StoreToken(token_info, token, max_token_length, c);\n      break;\n    }\n\n    case 3:\n    {\n      token[token_info->offset] = '\\0';\n      return 0;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_token/3"}
{"code": "for (i = 0; fontmap[i].name != ((char *) 0); i++)\n{\n  if (family == ((const char *) 0))\n  {\n    if ((LocaleCompare(fontmap[i].name, \"arial\") != 0) && (LocaleCompare(fontmap[i].name, \"helvetica\") != 0))\n      continue;\n  }\n  else\n    if (LocaleCompare(fontmap[i].name, family) != 0)\n    continue;\n  type_info = GetTypeInfoByFamily(fontmap[i].substitute, style, stretch, weight, exception);\n  break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_type/0"}
{"code": "for (i = 0; p != ((const TypeInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    fonts[i++] = p;\n  p = (const TypeInfo *) GetNextValueInSplayTree(type_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_type/1"}
{"code": "for (i = 0; p != ((const TypeInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    fonts[i++] = ConstantString(p->name);\n  p = (const TypeInfo *) GetNextValueInSplayTree(type_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_type/2"}
{"code": "for (i = 0; i < ((ssize_t) number_fonts); i++)\n{\n  if (type_info[i]->stealth != MagickFalse)\n    continue;\n  if (((path == ((const char *) 0)) || (LocaleCompare(path, type_info[i]->path) != 0)) && (type_info[i]->path != ((char *) 0)))\n    (void) FormatLocaleFile(file, \"\\nPath: %s\\n\", type_info[i]->path);\n  path = type_info[i]->path;\n  name = \"unknown\";\n  if (type_info[i]->name != ((char *) 0))\n    name = type_info[i]->name;\n  family = \"unknown\";\n  if (type_info[i]->family != ((char *) 0))\n    family = type_info[i]->family;\n  style = CommandOptionToMnemonic(MagickStyleOptions, type_info[i]->style);\n  stretch = CommandOptionToMnemonic(MagickStretchOptions, type_info[i]->stretch);\n  glyphs = \"unknown\";\n  if (type_info[i]->glyphs != ((char *) 0))\n    glyphs = type_info[i]->glyphs;\n  (void) FormatLocaleString(weight, MaxTextExtent, \"%.20g\", (double) type_info[i]->weight);\n  (void) FormatLocaleFile(file, \"  Font: %s\\n\", name);\n  (void) FormatLocaleFile(file, \"    family: %s\\n\", family);\n  (void) FormatLocaleFile(file, \"    style: %s\\n\", style);\n  (void) FormatLocaleFile(file, \"    stretch: %s\\n\", stretch);\n  (void) FormatLocaleFile(file, \"    weight: %s\\n\", weight);\n  (void) FormatLocaleFile(file, \"    glyphs: %s\\n\", glyphs);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_type/3"}
{"code": "for (q = (char *) xml; (*q) != '\\0';)\n{\n  GetMagickToken(q, &q, token);\n  if ((*token) == '\\0')\n    break;\n  (void) CopyMagickString(keyword, token, MaxTextExtent);\n  if (LocaleNCompare(keyword, \"<!DOCTYPE\", 9) == 0)\n  {\n    while ((LocaleNCompare(q, \"]>\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleNCompare(keyword, \"<!--\", 4) == 0)\n  {\n    while ((LocaleNCompare(q, \"->\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<include\") == 0)\n  {\n    while ((((*token) != '/') && ((*(token + 1)) != '>')) && ((*q) != '\\0'))\n    {\n      (void) CopyMagickString(keyword, token, MaxTextExtent);\n      GetMagickToken(q, &q, token);\n      if ((*token) != '=')\n        continue;\n      GetMagickToken(q, &q, token);\n      if (LocaleCompare(keyword, \"file\") == 0)\n      {\n        if (depth > 200)\n          (void) ThrowMagickException(exception, GetMagickModule(), ConfigureError, \"IncludeNodeNestedTooDeeply\", \"`%s'\", token);\n        else\n        {\n          char path[MaxTextExtent];\n          char *xml;\n          ExceptionInfo *sans_exception;\n          *path = '\\0';\n          GetPathComponent(filename, HeadPath, path);\n          if ((*path) != '\\0')\n            (void) ConcatenateMagickString(path, DirectorySeparator, MaxTextExtent);\n          if ((*token) == (*DirectorySeparator))\n            (void) CopyMagickString(path, token, MaxTextExtent);\n          else\n            (void) ConcatenateMagickString(path, token, MaxTextExtent);\n          sans_exception = AcquireExceptionInfo();\n          xml = FileToString(path, ~0, sans_exception);\n          sans_exception = DestroyExceptionInfo(sans_exception);\n          if (xml != ((char *) 0))\n          {\n            status = LoadTypeList(xml, path, depth + 1, exception);\n            xml = (char *) RelinquishMagickMemory(xml);\n          }\n        }\n      }\n    }\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<type\") == 0)\n  {\n    type_info = (TypeInfo *) AcquireMagickMemory(sizeof(*type_info));\n    if (type_info == ((TypeInfo *) 0))\n      ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(type_info, 0, sizeof(*type_info));\n    type_info->path = ConstantString(filename);\n    type_info->signature = MagickSignature;\n    continue;\n  }\n  if (type_info == ((TypeInfo *) 0))\n    continue;\n  if (LocaleCompare(keyword, \"/>\") == 0)\n  {\n    status = AddValueToSplayTree(type_list, type_info->name, type_info);\n    if (status == MagickFalse)\n      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", type_info->name);\n    type_info = (TypeInfo *) 0;\n  }\n  GetMagickToken(q, (const char **) 0, token);\n  if ((*token) != '=')\n    continue;\n  GetMagickToken(q, &q, token);\n  GetMagickToken(q, &q, token);\n  switch (*keyword)\n  {\n    case 'E':\n\n    case 'e':\n    {\n      if (LocaleCompare((char *) keyword, \"encoding\") == 0)\n      {\n        type_info->encoding = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'F':\n\n    case 'f':\n    {\n      if (LocaleCompare((char *) keyword, \"face\") == 0)\n      {\n        type_info->face = StringToUnsignedLong(token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"family\") == 0)\n      {\n        type_info->family = ConstantString(token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"format\") == 0)\n      {\n        type_info->format = ConstantString(token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"foundry\") == 0)\n      {\n        type_info->foundry = ConstantString(token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"fullname\") == 0)\n      {\n        type_info->description = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'G':\n\n    case 'g':\n    {\n      if (LocaleCompare((char *) keyword, \"glyphs\") == 0)\n      {\n        char *path;\n        path = ConstantString(token);\n        if (IsPathAccessible(path) == MagickFalse)\n        {\n          path = DestroyString(path);\n          GetPathComponent(filename, HeadPath, font_path);\n          (void) ConcatenateMagickString(font_path, DirectorySeparator, MaxTextExtent);\n          (void) ConcatenateMagickString(font_path, token, MaxTextExtent);\n          path = ConstantString(font_path);\n          if (IsPathAccessible(path) == MagickFalse)\n          {\n            path = DestroyString(path);\n            path = ConstantString(token);\n          }\n        }\n        type_info->glyphs = path;\n        break;\n      }\n      break;\n    }\n\n    case 'M':\n\n    case 'm':\n    {\n      if (LocaleCompare((char *) keyword, \"metrics\") == 0)\n      {\n        char *path;\n        path = ConstantString(token);\n        if (IsPathAccessible(path) == MagickFalse)\n        {\n          path = DestroyString(path);\n          GetPathComponent(filename, HeadPath, font_path);\n          (void) ConcatenateMagickString(font_path, DirectorySeparator, MaxTextExtent);\n          (void) ConcatenateMagickString(font_path, token, MaxTextExtent);\n          path = ConstantString(font_path);\n        }\n        type_info->metrics = path;\n        break;\n      }\n      break;\n    }\n\n    case 'N':\n\n    case 'n':\n    {\n      if (LocaleCompare((char *) keyword, \"name\") == 0)\n      {\n        type_info->name = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'S':\n\n    case 's':\n    {\n      if (LocaleCompare((char *) keyword, \"stealth\") == 0)\n      {\n        type_info->stealth = IsMagickTrue(token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"stretch\") == 0)\n      {\n        type_info->stretch = (StretchType) ParseCommandOption(MagickStretchOptions, MagickFalse, token);\n        break;\n      }\n      if (LocaleCompare((char *) keyword, \"style\") == 0)\n      {\n        type_info->style = (StyleType) ParseCommandOption(MagickStyleOptions, MagickFalse, token);\n        break;\n      }\n      break;\n    }\n\n    case 'W':\n\n    case 'w':\n    {\n      if (LocaleCompare((char *) keyword, \"weight\") == 0)\n      {\n        type_info->weight = StringToUnsignedLong(token);\n        if (LocaleCompare(token, \"bold\") == 0)\n          type_info->weight = 700;\n        if (LocaleCompare(token, \"normal\") == 0)\n          type_info->weight = 400;\n        break;\n      }\n      break;\n    }\n\n    default:\n      break;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_type/4"}
{"code": "for (i = 0; i < ((ssize_t) number_components); i++)\n{\n  GetPathComponent(components[i], SubimagePath, subnode);\n  GetPathComponent(components[i], CanonicalPath, tag);\n  child = GetXMLTreeChild(node, tag);\n  if (child == ((XMLTreeInfo *) 0))\n    child = AddChildToXMLTree(node, tag, offset);\n  node = child;\n  if (node == ((XMLTreeInfo *) 0))\n    break;\n  for (j = ((ssize_t) StringToLong(subnode)) - 1; j > 0; j--)\n  {\n    node = GetXMLTreeOrdered(node);\n    if (node == ((XMLTreeInfo *) 0))\n      break;\n  }\n\n  if (node == ((XMLTreeInfo *) 0))\n    break;\n  components[i] = DestroyString(components[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/0"}
{"code": "for (; i < ((ssize_t) number_components); i++)\n  components[i] = DestroyString(components[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/1"}
{"code": "for (p = utf8; (*p) != '\\0'; p++)\n  if (((((*p) < 0x20) && ((*p) != 0x09)) && ((*p) != 0x0a)) && ((*p) != 0x0d))\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/2"}
{"code": "for (p = utf8; (*p) != '\\0'; p++)\n{\n  if ((i + MaxTextExtent) > ((ssize_t) extent))\n  {\n    extent += MaxTextExtent;\n    canonical_content = (char *) ResizeQuantumMemory(canonical_content, extent, sizeof(*canonical_content));\n    if (canonical_content == ((char *) 0))\n      return canonical_content;\n  }\n  switch (*p)\n  {\n    case '&':\n    {\n      i += FormatLocaleString(canonical_content + i, extent, \"&amp;\");\n      break;\n    }\n\n    case '<':\n    {\n      i += FormatLocaleString(canonical_content + i, extent, \"&lt;\");\n      break;\n    }\n\n    case '>':\n    {\n      i += FormatLocaleString(canonical_content + i, extent, \"&gt;\");\n      break;\n    }\n\n    case '\"':\n    {\n      i += FormatLocaleString(canonical_content + i, extent, \"&quot;\");\n      break;\n    }\n\n    case '\\n':\n    {\n      if (pedantic == MagickFalse)\n      {\n        canonical_content[i++] = (char) (*p);\n        break;\n      }\n      i += FormatLocaleString(canonical_content + i, extent, \"&#xA;\");\n      break;\n    }\n\n    case '\\t':\n    {\n      if (pedantic == MagickFalse)\n      {\n        canonical_content[i++] = (char) (*p);\n        break;\n      }\n      i += FormatLocaleString(canonical_content + i, extent, \"&#x9;\");\n      break;\n    }\n\n    case '\\r':\n    {\n      i += FormatLocaleString(canonical_content + i, extent, \"&#xD;\");\n      break;\n    }\n\n    default:\n    {\n      canonical_content[i++] = (char) (*p);\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/3"}
{"code": "for (i = 0; attributes[i] != ((char *) 0); i += 2)\n{\n  if (attributes[i] != ((char *) 0))\n    attributes[i] = DestroyString(attributes[i]);\n  if (attributes[i + 1] != ((char *) 0))\n    attributes[i + 1] = DestroyString(attributes[i + 1]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/4"}
{"code": "for (i = 10; root->entities[i]; i += 2)\n  root->entities[i + 1] = DestroyString(root->entities[i + 1]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/5"}
{"code": "for (i = 0; root->attributes[i] != ((char **) 0); i++)\n{\n  attributes = root->attributes[i];\n  if (attributes[0] != ((char *) 0))\n    attributes[0] = DestroyString(attributes[0]);\n  for (j = 1; attributes[j] != ((char *) 0); j += 3)\n  {\n    if (attributes[j] != ((char *) 0))\n      attributes[j] = DestroyString(attributes[j]);\n    if (attributes[j + 1] != ((char *) 0))\n      attributes[j + 1] = DestroyString(attributes[j + 1]);\n    if (attributes[j + 2] != ((char *) 0))\n      attributes[j + 2] = DestroyString(attributes[j + 2]);\n  }\n\n  attributes = (char **) RelinquishMagickMemory(attributes);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/6"}
{"code": "for (i = 0; root->processing_instructions[i] != ((char **) 0); i++)\n{\n  for (j = 0; root->processing_instructions[i][j] != ((char *) 0); j++)\n    root->processing_instructions[i][j] = DestroyString(root->processing_instructions[i][j]);\n\n  root->processing_instructions[i][j + 1] = DestroyString(root->processing_instructions[i][j + 1]);\n  root->processing_instructions[i] = (char **) RelinquishMagickMemory(root->processing_instructions[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/7"}
{"code": "for (i = 0; i < ((ssize_t) number_components); i++)\n{\n  GetPathComponent(components[i], SubimagePath, subnode);\n  GetPathComponent(components[i], CanonicalPath, tag);\n  node = GetXMLTreeChild(node, tag);\n  if (node == ((XMLTreeInfo *) 0))\n    break;\n  for (j = ((ssize_t) StringToLong(subnode)) - 1; j > 0; j--)\n  {\n    node = GetXMLTreeOrdered(node);\n    if (node == ((XMLTreeInfo *) 0))\n      break;\n  }\n\n  if (node == ((XMLTreeInfo *) 0))\n    break;\n  components[i] = DestroyString(components[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/8"}
{"code": "for (i = 2; i < ((ssize_t) ((*length) - 1)); i += 2)\n{\n  c = (encoding != 0) ? (((content[i] & 0xff) << 8) | (content[i + 1] & 0xff)) : (((content[i + 1] & 0xff) << 8) | (content[i] & 0xff));\n  if (((c >= 0xd800) && (c <= 0xdfff)) && ((i += 2) < ((ssize_t) ((*length) - 1))))\n  {\n    byte = (encoding != 0) ? (((content[i] & 0xff) << 8) | (content[i + 1] & 0xff)) : (((content[i + 1] & 0xff) << 8) | (content[i] & 0xff));\n    c = (((c & 0x3ff) << 10) | (byte & 0x3ff)) + 0x10000;\n  }\n  if (((size_t) (j + MaxTextExtent)) > extent)\n  {\n    extent = ((size_t) j) + MaxTextExtent;\n    utf8 = (char *) ResizeQuantumMemory(utf8, extent, sizeof(*utf8));\n    if (utf8 == ((char *) 0))\n      return utf8;\n  }\n  if (c < 0x80)\n  {\n    utf8[j] = c;\n    j++;\n    continue;\n  }\n  byte = c;\n  for (bits = 0; byte != 0; byte /= 2)\n    bits++;\n\n  bits = (bits - 2) / 5;\n  utf8[j++] = (0xFF << (7 - bits)) | (c >> (6 * bits));\n  while (bits != 0)\n  {\n    bits--;\n    utf8[j] = 0x80 | ((c >> (6 * bits)) & 0x3f);\n    j++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/9"}
{"code": "for (; (*xml) != '\\0'; xml++)\n  while ((*xml) == '\\r')\n{\n  *(xml++) = '\\n';\n  if ((*xml) == '\\n')\n    (void) CopyMagickMemory(xml, xml + 1, strlen(xml));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/10"}
{"code": "for (xml = p;;)\n{\n  while (((((*xml) != '\\0') && ((*xml) != '&')) && (((*xml) != '%') || (state != '%'))) && isspace(((int) ((unsigned char) (*xml))) == 0))\n    xml++;\n\n  if ((*xml) == '\\0')\n    break;\n  if ((state != 'c') && (strncmp(xml, \"&#\", 2) == 0))\n  {\n    if (xml[2] != 'x')\n      c = strtol(xml + 2, &entity, 10);\n    else\n      c = strtol(xml + 3, &entity, 16);\n    if ((c == 0) || ((*entity) != ';'))\n    {\n      xml++;\n      continue;\n    }\n    if (c < 0x80)\n      *(xml++) = c;\n    else\n    {\n      byte = c;\n      for (i = 0; byte != 0; byte /= 2)\n        i++;\n\n      i = (i - 2) / 5;\n      *xml = (char) ((0xFF << (7 - i)) | (c >> (6 * i)));\n      xml++;\n      while (i != 0)\n      {\n        i--;\n        *xml = (char) (0x80 | ((c >> (6 * i)) & 0x3F));\n        xml++;\n      }\n\n    }\n    (void) CopyMagickMemory(xml, strchr(xml, ';') + 1, strlen(strchr(xml, ';')));\n  }\n  else\n    if ((((*xml) == '&') && (((state == '&') || (state == ' ')) || (state == '*'))) || ((state == '%') && ((*xml) == '%')))\n  {\n    i = 0;\n    while ((entities[i] != ((char *) 0)) && (strncmp(xml + 1, entities[i], strlen(entities[i])) != 0))\n      i += 2;\n\n    if (entities[i++] == ((char *) 0))\n      xml++;\n    else\n    {\n      length = strlen(entities[i]);\n      entity = strchr(xml, ';');\n      if ((length - 1L) >= ((size_t) (entity - xml)))\n      {\n        offset = (ssize_t) (xml - p);\n        extent = (size_t) ((offset + length) + strlen(entity));\n        if (p != q)\n          p = (char *) ResizeQuantumMemory(p, extent, sizeof(*p));\n        else\n        {\n          char *xml;\n          xml = (char *) AcquireQuantumMemory(extent, sizeof(*xml));\n          if (xml != ((char *) 0))\n          {\n            (void) CopyMagickString(xml, p, extent * (sizeof(*xml)));\n            p = xml;\n          }\n        }\n        if (p == ((char *) 0))\n          ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n        xml = p + offset;\n        entity = strchr(xml, ';');\n      }\n      (void) CopyMagickMemory(xml + length, entity + 1, strlen(entity));\n      (void) strncpy(xml, entities[i], length);\n    }\n  }\n  else\n    if (((state == ' ') || (state == '*')) && isspace(((int) ((unsigned char) (*xml))) != 0))\n    *(xml++) = ' ';\n  else\n    xml++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/11"}
{"code": "for (xml = p; (*xml) != '\\0'; xml++)\n{\n  i = (ssize_t) strspn(xml, \" \");\n  if (i != 0)\n    (void) CopyMagickMemory(xml, xml + i, strlen(xml + i) + 1);\n  while (((*xml) != '\\0') && ((*xml) != ' '))\n    xml++;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/12"}
{"code": "for (;; xml++)\n{\n  while (((*xml) != '\\0') && ((*xml) != '&'))\n    xml++;\n\n  if ((*xml) == '\\0')\n    return MagickTrue;\n  if (strncmp(xml + 1, tag, strlen(tag)) == 0)\n    return MagickFalse;\n  i = 0;\n  while ((entities[i] != ((char *) 0)) && strncmp(entities[i], xml + 1, strlen(entities[i]) == 0))\n    i += 2;\n\n  if ((entities[i] != ((char *) 0)) && (ValidateEntities(tag, entities[i + 1], entities) == 0))\n    return MagickFalse;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/13"}
{"code": "for (xml[length] = '\\0'; xml != ((char *) 0);)\n{\n  while ((((*xml) != '\\0') && ((*xml) != '<')) && ((*xml) != '%'))\n    xml++;\n\n  if ((*xml) == '\\0')\n    break;\n  if (strncmp(xml, \"<!ENTITY\", 8) == 0)\n  {\n    xml += strspn(xml + 8, \"\\t\\r\\n \") + 8;\n    c = xml;\n    n = xml + strspn(xml, \"\\t\\r\\n %\");\n    xml = n + strcspn(n, \"\\t\\r\\n \");\n    *xml = ';';\n    v = (xml + strspn(xml + 1, \"\\t\\r\\n \")) + 1;\n    q = *v;\n    v++;\n    if ((q != '\"') && (q != '\\''))\n    {\n      xml = strchr(xml, '>');\n      continue;\n    }\n    entities = ((*c) == '%') ? (predefined_entitites) : (root->entities);\n    for (i = 0; entities[i] != ((char *) 0); i++)\n      ;\n\n    entities = (char **) ResizeQuantumMemory(entities, (size_t) (i + 3), sizeof(*entities));\n    if (entities == ((char **) 0))\n      ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n    if ((*c) == '%')\n      predefined_entitites = entities;\n    else\n      root->entities = entities;\n    xml++;\n    *xml = '\\0';\n    xml = strchr(v, q);\n    if (xml != ((char *) 0))\n    {\n      *xml = '\\0';\n      xml++;\n    }\n    entities[i + 1] = ParseEntities(v, predefined_entitites, '%');\n    entities[i + 2] = (char *) 0;\n    if (ValidateEntities(n, entities[i + 1], entities) != MagickFalse)\n      entities[i] = n;\n    else\n    {\n      if (entities[i + 1] != v)\n        entities[i + 1] = DestroyString(entities[i + 1]);\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"circular entity declaration &%s\", n);\n      predefined_entitites = (char **) RelinquishMagickMemory(predefined_entitites);\n      return MagickFalse;\n    }\n  }\n  else\n    if (strncmp(xml, \"<!ATTLIST\", 9) == 0)\n  {\n    t = (xml + strspn(xml + 9, \"\\t\\r\\n \")) + 9;\n    if ((*t) == '\\0')\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unclosed <!ATTLIST\");\n      predefined_entitites = (char **) RelinquishMagickMemory(predefined_entitites);\n      return MagickFalse;\n    }\n    xml = t + strcspn(t, \"\\t\\r\\n >\");\n    if ((*xml) == '>')\n      continue;\n    *xml = '\\0';\n    i = 0;\n    while ((root->attributes[i] != ((char **) 0)) && (strcmp(n, root->attributes[i][0]) != 0))\n      i++;\n\n    while (((*(n = (xml + strspn(xml + 1, \"\\t\\r\\n \")) + 1)) != '\\0') && ((*n) != '>'))\n    {\n      xml = n + strcspn(n, \"\\t\\r\\n \");\n      if ((*xml) != '\\0')\n        *xml = '\\0';\n      else\n      {\n        (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"malformed <!ATTLIST\");\n        predefined_entitites = (char **) RelinquishMagickMemory(predefined_entitites);\n        return MagickFalse;\n      }\n      xml += strspn(xml + 1, \"\\t\\r\\n \") + 1;\n      c = (char *) ((strncmp(xml, \"CDATA\", 5) != 0) ? (\"*\") : (\" \"));\n      if (strncmp(xml, \"NOTATION\", 8) == 0)\n        xml += strspn(xml + 8, \"\\t\\r\\n \") + 8;\n      xml = ((*xml) == '(') ? (strchr(xml, ')')) : (xml + strcspn(xml, \"\\t\\r\\n \"));\n      if (xml == ((char *) 0))\n      {\n        (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"malformed <!ATTLIST\");\n        predefined_entitites = (char **) RelinquishMagickMemory(predefined_entitites);\n        return MagickFalse;\n      }\n      xml += strspn(xml, \"\\t\\r\\n )\");\n      if (strncmp(xml, \"#FIXED\", 6) == 0)\n        xml += strspn(xml + 6, \"\\t\\r\\n \") + 6;\n      if ((*xml) == '#')\n      {\n        xml += strcspn(xml, \"\\t\\r\\n >\") - 1;\n        if ((*c) == ' ')\n          continue;\n        v = (char *) 0;\n      }\n      else\n        if ((((*xml) == '\"') || ((*xml) == '\\'')) && ((xml = strchr(v = xml + 1, *xml)) != ((char *) 0)))\n        *xml = '\\0';\n      else\n      {\n        (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"malformed <!ATTLIST\");\n        predefined_entitites = (char **) RelinquishMagickMemory(predefined_entitites);\n        return MagickFalse;\n      }\n      if (root->attributes[i] == ((char **) 0))\n      {\n        if (i == 0)\n          root->attributes = (char ***) AcquireQuantumMemory(2, sizeof(*root->attributes));\n        else\n          root->attributes = (char ***) ResizeQuantumMemory(root->attributes, (size_t) (i + 2), sizeof(*root->attributes));\n        if (root->attributes == ((char ***) 0))\n          ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n        root->attributes[i] = (char **) AcquireQuantumMemory(2, sizeof(*root->attributes));\n        if (root->attributes[i] == ((char **) 0))\n          ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n        root->attributes[i][0] = ConstantString(t);\n        root->attributes[i][1] = (char *) 0;\n        root->attributes[i + 1] = (char **) 0;\n      }\n      for (j = 1; root->attributes[i][j] != ((char *) 0); j += 3)\n        ;\n\n      root->attributes[i] = (char **) ResizeQuantumMemory(root->attributes[i], (size_t) (j + 4), sizeof(*root->attributes));\n      if (root->attributes[i] == ((char **) 0))\n        ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n      root->attributes[i][j + 3] = (char *) 0;\n      root->attributes[i][j + 2] = ConstantString(c);\n      root->attributes[i][j + 1] = (char *) 0;\n      if (v != ((char *) 0))\n        root->attributes[i][j + 1] = ParseEntities(v, root->entities, *c);\n      root->attributes[i][j] = ConstantString(n);\n    }\n\n  }\n  else\n    if (strncmp(xml, \"<!--\", 4) == 0)\n    xml = strstr(xml + 4, \"-->\");\n  else\n    if (strncmp(xml, \"<?\", 2) == 0)\n  {\n    c = xml + 2;\n    xml = strstr(c, \"?>\");\n    if (xml != ((char *) 0))\n    {\n      ParseProcessingInstructions(root, c, (size_t) (xml - c));\n      xml++;\n    }\n  }\n  else\n    if ((*xml) == '<')\n    xml = strchr(xml, '>');\n  else\n    if (((*(xml++)) == '%') && (root->standalone == MagickFalse))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/14"}
{"code": "for (p++;; p++)\n{\n  attributes = (char **) sentinel;\n  tag = p;\n  if ((((isalpha((int) ((unsigned char) (*p))) != 0) || ((*p) == '_')) || ((*p) == ':')) || (((int) (*p)) < '\\0'))\n  {\n    if (root->node == ((XMLTreeInfo *) 0))\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"root tag missing\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n    p += strcspn(p, \"\\t\\r\\n />\");\n    while (isspace((int) ((unsigned char) (*p))) != 0)\n      *(p++) = '\\0';\n\n    if ((((*p) != '\\0') && ((*p) != '/')) && ((*p) != '>'))\n    {\n      i = 0;\n      while ((root->attributes[i] != ((char **) 0)) && (strcmp(root->attributes[i][0], tag) != 0))\n        i++;\n\n      attribute = root->attributes[i];\n    }\n    for (l = 0; (((*p) != '\\0') && ((*p) != '/')) && ((*p) != '>'); l += 2)\n    {\n      if (l == 0)\n        attributes = (char **) AcquireQuantumMemory(4, sizeof(*attributes));\n      else\n        attributes = (char **) ResizeQuantumMemory(attributes, (size_t) (l + 4), sizeof(*attributes));\n      if (attributes == ((char **) 0))\n      {\n        (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", \"\");\n        utf8 = DestroyString(utf8);\n        return &root->root;\n      }\n      attributes[l + 2] = (char *) 0;\n      attributes[l + 1] = (char *) 0;\n      attributes[l] = p;\n      p += strcspn(p, \"\\t\\r\\n =/>\");\n      if (((*p) != '=') && (isspace((int) ((unsigned char) (*p))) == 0))\n        attributes[l] = ConstantString(\"\");\n      else\n      {\n        *(p++) = '\\0';\n        p += strspn(p, \"\\t\\r\\n =\");\n        c = *p;\n        if ((c == '\"') || (c == '\\''))\n        {\n          p++;\n          attributes[l + 1] = p;\n          while (((*p) != '\\0') && ((*p) != c))\n            p++;\n\n          if ((*p) != '\\0')\n            *(p++) = '\\0';\n          else\n          {\n            attributes[l] = ConstantString(\"\");\n            attributes[l + 1] = ConstantString(\"\");\n            (void) DestroyXMLTreeAttributes(attributes);\n            (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"missing %c\", c);\n            utf8 = DestroyString(utf8);\n            return &root->root;\n          }\n          j = 1;\n          while (((attribute != ((char **) 0)) && (attribute[j] != ((char *) 0))) && (strcmp(attribute[j], attributes[l]) != 0))\n            j += 3;\n\n          attributes[l + 1] = ParseEntities(attributes[l + 1], root->entities, ((attribute != ((char **) 0)) && (attribute[j] != ((char *) 0))) ? (*attribute[j + 2]) : (' '));\n        }\n        attributes[l] = ConstantString(attributes[l]);\n      }\n      while (isspace((int) ((unsigned char) (*p))) != 0)\n        p++;\n\n    }\n\n    if ((*p) == '/')\n    {\n      *(p++) = '\\0';\n      if ((((*p) != '\\0') && ((*p) != '>')) || (((*p) == '\\0') && (terminal != '>')))\n      {\n        if (l != 0)\n          (void) DestroyXMLTreeAttributes(attributes);\n        (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"missing >\");\n        utf8 = DestroyString(utf8);\n        return &root->root;\n      }\n      ParseOpenTag(root, tag, attributes);\n      (void) ParseCloseTag(root, tag, p, exception);\n    }\n    else\n    {\n      c = *p;\n      if (((*p) == '>') || (((*p) == '\\0') && (terminal == '>')))\n      {\n        *p = '\\0';\n        ParseOpenTag(root, tag, attributes);\n        *p = c;\n      }\n      else\n      {\n        if (l != 0)\n          (void) DestroyXMLTreeAttributes(attributes);\n        (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"missing >\");\n        utf8 = DestroyString(utf8);\n        return &root->root;\n      }\n    }\n  }\n  else\n    if ((*p) == '/')\n  {\n    tag = p + 1;\n    p += strcspn(tag, \"\\t\\r\\n >\") + 1;\n    c = *p;\n    if ((c == '\\0') && (terminal != '>'))\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"missing >\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n    *p = '\\0';\n    if (ParseCloseTag(root, tag, p, exception) != ((XMLTreeInfo *) 0))\n    {\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n    *p = c;\n    if (isspace((int) ((unsigned char) (*p))) != 0)\n      p += strspn(p, \"\\t\\r\\n \");\n  }\n  else\n    if (strncmp(p, \"!--\", 3) == 0)\n  {\n    p = strstr(p + 3, \"--\");\n    if (((p == ((char *) 0)) || (((*(p += 2)) != '>') && ((*p) != '\\0'))) || (((*p) == '\\0') && (terminal != '>')))\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unclosed <!--\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n  }\n  else\n    if (strncmp(p, \"![CDATA[\", 8) == 0)\n  {\n    p = strstr(p, \"]]>\");\n    if (p != ((char *) 0))\n    {\n      p += 2;\n      ParseCharacterContent(root, tag + 8, (size_t) ((p - tag) - 10), 'c');\n    }\n    else\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unclosed <![CDATA[\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n  }\n  else\n    if (strncmp(p, \"!DOCTYPE\", 8) == 0)\n  {\n    for (l = 0; ((*p) != '\\0') && (((l == 0) && ((*p) != '>')) || ((l != 0) && (((*p) != ']') || ((*((p + strspn(p + 1, \"\\t\\r\\n \")) + 1)) != '>')))); l = (ssize_t) (((*p) == '[') ? (1) : (l)))\n      p += strcspn(p + 1, \"[]>\") + 1;\n\n    if (((*p) == '\\0') && (terminal != '>'))\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unclosed <!DOCTYPE\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n    if (l != 0)\n      tag = strchr(tag, '[') + 1;\n    if (l != 0)\n    {\n      status = ParseInternalDoctype(root, tag, (size_t) (p - tag), exception);\n      if (status == MagickFalse)\n      {\n        utf8 = DestroyString(utf8);\n        return &root->root;\n      }\n      p++;\n    }\n  }\n  else\n    if ((*p) == '?')\n  {\n    do\n    {\n      p = strchr(p, '?');\n      if (p == ((char *) 0))\n        break;\n      p++;\n    }\n    while (((*p) != '\\0') && ((*p) != '>'));\n    if ((p == ((char *) 0)) || (((*p) == '\\0') && (terminal != '>')))\n    {\n      (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unclosed <?\");\n      utf8 = DestroyString(utf8);\n      return &root->root;\n    }\n    ParseProcessingInstructions(root, tag + 1, (size_t) ((p - tag) - 2));\n  }\n  else\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionWarning, \"ParseError\", \"unexpected <\");\n    utf8 = DestroyString(utf8);\n    return &root->root;\n  }\n  if ((p == ((char *) 0)) || ((*p) == '\\0'))\n    break;\n  *(p++) = '\\0';\n  tag = p;\n  if (((*p) != '\\0') && ((*p) != '<'))\n  {\n    while (((*p) != '\\0') && ((*p) != '<'))\n      p++;\n\n    if ((*p) == '\\0')\n      break;\n    ParseCharacterContent(root, tag, (size_t) (p - tag), '&');\n  }\n  else\n    if ((*p) == '\\0')\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/15"}
{"code": "for (j = i; xml_info->attributes[j] != ((char *) 0); j += 2)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/16"}
{"code": "for (i = 0; xml_info->attributes[i]; i += 2)\n{\n  attribute = GetXMLTreeAttribute(xml_info, xml_info->attributes[i]);\n  if (attribute != xml_info->attributes[i + 1])\n    continue;\n  if ((((*length) + strlen(xml_info->attributes[i])) + MaxTextExtent) > (*extent))\n  {\n    *extent = ((*length) + strlen(xml_info->attributes[i])) + MaxTextExtent;\n    *source = (char *) ResizeQuantumMemory(*source, *extent, sizeof(*(*source)));\n    if ((*source) == ((char *) 0))\n      return (char *) 0;\n  }\n  *length += FormatLocaleString((*source) + (*length), *extent, \" %s=\\\"\", xml_info->attributes[i]);\n  (void) EncodePredefinedEntities(xml_info->attributes[i + 1], -1, source, length, extent, MagickTrue);\n  *length += FormatLocaleString((*source) + (*length), *extent, \"\\\"\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/17"}
{"code": "for (i = 0; root->processing_instructions[i] != ((char **) 0); i++)\n{\n  for (k = 2; root->processing_instructions[i][k - 1]; k++)\n    ;\n\n  p = root->processing_instructions[i][1];\n  for (j = 1; p != ((char *) 0); j++)\n  {\n    if (root->processing_instructions[i][k][j - 1] == '>')\n    {\n      p = root->processing_instructions[i][j];\n      continue;\n    }\n    q = root->processing_instructions[i][0];\n    if ((((length + strlen(p)) + strlen(q)) + MaxTextExtent) > extent)\n    {\n      extent = ((length + strlen(p)) + strlen(q)) + MaxTextExtent;\n      xml = (char *) ResizeQuantumMemory(xml, extent, sizeof(*xml));\n      if (xml == ((char *) 0))\n        return xml;\n    }\n    length += FormatLocaleString(xml + length, extent, \"<?%s%s%s?>\\n\", q, ((*p) != '\\0') ? (\" \") : (\"\"), p);\n    p = root->processing_instructions[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/18"}
{"code": "for (i = 0; root->processing_instructions[i] != ((char **) 0); i++)\n{\n  for (k = 2; root->processing_instructions[i][k - 1]; k++)\n    ;\n\n  p = root->processing_instructions[i][1];\n  for (j = 1; p != ((char *) 0); j++)\n  {\n    if (root->processing_instructions[i][k][j - 1] == '<')\n    {\n      p = root->processing_instructions[i][j];\n      continue;\n    }\n    q = root->processing_instructions[i][0];\n    if ((((length + strlen(p)) + strlen(q)) + MaxTextExtent) > extent)\n    {\n      extent = ((length + strlen(p)) + strlen(q)) + MaxTextExtent;\n      xml = (char *) ResizeQuantumMemory(xml, extent, sizeof(*xml));\n      if (xml == ((char *) 0))\n        return xml;\n    }\n    length += FormatLocaleString(xml + length, extent, \"\\n<?%s%s%s?>\", q, ((*p) != '\\0') ? (\" \") : (\"\"), p);\n    p = root->processing_instructions[i][j];\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_xml-tree/19"}
{"code": "for (i = 0; i < length; i += count)\n{\n  count = read(file, string + i, (size_t) MagickMin(length - i, (size_t) SSIZE_MAX));\n  if (count <= 0)\n  {\n    count = 0;\n    if (errno != EINTR)\n      break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/0"}
{"code": "for (n = length; n > 4; n -= 4)\n{\n  *q = *(p++);\n  if ((*q) == '\\0')\n    return (size_t) ((p - source) - 1);\n  q++;\n  *q = *(p++);\n  if ((*q) == '\\0')\n    return (size_t) ((p - source) - 1);\n  q++;\n  *q = *(p++);\n  if ((*q) == '\\0')\n    return (size_t) ((p - source) - 1);\n  q++;\n  *q = *(p++);\n  if ((*q) == '\\0')\n    return (size_t) ((p - source) - 1);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/1"}
{"code": "for (n--; n != 0; n--)\n{\n  *q = *(p++);\n  if ((*q) == '\\0')\n    return (size_t) ((p - source) - 1);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/2"}
{"code": "for (i = 0; list[i] != ((char *) 0); i++)\n  list[i] = DestroyString(list[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/3"}
{"code": "for (p = source; (*p) != '\\0'; p++)\n  if (((*p) == '\\\\') || ((*p) == escape))\n{\n  if ((~length) < 1)\n    ThrowFatalException(ResourceLimitFatalError, \"UnableToEscapeString\");\n  length++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/4"}
{"code": "for (p = source; (*p) != '\\0'; p++)\n{\n  if (((*p) == '\\\\') || ((*p) == escape))\n    *(q++) = '\\\\';\n  *(q++) = *p;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/5"}
{"code": "for (i = 0; (length >= bytes) && (units[i + 1] != ((const char *) 0)); i++)\n  length /= bytes;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/6"}
{"code": "for (j = 2; j < 12; j++)\n{\n  count = FormatLocaleString(format, MaxTextExtent, \"%.*g%sB\", (int) (i + j), length, units[i]);\n  if (strchr(format, '+') == ((char *) 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/7"}
{"code": "for (;;)\n{\n  c = (int) (*((unsigned char *) p));\n  d = (int) (*((unsigned char *) q));\n  if ((c == 0) || (AsciiMap[c] != AsciiMap[d]))\n    break;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/8"}
{"code": "for (q = string; (*q) != '\\0'; q++)\n  *q = (char) tolower((int) (*q));\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/9"}
{"code": "for (i = length; i != 0; i--)\n{\n  c = (int) (*((unsigned char *) p));\n  d = (int) (*((unsigned char *) q));\n  if (AsciiMap[c] != AsciiMap[d])\n    return AsciiMap[c] - ((int) AsciiMap[d]);\n  if (c == 0)\n    return 0;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/10"}
{"code": "for (q = string; (*q) != '\\0'; q++)\n  *q = (char) toupper((int) (*q));\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/11"}
{"code": "for (i = 0; i < string_info->length; i++)\n{\n  if ((((int) ((unsigned char) (*p))) < 32) && (isspace((int) ((unsigned char) (*p))) == 0))\n    break;\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/12"}
{"code": "for (i = 0; i < string_info->length; i += 0x14)\n{\n  (void) FormatLocaleFile(file, \"0x%08lx: \", (unsigned long) (0x14 * i));\n  for (j = 1; j <= MagickMin(string_info->length - i, 0x14); j++)\n  {\n    (void) FormatLocaleFile(file, \"%02lx\", ((unsigned long) (*(p + j))) & 0xff);\n    if ((j % 0x04) == 0)\n      (void) fputc(' ', file);\n  }\n\n  for (; j <= 0x14; j++)\n  {\n    (void) fputc(' ', file);\n    (void) fputc(' ', file);\n    if ((j % 0x04) == 0)\n      (void) fputc(' ', file);\n  }\n\n  (void) fputc(' ', file);\n  for (j = 1; j <= MagickMin(string_info->length - i, 0x14); j++)\n  {\n    if (isprint((int) ((unsigned char) (*p))) != 0)\n      (void) fputc(*p, file);\n    else\n      (void) fputc('-', file);\n    p++;\n  }\n\n  (void) fputc('\\n', file);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/13"}
{"code": "for (p = text; (*p) != '\\0';)\n{\n  while (isspace((int) ((unsigned char) (*p))) != 0)\n    p++;\n\n  if ((*p) == '\\0')\n    break;\n  (*argc)++;\n  if ((*p) == '\"')\n    for (p++; ((*p) != '\"') && ((*p) != '\\0'); p++)\n    ;\n\n  if ((*p) == '\\'')\n    for (p++; ((*p) != '\\'') && ((*p) != '\\0'); p++)\n    ;\n\n  while ((isspace((int) ((unsigned char) (*p))) == 0) && ((*p) != '\\0'))\n    p++;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/14"}
{"code": "for (i = 1; i < ((ssize_t) (*argc)); i++)\n{\n  while (isspace((int) ((unsigned char) (*p))) != 0)\n    p++;\n\n  q = p;\n  if ((*q) == '\"')\n  {\n    p++;\n    for (q++; ((*q) != '\"') && ((*q) != '\\0'); q++)\n      ;\n\n  }\n  else\n    if ((*q) == '\\'')\n  {\n    p++;\n    for (q++; ((*q) != '\\'') && ((*q) != '\\0'); q++)\n      ;\n\n  }\n  else\n    while ((isspace((int) ((unsigned char) (*q))) == 0) && ((*q) != '\\0'))\n    q++;\n\n  argv[i] = (char *) AcquireQuantumMemory(((size_t) (q - p)) + MaxTextExtent, sizeof(*(*argv)));\n  if (argv[i] == ((char *) 0))\n  {\n    for (i--; i >= 0; i--)\n      argv[i] = DestroyString(argv[i]);\n\n    argv = (char **) RelinquishMagickMemory(argv);\n    ThrowFatalException(ResourceLimitFatalError, \"UnableToConvertStringToARGV\");\n  }\n  (void) memcpy(argv[i], p, (size_t) (q - p));\n  argv[i][q - p] = '\\0';\n  p = q;\n  while ((isspace((int) ((unsigned char) (*p))) == 0) && ((*p) != '\\0'))\n    p++;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/15"}
{"code": "for (i = 0; i < ((ssize_t) string_info->length); i++)\n{\n  *(q++) = hex_digits[((*p) >> 4) & 0x0f];\n  *(q++) = hex_digits[(*p) & 0x0f];\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/16"}
{"code": "for (q = p;;)\n{\n  c = *(p++);\n  r = delimiters;\n  do\n  {\n    d = *(r++);\n    if (c == d)\n    {\n      if (c == '\\0')\n        p = (char *) 0;\n      else\n        p[-1] = '\\0';\n      *string = p;\n      return q;\n    }\n  }\n  while (d != '\\0');\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/17"}
{"code": "for (p = text; (*p) != '\\0'; p++)\n  if ((((int) ((unsigned char) (*p))) < 32) && (isspace((int) ((unsigned char) (*p))) == 0))\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/18"}
{"code": "for (p = text; (*p) != '\\0'; p++)\n  if ((*p) == '\\n')\n  lines++;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/19"}
{"code": "for (i = 0; i < ((ssize_t) lines); i++)\n{\n  for (q = p; (*q) != '\\0'; q++)\n    if (((*q) == '\\r') || ((*q) == '\\n'))\n    break;\n\n  textlist[i] = (char *) AcquireQuantumMemory(((size_t) (q - p)) + MaxTextExtent, sizeof(*(*textlist)));\n  if (textlist[i] == ((char *) 0))\n    ThrowFatalException(ResourceLimitFatalError, \"UnableToConvertText\");\n  (void) memcpy(textlist[i], p, (size_t) (q - p));\n  textlist[i][q - p] = '\\0';\n  if ((*q) == '\\r')\n    q++;\n  p = q + 1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/20"}
{"code": "for (i = 0; i < ((ssize_t) lines); i++)\n{\n  textlist[i] = (char *) AcquireQuantumMemory(2UL * MaxTextExtent, sizeof(*(*textlist)));\n  if (textlist[i] == ((char *) 0))\n    ThrowFatalException(ResourceLimitFatalError, \"UnableToConvertText\");\n  (void) FormatLocaleString(textlist[i], MaxTextExtent, \"0x%08lx: \", (long) (0x14 * i));\n  q = textlist[i] + strlen(textlist[i]);\n  for (j = 1; j <= ((ssize_t) MagickMin(strlen(p), 0x14)); j++)\n  {\n    (void) FormatLocaleString(hex_string, MaxTextExtent, \"%02x\", *(p + j));\n    (void) CopyMagickString(q, hex_string, MaxTextExtent);\n    q += 2;\n    if ((j % 0x04) == 0)\n      *(q++) = ' ';\n  }\n\n  for (; j <= 0x14; j++)\n  {\n    *(q++) = ' ';\n    *(q++) = ' ';\n    if ((j % 0x04) == 0)\n      *(q++) = ' ';\n  }\n\n  *(q++) = ' ';\n  for (j = 1; j <= ((ssize_t) MagickMin(strlen(p), 0x14)); j++)\n  {\n    if (isprint((int) ((unsigned char) (*p))) != 0)\n      *(q++) = *p;\n    else\n      *(q++) = '-';\n    p++;\n  }\n\n  *q = '\\0';\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/21"}
{"code": "for (p = message; (*p) != '\\0'; p++)\n  if ((*p) == '\\n')\n  *p = ' ';\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/22"}
{"code": "for (p = strchr(*string, *search); p != ((char *) 0); p = strchr(p + 1, *search))\n{\n  if (search_extent == 0)\n    search_extent = strlen(search);\n  if (strncmp(p, search, search_extent) != 0)\n    continue;\n  status = MagickTrue;\n  if (replace_extent == 0)\n    replace_extent = strlen(replace);\n  if (replace_extent > search_extent)\n  {\n    offset = (ssize_t) (p - (*string));\n    extent = ((strlen(*string) + replace_extent) - search_extent) + 1;\n    *string = (char *) ResizeQuantumMemory(*string, extent + MaxTextExtent, sizeof(*p));\n    if ((*string) == ((char *) 0))\n      ThrowFatalException(ResourceLimitFatalError, \"UnableToAcquireString\");\n    p = (*string) + offset;\n  }\n  if (search_extent != replace_extent)\n    (void) CopyMagickMemory(p + replace_extent, p + search_extent, strlen(p + search_extent) + 1);\n  (void) CopyMagickMemory(p, replace, replace_extent);\n  p += replace_extent - 1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_string/23"}
{"code": "for (y = 0; y < ((ssize_t) extent.y); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict chop_indexes;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(chop_view, 0, y, chop_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  chop_indexes = GetCacheViewAuthenticIndexQueue(chop_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((x < extent.x) || (x >= ((ssize_t) (extent.x + extent.width))))\n    {\n      *q = *p;\n      if (indexes != ((IndexPacket *) 0))\n      {\n        if (chop_indexes != ((IndexPacket *) 0))\n          *(chop_indexes++) = GetPixelIndex(indexes + x);\n      }\n      q++;\n    }\n    p++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(chop_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ChopImage)\n    proceed = SetImageProgress(image, \"Chop/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/0"}
{"code": "for (y = 0; y < ((ssize_t) (image->rows - (extent.y + extent.height))); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict chop_indexes;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, (extent.y + extent.height) + y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(chop_view, 0, extent.y + y, chop_image->columns, 1, exception);\n  if ((p == ((PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  chop_indexes = GetCacheViewAuthenticIndexQueue(chop_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((x < extent.x) || (x >= ((ssize_t) (extent.x + extent.width))))\n    {\n      *q = *p;\n      if (indexes != ((IndexPacket *) 0))\n      {\n        if (chop_indexes != ((IndexPacket *) 0))\n          *(chop_indexes++) = GetPixelIndex(indexes + x);\n      }\n      q++;\n    }\n    p++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(chop_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ChopImage)\n    proceed = SetImageProgress(image, \"Chop/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/1"}
{"code": "for (y = 0; y < ((ssize_t) crop_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict crop_indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, page.x, page.y + y, crop_image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(crop_view, 0, y, crop_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  crop_indexes = GetCacheViewAuthenticIndexQueue(crop_view);\n  (void) CopyMagickMemory(q, p, ((size_t) crop_image->columns) * (sizeof(*p)));\n  if ((indexes != ((IndexPacket *) 0)) && (crop_indexes != ((IndexPacket *) 0)))\n    (void) CopyMagickMemory(crop_indexes, indexes, ((size_t) crop_image->columns) * (sizeof(*crop_indexes)));\n  if (SyncCacheViewAuthenticPixels(crop_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_CropImage)\n    proceed = SetImageProgress(image, \"Crop/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/2"}
{"code": "for (y = 0; y < ((ssize_t) excerpt_image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict excerpt_indexes;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, geometry->x, geometry->y + y, geometry->width, 1, exception);\n  q = GetCacheViewAuthenticPixels(excerpt_view, 0, y, excerpt_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  (void) CopyMagickMemory(q, p, ((size_t) excerpt_image->columns) * (sizeof(*q)));\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  if (indexes != ((IndexPacket *) 0))\n  {\n    excerpt_indexes = GetCacheViewAuthenticIndexQueue(excerpt_view);\n    if (excerpt_indexes != ((IndexPacket *) 0))\n      (void) CopyMagickMemory(excerpt_indexes, indexes, ((size_t) excerpt_image->columns) * (sizeof(*excerpt_indexes)));\n  }\n  if (SyncCacheViewAuthenticPixels(excerpt_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ExcerptImage)\n    proceed = SetImageProgress(image, \"Excerpt/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/3"}
{"code": "for (y = 0; y < ((ssize_t) flip_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict flip_indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(flip_view, 0, (ssize_t) ((flip_image->rows - y) - 1), flip_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  (void) CopyMagickMemory(q, p, ((size_t) image->columns) * (sizeof(*q)));\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  if (indexes != ((const IndexPacket *) 0))\n  {\n    flip_indexes = GetCacheViewAuthenticIndexQueue(flip_view);\n    if (flip_indexes != ((IndexPacket *) 0))\n      (void) CopyMagickMemory(flip_indexes, indexes, ((size_t) image->columns) * (sizeof(*flip_indexes)));\n  }\n  if (SyncCacheViewAuthenticPixels(flip_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_FlipImage)\n    proceed = SetImageProgress(image, \"Flip/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/4"}
{"code": "for (y = 0; y < ((ssize_t) flop_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict flop_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(flop_view, 0, y, flop_image->columns, 1, exception);\n  if ((p == ((PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  q += flop_image->columns;\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  flop_indexes = GetCacheViewAuthenticIndexQueue(flop_view);\n  for (x = 0; x < ((ssize_t) flop_image->columns); x++)\n  {\n    *(--q) = *(p++);\n    if ((indexes != ((const IndexPacket *) 0)) && (flop_indexes != ((IndexPacket *) 0)))\n      SetPixelIndex(((flop_indexes + flop_image->columns) - x) - 1, GetPixelIndex(indexes + x));\n  }\n\n  if (SyncCacheViewAuthenticPixels(flop_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_FlopImage)\n    proceed = SetImageProgress(image, \"Flop/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/5"}
{"code": "for (y = 0; y < ((ssize_t) rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict destination_indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(source_view, sx, sy + y, columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(destination_view, dx, dy + y, columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(source_view);\n  (void) CopyMagickMemory(q, p, ((size_t) columns) * (sizeof(*p)));\n  if (indexes != ((IndexPacket *) 0))\n  {\n    destination_indexes = GetCacheViewAuthenticIndexQueue(destination_view);\n    if (destination_indexes != ((IndexPacket *) 0))\n      (void) CopyMagickMemory(destination_indexes, indexes, ((size_t) columns) * (sizeof(*indexes)));\n  }\n  sync = SyncCacheViewAuthenticPixels(destination_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/6"}
{"code": "for (y = 0; y < ((ssize_t) splice_geometry.y); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict indexes;\n  IndexPacket * restrict splice_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(splice_view, 0, y, splice_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  splice_indexes = GetCacheViewAuthenticIndexQueue(splice_view);\n  for (x = 0; x < splice_geometry.x; x++)\n  {\n    SetPixelRed(q, GetPixelRed(p));\n    SetPixelGreen(q, GetPixelGreen(p));\n    SetPixelBlue(q, GetPixelBlue(p));\n    SetPixelOpacity(q, OpaqueOpacity);\n    if (image->matte != MagickFalse)\n      SetPixelOpacity(q, GetPixelOpacity(p));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(splice_indexes + x, GetPixelIndex(indexes));\n    indexes++;\n    p++;\n    q++;\n  }\n\n  for (; x < ((ssize_t) (splice_geometry.x + splice_geometry.width)); x++)\n    q++;\n\n  for (; x < ((ssize_t) splice_image->columns); x++)\n  {\n    SetPixelRed(q, GetPixelRed(p));\n    SetPixelGreen(q, GetPixelGreen(p));\n    SetPixelBlue(q, GetPixelBlue(p));\n    SetPixelOpacity(q, OpaqueOpacity);\n    if (image->matte != MagickFalse)\n      SetPixelOpacity(q, GetPixelOpacity(p));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(splice_indexes + x, GetPixelIndex(indexes));\n    indexes++;\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(splice_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TransposeImage)\n    proceed = SetImageProgress(image, \"Splice/Image\", progress++, splice_image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/7"}
{"code": "for (y = (ssize_t) (splice_geometry.y + splice_geometry.height); y < ((ssize_t) splice_image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict indexes;\n  IndexPacket * restrict splice_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y - ((ssize_t) splice_geometry.height), image->columns, 1, exception);\n  if ((y < 0) || (y >= ((ssize_t) splice_image->rows)))\n    continue;\n  q = QueueCacheViewAuthenticPixels(splice_view, 0, y, splice_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  splice_indexes = GetCacheViewAuthenticIndexQueue(splice_view);\n  for (x = 0; x < splice_geometry.x; x++)\n  {\n    SetPixelRed(q, GetPixelRed(p));\n    SetPixelGreen(q, GetPixelGreen(p));\n    SetPixelBlue(q, GetPixelBlue(p));\n    SetPixelOpacity(q, OpaqueOpacity);\n    if (image->matte != MagickFalse)\n      SetPixelOpacity(q, GetPixelOpacity(p));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(splice_indexes + x, GetPixelIndex(indexes));\n    indexes++;\n    p++;\n    q++;\n  }\n\n  for (; x < ((ssize_t) (splice_geometry.x + splice_geometry.width)); x++)\n    q++;\n\n  for (; x < ((ssize_t) splice_image->columns); x++)\n  {\n    SetPixelRed(q, GetPixelRed(p));\n    SetPixelGreen(q, GetPixelGreen(p));\n    SetPixelBlue(q, GetPixelBlue(p));\n    SetPixelOpacity(q, OpaqueOpacity);\n    if (image->matte != MagickFalse)\n      SetPixelOpacity(q, GetPixelOpacity(p));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(splice_indexes + x, GetPixelIndex(indexes));\n    indexes++;\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(splice_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TransposeImage)\n    proceed = SetImageProgress(image, \"Splice/Image\", progress++, splice_image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/8"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict transpose_indexes;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, (((ssize_t) image->rows) - y) - 1, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(transpose_view, (ssize_t) ((image->rows - y) - 1), 0, 1, transpose_image->rows, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  (void) CopyMagickMemory(q, p, ((size_t) image->columns) * (sizeof(*q)));\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  if (indexes != ((IndexPacket *) 0))\n  {\n    transpose_indexes = GetCacheViewAuthenticIndexQueue(transpose_view);\n    if (transpose_indexes != ((IndexPacket *) 0))\n      (void) CopyMagickMemory(transpose_indexes, indexes, ((size_t) image->columns) * (sizeof(*transpose_indexes)));\n  }\n  if (SyncCacheViewAuthenticPixels(transpose_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TransposeImage)\n    proceed = SetImageProgress(image, \"Transpose/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/9"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict transverse_indexes;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(transverse_view, (ssize_t) ((image->rows - y) - 1), 0, 1, transverse_image->rows, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  q += image->columns;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n    *(--q) = *(p++);\n\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  if (indexes != ((IndexPacket *) 0))\n  {\n    transverse_indexes = GetCacheViewAuthenticIndexQueue(transverse_view);\n    if (transverse_indexes != ((IndexPacket *) 0))\n      for (x = 0; x < ((ssize_t) image->columns); x++)\n      SetPixelIndex(((transverse_indexes + image->columns) - x) - 1, GetPixelIndex(indexes + x));\n\n  }\n  sync = SyncCacheViewAuthenticPixels(transverse_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TransverseImage)\n    proceed = SetImageProgress(image, \"Transverse/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/10"}
{"code": "for (i = 0; i < ((ssize_t) GetImageListLength(images)); i += 4)\n{\n  cmyk_image = CloneImage(images, images->columns, images->rows, MagickTrue, exception);\n  if (cmyk_image == ((Image *) 0))\n    break;\n  if (SetImageStorageClass(cmyk_image, DirectClass) == MagickFalse)\n    break;\n  (void) SetImageColorspace(cmyk_image, CMYKColorspace);\n  image_view = AcquireCacheView(images);\n  cmyk_view = AcquireCacheView(cmyk_image);\n  for (y = 0; y < ((ssize_t) images->rows); y++)\n  {\n    const PixelPacket * restrict p;\n    ssize_t x;\n    PixelPacket * restrict q;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, images->columns, 1, exception);\n    q = QueueCacheViewAuthenticPixels(cmyk_view, 0, y, cmyk_image->columns, 1, exception);\n    if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n      break;\n    for (x = 0; x < ((ssize_t) images->columns); x++)\n    {\n      SetPixelRed(q, QuantumRange - PixelIntensityToQuantum(p));\n      p++;\n      q++;\n    }\n\n    if (SyncCacheViewAuthenticPixels(cmyk_view, exception) == MagickFalse)\n      break;\n  }\n\n  cmyk_view = DestroyCacheView(cmyk_view);\n  image_view = DestroyCacheView(image_view);\n  images = GetNextImageInList(images);\n  if (images == ((Image *) 0))\n    break;\n  image_view = AcquireCacheView(images);\n  cmyk_view = AcquireCacheView(cmyk_image);\n  for (y = 0; y < ((ssize_t) images->rows); y++)\n  {\n    const PixelPacket * restrict p;\n    ssize_t x;\n    PixelPacket * restrict q;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, images->columns, 1, exception);\n    q = GetCacheViewAuthenticPixels(cmyk_view, 0, y, cmyk_image->columns, 1, exception);\n    if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n      break;\n    for (x = 0; x < ((ssize_t) images->columns); x++)\n    {\n      q->green = (Quantum) (QuantumRange - PixelIntensityToQuantum(p));\n      p++;\n      q++;\n    }\n\n    if (SyncCacheViewAuthenticPixels(cmyk_view, exception) == MagickFalse)\n      break;\n  }\n\n  cmyk_view = DestroyCacheView(cmyk_view);\n  image_view = DestroyCacheView(image_view);\n  images = GetNextImageInList(images);\n  if (images == ((Image *) 0))\n    break;\n  image_view = AcquireCacheView(images);\n  cmyk_view = AcquireCacheView(cmyk_image);\n  for (y = 0; y < ((ssize_t) images->rows); y++)\n  {\n    const PixelPacket * restrict p;\n    ssize_t x;\n    PixelPacket * restrict q;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, images->columns, 1, exception);\n    q = GetCacheViewAuthenticPixels(cmyk_view, 0, y, cmyk_image->columns, 1, exception);\n    if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n      break;\n    for (x = 0; x < ((ssize_t) images->columns); x++)\n    {\n      q->blue = (Quantum) (QuantumRange - PixelIntensityToQuantum(p));\n      p++;\n      q++;\n    }\n\n    if (SyncCacheViewAuthenticPixels(cmyk_view, exception) == MagickFalse)\n      break;\n  }\n\n  cmyk_view = DestroyCacheView(cmyk_view);\n  image_view = DestroyCacheView(image_view);\n  images = GetNextImageInList(images);\n  if (images == ((Image *) 0))\n    break;\n  image_view = AcquireCacheView(images);\n  cmyk_view = AcquireCacheView(cmyk_image);\n  for (y = 0; y < ((ssize_t) images->rows); y++)\n  {\n    const PixelPacket * restrict p;\n    IndexPacket * restrict indexes;\n    ssize_t x;\n    PixelPacket * restrict q;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, images->columns, 1, exception);\n    q = GetCacheViewAuthenticPixels(cmyk_view, 0, y, cmyk_image->columns, 1, exception);\n    if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n      break;\n    indexes = GetCacheViewAuthenticIndexQueue(cmyk_view);\n    for (x = 0; x < ((ssize_t) images->columns); x++)\n    {\n      SetPixelIndex(indexes + x, QuantumRange - PixelIntensityToQuantum(p));\n      p++;\n    }\n\n    if (SyncCacheViewAuthenticPixels(cmyk_view, exception) == MagickFalse)\n      break;\n  }\n\n  cmyk_view = DestroyCacheView(cmyk_view);\n  image_view = DestroyCacheView(image_view);\n  AppendImageToList(&cmyk_images, cmyk_image);\n  images = GetNextImageInList(images);\n  if (images == ((Image *) 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/11"}
{"code": "for (offset.y = 0; offset.y < ((double) height);)\n{\n  if ((flags & AspectValue) == 0)\n  {\n    crop.y = (ssize_t) MagickRound((MagickRealType) (offset.y - ((geometry.y > 0) ? (0) : (geometry.y))));\n    offset.y += delta.y;\n    crop.height = (size_t) MagickRound((MagickRealType) (offset.y + ((geometry.y < 0) ? (0) : (geometry.y))));\n  }\n  else\n  {\n    crop.y = (ssize_t) MagickRound((MagickRealType) (offset.y - ((geometry.y > 0) ? (geometry.y) : (0))));\n    offset.y += delta.y;\n    crop.height = (size_t) MagickRound((MagickRealType) (offset.y + ((geometry.y < 0) ? (geometry.y) : (0))));\n  }\n  crop.height -= crop.y;\n  crop.y += image->page.y;\n  for (offset.x = 0; offset.x < ((double) width);)\n  {\n    if ((flags & AspectValue) == 0)\n    {\n      crop.x = (ssize_t) MagickRound((MagickRealType) (offset.x - ((geometry.x > 0) ? (0) : (geometry.x))));\n      offset.x += +delta.x;\n      crop.width = (size_t) MagickRound((MagickRealType) (offset.x + ((geometry.x < 0) ? (0) : (geometry.x))));\n    }\n    else\n    {\n      crop.x = (ssize_t) MagickRound((MagickRealType) (offset.x - ((geometry.x > 0) ? (geometry.x) : (0))));\n      offset.x += +delta.x;\n      crop.width = (size_t) MagickRound((MagickRealType) (offset.x + ((geometry.x < 0) ? (geometry.x) : (0))));\n    }\n    crop.width -= crop.x;\n    crop.x += image->page.x;\n    next = CropImage(image, &crop, exception);\n    if (next == ((Image *) 0))\n      break;\n    AppendImageToList(&crop_image, next);\n  }\n\n  if (next == ((Image *) 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/12"}
{"code": "for (y = 0; y < ((ssize_t) page.height); y += (ssize_t) height)\n{\n  for (x = 0; x < ((ssize_t) page.width); x += (ssize_t) width)\n  {\n    geometry.width = width;\n    geometry.height = height;\n    geometry.x = x;\n    geometry.y = y;\n    next = CropImage(image, &geometry, exception);\n    if (next == ((Image *) 0))\n      break;\n    AppendImageToList(&crop_image, next);\n  }\n\n  if (next == ((Image *) 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/13"}
{"code": "for (i = 0; image_list[i] != ((Image *) 0); i++)\n{\n  image = image_list[i];\n  status |= TransformImage(&image, crop_geometry, image_geometry);\n  AppendImageToList(&transform_images, image);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_transform/14"}
{"code": "for (i = 0; i < (32 / 4); i++)\n{\n  *(q++) = (unsigned char) (((*p) >> 24) & 0xff);\n  *(q++) = (unsigned char) (((*p) >> 16) & 0xff);\n  *(q++) = (unsigned char) (((*p) >> 8) & 0xff);\n  *(q++) = (unsigned char) ((*p) & 0xff);\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  length = ExportQuantumPixels(image, image_view, quantum_info, quantum_type, pixels, &image->exception);\n  SetStringInfoLength(signature, length);\n  SetStringInfoDatum(signature, pixels);\n  UpdateSignature(signature_info, signature);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/1"}
{"code": "for (i = 0; i < 16; i++)\n{\n  T = *((unsigned int *) p);\n  p += 4;\n  W[i] = Trunc32(T);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/2"}
{"code": "for (i = 0; i < 16; i += 2)\n{\n  T = *((unsigned int *) p);\n  p += 8;\n  W[i] = Trunc32(T >> shift);\n  W[i + 1] = Trunc32(T);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  T = *((unsigned int *) p);\n  p += 4;\n  W[i] = ((((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)) | ((T >> 8) & 0x0000ff00)) | ((T >> 24) & 0x000000ff);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/4"}
{"code": "for (i = 0; i < 16; i += 2)\n{\n  T = *((unsigned int *) p);\n  p += 8;\n  W[i] = ((((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)) | ((T >> 8) & 0x0000ff00)) | ((T >> 24) & 0x000000ff);\n  T >>= shift;\n  W[i + 1] = ((((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)) | ((T >> 8) & 0x0000ff00)) | ((T >> 24) & 0x000000ff);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/5"}
{"code": "for (i = 16; i < 64; i++)\n  W[i] = Trunc32(((((RotateRight(W[i - 2], 17) ^ RotateRight(W[i - 2], 19)) ^ Trunc32(W[i - 2] >> 10)) + W[i - 7]) + ((RotateRight(W[i - 15], 7) ^ RotateRight(W[i - 15], 18)) ^ Trunc32(W[i - 15] >> 3))) + W[i - 16]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/6"}
{"code": "for (j = 0; j < 64; j++)\n{\n  T1 = Trunc32((((H + ((RotateRight(E, 6) ^ RotateRight(E, 11)) ^ RotateRight(E, 25))) + Ch(E, F, G)) + K[j]) + W[j]);\n  T2 = Trunc32(((RotateRight(A, 2) ^ RotateRight(A, 13)) ^ RotateRight(A, 22)) + Maj(A, B, C));\n  H = G;\n  G = F;\n  F = E;\n  E = Trunc32(D + T1);\n  D = C;\n  C = B;\n  B = A;\n  A = Trunc32(T1 + T2);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_signature/7"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict threshold_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) width) / 2L), y - (((ssize_t) height) / 2L), image->columns + width, height, exception);\n  q = GetCacheViewAuthenticPixels(threshold_view, 0, y, threshold_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  threshold_indexes = GetCacheViewAuthenticIndexQueue(threshold_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket mean;\n    MagickPixelPacket pixel;\n    const PixelPacket *r;\n    ssize_t u;\n    ssize_t v;\n    pixel = zero;\n    mean = zero;\n    r = p;\n    for (v = 0; v < ((ssize_t) height); v++)\n    {\n      for (u = 0; u < ((ssize_t) width); u++)\n      {\n        pixel.red += r[u].red;\n        pixel.green += r[u].green;\n        pixel.blue += r[u].blue;\n        pixel.opacity += r[u].opacity;\n        if (image->colorspace == CMYKColorspace)\n          pixel.index = (MagickRealType) GetPixelIndex(((indexes + x) + (r - p)) + u);\n      }\n\n      r += image->columns + width;\n    }\n\n    mean.red = (MagickRealType) ((pixel.red / number_pixels) + offset);\n    mean.green = (MagickRealType) ((pixel.green / number_pixels) + offset);\n    mean.blue = (MagickRealType) ((pixel.blue / number_pixels) + offset);\n    mean.opacity = (MagickRealType) ((pixel.opacity / number_pixels) + offset);\n    if (image->colorspace == CMYKColorspace)\n      mean.index = (MagickRealType) ((pixel.index / number_pixels) + offset);\n    SetPixelRed(q, (((MagickRealType) GetPixelRed(q)) <= mean.red) ? (0) : (QuantumRange));\n    SetPixelGreen(q, (((MagickRealType) GetPixelGreen(q)) <= mean.green) ? (0) : (QuantumRange));\n    SetPixelBlue(q, (((MagickRealType) GetPixelBlue(q)) <= mean.blue) ? (0) : (QuantumRange));\n    SetPixelOpacity(q, (((MagickRealType) GetPixelOpacity(q)) <= mean.opacity) ? (0) : (QuantumRange));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(threshold_indexes + x, (((MagickRealType) GetPixelIndex(threshold_indexes + x)) <= mean.index) ? (0) : (QuantumRange));\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(threshold_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_AdaptiveThresholdImage)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  if (channel == DefaultChannels)\n  {\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    {\n      SetPixelRed(q, (((MagickRealType) PixelIntensityToQuantum(q)) <= threshold) ? (0) : (QuantumRange));\n      SetPixelGreen(q, GetPixelRed(q));\n      SetPixelBlue(q, GetPixelRed(q));\n      q++;\n    }\n\n  }\n  else\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, (((MagickRealType) GetPixelRed(q)) <= threshold) ? (0) : (QuantumRange));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, (((MagickRealType) GetPixelGreen(q)) <= threshold) ? (0) : (QuantumRange));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, (((MagickRealType) GetPixelBlue(q)) <= threshold) ? (0) : (QuantumRange));\n    if ((channel & OpacityChannel) != 0)\n    {\n      if (image->matte == MagickFalse)\n        SetPixelOpacity(q, (((MagickRealType) GetPixelOpacity(q)) <= threshold) ? (0) : (QuantumRange));\n      else\n        SetPixelOpacity(q, (((MagickRealType) GetPixelOpacity(q)) <= threshold) ? (OpaqueOpacity) : (TransparentOpacity));\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, (((MagickRealType) GetPixelIndex(indexes + x)) <= threshold) ? (0) : (QuantumRange));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_BilevelImageChannel)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (channel != DefaultChannels)\n    {\n      if (PixelIntensity(q) < MagickPixelIntensity(&threshold))\n      {\n        SetPixelRed(q, 0);\n        SetPixelGreen(q, 0);\n        SetPixelBlue(q, 0);\n        if (image->colorspace == CMYKColorspace)\n          SetPixelIndex(indexes + x, 0);\n      }\n    }\n    else\n    {\n      if (((channel & RedChannel) != 0) && (((MagickRealType) GetPixelRed(q)) < threshold.red))\n        SetPixelRed(q, 0);\n      if (((channel & GreenChannel) != 0) && (((MagickRealType) GetPixelGreen(q)) < threshold.green))\n        SetPixelGreen(q, 0);\n      if (((channel & BlueChannel) != 0) && (((MagickRealType) GetPixelBlue(q)) < threshold.blue))\n        SetPixelBlue(q, 0);\n      if (((channel & OpacityChannel) != 0) && (((MagickRealType) GetPixelOpacity(q)) < threshold.opacity))\n        SetPixelOpacity(q, 0);\n      if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (((MagickRealType) GetPixelIndex(indexes + x)) < threshold.index))\n        SetPixelIndex(indexes + x, 0);\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_BlackThresholdImageChannel)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToUnsignedQuantum(GetPixelRed(q)));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToUnsignedQuantum(GetPixelGreen(q)));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToUnsignedQuantum(GetPixelBlue(q)));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, ClampToUnsignedQuantum(GetPixelOpacity(q)));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToUnsignedQuantum(GetPixelIndex(indexes + x)));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ClampImageChannel)\n    proceed = SetImageProgress(image, \"Clamp/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ssize_t threshold;\n    ssize_t t;\n    ssize_t l;\n    threshold = map->levels[(x % map->width) + (map->width * (y % map->height))];\n    if (levels.red)\n    {\n      t = (ssize_t) ((QuantumScale * GetPixelRed(q)) * ((levels.red * d) + 1));\n      l = t / d;\n      t = t - (l * d);\n      SetPixelRed(q, RoundToQuantum((MagickRealType) (((l + (t >= threshold)) * ((MagickRealType) QuantumRange)) / levels.red)));\n    }\n    if (levels.green)\n    {\n      t = (ssize_t) ((QuantumScale * GetPixelGreen(q)) * ((levels.green * d) + 1));\n      l = t / d;\n      t = t - (l * d);\n      SetPixelGreen(q, RoundToQuantum((MagickRealType) (((l + (t >= threshold)) * ((MagickRealType) QuantumRange)) / levels.green)));\n    }\n    if (levels.blue)\n    {\n      t = (ssize_t) ((QuantumScale * GetPixelBlue(q)) * ((levels.blue * d) + 1));\n      l = t / d;\n      t = t - (l * d);\n      SetPixelBlue(q, RoundToQuantum((MagickRealType) (((l + (t >= threshold)) * ((MagickRealType) QuantumRange)) / levels.blue)));\n    }\n    if (levels.opacity)\n    {\n      t = (ssize_t) ((1.0 - (QuantumScale * GetPixelOpacity(q))) * ((levels.opacity * d) + 1));\n      l = t / d;\n      t = t - (l * d);\n      SetPixelOpacity(q, RoundToQuantum((MagickRealType) ((((1.0 - l) - (t >= threshold)) * ((MagickRealType) QuantumRange)) / levels.opacity)));\n    }\n    if (levels.index)\n    {\n      t = (ssize_t) ((QuantumScale * GetPixelIndex(indexes + x)) * ((levels.index * d) + 1));\n      l = t / d;\n      t = t - (l * d);\n      SetPixelIndex(indexes + x, RoundToQuantum((MagickRealType) (((l + (t >= threshold)) * ((MagickRealType) QuantumRange)) / levels.index)));\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_OrderedPosterizeImageChannel)\n    proceed = SetImageProgress(image, \"Dither/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  MagickBooleanType sync;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    IndexPacket index;\n    MagickRealType intensity;\n    intensity = (MagickRealType) PixelIntensityToQuantum(q);\n    if (intensity < min_threshold)\n      threshold.index = min_threshold;\n    else\n      if (intensity > max_threshold)\n      threshold.index = max_threshold;\n    else\n      threshold.index = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    index = (IndexPacket) ((intensity <= threshold.index) ? (0) : (1));\n    SetPixelIndex(indexes + x, index);\n    SetPixelRGBO(q, image->colormap + ((ssize_t) index));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_RandomThresholdImageChannel)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/5"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n    {\n      if (((MagickRealType) GetPixelRed(q)) < min_threshold)\n        threshold.red = min_threshold;\n      else\n        if (((MagickRealType) GetPixelRed(q)) > max_threshold)\n        threshold.red = max_threshold;\n      else\n        threshold.red = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      if (((MagickRealType) GetPixelGreen(q)) < min_threshold)\n        threshold.green = min_threshold;\n      else\n        if (((MagickRealType) GetPixelGreen(q)) > max_threshold)\n        threshold.green = max_threshold;\n      else\n        threshold.green = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      if (((MagickRealType) GetPixelBlue(q)) < min_threshold)\n        threshold.blue = min_threshold;\n      else\n        if (((MagickRealType) GetPixelBlue(q)) > max_threshold)\n        threshold.blue = max_threshold;\n      else\n        threshold.blue = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    }\n    if ((channel & OpacityChannel) != 0)\n    {\n      if (((MagickRealType) GetPixelOpacity(q)) < min_threshold)\n        threshold.opacity = min_threshold;\n      else\n        if (((MagickRealType) GetPixelOpacity(q)) > max_threshold)\n        threshold.opacity = max_threshold;\n      else\n        threshold.opacity = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      if (((MagickRealType) GetPixelIndex(indexes + x)) < min_threshold)\n        threshold.index = min_threshold;\n      else\n        if (((MagickRealType) GetPixelIndex(indexes + x)) > max_threshold)\n        threshold.index = max_threshold;\n      else\n        threshold.index = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    }\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, (((MagickRealType) GetPixelRed(q)) <= threshold.red) ? (0) : (QuantumRange));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, (((MagickRealType) GetPixelGreen(q)) <= threshold.green) ? (0) : (QuantumRange));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, (((MagickRealType) GetPixelBlue(q)) <= threshold.blue) ? (0) : (QuantumRange));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, (((MagickRealType) GetPixelOpacity(q)) <= threshold.opacity) ? (0) : (QuantumRange));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, (((MagickRealType) GetPixelIndex(indexes + x)) <= threshold.index) ? (0) : (QuantumRange));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_RandomThresholdImageChannel)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/6"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (channel != DefaultChannels)\n    {\n      if (PixelIntensity(q) > MagickPixelIntensity(&threshold))\n      {\n        SetPixelRed(q, QuantumRange);\n        SetPixelGreen(q, QuantumRange);\n        SetPixelBlue(q, QuantumRange);\n        if (image->colorspace == CMYKColorspace)\n          SetPixelIndex(indexes + x, QuantumRange);\n      }\n    }\n    else\n    {\n      if (((channel & RedChannel) != 0) && (((MagickRealType) GetPixelRed(q)) > threshold.red))\n        SetPixelRed(q, QuantumRange);\n      if (((channel & GreenChannel) != 0) && (((MagickRealType) GetPixelGreen(q)) > threshold.green))\n        SetPixelGreen(q, QuantumRange);\n      if (((channel & BlueChannel) != 0) && (((MagickRealType) GetPixelBlue(q)) > threshold.blue))\n        SetPixelBlue(q, QuantumRange);\n      if (((channel & OpacityChannel) != 0) && (((MagickRealType) GetPixelOpacity(q)) > threshold.opacity))\n        SetPixelOpacity(q, QuantumRange);\n      if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (((MagickRealType) GetPixelIndex(indexes + x)) > threshold.index))\n        SetPixelIndex(indexes + x, QuantumRange);\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_WhiteThresholdImageChannel)\n    proceed = SetImageProgress(image, \"Threshold/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/7"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  SetPixelRed(q, ClampToUnsignedQuantum(GetPixelRed(q)));\n  SetPixelGreen(q, ClampToUnsignedQuantum(GetPixelGreen(q)));\n  SetPixelBlue(q, ClampToUnsignedQuantum(GetPixelBlue(q)));\n  SetPixelOpacity(q, ClampToUnsignedQuantum(GetPixelOpacity(q)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/8"}
{"code": "for (threshold = GetXMLTreeChild(thresholds, \"threshold\"); threshold != ((XMLTreeInfo *) 0); threshold = GetNextXMLTreeTag(threshold))\n{\n  attr = GetXMLTreeAttribute(threshold, \"map\");\n  if ((attr != ((char *) 0)) && (LocaleCompare(map_id, attr) == 0))\n    break;\n  attr = GetXMLTreeAttribute(threshold, \"alias\");\n  if ((attr != ((char *) 0)) && (LocaleCompare(map_id, attr) == 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/9"}
{"code": "for (i = 0; i < ((ssize_t) (map->width * map->height)); i++)\n{\n  map->levels[i] = (ssize_t) strtol(content, &p, 10);\n  if (p == content)\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionError, \"XmlInvalidContent\", \"<level> too few values, map \\\"%s\\\"\", map_id);\n    thresholds = DestroyXMLTree(thresholds);\n    map = DestroyThresholdMap(map);\n    return map;\n  }\n  if ((map->levels[i] < 0) || (map->levels[i] > map->divisor))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionError, \"XmlInvalidContent\", \"<level> %.20g out of range, map \\\"%s\\\"\", (double) map->levels[i], map_id);\n    thresholds = DestroyXMLTree(thresholds);\n    map = DestroyThresholdMap(map);\n    return map;\n  }\n  content = p;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/10"}
{"code": "for (threshold = GetXMLTreeChild(thresholds, \"threshold\"); threshold != ((XMLTreeInfo *) 0); threshold = GetNextXMLTreeTag(threshold))\n{\n  map = GetXMLTreeAttribute(threshold, \"map\");\n  if (map == ((char *) 0))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionError, \"XmlMissingAttribute\", \"<map>\");\n    thresholds = DestroyXMLTree(thresholds);\n    return MagickFalse;\n  }\n  alias = GetXMLTreeAttribute(threshold, \"alias\");\n  description = GetXMLTreeChild(threshold, \"description\");\n  if (description == ((XMLTreeInfo *) 0))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionError, \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\", map);\n    thresholds = DestroyXMLTree(thresholds);\n    return MagickFalse;\n  }\n  content = GetXMLTreeContent(description);\n  if (content == ((char *) 0))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), OptionError, \"XmlMissingContent\", \"<description>, map \\\"%s\\\"\", map);\n    thresholds = DestroyXMLTree(thresholds);\n    return MagickFalse;\n  }\n  (void) FormatLocaleFile(file, \"%-16s %-12s %s\\n\", map, (alias) ? (alias) : (\"\"), content);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_threshold/11"}
{"code": "for (pend = splay_tree->root; pend != ((NodeInfo *) 0);)\n{\n  active = pend;\n  for (pend = (NodeInfo *) 0; active != ((NodeInfo *) 0);)\n  {\n    if (active->left != ((NodeInfo *) 0))\n    {\n      if ((splay_tree->relinquish_value != ((void *(*)(void *)) 0)) && (active->left->value != ((void *) 0)))\n        active->left->value = splay_tree->relinquish_value(active->left->value);\n      if ((splay_tree->relinquish_key != ((void *(*)(void *)) 0)) && (active->left->key != ((void *) 0)))\n        active->left->key = splay_tree->relinquish_key(active->left->key);\n      active->left->key = (void *) pend;\n      pend = active->left;\n    }\n    if (active->right != ((NodeInfo *) 0))\n    {\n      if ((splay_tree->relinquish_value != ((void *(*)(void *)) 0)) && (active->right->value != ((void *) 0)))\n        active->right->value = splay_tree->relinquish_value(active->right->value);\n      if ((splay_tree->relinquish_key != ((void *(*)(void *)) 0)) && (active->right->key != ((void *) 0)))\n        active->right->key = splay_tree->relinquish_key(active->right->key);\n      active->right->key = (void *) pend;\n      pend = active->right;\n    }\n    node = active;\n    active = (NodeInfo *) node->key;\n    node = (NodeInfo *) RelinquishMagickMemory(node);\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_splay-tree/0"}
{"code": "for (i = 0; final_transition == MagickFalse;)\n{\n  node = nodes[i];\n  transition = (TransitionType) transitions[i];\n  switch (transition)\n  {\n    case LeftTransition:\n    {\n      transitions[i] = (unsigned char) DownTransition;\n      if (node->left == ((NodeInfo *) 0))\n        break;\n      i++;\n      nodes[i] = node->left;\n      transitions[i] = (unsigned char) LeftTransition;\n      break;\n    }\n\n    case RightTransition:\n    {\n      transitions[i] = (unsigned char) UpTransition;\n      if (node->right == ((NodeInfo *) 0))\n        break;\n      i++;\n      nodes[i] = node->right;\n      transitions[i] = (unsigned char) LeftTransition;\n      break;\n    }\n\n    case DownTransition:\n\n    default:\n    {\n      transitions[i] = (unsigned char) RightTransition;\n      status = (*method)(node, value);\n      if (status != 0)\n        final_transition = MagickTrue;\n      break;\n    }\n\n    case UpTransition:\n    {\n      if (i == 0)\n      {\n        final_transition = MagickTrue;\n        break;\n      }\n      i--;\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_splay-tree/1"}
{"code": "for (p = path; (*p) != '\\0'; p++)\n  if ((*p) == (*DirectorySeparator))\n  *p = '/';\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_resource/0"}
{"code": "for (i = 0; i < ((ssize_t) 238328); i++)\n{\n  (void) GetPathTemplate(path);\n  key = GetRandomKey(random_info, 2);\n  p = (path + strlen(path)) - 8;\n  datum = GetStringInfoDatum(key);\n  for (i = 0; i < ((ssize_t) GetStringInfoLength(key)); i++)\n  {\n    c = (int) (datum[i] & 0x3f);\n    *(p++) = portable_filename[c];\n  }\n\n  key = DestroyStringInfo(key);\n  key = GetRandomKey(random_info, 6);\n  p = (path + strlen(path)) - 6;\n  datum = GetStringInfoDatum(key);\n  for (i = 0; i < ((ssize_t) GetStringInfoLength(key)); i++)\n  {\n    c = (int) (datum[i] & 0x3f);\n    *(p++) = portable_filename[c];\n  }\n\n  key = DestroyStringInfo(key);\n  file = open(path, (((O_RDWR | O_CREAT) | O_EXCL) | O_BINARY) | 0, S_MODE);\n  if ((file >= 0) || (errno != EEXIST))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_resource/1"}
{"code": "for (p = key; (*p) != '\\0'; p++)\n  if ((*p) == '=')\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_registry/0"}
{"code": "for (x = 0; x < ((ssize_t) p->width); x++)\n{\n  ssize_t y;\n  size_t sum;\n  sum = 0;\n  for (y = 0; y < ((ssize_t) (p->height - 1)); y++)\n  {\n    ssize_t delta;\n    delta = GetRadonCell(p, x, y) - ((ssize_t) GetRadonCell(p, x, y + 1));\n    sum += delta * delta;\n  }\n\n  projection[(p->width + (sign * x)) - 1] = sum;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t i;\n  ssize_t x;\n  size_t bit;\n  size_t byte;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  bit = 0;\n  byte = 0;\n  i = ((ssize_t) (image->columns + 7)) / 8;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    byte <<= 1;\n    if (((((MagickRealType) GetPixelRed(p)) < threshold) || (((MagickRealType) GetPixelGreen(p)) < threshold)) || (((MagickRealType) GetPixelBlue(p)) < threshold))\n      byte |= 0x01;\n    bit++;\n    if (bit == 8)\n    {\n      (void) SetRadonCell(source_cells, --i, y, bits[byte]);\n      bit = 0;\n      byte = 0;\n    }\n    p++;\n  }\n\n  if (bit != 0)\n  {\n    byte <<= 8 - bit;\n    (void) SetRadonCell(source_cells, --i, y, bits[byte]);\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t i;\n  ssize_t x;\n  size_t bit;\n  size_t byte;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  bit = 0;\n  byte = 0;\n  i = 0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    byte <<= 1;\n    if (((((MagickRealType) GetPixelRed(p)) < threshold) || (((MagickRealType) GetPixelGreen(p)) < threshold)) || (((MagickRealType) GetPixelBlue(p)) < threshold))\n      byte |= 0x01;\n    bit++;\n    if (bit == 8)\n    {\n      (void) SetRadonCell(source_cells, i++, y, bits[byte]);\n      bit = 0;\n      byte = 0;\n    }\n    p++;\n  }\n\n  if (bit != 0)\n  {\n    byte <<= 8 - bit;\n    (void) SetRadonCell(source_cells, i++, y, bits[byte]);\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/2"}
{"code": "for (tile_y = 0; tile_y < ((ssize_t) image->rows); tile_y += (ssize_t) tile_height)\n{\n  ssize_t tile_x;\n  if (status == MagickFalse)\n    continue;\n  for (tile_x = 0; tile_x < ((ssize_t) image->columns); tile_x += (ssize_t) tile_width)\n  {\n    MagickBooleanType sync;\n    const IndexPacket * restrict indexes;\n    const PixelPacket * restrict p;\n    IndexPacket * restrict rotate_indexes;\n    ssize_t y;\n    PixelPacket * restrict q;\n    size_t height;\n    size_t width;\n    width = tile_width;\n    if ((tile_x + ((ssize_t) tile_width)) > ((ssize_t) image->columns))\n      width = (size_t) (tile_width - ((tile_x + tile_width) - image->columns));\n    height = tile_height;\n    if ((tile_y + ((ssize_t) tile_height)) > ((ssize_t) image->rows))\n      height = (size_t) (tile_height - ((tile_y + tile_height) - image->rows));\n    p = GetCacheViewVirtualPixels(image_view, tile_x, tile_y, width, height, exception);\n    if (p == ((const PixelPacket *) 0))\n    {\n      status = MagickFalse;\n      break;\n    }\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    for (y = 0; y < ((ssize_t) width); y++)\n    {\n      const PixelPacket * restrict tile_pixels;\n      ssize_t x;\n      q = QueueCacheViewAuthenticPixels(rotate_view, (ssize_t) (rotate_image->columns - (tile_y + height)), y + tile_x, height, 1, exception);\n      if (q == ((PixelPacket *) 0))\n      {\n        status = MagickFalse;\n        break;\n      }\n      tile_pixels = (p + ((height - 1) * width)) + y;\n      for (x = 0; x < ((ssize_t) height); x++)\n      {\n        *(q++) = *tile_pixels;\n        tile_pixels -= width;\n      }\n\n      rotate_indexes = GetCacheViewAuthenticIndexQueue(rotate_view);\n      if ((indexes != ((IndexPacket *) 0)) && (rotate_indexes != ((IndexPacket *) 0)))\n      {\n        const IndexPacket * restrict tile_indexes;\n        tile_indexes = (indexes + ((height - 1) * width)) + y;\n        for (x = 0; x < ((ssize_t) height); x++)\n        {\n          *(rotate_indexes++) = *tile_indexes;\n          tile_indexes -= width;\n        }\n\n      }\n      sync = SyncCacheViewAuthenticPixels(rotate_view, exception);\n      if (sync == MagickFalse)\n        status = MagickFalse;\n    }\n\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Rotate/Image\", progress += tile_height, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(static,1) shared(progress, status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict rotate_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(rotate_view, 0, (ssize_t) ((image->rows - y) - 1), image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  rotate_indexes = GetCacheViewAuthenticIndexQueue(rotate_view);\n  q += image->columns;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n    *(--q) = *(p++);\n\n  if ((indexes != ((IndexPacket *) 0)) && (rotate_indexes != ((IndexPacket *) 0)))\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    SetPixelIndex(((rotate_indexes + image->columns) - x) - 1, GetPixelIndex(indexes + x));\n\n  sync = SyncCacheViewAuthenticPixels(rotate_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Rotate/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(static,8) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/4"}
{"code": "for (tile_y = 0; tile_y < ((ssize_t) image->rows); tile_y += (ssize_t) tile_height)\n{\n  ssize_t tile_x;\n  if (status == MagickFalse)\n    continue;\n  for (tile_x = 0; tile_x < ((ssize_t) image->columns); tile_x += (ssize_t) tile_width)\n  {\n    MagickBooleanType sync;\n    const IndexPacket * restrict indexes;\n    const PixelPacket * restrict p;\n    IndexPacket * restrict rotate_indexes;\n    ssize_t y;\n    PixelPacket * restrict q;\n    size_t height;\n    size_t width;\n    width = tile_width;\n    if ((tile_x + ((ssize_t) tile_width)) > ((ssize_t) image->columns))\n      width = (size_t) (tile_width - ((tile_x + tile_width) - image->columns));\n    height = tile_height;\n    if ((tile_y + ((ssize_t) tile_height)) > ((ssize_t) image->rows))\n      height = (size_t) (tile_height - ((tile_y + tile_height) - image->rows));\n    p = GetCacheViewVirtualPixels(image_view, tile_x, tile_y, width, height, exception);\n    if (p == ((const PixelPacket *) 0))\n    {\n      status = MagickFalse;\n      break;\n    }\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    for (y = 0; y < ((ssize_t) width); y++)\n    {\n      const PixelPacket * restrict tile_pixels;\n      ssize_t x;\n      q = QueueCacheViewAuthenticPixels(rotate_view, tile_y, (ssize_t) ((y + rotate_image->rows) - (tile_x + width)), height, 1, exception);\n      if (q == ((PixelPacket *) 0))\n      {\n        status = MagickFalse;\n        break;\n      }\n      tile_pixels = (p + (width - 1)) - y;\n      for (x = 0; x < ((ssize_t) height); x++)\n      {\n        *(q++) = *tile_pixels;\n        tile_pixels += width;\n      }\n\n      rotate_indexes = GetCacheViewAuthenticIndexQueue(rotate_view);\n      if ((indexes != ((IndexPacket *) 0)) && (rotate_indexes != ((IndexPacket *) 0)))\n      {\n        const IndexPacket * restrict tile_indexes;\n        tile_indexes = (indexes + (width - 1)) - y;\n        for (x = 0; x < ((ssize_t) height); x++)\n        {\n          *(rotate_indexes++) = *tile_indexes;\n          tile_indexes += width;\n        }\n\n      }\n      sync = SyncCacheViewAuthenticPixels(rotate_view, exception);\n      if (sync == MagickFalse)\n        status = MagickFalse;\n    }\n\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Rotate/Image\", progress += tile_height, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(static,1) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/5"}
{"code": "for (y = 0; y < ((ssize_t) height); y++)\n{\n  MagickPixelPacket pixel;\n  MagickPixelPacket source;\n  MagickPixelPacket destination;\n  MagickRealType area;\n  MagickRealType displacement;\n  IndexPacket * restrict indexes;\n  IndexPacket * restrict shear_indexes;\n  PixelPacket * restrict p;\n  PixelPacket * restrict q;\n  ssize_t i;\n  ShearDirection direction;\n  ssize_t step;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewAuthenticPixels(image_view, 0, y_offset + y, image->columns, 1, exception);\n  if (p == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  p += x_offset;\n  indexes += x_offset;\n  displacement = degrees * ((MagickRealType) (y - (height / 2.0)));\n  if (displacement == 0.0)\n    continue;\n  if (displacement > 0.0)\n    direction = RIGHT;\n  else\n  {\n    displacement *= -1.0;\n    direction = LEFT;\n  }\n  step = (ssize_t) floor((double) displacement);\n  area = (MagickRealType) (displacement - step);\n  step++;\n  pixel = background;\n  GetMagickPixelPacket(image, &source);\n  GetMagickPixelPacket(image, &destination);\n  switch (direction)\n  {\n    case LEFT:\n    {\n      if (step > x_offset)\n        break;\n      q = p - step;\n      shear_indexes = indexes - step;\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        if ((x_offset + i) < step)\n        {\n          SetMagickPixelPacket(image, ++p, ++indexes, &pixel);\n          q++;\n          shear_indexes++;\n          continue;\n        }\n        SetMagickPixelPacket(image, p, indexes, &source);\n        MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &source, (MagickRealType) GetPixelOpacity(p), area, &destination);\n        SetPixelPacket(image, &destination, q++, shear_indexes++);\n        SetMagickPixelPacket(image, p++, indexes++, &pixel);\n      }\n\n      MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &background, (MagickRealType) background.opacity, area, &destination);\n      SetPixelPacket(image, &destination, q++, shear_indexes++);\n      for (i = 0; i < (step - 1); i++)\n        SetPixelPacket(image, &background, q++, shear_indexes++);\n\n      break;\n    }\n\n    case RIGHT:\n    {\n      p += width;\n      indexes += width;\n      q = p + step;\n      shear_indexes = indexes + step;\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        p--;\n        indexes--;\n        q--;\n        shear_indexes--;\n        if (((size_t) (((x_offset + width) + step) - i)) >= image->columns)\n          continue;\n        SetMagickPixelPacket(image, p, indexes, &source);\n        MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &source, (MagickRealType) GetPixelOpacity(p), area, &destination);\n        SetPixelPacket(image, &destination, q, shear_indexes);\n        SetMagickPixelPacket(image, p, indexes, &pixel);\n      }\n\n      MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &background, (MagickRealType) background.opacity, area, &destination);\n      SetPixelPacket(image, &destination, --q, --shear_indexes);\n      for (i = 0; i < (step - 1); i++)\n        SetPixelPacket(image, &background, --q, --shear_indexes);\n\n      break;\n    }\n\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_XShearImage)\n    proceed = SetImageProgress(image, \"XShear/Image\", progress++, height);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress, status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/6"}
{"code": "for (x = 0; x < ((ssize_t) width); x++)\n{\n  ssize_t step;\n  MagickPixelPacket pixel;\n  MagickPixelPacket source;\n  MagickPixelPacket destination;\n  MagickRealType area;\n  MagickRealType displacement;\n  IndexPacket * restrict indexes;\n  IndexPacket * restrict shear_indexes;\n  ssize_t i;\n  PixelPacket * restrict p;\n  PixelPacket * restrict q;\n  ShearDirection direction;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewAuthenticPixels(image_view, x_offset + x, 0, 1, image->rows, exception);\n  if (p == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  p += y_offset;\n  indexes += y_offset;\n  displacement = degrees * ((MagickRealType) (x - (width / 2.0)));\n  if (displacement == 0.0)\n    continue;\n  if (displacement > 0.0)\n    direction = DOWN;\n  else\n  {\n    displacement *= -1.0;\n    direction = UP;\n  }\n  step = (ssize_t) floor((double) displacement);\n  area = (MagickRealType) (displacement - step);\n  step++;\n  pixel = background;\n  GetMagickPixelPacket(image, &source);\n  GetMagickPixelPacket(image, &destination);\n  switch (direction)\n  {\n    case UP:\n    {\n      if (step > y_offset)\n        break;\n      q = p - step;\n      shear_indexes = indexes - step;\n      for (i = 0; i < ((ssize_t) height); i++)\n      {\n        if ((y_offset + i) < step)\n        {\n          SetMagickPixelPacket(image, ++p, ++indexes, &pixel);\n          q++;\n          shear_indexes++;\n          continue;\n        }\n        SetMagickPixelPacket(image, p, indexes, &source);\n        MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &source, (MagickRealType) GetPixelOpacity(p), area, &destination);\n        SetPixelPacket(image, &destination, q++, shear_indexes++);\n        SetMagickPixelPacket(image, p++, indexes++, &pixel);\n      }\n\n      MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &background, (MagickRealType) background.opacity, area, &destination);\n      SetPixelPacket(image, &destination, q++, shear_indexes++);\n      for (i = 0; i < (step - 1); i++)\n        SetPixelPacket(image, &background, q++, shear_indexes++);\n\n      break;\n    }\n\n    case DOWN:\n    {\n      p += height;\n      indexes += height;\n      q = p + step;\n      shear_indexes = indexes + step;\n      for (i = 0; i < ((ssize_t) height); i++)\n      {\n        p--;\n        indexes--;\n        q--;\n        shear_indexes--;\n        if (((size_t) (((y_offset + height) + step) - i)) >= image->rows)\n          continue;\n        SetMagickPixelPacket(image, p, indexes, &source);\n        MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &source, (MagickRealType) GetPixelOpacity(p), area, &destination);\n        SetPixelPacket(image, &destination, q, shear_indexes);\n        SetMagickPixelPacket(image, p, indexes, &pixel);\n      }\n\n      MagickPixelCompositeAreaBlend(&pixel, (MagickRealType) pixel.opacity, &background, (MagickRealType) background.opacity, area, &destination);\n      SetPixelPacket(image, &destination, --q, --shear_indexes);\n      for (i = 0; i < (step - 1); i++)\n        SetPixelPacket(image, &background, --q, --shear_indexes);\n\n      break;\n    }\n\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_YShearImage)\n    proceed = SetImageProgress(image, \"YShear/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress, status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/7"}
{"code": "for (i = 0; i < 4; i++)\n{\n  extent[i].x += x_shear * extent[i].y;\n  extent[i].y += y_shear * extent[i].x;\n  if (rotate != MagickFalse)\n    extent[i].x += x_shear * extent[i].y;\n  extent[i].x += ((double) (*image)->columns) / 2.0;\n  extent[i].y += ((double) (*image)->rows) / 2.0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/8"}
{"code": "for (i = 1; i < 4; i++)\n{\n  if (min.x > extent[i].x)\n    min.x = extent[i].x;\n  if (min.y > extent[i].y)\n    min.y = extent[i].y;\n  if (max.x < extent[i].x)\n    max.x = extent[i].x;\n  if (max.y < extent[i].y)\n    max.y = extent[i].y;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/9"}
{"code": "for (y = 0; y < ((ssize_t) radon_info->height); y++)\n{\n  for (x = 0; x < ((ssize_t) radon_info->width); x++)\n  {\n    count = write(radon_info->file, &value, sizeof(*radon_info->cells));\n    if (count != ((ssize_t) (sizeof(*radon_info->cells))))\n      break;\n  }\n\n  if (x < ((ssize_t) radon_info->width))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/10"}
{"code": "for (i = 0; i < ((ssize_t) length); i += count)\n{\n  count = read(radon_info->file, buffer + i, MagickMin(length - i, (size_t) SSIZE_MAX));\n  if (count > 0)\n    continue;\n  count = 0;\n  if (errno != EINTR)\n  {\n    i = -1;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/11"}
{"code": "for (i = 0; i < ((ssize_t) length); i += count)\n{\n  count = write(radon_info->file, buffer + i, MagickMin(length - i, (size_t) SSIZE_MAX));\n  if (count > 0)\n    continue;\n  count = 0;\n  if (errno != EINTR)\n  {\n    i = -1;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/12"}
{"code": "for (step = 1; step < p->width; step *= 2)\n{\n  for (x = 0; x < ((ssize_t) p->width); x += 2 * ((ssize_t) step))\n  {\n    ssize_t i;\n    ssize_t y;\n    unsigned short cell;\n    for (i = 0; i < ((ssize_t) step); i++)\n    {\n      for (y = 0; y < ((ssize_t) ((p->height - i) - 1)); y++)\n      {\n        cell = GetRadonCell(p, x + i, y);\n        (void) SetRadonCell(q, x + (2 * i), y, cell + GetRadonCell(p, (x + i) + ((ssize_t) step), y + i));\n        (void) SetRadonCell(q, (x + (2 * i)) + 1, y, cell + GetRadonCell(p, (x + i) + ((ssize_t) step), (y + i) + 1));\n      }\n\n      for (; y < ((ssize_t) (p->height - i)); y++)\n      {\n        cell = GetRadonCell(p, x + i, y);\n        (void) SetRadonCell(q, x + (2 * i), y, cell + GetRadonCell(p, (x + i) + ((ssize_t) step), y + i));\n        (void) SetRadonCell(q, (x + (2 * i)) + 1, y, cell);\n      }\n\n      for (; y < ((ssize_t) p->height); y++)\n      {\n        cell = GetRadonCell(p, x + i, y);\n        (void) SetRadonCell(q, x + (2 * i), y, cell);\n        (void) SetRadonCell(q, (x + (2 * i)) + 1, y, cell);\n      }\n\n    }\n\n  }\n\n  swap = p;\n  p = q;\n  q = swap;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/13"}
{"code": "for (width = 1; width < ((image->columns + 7) / 8); width <<= 1)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/14"}
{"code": "for (i = 0; i < 256; i++)\n{\n  byte = (unsigned char) i;\n  for (count = 0; byte != 0; byte >>= 1)\n    count += byte & 0x01;\n\n  bits[i] = (unsigned short) count;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/15"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  if ((y >= offset) && (y < (((ssize_t) image->rows) - offset)))\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    continue;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((x >= offset) && (x < (((ssize_t) image->columns) - offset)))\n      continue;\n    background.red += QuantumScale * GetPixelRed(p);\n    background.green += QuantumScale * GetPixelGreen(p);\n    background.blue += QuantumScale * GetPixelBlue(p);\n    background.opacity += QuantumScale * GetPixelOpacity(p);\n    count++;\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/16"}
{"code": "for (i = 0; i < ((ssize_t) ((2 * width) - 1)); i++)\n{\n  if (projection[i] > max_projection)\n  {\n    skew = (i - ((ssize_t) width)) + 1;\n    max_projection = projection[i];\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/17"}
{"code": "for (rotations = 0; angle > 45.0; rotations++)\n  angle -= 90.0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_shear/18"}
{"code": "for (i = (ssize_t) depth; i > 0L;)\n{\n  if (quantum_state->bits == 0UL)\n  {\n    quantum_state->pixel = *(pixels++);\n    quantum_state->bits = 8UL;\n  }\n  quantum_bits = (size_t) i;\n  if (quantum_bits > quantum_state->bits)\n    quantum_bits = quantum_state->bits;\n  i -= (ssize_t) quantum_bits;\n  quantum_state->bits -= quantum_bits;\n  *quantum = (unsigned int) (((*quantum) << quantum_bits) | ((quantum_state->pixel >> quantum_state->bits) & (~((~0UL) << quantum_bits))));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/0"}
{"code": "for (i = (ssize_t) depth; i > 0;)\n{\n  if (quantum_state->bits == 0)\n  {\n    pixels = PushLongPixel(quantum_state->endian, pixels, &quantum_state->pixel);\n    quantum_state->bits = 32U;\n  }\n  quantum_bits = (size_t) i;\n  if (quantum_bits > quantum_state->bits)\n    quantum_bits = quantum_state->bits;\n  *quantum |= ((quantum_state->pixel >> (32U - quantum_state->bits)) & quantum_state->mask[quantum_bits]) << (depth - i);\n  i -= (ssize_t) quantum_bits;\n  quantum_state->bits -= quantum_bits;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/1"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 7); x += 8)\n{\n  for (bit = 0; bit < 8; bit++)\n  {\n    if (quantum_info->min_is_white == MagickFalse)\n      pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) == 0) ? (0x00) : (0x01));\n    else\n      pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n    SetPixelIndex((indexes + x) + bit, PushColormapIndex(image, pixel, &range_exception));\n    SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex((indexes + x) + bit)));\n    q++;\n  }\n\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/2"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 8)); bit++)\n{\n  if (quantum_info->min_is_white == MagickFalse)\n    pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) == 0) ? (0x00) : (0x01));\n  else\n    pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n  SetPixelIndex((indexes + x) + bit, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex((indexes + x) + bit)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/3"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 1); x += 2)\n{\n  pixel = (unsigned char) (((*p) >> 4) & 0xf);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  q++;\n  pixel = (unsigned char) ((*p) & 0xf);\n  SetPixelIndex((indexes + x) + 1, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex((indexes + x) + 1)));\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/4"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 2)); bit++)\n{\n  pixel = (unsigned char) (((*(p++)) >> 4) & 0xf);\n  SetPixelIndex((indexes + x) + bit, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex((indexes + x) + bit)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/5"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/6"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/7"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/8"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(pixel), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/9"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/10"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(pixel), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/11"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/12"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 3); x += 4)\n{\n  for (bit = 0; bit < 8; bit += 2)\n  {\n    if (quantum_info->min_is_white == MagickFalse)\n      pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) == 0) ? (0x00) : (0x01));\n    else\n      pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n    SetPixelIndex((indexes + x) + (bit / 2), (pixel == 0) ? (0) : (1));\n    SetPixelRed(q, (pixel == 0) ? (0) : (QuantumRange));\n    SetPixelGreen(q, GetPixelRed(q));\n    SetPixelBlue(q, GetPixelRed(q));\n    SetPixelOpacity(q, (((*p) & (1UL << ((unsigned char) (6 - bit)))) == 0) ? (TransparentOpacity) : (OpaqueOpacity));\n    q++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/13"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 4)); bit += 2)\n{\n  if (quantum_info->min_is_white == MagickFalse)\n    pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) == 0) ? (0x00) : (0x01));\n  else\n    pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n  SetPixelIndex((indexes + x) + (bit / 2), (pixel == 0) ? (0) : (1));\n  SetPixelRed(q, (pixel == 0) ? (0) : (QuantumRange));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  SetPixelOpacity(q, (((*p) & (1UL << ((unsigned char) (6 - bit)))) == 0) ? (TransparentOpacity) : (OpaqueOpacity));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/14"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned char) (((*p) >> 4) & 0xf);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  pixel = (unsigned char) ((*p) & 0xf);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/15"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/16"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/17"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/18"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(pixel), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/19"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/20"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, ClampToQuantum(pixel), &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/21"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelIndex(indexes + x, PushColormapIndex(image, pixel, &range_exception));\n  SetPixelRGBO(q, image->colormap + ((ssize_t) GetPixelIndex(indexes + x)));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/22"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  SetPixelOpacity(q, OpaqueOpacity);\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/23"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 22) & 0x3ff, range));\n  SetPixelGreen(q, ScaleAnyToQuantum((pixel >> 12) & 0x3ff, range));\n  SetPixelBlue(q, ScaleAnyToQuantum((pixel >> 2) & 0x3ff, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/24"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/25"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/26"}
{"code": "for (x = 0; x < ((ssize_t) ((3 * number_pixels) - 1)); x += 2)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  switch (x % 3)\n  {\n    default:\n\n    case 0:\n    {\n      SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 1:\n    {\n      SetPixelGreen(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 2:\n    {\n      SetPixelBlue(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      q++;\n      break;\n    }\n\n  }\n\n  p = PushShortPixel(endian, p, &pixel);\n  switch ((x + 1) % 3)\n  {\n    default:\n\n    case 0:\n    {\n      SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 1:\n    {\n      SetPixelGreen(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 2:\n    {\n      SetPixelBlue(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      q++;\n      break;\n    }\n\n  }\n\n  p += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/27"}
{"code": "for (bit = 0; bit < ((ssize_t) ((3 * number_pixels) % 2)); bit++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  switch ((x + bit) % 3)\n  {\n    default:\n\n    case 0:\n    {\n      SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 1:\n    {\n      SetPixelGreen(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      break;\n    }\n\n    case 2:\n    {\n      SetPixelBlue(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n      q++;\n      break;\n    }\n\n  }\n\n  p += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/28"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/29"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/30"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/31"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/32"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/33"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/34"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  for (i = 0; i < 4; i++)\n  {\n    switch (n % 3)\n    {\n      case 0:\n      {\n        p = PushLongPixel(endian, p, &pixel);\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 22) & 0x3ff) << 6));\n        break;\n      }\n\n      case 1:\n      {\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 12) & 0x3ff) << 6));\n        break;\n      }\n\n      case 2:\n      {\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 2) & 0x3ff) << 6));\n        break;\n      }\n\n    }\n\n    switch (i)\n    {\n      case 0:\n        SetPixelRed(q, quantum);\n        break;\n\n      case 1:\n        SetPixelGreen(q, quantum);\n        break;\n\n      case 2:\n        SetPixelBlue(q, quantum);\n        break;\n\n      case 3:\n        SetPixelAlpha(q, quantum);\n        break;\n\n    }\n\n    n++;\n  }\n\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/35"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum((unsigned short) (pixel << 6)));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum((unsigned short) (pixel << 6)));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum((unsigned short) (pixel << 6)));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum((unsigned short) (pixel << 6)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/36"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/37"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/38"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/39"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/40"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/41"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/42"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 7); x += 8)\n{\n  for (bit = 0; bit < 8; bit++)\n  {\n    SetPixelRed(q, (((*p) & (1 << (7 - bit))) == 0) ? (black) : (white));\n    SetPixelGreen(q, GetPixelRed(q));\n    SetPixelBlue(q, GetPixelRed(q));\n    q++;\n  }\n\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/43"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 8)); bit++)\n{\n  SetPixelRed(q, (((*p) & (0x01 << (7 - bit))) == 0) ? (black) : (white));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/44"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 1); x += 2)\n{\n  pixel = (unsigned char) (((*p) >> 4) & 0xf);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  pixel = (unsigned char) ((*p) & 0xf);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/45"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 2)); bit++)\n{\n  pixel = (unsigned char) ((*(p++)) >> 4);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/46"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, QuantumRange - ScaleCharToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  SetPixelOpacity(q, OpaqueOpacity);\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/47"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  SetPixelOpacity(q, OpaqueOpacity);\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/48"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 2)); x += 3)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 2) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 12) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 22) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/49"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 2)); x += 3)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 22) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 12) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  SetPixelRed(q, ScaleAnyToQuantum((pixel >> 2) & 0x3ff, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/50"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/51"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 1)); x += 2)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  q++;\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/52"}
{"code": "for (bit = 0; bit < ((ssize_t) (number_pixels % 2)); bit++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum((QuantumAny) (pixel >> 4), range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/53"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, QuantumRange - ScaleShortToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/54"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/55"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/56"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/57"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/58"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/59"}
{"code": "for (x = 0; x < (((ssize_t) number_pixels) - 3); x += 4)\n{\n  for (bit = 0; bit < 8; bit += 2)\n  {\n    pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n    SetPixelRed(q, (pixel == 0) ? (0) : (QuantumRange));\n    SetPixelGreen(q, GetPixelRed(q));\n    SetPixelBlue(q, GetPixelRed(q));\n    SetPixelOpacity(q, (((*p) & (1UL << ((unsigned char) (6 - bit)))) == 0) ? (TransparentOpacity) : (OpaqueOpacity));\n    q++;\n  }\n\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/60"}
{"code": "for (bit = 0; bit <= ((ssize_t) (number_pixels % 4)); bit += 2)\n{\n  pixel = (unsigned char) ((((*p) & (1 << (7 - bit))) != 0) ? (0x00) : (0x01));\n  SetPixelRed(q, (pixel != 0) ? (0) : (QuantumRange));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  SetPixelOpacity(q, (((*p) & (1UL << ((unsigned char) (6 - bit)))) == 0) ? (TransparentOpacity) : (OpaqueOpacity));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/61"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned char) (((*p) >> 4) & 0xf);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  pixel = (unsigned char) ((*p) & 0xf);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/62"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/63"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelOpacity(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/64"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/65"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/66"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/67"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/68"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/69"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  SetPixelGreen(q, GetPixelRed(q));\n  SetPixelBlue(q, GetPixelRed(q));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/70"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/71"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/72"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/73"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/74"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/75"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/76"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/77"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/78"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/79"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/80"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/81"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/82"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/83"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/84"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/85"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/86"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/87"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/88"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/89"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/90"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/91"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/92"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/93"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/94"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/95"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/96"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/97"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/98"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelIndex(indexes + x, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/99"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/100"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/101"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/102"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/103"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/104"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleAnyToQuantum(pixel, range));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/105"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  SetPixelOpacity(q, OpaqueOpacity);\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/106"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumLongPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/107"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/108"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/109"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/110"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/111"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/112"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/113"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/114"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelIndex(indexes + x, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/115"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/116"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/117"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/118"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/119"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/120"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/121"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushCharPixel(p, &pixel);\n  SetPixelRed(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelGreen(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelBlue(q, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelIndex(indexes + x, ScaleCharToQuantum(pixel));\n  p = PushCharPixel(p, &pixel);\n  SetPixelAlpha(q, ScaleCharToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/122"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * HalfToSinglePrecision(pixel)));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/123"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleShortToQuantum(pixel));\n  p = PushShortPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleShortToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/124"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p = PushFloatPixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/125"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelRed(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelGreen(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelBlue(q, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleLongToQuantum(pixel));\n  p = PushLongPixel(endian, p, &pixel);\n  SetPixelAlpha(q, ScaleLongToQuantum(pixel));\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/126"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelRed(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelGreen(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelBlue(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelIndex(indexes + x, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  SetPixelAlpha(q, ClampToQuantum(pixel));\n  p = PushDoublePixel(&quantum_state, p, &pixel);\n  p += quantum_info->pad;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/127"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelBlue(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelIndex(indexes + x, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelAlpha(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/128"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x += 2)\n{\n  for (i = 0; i < 4; i++)\n  {\n    switch (n % 3)\n    {\n      case 0:\n      {\n        p = PushLongPixel(endian, p, &pixel);\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 22) & 0x3ff) << 6));\n        break;\n      }\n\n      case 1:\n      {\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 12) & 0x3ff) << 6));\n        break;\n      }\n\n      case 2:\n      {\n        quantum = (size_t) ScaleShortToQuantum((unsigned short) (((pixel >> 2) & 0x3ff) << 6));\n        break;\n      }\n\n    }\n\n    cbcr[i] = (Quantum) quantum;\n    n++;\n  }\n\n  p += quantum_info->pad;\n  SetPixelRed(q, cbcr[1]);\n  SetPixelGreen(q, cbcr[0]);\n  SetPixelBlue(q, cbcr[2]);\n  q++;\n  SetPixelRed(q, cbcr[3]);\n  SetPixelGreen(q, cbcr[0]);\n  SetPixelBlue(q, cbcr[2]);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/129"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelRed(q, ScaleAnyToQuantum(pixel, range));\n  p = PushQuantumPixel(&quantum_state, image->depth, p, &pixel);\n  SetPixelGreen(q, ScaleAnyToQuantum(pixel, range));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/130"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  quantum = GetPixelRed(q);\n  SetPixelRed(q, GetPixelGreen(q));\n  SetPixelGreen(q, quantum);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/131"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  SetPixelOpacity(q, GetPixelAlpha(q));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/132"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  alpha = QuantumScale * GetPixelAlpha(q);\n  alpha = 1.0 / ((fabs(alpha) <= MagickEpsilon) ? (1.0) : (alpha));\n  SetPixelRed(q, ClampToQuantum(alpha * GetPixelRed(q)));\n  SetPixelGreen(q, ClampToQuantum(alpha * GetPixelGreen(q)));\n  SetPixelBlue(q, ClampToQuantum(alpha * GetPixelBlue(q)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-import/133"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  CubeInfo cube;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  ssize_t count;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  cube = *cube_info;\n  for (x = 0; x < ((ssize_t) image->columns); x += count)\n  {\n    RealPixelPacket pixel;\n    const NodeInfo *node_info;\n    ssize_t i;\n    size_t id;\n    size_t index;\n    for (count = 1; (x + count) < ((ssize_t) image->columns); count++)\n      if (IsSameColor(image, q, q + count) == MagickFalse)\n      break;\n\n    AssociateAlphaPixel(&cube, q, &pixel);\n    node_info = cube.root;\n    for (index = 8 - 1; ((ssize_t) index) > 0; index--)\n    {\n      id = ColorToNodeId(&cube, &pixel, index);\n      if (node_info->child[id] == ((NodeInfo *) 0))\n        break;\n      node_info = node_info->child[id];\n    }\n\n    cube.target = pixel;\n    cube.distance = (MagickRealType) (((4.0 * (QuantumRange + 1.0)) * (QuantumRange + 1.0)) + 1.0);\n    ClosestColor(image, &cube, node_info->parent);\n    index = cube.color_number;\n    for (i = 0; i < ((ssize_t) count); i++)\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex((indexes + x) + i, index);\n      if (cube.quantize_info->measure_error == MagickFalse)\n      {\n        SetPixelRGB(q, image->colormap + index);\n        if (cube.associate_alpha != MagickFalse)\n          SetPixelOpacity(q, image->colormap[index].opacity);\n      }\n      q++;\n    }\n\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_AssignImageColors)\n    proceed = SetImageProgress(image, \"Assign/Image\", (MagickOffsetType) y, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/0"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = (Quantum) ((QuantumRange * MagickRound((QuantumScale * image->colormap[i].red) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1));\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = (Quantum) ((QuantumRange * MagickRound((QuantumScale * image->colormap[i].green) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1));\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = (Quantum) ((QuantumRange * MagickRound((QuantumScale * image->colormap[i].blue) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1));\n  if ((channel & OpacityChannel) != 0)\n    image->colormap[i].opacity = (Quantum) ((QuantumRange * MagickRound((QuantumScale * image->colormap[i].opacity) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, (Quantum) ((QuantumRange * MagickRound((QuantumScale * GetPixelRed(q)) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1)));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, (Quantum) ((QuantumRange * MagickRound((QuantumScale * GetPixelGreen(q)) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1)));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, (Quantum) ((QuantumRange * MagickRound((QuantumScale * GetPixelBlue(q)) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1)));\n    if (((channel & OpacityChannel) != 0) && (image->matte == MagickTrue))\n      SetPixelOpacity(q, (Quantum) ((QuantumRange * MagickRound((QuantumScale * GetPixelOpacity(q)) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1)));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, (Quantum) ((QuantumRange * MagickRound((QuantumScale * GetPixelIndex(indexes + x)) * (levels - 1))) / MagickMax(((ssize_t) levels) - 1, 1)));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_PosterizeImageChannel)\n    proceed = SetImageProgress(image, \"Posterize/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    size_t intensity;\n    intensity = ScaleQuantumToMap(GetPixelRed(q));\n    if (colormap_index[intensity] < 0)\n    {\n      #pragma omp critical (MagickCore_SetGrayscaleImage)\n      if (colormap_index[intensity] < 0)\n      {\n        colormap_index[intensity] = (ssize_t) image->colors;\n        image->colormap[image->colors].red = GetPixelRed(q);\n        image->colormap[image->colors].green = GetPixelGreen(q);\n        image->colormap[image->colors].blue = GetPixelBlue(q);\n        image->colors++;\n      }\n    }\n    SetPixelIndex(indexes + x, colormap_index[intensity]);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n    SetPixelIndex(indexes + x, colormap_index[ScaleQuantumToMap(GetPixelIndex(indexes + x))]);\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/4"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  intensity = (Quantum) ((PixelIntensity(q) < (((MagickRealType) QuantumRange) / 2.0)) ? (0) : (QuantumRange));\n  SetPixelRed(q, intensity);\n  SetPixelGreen(q, intensity);\n  SetPixelBlue(q, intensity);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/5"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  if (cube_info->nodes > 266817)\n  {\n    PruneLevel(image, cube_info, cube_info->root);\n    cube_info->depth--;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x += (ssize_t) count)\n  {\n    for (count = 1; (x + ((ssize_t) count)) < ((ssize_t) image->columns); count++)\n      if (IsSameColor(image, p, p + count) == MagickFalse)\n      break;\n\n    AssociateAlphaPixel(cube_info, p, &pixel);\n    index = 8 - 1;\n    bisect = (((MagickRealType) QuantumRange) + 1.0) / 2.0;\n    mid = midpoint;\n    node_info = cube_info->root;\n    for (level = 1; level <= 8; level++)\n    {\n      bisect *= 0.5;\n      id = ColorToNodeId(cube_info, &pixel, index);\n      mid.red += ((id & 1) != 0) ? (bisect) : (-bisect);\n      mid.green += ((id & 2) != 0) ? (bisect) : (-bisect);\n      mid.blue += ((id & 4) != 0) ? (bisect) : (-bisect);\n      mid.opacity += ((id & 8) != 0) ? (bisect) : (-bisect);\n      if (node_info->child[id] == ((NodeInfo *) 0))\n      {\n        node_info->child[id] = GetNodeInfo(cube_info, id, level, node_info);\n        if (node_info->child[id] == ((NodeInfo *) 0))\n          (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", image->filename);\n        if (level == 8)\n          cube_info->colors++;\n      }\n      node_info = node_info->child[id];\n      error.red = QuantumScale * (pixel.red - mid.red);\n      error.green = QuantumScale * (pixel.green - mid.green);\n      error.blue = QuantumScale * (pixel.blue - mid.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        error.opacity = QuantumScale * (pixel.opacity - mid.opacity);\n      node_info->quantize_error += sqrt((double) (((((count * error.red) * error.red) + ((count * error.green) * error.green)) + ((count * error.blue) * error.blue)) + ((count * error.opacity) * error.opacity)));\n      cube_info->root->quantize_error += node_info->quantize_error;\n      index--;\n    }\n\n    node_info->number_unique += count;\n    node_info->total_color.red += (count * QuantumScale) * pixel.red;\n    node_info->total_color.green += (count * QuantumScale) * pixel.green;\n    node_info->total_color.blue += (count * QuantumScale) * pixel.blue;\n    if (cube_info->associate_alpha != MagickFalse)\n      node_info->total_color.opacity += (count * QuantumScale) * pixel.opacity;\n    p += count;\n  }\n\n  if (cube_info->colors > cube_info->maximum_colors)\n  {\n    PruneToCubeDepth(image, cube_info, cube_info->root);\n    break;\n  }\n  proceed = SetImageProgress(image, \"Classify/Image\", (MagickOffsetType) y, image->rows);\n  if (proceed == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/6"}
{"code": "for (y++; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  if (cube_info->nodes > 266817)\n  {\n    PruneLevel(image, cube_info, cube_info->root);\n    cube_info->depth--;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x += (ssize_t) count)\n  {\n    for (count = 1; (x + ((ssize_t) count)) < ((ssize_t) image->columns); count++)\n      if (IsSameColor(image, p, p + count) == MagickFalse)\n      break;\n\n    AssociateAlphaPixel(cube_info, p, &pixel);\n    index = 8 - 1;\n    bisect = (((MagickRealType) QuantumRange) + 1.0) / 2.0;\n    mid = midpoint;\n    node_info = cube_info->root;\n    for (level = 1; level <= cube_info->depth; level++)\n    {\n      bisect *= 0.5;\n      id = ColorToNodeId(cube_info, &pixel, index);\n      mid.red += ((id & 1) != 0) ? (bisect) : (-bisect);\n      mid.green += ((id & 2) != 0) ? (bisect) : (-bisect);\n      mid.blue += ((id & 4) != 0) ? (bisect) : (-bisect);\n      mid.opacity += ((id & 8) != 0) ? (bisect) : (-bisect);\n      if (node_info->child[id] == ((NodeInfo *) 0))\n      {\n        node_info->child[id] = GetNodeInfo(cube_info, id, level, node_info);\n        if (node_info->child[id] == ((NodeInfo *) 0))\n          (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"%s\", image->filename);\n        if (level == cube_info->depth)\n          cube_info->colors++;\n      }\n      node_info = node_info->child[id];\n      error.red = QuantumScale * (pixel.red - mid.red);\n      error.green = QuantumScale * (pixel.green - mid.green);\n      error.blue = QuantumScale * (pixel.blue - mid.blue);\n      if (cube_info->associate_alpha != MagickFalse)\n        error.opacity = QuantumScale * (pixel.opacity - mid.opacity);\n      node_info->quantize_error += sqrt((double) (((((count * error.red) * error.red) + ((count * error.green) * error.green)) + ((count * error.blue) * error.blue)) + ((count * error.opacity) * error.opacity)));\n      cube_info->root->quantize_error += node_info->quantize_error;\n      index--;\n    }\n\n    node_info->number_unique += count;\n    node_info->total_color.red += (count * QuantumScale) * pixel.red;\n    node_info->total_color.green += (count * QuantumScale) * pixel.green;\n    node_info->total_color.blue += (count * QuantumScale) * pixel.blue;\n    if (cube_info->associate_alpha != MagickFalse)\n      node_info->total_color.opacity += (count * QuantumScale) * pixel.opacity;\n    p += count;\n  }\n\n  proceed = SetImageProgress(image, \"Classify/Image\", (MagickOffsetType) y, image->rows);\n  if (proceed == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/7"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  ClosestColor(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/8"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  (void) DefineImageColormap(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/9"}
{"code": "for (i = 0; i < ((ssize_t) GetOpenMPMaximumThreads()); i++)\n  if (pixels[i] != ((RealPixelPacket *) 0))\n  pixels[i] = (RealPixelPacket *) RelinquishMagickMemory(pixels[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/10"}
{"code": "for (i = 0; i < ((ssize_t) number_threads); i++)\n{\n  pixels[i] = (RealPixelPacket *) AcquireQuantumMemory(count, 2 * (sizeof(*(*pixels))));\n  if (pixels[i] == ((RealPixelPacket *) 0))\n    return DestroyPixelThreadSet(pixels);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  CubeInfo cube;\n  RealPixelPacket *current;\n  RealPixelPacket *previous;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  size_t index;\n  ssize_t v;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  cube = *cube_info;\n  current = pixels[id] + ((y & 0x01) * image->columns);\n  previous = pixels[id] + (((y + 1) & 0x01) * image->columns);\n  v = (ssize_t) ((y & 0x01) ? (-1) : (1));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    RealPixelPacket color;\n    RealPixelPacket pixel;\n    ssize_t i;\n    ssize_t u;\n    u = (y & 0x01) ? ((((ssize_t) image->columns) - 1) - x) : (x);\n    AssociateAlphaPixel(&cube, q + u, &pixel);\n    if (x > 0)\n    {\n      pixel.red += (7 * current[u - v].red) / 16;\n      pixel.green += (7 * current[u - v].green) / 16;\n      pixel.blue += (7 * current[u - v].blue) / 16;\n      if (cube.associate_alpha != MagickFalse)\n        pixel.opacity += (7 * current[u - v].opacity) / 16;\n    }\n    if (y > 0)\n    {\n      if (x < ((ssize_t) (image->columns - 1)))\n      {\n        pixel.red += previous[u + v].red / 16;\n        pixel.green += previous[u + v].green / 16;\n        pixel.blue += previous[u + v].blue / 16;\n        if (cube.associate_alpha != MagickFalse)\n          pixel.opacity += previous[u + v].opacity / 16;\n      }\n      pixel.red += (5 * previous[u].red) / 16;\n      pixel.green += (5 * previous[u].green) / 16;\n      pixel.blue += (5 * previous[u].blue) / 16;\n      if (cube.associate_alpha != MagickFalse)\n        pixel.opacity += (5 * previous[u].opacity) / 16;\n      if (x > 0)\n      {\n        pixel.red += (3 * previous[u - v].red) / 16;\n        pixel.green += (3 * previous[u - v].green) / 16;\n        pixel.blue += (3 * previous[u - v].blue) / 16;\n        if (cube.associate_alpha != MagickFalse)\n          pixel.opacity += (3 * previous[u - v].opacity) / 16;\n      }\n    }\n    pixel.red = (MagickRealType) ClampToUnsignedQuantum(pixel.red);\n    pixel.green = (MagickRealType) ClampToUnsignedQuantum(pixel.green);\n    pixel.blue = (MagickRealType) ClampToUnsignedQuantum(pixel.blue);\n    if (cube.associate_alpha != MagickFalse)\n      pixel.opacity = (MagickRealType) ClampToUnsignedQuantum(pixel.opacity);\n    i = CacheOffset(&cube, &pixel);\n    if (cube.cache[i] < 0)\n    {\n      NodeInfo *node_info;\n      size_t id;\n      node_info = cube.root;\n      for (index = 8 - 1; ((ssize_t) index) > 0; index--)\n      {\n        id = ColorToNodeId(&cube, &pixel, index);\n        if (node_info->child[id] == ((NodeInfo *) 0))\n          break;\n        node_info = node_info->child[id];\n      }\n\n      cube.target = pixel;\n      cube.distance = (MagickRealType) (((4.0 * (QuantumRange + 1.0)) * (QuantumRange + 1.0)) + 1.0);\n      ClosestColor(image, &cube, node_info->parent);\n      cube.cache[i] = (ssize_t) cube.color_number;\n    }\n    index = (size_t) cube.cache[i];\n    if (image->storage_class == PseudoClass)\n      SetPixelIndex(indexes + u, index);\n    if (cube.quantize_info->measure_error == MagickFalse)\n    {\n      SetPixelRGB(q + u, image->colormap + index);\n      if (cube.associate_alpha != MagickFalse)\n        SetPixelOpacity(q + u, image->colormap[index].opacity);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n      status = MagickFalse;\n    AssociateAlphaPixel(&cube, image->colormap + index, &color);\n    current[u].red = pixel.red - color.red;\n    current[u].green = pixel.green - color.green;\n    current[u].blue = pixel.blue - color.blue;\n    if (cube.associate_alpha != MagickFalse)\n      current[u].opacity = pixel.opacity - color.opacity;\n    if (image->progress_monitor != ((MagickProgressMonitor) 0))\n    {\n      MagickBooleanType proceed;\n      #pragma omp critical (MagickCore_FloydSteinbergDither)\n      proceed = SetImageProgress(image, \"Dither/Image\", (MagickOffsetType) y, image->rows);\n      if (proceed == MagickFalse)\n        status = MagickFalse;\n    }\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/12"}
{"code": "for (i = 0; i < 16; i++)\n{\n  pixel.red += p->weights[i] * p->error[i].red;\n  pixel.green += p->weights[i] * p->error[i].green;\n  pixel.blue += p->weights[i] * p->error[i].blue;\n  if (cube_info->associate_alpha != MagickFalse)\n    pixel.opacity += p->weights[i] * p->error[i].opacity;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/13"}
{"code": "for (index = 8 - 1; ((ssize_t) index) > 0; index--)\n{\n  id = ColorToNodeId(cube_info, &pixel, index);\n  if (node_info->child[id] == ((NodeInfo *) 0))\n    break;\n  node_info = node_info->child[id];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/14"}
{"code": "for (depth = 1; i != 0; depth++)\n  i >>= 1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/15"}
{"code": "for (i = 0; i < ((ssize_t) length); i++)\n  cube_info->cache[i] = -1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/16"}
{"code": "for (i = 0; i < 16; i++)\n{\n  cube_info->weights[(16 - i) - 1] = 1.0 / weight;\n  weight *= exp(log(((double) QuantumRange) + 1.0) / (16 - 1.0));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/17"}
{"code": "for (i = 0; i < 16; i++)\n  weight += cube_info->weights[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/18"}
{"code": "for (i = 0; i < 16; i++)\n{\n  cube_info->weights[i] /= weight;\n  sum += cube_info->weights[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/19"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    index = 1UL * GetPixelIndex(indexes + x);\n    if (image->matte != MagickFalse)\n    {\n      alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(p));\n      beta = (MagickRealType) (QuantumScale * (QuantumRange - image->colormap[index].opacity));\n    }\n    distance = fabs((alpha * GetPixelRed(p)) - (beta * image->colormap[index].red));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    distance = fabs((alpha * GetPixelGreen(p)) - (beta * image->colormap[index].green));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    distance = fabs((alpha * GetPixelBlue(p)) - (beta * image->colormap[index].blue));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/20"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  PruneChild(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/21"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  PruneLevel(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/22"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  PruneToCubeDepth(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/23"}
{"code": "for (depth = 1; colors != 0; depth++)\n  colors >>= 2;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/24"}
{"code": "for (i = 0; image != ((Image *) 0); i++)\n{\n  progress_monitor = SetImageProgressMonitor(image, (MagickProgressMonitor) 0, image->client_data);\n  status = ClassifyImageColors(cube_info, image, &image->exception);\n  if (status == MagickFalse)\n    break;\n  (void) SetImageProgressMonitor(image, progress_monitor, image->client_data);\n  proceed = SetImageProgress(image, \"Assign/Image\", (MagickOffsetType) i, number_images);\n  if (proceed == MagickFalse)\n    break;\n  image = GetNextImageInList(image);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/25"}
{"code": "for (i = 0; image != ((Image *) 0); i++)\n{\n  progress_monitor = SetImageProgressMonitor(image, (MagickProgressMonitor) 0, image->client_data);\n  status = AssignImageColors(image, cube_info);\n  if (status == MagickFalse)\n    break;\n  (void) SetImageProgressMonitor(image, progress_monitor, image->client_data);\n  proceed = SetImageProgress(image, \"Assign/Image\", (MagickOffsetType) i, number_images);\n  if (proceed == MagickFalse)\n    break;\n  image = GetNextImageInList(image);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/26"}
{"code": "for (i = 0; i < ((ssize_t) number_children); i++)\n  if (node_info->child[i] != ((NodeInfo *) 0))\n  Reduce(image, cube_info, node_info->child[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/27"}
{"code": "for (span = cube_info->colors; cube_info->colors > cube_info->maximum_colors;)\n{\n  cube_info->pruning_threshold = cube_info->next_threshold;\n  cube_info->next_threshold = cube_info->root->quantize_error - 1;\n  cube_info->colors = 0;\n  Reduce(image, cube_info, cube_info->root);\n  offset = ((MagickOffsetType) span) - cube_info->colors;\n  proceed = SetImageProgress(image, \"Reduce/Image\", offset, (span - cube_info->maximum_colors) + 1);\n  if (proceed == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/28"}
{"code": "for (; image != ((Image *) 0); image = GetNextImageInList(image))\n{\n  status = AssignImageColors(image, cube_info);\n  if (status == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/29"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n  colormap_index[i] = -1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/30"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n  image->colormap[i].opacity = (unsigned short) i;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/31"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if (IsSameColor(image, &colormap[j], &image->colormap[i]) == MagickFalse)\n  {\n    j++;\n    colormap[j] = image->colormap[i];\n  }\n  colormap_index[(ssize_t) image->colormap[i].opacity] = j;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantize/32"}
{"code": "for (name = GetNextImageProfile(image); name != ((const char *) 0);)\n{\n  for (i = 1; i < ((ssize_t) number_arguments); i++)\n  {\n    if (((*arguments[i]) == '!') && (LocaleCompare(name, arguments[i] + 1) == 0))\n      break;\n    if (GlobExpression(name, arguments[i], MagickTrue) != MagickFalse)\n    {\n      (void) DeleteImageProfile(image, name);\n      ResetImageProfileIterator(image);\n      break;\n    }\n  }\n\n  name = GetNextImageProfile(image);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_profile/0"}
{"code": "for (i = 0; i < ((ssize_t) number_arguments); i++)\n  arguments[i] = DestroyString(arguments[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_profile/1"}
{"code": "for (i = 0; i < count; i++)\n  *(quantum++) = *(p++);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_profile/2"}
{"code": "for (p = datum; p < ((datum + length) - 16);)\n{\n  if (LocaleNCompare((char *) p, \"8BIM\", 4) != 0)\n    break;\n  p += 4;\n  p = ReadResourceShort(p, &id);\n  p = ReadResourceByte(p, &length_byte);\n  p += length_byte;\n  if (((length_byte + 1) & 0x01) != 0)\n    p++;\n  if (p > ((datum + length) - 4))\n    break;\n  p = ReadResourceLong(p, &count);\n  if ((p > ((datum + length) - count)) || (count > length))\n    break;\n  switch (id)\n  {\n    case 0x03ed:\n    {\n      unsigned short resolution;\n      p = ReadResourceShort(p, &resolution) + 6;\n      image->x_resolution = (double) resolution;\n      p = ReadResourceShort(p, &resolution) + 6;\n      image->y_resolution = (double) resolution;\n      break;\n    }\n\n    case 0x0404:\n    {\n      profile = AcquireStringInfo(count);\n      SetStringInfoDatum(profile, p);\n      (void) SetImageProfile(image, \"iptc\", profile);\n      profile = DestroyStringInfo(profile);\n      p += count;\n      break;\n    }\n\n    case 0x040c:\n    {\n      p += count;\n      break;\n    }\n\n    case 0x040f:\n    {\n      profile = AcquireStringInfo(count);\n      SetStringInfoDatum(profile, p);\n      (void) SetImageProfile(image, \"icc\", profile);\n      profile = DestroyStringInfo(profile);\n      p += count;\n      break;\n    }\n\n    case 0x0422:\n    {\n      profile = AcquireStringInfo(count);\n      SetStringInfoDatum(profile, p);\n      (void) SetImageProfile(image, \"exif\", profile);\n      profile = DestroyStringInfo(profile);\n      p += count;\n      break;\n    }\n\n    case 0x0424:\n    {\n      profile = AcquireStringInfo(count);\n      SetStringInfoDatum(profile, p);\n      (void) SetImageProfile(image, \"xmp\", profile);\n      profile = DestroyStringInfo(profile);\n      p += count;\n      break;\n    }\n\n    default:\n    {\n      p += count;\n      break;\n    }\n\n  }\n\n  if ((count & 0x01) != 0)\n    p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_profile/3"}
{"code": "for (; entry < number_entries; entry++)\n{\n  int components;\n  unsigned char *p;\n  unsigned char *q;\n  size_t number_bytes;\n  ssize_t format;\n  ssize_t tag_value;\n  q = (unsigned char *) ((directory + 2) + (12 * entry));\n  tag_value = (ssize_t) ReadProfileShort(endian, q);\n  format = (ssize_t) ReadProfileShort(endian, q + 2);\n  if ((format - 1) >= 12)\n    break;\n  components = (int) ReadProfileLong(endian, q + 4);\n  number_bytes = ((size_t) components) * format_bytes[format];\n  if (number_bytes <= 4)\n    p = q + 8;\n  else\n  {\n    int offset;\n    offset = (int) ReadProfileLong(endian, q + 8);\n    if (((size_t) (offset + number_bytes)) > length)\n      continue;\n    p = (unsigned char *) (exif + offset);\n  }\n  switch (tag_value)\n  {\n    case 0x011a:\n    {\n      (void) WriteProfileLong(endian, (size_t) (image->x_resolution + 0.5), p);\n      (void) WriteProfileLong(endian, 1UL, p + 4);\n      break;\n    }\n\n    case 0x011b:\n    {\n      (void) WriteProfileLong(endian, (size_t) (image->y_resolution + 0.5), p);\n      (void) WriteProfileLong(endian, 1UL, p + 4);\n      break;\n    }\n\n    case 0x0112:\n    {\n      (void) WriteProfileShort(endian, (unsigned short) image->orientation, p);\n      break;\n    }\n\n    case 0x0128:\n    {\n      (void) WriteProfileShort(endian, (unsigned short) (image->units + 1), p);\n      break;\n    }\n\n    default:\n      break;\n\n  }\n\n  if ((tag_value == 0x8769) || (tag_value == 0xa005))\n  {\n    size_t offset;\n    offset = (size_t) ReadProfileLong(endian, p);\n    if ((offset < length) && (level < (16 - 2)))\n    {\n      directory_stack[level].directory = directory;\n      entry++;\n      directory_stack[level].entry = entry;\n      level++;\n      directory_stack[level].directory = exif + offset;\n      directory_stack[level].entry = 0;\n      level++;\n      if (((directory + 2) + (12 * number_entries)) > (exif + length))\n        break;\n      offset = (size_t) ReadProfileLong(endian, (directory + 2) + (12 * number_entries));\n      if (((offset != 0) && (offset < length)) && (level < (16 - 2)))\n      {\n        directory_stack[level].directory = exif + offset;\n        directory_stack[level].entry = 0;\n        level++;\n      }\n    }\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_profile/4"}
{"code": "for (i = (ssize_t) depth; i > 0L;)\n{\n  quantum_bits = (size_t) i;\n  if (quantum_bits > quantum_state->bits)\n    quantum_bits = quantum_state->bits;\n  i -= (ssize_t) quantum_bits;\n  if (quantum_state->bits == 8UL)\n    *pixels = '\\0';\n  quantum_state->bits -= quantum_bits;\n  *pixels |= ((pixel >> i) & (~((~0UL) << quantum_bits))) << quantum_state->bits;\n  if (quantum_state->bits == 0UL)\n  {\n    pixels++;\n    quantum_state->bits = 8UL;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/0"}
{"code": "for (i = (ssize_t) depth; i > 0;)\n{\n  quantum_bits = (size_t) i;\n  if (quantum_bits > quantum_state->bits)\n    quantum_bits = quantum_state->bits;\n  quantum_state->pixel |= ((pixel >> (depth - i)) & quantum_state->mask[quantum_bits]) << (32U - quantum_state->bits);\n  i -= (ssize_t) quantum_bits;\n  quantum_state->bits -= quantum_bits;\n  if (quantum_state->bits == 0U)\n  {\n    pixels = PopLongPixel(quantum_state->endian, quantum_state->pixel, pixels);\n    quantum_state->pixel = 0U;\n    quantum_state->bits = 32U;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/1"}
{"code": "for (x = 0; x < ((ssize_t) image->columns); x++)\n{\n  alpha = QuantumScale * GetPixelAlpha(q);\n  SetPixelRed(q, ClampToQuantum(alpha * GetPixelRed(q)));\n  SetPixelGreen(q, ClampToQuantum(alpha * GetPixelGreen(q)));\n  SetPixelBlue(q, ClampToQuantum(alpha * GetPixelBlue(q)));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/2"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q->opacity = (Quantum) GetPixelAlpha(q);\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/3"}
{"code": "for (x = ((ssize_t) number_pixels) - 7; x > 0; x -= 8)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q = (pixel & 0x01) << 7;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 6;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 5;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 4;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 3;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 2;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 1;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 0;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/4"}
{"code": "for (bit = 7; bit >= ((ssize_t) (8 - (number_pixels % 8))); bit--)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << ((unsigned char) bit);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/5"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 1)); x += 2)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q = (pixel & 0xf) << 4;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0xf) << 0;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/6"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopCharPixel((unsigned char) GetPixelIndex(indexes + x), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/7"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopShortPixel(endian, SinglePrecisionToHalf(QuantumScale * GetPixelIndex(indexes + x)), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/8"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopShortPixel(endian, (unsigned short) GetPixelIndex(indexes + x), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/9"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelIndex(indexes + x), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/10"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopLongPixel(endian, (unsigned int) GetPixelIndex(indexes + x), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/11"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelIndex(indexes + x), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/12"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, GetPixelIndex(indexes + x), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/13"}
{"code": "for (x = ((ssize_t) number_pixels) - 3; x > 0; x -= 4)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q = (pixel & 0x01) << 7;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == ((Quantum) TransparentOpacity)) ? (1) : (0));\n  *q |= (pixel & 0x01) << 6;\n  p++;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 5;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == ((Quantum) TransparentOpacity)) ? (1) : (0));\n  *q |= (pixel & 0x01) << 4;\n  p++;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 3;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == ((Quantum) TransparentOpacity)) ? (1) : (0));\n  *q |= (pixel & 0x01) << 2;\n  p++;\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << 1;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == ((Quantum) TransparentOpacity)) ? (1) : (0));\n  *q |= (pixel & 0x01) << 0;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/14"}
{"code": "for (bit = 3; bit >= ((ssize_t) (4 - (number_pixels % 4))); bit -= 2)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q |= (pixel & 0x01) << ((unsigned char) (bit + 4));\n  pixel = (unsigned char) ((GetPixelOpacity(p) == ((Quantum) TransparentOpacity)) ? (1) : (0));\n  *q |= (pixel & 0x01) << ((unsigned char) ((bit + 4) - 1));\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/15"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned char) (*(indexes++));\n  *q = (pixel & 0xf) << 4;\n  pixel = (unsigned char) (((16 * QuantumScale) * ((Quantum) (QuantumRange - GetPixelOpacity(p)))) + 0.5);\n  *q |= (pixel & 0xf) << 0;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/16"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopCharPixel((unsigned char) GetPixelIndex(indexes + x), q);\n  pixel = ScaleQuantumToChar((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/17"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopShortPixel(endian, (unsigned short) GetPixelIndex(indexes + x), q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/18"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopShortPixel(endian, (unsigned short) GetPixelIndex(indexes + x), q);\n  pixel = ScaleQuantumToShort((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/19"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  q = PopFloatPixel(&quantum_state, (float) GetPixelIndex(indexes + x), q);\n  pixel = (float) GetPixelAlpha(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/20"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopLongPixel(endian, (unsigned int) GetPixelIndex(indexes + x), q);\n  pixel = ScaleQuantumToLong((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/21"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  double pixel;\n  q = PopDoublePixel(&quantum_state, (double) GetPixelIndex(indexes + x), q);\n  pixel = (double) GetPixelAlpha(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/22"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, GetPixelIndex(indexes + x), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelAlpha(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/23"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)), q);\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)), q);\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/24"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned int) (((ScaleQuantumToAny(GetPixelRed(p), range) << 22) | (ScaleQuantumToAny(GetPixelGreen(p), range) << 12)) | (ScaleQuantumToAny(GetPixelBlue(p), range) << 2));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/25"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/26"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/27"}
{"code": "for (x = 0; x < ((ssize_t) ((3 * number_pixels) - 1)); x += 2)\n{\n  switch (x % 3)\n  {\n    default:\n\n    case 0:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n      break;\n    }\n\n    case 1:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n      break;\n    }\n\n    case 2:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n      p++;\n      break;\n    }\n\n  }\n\n  q = PopShortPixel(endian, (unsigned short) (pixel << 4), q);\n  switch ((x + 1) % 3)\n  {\n    default:\n\n    case 0:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n      break;\n    }\n\n    case 1:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n      break;\n    }\n\n    case 2:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n      p++;\n      break;\n    }\n\n  }\n\n  q = PopShortPixel(endian, (unsigned short) (pixel << 4), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/28"}
{"code": "for (bit = 0; bit < ((ssize_t) ((3 * number_pixels) % 2)); bit++)\n{\n  switch ((x + bit) % 3)\n  {\n    default:\n\n    case 0:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n      break;\n    }\n\n    case 1:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n      break;\n    }\n\n    case 2:\n    {\n      pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n      p++;\n      break;\n    }\n\n  }\n\n  q = PopShortPixel(endian, (unsigned short) (pixel << 4), q);\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/29"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/30"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/31"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelRed(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelGreen(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelBlue(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/32"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/33"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelRed(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelGreen(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelBlue(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/34"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/35"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelBlue(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelGreen(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelRed(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar((Quantum) GetPixelAlpha(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/36"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  for (i = 0; i < 4; i++)\n  {\n    switch (i)\n    {\n      case 0:\n        quantum = GetPixelRed(p);\n        break;\n\n      case 1:\n        quantum = GetPixelGreen(p);\n        break;\n\n      case 2:\n        quantum = GetPixelBlue(p);\n        break;\n\n      case 3:\n        quantum = (Quantum) (QuantumRange - GetPixelOpacity(p));\n        break;\n\n    }\n\n    switch (n % 3)\n    {\n      case 0:\n      {\n        pixel |= (size_t) (ScaleQuantumToAny((Quantum) quantum, range) << 22);\n        break;\n      }\n\n      case 1:\n      {\n        pixel |= (size_t) (ScaleQuantumToAny((Quantum) quantum, range) << 12);\n        break;\n      }\n\n      case 2:\n      {\n        pixel |= (size_t) (ScaleQuantumToAny((Quantum) quantum, range) << 2);\n        q = PopLongPixel(endian, pixel, q);\n        pixel = 0;\n        break;\n      }\n\n    }\n\n    n++;\n  }\n\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/37"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny((Quantum) (QuantumRange - GetPixelOpacity(p)), range);\n  q = PopQuantumLongPixel(&quantum_state, quantum_info->depth, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/38"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelRed(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelGreen(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny(GetPixelBlue(p), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  pixel = (unsigned int) ScaleQuantumToAny((Quantum) (QuantumRange - GetPixelOpacity(p)), range);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/39"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/40"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort((Quantum) GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/41"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  q = PopFloatPixel(&quantum_state, (float) GetPixelRed(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelGreen(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelBlue(p), q);\n  pixel = (float) GetPixelAlpha(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/42"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong((Quantum) GetPixelAlpha(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/43"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelRed(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelGreen(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelBlue(p), q);\n  pixel = (double) GetPixelAlpha(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/44"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelAlpha(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/45"}
{"code": "for (x = ((ssize_t) number_pixels) - 7; x > 0; x -= 8)\n{\n  *q = '\\0';\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 7;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 6;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 5;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 4;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 3;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 2;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 1;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << 0;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/46"}
{"code": "for (bit = 7; bit >= ((ssize_t) (8 - (number_pixels % 8))); bit--)\n{\n  *q |= ((PixelIntensityToQuantum(p) < threshold) ? (black) : (white)) << bit;\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/47"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 1)); x += 2)\n{\n  pixel = ScaleQuantumToChar(PixelIntensityToQuantum(p));\n  *q = ((pixel >> 4) & 0xf) << 4;\n  p++;\n  pixel = ScaleQuantumToChar(PixelIntensityToQuantum(p));\n  *q |= pixel >> 4;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/48"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(PixelIntensityToQuantum(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/49"}
{"code": "for (x = 0; x < ((ssize_t) (number_pixels - 2)); x += 3)\n{\n  pixel = (unsigned int) (((ScaleQuantumToAny(PixelIntensityToQuantum(p + 2), range) << 22) | (ScaleQuantumToAny(PixelIntensityToQuantum(p + 1), range) << 12)) | (ScaleQuantumToAny(PixelIntensityToQuantum(p + 0), range) << 2));\n  q = PopLongPixel(endian, pixel, q);\n  p += 3;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/50"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(PixelIntensityToQuantum(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/51"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(PixelIntensityToQuantum(p));\n  q = PopShortPixel(endian, (unsigned short) (pixel >> 4), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/52"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * PixelIntensityToQuantum(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/53"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(PixelIntensityToQuantum(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/54"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  pixel = (float) PixelIntensityToQuantum(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/55"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(PixelIntensityToQuantum(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/56"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  double pixel;\n  pixel = (double) PixelIntensityToQuantum(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/57"}
{"code": "for (x = ((ssize_t) number_pixels) - 3; x > 0; x -= 4)\n{\n  *q = '\\0';\n  *q |= ((PixelIntensityToQuantum(p) > threshold) ? (black) : (white)) << 7;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == OpaqueOpacity) ? (0x00) : (0x01));\n  *q |= ((((int) pixel) != 0) ? (0x00) : (0x01)) << 6;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) > threshold) ? (black) : (white)) << 5;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == OpaqueOpacity) ? (0x00) : (0x01));\n  *q |= ((((int) pixel) != 0) ? (0x00) : (0x01)) << 4;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) > threshold) ? (black) : (white)) << 3;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == OpaqueOpacity) ? (0x00) : (0x01));\n  *q |= ((((int) pixel) != 0) ? (0x00) : (0x01)) << 2;\n  p++;\n  *q |= ((PixelIntensityToQuantum(p) > threshold) ? (black) : (white)) << 1;\n  pixel = (unsigned char) ((GetPixelOpacity(p) == OpaqueOpacity) ? (0x00) : (0x01));\n  *q |= ((((int) pixel) != 0) ? (0x00) : (0x01)) << 0;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/58"}
{"code": "for (bit = 0; bit <= ((ssize_t) (number_pixels % 4)); bit += 2)\n{\n  *q |= ((PixelIntensityToQuantum(p) > threshold) ? (black) : (white)) << (7 - bit);\n  pixel = (unsigned char) ((GetPixelOpacity(p) == OpaqueOpacity) ? (0x00) : (0x01));\n  *q |= ((((int) pixel) != 0) ? (0x00) : (0x01)) << ((unsigned char) ((7 - bit) - 1));\n  p++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/59"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(PixelIntensityToQuantum(p));\n  *q = ((pixel >> 4) & 0xf) << 4;\n  pixel = (unsigned char) (((16 * QuantumScale) * ((Quantum) (QuantumRange - GetPixelOpacity(p)))) + 0.5);\n  *q |= pixel & 0xf;\n  p++;\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/60"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(PixelIntensityToQuantum(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/61"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * PixelIntensityToQuantum(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/62"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(PixelIntensityToQuantum(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/63"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  pixel = (float) PixelIntensityToQuantum(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  pixel = (float) GetPixelAlpha(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/64"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(PixelIntensityToQuantum(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/65"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  double pixel;\n  pixel = (double) PixelIntensityToQuantum(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  pixel = (double) GetPixelAlpha(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/66"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(PixelIntensityToQuantum(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelAlpha(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/67"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelRed(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/68"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/69"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/70"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelRed(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/71"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/72"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelRed(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/73"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/74"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelGreen(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/75"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/76"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/77"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelGreen(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/78"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/79"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelGreen(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/80"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/81"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelBlue(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/82"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/83"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/84"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelBlue(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/85"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/86"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelBlue(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/87"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/88"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/89"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/90"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/91"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  pixel = (float) GetPixelAlpha(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/92"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/93"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  double pixel;\n  pixel = (double) GetPixelAlpha(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/94"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelAlpha(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/95"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelOpacity(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/96"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelOpacity(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/97"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelOpacity(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/98"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelOpacity(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/99"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelOpacity(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/100"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelOpacity(p), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/101"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelOpacity(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/102"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelIndex(indexes + x));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/103"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/104"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/105"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelIndex(indexes + x));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/106"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelIndex(indexes + x), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/107"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)), q);\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)), q);\n  q = PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/108"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/109"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/110"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/111"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelRed(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelGreen(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelBlue(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar((Quantum) GetPixelAlpha(p));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/112"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/113"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort((Quantum) GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/114"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong((Quantum) GetPixelAlpha(p));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/115"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny((Quantum) GetPixelAlpha(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/116"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelRed(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelGreen(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelBlue(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelIndex(indexes + x));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/117"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/118"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/119"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopFloatPixel(&quantum_state, (float) GetPixelRed(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelGreen(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelBlue(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelIndex(indexes + x), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/120"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelIndex(indexes + x));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/121"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelRed(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelGreen(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelBlue(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelIndex(indexes + x), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/122"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelIndex(indexes + x), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/123"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToChar(GetPixelRed(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelGreen(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelBlue(p));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar(GetPixelIndex(indexes + x));\n  q = PopCharPixel(pixel, q);\n  pixel = ScaleQuantumToChar((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopCharPixel(pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/124"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = SinglePrecisionToHalf(QuantumScale * GetPixelAlpha(p));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/125"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToShort(GetPixelRed(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelGreen(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelBlue(p));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort(GetPixelIndex(indexes + x));\n  q = PopShortPixel(endian, pixel, q);\n  pixel = ScaleQuantumToShort((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopShortPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/126"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  float pixel;\n  q = PopFloatPixel(&quantum_state, (float) GetPixelRed(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelGreen(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelBlue(p), q);\n  q = PopFloatPixel(&quantum_state, (float) GetPixelIndex(indexes + x), q);\n  pixel = (float) GetPixelAlpha(p);\n  q = PopFloatPixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/127"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  pixel = ScaleQuantumToLong(GetPixelRed(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelGreen(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelBlue(p));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong(GetPixelIndex(indexes + x));\n  q = PopLongPixel(endian, pixel, q);\n  pixel = ScaleQuantumToLong((Quantum) (QuantumRange - GetPixelOpacity(p)));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/128"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopDoublePixel(&quantum_state, (double) GetPixelRed(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelGreen(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelBlue(p), q);\n  q = PopDoublePixel(&quantum_state, (double) GetPixelIndex(indexes + x), q);\n  pixel = (double) GetPixelAlpha(p);\n  q = PopDoublePixel(&quantum_state, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/129"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelRed(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelGreen(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelBlue(p), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelIndex(indexes + x), range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(GetPixelOpacity(p), range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/130"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x += 2)\n{\n  for (i = 0; i < 4; i++)\n  {\n    switch (n % 3)\n    {\n      case 0:\n      {\n        quantum = GetPixelRed(p);\n        break;\n      }\n\n      case 1:\n      {\n        quantum = GetPixelGreen(p);\n        break;\n      }\n\n      case 2:\n      {\n        quantum = GetPixelBlue(p);\n        break;\n      }\n\n    }\n\n    cbcr[i] = (Quantum) quantum;\n    n++;\n  }\n\n  pixel = (unsigned int) (((((size_t) cbcr[1]) << 22) | (((size_t) cbcr[0]) << 12)) | (((size_t) cbcr[2]) << 2));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  pixel = (unsigned int) (((((size_t) cbcr[3]) << 22) | (((size_t) cbcr[0]) << 12)) | (((size_t) cbcr[2]) << 2));\n  q = PopLongPixel(endian, pixel, q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/131"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x += 2)\n{\n  for (i = 0; i < 4; i++)\n  {\n    switch (n % 3)\n    {\n      case 0:\n      {\n        quantum = GetPixelRed(p);\n        break;\n      }\n\n      case 1:\n      {\n        quantum = GetPixelGreen(p);\n        break;\n      }\n\n      case 2:\n      {\n        quantum = GetPixelBlue(p);\n        break;\n      }\n\n    }\n\n    cbcr[i] = (Quantum) quantum;\n    n++;\n  }\n\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[1], range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[0], range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[2], range), q);\n  p++;\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[3], range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[0], range), q);\n  q = PopQuantumPixel(&quantum_state, quantum_info->depth, ScaleQuantumToAny(cbcr[2], range), q);\n  p++;\n  q += quantum_info->pad;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/132"}
{"code": "for (x = 0; x < ((ssize_t) number_pixels); x++)\n{\n  SetPixelOpacity(q, (Quantum) GetPixelAlpha(q));\n  q++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_quantum-export/133"}
{"code": "for (v = v1; v <= v2; v++)\n{\n  u = (ssize_t) ceil(u1);\n  u1 += resample_filter->slope;\n  U = ((double) u) - u0;\n  V = ((double) v) - v0;\n  Q = (((resample_filter->A * U) + (resample_filter->B * V)) * U) + ((resample_filter->C * V) * V);\n  DQ = (resample_filter->A * ((2.0 * U) + 1)) + (resample_filter->B * V);\n  pixels = GetCacheViewVirtualPixels(resample_filter->view, u, v, (size_t) uw, 1, resample_filter->exception);\n  if (pixels == ((const PixelPacket *) 0))\n    return MagickFalse;\n  indexes = GetCacheViewVirtualIndexQueue(resample_filter->view);\n  for (u = 0; u < uw; u++)\n  {\n    if (Q < ((double) 1024))\n    {\n      weight = resample_filter->filter_lut[(int) Q];\n      pixel->opacity += weight * pixels->opacity;\n      divisor_m += weight;\n      if (pixel->matte != MagickFalse)\n        weight *= QuantumScale * ((MagickRealType) (QuantumRange - pixels->opacity));\n      pixel->red += weight * pixels->red;\n      pixel->green += weight * pixels->green;\n      pixel->blue += weight * pixels->blue;\n      if (pixel->colorspace == CMYKColorspace)\n        pixel->index += weight * (*indexes);\n      divisor_c += weight;\n      hit++;\n    }\n    pixels++;\n    indexes++;\n    Q += DQ;\n    DQ += DDQ;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_resample/0"}
{"code": "for (Q = 0; Q < 1024; Q++)\n  resample_filter->filter_lut[Q] = (double) GetResizeFilterWeight(resize_filter, sqrt((double) Q) * r_scale);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_resample/1"}
{"code": "for (Q = 0; Q < 1024; Q++)\n  printf(\"%8.*g %.*g\\n\", GetMagickPrecision(), sqrt((double) Q) * r_scale, GetMagickPrecision(), resample_filter->filter_lut[Q]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_resample/2"}
{"code": "for (q = source; length != 0; length -= count)\n{\n  count = (ssize_t) read(file, q, length);\n  if (count <= 0)\n  {\n    count = 0;\n    if (errno == EINTR)\n      continue;\n    return -1;\n  }\n  q += count;\n  offset += count;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_random/0"}
{"code": "for (i = 0; environ[i] != ((char *) 0); i++)\n{\n  SetStringInfoLength(chaos, strlen(environ[i]));\n  SetStringInfoDatum(chaos, (unsigned char *) environ[i]);\n  ConcatenateStringInfo(entropy, chaos);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_random/1"}
{"code": "for (i = (ssize_t) (GetStringInfoLength(nonce) - 1); i != 0; i--)\n{\n  datum[i]++;\n  if (datum[i] != 0)\n    return;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_random/2"}
{"code": "for (p = key; (i != 0) && (random_info->i != 0); i--)\n{\n  *(p++) = datum[random_info->i];\n  random_info->i++;\n  if (random_info->i == GetSignatureDigestsize(signature_info))\n    random_info->i = 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_random/3"}
{"code": "for (i = 0; i < ((ssize_t) GetStringInfoLength(profile)); i += (ssize_t) length)\n{\n  length = 1;\n  if (((ssize_t) GetStringInfoDatum(profile)[i]) != 0x1c)\n    continue;\n  length = (size_t) (GetStringInfoDatum(profile)[i + 3] << 8);\n  length |= GetStringInfoDatum(profile)[i + 4];\n  if ((((long) GetStringInfoDatum(profile)[i + 1]) == dataset) && (((long) GetStringInfoDatum(profile)[i + 2]) == record))\n  {\n    message = (char *) 0;\n    if ((~length) >= 1)\n      message = (char *) AcquireQuantumMemory(length + 1UL, sizeof(*message));\n    if (message != ((char *) 0))\n    {\n      (void) CopyMagickString(message, (((char *) GetStringInfoDatum(profile)) + i) + 5, length + 1);\n      (void) ConcatenateString(&attribute, message);\n      (void) ConcatenateString(&attribute, \";\");\n      message = DestroyString(message);\n    }\n  }\n  i += 5;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  c = (int) (*((*p)++));\n  (*length)--;\n  buffer[i] = (unsigned char) c;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/1"}
{"code": "for (i = 0; i < 2; i++)\n{\n  c = (int) (*((*p)++));\n  (*length)--;\n  buffer[i] = (unsigned char) c;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/2"}
{"code": "for (i = 0; i < ((ssize_t) count); i++)\n  resource[i] = (char) ReadPropertyByte(&info, &length);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/3"}
{"code": "for (i = ((ssize_t) n) - 1L; i >= 0; i--)\n{\n  c = *(property++);\n  tag <<= 4;\n  if ((c >= '0') && (c <= '9'))\n    tag |= c - '0';\n  else\n    if ((c >= 'A') && (c <= 'F'))\n    tag |= c - ('A' - 10);\n  else\n    if ((c >= 'a') && (c <= 'f'))\n    tag |= c - ('a' - 10);\n  else\n    return MagickFalse;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/4"}
{"code": "for (i = 0;; i++)\n{\n  if (EXIFTag[i].tag == 0)\n    break;\n  if (LocaleCompare(EXIFTag[i].description, property) == 0)\n  {\n    tag = (size_t) EXIFTag[i].tag;\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/5"}
{"code": "for (; entry < number_entries; entry++)\n{\n  unsigned char *p;\n  unsigned char *q;\n  size_t format;\n  size_t number_bytes;\n  ssize_t components;\n  q = (unsigned char *) ((directory + 2) + (12 * entry));\n  tag_value = (ssize_t) (ReadPropertyShort(endian, q) + tag_offset);\n  format = (size_t) ReadPropertyShort(endian, q + 2);\n  if (format >= ((sizeof(tag_bytes)) / (sizeof(*tag_bytes))))\n    break;\n  components = (ssize_t) ((int) ReadPropertyLong(endian, q + 4));\n  number_bytes = ((size_t) components) * tag_bytes[format];\n  if (number_bytes <= 4)\n    p = q + 8;\n  else\n  {\n    ssize_t offset;\n    offset = (ssize_t) ((int) ReadPropertyLong(endian, q + 8));\n    if (((size_t) (offset + number_bytes)) > length)\n      continue;\n    p = (unsigned char *) (exif + offset);\n  }\n  if ((all != 0) || (tag == ((size_t) tag_value)))\n  {\n    char buffer[MaxTextExtent];\n    char *value;\n    switch (format)\n    {\n      case 1:\n\n      case 7:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g, \", (double) (*((unsigned char *) p1)));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 1;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 6:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g, \", (double) (*((signed char *) p1)));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 1;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 8:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%hd, \", ReadPropertyShort(endian, p1));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 2;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 3:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%hu, \", ReadPropertyShort(endian, p1));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 2;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 4:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g, \", (double) ReadPropertyLong(endian, p1));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 4;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 9:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g, \", (double) ReadPropertyLong(endian, p1));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 4;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 5:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g/%.20g, \", (double) ReadPropertyLong(endian, p1), (double) ReadPropertyLong(endian, p1 + 4));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 8;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 10:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%.20g/%.20g, \", (double) ReadPropertyLong(endian, p1), (double) ReadPropertyLong(endian, p1 + 4));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 8;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 11:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%f, \", (double) (*((float *) p1)));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 4;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      case 12:\n      {\n        {\n          ssize_t component;\n          size_t length;\n          unsigned char *p1;\n          length = 0;\n          p1 = p;\n          for (component = 0; component < components; component++)\n          {\n            length += FormatLocaleString(buffer + length, MaxTextExtent - length, \"%f, \", *((double *) p1));\n            if (length >= (MaxTextExtent - 1))\n              length = MaxTextExtent - 1;\n            p1 += 8;\n          }\n\n          if (length > 1)\n            buffer[length - 2] = '\\0';\n          value = AcquireString(buffer);\n        }\n        ;\n        break;\n      }\n\n      default:\n\n      case 2:\n      {\n        value = (char *) 0;\n        if ((~(1UL * number_bytes)) >= 1)\n          value = (char *) AcquireQuantumMemory(((size_t) number_bytes) + 1UL, sizeof(*value));\n        if (value != ((char *) 0))\n        {\n          ssize_t i;\n          for (i = 0; i < ((ssize_t) number_bytes); i++)\n          {\n            value[i] = '.';\n            if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n              value[i] = (char) p[i];\n          }\n\n          value[i] = '\\0';\n        }\n        break;\n      }\n\n    }\n\n    if (value != ((char *) 0))\n    {\n      char key[MaxTextExtent];\n      const char *p;\n      (void) CopyMagickString(key, property, MaxTextExtent);\n      switch (all)\n      {\n        case 1:\n        {\n          const char *description;\n          ssize_t i;\n          description = \"unknown\";\n          for (i = 0;; i++)\n          {\n            if (EXIFTag[i].tag == 0)\n              break;\n            if (((ssize_t) EXIFTag[i].tag) == tag_value)\n            {\n              description = EXIFTag[i].description;\n              break;\n            }\n          }\n\n          (void) FormatLocaleString(key, MaxTextExtent, \"%s\", description);\n          break;\n        }\n\n        case 2:\n        {\n          if (tag_value < 0x10000)\n            (void) FormatLocaleString(key, MaxTextExtent, \"#%04lx\", (unsigned long) tag_value);\n          else\n            if (tag_value < 0x20000)\n            (void) FormatLocaleString(key, MaxTextExtent, \"@%04lx\", (unsigned long) (tag_value & 0xffff));\n          else\n            (void) FormatLocaleString(key, MaxTextExtent, \"unknown\");\n          break;\n        }\n\n      }\n\n      p = (const char *) 0;\n      if (image->properties != ((void *) 0))\n        p = (const char *) GetValueFromSplayTree((SplayTreeInfo *) image->properties, key);\n      if (p == ((const char *) 0))\n        (void) SetImageProperty((Image *) image, key, value);\n      value = DestroyString(value);\n      status = MagickTrue;\n    }\n  }\n  if (((tag_value == 0x8769) || (tag_value == 0xa005)) || (tag_value == 0x8825))\n  {\n    size_t offset;\n    offset = (size_t) ReadPropertyLong(endian, p);\n    if ((offset < length) && (level < (16 - 2)))\n    {\n      size_t tag_offset1;\n      tag_offset1 = (tag_value == 0x8825) ? (0x10000UL) : (0UL);\n      directory_stack[level].directory = directory;\n      entry++;\n      directory_stack[level].entry = entry;\n      directory_stack[level].offset = tag_offset;\n      level++;\n      directory_stack[level].directory = exif + offset;\n      directory_stack[level].offset = tag_offset1;\n      directory_stack[level].entry = 0;\n      level++;\n      if (((directory + 2) + (12 * number_entries)) > (exif + length))\n        break;\n      offset = (size_t) ReadPropertyLong(endian, (directory + 2) + (12 * number_entries));\n      if (((offset != 0) && (offset < length)) && (level < (16 - 2)))\n      {\n        directory_stack[level].directory = exif + offset;\n        directory_stack[level].entry = 0;\n        directory_stack[level].offset = tag_offset1;\n        level++;\n      }\n    }\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/6"}
{"code": "for (p = xmp_profile; (*p) != '\\0'; p++)\n  if (((*p) == '<') && ((*(p + 1)) == 'x'))\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/7"}
{"code": "for (i = 0; i < 3; i++)\n{\n  size_t xx;\n  size_t yy;\n  yy = ReadPropertyMSBLong(&blob, &length);\n  xx = ReadPropertyMSBLong(&blob, &length);\n  x = (ssize_t) xx;\n  if (xx > 2147483647)\n    x = (((ssize_t) xx) - 4294967295U) - 1;\n  y = (ssize_t) yy;\n  if (yy > 2147483647)\n    y = (((ssize_t) yy) - 4294967295U) - 1;\n  point[i].x = (((double) x) / 4096) / 4096;\n  point[i].y = 1.0 - ((((double) y) / 4096) / 4096);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/8"}
{"code": "for (i = 0; i < 3; i++)\n{\n  first[i] = point[i];\n  last[i] = point[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/9"}
{"code": "for (i = 0; i < 3; i++)\n  last[i] = point[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/10"}
{"code": "for (i = 0; i < 3; i++)\n{\n  size_t xx;\n  size_t yy;\n  yy = ReadPropertyMSBLong(&blob, &length);\n  xx = ReadPropertyMSBLong(&blob, &length);\n  x = (ssize_t) xx;\n  if (xx > 2147483647)\n    x = (((ssize_t) xx) - 4294967295U) - 1;\n  y = (ssize_t) yy;\n  if (yy > 2147483647)\n    y = (((ssize_t) yy) - 4294967295U) - 1;\n  point[i].x = ((((double) x) * columns) / 4096) / 4096;\n  point[i].y = ((((double) y) * rows) / 4096) / 4096;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/11"}
{"code": "for (q = interpret_text; (*p) != '\\0'; p++)\n{\n  *q = '\\0';\n  if (((size_t) ((q - interpret_text) + MaxTextExtent)) >= extent)\n  {\n    extent += MaxTextExtent;\n    interpret_text = (char *) ResizeQuantumMemory(interpret_text, (extent + MaxTextExtent) + 1, sizeof(*interpret_text));\n    if (interpret_text == ((char *) 0))\n      break;\n    q = interpret_text + strlen(interpret_text);\n  }\n  if (((*p) == '\\\\') && ((*(p + 1)) == 'r'))\n  {\n    *(q++) = '\\r';\n    p++;\n    continue;\n  }\n  if (((*p) == '\\\\') && ((*(p + 1)) == 'n'))\n  {\n    *(q++) = '\\n';\n    p++;\n    continue;\n  }\n  if ((*p) == '\\\\')\n  {\n    p++;\n    *(q++) = *p;\n    continue;\n  }\n  if ((*p) != '%')\n  {\n    *(q++) = *p;\n    continue;\n  }\n  p++;\n  switch (*p)\n  {\n    case 'b':\n    {\n      char format[MaxTextExtent];\n      (void) FormatLocaleString(format, MaxTextExtent, \"%.20g\", (double) ((MagickOffsetType) image->extent));\n      if (image->extent != ((MagickSizeType) ((size_t) image->extent)))\n        (void) FormatMagickSize(image->extent, MagickFalse, format);\n      q += ConcatenateMagickString(q, format, extent);\n      q += ConcatenateMagickString(q, \"B\", extent);\n      break;\n    }\n\n    case 'c':\n    {\n      value = GetImageProperty(image, \"comment\");\n      if (value == ((const char *) 0))\n        break;\n      length = strlen(value);\n      if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n      {\n        extent += length;\n        interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n        if (interpret_text == ((char *) 0))\n          break;\n        q = interpret_text + strlen(interpret_text);\n      }\n      (void) CopyMagickString(q, value, extent);\n      q += length;\n      break;\n    }\n\n    case 'd':\n\n    case 'e':\n\n    case 'f':\n\n    case 't':\n    {\n      if ((*image->magick_filename) == '\\0')\n        break;\n      switch (*p)\n      {\n        case 'd':\n        {\n          GetPathComponent(image->magick_filename, HeadPath, filename);\n          q += CopyMagickString(q, filename, extent);\n          break;\n        }\n\n        case 'e':\n        {\n          GetPathComponent(image->magick_filename, ExtensionPath, filename);\n          q += CopyMagickString(q, filename, extent);\n          break;\n        }\n\n        case 'f':\n        {\n          GetPathComponent(image->magick_filename, TailPath, filename);\n          q += CopyMagickString(q, filename, extent);\n          break;\n        }\n\n        case 't':\n        {\n          GetPathComponent(image->magick_filename, BasePath, filename);\n          q += CopyMagickString(q, filename, extent);\n          break;\n        }\n\n      }\n\n      break;\n    }\n\n    case 'g':\n    {\n      q += FormatLocaleString(q, extent, \"%.20gx%.20g%+.20g%+.20g\", (double) image->page.width, (double) image->page.height, (double) image->page.x, (double) image->page.y);\n      break;\n    }\n\n    case 'h':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) ((image->rows != 0) ? (image->rows) : (image->magick_rows)));\n      break;\n    }\n\n    case 'i':\n    {\n      q += CopyMagickString(q, image->filename, extent);\n      break;\n    }\n\n    case 'k':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) GetNumberColors(image, (FILE *) 0, &image->exception));\n      break;\n    }\n\n    case 'l':\n    {\n      value = GetImageProperty(image, \"label\");\n      if (value == ((const char *) 0))\n        break;\n      length = strlen(value);\n      if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n      {\n        extent += length;\n        interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n        if (interpret_text == ((char *) 0))\n          break;\n        q = interpret_text + strlen(interpret_text);\n      }\n      q += CopyMagickString(q, value, extent);\n      break;\n    }\n\n    case 'm':\n    {\n      q += CopyMagickString(q, image->magick, extent);\n      break;\n    }\n\n    case 'M':\n    {\n      q += CopyMagickString(q, image->magick_filename, extent);\n      break;\n    }\n\n    case 'n':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) GetImageListLength(image));\n      break;\n    }\n\n    case 'o':\n    {\n      q += CopyMagickString(q, image_info->filename, extent);\n      break;\n    }\n\n    case 'p':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) GetImageIndexInList(image));\n      break;\n    }\n\n    case 'q':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n\n    case 'r':\n    {\n      ColorspaceType colorspace;\n      colorspace = image->colorspace;\n      if (IsGrayImage(image, &image->exception) != MagickFalse)\n        colorspace = GRAYColorspace;\n      q += FormatLocaleString(q, extent, \"%s%s%s\", CommandOptionToMnemonic(MagickClassOptions, (ssize_t) image->storage_class), CommandOptionToMnemonic(MagickColorspaceOptions, (ssize_t) colorspace), (image->matte != MagickFalse) ? (\"Matte\") : (\"\"));\n      break;\n    }\n\n    case 's':\n    {\n      if (image_info->number_scenes == 0)\n        q += FormatLocaleString(q, extent, \"%.20g\", (double) image->scene);\n      else\n        q += FormatLocaleString(q, extent, \"%.20g\", (double) image_info->scene);\n      break;\n    }\n\n    case 'u':\n    {\n      (void) CopyMagickString(filename, image_info->unique, extent);\n      q += CopyMagickString(q, filename, extent);\n      break;\n    }\n\n    case 'w':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) ((image->columns != 0) ? (image->columns) : (image->magick_columns)));\n      break;\n    }\n\n    case 'x':\n    {\n      q += FormatLocaleString(q, extent, \"%g %s\", image->x_resolution, CommandOptionToMnemonic(MagickResolutionOptions, (ssize_t) image->units));\n      break;\n    }\n\n    case 'y':\n    {\n      q += FormatLocaleString(q, extent, \"%g %s\", image->y_resolution, CommandOptionToMnemonic(MagickResolutionOptions, (ssize_t) image->units));\n      break;\n    }\n\n    case 'z':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) image->depth);\n      break;\n    }\n\n    case 'A':\n    {\n      q += FormatLocaleString(q, extent, \"%s\", CommandOptionToMnemonic(MagickBooleanOptions, (ssize_t) image->matte));\n      break;\n    }\n\n    case 'C':\n    {\n      q += FormatLocaleString(q, extent, \"%s\", CommandOptionToMnemonic(MagickCompressOptions, (ssize_t) image->compression));\n      break;\n    }\n\n    case 'D':\n    {\n      q += FormatLocaleString(q, extent, \"%s\", CommandOptionToMnemonic(MagickDisposeOptions, (ssize_t) image->dispose));\n      break;\n    }\n\n    case 'G':\n    {\n      q += FormatLocaleString(q, extent, \"%.20gx%.20g\", (double) image->magick_columns, (double) image->magick_rows);\n      break;\n    }\n\n    case 'H':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) image->page.height);\n      break;\n    }\n\n    case 'O':\n    {\n      q += FormatLocaleString(q, extent, \"%+ld%+ld\", (long) image->page.x, (long) image->page.y);\n      break;\n    }\n\n    case 'P':\n    {\n      q += FormatLocaleString(q, extent, \"%.20gx%.20g\", (double) image->page.width, (double) image->page.height);\n      break;\n    }\n\n    case 'Q':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) image->quality);\n      break;\n    }\n\n    case 'S':\n    {\n      if (image_info->number_scenes == 0)\n        q += CopyMagickString(q, \"2147483647\", extent);\n      else\n        q += FormatLocaleString(q, extent, \"%.20g\", (double) (image_info->scene + image_info->number_scenes));\n      break;\n    }\n\n    case 'T':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) image->delay);\n      break;\n    }\n\n    case 'W':\n    {\n      q += FormatLocaleString(q, extent, \"%.20g\", (double) image->page.width);\n      break;\n    }\n\n    case 'X':\n    {\n      q += FormatLocaleString(q, extent, \"%+.20g\", (double) image->page.x);\n      break;\n    }\n\n    case 'Y':\n    {\n      q += FormatLocaleString(q, extent, \"%+.20g\", (double) image->page.y);\n      break;\n    }\n\n    case 'Z':\n    {\n      (void) CopyMagickString(filename, image_info->zero, extent);\n      q += CopyMagickString(q, filename, extent);\n      break;\n    }\n\n    case '[':\n    {\n      char pattern[MaxTextExtent];\n      const char *key;\n      const char *value;\n      ssize_t depth;\n      if (strchr(p, ']') == ((char *) 0))\n        break;\n      depth = 1;\n      p++;\n      for (i = 0; (i < (MaxTextExtent - 1L)) && ((*p) != '\\0'); i++)\n      {\n        if ((*p) == '[')\n          depth++;\n        if ((*p) == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[i] = *(p++);\n      }\n\n      pattern[i] = '\\0';\n      value = GetImageProperty(image, pattern);\n      if (value != ((const char *) 0))\n      {\n        length = strlen(value);\n        if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n        {\n          extent += length;\n          interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n          if (interpret_text == ((char *) 0))\n            break;\n          q = interpret_text + strlen(interpret_text);\n        }\n        (void) CopyMagickString(q, value, extent);\n        q += length;\n        break;\n      }\n      else\n        if (IsGlob(pattern) != MagickFalse)\n      {\n        ResetImagePropertyIterator(image);\n        key = GetNextImageProperty(image);\n        while (key != ((const char *) 0))\n        {\n          if (GlobExpression(key, pattern, MagickTrue) != MagickFalse)\n          {\n            value = GetImageProperty(image, key);\n            if (value != ((const char *) 0))\n            {\n              length = (strlen(key) + strlen(value)) + 2;\n              if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n              {\n                extent += length;\n                interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n                if (interpret_text == ((char *) 0))\n                  break;\n                q = interpret_text + strlen(interpret_text);\n              }\n              q += FormatLocaleString(q, extent, \"%s=%s\\n\", key, value);\n            }\n          }\n          key = GetNextImageProperty(image);\n        }\n\n      }\n      value = GetMagickProperty(image_info, image, pattern);\n      if (value != ((const char *) 0))\n      {\n        length = strlen(value);\n        if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n        {\n          extent += length;\n          interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n          if (interpret_text == ((char *) 0))\n            break;\n          q = interpret_text + strlen(interpret_text);\n        }\n        (void) CopyMagickString(q, value, extent);\n        q += length;\n        break;\n      }\n      if (image_info == ((ImageInfo *) 0))\n        break;\n      value = GetImageOption(image_info, pattern);\n      if (value != ((char *) 0))\n      {\n        length = strlen(value);\n        if (((size_t) (((q - interpret_text) + length) + 1)) >= extent)\n        {\n          extent += length;\n          interpret_text = (char *) ResizeQuantumMemory(interpret_text, extent + MaxTextExtent, sizeof(*interpret_text));\n          if (interpret_text == ((char *) 0))\n            break;\n          q = interpret_text + strlen(interpret_text);\n        }\n        (void) CopyMagickString(q, value, extent);\n        q += length;\n        break;\n      }\n      break;\n    }\n\n    case '@':\n    {\n      RectangleInfo page;\n      page = GetImageBoundingBox(image, &image->exception);\n      q += FormatLocaleString(q, MaxTextExtent, \"%.20gx%.20g%+.20g%+.20g\", (double) page.width, (double) page.height, (double) page.x, (double) page.y);\n      break;\n    }\n\n    case '#':\n    {\n      (void) SignatureImage(image);\n      value = GetImageProperty(image, \"signature\");\n      if (value == ((const char *) 0))\n        break;\n      q += CopyMagickString(q, value, extent);\n      break;\n    }\n\n    case '%':\n    {\n      *(q++) = *p;\n      break;\n    }\n\n    default:\n    {\n      *(q++) = '%';\n      *(q++) = *p;\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_property/12"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double density;\n  const IndexPacket *indexes;\n  const PixelPacket *p;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    density = ((((double) GetPixelRed(p)) + GetPixelGreen(p)) + GetPixelBlue(p)) + GetPixelIndex(indexes + x);\n    if (density > total_ink_density)\n    {\n      #pragma omp critical (MagickCore_GetImageTotalInkDensity)\n      {\n        if (density > total_ink_density)\n          total_ink_density = density;\n      }\n    }\n    p++;\n  }\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_prepress/0"}
{"code": "for (i = 0; i < ((ssize_t) number_images); i++)\n{\n  image = CloneImage(image_list[i], 0, 0, MagickTrue, exception);\n  if (image == ((Image *) 0))\n    break;\n  (void) ParseAbsoluteGeometry(\"0x0+0+0\", &image->page);\n  progress_monitor = SetImageProgressMonitor(image, (MagickProgressMonitor) 0, image->client_data);\n  flags = ParseRegionGeometry(image, montage_info->geometry, &geometry, exception);\n  thumbnail = ThumbnailImage(image, geometry.width, geometry.height, exception);\n  if (thumbnail == ((Image *) 0))\n    break;\n  image_list[i] = thumbnail;\n  (void) SetImageProgressMonitor(image, progress_monitor, image->client_data);\n  proceed = SetImageProgress(image, \"Tile/Image\", (MagickOffsetType) i, number_images);\n  if (proceed == MagickFalse)\n    break;\n  image = DestroyImage(image);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/0"}
{"code": "for (tile = 0; ((ssize_t) tile) <= i; tile++)\n  if (image_list[tile] != ((Image *) 0))\n  image_list[tile] = DestroyImage(image_list[tile]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/1"}
{"code": "for (i = 0; i < ((ssize_t) number_images); i++)\n  if (image_list[i]->scene == 0)\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/2"}
{"code": "for (i = 0; i < ((ssize_t) number_images); i++)\n{\n  if (image_list[i]->columns > extract_info.width)\n    extract_info.width = image_list[i]->columns;\n  if (image_list[i]->rows > extract_info.height)\n    extract_info.height = image_list[i]->rows;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/3"}
{"code": "for (i = 0; i < ((ssize_t) number_images); i++)\n{\n  value = GetImageProperty(image_list[i], \"label\");\n  if (value == ((const char *) 0))\n    continue;\n  if (MultilineCensus(value) > number_lines)\n    number_lines = MultilineCensus(value);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/4"}
{"code": "for (i = 0; i < ((ssize_t) images_per_page); i++)\n{\n  tiles_per_page = tiles_per_row * tiles_per_column;\n  x_offset = 0;\n  y_offset = 0;\n  if (montage_info->tile != ((char *) 0))\n    GetMontageGeometry(montage_info->tile, number_images, &x_offset, &y_offset, &sans, &sans);\n  tiles_per_page = tiles_per_row * tiles_per_column;\n  y_offset += (ssize_t) title_offset;\n  max_height = 0;\n  bounds.width = 0;\n  bounds.height = 0;\n  width = 0;\n  for (tile = 0; tile < ((ssize_t) tiles_per_page); tile++)\n  {\n    if (tile < ((ssize_t) number_images))\n    {\n      width = (concatenate != MagickFalse) ? (image_list[tile]->columns) : (extract_info.width);\n      if (image_list[tile]->rows > max_height)\n        max_height = image_list[tile]->rows;\n    }\n    x_offset += (ssize_t) (width + (2 * (extract_info.x + border_width)));\n    if (x_offset > ((ssize_t) bounds.width))\n      bounds.width = (size_t) x_offset;\n    if (((tile + 1) == ((ssize_t) tiles_per_page)) || (((tile + 1) % tiles_per_row) == 0))\n    {\n      x_offset = 0;\n      if (montage_info->tile != ((char *) 0))\n        GetMontageGeometry(montage_info->tile, number_images, &x_offset, &y, &sans, &sans);\n      height = (concatenate != MagickFalse) ? (max_height) : (extract_info.height);\n      y_offset += (ssize_t) (((height + ((extract_info.y + ((ssize_t) border_width)) * 2)) + (((metrics.ascent - metrics.descent) + 4) * number_lines)) + ((montage_info->shadow != MagickFalse) ? (4) : (0)));\n      if (y_offset > ((ssize_t) bounds.height))\n        bounds.height = (size_t) y_offset;\n      max_height = 0;\n    }\n  }\n\n  if (montage_info->shadow != MagickFalse)\n    bounds.width += 4;\n  (void) CopyMagickString(montage->filename, montage_info->filename, MaxTextExtent);\n  montage->columns = bounds.width;\n  montage->rows = bounds.height;\n  (void) SetImageBackgroundColor(montage);\n  montage->montage = AcquireString((char *) 0);\n  tile = 0;\n  extent = 1;\n  while (tile < MagickMin((ssize_t) tiles_per_page, (ssize_t) number_images))\n  {\n    extent += strlen(image_list[tile]->filename) + 1;\n    tile++;\n  }\n\n  montage->directory = (char *) AcquireQuantumMemory(extent, sizeof(*montage->directory));\n  if ((montage->montage == ((char *) 0)) || (montage->directory == ((char *) 0)))\n    ThrowImageException(ResourceLimitError, \"MemoryAllocationFailed\");\n  x_offset = 0;\n  y_offset = 0;\n  if (montage_info->tile != ((char *) 0))\n    GetMontageGeometry(montage_info->tile, number_images, &x_offset, &y_offset, &sans, &sans);\n  y_offset += (ssize_t) title_offset;\n  (void) FormatLocaleString(montage->montage, MaxTextExtent, \"%.20gx%.20g%+.20g%+.20g\", (double) (extract_info.width + ((extract_info.x + border_width) * 2)), (double) ((extract_info.height + ((extract_info.y + border_width) * 2)) + ((double) ((((metrics.ascent - metrics.descent) + 4) * number_lines) + ((montage_info->shadow != MagickFalse) ? (4) : (0))))), (double) x_offset, (double) y_offset);\n  *montage->directory = '\\0';\n  tile = 0;\n  while (tile < MagickMin((ssize_t) tiles_per_page, (ssize_t) number_images))\n  {\n    (void) ConcatenateMagickString(montage->directory, image_list[tile]->filename, extent);\n    (void) ConcatenateMagickString(montage->directory, \"\\n\", extent);\n    tile++;\n  }\n\n  progress_monitor = SetImageProgressMonitor(montage, (MagickProgressMonitor) 0, montage->client_data);\n  if (texture != ((Image *) 0))\n    (void) TextureImage(montage, texture);\n  if (montage_info->title != ((char *) 0))\n  {\n    char geometry[MaxTextExtent];\n    DrawInfo *clone_info;\n    TypeMetric metrics;\n    clone_info = CloneDrawInfo(image_info, draw_info);\n    clone_info->gravity = CenterGravity;\n    clone_info->pointsize *= 2.0;\n    (void) GetTypeMetrics(image_list[0], clone_info, &metrics);\n    (void) FormatLocaleString(geometry, MaxTextExtent, \"%.20gx%.20g%+.20g%+.20g\", (double) montage->columns, (double) (metrics.ascent - metrics.descent), 0.0, ((double) extract_info.y) + 4);\n    (void) CloneString(&clone_info->geometry, geometry);\n    (void) CloneString(&clone_info->text, title);\n    (void) AnnotateImage(montage, clone_info);\n    clone_info = DestroyDrawInfo(clone_info);\n  }\n  (void) SetImageProgressMonitor(montage, progress_monitor, montage->client_data);\n  x_offset = 0;\n  y_offset = 0;\n  if (montage_info->tile != ((char *) 0))\n    GetMontageGeometry(montage_info->tile, number_images, &x_offset, &y_offset, &sans, &sans);\n  x_offset += extract_info.x;\n  y_offset += ((ssize_t) title_offset) + extract_info.y;\n  max_height = 0;\n  status = MagickTrue;\n  for (tile = 0; tile < MagickMin((ssize_t) tiles_per_page, (ssize_t) number_images); tile++)\n  {\n    image = CloneImage(image_list[tile], 0, 0, MagickTrue, exception);\n    progress_monitor = SetImageProgressMonitor(image, (MagickProgressMonitor) 0, image->client_data);\n    width = (concatenate != MagickFalse) ? (image->columns) : (extract_info.width);\n    if (image->rows > max_height)\n      max_height = image->rows;\n    height = (concatenate != MagickFalse) ? (max_height) : (extract_info.height);\n    if (border_width != 0)\n    {\n      Image *border_image;\n      RectangleInfo border_info;\n      border_info.width = border_width;\n      border_info.height = border_width;\n      if (montage_info->frame != ((char *) 0))\n      {\n        border_info.width = ((width - image->columns) + 1) / 2;\n        border_info.height = ((height - image->rows) + 1) / 2;\n      }\n      border_image = BorderImage(image, &border_info, exception);\n      if (border_image != ((Image *) 0))\n      {\n        image = DestroyImage(image);\n        image = border_image;\n      }\n      if ((montage_info->frame != ((char *) 0)) && (image->compose == DstOutCompositeOp))\n        (void) NegateImageChannel(image, OpacityChannel, MagickFalse);\n    }\n    tile_image->columns = width;\n    tile_image->rows = height;\n    tile_image->gravity = montage_info->gravity;\n    if (image->gravity != UndefinedGravity)\n      tile_image->gravity = image->gravity;\n    (void) FormatLocaleString(tile_geometry, MaxTextExtent, \"%.20gx%.20g+0+0\", (double) image->columns, (double) image->rows);\n    flags = ParseGravityGeometry(tile_image, tile_geometry, &geometry, exception);\n    x = (ssize_t) (geometry.x + border_width);\n    y = (ssize_t) (geometry.y + border_width);\n    if ((montage_info->frame != ((char *) 0)) && (bevel_width != 0))\n    {\n      FrameInfo extract_info;\n      Image *frame_image;\n      extract_info = frame_info;\n      extract_info.width = width + (2 * frame_info.width);\n      extract_info.height = height + (2 * frame_info.height);\n      value = GetImageProperty(image, \"label\");\n      if (value != ((const char *) 0))\n        extract_info.height += (size_t) (((metrics.ascent - metrics.descent) + 4) * MultilineCensus(value));\n      frame_image = FrameImage(image, &extract_info, exception);\n      if (frame_image != ((Image *) 0))\n      {\n        image = DestroyImage(image);\n        image = frame_image;\n      }\n      x = 0;\n      y = 0;\n    }\n    if (LocaleCompare(image->magick, \"NULL\") != 0)\n    {\n      if (montage_info->shadow != MagickFalse)\n      {\n        Image *shadow_image;\n        (void) QueryColorDatabase(\"#000000\", &image->background_color, exception);\n        shadow_image = ShadowImage(image, 80.0, 2.0, 5, 5, exception);\n        if (shadow_image != ((Image *) 0))\n        {\n          InheritException(&shadow_image->exception, exception);\n          (void) CompositeImage(shadow_image, OverCompositeOp, image, 0, 0);\n          image = DestroyImage(image);\n          image = shadow_image;\n        }\n      }\n      (void) CompositeImage(montage, image->compose, image, x_offset + x, y_offset + y);\n      value = GetImageProperty(image, \"label\");\n      if (value != ((const char *) 0))\n      {\n        char geometry[MaxTextExtent];\n        (void) FormatLocaleString(geometry, MaxTextExtent, \"%.20gx%.20g%+.20g%+.20g\", (double) (((montage_info->frame) ? (image->columns) : (width)) - (2 * border_width)), ((double) ((metrics.ascent - metrics.descent) + 4)) * MultilineCensus(value), (double) (x_offset + border_width), (double) (((montage_info->frame) ? (((y_offset + height) + border_width) + 4) : (((y_offset + extract_info.height) + border_width) + ((montage_info->shadow != MagickFalse) ? (4) : (0)))) + bevel_width));\n        (void) CloneString(&draw_info->geometry, geometry);\n        (void) CloneString(&draw_info->text, value);\n        (void) AnnotateImage(montage, draw_info);\n      }\n    }\n    x_offset += (ssize_t) (width + (2 * (extract_info.x + border_width)));\n    if (((tile + 1) == ((ssize_t) tiles_per_page)) || (((tile + 1) % tiles_per_row) == 0))\n    {\n      x_offset = extract_info.x;\n      y_offset += (ssize_t) (((height + ((extract_info.y + border_width) * 2)) + (((metrics.ascent - metrics.descent) + 4) * number_lines)) + ((montage_info->shadow != MagickFalse) ? (4) : (0)));\n      max_height = 0;\n    }\n    if (images->progress_monitor != ((MagickProgressMonitor) 0))\n    {\n      MagickBooleanType proceed;\n      proceed = SetImageProgress(image, \"Montage/Image\", tiles, total_tiles);\n      if (proceed == MagickFalse)\n        status = MagickFalse;\n    }\n    image_list[tile] = DestroyImage(image_list[tile]);\n    image = DestroyImage(image);\n    tiles++;\n  }\n\n  (void) status;\n  if ((i + 1) < ((ssize_t) images_per_page))\n  {\n    AcquireNextImage(clone_info, montage);\n    if (GetNextImageInList(montage) == ((Image *) 0))\n    {\n      montage = DestroyImageList(montage);\n      return (Image *) 0;\n    }\n    montage = GetNextImageInList(montage);\n    montage->background_color = montage_info->background_color;\n    image_list += tiles_per_page;\n    number_images -= tiles_per_page;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_montage/5"}
{"code": "for (i = 0; i < ((ssize_t) number_rows); i++)\n{\n  matrix[i] = (double *) AcquireQuantumMemory(size, sizeof(*matrix[i]));\n  if (matrix[i] == ((double *) 0))\n  {\n    for (j = 0; j < i; j++)\n      matrix[j] = (double *) RelinquishMagickMemory(matrix[j]);\n\n    matrix = (double **) RelinquishMagickMemory(matrix);\n    return (double **) 0;\n  }\n  for (j = 0; j < ((ssize_t) size); j++)\n    matrix[i][j] = 0.0;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_matrix/0"}
{"code": "for (i = 0; i < ((ssize_t) rank); i++)\n{\n  max = 0.0;\n  for (j = 0; j < ((ssize_t) rank); j++)\n    if (pivots[j] != 1)\n  {\n    for (k = 0; k < ((ssize_t) rank); k++)\n      if (pivots[k] != 0)\n    {\n      if (pivots[k] > 1)\n        return MagickFalse;\n    }\n    else\n      if (fabs(matrix[j][k]) >= max)\n    {\n      max = fabs(matrix[j][k]);\n      row = j;\n      column = k;\n    }\n\n  }\n\n  pivots[column]++;\n  if (row != column)\n  {\n    for (k = 0; k < ((ssize_t) rank); k++)\n    {\n      if (matrix[row][k] != matrix[column][k])\n      {\n        matrix[row][k] += matrix[column][k];\n        matrix[column][k] = matrix[row][k] - matrix[column][k];\n        matrix[row][k] = matrix[row][k] - matrix[column][k];\n      }\n    }\n\n    ;\n    for (k = 0; k < ((ssize_t) number_vectors); k++)\n    {\n      if (vectors[k][row] != vectors[k][column])\n      {\n        vectors[k][row] += vectors[k][column];\n        vectors[k][column] = vectors[k][row] - vectors[k][column];\n        vectors[k][row] = vectors[k][row] - vectors[k][column];\n      }\n    }\n\n    ;\n  }\n  rows[i] = row;\n  columns[i] = column;\n  if (matrix[column][column] == 0.0)\n    return MagickFalse;\n  scale = 1.0 / matrix[column][column];\n  matrix[column][column] = 1.0;\n  for (j = 0; j < ((ssize_t) rank); j++)\n    matrix[column][j] *= scale;\n\n  for (j = 0; j < ((ssize_t) number_vectors); j++)\n    vectors[j][column] *= scale;\n\n  for (j = 0; j < ((ssize_t) rank); j++)\n    if (j != column)\n  {\n    scale = matrix[j][column];\n    matrix[j][column] = 0.0;\n    for (k = 0; k < ((ssize_t) rank); k++)\n      matrix[j][k] -= scale * matrix[column][k];\n\n    for (k = 0; k < ((ssize_t) number_vectors); k++)\n      vectors[k][j] -= scale * vectors[k][column];\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_matrix/1"}
{"code": "for (j = ((ssize_t) rank) - 1; j >= 0; j--)\n  if (columns[j] != rows[j])\n  for (i = 0; i < ((ssize_t) rank); i++)\n{\n  if (matrix[i][rows[j]] != matrix[i][columns[j]])\n  {\n    matrix[i][rows[j]] += matrix[i][columns[j]];\n    matrix[i][columns[j]] = matrix[i][rows[j]] - matrix[i][columns[j]];\n    matrix[i][rows[j]] = matrix[i][rows[j]] - matrix[i][columns[j]];\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_matrix/2"}
{"code": "for (j = 0; j < ((ssize_t) rank); j++)\n{\n  for (i = 0; i < ((ssize_t) rank); i++)\n    matrix[i][j] += terms[i] * terms[j];\n\n  for (i = 0; i < ((ssize_t) number_vectors); i++)\n    vectors[i][j] += results[i] * terms[j];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_matrix/3"}
{"code": "for (i = 0; i < ((ssize_t) number_rows); i++)\n  matrix[i] = (double *) RelinquishMagickMemory(matrix[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_matrix/4"}
{"code": "for (i = 0; p != ((const MagicInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    aliases[i++] = p;\n  p = (const MagicInfo *) GetNextValueInLinkedList(magic_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_magic/0"}
{"code": "for (i = 0; p != ((const MagicInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    aliases[i++] = ConstantString(p->name);\n  p = (const MagicInfo *) GetNextValueInLinkedList(magic_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_magic/1"}
{"code": "for (i = 0; i < ((ssize_t) number_aliases); i++)\n{\n  if (magic_info[i]->stealth != MagickFalse)\n    continue;\n  if ((path == ((const char *) 0)) || (LocaleCompare(path, magic_info[i]->path) != 0))\n  {\n    if (magic_info[i]->path != ((char *) 0))\n      (void) FormatLocaleFile(file, \"\\nPath: %s\\n\\n\", magic_info[i]->path);\n    (void) FormatLocaleFile(file, \"Name      Offset Target\\n\");\n    (void) FormatLocaleFile(file, \"-------------------------------------------------------------------------------\\n\");\n  }\n  path = magic_info[i]->path;\n  (void) FormatLocaleFile(file, \"%s\", magic_info[i]->name);\n  for (j = (ssize_t) strlen(magic_info[i]->name); j <= 9; j++)\n    (void) FormatLocaleFile(file, \" \");\n\n  (void) FormatLocaleFile(file, \"%6ld \", (long) magic_info[i]->offset);\n  if (magic_info[i]->target != ((char *) 0))\n  {\n    ssize_t j;\n    for (j = 0; magic_info[i]->target[j] != '\\0'; j++)\n      if (isprint((int) ((unsigned char) magic_info[i]->target[j])) != 0)\n      (void) FormatLocaleFile(file, \"%c\", magic_info[i]->target[j]);\n    else\n      (void) FormatLocaleFile(file, \"\\\\%03o\", (unsigned int) ((unsigned char) magic_info[i]->target[j]));\n\n  }\n  (void) FormatLocaleFile(file, \"\\n\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_magic/2"}
{"code": "for (q = (char *) xml; (*q) != '\\0';)\n{\n  GetMagickToken(q, &q, token);\n  if ((*token) == '\\0')\n    break;\n  (void) CopyMagickString(keyword, token, MaxTextExtent);\n  if (LocaleNCompare(keyword, \"<!DOCTYPE\", 9) == 0)\n  {\n    while ((LocaleNCompare(q, \"]>\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleNCompare(keyword, \"<!--\", 4) == 0)\n  {\n    while ((LocaleNCompare(q, \"->\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<include\") == 0)\n  {\n    while ((((*token) != '/') && ((*(token + 1)) != '>')) && ((*q) != '\\0'))\n    {\n      (void) CopyMagickString(keyword, token, MaxTextExtent);\n      GetMagickToken(q, &q, token);\n      if ((*token) != '=')\n        continue;\n      GetMagickToken(q, &q, token);\n      if (LocaleCompare(keyword, \"file\") == 0)\n      {\n        if (depth > 200)\n          (void) ThrowMagickException(exception, GetMagickModule(), ConfigureError, \"IncludeElementNestedTooDeeply\", \"`%s'\", token);\n        else\n        {\n          char path[MaxTextExtent];\n          char *xml;\n          GetPathComponent(filename, HeadPath, path);\n          if ((*path) != '\\0')\n            (void) ConcatenateMagickString(path, DirectorySeparator, MaxTextExtent);\n          if ((*token) == (*DirectorySeparator))\n            (void) CopyMagickString(path, token, MaxTextExtent);\n          else\n            (void) ConcatenateMagickString(path, token, MaxTextExtent);\n          xml = FileToString(path, ~0, exception);\n          if (xml != ((char *) 0))\n          {\n            status = LoadMagicList(xml, path, depth + 1, exception);\n            xml = (char *) RelinquishMagickMemory(xml);\n          }\n        }\n      }\n    }\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<magic\") == 0)\n  {\n    magic_info = (MagicInfo *) AcquireMagickMemory(sizeof(*magic_info));\n    if (magic_info == ((MagicInfo *) 0))\n      ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(magic_info, 0, sizeof(*magic_info));\n    magic_info->path = ConstantString(filename);\n    magic_info->exempt = MagickFalse;\n    magic_info->signature = MagickSignature;\n    continue;\n  }\n  if (magic_info == ((MagicInfo *) 0))\n    continue;\n  if (LocaleCompare(keyword, \"/>\") == 0)\n  {\n    status = AppendValueToLinkedList(magic_list, magic_info);\n    if (status == MagickFalse)\n      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", magic_info->name);\n    magic_info = (MagicInfo *) 0;\n  }\n  GetMagickToken(q, (const char **) 0, token);\n  if ((*token) != '=')\n    continue;\n  GetMagickToken(q, &q, token);\n  GetMagickToken(q, &q, token);\n  switch (*keyword)\n  {\n    case 'N':\n\n    case 'n':\n    {\n      if (LocaleCompare((char *) keyword, \"name\") == 0)\n      {\n        magic_info->name = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'O':\n\n    case 'o':\n    {\n      if (LocaleCompare((char *) keyword, \"offset\") == 0)\n      {\n        magic_info->offset = (MagickOffsetType) StringToLong(token);\n        break;\n      }\n      break;\n    }\n\n    case 'S':\n\n    case 's':\n    {\n      if (LocaleCompare((char *) keyword, \"stealth\") == 0)\n      {\n        magic_info->stealth = IsMagickTrue(token);\n        break;\n      }\n      break;\n    }\n\n    case 'T':\n\n    case 't':\n    {\n      if (LocaleCompare((char *) keyword, \"target\") == 0)\n      {\n        char *p;\n        unsigned char *q;\n        size_t length;\n        length = strlen(token);\n        magic_info->target = ConstantString(token);\n        magic_info->magic = (unsigned char *) ConstantString(token);\n        q = magic_info->magic;\n        for (p = magic_info->target; (*p) != '\\0';)\n        {\n          if ((*p) == '\\\\')\n          {\n            p++;\n            if (isdigit((int) ((unsigned char) (*p))) != 0)\n            {\n              char *end;\n              *(q++) = (unsigned char) strtol(p, &end, 8);\n              p += end - p;\n              magic_info->length++;\n              continue;\n            }\n            switch (*p)\n            {\n              case 'b':\n                *q = '\\b';\n                break;\n\n              case 'f':\n                *q = '\\f';\n                break;\n\n              case 'n':\n                *q = '\\n';\n                break;\n\n              case 'r':\n                *q = '\\r';\n                break;\n\n              case 't':\n                *q = '\\t';\n                break;\n\n              case 'v':\n                *q = '\\v';\n                break;\n\n              case 'a':\n                *q = 'a';\n                break;\n\n              case '?':\n                *q = '\\?';\n                break;\n\n              default:\n                *q = (unsigned char) (*p);\n                break;\n\n            }\n\n            p++;\n            q++;\n            magic_info->length++;\n            continue;\n          }\n          else\n            if (LocaleNCompare(p, \"&amp;\", 5) == 0)\n            (void) CopyMagickString(p + 1, p + 5, length - magic_info->length);\n          *(q++) = (unsigned char) (*(p++));\n          magic_info->length++;\n        }\n\n        break;\n      }\n      break;\n    }\n\n    default:\n      break;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_magic/3"}
{"code": "for (i = 0; i < ((ssize_t) ((sizeof(MagicMap)) / (sizeof(*MagicMap)))); i++)\n{\n  MagicInfo *magic_info;\n  const MagicMapInfo *p;\n  p = MagicMap + i;\n  magic_info = (MagicInfo *) AcquireMagickMemory(sizeof(*magic_info));\n  if (magic_info == ((MagicInfo *) 0))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", magic_info->name);\n    continue;\n  }\n  (void) ResetMagickMemory(magic_info, 0, sizeof(*magic_info));\n  magic_info->path = (char *) \"[built-in]\";\n  magic_info->name = (char *) p->name;\n  magic_info->offset = p->offset;\n  magic_info->target = (char *) p->magic;\n  magic_info->magic = (unsigned char *) p->magic;\n  magic_info->length = p->length;\n  magic_info->exempt = MagickTrue;\n  magic_info->signature = MagickSignature;\n  status = AppendValueToLinkedList(magic_list, magic_info);\n  if (status == MagickFalse)\n    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", magic_info->name);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_magic/4"}
{"code": "for (p = (Image *) 0; images != ((Image *) 0); images = images->next)\n{\n  clone = CloneImage(images, 0, 0, MagickTrue, exception);\n  if (clone == ((Image *) 0))\n  {\n    if (image != ((Image *) 0))\n      image = DestroyImageList(image);\n    return (Image *) 0;\n  }\n  if (image == ((Image *) 0))\n  {\n    image = clone;\n    p = image;\n    continue;\n  }\n  p->next = clone;\n  clone->previous = p;\n  p = p->next;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/0"}
{"code": "for (p = (char *) scenes; (*p) != '\\0';)\n{\n  while ((isspace((int) ((unsigned char) (*p))) != 0) || ((*p) == ','))\n    p++;\n\n  first = strtol(p, &p, 10);\n  if (first < 0)\n    first += (long) length;\n  last = first;\n  while (isspace((int) ((unsigned char) (*p))) != 0)\n    p++;\n\n  if ((*p) == '-')\n  {\n    last = strtol(p + 1, &p, 10);\n    if (last < 0)\n      last += (long) length;\n  }\n  for (step = (first > last) ? (-1) : (1); first != (last + step); first += step)\n  {\n    i = 0;\n    for (next = images; next != ((Image *) 0); next = GetNextImageInList(next))\n    {\n      if (i == ((ssize_t) first))\n      {\n        image = CloneImage(next, 0, 0, MagickTrue, exception);\n        if (image == ((Image *) 0))\n          break;\n        AppendImageToList(&clone_images, image);\n      }\n      i++;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/1"}
{"code": "for (i = 0; i < ((ssize_t) length); i++)\n  delete_list[i] = MagickFalse;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/2"}
{"code": "for (p = (char *) scenes; (*p) != '\\0';)\n{\n  while ((isspace((int) (*p)) != 0) || ((*p) == ','))\n    p++;\n\n  first = strtol(p, &p, 10);\n  if (first < 0)\n    first += (long) length;\n  last = first;\n  while (isspace((int) ((unsigned char) (*p))) != 0)\n    p++;\n\n  if ((*p) == '-')\n  {\n    last = strtol(p + 1, &p, 10);\n    if (last < 0)\n      last += (long) length;\n  }\n  if (first > last)\n    continue;\n  for (i = (ssize_t) first; i <= ((ssize_t) last); i++)\n    if ((i >= 0) && (i < ((ssize_t) length)))\n    delete_list[i] = MagickTrue;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/3"}
{"code": "for (i = 0; i < ((ssize_t) length); i++)\n{\n  *images = image;\n  image = GetNextImageInList(image);\n  if (delete_list[i] != MagickFalse)\n    DeleteImageFromList(images);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/4"}
{"code": "for (i = 0; i < ((ssize_t) number_duplicates); i++)\n{\n  clone_images = CloneImages(images, scenes, exception);\n  AppendImageToList(&duplicate_images, clone_images);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/5"}
{"code": "for (p = images; p->previous != ((Image *) 0); p = p->previous)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/6"}
{"code": "for (offset = index; offset < 0; offset += (ssize_t) length)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/7"}
{"code": "for (i = 0; p != ((Image *) 0); p = p->next)\n  if ((i++) == ((ssize_t) (offset % length)))\n  break;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/8"}
{"code": "for (i = 0; images->previous != ((Image *) 0); i++)\n  images = images->previous;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/9"}
{"code": "for (i = 0; images != ((Image *) 0); images = images->next)\n  i++;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/10"}
{"code": "for (p = images; p->next != ((Image *) 0); p = p->next)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/11"}
{"code": "for (i = 0; images != ((Image *) 0); images = images->next)\n  group[i++] = (Image *) images;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/12"}
{"code": "for (p = *images; p->next != ((Image *) 0); p = p->next)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/13"}
{"code": "for (; p != ((Image *) 0); p = p->next)\n{\n  next = p->next;\n  p->next = p->previous;\n  p->previous = next;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/14"}
{"code": "for (i = 0; (i < length) && (split != ((Image *) 0)); i++)\n  AppendImageToList(&image, RemoveImageFromList(&split));\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/15"}
{"code": "for (p = images; p != ((Image *) 0); p = p->next)\n{\n  for (q = p->next; q != ((Image *) 0); q = q->next)\n    if (p->scene == q->scene)\n    break;\n\n  if (q != ((Image *) 0))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/16"}
{"code": "for (p = images->next; p != ((Image *) 0); p = p->next)\n  p->scene = p->previous->scene + 1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_list/17"}
{"code": "for (p = pedantic_geometry; (*p) != '\\0';)\n{\n  if (isspace((int) ((unsigned char) (*p))) != 0)\n  {\n    (void) CopyMagickString(p, p + 1, MaxTextExtent);\n    continue;\n  }\n  switch ((int) (*p))\n  {\n    case '%':\n    {\n      flags |= PercentValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '!':\n    {\n      flags |= AspectValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '<':\n    {\n      flags |= LessValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '>':\n    {\n      flags |= GreaterValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '^':\n    {\n      flags |= MinimumValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '@':\n    {\n      flags |= AreaValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '(':\n\n    case ')':\n    {\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '-':\n\n    case '.':\n\n    case ',':\n\n    case '+':\n\n    case '0':\n\n    case '1':\n\n    case '2':\n\n    case '3':\n\n    case '4':\n\n    case '5':\n\n    case '6':\n\n    case '7':\n\n    case '8':\n\n    case '9':\n\n    case -41:\n\n    case 'x':\n\n    case 'X':\n    {\n      p++;\n      break;\n    }\n\n    default:\n      return flags;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_geometry/0"}
{"code": "for (i = 0; (*PageSizes[i]) != ((char *) 0); i++)\n  if (LocaleNCompare(PageSizes[i][0], page, strlen(PageSizes[i][0])) == 0)\n{\n  RectangleInfo geometry;\n  MagickStatusType flags;\n  (void) CopyMagickString(page, PageSizes[i][1], MaxTextExtent);\n  (void) ConcatenateMagickString(page, page_geometry + strlen(PageSizes[i][0]), MaxTextExtent);\n  flags = GetGeometry(page, &geometry.x, &geometry.y, &geometry.width, &geometry.height);\n  if ((flags & GreaterValue) == 0)\n    (void) ConcatenateMagickString(page, \">\", MaxTextExtent);\n  break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_geometry/1"}
{"code": "for (i = 0; ((*p) != '\\0') && (i < 6); i++)\n{\n  GetMagickToken(p, &p, token);\n  if ((*token) == ',')\n    GetMagickToken(p, &p, token);\n  switch (i)\n  {\n    case 0:\n    {\n      affine_matrix->sx = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 1:\n    {\n      affine_matrix->rx = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 2:\n    {\n      affine_matrix->ry = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 3:\n    {\n      affine_matrix->sy = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 4:\n    {\n      affine_matrix->tx = InterpretLocaleValue(token, (char **) 0);\n      flags |= XValue;\n      break;\n    }\n\n    case 5:\n    {\n      affine_matrix->ty = InterpretLocaleValue(token, (char **) 0);\n      flags |= YValue;\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_geometry/2"}
{"code": "for (p = pedantic_geometry; (*p) != '\\0';)\n{\n  if (isspace((int) ((unsigned char) (*p))) != 0)\n  {\n    (void) CopyMagickString(p, p + 1, MaxTextExtent);\n    continue;\n  }\n  switch ((int) (*p))\n  {\n    case '%':\n    {\n      flags |= PercentValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '!':\n    {\n      flags |= AspectValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '<':\n    {\n      flags |= LessValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '>':\n    {\n      flags |= GreaterValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '^':\n    {\n      flags |= MinimumValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '@':\n    {\n      flags |= AreaValue;\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '(':\n\n    case ')':\n    {\n      (void) CopyMagickString(p, p + 1, MaxTextExtent);\n      break;\n    }\n\n    case '-':\n\n    case '+':\n\n    case ',':\n\n    case '0':\n\n    case '1':\n\n    case '2':\n\n    case '3':\n\n    case '4':\n\n    case '5':\n\n    case '6':\n\n    case '7':\n\n    case '8':\n\n    case '9':\n\n    case -41:\n\n    case 'x':\n\n    case 'X':\n\n    case '/':\n\n    case ':':\n    {\n      p++;\n      break;\n    }\n\n    case '.':\n    {\n      p++;\n      flags |= DecimalValue;\n      break;\n    }\n\n    default:\n      return flags;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_geometry/3"}
{"code": "for (i = 0; alpha > poisson; i++)\n{\n  beta = GetPseudoRandomValue(random_info);\n  alpha *= beta;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_gem/0"}
{"code": "for (width = 5;;)\n{\n  normalize = 0.0;\n  j = ((ssize_t) width) / 2;\n  for (i = -j; i <= j; i++)\n    normalize += exp((-((double) (i * i))) * alpha) * beta;\n\n  value = (exp((-((double) (j * j))) * alpha) * beta) / normalize;\n  if ((value < QuantumScale) || (value < MagickEpsilon))\n    break;\n  width += 2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_gem/1"}
{"code": "for (width = 5;;)\n{\n  normalize = 0.0;\n  j = ((ssize_t) width) / 2;\n  for (v = -j; v <= j; v++)\n    for (u = -j; u <= j; u++)\n    normalize += exp((-((double) ((u * u) + (v * v)))) * alpha) * beta;\n\n\n  value = (exp((-((double) (j * j))) * alpha) * beta) / normalize;\n  if ((value < QuantumScale) || (value < MagickEpsilon))\n    break;\n  width += 2;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_gem/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict noise_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(noise_view, 0, y, noise_image->columns, 1, exception);\n  if ((p == ((PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  noise_indexes = GetCacheViewAuthenticIndexQueue(noise_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(GenerateDifferentialNoise(random_info[id], GetPixelRed(p), noise_type, attenuate)));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(GenerateDifferentialNoise(random_info[id], GetPixelGreen(p), noise_type, attenuate)));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(GenerateDifferentialNoise(random_info[id], GetPixelBlue(p), noise_type, attenuate)));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, ClampToQuantum(GenerateDifferentialNoise(random_info[id], GetPixelOpacity(p), noise_type, attenuate)));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(noise_indexes + x, ClampToQuantum(GenerateDifferentialNoise(random_info[id], GetPixelIndex(indexes + x), noise_type, attenuate)));\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(noise_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_AddNoiseImage)\n    proceed = SetImageProgress(image, \"AddNoise/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  MagickPixelPacket pixel;\n  Quantum quantum;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(shift_view, 0, y, shift_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    quantum = GetPixelRed(p);\n    if (GetPixelGreen(p) < quantum)\n      quantum = GetPixelGreen(p);\n    if (GetPixelBlue(p) < quantum)\n      quantum = GetPixelBlue(p);\n    pixel.red = 0.5 * (GetPixelRed(p) + (factor * quantum));\n    pixel.green = 0.5 * (GetPixelGreen(p) + (factor * quantum));\n    pixel.blue = 0.5 * (GetPixelBlue(p) + (factor * quantum));\n    quantum = GetPixelRed(p);\n    if (GetPixelGreen(p) > quantum)\n      quantum = GetPixelGreen(p);\n    if (GetPixelBlue(p) > quantum)\n      quantum = GetPixelBlue(p);\n    pixel.red = 0.5 * (pixel.red + (factor * quantum));\n    pixel.green = 0.5 * (pixel.green + (factor * quantum));\n    pixel.blue = 0.5 * (pixel.blue + (factor * quantum));\n    SetPixelRed(q, ClampToQuantum(pixel.red));\n    SetPixelGreen(q, ClampToQuantum(pixel.green));\n    SetPixelBlue(q, ClampToQuantum(pixel.blue));\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(shift_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_BlueShiftImage)\n    proceed = SetImageProgress(image, \"BlueShift/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(colorize_view, 0, y, colorize_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ((GetPixelRed(p) * (100.0 - pixel.red)) + (colorize.red * pixel.red)) / 100.0);\n    SetPixelGreen(q, ((GetPixelGreen(p) * (100.0 - pixel.green)) + (colorize.green * pixel.green)) / 100.0);\n    SetPixelBlue(q, ((GetPixelBlue(p) * (100.0 - pixel.blue)) + (colorize.blue * pixel.blue)) / 100.0);\n    SetPixelOpacity(q, ((GetPixelOpacity(p) * (100.0 - pixel.opacity)) + (colorize.opacity * pixel.opacity)) / 100.0);\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(colorize_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ColorizeImage)\n    proceed = SetImageProgress(image, \"Colorize/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickRealType pixel;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  IndexPacket * restrict color_indexes;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(color_view, 0, y, color_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  color_indexes = GetCacheViewAuthenticIndexQueue(color_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ssize_t v;\n    size_t height;\n    height = (color_matrix->height > 6) ? (6UL) : (color_matrix->height);\n    for (v = 0; v < ((ssize_t) height); v++)\n    {\n      pixel = ((ColorMatrix[v][0] * GetPixelRed(p)) + (ColorMatrix[v][1] * GetPixelGreen(p))) + (ColorMatrix[v][2] * GetPixelBlue(p));\n      if (image->matte != MagickFalse)\n        pixel += ColorMatrix[v][3] * (QuantumRange - GetPixelOpacity(p));\n      if (image->colorspace == CMYKColorspace)\n        pixel += ColorMatrix[v][4] * GetPixelIndex(indexes + x);\n      pixel += QuantumRange * ColorMatrix[v][5];\n      switch (v)\n      {\n        case 0:\n          SetPixelRed(q, ClampToQuantum(pixel));\n          break;\n\n        case 1:\n          SetPixelGreen(q, ClampToQuantum(pixel));\n          break;\n\n        case 2:\n          SetPixelBlue(q, ClampToQuantum(pixel));\n          break;\n\n        case 3:\n        {\n          if (image->matte != MagickFalse)\n            SetPixelAlpha(q, ClampToQuantum(pixel));\n          break;\n        }\n\n        case 4:\n        {\n          if (image->colorspace == CMYKColorspace)\n            SetPixelIndex(color_indexes + x, ClampToQuantum(pixel));\n          break;\n        }\n\n      }\n\n    }\n\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(color_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ColorMatrixImage)\n    proceed = SetImageProgress(image, \"ColorMatrix/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/3"}
{"code": "for (y = 0; y < ((ssize_t) fx_image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  MagickRealType alpha;\n  IndexPacket * restrict fx_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(fx_view, 0, y, fx_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  fx_indexes = GetCacheViewAuthenticIndexQueue(fx_view);\n  alpha = 0.0;\n  for (x = 0; x < ((ssize_t) fx_image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n    {\n      (void) FxEvaluateChannelExpression(fx_info[id], RedChannel, x, y, &alpha, exception);\n      SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * alpha));\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      (void) FxEvaluateChannelExpression(fx_info[id], GreenChannel, x, y, &alpha, exception);\n      SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * alpha));\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      (void) FxEvaluateChannelExpression(fx_info[id], BlueChannel, x, y, &alpha, exception);\n      SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * alpha));\n    }\n    if ((channel & OpacityChannel) != 0)\n    {\n      (void) FxEvaluateChannelExpression(fx_info[id], OpacityChannel, x, y, &alpha, exception);\n      if (image->matte == MagickFalse)\n        SetPixelOpacity(q, ClampToQuantum(((MagickRealType) QuantumRange) * alpha));\n      else\n        SetPixelOpacity(q, ClampToQuantum((MagickRealType) (QuantumRange - (QuantumRange * alpha))));\n    }\n    if (((channel & IndexChannel) != 0) && (fx_image->colorspace == CMYKColorspace))\n    {\n      (void) FxEvaluateChannelExpression(fx_info[id], IndexChannel, x, y, &alpha, exception);\n      SetPixelIndex(fx_indexes + x, ClampToQuantum(((MagickRealType) QuantumRange) * alpha));\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(fx_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_FxImageChannel)\n    proceed = SetImageProgress(image, \"Fx/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  MagickRealType distance;\n  PointInfo delta;\n  IndexPacket * restrict implode_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(implode_view, 0, y, implode_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  implode_indexes = GetCacheViewAuthenticIndexQueue(implode_view);\n  delta.y = scale.y * ((double) (y - center.y));\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    delta.x = scale.x * ((double) (x - center.x));\n    distance = (delta.x * delta.x) + (delta.y * delta.y);\n    if (distance < (radius * radius))\n    {\n      double factor;\n      factor = 1.0;\n      if (distance > 0.0)\n        factor = pow(sin((double) (((MagickPI * sqrt((double) distance)) / radius) / 2)), -amount);\n      (void) InterpolateMagickPixelPacket(image, image_view, UndefinedInterpolatePixel, (double) (((factor * delta.x) / scale.x) + center.x), (double) (((factor * delta.y) / scale.y) + center.y), &pixel, exception);\n      SetPixelPacket(implode_image, &pixel, q, implode_indexes + x);\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(implode_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ImplodeImage)\n    proceed = SetImageProgress(image, \"Implode/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/5"}
{"code": "for (y = 0; y < ((ssize_t) morph_images->rows); y++)\n{\n  MagickBooleanType sync;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, morph_image->columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(morph_view, 0, y, morph_images->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) morph_images->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum((alpha * GetPixelRed(q)) + (beta * GetPixelRed(p))));\n    SetPixelGreen(q, ClampToQuantum((alpha * GetPixelGreen(q)) + (beta * GetPixelGreen(p))));\n    SetPixelBlue(q, ClampToQuantum((alpha * GetPixelBlue(q)) + (beta * GetPixelBlue(p))));\n    SetPixelOpacity(q, ClampToQuantum((alpha * GetPixelOpacity(q)) + (beta * GetPixelOpacity(p))));\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(morph_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/6"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(sepia_view, 0, y, sepia_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType intensity;\n    MagickRealType tone;\n    intensity = (MagickRealType) PixelIntensityToQuantum(p);\n    tone = (intensity > threshold) ? ((MagickRealType) QuantumRange) : ((intensity + ((MagickRealType) QuantumRange)) - threshold);\n    SetPixelRed(q, ClampToQuantum(tone));\n    tone = (intensity > ((7.0 * threshold) / 6.0)) ? ((MagickRealType) QuantumRange) : ((intensity + ((MagickRealType) QuantumRange)) - ((7.0 * threshold) / 6.0));\n    SetPixelGreen(q, ClampToQuantum(tone));\n    tone = (intensity < (threshold / 6.0)) ? (0) : (intensity - (threshold / 6.0));\n    SetPixelBlue(q, ClampToQuantum(tone));\n    tone = threshold / 7.0;\n    if (((MagickRealType) GetPixelGreen(q)) < tone)\n      SetPixelGreen(q, ClampToQuantum(tone));\n    if (((MagickRealType) GetPixelBlue(q)) < tone)\n      SetPixelBlue(q, ClampToQuantum(tone));\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(sepia_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SepiaToneImage)\n    proceed = SetImageProgress(image, \"SepiaTone/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/7"}
{"code": "for (y = 0; y < ((ssize_t) border_image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, border_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) border_image->columns); x++)\n  {\n    SetPixelRed(q, border_image->background_color.red);\n    SetPixelGreen(q, border_image->background_color.green);\n    SetPixelBlue(q, border_image->background_color.blue);\n    if (border_image->matte == MagickFalse)\n      SetPixelOpacity(q, border_image->background_color.opacity);\n    else\n      SetPixelOpacity(q, ClampToQuantum((MagickRealType) (QuantumRange - ((GetPixelAlpha(q) * opacity) / 100.0))));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ShadowImage)\n    proceed = SetImageProgress(image, \"Shadow/Image\", progress++, border_image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/8"}
{"code": "for (y = 0; y < ((ssize_t) random_image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = QueueCacheViewAuthenticPixels(random_view, 0, y, random_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(random_view);\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) random_image->columns); x++)\n  {\n    pixel.red = (MagickRealType) (QuantumRange * GetPseudoRandomValue(random_info[id]));\n    pixel.green = pixel.red;\n    pixel.blue = pixel.red;\n    if (image->colorspace == CMYKColorspace)\n      pixel.index = pixel.red;\n    SetPixelPacket(random_image, &pixel, q, indexes + x);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(random_view, exception) == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/9"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (((MagickRealType) GetPixelRed(q)) > threshold)\n      SetPixelRed(q, QuantumRange - GetPixelRed(q));\n    if (((MagickRealType) GetPixelGreen(q)) > threshold)\n      SetPixelGreen(q, QuantumRange - GetPixelGreen(q));\n    if (((MagickRealType) GetPixelBlue(q)) > threshold)\n      SetPixelBlue(q, QuantumRange - GetPixelBlue(q));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SolarizeImage)\n    proceed = SetImageProgress(image, \"Solarize/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/10"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  MagickRealType distance;\n  PointInfo delta;\n  IndexPacket * restrict swirl_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(swirl_view, 0, y, swirl_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  swirl_indexes = GetCacheViewAuthenticIndexQueue(swirl_view);\n  delta.y = scale.y * ((double) (y - center.y));\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    delta.x = scale.x * ((double) (x - center.x));\n    distance = (delta.x * delta.x) + (delta.y * delta.y);\n    if (distance < (radius * radius))\n    {\n      MagickRealType cosine;\n      MagickRealType factor;\n      MagickRealType sine;\n      factor = 1.0 - (sqrt((double) distance) / radius);\n      sine = sin((double) ((degrees * factor) * factor));\n      cosine = cos((double) ((degrees * factor) * factor));\n      (void) InterpolateMagickPixelPacket(image, image_view, UndefinedInterpolatePixel, (double) ((((cosine * delta.x) - (sine * delta.y)) / scale.x) + center.x), (double) ((((sine * delta.x) + (cosine * delta.y)) / scale.y) + center.y), &pixel, exception);\n      SetPixelPacket(swirl_image, &pixel, q, swirl_indexes + x);\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(swirl_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SwirlImage)\n    proceed = SetImageProgress(image, \"Swirl/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(tint_view, 0, y, tint_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    MagickRealType weight;\n    weight = (QuantumScale * GetPixelRed(p)) - 0.5;\n    pixel.red = ((MagickRealType) GetPixelRed(p)) + (color_vector.red * (1.0 - (4.0 * (weight * weight))));\n    SetPixelRed(q, ClampToQuantum(pixel.red));\n    weight = (QuantumScale * GetPixelGreen(p)) - 0.5;\n    pixel.green = ((MagickRealType) GetPixelGreen(p)) + (color_vector.green * (1.0 - (4.0 * (weight * weight))));\n    SetPixelGreen(q, ClampToQuantum(pixel.green));\n    weight = (QuantumScale * GetPixelBlue(p)) - 0.5;\n    pixel.blue = ((MagickRealType) GetPixelBlue(p)) + (color_vector.blue * (1.0 - (4.0 * (weight * weight))));\n    SetPixelBlue(q, ClampToQuantum(pixel.blue));\n    SetPixelOpacity(q, GetPixelOpacity(p));\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(tint_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TintImage)\n    proceed = SetImageProgress(image, \"Tint/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/12"}
{"code": "for (y = 0; y < ((ssize_t) wave_image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = QueueCacheViewAuthenticPixels(wave_view, 0, y, wave_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(wave_view);\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) wave_image->columns); x++)\n  {\n    (void) InterpolateMagickPixelPacket(image, image_view, UndefinedInterpolatePixel, (double) x, (double) (y - sine_map[x]), &pixel, exception);\n    SetPixelPacket(wave_image, &pixel, q, indexes + x);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(wave_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_WaveImage)\n    proceed = SetImageProgress(image, \"Wave/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/13"}
{"code": "for (; next != ((Image *) 0); next = next->next)\n{\n  fx_info->view[i] = AcquireCacheView(next);\n  i++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/14"}
{"code": "for (v = 0; v < ((ssize_t) color_matrix->height); v++)\n  for (u = 0; u < ((ssize_t) color_matrix->width); u++)\n{\n  if ((v < 6) && (u < 6))\n    ColorMatrix[v][u] = color_matrix->values[i];\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/15"}
{"code": "for (v = 0; v < 6; v++)\n{\n  *message = '\\0';\n  (void) FormatLocaleString(format, MaxTextExtent, \"%.20g: \", (double) v);\n  (void) ConcatenateString(&message, format);\n  for (u = 0; u < 6; u++)\n  {\n    (void) FormatLocaleString(format, MaxTextExtent, \"%+f \", ColorMatrix[v][u]);\n    (void) ConcatenateString(&message, format);\n  }\n\n  (void) LogMagickEvent(TransformEvent, GetMagickModule(), \"%s\", message);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/16"}
{"code": "for (i = ((ssize_t) GetImageListLength(fx_info->images)) - 1; i >= 0; i--)\n  fx_info->view[i] = DestroyCacheView(fx_info->view[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/17"}
{"code": "for (p = symbol; ((*p) != '.') && ((*p) != '\\0'); p++)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/18"}
{"code": "for (p++; (*p) != '\\0';)\n{\n  if ((*p) == '[')\n    level++;\n  else\n    if ((*p) == ']')\n  {\n    level--;\n    if (level == 0)\n      break;\n  }\n  *(q++) = *(p++);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/19"}
{"code": "for (p++; (*p) != '\\0';)\n{\n  if ((*p) == '{')\n    level++;\n  else\n    if ((*p) == '}')\n  {\n    level--;\n    if (level == 0)\n      break;\n  }\n  *(q++) = *(p++);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/20"}
{"code": "for (q = name + (strlen(name) - 1); q > name; q--)\n{\n  if ((*q) == ')')\n    break;\n  if ((*q) == '.')\n  {\n    *q = '\\0';\n    break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/21"}
{"code": "for (i = 0; i < ((ssize_t) GetOpenMPMaximumThreads()); i++)\n  if (fx_info[i] != ((FxInfo *) 0))\n  fx_info[i] = DestroyFxInfo(fx_info[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/22"}
{"code": "for (i = 0; i < ((ssize_t) number_threads); i++)\n{\n  fx_info[i] = AcquireFxInfo(image, fx_expression);\n  if (fx_info[i] == ((FxInfo *) 0))\n    return DestroyFxThreadSet(fx_info);\n  (void) FxPreprocessExpression(fx_info[i], &alpha, fx_info[i]->exception);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/23"}
{"code": "for (i = 1; i < ((ssize_t) number_frames); i++)\n{\n  morph_image = CloneImage(image, 0, 0, MagickTrue, exception);\n  if (morph_image == ((Image *) 0))\n  {\n    morph_images = DestroyImageList(morph_images);\n    return (Image *) 0;\n  }\n  AppendImageToList(&morph_images, morph_image);\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Morph/Image\", (MagickOffsetType) i, number_frames);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/24"}
{"code": "for (; GetNextImageInList(next) != ((Image *) 0); next = GetNextImageInList(next))\n{\n  for (i = 0; i < ((ssize_t) number_frames); i++)\n  {\n    CacheView *image_view;\n    CacheView *morph_view;\n    beta = ((MagickRealType) (i + 1.0)) / ((MagickRealType) (number_frames + 1.0));\n    alpha = 1.0 - beta;\n    morph_image = ResizeImage(next, (size_t) (((alpha * next->columns) + (beta * GetNextImageInList(next)->columns)) + 0.5), (size_t) (((alpha * next->rows) + (beta * GetNextImageInList(next)->rows)) + 0.5), next->filter, next->blur, exception);\n    if (morph_image == ((Image *) 0))\n    {\n      morph_images = DestroyImageList(morph_images);\n      return (Image *) 0;\n    }\n    if (SetImageStorageClass(morph_image, DirectClass) == MagickFalse)\n    {\n      InheritException(exception, &morph_image->exception);\n      morph_image = DestroyImage(morph_image);\n      return (Image *) 0;\n    }\n    AppendImageToList(&morph_images, morph_image);\n    morph_images = GetLastImageInList(morph_images);\n    morph_image = ResizeImage(GetNextImageInList(next), morph_images->columns, morph_images->rows, GetNextImageInList(next)->filter, GetNextImageInList(next)->blur, exception);\n    if (morph_image == ((Image *) 0))\n    {\n      morph_images = DestroyImageList(morph_images);\n      return (Image *) 0;\n    }\n    image_view = AcquireCacheView(morph_image);\n    morph_view = AcquireCacheView(morph_images);\n    #pragma omp parallel for schedule(dynamic,4) shared(status)\n    for (y = 0; y < ((ssize_t) morph_images->rows); y++)\n    {\n      MagickBooleanType sync;\n      const PixelPacket * restrict p;\n      ssize_t x;\n      PixelPacket * restrict q;\n      if (status == MagickFalse)\n        continue;\n      p = GetCacheViewVirtualPixels(image_view, 0, y, morph_image->columns, 1, exception);\n      q = GetCacheViewAuthenticPixels(morph_view, 0, y, morph_images->columns, 1, exception);\n      if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n      {\n        status = MagickFalse;\n        continue;\n      }\n      for (x = 0; x < ((ssize_t) morph_images->columns); x++)\n      {\n        SetPixelRed(q, ClampToQuantum((alpha * GetPixelRed(q)) + (beta * GetPixelRed(p))));\n        SetPixelGreen(q, ClampToQuantum((alpha * GetPixelGreen(q)) + (beta * GetPixelGreen(p))));\n        SetPixelBlue(q, ClampToQuantum((alpha * GetPixelBlue(q)) + (beta * GetPixelBlue(p))));\n        SetPixelOpacity(q, ClampToQuantum((alpha * GetPixelOpacity(q)) + (beta * GetPixelOpacity(p))));\n        p++;\n        q++;\n      }\n\n      sync = SyncCacheViewAuthenticPixels(morph_view, exception);\n      if (sync == MagickFalse)\n        status = MagickFalse;\n    }\n\n    morph_view = DestroyCacheView(morph_view);\n    image_view = DestroyCacheView(image_view);\n    morph_image = DestroyImage(morph_image);\n  }\n\n  if (i < ((ssize_t) number_frames))\n    break;\n  morph_image = CloneImage(GetNextImageInList(next), 0, 0, MagickTrue, exception);\n  if (morph_image == ((Image *) 0))\n  {\n    morph_images = DestroyImageList(morph_images);\n    return (Image *) 0;\n  }\n  AppendImageToList(&morph_images, morph_image);\n  morph_images = GetLastImageInList(morph_images);\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_MorphImages)\n    proceed = SetImageProgress(image, \"Morph/Image\", scene, GetImageListLength(image));\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n  scene++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/25"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if (((MagickRealType) image->colormap[i].red) > threshold)\n    image->colormap[i].red = ((Quantum) QuantumRange) - image->colormap[i].red;\n  if (((MagickRealType) image->colormap[i].green) > threshold)\n    image->colormap[i].green = ((Quantum) QuantumRange) - image->colormap[i].green;\n  if (((MagickRealType) image->colormap[i].blue) > threshold)\n    image->colormap[i].blue = ((Quantum) QuantumRange) - image->colormap[i].blue;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/26"}
{"code": "for (i = ((ssize_t) depth) - 1; (i >= 0) && (j < ((ssize_t) depth)); i--)\n{\n  for (y = 0; (y < ((ssize_t) watermark->rows)) && (j < ((ssize_t) depth)); y++)\n  {\n    for (x = 0; (x < ((ssize_t) watermark->columns)) && (j < ((ssize_t) depth)); x++)\n    {\n      (void) GetOneCacheViewVirtualPixel(watermark_view, x, y, &pixel, exception);\n      if ((k / ((ssize_t) stegano_image->columns)) >= ((ssize_t) stegano_image->rows))\n        break;\n      q = GetCacheViewAuthenticPixels(stegano_view, k % ((ssize_t) stegano_image->columns), k / ((ssize_t) stegano_image->columns), 1, 1, exception);\n      if (q == ((PixelPacket *) 0))\n        break;\n      switch (c)\n      {\n        case 0:\n        {\n          GetPixelRed(q) = (Quantum) (((((((size_t) PixelIntensityToQuantum(&pixel)) >> ((size_t) i)) & 0x01) != 0) != 0) ? (((size_t) GetPixelRed(q)) | (one << ((size_t) j))) : (((size_t) GetPixelRed(q)) & (~(one << ((size_t) j)))));\n          break;\n        }\n\n        case 1:\n        {\n          GetPixelGreen(q) = (Quantum) (((((((size_t) PixelIntensityToQuantum(&pixel)) >> ((size_t) i)) & 0x01) != 0) != 0) ? (((size_t) GetPixelGreen(q)) | (one << ((size_t) j))) : (((size_t) GetPixelGreen(q)) & (~(one << ((size_t) j)))));\n          break;\n        }\n\n        case 2:\n        {\n          GetPixelBlue(q) = (Quantum) (((((((size_t) PixelIntensityToQuantum(&pixel)) >> ((size_t) i)) & 0x01) != 0) != 0) ? (((size_t) GetPixelBlue(q)) | (one << ((size_t) j))) : (((size_t) GetPixelBlue(q)) & (~(one << ((size_t) j)))));\n          break;\n        }\n\n      }\n\n      if (SyncCacheViewAuthenticPixels(stegano_view, exception) == MagickFalse)\n        break;\n      c++;\n      if (c == 3)\n        c = 0;\n      k++;\n      if (k == ((ssize_t) (stegano_image->columns * stegano_image->columns)))\n        k = 0;\n      if (k == image->offset)\n        j++;\n    }\n\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Stegano/Image\", (MagickOffsetType) (depth - i), depth);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/27"}
{"code": "for (y = 0; y < ((ssize_t) stereo_image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  PixelPacket * restrict r;\n  p = GetVirtualPixels(left_image, -x_offset, y - y_offset, image->columns, 1, exception);\n  q = GetVirtualPixels(right_image, 0, y, right_image->columns, 1, exception);\n  r = QueueAuthenticPixels(stereo_image, 0, y, stereo_image->columns, 1, exception);\n  if (((p == ((PixelPacket *) 0)) || (q == ((PixelPacket *) 0))) || (r == ((PixelPacket *) 0)))\n    break;\n  for (x = 0; x < ((ssize_t) stereo_image->columns); x++)\n  {\n    SetPixelRed(r, GetPixelRed(p));\n    SetPixelGreen(r, GetPixelGreen(q));\n    SetPixelBlue(r, GetPixelBlue(q));\n    SetPixelOpacity(r, (GetPixelOpacity(p) + q->opacity) / 2);\n    p++;\n    q++;\n    r++;\n  }\n\n  if (SyncAuthenticPixels(stereo_image, exception) == MagickFalse)\n    break;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Stereo/Image\", (MagickOffsetType) y, stereo_image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/28"}
{"code": "for (i = 0; i < ((ssize_t) wave_image->columns); i++)\n  sine_map[i] = fabs(amplitude) + (amplitude * sin((double) (((2.0 * MagickPI) * i) / wave_length)));\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_fx/29"}
{"code": "for (y = 0; y < ((ssize_t) blur_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict r;\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  r = GetCacheViewVirtualPixels(edge_view, 0, y, edge_image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(blur_view, 0, y, blur_image->columns, 1, exception);\n  if ((r == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (x = 0; x < ((ssize_t) blur_image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    MagickRealType alpha;\n    MagickRealType gamma;\n    const double * restrict k;\n    ssize_t i;\n    ssize_t u;\n    ssize_t v;\n    gamma = 0.0;\n    i = (ssize_t) ceil(((((double) width) * QuantumScale) * PixelIntensity(r)) - 0.5);\n    if (i < 0)\n      i = 0;\n    else\n      if (i > ((ssize_t) width))\n      i = (ssize_t) width;\n    if ((i & 0x01) != 0)\n      i--;\n    p = GetCacheViewVirtualPixels(image_view, x - (((ssize_t) (width - i)) / 2L), y - ((ssize_t) ((width - i) / 2L)), width - i, width - i, exception);\n    if (p == ((const PixelPacket *) 0))\n      break;\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    pixel = bias;\n    k = kernel[i];\n    for (v = 0; v < ((ssize_t) (width - i)); v++)\n    {\n      for (u = 0; u < ((ssize_t) (width - i)); u++)\n      {\n        alpha = 1.0;\n        if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n          alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(p));\n        if ((channel & RedChannel) != 0)\n          pixel.red += ((*k) * alpha) * GetPixelRed(p);\n        if ((channel & GreenChannel) != 0)\n          pixel.green += ((*k) * alpha) * GetPixelGreen(p);\n        if ((channel & BlueChannel) != 0)\n          pixel.blue += ((*k) * alpha) * GetPixelBlue(p);\n        if ((channel & OpacityChannel) != 0)\n          pixel.opacity += (*k) * GetPixelOpacity(p);\n        if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n          pixel.index += ((*k) * alpha) * GetPixelIndex(((indexes + x) + ((width - i) * v)) + u);\n        gamma += (*k) * alpha;\n        k++;\n        p++;\n      }\n\n    }\n\n    gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * pixel.index));\n    q++;\n    r++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(blur_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_AdaptiveBlurImageChannel)\n    proceed = SetImageProgress(image, \"Convolve/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/0"}
{"code": "for (y = 0; y < ((ssize_t) sharp_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict r;\n  IndexPacket * restrict sharp_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  r = GetCacheViewVirtualPixels(edge_view, 0, y, edge_image->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(sharp_view, 0, y, sharp_image->columns, 1, exception);\n  if ((r == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  sharp_indexes = GetCacheViewAuthenticIndexQueue(sharp_view);\n  for (x = 0; x < ((ssize_t) sharp_image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    MagickRealType alpha;\n    MagickRealType gamma;\n    const double * restrict k;\n    ssize_t i;\n    ssize_t u;\n    ssize_t v;\n    gamma = 0.0;\n    i = (ssize_t) ceil((((double) width) * (QuantumRange - (QuantumScale * PixelIntensity(r)))) - 0.5);\n    if (i < 0)\n      i = 0;\n    else\n      if (i > ((ssize_t) width))\n      i = (ssize_t) width;\n    if ((i & 0x01) != 0)\n      i--;\n    p = GetCacheViewVirtualPixels(image_view, x - (((ssize_t) (width - i)) / 2L), y - ((ssize_t) ((width - i) / 2L)), width - i, width - i, exception);\n    if (p == ((const PixelPacket *) 0))\n      break;\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    k = kernel[i];\n    pixel = bias;\n    for (v = 0; v < ((ssize_t) (width - i)); v++)\n    {\n      for (u = 0; u < ((ssize_t) (width - i)); u++)\n      {\n        alpha = 1.0;\n        if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n          alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(p));\n        if ((channel & RedChannel) != 0)\n          pixel.red += ((*k) * alpha) * GetPixelRed(p);\n        if ((channel & GreenChannel) != 0)\n          pixel.green += ((*k) * alpha) * GetPixelGreen(p);\n        if ((channel & BlueChannel) != 0)\n          pixel.blue += ((*k) * alpha) * GetPixelBlue(p);\n        if ((channel & OpacityChannel) != 0)\n          pixel.opacity += (*k) * GetPixelOpacity(p);\n        if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n          pixel.index += ((*k) * alpha) * GetPixelIndex(((indexes + x) + ((width - i) * v)) + u);\n        gamma += (*k) * alpha;\n        k++;\n        p++;\n      }\n\n    }\n\n    gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(sharp_indexes + x, ClampToQuantum(gamma * pixel.index));\n    q++;\n    r++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(sharp_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_AdaptiveSharpenImageChannel)\n    proceed = SetImageProgress(image, \"Convolve/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/1"}
{"code": "for (y = 0; y < ((ssize_t) blur_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) width) / 2L), y, image->columns + width, 1, exception);\n  q = GetCacheViewAuthenticPixels(blur_view, 0, y, blur_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (x = 0; x < ((ssize_t) blur_image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    const double * restrict k;\n    const PixelPacket * restrict kernel_pixels;\n    ssize_t i;\n    pixel = bias;\n    k = kernel;\n    kernel_pixels = p;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        pixel.red += (*k) * GetPixelRed(kernel_pixels);\n        pixel.green += (*k) * GetPixelGreen(kernel_pixels);\n        pixel.blue += (*k) * GetPixelBlue(kernel_pixels);\n        k++;\n        kernel_pixels++;\n      }\n\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel;\n        kernel_pixels = p;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels);\n          k++;\n          kernel_pixels++;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel;\n        kernel_indexes = indexes;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.index += (*k) * GetPixelIndex(kernel_indexes);\n          k++;\n          kernel_indexes++;\n        }\n\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(pixel.index));\n      }\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      gamma = 0.0;\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(kernel_pixels));\n        pixel.red += ((*k) * alpha) * GetPixelRed(kernel_pixels);\n        pixel.green += ((*k) * alpha) * GetPixelGreen(kernel_pixels);\n        pixel.blue += ((*k) * alpha) * GetPixelBlue(kernel_pixels);\n        gamma += (*k) * alpha;\n        k++;\n        kernel_pixels++;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel;\n        kernel_pixels = p;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels);\n          k++;\n          kernel_pixels++;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel;\n        kernel_pixels = p;\n        kernel_indexes = indexes;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(kernel_pixels));\n          pixel.index += ((*k) * alpha) * (*kernel_indexes);\n          k++;\n          kernel_pixels++;\n          kernel_indexes++;\n        }\n\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * pixel.index));\n      }\n    }\n    indexes++;\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(blur_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_BlurImageChannel)\n    proceed = SetImageProgress(image, \"Blur/Image\", progress++, blur_image->rows + blur_image->columns);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/2"}
{"code": "for (x = 0; x < ((ssize_t) blur_image->columns); x++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t y;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, x, -(((ssize_t) width) / 2L), 1, image->rows + width, exception);\n  q = GetCacheViewAuthenticPixels(blur_view, x, 0, 1, blur_image->rows, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (y = 0; y < ((ssize_t) blur_image->rows); y++)\n  {\n    MagickPixelPacket pixel;\n    const double * restrict k;\n    const PixelPacket * restrict kernel_pixels;\n    ssize_t i;\n    pixel = bias;\n    k = kernel;\n    kernel_pixels = p;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        pixel.red += (*k) * GetPixelRed(kernel_pixels);\n        pixel.green += (*k) * GetPixelGreen(kernel_pixels);\n        pixel.blue += (*k) * GetPixelBlue(kernel_pixels);\n        k++;\n        kernel_pixels++;\n      }\n\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel;\n        kernel_pixels = p;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels);\n          k++;\n          kernel_pixels++;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel;\n        kernel_indexes = indexes;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.index += (*k) * GetPixelIndex(kernel_indexes);\n          k++;\n          kernel_indexes++;\n        }\n\n        SetPixelIndex(blur_indexes + y, ClampToQuantum(pixel.index));\n      }\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      gamma = 0.0;\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(kernel_pixels));\n        pixel.red += ((*k) * alpha) * GetPixelRed(kernel_pixels);\n        pixel.green += ((*k) * alpha) * GetPixelGreen(kernel_pixels);\n        pixel.blue += ((*k) * alpha) * GetPixelBlue(kernel_pixels);\n        gamma += (*k) * alpha;\n        k++;\n        kernel_pixels++;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel;\n        kernel_pixels = p;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels);\n          k++;\n          kernel_pixels++;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel;\n        kernel_pixels = p;\n        kernel_indexes = indexes;\n        for (i = 0; i < ((ssize_t) width); i++)\n        {\n          alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(kernel_pixels));\n          pixel.index += ((*k) * alpha) * (*kernel_indexes);\n          k++;\n          kernel_pixels++;\n          kernel_indexes++;\n        }\n\n        SetPixelIndex(blur_indexes + y, ClampToQuantum(gamma * pixel.index));\n      }\n    }\n    indexes++;\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(blur_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_BlurImageChannel)\n    proceed = SetImageProgress(image, \"Blur/Image\", progress++, blur_image->rows + blur_image->columns);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict convolve_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) width) / 2L), y - ((ssize_t) (width / 2L)), image->columns + width, width, exception);\n  q = GetCacheViewAuthenticPixels(convolve_view, 0, y, convolve_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  convolve_indexes = GetCacheViewAuthenticIndexQueue(convolve_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    const double * restrict k;\n    const PixelPacket * restrict kernel_pixels;\n    ssize_t u;\n    ssize_t v;\n    pixel = bias;\n    k = normal_kernel;\n    kernel_pixels = p;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (v = 0; v < ((ssize_t) width); v++)\n      {\n        for (u = 0; u < ((ssize_t) width); u++)\n        {\n          pixel.red += (*k) * kernel_pixels[u].red;\n          pixel.green += (*k) * kernel_pixels[u].green;\n          pixel.blue += (*k) * kernel_pixels[u].blue;\n          k++;\n        }\n\n        kernel_pixels += image->columns + width;\n      }\n\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = normal_kernel;\n        kernel_pixels = p;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            pixel.opacity += (*k) * kernel_pixels[u].opacity;\n            k++;\n          }\n\n          kernel_pixels += image->columns + width;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = normal_kernel;\n        kernel_indexes = indexes;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            pixel.index += (*k) * GetPixelIndex(kernel_indexes + u);\n            k++;\n          }\n\n          kernel_indexes += image->columns + width;\n        }\n\n        SetPixelIndex(convolve_indexes + x, ClampToQuantum(pixel.index));\n      }\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      gamma = 0.0;\n      for (v = 0; v < ((ssize_t) width); v++)\n      {\n        for (u = 0; u < ((ssize_t) width); u++)\n        {\n          alpha = (MagickRealType) (QuantumScale * (QuantumRange - kernel_pixels[u].opacity));\n          pixel.red += ((*k) * alpha) * kernel_pixels[u].red;\n          pixel.green += ((*k) * alpha) * kernel_pixels[u].green;\n          pixel.blue += ((*k) * alpha) * kernel_pixels[u].blue;\n          gamma += (*k) * alpha;\n          k++;\n        }\n\n        kernel_pixels += image->columns + width;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = normal_kernel;\n        kernel_pixels = p;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels + u);\n            k++;\n          }\n\n          kernel_pixels += image->columns + width;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = normal_kernel;\n        kernel_pixels = p;\n        kernel_indexes = indexes;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            alpha = (MagickRealType) (QuantumScale * (QuantumRange - kernel_pixels[u].opacity));\n            pixel.index += ((*k) * alpha) * GetPixelIndex(kernel_indexes + u);\n            k++;\n          }\n\n          kernel_pixels += image->columns + width;\n          kernel_indexes += image->columns + width;\n        }\n\n        SetPixelIndex(convolve_indexes + x, ClampToQuantum(gamma * pixel.index));\n      }\n    }\n    indexes++;\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(convolve_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ConvolveImageChannel)\n    proceed = SetImageProgress(image, \"Convolve/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict filter_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) kernel->width) / 2L), y - ((ssize_t) (kernel->height / 2L)), image->columns + kernel->width, kernel->height, exception);\n  q = GetCacheViewAuthenticPixels(filter_view, 0, y, filter_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  filter_indexes = GetCacheViewAuthenticIndexQueue(filter_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    const double * restrict k;\n    const PixelPacket * restrict kernel_pixels;\n    ssize_t u;\n    ssize_t v;\n    pixel = bias;\n    k = kernel->values;\n    kernel_pixels = p;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (v = 0; v < ((ssize_t) kernel->width); v++)\n      {\n        for (u = 0; u < ((ssize_t) kernel->height); u++)\n        {\n          pixel.red += (*k) * kernel_pixels[u].red;\n          pixel.green += (*k) * kernel_pixels[u].green;\n          pixel.blue += (*k) * kernel_pixels[u].blue;\n          k++;\n        }\n\n        kernel_pixels += image->columns + kernel->width;\n      }\n\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel->values;\n        kernel_pixels = p;\n        for (v = 0; v < ((ssize_t) kernel->width); v++)\n        {\n          for (u = 0; u < ((ssize_t) kernel->height); u++)\n          {\n            pixel.opacity += (*k) * kernel_pixels[u].opacity;\n            k++;\n          }\n\n          kernel_pixels += image->columns + kernel->width;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel->values;\n        kernel_indexes = indexes;\n        for (v = 0; v < ((ssize_t) kernel->width); v++)\n        {\n          for (u = 0; u < ((ssize_t) kernel->height); u++)\n          {\n            pixel.index += (*k) * GetPixelIndex(kernel_indexes + u);\n            k++;\n          }\n\n          kernel_indexes += image->columns + kernel->width;\n        }\n\n        SetPixelIndex(filter_indexes + x, ClampToQuantum(pixel.index));\n      }\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      gamma = 0.0;\n      for (v = 0; v < ((ssize_t) kernel->width); v++)\n      {\n        for (u = 0; u < ((ssize_t) kernel->height); u++)\n        {\n          alpha = (MagickRealType) (QuantumScale * (QuantumRange - GetPixelOpacity(kernel_pixels + u)));\n          pixel.red += ((*k) * alpha) * GetPixelRed(kernel_pixels + u);\n          pixel.green += ((*k) * alpha) * GetPixelGreen(kernel_pixels + u);\n          pixel.blue += ((*k) * alpha) * GetPixelBlue(kernel_pixels + u);\n          gamma += (*k) * alpha;\n          k++;\n        }\n\n        kernel_pixels += image->columns + kernel->width;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n      {\n        k = kernel->values;\n        kernel_pixels = p;\n        for (v = 0; v < ((ssize_t) kernel->width); v++)\n        {\n          for (u = 0; u < ((ssize_t) kernel->height); u++)\n          {\n            pixel.opacity += (*k) * GetPixelOpacity(kernel_pixels + u);\n            k++;\n          }\n\n          kernel_pixels += image->columns + kernel->width;\n        }\n\n        SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        const IndexPacket * restrict kernel_indexes;\n        k = kernel->values;\n        kernel_pixels = p;\n        kernel_indexes = indexes;\n        for (v = 0; v < ((ssize_t) kernel->width); v++)\n        {\n          for (u = 0; u < ((ssize_t) kernel->height); u++)\n          {\n            alpha = (MagickRealType) (QuantumScale * (QuantumRange - kernel_pixels[u].opacity));\n            pixel.index += ((*k) * alpha) * GetPixelIndex(kernel_indexes + u);\n            k++;\n          }\n\n          kernel_pixels += image->columns + kernel->width;\n          kernel_indexes += image->columns + kernel->width;\n        }\n\n        SetPixelIndex(filter_indexes + x, ClampToQuantum(gamma * pixel.index));\n      }\n    }\n    indexes++;\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(filter_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_FilterImageChannel)\n    proceed = SetImageProgress(image, \"Filter/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/5"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(blur_view, 0, y, blur_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket qixel;\n    PixelPacket pixel;\n    const IndexPacket * restrict indexes;\n    double * restrict k;\n    ssize_t i;\n    k = kernel;\n    qixel = bias;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        (void) GetOneCacheViewVirtualPixel(image_view, x + offset[i].x, y + offset[i].y, &pixel, exception);\n        qixel.red += (*k) * pixel.red;\n        qixel.green += (*k) * pixel.green;\n        qixel.blue += (*k) * pixel.blue;\n        qixel.opacity += (*k) * pixel.opacity;\n        if (image->colorspace == CMYKColorspace)\n        {\n          indexes = GetCacheViewVirtualIndexQueue(image_view);\n          qixel.index += (*k) * (*indexes);\n        }\n        k++;\n      }\n\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(qixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(qixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(qixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q, ClampToQuantum(qixel.opacity));\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(qixel.index));\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      alpha = 0.0;\n      gamma = 0.0;\n      for (i = 0; i < ((ssize_t) width); i++)\n      {\n        (void) GetOneCacheViewVirtualPixel(image_view, x + offset[i].x, y + offset[i].y, &pixel, exception);\n        alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(&pixel));\n        qixel.red += ((*k) * alpha) * pixel.red;\n        qixel.green += ((*k) * alpha) * pixel.green;\n        qixel.blue += ((*k) * alpha) * pixel.blue;\n        qixel.opacity += (*k) * pixel.opacity;\n        if (image->colorspace == CMYKColorspace)\n        {\n          indexes = GetCacheViewVirtualIndexQueue(image_view);\n          qixel.index += ((*k) * alpha) * GetPixelIndex(indexes);\n        }\n        gamma += (*k) * alpha;\n        k++;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * qixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * qixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * qixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q, ClampToQuantum(qixel.opacity));\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * qixel.index));\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(blur_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_MotionBlurImageChannel)\n    proceed = SetImageProgress(image, \"Blur/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/6"}
{"code": "for (y = 0; y < ((ssize_t) blur_image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(blur_view, 0, y, blur_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (x = 0; x < ((ssize_t) blur_image->columns); x++)\n  {\n    MagickPixelPacket qixel;\n    MagickRealType normalize;\n    MagickRealType radius;\n    PixelPacket pixel;\n    PointInfo center;\n    ssize_t i;\n    size_t step;\n    center.x = ((double) x) - blur_center.x;\n    center.y = ((double) y) - blur_center.y;\n    radius = hypot((double) center.x, center.y);\n    if (radius == 0)\n      step = 1;\n    else\n    {\n      step = (size_t) (blur_radius / radius);\n      if (step == 0)\n        step = 1;\n      else\n        if (step >= n)\n        step = n - 1;\n    }\n    normalize = 0.0;\n    qixel = bias;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (i = 0; i < ((ssize_t) n); i += (ssize_t) step)\n      {\n        (void) GetOneCacheViewVirtualPixel(image_view, (ssize_t) (((blur_center.x + (center.x * cos_theta[i])) - (center.y * sin_theta[i])) + 0.5), (ssize_t) (((blur_center.y + (center.x * sin_theta[i])) + (center.y * cos_theta[i])) + 0.5), &pixel, exception);\n        qixel.red += pixel.red;\n        qixel.green += pixel.green;\n        qixel.blue += pixel.blue;\n        qixel.opacity += pixel.opacity;\n        if (image->colorspace == CMYKColorspace)\n        {\n          indexes = GetCacheViewVirtualIndexQueue(image_view);\n          qixel.index += *indexes;\n        }\n        normalize += 1.0;\n      }\n\n      normalize = 1.0 / ((fabs((double) normalize) <= MagickEpsilon) ? (1.0) : (normalize));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(normalize * qixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(normalize * qixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(normalize * qixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q, ClampToQuantum(normalize * qixel.opacity));\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(normalize * qixel.index));\n    }\n    else\n    {\n      MagickRealType alpha;\n      MagickRealType gamma;\n      alpha = 1.0;\n      gamma = 0.0;\n      for (i = 0; i < ((ssize_t) n); i += (ssize_t) step)\n      {\n        (void) GetOneCacheViewVirtualPixel(image_view, (ssize_t) (((blur_center.x + (center.x * cos_theta[i])) - (center.y * sin_theta[i])) + 0.5), (ssize_t) (((blur_center.y + (center.x * sin_theta[i])) + (center.y * cos_theta[i])) + 0.5), &pixel, exception);\n        alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(&pixel));\n        qixel.red += alpha * pixel.red;\n        qixel.green += alpha * pixel.green;\n        qixel.blue += alpha * pixel.blue;\n        qixel.opacity += pixel.opacity;\n        if (image->colorspace == CMYKColorspace)\n        {\n          indexes = GetCacheViewVirtualIndexQueue(image_view);\n          qixel.index += alpha * (*indexes);\n        }\n        gamma += alpha;\n        normalize += 1.0;\n      }\n\n      gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n      normalize = 1.0 / ((fabs((double) normalize) <= MagickEpsilon) ? (1.0) : (normalize));\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, ClampToQuantum(gamma * qixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, ClampToQuantum(gamma * qixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, ClampToQuantum(gamma * qixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q, ClampToQuantum(normalize * qixel.opacity));\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * qixel.index));\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(blur_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_RadialBlurImageChannel)\n    proceed = SetImageProgress(image, \"Blur/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/7"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  MagickRealType gamma;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict blur_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) width) / 2L), y - ((ssize_t) (width / 2L)), image->columns + width, width, exception);\n  q = GetCacheViewAuthenticPixels(blur_view, 0, y, blur_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  blur_indexes = GetCacheViewAuthenticIndexQueue(blur_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    const double * restrict k;\n    ssize_t u;\n    ssize_t j;\n    ssize_t v;\n    pixel = bias;\n    k = kernel;\n    gamma = 0.0;\n    j = 0;\n    if (((channel & OpacityChannel) == 0) || (image->matte == MagickFalse))\n    {\n      for (v = 0; v < ((ssize_t) width); v++)\n      {\n        for (u = 0; u < ((ssize_t) width); u++)\n        {\n          if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n          {\n            pixel.red += (*k) * GetPixelRed((p + u) + j);\n            pixel.green += (*k) * GetPixelGreen((p + u) + j);\n            pixel.blue += (*k) * GetPixelBlue((p + u) + j);\n            gamma += *k;\n            k++;\n          }\n        }\n\n        j += (ssize_t) (image->columns + width);\n      }\n\n      if (gamma != 0.0)\n      {\n        gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n        if ((channel & RedChannel) != 0)\n          SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n        if ((channel & GreenChannel) != 0)\n          SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n        if ((channel & BlueChannel) != 0)\n          SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      }\n      if ((channel & OpacityChannel) != 0)\n      {\n        gamma = 0.0;\n        j = 0;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n            {\n              pixel.opacity += (*k) * ((p + u) + j)->opacity;\n              gamma += *k;\n              k++;\n            }\n          }\n\n          j += (ssize_t) (image->columns + width);\n        }\n\n        if (gamma != 0.0)\n        {\n          gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n          SetPixelOpacity(q, ClampToQuantum(gamma * pixel.opacity));\n        }\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        gamma = 0.0;\n        j = 0;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n            {\n              pixel.index += (*k) * GetPixelIndex(((indexes + x) + u) + j);\n              gamma += *k;\n              k++;\n            }\n          }\n\n          j += (ssize_t) (image->columns + width);\n        }\n\n        if (gamma != 0.0)\n        {\n          gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n          SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * pixel.index));\n        }\n      }\n    }\n    else\n    {\n      MagickRealType alpha;\n      for (v = 0; v < ((ssize_t) width); v++)\n      {\n        for (u = 0; u < ((ssize_t) width); u++)\n        {\n          if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n          {\n            alpha = (MagickRealType) (QuantumScale * GetPixelAlpha((p + u) + j));\n            pixel.red += ((*k) * alpha) * GetPixelRed((p + u) + j);\n            pixel.green += ((*k) * alpha) * GetPixelGreen((p + u) + j);\n            pixel.blue += ((*k) * alpha) * GetPixelBlue((p + u) + j);\n            pixel.opacity += (*k) * GetPixelOpacity((p + u) + j);\n            gamma += (*k) * alpha;\n            k++;\n          }\n        }\n\n        j += (ssize_t) (image->columns + width);\n      }\n\n      if (gamma != 0.0)\n      {\n        gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n        if ((channel & RedChannel) != 0)\n          SetPixelRed(q, ClampToQuantum(gamma * pixel.red));\n        if ((channel & GreenChannel) != 0)\n          SetPixelGreen(q, ClampToQuantum(gamma * pixel.green));\n        if ((channel & BlueChannel) != 0)\n          SetPixelBlue(q, ClampToQuantum(gamma * pixel.blue));\n      }\n      if ((channel & OpacityChannel) != 0)\n      {\n        gamma = 0.0;\n        j = 0;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n            {\n              pixel.opacity += (*k) * GetPixelOpacity((p + u) + j);\n              gamma += *k;\n              k++;\n            }\n          }\n\n          j += (ssize_t) (image->columns + width);\n        }\n\n        if (gamma != 0.0)\n        {\n          gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n          SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n        }\n      }\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      {\n        gamma = 0.0;\n        j = 0;\n        for (v = 0; v < ((ssize_t) width); v++)\n        {\n          for (u = 0; u < ((ssize_t) width); u++)\n          {\n            if (SelectiveContrast((p + u) + j, q, threshold) != MagickFalse)\n            {\n              alpha = (MagickRealType) (QuantumScale * GetPixelAlpha((p + u) + j));\n              pixel.index += ((*k) * alpha) * GetPixelIndex(((indexes + x) + u) + j);\n              gamma += *k;\n              k++;\n            }\n          }\n\n          j += (ssize_t) (image->columns + width);\n        }\n\n        if (gamma != 0.0)\n        {\n          gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n          SetPixelIndex(blur_indexes + x, ClampToQuantum(gamma * pixel.index));\n        }\n      }\n    }\n    p++;\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(blur_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SelectiveBlurImageChannel)\n    proceed = SetImageProgress(image, \"SelectiveBlur/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/8"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickRealType distance;\n  MagickRealType normal_distance;\n  MagickRealType shade;\n  PrimaryInfo normal;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict s0;\n  const PixelPacket * restrict s1;\n  const PixelPacket * restrict s2;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -1, y - 1, image->columns + 2, 3, exception);\n  q = QueueCacheViewAuthenticPixels(shade_view, 0, y, shade_image->columns, 1, exception);\n  if ((p == ((PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  normal.z = 2.0 * ((double) QuantumRange);\n  s0 = p + 1;\n  s1 = (s0 + image->columns) + 2;\n  s2 = (s1 + image->columns) + 2;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    normal.x = (double) (((((PixelIntensity(s0 - 1) + PixelIntensity(s1 - 1)) + PixelIntensity(s2 - 1)) - PixelIntensity(s0 + 1)) - PixelIntensity(s1 + 1)) - PixelIntensity(s2 + 1));\n    normal.y = (double) (((((PixelIntensity(s2 - 1) + PixelIntensity(s2)) + PixelIntensity(s2 + 1)) - PixelIntensity(s0 - 1)) - PixelIntensity(s0)) - PixelIntensity(s0 + 1));\n    if ((normal.x == 0.0) && (normal.y == 0.0))\n      shade = light.z;\n    else\n    {\n      shade = 0.0;\n      distance = ((normal.x * light.x) + (normal.y * light.y)) + (normal.z * light.z);\n      if (distance > MagickEpsilon)\n      {\n        normal_distance = ((normal.x * normal.x) + (normal.y * normal.y)) + (normal.z * normal.z);\n        if (normal_distance > (MagickEpsilon * MagickEpsilon))\n          shade = distance / sqrt((double) normal_distance);\n      }\n    }\n    if (gray != MagickFalse)\n    {\n      SetPixelRed(q, shade);\n      SetPixelGreen(q, shade);\n      SetPixelBlue(q, shade);\n    }\n    else\n    {\n      SetPixelRed(q, ClampToQuantum((QuantumScale * shade) * GetPixelRed(s1)));\n      SetPixelGreen(q, ClampToQuantum((QuantumScale * shade) * GetPixelGreen(s1)));\n      SetPixelBlue(q, ClampToQuantum((QuantumScale * shade) * GetPixelBlue(s1)));\n    }\n    q->opacity = s1->opacity;\n    s0++;\n    s1++;\n    s2++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(shade_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ShadeImage)\n    proceed = SetImageProgress(image, \"Shade/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/9"}
{"code": "for (y = 0; y < ((ssize_t) spread_image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = QueueCacheViewAuthenticPixels(spread_view, 0, y, spread_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(spread_view);\n  pixel = bias;\n  for (x = 0; x < ((ssize_t) spread_image->columns); x++)\n  {\n    (void) InterpolateMagickPixelPacket(image, image_view, UndefinedInterpolatePixel, ((double) x) + (width * (GetPseudoRandomValue(random_info[id]) - 0.5)), ((double) y) + (width * (GetPseudoRandomValue(random_info[id]) - 0.5)), &pixel, exception);\n    SetPixelPacket(spread_image, &pixel, q, indexes + x);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(spread_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SpreadImage)\n    proceed = SetImageProgress(image, \"Spread/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/10"}
{"code": "for (y = 0; y < ((ssize_t) statistic_image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict statistic_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -(((ssize_t) ((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width))) / 2L), y - ((ssize_t) (((height == 0) ? (GetOptimalKernelWidth2D((double) height, 0.5)) : (height)) / 2L)), image->columns + ((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width)), (height == 0) ? (GetOptimalKernelWidth2D((double) height, 0.5)) : (height), exception);\n  q = QueueCacheViewAuthenticPixels(statistic_view, 0, y, statistic_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  statistic_indexes = GetCacheViewAuthenticIndexQueue(statistic_view);\n  for (x = 0; x < ((ssize_t) statistic_image->columns); x++)\n  {\n    MagickPixelPacket pixel;\n    const IndexPacket * restrict s;\n    const PixelPacket * restrict r;\n    ssize_t u;\n    ssize_t v;\n    r = p;\n    s = indexes + x;\n    ResetPixelList(pixel_list[id]);\n    for (v = 0; v < ((ssize_t) ((height == 0) ? (GetOptimalKernelWidth2D((double) height, 0.5)) : (height))); v++)\n    {\n      for (u = 0; u < ((ssize_t) ((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width))); u++)\n        InsertPixelList(image, r + u, s + u, pixel_list[id]);\n\n      r += image->columns + ((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width));\n      s += image->columns + ((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width));\n    }\n\n    GetMagickPixelPacket(image, &pixel);\n    SetMagickPixelPacket(image, p + ((((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width)) * ((height == 0) ? (GetOptimalKernelWidth2D((double) height, 0.5)) : (height))) / 2), (indexes + ((((width == 0) ? (GetOptimalKernelWidth2D((double) width, 0.5)) : (width)) * ((height == 0) ? (GetOptimalKernelWidth2D((double) height, 0.5)) : (height))) / 2)) + x, &pixel);\n    switch (type)\n    {\n      case GradientStatistic:\n      {\n        MagickPixelPacket maximum;\n        MagickPixelPacket minimum;\n        minimum = GetMinimumPixelList(pixel_list[id]);\n        maximum = GetMaximumPixelList(pixel_list[id]);\n        pixel.red = MagickAbsoluteValue(maximum.red - minimum.red);\n        pixel.green = MagickAbsoluteValue(maximum.green - minimum.green);\n        pixel.blue = MagickAbsoluteValue(maximum.blue - minimum.blue);\n        pixel.opacity = MagickAbsoluteValue(maximum.opacity - minimum.opacity);\n        if (image->colorspace == CMYKColorspace)\n          pixel.index = MagickAbsoluteValue(maximum.index - minimum.index);\n        break;\n      }\n\n      case MaximumStatistic:\n      {\n        pixel = GetMaximumPixelList(pixel_list[id]);\n        break;\n      }\n\n      case MeanStatistic:\n      {\n        pixel = GetMeanPixelList(pixel_list[id]);\n        break;\n      }\n\n      case MedianStatistic:\n\n      default:\n      {\n        pixel = GetMedianPixelList(pixel_list[id]);\n        break;\n      }\n\n      case MinimumStatistic:\n      {\n        pixel = GetMinimumPixelList(pixel_list[id]);\n        break;\n      }\n\n      case ModeStatistic:\n      {\n        pixel = GetModePixelList(pixel_list[id]);\n        break;\n      }\n\n      case NonpeakStatistic:\n      {\n        pixel = GetNonpeakPixelList(pixel_list[id]);\n        break;\n      }\n\n      case StandardDeviationStatistic:\n      {\n        pixel = GetStandardDeviationPixelList(pixel_list[id]);\n        break;\n      }\n\n    }\n\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(pixel.red));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(pixel.green));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(pixel.blue));\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n      SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(statistic_indexes + x, ClampToQuantum(pixel.index));\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(statistic_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_StatisticImage)\n    proceed = SetImageProgress(image, \"Statistic/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict unsharp_indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(unsharp_view, 0, y, unsharp_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  unsharp_indexes = GetCacheViewAuthenticIndexQueue(unsharp_view);\n  pixel = bias;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n    {\n      pixel.red = GetPixelRed(p) - ((MagickRealType) GetPixelRed(q));\n      if (fabs(2.0 * pixel.red) < quantum_threshold)\n        pixel.red = (MagickRealType) GetPixelRed(p);\n      else\n        pixel.red = ((MagickRealType) GetPixelRed(p)) + (pixel.red * amount);\n      SetPixelRed(q, ClampToQuantum(pixel.red));\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      pixel.green = GetPixelGreen(p) - ((MagickRealType) q->green);\n      if (fabs(2.0 * pixel.green) < quantum_threshold)\n        pixel.green = (MagickRealType) GetPixelGreen(p);\n      else\n        pixel.green = ((MagickRealType) GetPixelGreen(p)) + (pixel.green * amount);\n      SetPixelGreen(q, ClampToQuantum(pixel.green));\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      pixel.blue = GetPixelBlue(p) - ((MagickRealType) q->blue);\n      if (fabs(2.0 * pixel.blue) < quantum_threshold)\n        pixel.blue = (MagickRealType) GetPixelBlue(p);\n      else\n        pixel.blue = ((MagickRealType) GetPixelBlue(p)) + (pixel.blue * amount);\n      SetPixelBlue(q, ClampToQuantum(pixel.blue));\n    }\n    if ((channel & OpacityChannel) != 0)\n    {\n      pixel.opacity = GetPixelOpacity(p) - ((MagickRealType) q->opacity);\n      if (fabs(2.0 * pixel.opacity) < quantum_threshold)\n        pixel.opacity = (MagickRealType) GetPixelOpacity(p);\n      else\n        pixel.opacity = GetPixelOpacity(p) + (pixel.opacity * amount);\n      SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      pixel.index = GetPixelIndex(indexes + x) - ((MagickRealType) GetPixelIndex(unsharp_indexes + x));\n      if (fabs(2.0 * pixel.index) < quantum_threshold)\n        pixel.index = (MagickRealType) GetPixelIndex(indexes + x);\n      else\n        pixel.index = ((MagickRealType) GetPixelIndex(indexes + x)) + (pixel.index * amount);\n      SetPixelIndex(unsharp_indexes + x, ClampToQuantum(pixel.index));\n    }\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(unsharp_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_UnsharpMaskImageChannel)\n    proceed = SetImageProgress(image, \"Sharpen/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/12"}
{"code": "for (i = 0; i < ((ssize_t) width); i += 2)\n{\n  kernel[i] = (double *) AcquireQuantumMemory((size_t) (width - i), (width - i) * (sizeof(*(*kernel))));\n  if (kernel[i] == ((double *) 0))\n    break;\n  normalize = 0.0;\n  j = ((ssize_t) (width - i)) / 2;\n  k = 0;\n  for (v = -j; v <= j; v++)\n  {\n    for (u = -j; u <= j; u++)\n    {\n      kernel[i][k] = (double) (exp((-((((double) u) * u) + (v * v))) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma)))) / (((2.0 * MagickPI) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n      normalize += kernel[i][k];\n      k++;\n    }\n\n  }\n\n  if (fabs(normalize) <= MagickEpsilon)\n    normalize = 1.0;\n  normalize = 1.0 / normalize;\n  for (k = 0; k < (j * j); k++)\n    kernel[i][k] = normalize * kernel[i][k];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/13"}
{"code": "for (i -= 2; i >= 0; i -= 2)\n  kernel[i] = (double *) RelinquishMagickMemory(kernel[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/14"}
{"code": "for (i = 0; i < ((ssize_t) width); i += 2)\n  kernel[i] = (double *) RelinquishMagickMemory(kernel[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/15"}
{"code": "for (i = 0; i < ((ssize_t) width); i += 2)\n{\n  kernel[i] = (double *) AcquireQuantumMemory((size_t) (width - i), (width - i) * (sizeof(*(*kernel))));\n  if (kernel[i] == ((double *) 0))\n    break;\n  normalize = 0.0;\n  j = ((ssize_t) (width - i)) / 2;\n  k = 0;\n  for (v = -j; v <= j; v++)\n  {\n    for (u = -j; u <= j; u++)\n    {\n      kernel[i][k] = (double) ((-exp((-((((double) u) * u) + (v * v))) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))))) / (((2.0 * MagickPI) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n      normalize += kernel[i][k];\n      k++;\n    }\n\n  }\n\n  if (fabs(normalize) <= MagickEpsilon)\n    normalize = 1.0;\n  normalize = 1.0 / normalize;\n  for (k = 0; k < (j * j); k++)\n    kernel[i][k] = normalize * kernel[i][k];\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/16"}
{"code": "for (k = -j; k <= j; k++)\n{\n  kernel[i] = (double) (exp((-(((double) k) * k)) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma)))) / (MagickSQ2PI * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n  normalize += kernel[i];\n  i++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/17"}
{"code": "for (i = 0; i < ((ssize_t) width); i++)\n  kernel[i] /= normalize;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/18"}
{"code": "for (i = 0; i < ((ssize_t) width); i++)\n{\n  *message = '\\0';\n  (void) FormatLocaleString(format, MaxTextExtent, \"%.20g: \", (double) i);\n  (void) ConcatenateString(&message, format);\n  (void) FormatLocaleString(format, MaxTextExtent, \"%g \", *(k++));\n  (void) ConcatenateString(&message, format);\n  (void) LogMagickEvent(TransformEvent, GetMagickModule(), \"%s\", message);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/19"}
{"code": "for (v = 0; v < ((ssize_t) width); v++)\n{\n  *message = '\\0';\n  (void) FormatLocaleString(format, MaxTextExtent, \"%.20g: \", (double) v);\n  (void) ConcatenateString(&message, format);\n  for (u = 0; u < ((ssize_t) width); u++)\n  {\n    (void) FormatLocaleString(format, MaxTextExtent, \"%g \", *(k++));\n    (void) ConcatenateString(&message, format);\n  }\n\n  (void) LogMagickEvent(TransformEvent, GetMagickModule(), \"%s\", message);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/20"}
{"code": "for (i = 0; i < ((ssize_t) (width * width)); i++)\n  gamma += kernel[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/21"}
{"code": "for (i = 0; i < ((ssize_t) (width * width)); i++)\n  normal_kernel[i] = gamma * kernel[i];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/22"}
{"code": "for (y = 0; y < ((ssize_t) rows); y++)\n{\n  p++;\n  q++;\n  r++;\n  if (polarity > 0)\n    for (x = (ssize_t) columns; x != 0; x--)\n  {\n    v = (MagickRealType) (*p);\n    if (((MagickRealType) (*r)) >= (v + ((MagickRealType) ScaleCharToQuantum(2))))\n      v += ScaleCharToQuantum(1);\n    *q = (Quantum) v;\n    p++;\n    q++;\n    r++;\n  }\n\n  else\n    for (x = (ssize_t) columns; x != 0; x--)\n  {\n    v = (MagickRealType) (*p);\n    if (((MagickRealType) (*r)) <= (v - ((MagickRealType) ScaleCharToQuantum(2))))\n      v -= (ssize_t) ScaleCharToQuantum(1);\n    *q = (Quantum) v;\n    p++;\n    q++;\n    r++;\n  }\n\n  p++;\n  q++;\n  r++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/23"}
{"code": "for (y = 0; y < ((ssize_t) rows); y++)\n{\n  p++;\n  q++;\n  r++;\n  s++;\n  if (polarity > 0)\n    for (x = (ssize_t) columns; x != 0; x--)\n  {\n    v = (MagickRealType) (*q);\n    if ((((MagickRealType) (*s)) >= (v + ((MagickRealType) ScaleCharToQuantum(2)))) && (((MagickRealType) (*r)) > v))\n      v += ScaleCharToQuantum(1);\n    *p = (Quantum) v;\n    p++;\n    q++;\n    r++;\n    s++;\n  }\n\n  else\n    for (x = (ssize_t) columns; x != 0; x--)\n  {\n    v = (MagickRealType) (*q);\n    if ((((MagickRealType) (*s)) <= (v - ((MagickRealType) ScaleCharToQuantum(2)))) && (((MagickRealType) (*r)) < v))\n      v -= (MagickRealType) ScaleCharToQuantum(1);\n    *p = (Quantum) v;\n    p++;\n    q++;\n    r++;\n    s++;\n  }\n\n  p++;\n  q++;\n  r++;\n  s++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/24"}
{"code": "for (i = 0; i < ((ssize_t) number_channels); i++)\n{\n  Quantum *buffer;\n  Quantum *pixel;\n  ssize_t k;\n  ssize_t x;\n  ssize_t j;\n  ssize_t y;\n  if (status == MagickFalse)\n    continue;\n  pixel = pixels;\n  (void) ResetMagickMemory(pixel, 0, length * (sizeof(*pixel)));\n  buffer = buffers;\n  j = ((ssize_t) image->columns) + 2;\n  for (y = 0; y < ((ssize_t) image->rows); y++)\n  {\n    const IndexPacket * restrict indexes;\n    const PixelPacket * restrict p;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n    if (p == ((const PixelPacket *) 0))\n      break;\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    j++;\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    {\n      switch (i)\n      {\n        case 0:\n          pixel[j] = GetPixelRed(p);\n          break;\n\n        case 1:\n          pixel[j] = GetPixelGreen(p);\n          break;\n\n        case 2:\n          pixel[j] = GetPixelBlue(p);\n          break;\n\n        case 3:\n          pixel[j] = GetPixelOpacity(p);\n          break;\n\n        case 4:\n          pixel[j] = GetPixelBlack(indexes + x);\n          break;\n\n        default:\n          break;\n\n      }\n\n      p++;\n      j++;\n    }\n\n    j++;\n  }\n\n  (void) ResetMagickMemory(buffer, 0, length * (sizeof(*buffer)));\n  for (k = 0; k < 4; k++)\n  {\n    Hull(X[k], Y[k], image->columns, image->rows, pixel, buffer, 1);\n    Hull(-X[k], -Y[k], image->columns, image->rows, pixel, buffer, 1);\n    Hull(-X[k], -Y[k], image->columns, image->rows, pixel, buffer, -1);\n    Hull(X[k], Y[k], image->columns, image->rows, pixel, buffer, -1);\n  }\n\n  j = ((ssize_t) image->columns) + 2;\n  for (y = 0; y < ((ssize_t) image->rows); y++)\n  {\n    MagickBooleanType sync;\n    IndexPacket * restrict indexes;\n    PixelPacket * restrict q;\n    q = GetCacheViewAuthenticPixels(despeckle_view, 0, y, despeckle_image->columns, 1, exception);\n    if (q == ((PixelPacket *) 0))\n      break;\n    indexes = GetCacheViewAuthenticIndexQueue(image_view);\n    j++;\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    {\n      switch (i)\n      {\n        case 0:\n          SetPixelRed(q, pixel[j]);\n          break;\n\n        case 1:\n          SetPixelGreen(q, pixel[j]);\n          break;\n\n        case 2:\n          SetPixelBlue(q, pixel[j]);\n          break;\n\n        case 3:\n          SetPixelOpacity(q, pixel[j]);\n          break;\n\n        case 4:\n          SetPixelIndex(indexes + x, pixel[j]);\n          break;\n\n        default:\n          break;\n\n      }\n\n      q++;\n      j++;\n    }\n\n    sync = SyncCacheViewAuthenticPixels(despeckle_view, exception);\n    if (sync == MagickFalse)\n    {\n      status = MagickFalse;\n      break;\n    }\n    j++;\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Despeckle/Image\", (MagickOffsetType) i, number_channels);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/25"}
{"code": "for (i = 0; i < ((ssize_t) (width * width)); i++)\n  kernel[i] = -1.0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/26"}
{"code": "for (v = -j; v <= j; v++)\n{\n  for (u = -j; u <= j; u++)\n  {\n    kernel[i] = (double) (((((u < 0) || (v < 0)) ? (-8.0) : (8.0)) * exp((-((((double) u) * u) + (v * v))) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))))) / (((2.0 * MagickPI) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n    if (u != k)\n      kernel[i] = 0.0;\n    i++;\n  }\n\n  k--;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/27"}
{"code": "for (v = 0; v < ((ssize_t) kernel->height); v++)\n{\n  *message = '\\0';\n  (void) FormatLocaleString(format, MaxTextExtent, \"%.20g: \", (double) v);\n  (void) ConcatenateString(&message, format);\n  for (u = 0; u < ((ssize_t) kernel->width); u++)\n  {\n    (void) FormatLocaleString(format, MaxTextExtent, \"%g \", *(k++));\n    (void) ConcatenateString(&message, format);\n  }\n\n  (void) LogMagickEvent(TransformEvent, GetMagickModule(), \"%s\", message);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/28"}
{"code": "for (v = -j; v <= j; v++)\n{\n  for (u = -j; u <= j; u++)\n    kernel[i++] = (double) (exp((-((((double) u) * u) + (v * v))) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma)))) / (((2.0 * MagickPI) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/29"}
{"code": "for (i = 0; i < ((ssize_t) width); i++)\n{\n  kernel[i] = (double) (exp((-(((double) i) * i)) / ((double) ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))))) / (MagickSQ2PI * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n  normalize += kernel[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/30"}
{"code": "for (i = 0; i < ((ssize_t) width); i++)\n{\n  offset[i].x = (ssize_t) ceil((((double) (i * point.y)) / hypot(point.x, point.y)) - 0.5);\n  offset[i].y = (ssize_t) ceil((((double) (i * point.x)) / hypot(point.x, point.y)) - 0.5);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/31"}
{"code": "for (i = 0; i < 9; i++)\n{\n  thumbnail = ThumbnailImage(image, geometry.width, geometry.height, exception);\n  if (thumbnail == ((Image *) 0))\n    break;\n  (void) SetImageProgressMonitor(thumbnail, (MagickProgressMonitor) 0, (void *) 0);\n  (void) SetImageProperty(thumbnail, \"label\", DefaultTileLabel);\n  if (i == (9 / 2))\n  {\n    (void) QueryColorDatabase(\"#dfdfdf\", &thumbnail->matte_color, exception);\n    AppendImageToList(&images, thumbnail);\n    continue;\n  }\n  switch (preview)\n  {\n    case RotatePreview:\n    {\n      degrees += 45.0;\n      preview_image = RotateImage(thumbnail, degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"rotate %g\", degrees);\n      break;\n    }\n\n    case ShearPreview:\n    {\n      degrees += 5.0;\n      preview_image = ShearImage(thumbnail, degrees, degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"shear %gx%g\", degrees, 2.0 * degrees);\n      break;\n    }\n\n    case RollPreview:\n    {\n      x = ((ssize_t) ((i + 1) * thumbnail->columns)) / 9;\n      y = ((ssize_t) ((i + 1) * thumbnail->rows)) / 9;\n      preview_image = RollImage(thumbnail, x, y, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"roll %+.20gx%+.20g\", (double) x, (double) y);\n      break;\n    }\n\n    case HuePreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) FormatLocaleString(factor, MaxTextExtent, \"100,100,%g\", 2.0 * percentage);\n      (void) ModulateImage(preview_image, factor);\n      (void) FormatLocaleString(label, MaxTextExtent, \"modulate %s\", factor);\n      break;\n    }\n\n    case SaturationPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) FormatLocaleString(factor, MaxTextExtent, \"100,%g\", 2.0 * percentage);\n      (void) ModulateImage(preview_image, factor);\n      (void) FormatLocaleString(label, MaxTextExtent, \"modulate %s\", factor);\n      break;\n    }\n\n    case BrightnessPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) FormatLocaleString(factor, MaxTextExtent, \"%g\", 2.0 * percentage);\n      (void) ModulateImage(preview_image, factor);\n      (void) FormatLocaleString(label, MaxTextExtent, \"modulate %s\", factor);\n      break;\n    }\n\n    case GammaPreview:\n\n    default:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      gamma += 0.4f;\n      (void) GammaImageChannel(preview_image, DefaultChannels, gamma);\n      (void) FormatLocaleString(label, MaxTextExtent, \"gamma %g\", gamma);\n      break;\n    }\n\n    case SpiffPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image != ((Image *) 0))\n        for (x = 0; x < i; x++)\n        (void) ContrastImage(preview_image, MagickTrue);\n\n      (void) FormatLocaleString(label, MaxTextExtent, \"contrast (%.20g)\", ((double) i) + 1);\n      break;\n    }\n\n    case DullPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      for (x = 0; x < i; x++)\n        (void) ContrastImage(preview_image, MagickFalse);\n\n      (void) FormatLocaleString(label, MaxTextExtent, \"+contrast (%.20g)\", ((double) i) + 1);\n      break;\n    }\n\n    case GrayscalePreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      colors <<= 1;\n      quantize_info.number_colors = colors;\n      quantize_info.colorspace = GRAYColorspace;\n      (void) QuantizeImage(&quantize_info, preview_image);\n      (void) FormatLocaleString(label, MaxTextExtent, \"-colorspace gray -colors %.20g\", (double) colors);\n      break;\n    }\n\n    case QuantizePreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      colors <<= 1;\n      quantize_info.number_colors = colors;\n      (void) QuantizeImage(&quantize_info, preview_image);\n      (void) FormatLocaleString(label, MaxTextExtent, \"colors %.20g\", (double) colors);\n      break;\n    }\n\n    case DespecklePreview:\n    {\n      for (x = 0; x < (i - 1); x++)\n      {\n        preview_image = DespeckleImage(thumbnail, exception);\n        if (preview_image == ((Image *) 0))\n          break;\n        thumbnail = DestroyImage(thumbnail);\n        thumbnail = preview_image;\n      }\n\n      preview_image = DespeckleImage(thumbnail, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) FormatLocaleString(label, MaxTextExtent, \"despeckle (%.20g)\", ((double) i) + 1);\n      break;\n    }\n\n    case ReduceNoisePreview:\n    {\n      preview_image = StatisticImage(thumbnail, NonpeakStatistic, (size_t) radius, (size_t) radius, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"noise %g\", radius);\n      break;\n    }\n\n    case AddNoisePreview:\n    {\n      switch ((int) i)\n      {\n        case 0:\n        {\n          (void) CopyMagickString(factor, \"uniform\", MaxTextExtent);\n          break;\n        }\n\n        case 1:\n        {\n          (void) CopyMagickString(factor, \"gaussian\", MaxTextExtent);\n          break;\n        }\n\n        case 2:\n        {\n          (void) CopyMagickString(factor, \"multiplicative\", MaxTextExtent);\n          break;\n        }\n\n        case 3:\n        {\n          (void) CopyMagickString(factor, \"impulse\", MaxTextExtent);\n          break;\n        }\n\n        case 4:\n        {\n          (void) CopyMagickString(factor, \"laplacian\", MaxTextExtent);\n          break;\n        }\n\n        case 5:\n        {\n          (void) CopyMagickString(factor, \"Poisson\", MaxTextExtent);\n          break;\n        }\n\n        default:\n        {\n          (void) CopyMagickString(thumbnail->magick, \"NULL\", MaxTextExtent);\n          break;\n        }\n\n      }\n\n      preview_image = StatisticImage(thumbnail, NonpeakStatistic, (size_t) i, (size_t) i, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"+noise %s\", factor);\n      break;\n    }\n\n    case SharpenPreview:\n    {\n      preview_image = SharpenImage(thumbnail, radius, sigma, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"sharpen %gx%g\", radius, sigma);\n      break;\n    }\n\n    case BlurPreview:\n    {\n      preview_image = BlurImage(thumbnail, radius, sigma, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"blur %gx%g\", radius, sigma);\n      break;\n    }\n\n    case ThresholdPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) BilevelImage(thumbnail, ((double) (percentage * (((MagickRealType) QuantumRange) + 1.0))) / 100.0);\n      (void) FormatLocaleString(label, MaxTextExtent, \"threshold %g\", ((double) (percentage * (((MagickRealType) QuantumRange) + 1.0))) / 100.0);\n      break;\n    }\n\n    case EdgeDetectPreview:\n    {\n      preview_image = EdgeImage(thumbnail, radius, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"edge %g\", radius);\n      break;\n    }\n\n    case SpreadPreview:\n    {\n      preview_image = SpreadImage(thumbnail, radius, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"spread %g\", radius + 0.5);\n      break;\n    }\n\n    case SolarizePreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      (void) SolarizeImage(preview_image, (((double) QuantumRange) * percentage) / 100.0);\n      (void) FormatLocaleString(label, MaxTextExtent, \"solarize %g\", (QuantumRange * percentage) / 100.0);\n      break;\n    }\n\n    case ShadePreview:\n    {\n      degrees += 10.0;\n      preview_image = ShadeImage(thumbnail, MagickTrue, degrees, degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"shade %gx%g\", degrees, degrees);\n      break;\n    }\n\n    case RaisePreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      geometry.width = (size_t) ((2 * i) + 2);\n      geometry.height = (size_t) ((2 * i) + 2);\n      geometry.x = i / 2;\n      geometry.y = i / 2;\n      (void) RaiseImage(preview_image, &geometry, MagickTrue);\n      (void) FormatLocaleString(label, MaxTextExtent, \"raise %.20gx%.20g%+.20g%+.20g\", (double) geometry.width, (double) geometry.height, (double) geometry.x, (double) geometry.y);\n      break;\n    }\n\n    case SegmentPreview:\n    {\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      threshold += 0.4f;\n      (void) SegmentImage(preview_image, RGBColorspace, MagickFalse, threshold, threshold);\n      (void) FormatLocaleString(label, MaxTextExtent, \"segment %gx%g\", threshold, threshold);\n      break;\n    }\n\n    case SwirlPreview:\n    {\n      preview_image = SwirlImage(thumbnail, degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"swirl %g\", degrees);\n      degrees += 45.0;\n      break;\n    }\n\n    case ImplodePreview:\n    {\n      degrees += 0.1f;\n      preview_image = ImplodeImage(thumbnail, degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"implode %g\", degrees);\n      break;\n    }\n\n    case WavePreview:\n    {\n      degrees += 5.0f;\n      preview_image = WaveImage(thumbnail, 0.5 * degrees, 2.0 * degrees, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"wave %gx%g\", 0.5 * degrees, 2.0 * degrees);\n      break;\n    }\n\n    case OilPaintPreview:\n    {\n      preview_image = OilPaintImage(thumbnail, (double) radius, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"paint %g\", radius);\n      break;\n    }\n\n    case CharcoalDrawingPreview:\n    {\n      preview_image = CharcoalImage(thumbnail, (double) radius, (double) sigma, exception);\n      (void) FormatLocaleString(label, MaxTextExtent, \"charcoal %gx%g\", radius, sigma);\n      break;\n    }\n\n    case JPEGPreview:\n    {\n      char filename[MaxTextExtent];\n      int file;\n      MagickBooleanType status;\n      preview_image = CloneImage(thumbnail, 0, 0, MagickTrue, exception);\n      if (preview_image == ((Image *) 0))\n        break;\n      preview_info->quality = (size_t) percentage;\n      (void) FormatLocaleString(factor, MaxTextExtent, \"%.20g\", (double) preview_info->quality);\n      file = AcquireUniqueFileResource(filename);\n      if (file != (-1))\n        file = close(file) - 1;\n      (void) FormatLocaleString(preview_image->filename, MaxTextExtent, \"jpeg:%s\", filename);\n      status = WriteImage(preview_info, preview_image);\n      if (status != MagickFalse)\n      {\n        Image *quality_image;\n        (void) CopyMagickString(preview_info->filename, preview_image->filename, MaxTextExtent);\n        quality_image = ReadImage(preview_info, exception);\n        if (quality_image != ((Image *) 0))\n        {\n          preview_image = DestroyImage(preview_image);\n          preview_image = quality_image;\n        }\n      }\n      (void) RelinquishUniqueFileResource(preview_image->filename);\n      if ((GetBlobSize(preview_image) / 1024) >= 1024)\n        (void) FormatLocaleString(label, MaxTextExtent, \"quality %s\\n%gmb \", factor, (((double) ((MagickOffsetType) GetBlobSize(preview_image))) / 1024.0) / 1024.0);\n      else\n        if (GetBlobSize(preview_image) >= 1024)\n        (void) FormatLocaleString(label, MaxTextExtent, \"quality %s\\n%gkb \", factor, ((double) ((MagickOffsetType) GetBlobSize(preview_image))) / 1024.0);\n      else\n        (void) FormatLocaleString(label, MaxTextExtent, \"quality %s\\n%.20gb \", factor, (double) ((MagickOffsetType) GetBlobSize(thumbnail)));\n      break;\n    }\n\n  }\n\n  thumbnail = DestroyImage(thumbnail);\n  percentage += 12.5;\n  radius += 0.5;\n  sigma += 0.25;\n  if (preview_image == ((Image *) 0))\n    break;\n  (void) DeleteImageProperty(preview_image, \"label\");\n  (void) SetImageProperty(preview_image, \"label\", label);\n  AppendImageToList(&images, preview_image);\n  proceed = SetImageProgress(image, \"Preview/Image\", (MagickOffsetType) i, 9);\n  if (proceed == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/32"}
{"code": "for (i = 0; i < ((ssize_t) n); i++)\n{\n  cos_theta[i] = cos((double) ((theta * i) - offset));\n  sin_theta[i] = sin((double) ((theta * i) - offset));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/33"}
{"code": "for (v = 0; v < ((ssize_t) width); v++)\n{\n  *message = '\\0';\n  (void) FormatLocaleString(format, MaxTextExtent, \"%.20g: \", (double) v);\n  (void) ConcatenateString(&message, format);\n  for (u = 0; u < ((ssize_t) width); u++)\n  {\n    (void) FormatLocaleString(format, MaxTextExtent, \"%+f \", *(k++));\n    (void) ConcatenateString(&message, format);\n  }\n\n  (void) LogMagickEvent(TransformEvent, GetMagickModule(), \"%s\", message);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/34"}
{"code": "for (v = -j; v <= j; v++)\n{\n  for (u = -j; u <= j; u++)\n  {\n    kernel[i] = (double) ((-exp((-((((double) u) * u) + (v * v))) / ((2.0 * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))))) / (((2.0 * MagickPI) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))) * ((fabs(sigma) <= MagickEpsilon) ? (1.0) : (sigma))));\n    normalize += kernel[i];\n    i++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/35"}
{"code": "for (i = 0; i < 5; i++)\n  if (pixel_list->lists[i].nodes != ((ListNode *) 0))\n  pixel_list->lists[i].nodes = (ListNode *) RelinquishMagickMemory(pixel_list->lists[i].nodes);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/36"}
{"code": "for (i = 0; i < ((ssize_t) GetOpenMPMaximumThreads()); i++)\n  if (pixel_list[i] != ((PixelList *) 0))\n  pixel_list[i] = DestroyPixelList(pixel_list[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/37"}
{"code": "for (i = 0; i < 5; i++)\n{\n  pixel_list->lists[i].nodes = (ListNode *) AcquireQuantumMemory(65537UL, sizeof(*pixel_list->lists[i].nodes));\n  if (pixel_list->lists[i].nodes == ((ListNode *) 0))\n    return DestroyPixelList(pixel_list);\n  (void) ResetMagickMemory(pixel_list->lists[i].nodes, 0, 65537UL * (sizeof(*pixel_list->lists[i].nodes)));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/38"}
{"code": "for (i = 0; i < ((ssize_t) number_threads); i++)\n{\n  pixel_list[i] = AcquirePixelList(width, height);\n  if (pixel_list[i] == ((PixelList *) 0))\n    return DestroyPixelListThreadSet(pixel_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/39"}
{"code": "for (level = list->level; level >= 0; level--)\n{\n  while (list->nodes[search].next[level] < color)\n    search = list->nodes[search].next[level];\n\n  update[level] = search;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/40"}
{"code": "for (level = 0;; level++)\n{\n  pixel_list->seed = (pixel_list->seed * 42893621L) + 1L;\n  if ((pixel_list->seed & 0x300) != 0x300)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/41"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  count = 0;\n  maximum = list->nodes[color].next[0];\n  do\n  {\n    color = list->nodes[color].next[0];\n    if (color > maximum)\n      maximum = color;\n    count += list->nodes[color].count;\n  }\n  while (count < ((ssize_t) pixel_list->length));\n  channels[channel] = (unsigned short) maximum;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/42"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  count = 0;\n  sum = 0.0;\n  do\n  {\n    color = list->nodes[color].next[0];\n    sum += ((MagickRealType) list->nodes[color].count) * color;\n    count += list->nodes[color].count;\n  }\n  while (count < ((ssize_t) pixel_list->length));\n  sum /= pixel_list->length;\n  channels[channel] = (unsigned short) sum;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/43"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  count = 0;\n  do\n  {\n    color = list->nodes[color].next[0];\n    count += list->nodes[color].count;\n  }\n  while (count <= ((ssize_t) (pixel_list->length >> 1)));\n  channels[channel] = (unsigned short) color;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/44"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  count = 0;\n  color = 65536UL;\n  minimum = list->nodes[color].next[0];\n  do\n  {\n    color = list->nodes[color].next[0];\n    if (color < minimum)\n      minimum = color;\n    count += list->nodes[color].count;\n  }\n  while (count < ((ssize_t) pixel_list->length));\n  channels[channel] = (unsigned short) minimum;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/45"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  mode = color;\n  max_count = list->nodes[mode].count;\n  count = 0;\n  do\n  {\n    color = list->nodes[color].next[0];\n    if (list->nodes[color].count > max_count)\n    {\n      mode = color;\n      max_count = list->nodes[mode].count;\n    }\n    count += list->nodes[color].count;\n  }\n  while (count < ((ssize_t) pixel_list->length));\n  channels[channel] = (unsigned short) mode;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/46"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  next = list->nodes[color].next[0];\n  count = 0;\n  do\n  {\n    previous = color;\n    color = next;\n    next = list->nodes[color].next[0];\n    count += list->nodes[color].count;\n  }\n  while (count <= ((ssize_t) (pixel_list->length >> 1)));\n  if ((previous == 65536UL) && (next != 65536UL))\n    color = next;\n  else\n    if ((previous != 65536UL) && (next == 65536UL))\n    color = previous;\n  channels[channel] = (unsigned short) color;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/47"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  color = 65536L;\n  count = 0;\n  sum = 0.0;\n  sum_squared = 0.0;\n  do\n  {\n    ssize_t i;\n    color = list->nodes[color].next[0];\n    sum += ((MagickRealType) list->nodes[color].count) * color;\n    for (i = 0; i < ((ssize_t) list->nodes[color].count); i++)\n      sum_squared += ((MagickRealType) color) * ((MagickRealType) color);\n\n    count += list->nodes[color].count;\n  }\n  while (count < ((ssize_t) pixel_list->length));\n  sum /= pixel_list->length;\n  sum_squared /= pixel_list->length;\n  channels[channel] = (unsigned short) sqrt(sum_squared - (sum * sum));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/48"}
{"code": "for (channel = 0; channel < 5; channel++)\n{\n  list = pixel_list->lists + channel;\n  root = list->nodes + 65536UL;\n  list->level = 0;\n  for (level = 0; level < 9; level++)\n    root->next[level] = 65536UL;\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_effect/49"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  cdl_map[i].red = ClampToQuantum((MagickRealType) ScaleMapToQuantum((MagickRealType) (MaxMap * pow(((color_correction.red.slope * i) / MaxMap) + color_correction.red.offset, color_correction.red.power))));\n  cdl_map[i].green = ClampToQuantum((MagickRealType) ScaleMapToQuantum((MagickRealType) (MaxMap * pow(((color_correction.green.slope * i) / MaxMap) + color_correction.green.offset, color_correction.green.power))));\n  cdl_map[i].blue = ClampToQuantum((MagickRealType) ScaleMapToQuantum((MagickRealType) (MaxMap * pow(((color_correction.blue.slope * i) / MaxMap) + color_correction.blue.offset, color_correction.blue.power))));\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/0"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  double luma;\n  luma = ((0.2126 * image->colormap[i].red) + (0.7152 * image->colormap[i].green)) + (0.0722 * image->colormap[i].blue);\n  image->colormap[i].red = ClampToQuantum((luma + (color_correction.saturation * cdl_map[ScaleQuantumToMap(image->colormap[i].red)].red)) - luma);\n  image->colormap[i].green = ClampToQuantum((luma + (color_correction.saturation * cdl_map[ScaleQuantumToMap(image->colormap[i].green)].green)) - luma);\n  image->colormap[i].blue = ClampToQuantum((luma + (color_correction.saturation * cdl_map[ScaleQuantumToMap(image->colormap[i].blue)].blue)) - luma);\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double luma;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    luma = ((0.2126 * GetPixelRed(q)) + (0.7152 * GetPixelGreen(q))) + (0.0722 * GetPixelBlue(q));\n    SetPixelRed(q, ClampToQuantum(luma + (color_correction.saturation * (cdl_map[ScaleQuantumToMap(GetPixelRed(q))].red - luma))));\n    SetPixelGreen(q, ClampToQuantum(luma + (color_correction.saturation * (cdl_map[ScaleQuantumToMap(GetPixelGreen(q))].green - luma))));\n    SetPixelBlue(q, ClampToQuantum(luma + (color_correction.saturation * (cdl_map[ScaleQuantumToMap(GetPixelBlue(q))].blue - luma))));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ColorDecisionListImageChannel)\n    proceed = SetImageProgress(image, \"ColorDecisionList/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/2"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  GetMagickPixelPacket(clut_image, clut_map + i);\n  (void) InterpolateMagickPixelPacket(clut_image, clut_view, UndefinedInterpolatePixel, (QuantumScale * i) * (clut_image->columns - adjust), (QuantumScale * i) * (clut_image->rows - adjust), clut_map + i, exception);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  GetMagickPixelPacket(image, &pixel);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetMagickPixelPacket(image, q, indexes + x, &pixel);\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampPixelRed(clut_map + ScaleQuantumToMap(GetPixelRed(q))));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampPixelGreen(clut_map + ScaleQuantumToMap(GetPixelGreen(q))));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampPixelBlue(clut_map + ScaleQuantumToMap(GetPixelBlue(q))));\n    if ((channel & OpacityChannel) != 0)\n    {\n      if (clut_image->matte == MagickFalse)\n        SetPixelAlpha(q, MagickPixelIntensityToQuantum(clut_map + ScaleQuantumToMap((Quantum) GetPixelAlpha(q))));\n      else\n        if (image->matte == MagickFalse)\n        SetPixelOpacity(q, ClampPixelOpacity(clut_map + ScaleQuantumToMap((Quantum) MagickPixelIntensity(&pixel))));\n      else\n        SetPixelOpacity(q, ClampPixelOpacity(clut_map + ScaleQuantumToMap(GetPixelOpacity(q))));\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToQuantum((clut_map + ((ssize_t) GetPixelIndex(indexes + x)))->index));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ClutImageChannel)\n    proceed = SetImageProgress(image, \"Clut/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  Quantum blue;\n  Quantum green;\n  Quantum red;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    red = GetPixelRed(q);\n    green = GetPixelGreen(q);\n    blue = GetPixelBlue(q);\n    Contrast(sign, &red, &green, &blue);\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ContrastImage)\n    proceed = SetImageProgress(image, \"Contrast/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/5"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  if ((channel & RedChannel) != 0)\n  {\n    if (i < ((ssize_t) black.red))\n      stretch_map[i].red = 0.0;\n    else\n      if (i > ((ssize_t) white.red))\n      stretch_map[i].red = (MagickRealType) QuantumRange;\n    else\n      if (black.red != white.red)\n      stretch_map[i].red = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (i - black.red)) / (white.red - black.red)));\n  }\n  if ((channel & GreenChannel) != 0)\n  {\n    if (i < ((ssize_t) black.green))\n      stretch_map[i].green = 0.0;\n    else\n      if (i > ((ssize_t) white.green))\n      stretch_map[i].green = (MagickRealType) QuantumRange;\n    else\n      if (black.green != white.green)\n      stretch_map[i].green = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (i - black.green)) / (white.green - black.green)));\n  }\n  if ((channel & BlueChannel) != 0)\n  {\n    if (i < ((ssize_t) black.blue))\n      stretch_map[i].blue = 0.0;\n    else\n      if (i > ((ssize_t) white.blue))\n      stretch_map[i].blue = (MagickRealType) QuantumRange;\n    else\n      if (black.blue != white.blue)\n      stretch_map[i].blue = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (i - black.blue)) / (white.blue - black.blue)));\n  }\n  if ((channel & OpacityChannel) != 0)\n  {\n    if (i < ((ssize_t) black.opacity))\n      stretch_map[i].opacity = 0.0;\n    else\n      if (i > ((ssize_t) white.opacity))\n      stretch_map[i].opacity = (MagickRealType) QuantumRange;\n    else\n      if (black.opacity != white.opacity)\n      stretch_map[i].opacity = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (i - black.opacity)) / (white.opacity - black.opacity)));\n  }\n  if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n  {\n    if (i < ((ssize_t) black.index))\n      stretch_map[i].index = 0.0;\n    else\n      if (i > ((ssize_t) white.index))\n      stretch_map[i].index = (MagickRealType) QuantumRange;\n    else\n      if (black.index != white.index)\n      stretch_map[i].index = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (i - black.index)) / (white.index - black.index)));\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/6"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n  {\n    if (black.red != white.red)\n      image->colormap[i].red = ClampToQuantum(stretch_map[ScaleQuantumToMap(image->colormap[i].red)].red);\n  }\n  if ((channel & GreenChannel) != 0)\n  {\n    if (black.green != white.green)\n      image->colormap[i].green = ClampToQuantum(stretch_map[ScaleQuantumToMap(image->colormap[i].green)].green);\n  }\n  if ((channel & BlueChannel) != 0)\n  {\n    if (black.blue != white.blue)\n      image->colormap[i].blue = ClampToQuantum(stretch_map[ScaleQuantumToMap(image->colormap[i].blue)].blue);\n  }\n  if ((channel & OpacityChannel) != 0)\n  {\n    if (black.opacity != white.opacity)\n      image->colormap[i].opacity = ClampToQuantum(stretch_map[ScaleQuantumToMap(image->colormap[i].opacity)].opacity);\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/7"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n    {\n      if (black.red != white.red)\n        SetPixelRed(q, ClampToQuantum(stretch_map[ScaleQuantumToMap(GetPixelRed(q))].red));\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      if (black.green != white.green)\n        SetPixelGreen(q, ClampToQuantum(stretch_map[ScaleQuantumToMap(GetPixelGreen(q))].green));\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      if (black.blue != white.blue)\n        SetPixelBlue(q, ClampToQuantum(stretch_map[ScaleQuantumToMap(GetPixelBlue(q))].blue));\n    }\n    if ((channel & OpacityChannel) != 0)\n    {\n      if (black.opacity != white.opacity)\n        SetPixelOpacity(q, ClampToQuantum(stretch_map[ScaleQuantumToMap(GetPixelOpacity(q))].opacity));\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      if (black.index != white.index)\n        SetPixelIndex(indexes + x, ClampToQuantum(stretch_map[ScaleQuantumToMap(GetPixelIndex(indexes + x))].index));\n    }\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ContrastStretchImageChannel)\n    proceed = SetImageProgress(image, \"ContrastStretch/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/8"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -2, y - 2, image->columns + 4, 5, exception);\n  q = QueueCacheViewAuthenticPixels(enhance_view, 0, y, enhance_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickPixelPacket aggregate;\n    MagickRealType distance;\n    MagickRealType distance_squared;\n    MagickRealType mean;\n    MagickRealType total_weight;\n    PixelPacket pixel;\n    const PixelPacket * restrict r;\n    aggregate = zero;\n    total_weight = 0.0;\n    r = (p + (2 * (image->columns + 4))) + 2;\n    pixel = *r;\n    r = p;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 5.0 * GetPixelRed(r);\n      aggregate.green += 5.0 * GetPixelGreen(r);\n      aggregate.blue += 5.0 * GetPixelBlue(r);\n      aggregate.opacity += 5.0 * GetPixelOpacity(r);\n      total_weight += 5.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 10.0 * GetPixelRed(r);\n      aggregate.green += 10.0 * GetPixelGreen(r);\n      aggregate.blue += 10.0 * GetPixelBlue(r);\n      aggregate.opacity += 10.0 * GetPixelOpacity(r);\n      total_weight += 10.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 5.0 * GetPixelRed(r);\n      aggregate.green += 5.0 * GetPixelGreen(r);\n      aggregate.blue += 5.0 * GetPixelBlue(r);\n      aggregate.opacity += 5.0 * GetPixelOpacity(r);\n      total_weight += 5.0;\n    }\n    r++;\n    ;\n    r = p + (image->columns + 4);\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 20.0 * GetPixelRed(r);\n      aggregate.green += 20.0 * GetPixelGreen(r);\n      aggregate.blue += 20.0 * GetPixelBlue(r);\n      aggregate.opacity += 20.0 * GetPixelOpacity(r);\n      total_weight += 20.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 40.0 * GetPixelRed(r);\n      aggregate.green += 40.0 * GetPixelGreen(r);\n      aggregate.blue += 40.0 * GetPixelBlue(r);\n      aggregate.opacity += 40.0 * GetPixelOpacity(r);\n      total_weight += 40.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 20.0 * GetPixelRed(r);\n      aggregate.green += 20.0 * GetPixelGreen(r);\n      aggregate.blue += 20.0 * GetPixelBlue(r);\n      aggregate.opacity += 20.0 * GetPixelOpacity(r);\n      total_weight += 20.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    r = p + (2 * (image->columns + 4));\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 10.0 * GetPixelRed(r);\n      aggregate.green += 10.0 * GetPixelGreen(r);\n      aggregate.blue += 10.0 * GetPixelBlue(r);\n      aggregate.opacity += 10.0 * GetPixelOpacity(r);\n      total_weight += 10.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 40.0 * GetPixelRed(r);\n      aggregate.green += 40.0 * GetPixelGreen(r);\n      aggregate.blue += 40.0 * GetPixelBlue(r);\n      aggregate.opacity += 40.0 * GetPixelOpacity(r);\n      total_weight += 40.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 80.0 * GetPixelRed(r);\n      aggregate.green += 80.0 * GetPixelGreen(r);\n      aggregate.blue += 80.0 * GetPixelBlue(r);\n      aggregate.opacity += 80.0 * GetPixelOpacity(r);\n      total_weight += 80.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 40.0 * GetPixelRed(r);\n      aggregate.green += 40.0 * GetPixelGreen(r);\n      aggregate.blue += 40.0 * GetPixelBlue(r);\n      aggregate.opacity += 40.0 * GetPixelOpacity(r);\n      total_weight += 40.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 10.0 * GetPixelRed(r);\n      aggregate.green += 10.0 * GetPixelGreen(r);\n      aggregate.blue += 10.0 * GetPixelBlue(r);\n      aggregate.opacity += 10.0 * GetPixelOpacity(r);\n      total_weight += 10.0;\n    }\n    r++;\n    ;\n    r = p + (3 * (image->columns + 4));\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 20.0 * GetPixelRed(r);\n      aggregate.green += 20.0 * GetPixelGreen(r);\n      aggregate.blue += 20.0 * GetPixelBlue(r);\n      aggregate.opacity += 20.0 * GetPixelOpacity(r);\n      total_weight += 20.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 40.0 * GetPixelRed(r);\n      aggregate.green += 40.0 * GetPixelGreen(r);\n      aggregate.blue += 40.0 * GetPixelBlue(r);\n      aggregate.opacity += 40.0 * GetPixelOpacity(r);\n      total_weight += 40.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 20.0 * GetPixelRed(r);\n      aggregate.green += 20.0 * GetPixelGreen(r);\n      aggregate.blue += 20.0 * GetPixelBlue(r);\n      aggregate.opacity += 20.0 * GetPixelOpacity(r);\n      total_weight += 20.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    r = p + (4 * (image->columns + 4));\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 5.0 * GetPixelRed(r);\n      aggregate.green += 5.0 * GetPixelGreen(r);\n      aggregate.blue += 5.0 * GetPixelBlue(r);\n      aggregate.opacity += 5.0 * GetPixelOpacity(r);\n      total_weight += 5.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 10.0 * GetPixelRed(r);\n      aggregate.green += 10.0 * GetPixelGreen(r);\n      aggregate.blue += 10.0 * GetPixelBlue(r);\n      aggregate.opacity += 10.0 * GetPixelOpacity(r);\n      total_weight += 10.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 8.0 * GetPixelRed(r);\n      aggregate.green += 8.0 * GetPixelGreen(r);\n      aggregate.blue += 8.0 * GetPixelBlue(r);\n      aggregate.opacity += 8.0 * GetPixelOpacity(r);\n      total_weight += 8.0;\n    }\n    r++;\n    ;\n    mean = (((MagickRealType) GetPixelRed(r)) + pixel.red) / 2;\n    distance = ((MagickRealType) GetPixelRed(r)) - ((MagickRealType) pixel.red);\n    distance_squared = ((QuantumScale * ((2.0 * (((MagickRealType) QuantumRange) + 1.0)) + mean)) * distance) * distance;\n    mean = (((MagickRealType) GetPixelGreen(r)) + pixel.green) / 2;\n    distance = ((MagickRealType) GetPixelGreen(r)) - ((MagickRealType) pixel.green);\n    distance_squared += (4.0 * distance) * distance;\n    mean = (((MagickRealType) GetPixelBlue(r)) + pixel.blue) / 2;\n    distance = ((MagickRealType) GetPixelBlue(r)) - ((MagickRealType) pixel.blue);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    mean = (((MagickRealType) r->opacity) + pixel.opacity) / 2;\n    distance = ((MagickRealType) r->opacity) - ((MagickRealType) pixel.opacity);\n    distance_squared += ((QuantumScale * (((3.0 * (((MagickRealType) QuantumRange) + 1.0)) - 1.0) - mean)) * distance) * distance;\n    if (distance_squared < ((((MagickRealType) QuantumRange) * ((MagickRealType) QuantumRange)) / 25.0f))\n    {\n      aggregate.red += 5.0 * GetPixelRed(r);\n      aggregate.green += 5.0 * GetPixelGreen(r);\n      aggregate.blue += 5.0 * GetPixelBlue(r);\n      aggregate.opacity += 5.0 * GetPixelOpacity(r);\n      total_weight += 5.0;\n    }\n    r++;\n    ;\n    SetPixelRed(q, ((aggregate.red + (total_weight / 2)) - 1) / total_weight);\n    SetPixelGreen(q, ((aggregate.green + (total_weight / 2)) - 1) / total_weight);\n    SetPixelBlue(q, ((aggregate.blue + (total_weight / 2)) - 1) / total_weight);\n    SetPixelOpacity(q, ((aggregate.opacity + (total_weight / 2)) - 1) / total_weight);\n    p++;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(enhance_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_EnhanceImage)\n    proceed = SetImageProgress(image, \"Enhance/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/9"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  if (((channel & RedChannel) != 0) && (white.red != black.red))\n    equalize_map[i].red = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (map[i].red - black.red)) / (white.red - black.red)));\n  if (((channel & GreenChannel) != 0) && (white.green != black.green))\n    equalize_map[i].green = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (map[i].green - black.green)) / (white.green - black.green)));\n  if (((channel & BlueChannel) != 0) && (white.blue != black.blue))\n    equalize_map[i].blue = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (map[i].blue - black.blue)) / (white.blue - black.blue)));\n  if (((channel & OpacityChannel) != 0) && (white.opacity != black.opacity))\n    equalize_map[i].opacity = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (map[i].opacity - black.opacity)) / (white.opacity - black.opacity)));\n  if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (white.index != black.index))\n    equalize_map[i].index = (MagickRealType) ScaleMapToQuantum((MagickRealType) ((MaxMap * (map[i].index - black.index)) / (white.index - black.index)));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/10"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if (((channel & RedChannel) != 0) && (white.red != black.red))\n    image->colormap[i].red = ClampToQuantum(equalize_map[ScaleQuantumToMap(image->colormap[i].red)].red);\n  if (((channel & GreenChannel) != 0) && (white.green != black.green))\n    image->colormap[i].green = ClampToQuantum(equalize_map[ScaleQuantumToMap(image->colormap[i].green)].green);\n  if (((channel & BlueChannel) != 0) && (white.blue != black.blue))\n    image->colormap[i].blue = ClampToQuantum(equalize_map[ScaleQuantumToMap(image->colormap[i].blue)].blue);\n  if (((channel & OpacityChannel) != 0) && (white.opacity != black.opacity))\n    image->colormap[i].opacity = ClampToQuantum(equalize_map[ScaleQuantumToMap(image->colormap[i].opacity)].opacity);\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (((channel & RedChannel) != 0) && (white.red != black.red))\n      SetPixelRed(q, ClampToQuantum(equalize_map[ScaleQuantumToMap(GetPixelRed(q))].red));\n    if (((channel & GreenChannel) != 0) && (white.green != black.green))\n      SetPixelGreen(q, ClampToQuantum(equalize_map[ScaleQuantumToMap(GetPixelGreen(q))].green));\n    if (((channel & BlueChannel) != 0) && (white.blue != black.blue))\n      SetPixelBlue(q, ClampToQuantum(equalize_map[ScaleQuantumToMap(GetPixelBlue(q))].blue));\n    if (((channel & OpacityChannel) != 0) && (white.opacity != black.opacity))\n      SetPixelOpacity(q, ClampToQuantum(equalize_map[ScaleQuantumToMap(GetPixelOpacity(q))].opacity));\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (white.index != black.index))\n      SetPixelIndex(indexes + x, ClampToQuantum(equalize_map[ScaleQuantumToMap(GetPixelIndex(indexes + x))].index));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_EqualizeImageChannel)\n    proceed = SetImageProgress(image, \"Equalize/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/12"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n  gamma_map[i] = ClampToQuantum((MagickRealType) ScaleMapToQuantum((MagickRealType) (MaxMap * pow(((double) i) / MaxMap, 1.0 / gamma))));\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/13"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = gamma_map[ScaleQuantumToMap(image->colormap[i].red)];\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = gamma_map[ScaleQuantumToMap(image->colormap[i].green)];\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = gamma_map[ScaleQuantumToMap(image->colormap[i].blue)];\n  if ((channel & OpacityChannel) != 0)\n  {\n    if (image->matte == MagickFalse)\n      image->colormap[i].opacity = gamma_map[ScaleQuantumToMap(image->colormap[i].opacity)];\n    else\n      image->colormap[i].opacity = ((Quantum) QuantumRange) - gamma_map[ScaleQuantumToMap((Quantum) (QuantumRange - image->colormap[i].opacity))];\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/14"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (channel == DefaultChannels)\n    {\n      SetPixelRed(q, gamma_map[ScaleQuantumToMap(GetPixelRed(q))]);\n      SetPixelGreen(q, gamma_map[ScaleQuantumToMap(GetPixelGreen(q))]);\n      SetPixelBlue(q, gamma_map[ScaleQuantumToMap(GetPixelBlue(q))]);\n    }\n    else\n    {\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q, gamma_map[ScaleQuantumToMap(GetPixelRed(q))]);\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q, gamma_map[ScaleQuantumToMap(GetPixelGreen(q))]);\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q, gamma_map[ScaleQuantumToMap(GetPixelBlue(q))]);\n      if ((channel & OpacityChannel) != 0)\n      {\n        if (image->matte == MagickFalse)\n          SetPixelOpacity(q, gamma_map[ScaleQuantumToMap(GetPixelOpacity(q))]);\n        else\n          SetPixelAlpha(q, gamma_map[ScaleQuantumToMap((Quantum) GetPixelAlpha(q))]);\n      }\n    }\n    q++;\n  }\n\n  if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n    SetPixelIndex(indexes + x, gamma_map[ScaleQuantumToMap(GetPixelIndex(indexes + x))]);\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_GammaImageChannel)\n    proceed = SetImageProgress(image, \"GammaCorrect/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/15"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double offset;\n  HaldInfo point;\n  MagickPixelPacket pixel;\n  MagickPixelPacket pixel1;\n  MagickPixelPacket pixel2;\n  MagickPixelPacket pixel3;\n  MagickPixelPacket pixel4;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(hald_view);\n  pixel = zero;\n  pixel1 = zero;\n  pixel2 = zero;\n  pixel3 = zero;\n  pixel4 = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    point.x = (QuantumScale * (level - 1.0)) * GetPixelRed(q);\n    point.y = (QuantumScale * (level - 1.0)) * GetPixelGreen(q);\n    point.z = (QuantumScale * (level - 1.0)) * GetPixelBlue(q);\n    offset = (point.x + (level * floor(point.y))) + (cube_size * floor(point.z));\n    point.x -= floor(point.x);\n    point.y -= floor(point.y);\n    point.z -= floor(point.z);\n    (void) InterpolateMagickPixelPacket(image, hald_view, UndefinedInterpolatePixel, fmod(offset, width), floor(offset / width), &pixel1, exception);\n    (void) InterpolateMagickPixelPacket(image, hald_view, UndefinedInterpolatePixel, fmod(offset + level, width), floor((offset + level) / width), &pixel2, exception);\n    MagickPixelCompositeAreaBlend(&pixel1, pixel1.opacity, &pixel2, pixel2.opacity, point.y, &pixel3);\n    offset += cube_size;\n    (void) InterpolateMagickPixelPacket(image, hald_view, UndefinedInterpolatePixel, fmod(offset, width), floor(offset / width), &pixel1, exception);\n    (void) InterpolateMagickPixelPacket(image, hald_view, UndefinedInterpolatePixel, fmod(offset + level, width), floor((offset + level) / width), &pixel2, exception);\n    MagickPixelCompositeAreaBlend(&pixel1, pixel1.opacity, &pixel2, pixel2.opacity, point.y, &pixel4);\n    MagickPixelCompositeAreaBlend(&pixel3, pixel3.opacity, &pixel4, pixel4.opacity, point.z, &pixel);\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(pixel.red));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(pixel.green));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(pixel.blue));\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n      SetPixelOpacity(q, ClampToQuantum(pixel.opacity));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToQuantum(pixel.index));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_HaldClutImageChannel)\n    proceed = SetImageProgress(image, \"Clut/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/16"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) image->colormap[i].red) - black_point), 1.0 / gamma));\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) image->colormap[i].green) - black_point), 1.0 / gamma));\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) image->colormap[i].blue) - black_point), 1.0 / gamma));\n  if ((channel & OpacityChannel) != 0)\n    image->colormap[i].opacity = ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) image->colormap[i].opacity) - black_point), 1.0 / gamma));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/17"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) GetPixelRed(q)) - black_point), 1.0 / gamma)));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) GetPixelGreen(q)) - black_point), 1.0 / gamma)));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) GetPixelBlue(q)) - black_point), 1.0 / gamma)));\n    if (((channel & OpacityChannel) != 0) && (image->matte == MagickTrue))\n      SetPixelAlpha(q, ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) GetPixelAlpha(q)) - black_point), 1.0 / gamma)));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToQuantum(((MagickRealType) QuantumRange) * pow(scale * (((double) GetPixelIndex(indexes + x)) - black_point), 1.0 / gamma)));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_LevelImageChannel)\n    proceed = SetImageProgress(image, \"Level/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/18"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * image->colormap[i].red), 1.0 / gamma)) * (white_point - black_point)) + black_point);\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * image->colormap[i].green), 1.0 / gamma)) * (white_point - black_point)) + black_point);\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * image->colormap[i].blue), 1.0 / gamma)) * (white_point - black_point)) + black_point);\n  if ((channel & OpacityChannel) != 0)\n    image->colormap[i].opacity = ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * image->colormap[i].opacity), 1.0 / gamma)) * (white_point - black_point)) + black_point);\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/19"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * GetPixelRed(q)), 1.0 / gamma)) * (white_point - black_point)) + black_point));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * GetPixelGreen(q)), 1.0 / gamma)) * (white_point - black_point)) + black_point));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * GetPixelBlue(q)), 1.0 / gamma)) * (white_point - black_point)) + black_point));\n    if (((channel & OpacityChannel) != 0) && (image->matte == MagickTrue))\n      SetPixelOpacity(q, ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * GetPixelOpacity(q)), 1.0 / gamma)) * (white_point - black_point)) + black_point));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToQuantum((((MagickRealType) pow((double) (QuantumScale * GetPixelIndex(indexes + x)), 1.0 / gamma)) * (white_point - black_point)) + black_point));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_LevelizeImageChannel)\n    proceed = SetImageProgress(image, \"Levelize/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/20"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n  switch (colorspace)\n{\n  case HSBColorspace:\n  {\n    ModulateHSB(percent_hue, percent_saturation, percent_brightness, &image->colormap[i].red, &image->colormap[i].green, &image->colormap[i].blue);\n    break;\n  }\n\n  case HSLColorspace:\n\n  default:\n  {\n    ModulateHSL(percent_hue, percent_saturation, percent_brightness, &image->colormap[i].red, &image->colormap[i].green, &image->colormap[i].blue);\n    break;\n  }\n\n  case HWBColorspace:\n  {\n    ModulateHWB(percent_hue, percent_saturation, percent_brightness, &image->colormap[i].red, &image->colormap[i].green, &image->colormap[i].blue);\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/21"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  Quantum blue;\n  Quantum green;\n  Quantum red;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    red = GetPixelRed(q);\n    green = GetPixelGreen(q);\n    blue = GetPixelBlue(q);\n    switch (colorspace)\n    {\n      case HSBColorspace:\n      {\n        ModulateHSB(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue);\n        break;\n      }\n\n      case HSLColorspace:\n\n      default:\n      {\n        ModulateHSL(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue);\n        break;\n      }\n\n      case HWBColorspace:\n      {\n        ModulateHWB(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue);\n        break;\n      }\n\n    }\n\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_ModulateImage)\n    proceed = SetImageProgress(image, \"Modulate/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/22"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if (grayscale != MagickFalse)\n    if ((image->colormap[i].red != image->colormap[i].green) || (image->colormap[i].green != image->colormap[i].blue))\n    continue;\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = ((Quantum) QuantumRange) - image->colormap[i].red;\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = ((Quantum) QuantumRange) - image->colormap[i].green;\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = ((Quantum) QuantumRange) - image->colormap[i].blue;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/23"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((GetPixelRed(q) != GetPixelGreen(q)) || (GetPixelGreen(q) != GetPixelBlue(q)))\n    {\n      q++;\n      continue;\n    }\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, QuantumRange - GetPixelRed(q));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, QuantumRange - GetPixelGreen(q));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, QuantumRange - GetPixelBlue(q));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, QuantumRange - GetPixelOpacity(q));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, QuantumRange - GetPixelIndex(indexes + x));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_NegateImageChannel)\n    proceed = SetImageProgress(image, \"Negate/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/24"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, QuantumRange - GetPixelRed(q));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, QuantumRange - GetPixelGreen(q));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, QuantumRange - GetPixelBlue(q));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, QuantumRange - GetPixelOpacity(q));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, QuantumRange - GetPixelIndex(indexes + x));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_NegateImageChannel)\n    proceed = SetImageProgress(image, \"Negate/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/25"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  if (sharpen != MagickFalse)\n  {\n    sigmoidal_map[i] = (MagickRealType) ScaleMapToQuantum((MagickRealType) (((MaxMap * ((1.0 / (1.0 + exp(contrast * ((midpoint / ((double) QuantumRange)) - (((double) i) / MaxMap))))) - (1.0 / (1.0 + exp(contrast * (midpoint / ((double) QuantumRange))))))) / ((1.0 / (1.0 + exp(contrast * ((midpoint / ((double) QuantumRange)) - 1.0)))) - (1.0 / (1.0 + exp(contrast * (midpoint / ((double) QuantumRange))))))) + 0.5));\n    continue;\n  }\n  sigmoidal_map[i] = (MagickRealType) ScaleMapToQuantum((MagickRealType) (MaxMap * ((QuantumScale * midpoint) - (log((1.0 - ((1.0 / (1.0 + exp((midpoint / ((double) QuantumRange)) * contrast))) + ((((double) i) / MaxMap) * ((1.0 / (1.0 + exp(contrast * ((midpoint / ((double) QuantumRange)) - 1.0)))) - (1.0 / (1.0 + exp((midpoint / ((double) QuantumRange)) * contrast))))))) / ((1.0 / (1.0 + exp((midpoint / ((double) QuantumRange)) * contrast))) + ((((double) i) / MaxMap) * ((1.0 / (1.0 + exp(contrast * ((midpoint / ((double) QuantumRange)) - 1.0)))) - (1.0 / (1.0 + exp((midpoint / ((double) QuantumRange)) * contrast))))))) / contrast))));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/26"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    image->colormap[i].red = ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(image->colormap[i].red)]);\n  if ((channel & GreenChannel) != 0)\n    image->colormap[i].green = ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(image->colormap[i].green)]);\n  if ((channel & BlueChannel) != 0)\n    image->colormap[i].blue = ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(image->colormap[i].blue)]);\n  if ((channel & OpacityChannel) != 0)\n    image->colormap[i].opacity = ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(image->colormap[i].opacity)]);\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/27"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(GetPixelRed(q))]));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(GetPixelGreen(q))]));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(GetPixelBlue(q))]));\n    if ((channel & OpacityChannel) != 0)\n      SetPixelOpacity(q, ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(GetPixelOpacity(q))]));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ClampToQuantum(sigmoidal_map[ScaleQuantumToMap(GetPixelIndex(indexes + x))]));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SigmoidalContrastImageChannel)\n    proceed = SetImageProgress(image, \"SigmoidalContrast/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/28"}
{"code": "for (i = 0; ((*p) != '\\0') && (i < 3); i++)\n{\n  GetMagickToken(p, &p, token);\n  if ((*token) == ',')\n    GetMagickToken(p, &p, token);\n  switch (i)\n  {\n    case 0:\n    {\n      color_correction.red.slope = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 1:\n    {\n      color_correction.green.slope = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 2:\n    {\n      color_correction.blue.slope = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/29"}
{"code": "for (i = 0; ((*p) != '\\0') && (i < 3); i++)\n{\n  GetMagickToken(p, &p, token);\n  if ((*token) == ',')\n    GetMagickToken(p, &p, token);\n  switch (i)\n  {\n    case 0:\n    {\n      color_correction.red.offset = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 1:\n    {\n      color_correction.green.offset = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 2:\n    {\n      color_correction.blue.offset = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/30"}
{"code": "for (i = 0; ((*p) != '\\0') && (i < 3); i++)\n{\n  GetMagickToken(p, &p, token);\n  if ((*token) == ',')\n    GetMagickToken(p, &p, token);\n  switch (i)\n  {\n    case 0:\n    {\n      color_correction.red.power = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 1:\n    {\n      color_correction.green.power = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n    case 2:\n    {\n      color_correction.blue.power = InterpretLocaleValue(token, (char **) 0);\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/31"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n  Contrast(sign, &image->colormap[i].red, &image->colormap[i].green, &image->colormap[i].blue);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/32"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  if (channel == DefaultChannels)\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    Quantum intensity;\n    intensity = PixelIntensityToQuantum(p);\n    histogram[ScaleQuantumToMap(intensity)].red++;\n    histogram[ScaleQuantumToMap(intensity)].green++;\n    histogram[ScaleQuantumToMap(intensity)].blue++;\n    histogram[ScaleQuantumToMap(intensity)].index++;\n    p++;\n  }\n\n  else\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelRed(p))].red++;\n    if ((channel & GreenChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelGreen(p))].green++;\n    if ((channel & BlueChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelBlue(p))].blue++;\n    if ((channel & OpacityChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelOpacity(p))].opacity++;\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      histogram[ScaleQuantumToMap(GetPixelIndex(indexes + x))].index++;\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/33"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  intensity += histogram[i].red;\n  if (intensity > black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/34"}
{"code": "for (i = (ssize_t) MaxMap; i != 0; i--)\n{\n  intensity += histogram[i].red;\n  if (intensity > ((((double) image->columns) * image->rows) - white_point))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/35"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  intensity += histogram[i].green;\n  if (intensity > black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/36"}
{"code": "for (i = (ssize_t) MaxMap; i != 0; i--)\n{\n  intensity += histogram[i].green;\n  if (intensity > ((((double) image->columns) * image->rows) - white_point))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/37"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  intensity += histogram[i].blue;\n  if (intensity > black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/38"}
{"code": "for (i = (ssize_t) MaxMap; i != 0; i--)\n{\n  intensity += histogram[i].blue;\n  if (intensity > ((((double) image->columns) * image->rows) - white_point))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/39"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  intensity += histogram[i].opacity;\n  if (intensity > black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/40"}
{"code": "for (i = (ssize_t) MaxMap; i != 0; i--)\n{\n  intensity += histogram[i].opacity;\n  if (intensity > ((((double) image->columns) * image->rows) - white_point))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/41"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  intensity += histogram[i].index;\n  if (intensity > black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/42"}
{"code": "for (i = (ssize_t) MaxMap; i != 0; i--)\n{\n  intensity += histogram[i].index;\n  if (intensity > ((((double) image->columns) * image->rows) - white_point))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/43"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  p = GetVirtualPixels(image, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  indexes = GetVirtualIndexQueue(image);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelRed(p))].red++;\n    if ((channel & GreenChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelGreen(p))].green++;\n    if ((channel & BlueChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelBlue(p))].blue++;\n    if ((channel & OpacityChannel) != 0)\n      histogram[ScaleQuantumToMap(GetPixelOpacity(p))].opacity++;\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      histogram[ScaleQuantumToMap(GetPixelIndex(indexes + x))].index++;\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/44"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  if ((channel & RedChannel) != 0)\n    intensity.red += histogram[i].red;\n  if ((channel & GreenChannel) != 0)\n    intensity.green += histogram[i].green;\n  if ((channel & BlueChannel) != 0)\n    intensity.blue += histogram[i].blue;\n  if ((channel & OpacityChannel) != 0)\n    intensity.opacity += histogram[i].opacity;\n  if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    intensity.index += histogram[i].index;\n  map[i] = intensity;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/45"}
{"code": "for (level = 2; ((level * level) * level) < length; level++)\n  ;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/46"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket * restrict p;\n  ssize_t x;\n  p = GetVirtualPixels(image, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  for (x = ((ssize_t) image->columns) - 1; x >= 0; x--)\n  {\n    histogram[ScaleQuantumToMap(PixelIntensityToQuantum(p))]++;\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/47"}
{"code": "for (black = 0; black < ((ssize_t) MaxMap); black++)\n{\n  intensity += histogram[black];\n  if (intensity >= black_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/48"}
{"code": "for (white = (ssize_t) MaxMap; white != 0; white--)\n{\n  intensity += histogram[white];\n  if (intensity >= white_point)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_enhance/49"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    grays[ScaleQuantumToMap(GetPixelRed(p))].red = ScaleQuantumToMap(GetPixelRed(p));\n    grays[ScaleQuantumToMap(GetPixelGreen(p))].green = ScaleQuantumToMap(GetPixelGreen(p));\n    grays[ScaleQuantumToMap(GetPixelBlue(p))].blue = ScaleQuantumToMap(GetPixelBlue(p));\n    if (image->colorspace == CMYKColorspace)\n      grays[ScaleQuantumToMap(GetPixelIndex(indexes + x))].index = ScaleQuantumToMap(GetPixelIndex(indexes + x));\n    if (image->matte != MagickFalse)\n      grays[ScaleQuantumToMap(GetPixelOpacity(p))].opacity = ScaleQuantumToMap(GetPixelOpacity(p));\n    p++;\n  }\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  ssize_t y;\n  for (y = 0; y < ((ssize_t) number_grays); y++)\n  {\n    ssize_t x;\n    for (x = 0; x < ((ssize_t) number_grays); x++)\n    {\n      channel_features[RedChannel].angular_second_moment[i] += cooccurrence[x][y].direction[i].red * cooccurrence[x][y].direction[i].red;\n      channel_features[GreenChannel].angular_second_moment[i] += cooccurrence[x][y].direction[i].green * cooccurrence[x][y].direction[i].green;\n      channel_features[BlueChannel].angular_second_moment[i] += cooccurrence[x][y].direction[i].blue * cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackChannel].angular_second_moment[i] += cooccurrence[x][y].direction[i].index * cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        channel_features[OpacityChannel].angular_second_moment[i] += cooccurrence[x][y].direction[i].opacity * cooccurrence[x][y].direction[i].opacity;\n      sum[y].direction[i].red += cooccurrence[x][y].direction[i].red;\n      sum[y].direction[i].green += cooccurrence[x][y].direction[i].green;\n      sum[y].direction[i].blue += cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        sum[y].direction[i].index += cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        sum[y].direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n      correlation.direction[i].red += (x * y) * cooccurrence[x][y].direction[i].red;\n      correlation.direction[i].green += (x * y) * cooccurrence[x][y].direction[i].green;\n      correlation.direction[i].blue += (x * y) * cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        correlation.direction[i].index += (x * y) * cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        correlation.direction[i].opacity += (x * y) * cooccurrence[x][y].direction[i].opacity;\n      channel_features[RedChannel].inverse_difference_moment[i] += cooccurrence[x][y].direction[i].red / (((y - x) * (y - x)) + 1);\n      channel_features[GreenChannel].inverse_difference_moment[i] += cooccurrence[x][y].direction[i].green / (((y - x) * (y - x)) + 1);\n      channel_features[BlueChannel].inverse_difference_moment[i] += cooccurrence[x][y].direction[i].blue / (((y - x) * (y - x)) + 1);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[IndexChannel].inverse_difference_moment[i] += cooccurrence[x][y].direction[i].index / (((y - x) * (y - x)) + 1);\n      if (image->matte != MagickFalse)\n        channel_features[OpacityChannel].inverse_difference_moment[i] += cooccurrence[x][y].direction[i].opacity / (((y - x) * (y - x)) + 1);\n      density_xy[(y + x) + 2].direction[i].red += cooccurrence[x][y].direction[i].red;\n      density_xy[(y + x) + 2].direction[i].green += cooccurrence[x][y].direction[i].green;\n      density_xy[(y + x) + 2].direction[i].blue += cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        density_xy[(y + x) + 2].direction[i].index += cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        density_xy[(y + x) + 2].direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n      channel_features[RedChannel].entropy[i] -= cooccurrence[x][y].direction[i].red * log10(cooccurrence[x][y].direction[i].red + MagickEpsilon);\n      channel_features[GreenChannel].entropy[i] -= cooccurrence[x][y].direction[i].green * log10(cooccurrence[x][y].direction[i].green + MagickEpsilon);\n      channel_features[BlueChannel].entropy[i] -= cooccurrence[x][y].direction[i].blue * log10(cooccurrence[x][y].direction[i].blue + MagickEpsilon);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[IndexChannel].entropy[i] -= cooccurrence[x][y].direction[i].index * log10(cooccurrence[x][y].direction[i].index + MagickEpsilon);\n      if (image->matte != MagickFalse)\n        channel_features[OpacityChannel].entropy[i] -= cooccurrence[x][y].direction[i].opacity * log10(cooccurrence[x][y].direction[i].opacity + MagickEpsilon);\n      density_x[x].direction[i].red += cooccurrence[x][y].direction[i].red;\n      density_x[x].direction[i].green += cooccurrence[x][y].direction[i].green;\n      density_x[x].direction[i].blue += cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        density_x[x].direction[i].index += cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        density_x[x].direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n      density_y[y].direction[i].red += cooccurrence[x][y].direction[i].red;\n      density_y[y].direction[i].green += cooccurrence[x][y].direction[i].green;\n      density_y[y].direction[i].blue += cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        density_y[y].direction[i].index += cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        density_y[y].direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n    }\n\n    mean.direction[i].red += y * sum[y].direction[i].red;\n    sum_squares.direction[i].red += (y * y) * sum[y].direction[i].red;\n    mean.direction[i].green += y * sum[y].direction[i].green;\n    sum_squares.direction[i].green += (y * y) * sum[y].direction[i].green;\n    mean.direction[i].blue += y * sum[y].direction[i].blue;\n    sum_squares.direction[i].blue += (y * y) * sum[y].direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n    {\n      mean.direction[i].index += y * sum[y].direction[i].index;\n      sum_squares.direction[i].index += (y * y) * sum[y].direction[i].index;\n    }\n    if (image->matte != MagickFalse)\n    {\n      mean.direction[i].opacity += y * sum[y].direction[i].opacity;\n      sum_squares.direction[i].opacity += (y * y) * sum[y].direction[i].opacity;\n    }\n  }\n\n  channel_features[RedChannel].correlation[i] = (correlation.direction[i].red - (mean.direction[i].red * mean.direction[i].red)) / (sqrt(sum_squares.direction[i].red - (mean.direction[i].red * mean.direction[i].red)) * sqrt(sum_squares.direction[i].red - (mean.direction[i].red * mean.direction[i].red)));\n  channel_features[GreenChannel].correlation[i] = (correlation.direction[i].green - (mean.direction[i].green * mean.direction[i].green)) / (sqrt(sum_squares.direction[i].green - (mean.direction[i].green * mean.direction[i].green)) * sqrt(sum_squares.direction[i].green - (mean.direction[i].green * mean.direction[i].green)));\n  channel_features[BlueChannel].correlation[i] = (correlation.direction[i].blue - (mean.direction[i].blue * mean.direction[i].blue)) / (sqrt(sum_squares.direction[i].blue - (mean.direction[i].blue * mean.direction[i].blue)) * sqrt(sum_squares.direction[i].blue - (mean.direction[i].blue * mean.direction[i].blue)));\n  if (image->colorspace == CMYKColorspace)\n    channel_features[IndexChannel].correlation[i] = (correlation.direction[i].index - (mean.direction[i].index * mean.direction[i].index)) / (sqrt(sum_squares.direction[i].index - (mean.direction[i].index * mean.direction[i].index)) * sqrt(sum_squares.direction[i].index - (mean.direction[i].index * mean.direction[i].index)));\n  if (image->matte != MagickFalse)\n    channel_features[OpacityChannel].correlation[i] = (correlation.direction[i].opacity - (mean.direction[i].opacity * mean.direction[i].opacity)) / (sqrt(sum_squares.direction[i].opacity - (mean.direction[i].opacity * mean.direction[i].opacity)) * sqrt(sum_squares.direction[i].opacity - (mean.direction[i].opacity * mean.direction[i].opacity)));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  ssize_t x;\n  for (x = 2; x < ((ssize_t) (2 * number_grays)); x++)\n  {\n    channel_features[RedChannel].sum_average[i] += x * density_xy[x].direction[i].red;\n    channel_features[GreenChannel].sum_average[i] += x * density_xy[x].direction[i].green;\n    channel_features[BlueChannel].sum_average[i] += x * density_xy[x].direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      channel_features[IndexChannel].sum_average[i] += x * density_xy[x].direction[i].index;\n    if (image->matte != MagickFalse)\n      channel_features[OpacityChannel].sum_average[i] += x * density_xy[x].direction[i].opacity;\n    channel_features[RedChannel].sum_entropy[i] -= density_xy[x].direction[i].red * log10(density_xy[x].direction[i].red + MagickEpsilon);\n    channel_features[GreenChannel].sum_entropy[i] -= density_xy[x].direction[i].green * log10(density_xy[x].direction[i].green + MagickEpsilon);\n    channel_features[BlueChannel].sum_entropy[i] -= density_xy[x].direction[i].blue * log10(density_xy[x].direction[i].blue + MagickEpsilon);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[IndexChannel].sum_entropy[i] -= density_xy[x].direction[i].index * log10(density_xy[x].direction[i].index + MagickEpsilon);\n    if (image->matte != MagickFalse)\n      channel_features[OpacityChannel].sum_entropy[i] -= density_xy[x].direction[i].opacity * log10(density_xy[x].direction[i].opacity + MagickEpsilon);\n    channel_features[RedChannel].sum_variance[i] += ((x - channel_features[RedChannel].sum_entropy[i]) * (x - channel_features[RedChannel].sum_entropy[i])) * density_xy[x].direction[i].red;\n    channel_features[GreenChannel].sum_variance[i] += ((x - channel_features[GreenChannel].sum_entropy[i]) * (x - channel_features[GreenChannel].sum_entropy[i])) * density_xy[x].direction[i].green;\n    channel_features[BlueChannel].sum_variance[i] += ((x - channel_features[BlueChannel].sum_entropy[i]) * (x - channel_features[BlueChannel].sum_entropy[i])) * density_xy[x].direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      channel_features[IndexChannel].sum_variance[i] += ((x - channel_features[IndexChannel].sum_entropy[i]) * (x - channel_features[IndexChannel].sum_entropy[i])) * density_xy[x].direction[i].index;\n    if (image->matte != MagickFalse)\n      channel_features[OpacityChannel].sum_variance[i] += ((x - channel_features[OpacityChannel].sum_entropy[i]) * (x - channel_features[OpacityChannel].sum_entropy[i])) * density_xy[x].direction[i].opacity;\n  }\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/2"}
{"code": "for (i = 0; i < 4; i++)\n{\n  ssize_t y;\n  for (y = 0; y < ((ssize_t) number_grays); y++)\n  {\n    ssize_t x;\n    for (x = 0; x < ((ssize_t) number_grays); x++)\n    {\n      variance.direction[i].red += (((y - mean.direction[i].red) + 1) * ((y - mean.direction[i].red) + 1)) * cooccurrence[x][y].direction[i].red;\n      variance.direction[i].green += (((y - mean.direction[i].green) + 1) * ((y - mean.direction[i].green) + 1)) * cooccurrence[x][y].direction[i].green;\n      variance.direction[i].blue += (((y - mean.direction[i].blue) + 1) * ((y - mean.direction[i].blue) + 1)) * cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        variance.direction[i].index += (((y - mean.direction[i].index) + 1) * ((y - mean.direction[i].index) + 1)) * cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        variance.direction[i].opacity += (((y - mean.direction[i].opacity) + 1) * ((y - mean.direction[i].opacity) + 1)) * cooccurrence[x][y].direction[i].opacity;\n      density_xy[MagickAbsoluteValue(y - x)].direction[i].red += cooccurrence[x][y].direction[i].red;\n      density_xy[MagickAbsoluteValue(y - x)].direction[i].green += cooccurrence[x][y].direction[i].green;\n      density_xy[MagickAbsoluteValue(y - x)].direction[i].blue += cooccurrence[x][y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        density_xy[MagickAbsoluteValue(y - x)].direction[i].index += cooccurrence[x][y].direction[i].index;\n      if (image->matte != MagickFalse)\n        density_xy[MagickAbsoluteValue(y - x)].direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n      entropy_xy.direction[i].red -= cooccurrence[x][y].direction[i].red * log10(cooccurrence[x][y].direction[i].red + MagickEpsilon);\n      entropy_xy.direction[i].green -= cooccurrence[x][y].direction[i].green * log10(cooccurrence[x][y].direction[i].green + MagickEpsilon);\n      entropy_xy.direction[i].blue -= cooccurrence[x][y].direction[i].blue * log10(cooccurrence[x][y].direction[i].blue + MagickEpsilon);\n      if (image->colorspace == CMYKColorspace)\n        entropy_xy.direction[i].index -= cooccurrence[x][y].direction[i].index * log10(cooccurrence[x][y].direction[i].index + MagickEpsilon);\n      if (image->matte != MagickFalse)\n        entropy_xy.direction[i].opacity -= cooccurrence[x][y].direction[i].opacity * log10(cooccurrence[x][y].direction[i].opacity + MagickEpsilon);\n      entropy_xy1.direction[i].red -= cooccurrence[x][y].direction[i].red * log10((density_x[x].direction[i].red * density_y[y].direction[i].red) + MagickEpsilon);\n      entropy_xy1.direction[i].green -= cooccurrence[x][y].direction[i].green * log10((density_x[x].direction[i].green * density_y[y].direction[i].green) + MagickEpsilon);\n      entropy_xy1.direction[i].blue -= cooccurrence[x][y].direction[i].blue * log10((density_x[x].direction[i].blue * density_y[y].direction[i].blue) + MagickEpsilon);\n      if (image->colorspace == CMYKColorspace)\n        entropy_xy1.direction[i].index -= cooccurrence[x][y].direction[i].index * log10((density_x[x].direction[i].index * density_y[y].direction[i].index) + MagickEpsilon);\n      if (image->matte != MagickFalse)\n        entropy_xy1.direction[i].opacity -= cooccurrence[x][y].direction[i].opacity * log10((density_x[x].direction[i].opacity * density_y[y].direction[i].opacity) + MagickEpsilon);\n      entropy_xy2.direction[i].red -= (density_x[x].direction[i].red * density_y[y].direction[i].red) * log10((density_x[x].direction[i].red * density_y[y].direction[i].red) + MagickEpsilon);\n      entropy_xy2.direction[i].green -= (density_x[x].direction[i].green * density_y[y].direction[i].green) * log10((density_x[x].direction[i].green * density_y[y].direction[i].green) + MagickEpsilon);\n      entropy_xy2.direction[i].blue -= (density_x[x].direction[i].blue * density_y[y].direction[i].blue) * log10((density_x[x].direction[i].blue * density_y[y].direction[i].blue) + MagickEpsilon);\n      if (image->colorspace == CMYKColorspace)\n        entropy_xy2.direction[i].index -= (density_x[x].direction[i].index * density_y[y].direction[i].index) * log10((density_x[x].direction[i].index * density_y[y].direction[i].index) + MagickEpsilon);\n      if (image->matte != MagickFalse)\n        entropy_xy2.direction[i].opacity -= (density_x[x].direction[i].opacity * density_y[y].direction[i].opacity) * log10((density_x[x].direction[i].opacity * density_y[y].direction[i].opacity) + MagickEpsilon);\n    }\n\n  }\n\n  channel_features[RedChannel].variance_sum_of_squares[i] = variance.direction[i].red;\n  channel_features[GreenChannel].variance_sum_of_squares[i] = variance.direction[i].green;\n  channel_features[BlueChannel].variance_sum_of_squares[i] = variance.direction[i].blue;\n  if (image->colorspace == CMYKColorspace)\n    channel_features[RedChannel].variance_sum_of_squares[i] = variance.direction[i].index;\n  if (image->matte != MagickFalse)\n    channel_features[RedChannel].variance_sum_of_squares[i] = variance.direction[i].opacity;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/3"}
{"code": "for (i = 0; i < 4; i++)\n{\n  ssize_t x;\n  for (x = 0; x < ((ssize_t) number_grays); x++)\n  {\n    variance.direction[i].red += density_xy[x].direction[i].red;\n    variance.direction[i].green += density_xy[x].direction[i].green;\n    variance.direction[i].blue += density_xy[x].direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      variance.direction[i].index += density_xy[x].direction[i].index;\n    if (image->matte != MagickFalse)\n      variance.direction[i].opacity += density_xy[x].direction[i].opacity;\n    sum_squares.direction[i].red += density_xy[x].direction[i].red * density_xy[x].direction[i].red;\n    sum_squares.direction[i].green += density_xy[x].direction[i].green * density_xy[x].direction[i].green;\n    sum_squares.direction[i].blue += density_xy[x].direction[i].blue * density_xy[x].direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      sum_squares.direction[i].index += density_xy[x].direction[i].index * density_xy[x].direction[i].index;\n    if (image->matte != MagickFalse)\n      sum_squares.direction[i].opacity += density_xy[x].direction[i].opacity * density_xy[x].direction[i].opacity;\n    channel_features[RedChannel].difference_entropy[i] -= density_xy[x].direction[i].red * log10(density_xy[x].direction[i].red + MagickEpsilon);\n    channel_features[GreenChannel].difference_entropy[i] -= density_xy[x].direction[i].green * log10(density_xy[x].direction[i].green + MagickEpsilon);\n    channel_features[BlueChannel].difference_entropy[i] -= density_xy[x].direction[i].blue * log10(density_xy[x].direction[i].blue + MagickEpsilon);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[IndexChannel].difference_entropy[i] -= density_xy[x].direction[i].index * log10(density_xy[x].direction[i].index + MagickEpsilon);\n    if (image->matte != MagickFalse)\n      channel_features[OpacityChannel].difference_entropy[i] -= density_xy[x].direction[i].opacity * log10(density_xy[x].direction[i].opacity + MagickEpsilon);\n    entropy_x.direction[i].red -= density_x[x].direction[i].red * log10(density_x[x].direction[i].red + MagickEpsilon);\n    entropy_x.direction[i].green -= density_x[x].direction[i].green * log10(density_x[x].direction[i].green + MagickEpsilon);\n    entropy_x.direction[i].blue -= density_x[x].direction[i].blue * log10(density_x[x].direction[i].blue + MagickEpsilon);\n    if (image->colorspace == CMYKColorspace)\n      entropy_x.direction[i].index -= density_x[x].direction[i].index * log10(density_x[x].direction[i].index + MagickEpsilon);\n    if (image->matte != MagickFalse)\n      entropy_x.direction[i].opacity -= density_x[x].direction[i].opacity * log10(density_x[x].direction[i].opacity + MagickEpsilon);\n    entropy_y.direction[i].red -= density_y[x].direction[i].red * log10(density_y[x].direction[i].red + MagickEpsilon);\n    entropy_y.direction[i].green -= density_y[x].direction[i].green * log10(density_y[x].direction[i].green + MagickEpsilon);\n    entropy_y.direction[i].blue -= density_y[x].direction[i].blue * log10(density_y[x].direction[i].blue + MagickEpsilon);\n    if (image->colorspace == CMYKColorspace)\n      entropy_y.direction[i].index -= density_y[x].direction[i].index * log10(density_y[x].direction[i].index + MagickEpsilon);\n    if (image->matte != MagickFalse)\n      entropy_y.direction[i].opacity -= density_y[x].direction[i].opacity * log10(density_y[x].direction[i].opacity + MagickEpsilon);\n  }\n\n  channel_features[RedChannel].difference_variance[i] = (((((double) number_grays) * number_grays) * sum_squares.direction[i].red) - (variance.direction[i].red * variance.direction[i].red)) / (((((double) number_grays) * number_grays) * number_grays) * number_grays);\n  channel_features[GreenChannel].difference_variance[i] = (((((double) number_grays) * number_grays) * sum_squares.direction[i].green) - (variance.direction[i].green * variance.direction[i].green)) / (((((double) number_grays) * number_grays) * number_grays) * number_grays);\n  channel_features[BlueChannel].difference_variance[i] = (((((double) number_grays) * number_grays) * sum_squares.direction[i].blue) - (variance.direction[i].blue * variance.direction[i].blue)) / (((((double) number_grays) * number_grays) * number_grays) * number_grays);\n  if (image->matte != MagickFalse)\n    channel_features[OpacityChannel].difference_variance[i] = (((((double) number_grays) * number_grays) * sum_squares.direction[i].opacity) - (variance.direction[i].opacity * variance.direction[i].opacity)) / (((((double) number_grays) * number_grays) * number_grays) * number_grays);\n  if (image->colorspace == CMYKColorspace)\n    channel_features[IndexChannel].difference_variance[i] = (((((double) number_grays) * number_grays) * sum_squares.direction[i].index) - (variance.direction[i].index * variance.direction[i].index)) / (((((double) number_grays) * number_grays) * number_grays) * number_grays);\n  channel_features[RedChannel].measure_of_correlation_1[i] = (entropy_xy.direction[i].red - entropy_xy1.direction[i].red) / ((entropy_x.direction[i].red > entropy_y.direction[i].red) ? (entropy_x.direction[i].red) : (entropy_y.direction[i].red));\n  channel_features[GreenChannel].measure_of_correlation_1[i] = (entropy_xy.direction[i].green - entropy_xy1.direction[i].green) / ((entropy_x.direction[i].green > entropy_y.direction[i].green) ? (entropy_x.direction[i].green) : (entropy_y.direction[i].green));\n  channel_features[BlueChannel].measure_of_correlation_1[i] = (entropy_xy.direction[i].blue - entropy_xy1.direction[i].blue) / ((entropy_x.direction[i].blue > entropy_y.direction[i].blue) ? (entropy_x.direction[i].blue) : (entropy_y.direction[i].blue));\n  if (image->colorspace == CMYKColorspace)\n    channel_features[IndexChannel].measure_of_correlation_1[i] = (entropy_xy.direction[i].index - entropy_xy1.direction[i].index) / ((entropy_x.direction[i].index > entropy_y.direction[i].index) ? (entropy_x.direction[i].index) : (entropy_y.direction[i].index));\n  if (image->matte != MagickFalse)\n    channel_features[OpacityChannel].measure_of_correlation_1[i] = (entropy_xy.direction[i].opacity - entropy_xy1.direction[i].opacity) / ((entropy_x.direction[i].opacity > entropy_y.direction[i].opacity) ? (entropy_x.direction[i].opacity) : (entropy_y.direction[i].opacity));\n  channel_features[RedChannel].measure_of_correlation_2[i] = sqrt(fabs(1.0 - exp((-2.0) * (entropy_xy2.direction[i].red - entropy_xy.direction[i].red))));\n  channel_features[GreenChannel].measure_of_correlation_2[i] = sqrt(fabs(1.0 - exp((-2.0) * (entropy_xy2.direction[i].green - entropy_xy.direction[i].green))));\n  channel_features[BlueChannel].measure_of_correlation_2[i] = sqrt(fabs(1.0 - exp((-2.0) * (entropy_xy2.direction[i].blue - entropy_xy.direction[i].blue))));\n  if (image->colorspace == CMYKColorspace)\n    channel_features[IndexChannel].measure_of_correlation_2[i] = sqrt(fabs(1.0 - exp((-2.0) * (entropy_xy2.direction[i].index - entropy_xy.direction[i].index))));\n  if (image->matte != MagickFalse)\n    channel_features[OpacityChannel].measure_of_correlation_2[i] = sqrt(fabs(1.0 - exp((-2.0) * (entropy_xy2.direction[i].opacity - entropy_xy.direction[i].opacity))));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/4"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (z = 0; z < ((ssize_t) number_grays); z++)\n  {\n    ssize_t y;\n    ChannelStatistics pixel;\n    (void) ResetMagickMemory(&pixel, 0, sizeof(pixel));\n    for (y = 0; y < ((ssize_t) number_grays); y++)\n    {\n      ssize_t x;\n      for (x = 0; x < ((ssize_t) number_grays); x++)\n      {\n        if (((y - x) == z) || ((x - y) == z))\n        {\n          pixel.direction[i].red += cooccurrence[x][y].direction[i].red;\n          pixel.direction[i].green += cooccurrence[x][y].direction[i].green;\n          pixel.direction[i].blue += cooccurrence[x][y].direction[i].blue;\n          if (image->colorspace == CMYKColorspace)\n            pixel.direction[i].index += cooccurrence[x][y].direction[i].index;\n          if (image->matte != MagickFalse)\n            pixel.direction[i].opacity += cooccurrence[x][y].direction[i].opacity;\n        }\n        Q[z][y].direction[i].red += ((cooccurrence[z][x].direction[i].red * cooccurrence[y][x].direction[i].red) / density_x[z].direction[i].red) / density_y[x].direction[i].red;\n        Q[z][y].direction[i].green += ((cooccurrence[z][x].direction[i].green * cooccurrence[y][x].direction[i].green) / density_x[z].direction[i].green) / density_y[x].direction[i].red;\n        Q[z][y].direction[i].blue += ((cooccurrence[z][x].direction[i].blue * cooccurrence[y][x].direction[i].blue) / density_x[z].direction[i].blue) / density_y[x].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          Q[z][y].direction[i].index += ((cooccurrence[z][x].direction[i].index * cooccurrence[y][x].direction[i].index) / density_x[z].direction[i].index) / density_y[x].direction[i].index;\n        if (image->matte != MagickFalse)\n          Q[z][y].direction[i].opacity += ((cooccurrence[z][x].direction[i].opacity * cooccurrence[y][x].direction[i].opacity) / density_x[z].direction[i].opacity) / density_y[x].direction[i].opacity;\n      }\n\n    }\n\n    channel_features[RedChannel].contrast[i] += (z * z) * pixel.direction[i].red;\n    channel_features[GreenChannel].contrast[i] += (z * z) * pixel.direction[i].green;\n    channel_features[BlueChannel].contrast[i] += (z * z) * pixel.direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackChannel].contrast[i] += (z * z) * pixel.direction[i].index;\n    if (image->matte != MagickFalse)\n      channel_features[OpacityChannel].contrast[i] += (z * z) * pixel.direction[i].opacity;\n  }\n\n  channel_features[RedChannel].maximum_correlation_coefficient[i] = sqrt((double) (-1.0));\n  channel_features[GreenChannel].maximum_correlation_coefficient[i] = sqrt((double) (-1.0));\n  channel_features[BlueChannel].maximum_correlation_coefficient[i] = sqrt((double) (-1.0));\n  if (image->colorspace == CMYKColorspace)\n    channel_features[IndexChannel].maximum_correlation_coefficient[i] = sqrt((double) (-1.0));\n  if (image->matte != MagickFalse)\n    channel_features[OpacityChannel].maximum_correlation_coefficient[i] = sqrt((double) (-1.0));\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/5"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  grays[i].red = ~0U;\n  grays[i].green = ~0U;\n  grays[i].blue = ~0U;\n  grays[i].opacity = ~0U;\n  grays[i].index = ~0U;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/6"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  if (grays[i].red != (~0U))\n    grays[(ssize_t) (gray.red++)].red = grays[i].red;\n  if (grays[i].green != (~0U))\n    grays[(ssize_t) (gray.green++)].green = grays[i].green;\n  if (grays[i].blue != (~0U))\n    grays[(ssize_t) (gray.blue++)].blue = grays[i].blue;\n  if (image->colorspace == CMYKColorspace)\n    if (grays[i].index != (~0U))\n    grays[(ssize_t) (gray.index++)].index = grays[i].index;\n  if (image->matte != MagickFalse)\n    if (grays[i].opacity != (~0U))\n    grays[(ssize_t) (gray.opacity++)].opacity = grays[i].opacity;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/7"}
{"code": "for (i = 0; i < ((ssize_t) number_grays); i++)\n  Q[i] = (ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/8"}
{"code": "for (i = 0; i < ((ssize_t) number_grays); i++)\n  cooccurrence[i] = (ChannelStatistics *) RelinquishMagickMemory(cooccurrence[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/9"}
{"code": "for (i = 0; i < ((ssize_t) number_grays); i++)\n{\n  cooccurrence[i] = (ChannelStatistics *) AcquireQuantumMemory(number_grays, sizeof(*(*cooccurrence)));\n  Q[i] = (ChannelStatistics *) AcquireQuantumMemory(number_grays, sizeof(*(*Q)));\n  if ((cooccurrence[i] == ((ChannelStatistics *) 0)) || (Q[i] == ((ChannelStatistics *) 0)))\n    break;\n  (void) ResetMagickMemory(cooccurrence[i], 0, number_grays * (sizeof(*(*cooccurrence))));\n  (void) ResetMagickMemory(Q[i], 0, number_grays * (sizeof(*(*Q))));\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/10"}
{"code": "for (i--; i >= 0; i--)\n{\n  if (Q[i] != ((ChannelStatistics *) 0))\n    Q[i] = (ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n  if (cooccurrence[i] != ((ChannelStatistics *) 0))\n    cooccurrence[i] = (ChannelStatistics *) RelinquishMagickMemory(cooccurrence[i]);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  ssize_t i;\n  ssize_t offset;\n  ssize_t u;\n  ssize_t v;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, -((ssize_t) distance), y, image->columns + (2 * distance), distance + 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  p += distance;\n  indexes += distance;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    for (i = 0; i < 4; i++)\n    {\n      switch (i)\n      {\n        case 0:\n\n        default:\n        {\n          offset = (ssize_t) distance;\n          break;\n        }\n\n        case 1:\n        {\n          offset = (ssize_t) (image->columns + (2 * distance));\n          break;\n        }\n\n        case 2:\n        {\n          offset = (ssize_t) ((image->columns + (2 * distance)) - distance);\n          break;\n        }\n\n        case 3:\n        {\n          offset = (ssize_t) ((image->columns + (2 * distance)) + distance);\n          break;\n        }\n\n      }\n\n      u = 0;\n      v = 0;\n      while (grays[u].red != ScaleQuantumToMap(GetPixelRed(p)))\n        u++;\n\n      while (grays[v].red != ScaleQuantumToMap(GetPixelRed(p + offset)))\n        v++;\n\n      cooccurrence[u][v].direction[i].red++;\n      cooccurrence[v][u].direction[i].red++;\n      u = 0;\n      v = 0;\n      while (grays[u].green != ScaleQuantumToMap(GetPixelGreen(p)))\n        u++;\n\n      while (grays[v].green != ScaleQuantumToMap(GetPixelGreen(p + offset)))\n        v++;\n\n      cooccurrence[u][v].direction[i].green++;\n      cooccurrence[v][u].direction[i].green++;\n      u = 0;\n      v = 0;\n      while (grays[u].blue != ScaleQuantumToMap(GetPixelBlue(p)))\n        u++;\n\n      while (grays[v].blue != ScaleQuantumToMap((p + offset)->blue))\n        v++;\n\n      cooccurrence[u][v].direction[i].blue++;\n      cooccurrence[v][u].direction[i].blue++;\n      if (image->colorspace == CMYKColorspace)\n      {\n        u = 0;\n        v = 0;\n        while (grays[u].index != ScaleQuantumToMap(GetPixelIndex(indexes + x)))\n          u++;\n\n        while (grays[v].index != ScaleQuantumToMap(GetPixelIndex((indexes + x) + offset)))\n          v++;\n\n        cooccurrence[u][v].direction[i].index++;\n        cooccurrence[v][u].direction[i].index++;\n      }\n      if (image->matte != MagickFalse)\n      {\n        u = 0;\n        v = 0;\n        while (grays[u].opacity != ScaleQuantumToMap(GetPixelOpacity(p)))\n          u++;\n\n        while (grays[v].opacity != ScaleQuantumToMap((p + offset)->opacity))\n          v++;\n\n        cooccurrence[u][v].direction[i].opacity++;\n        cooccurrence[v][u].direction[i].opacity++;\n      }\n    }\n\n    p++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/12"}
{"code": "for (i = 0; i < 4; i++)\n{\n  double normalize;\n  ssize_t y;\n  switch (i)\n  {\n    case 0:\n\n    default:\n    {\n      normalize = (2.0 * image->rows) * (image->columns - distance);\n      break;\n    }\n\n    case 1:\n    {\n      normalize = (2.0 * (image->rows - distance)) * image->columns;\n      break;\n    }\n\n    case 2:\n    {\n      normalize = (2.0 * (image->rows - distance)) * (image->columns - distance);\n      break;\n    }\n\n    case 3:\n    {\n      normalize = (2.0 * (image->rows - distance)) * (image->columns - distance);\n      break;\n    }\n\n  }\n\n  normalize = 1.0 / ((fabs((double) normalize) <= MagickEpsilon) ? (1.0) : (normalize));\n  for (y = 0; y < ((ssize_t) number_grays); y++)\n  {\n    ssize_t x;\n    for (x = 0; x < ((ssize_t) number_grays); x++)\n    {\n      cooccurrence[x][y].direction[i].red *= normalize;\n      cooccurrence[x][y].direction[i].green *= normalize;\n      cooccurrence[x][y].direction[i].blue *= normalize;\n      if (image->colorspace == CMYKColorspace)\n        cooccurrence[x][y].direction[i].index *= normalize;\n      if (image->matte != MagickFalse)\n        cooccurrence[x][y].direction[i].opacity *= normalize;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_feature/13"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict frame_indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = QueueCacheViewAuthenticPixels(frame_view, 0, frame_info->y + y, frame_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  frame_indexes = GetCacheViewAuthenticIndexQueue(frame_view);\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) (frame_info->x - bevel_width)); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->inner_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  if ((image->compose != CopyCompositeOp) && ((image->compose != OverCompositeOp) || (image->matte != MagickFalse)))\n    for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelPacket(frame_image, &interior, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  else\n  {\n    const IndexPacket *indexes;\n    const PixelPacket *p;\n    p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n    if (p == ((const PixelPacket *) 0))\n    {\n      status = MagickFalse;\n      continue;\n    }\n    indexes = GetCacheViewVirtualIndexQueue(image_view);\n    (void) CopyMagickMemory(q, p, image->columns * (sizeof(*p)));\n    if ((image->colorspace == CMYKColorspace) && (frame_image->colorspace == CMYKColorspace))\n    {\n      (void) CopyMagickMemory(frame_indexes, indexes, image->columns * (sizeof(*indexes)));\n      frame_indexes += image->columns;\n    }\n    q += image->columns;\n  }\n  for (x = 0; x < ((ssize_t) frame_info->inner_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = ((frame_info->width - frame_info->x) - image->columns) - bevel_width;\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(frame_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_FrameImage)\n    proceed = SetImageProgress(image, \"Frame/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/0"}
{"code": "for (y = 0; y < ((ssize_t) raise_info->height); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < y; x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  for (; x < ((ssize_t) (image->columns - y)); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(135))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(135))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(135))))));\n    q++;\n  }\n\n  for (; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Raise/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/1"}
{"code": "for (y = (ssize_t) raise_info->height; y < ((ssize_t) (image->rows - raise_info->height)); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) raise_info->width); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  for (; x < ((ssize_t) (image->columns - raise_info->width)); x++)\n    q++;\n\n  for (; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Raise/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/2"}
{"code": "for (y = (ssize_t) (image->rows - raise_info->height); y < ((ssize_t) image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) (image->rows - y)); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) foreground) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  for (; x < ((ssize_t) (image->columns - (image->rows - y))); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(135))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(135))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(135)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(135))))));\n    q++;\n  }\n\n  for (; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelRed(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelGreen(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelGreen(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    SetPixelBlue(q, ClampToQuantum(QuantumScale * ((((MagickRealType) GetPixelBlue(q)) * ScaleCharToQuantum(190)) + (((MagickRealType) background) * (QuantumRange - ScaleCharToQuantum(190))))));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_RaiseImage)\n    proceed = SetImageProgress(image, \"Raise/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/3"}
{"code": "for (y = 0; y < ((ssize_t) frame_info->outer_bevel); y++)\n{\n  for (x = 0; x < ((ssize_t) (frame_image->columns - y)); x++)\n  {\n    if (x < y)\n      SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    else\n      SetPixelPacket(frame_image, &accentuate, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (; x < ((ssize_t) frame_image->columns); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/4"}
{"code": "for (y = 0; y < ((ssize_t) (frame_info->y - bevel_width)); y++)\n{\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = frame_image->columns - (2 * frame_info->outer_bevel);\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/5"}
{"code": "for (y = 0; y < ((ssize_t) frame_info->inner_bevel); y++)\n{\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) (frame_info->x - bevel_width)); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = (image->columns + (((size_t) frame_info->inner_bevel) << 1)) - y;\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    if (x < y)\n      SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    else\n      SetPixelPacket(frame_image, &trough, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (; x < ((ssize_t) (image->columns + (2 * frame_info->inner_bevel))); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = ((frame_info->width - frame_info->x) - image->columns) - bevel_width;\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/6"}
{"code": "for (y = frame_info->inner_bevel - 1; y >= 0; y--)\n{\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) (frame_info->x - bevel_width)); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < y; x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (; x < ((ssize_t) (image->columns + (2 * frame_info->inner_bevel))); x++)\n  {\n    if (x >= ((ssize_t) ((image->columns + (2 * frame_info->inner_bevel)) - y)))\n      SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    else\n      SetPixelPacket(frame_image, &accentuate, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = ((frame_info->width - frame_info->x) - image->columns) - bevel_width;\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/7"}
{"code": "for (y = 0; y < ((ssize_t) height); y++)\n{\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  width = frame_image->columns - (2 * frame_info->outer_bevel);\n  for (x = 0; x < ((ssize_t) width); x++)\n  {\n    SetPixelPacket(frame_image, &matte, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (x = 0; x < ((ssize_t) frame_info->outer_bevel); x++)\n  {\n    SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/8"}
{"code": "for (y = frame_info->outer_bevel - 1; y >= 0; y--)\n{\n  for (x = 0; x < y; x++)\n  {\n    SetPixelPacket(frame_image, &highlight, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n  for (; x < ((ssize_t) frame_image->columns); x++)\n  {\n    if (x >= ((ssize_t) (frame_image->columns - y)))\n      SetPixelPacket(frame_image, &shadow, q, frame_indexes);\n    else\n      SetPixelPacket(frame_image, &trough, q, frame_indexes);\n    q++;\n    frame_indexes++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_decorate/9"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  MagickPixelPacket pixel;\n  MagickPixelPacket reconstruct_pixel;\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  IndexPacket * restrict highlight_indexes;\n  ssize_t x;\n  PixelPacket * restrict r;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  r = QueueCacheViewAuthenticPixels(highlight_view, 0, y, highlight_image->columns, 1, exception);\n  if (((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0))) || (r == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  highlight_indexes = GetCacheViewAuthenticIndexQueue(highlight_view);\n  pixel = zero;\n  reconstruct_pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickStatusType difference;\n    SetMagickPixelPacket(image, p, indexes + x, &pixel);\n    SetMagickPixelPacket(reconstruct_image, q, reconstruct_indexes + x, &reconstruct_pixel);\n    difference = MagickFalse;\n    if (channel == CompositeChannels)\n    {\n      if (IsMagickColorSimilar(&pixel, &reconstruct_pixel) == MagickFalse)\n        difference = MagickTrue;\n    }\n    else\n    {\n      if (((channel & RedChannel) != 0) && (GetPixelRed(p) != GetPixelRed(q)))\n        difference = MagickTrue;\n      if (((channel & GreenChannel) != 0) && (GetPixelGreen(p) != GetPixelGreen(q)))\n        difference = MagickTrue;\n      if (((channel & BlueChannel) != 0) && (GetPixelBlue(p) != GetPixelBlue(q)))\n        difference = MagickTrue;\n      if ((((channel & OpacityChannel) != 0) && (image->matte != MagickFalse)) && (GetPixelOpacity(p) != GetPixelOpacity(q)))\n        difference = MagickTrue;\n      if (((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace)) && (GetPixelIndex(indexes + x) != GetPixelIndex(reconstruct_indexes + x)))\n        difference = MagickTrue;\n    }\n    if (difference != MagickFalse)\n      SetPixelPacket(highlight_image, &highlight, r, highlight_indexes + x);\n    else\n      SetPixelPacket(highlight_image, &lowlight, r, highlight_indexes + x);\n    p++;\n    q++;\n    r++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(highlight_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double channel_distortion[CompositeChannels + 1];\n  MagickPixelPacket pixel;\n  MagickPixelPacket reconstruct_pixel;\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t i;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  pixel = zero;\n  reconstruct_pixel = pixel;\n  (void) ResetMagickMemory(channel_distortion, 0, sizeof(channel_distortion));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetMagickPixelPacket(image, p, indexes + x, &pixel);\n    SetMagickPixelPacket(reconstruct_image, q, reconstruct_indexes + x, &reconstruct_pixel);\n    if (IsMagickColorSimilar(&pixel, &reconstruct_pixel) == MagickFalse)\n    {\n      if ((channel & RedChannel) != 0)\n        channel_distortion[RedChannel]++;\n      if ((channel & GreenChannel) != 0)\n        channel_distortion[GreenChannel]++;\n      if ((channel & BlueChannel) != 0)\n        channel_distortion[BlueChannel]++;\n      if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n        channel_distortion[OpacityChannel]++;\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        channel_distortion[BlackChannel]++;\n      channel_distortion[CompositeChannels]++;\n    }\n    p++;\n    q++;\n  }\n\n  #pragma omp critical (MagickCore_GetAbsoluteError)\n  for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n    distortion[i] += channel_distortion[i];\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double channel_distortion[CompositeChannels + 1];\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t i;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  (void) ResetMagickMemory(channel_distortion, 0, sizeof(channel_distortion));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    if ((channel & RedChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelRed(p) - ((MagickRealType) GetPixelRed(q)));\n      channel_distortion[RedChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelGreen(p) - ((MagickRealType) GetPixelGreen(q)));\n      channel_distortion[GreenChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelBlue(p) - ((MagickRealType) GetPixelBlue(q)));\n      channel_distortion[BlueChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if (((channel & OpacityChannel) != 0) && ((image->matte != MagickFalse) || (reconstruct_image->matte != MagickFalse)))\n    {\n      distance = QuantumScale * (((image->matte != MagickFalse) ? (GetPixelOpacity(p)) : (OpaqueOpacity)) - ((reconstruct_image->matte != MagickFalse) ? (GetPixelOpacity(q)) : (OpaqueOpacity)));\n      channel_distortion[OpacityChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace))\n    {\n      distance = QuantumScale * (GetPixelIndex(indexes + x) - ((MagickRealType) GetPixelIndex(reconstruct_indexes + x)));\n      channel_distortion[BlackChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    p++;\n    q++;\n  }\n\n  #pragma omp critical (MagickCore_GetMeanSquaredError)\n  for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n    distortion[i] += channel_distortion[i];\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double channel_distortion[CompositeChannels + 1];\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t i;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  (void) ResetMagickMemory(channel_distortion, 0, sizeof(channel_distortion));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    if ((channel & RedChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelRed(p) - ((double) GetPixelRed(q)));\n      channel_distortion[RedChannel] += distance;\n      channel_distortion[CompositeChannels] += distance;\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelGreen(p) - ((double) GetPixelGreen(q)));\n      channel_distortion[GreenChannel] += distance;\n      channel_distortion[CompositeChannels] += distance;\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelBlue(p) - ((double) GetPixelBlue(q)));\n      channel_distortion[BlueChannel] += distance;\n      channel_distortion[CompositeChannels] += distance;\n    }\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      distance = QuantumScale * fabs(GetPixelOpacity(p) - ((double) GetPixelOpacity(q)));\n      channel_distortion[OpacityChannel] += distance;\n      channel_distortion[CompositeChannels] += distance;\n    }\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      distance = QuantumScale * fabs(GetPixelIndex(indexes + x) - ((double) GetPixelIndex(reconstruct_indexes + x)));\n      channel_distortion[BlackChannel] += distance;\n      channel_distortion[CompositeChannels] += distance;\n    }\n    p++;\n    q++;\n  }\n\n  #pragma omp critical (MagickCore_GetMeanAbsoluteError)\n  for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n    distortion[i] += channel_distortion[i];\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double channel_distortion[CompositeChannels + 1];\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t i;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  (void) ResetMagickMemory(channel_distortion, 0, sizeof(channel_distortion));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    if ((channel & RedChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelRed(p) - ((MagickRealType) GetPixelRed(q)));\n      channel_distortion[RedChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelGreen(p) - ((MagickRealType) GetPixelGreen(q)));\n      channel_distortion[GreenChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      distance = QuantumScale * (GetPixelBlue(p) - ((MagickRealType) GetPixelBlue(q)));\n      channel_distortion[BlueChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      distance = QuantumScale * (GetPixelOpacity(p) - ((MagickRealType) GetPixelOpacity(q)));\n      channel_distortion[OpacityChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace))\n    {\n      distance = QuantumScale * (GetPixelIndex(indexes + x) - ((MagickRealType) GetPixelIndex(reconstruct_indexes + x)));\n      channel_distortion[BlackChannel] += distance * distance;\n      channel_distortion[CompositeChannels] += distance * distance;\n    }\n    p++;\n    q++;\n  }\n\n  #pragma omp critical (MagickCore_GetMeanSquaredError)\n  for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n    distortion[i] += channel_distortion[i];\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double channel_distortion[CompositeChannels + 1];\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t i;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  (void) ResetMagickMemory(channel_distortion, 0, sizeof(channel_distortion));\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    if ((channel & RedChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelRed(p) - ((double) GetPixelRed(q)));\n      if (distance > channel_distortion[RedChannel])\n        channel_distortion[RedChannel] = distance;\n      if (distance > channel_distortion[CompositeChannels])\n        channel_distortion[CompositeChannels] = distance;\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelGreen(p) - ((double) GetPixelGreen(q)));\n      if (distance > channel_distortion[GreenChannel])\n        channel_distortion[GreenChannel] = distance;\n      if (distance > channel_distortion[CompositeChannels])\n        channel_distortion[CompositeChannels] = distance;\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      distance = QuantumScale * fabs(GetPixelBlue(p) - ((double) GetPixelBlue(q)));\n      if (distance > channel_distortion[BlueChannel])\n        channel_distortion[BlueChannel] = distance;\n      if (distance > channel_distortion[CompositeChannels])\n        channel_distortion[CompositeChannels] = distance;\n    }\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      distance = QuantumScale * fabs(GetPixelOpacity(p) - ((double) GetPixelOpacity(q)));\n      if (distance > channel_distortion[OpacityChannel])\n        channel_distortion[OpacityChannel] = distance;\n      if (distance > channel_distortion[CompositeChannels])\n        channel_distortion[CompositeChannels] = distance;\n    }\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace))\n    {\n      distance = QuantumScale * fabs(GetPixelIndex(indexes + x) - ((double) GetPixelIndex(reconstruct_indexes + x)));\n      if (distance > channel_distortion[BlackChannel])\n        channel_distortion[BlackChannel] = distance;\n      if (distance > channel_distortion[CompositeChannels])\n        channel_distortion[CompositeChannels] = distance;\n    }\n    p++;\n    q++;\n  }\n\n  #pragma omp critical (MagickCore_GetPeakAbsoluteError)\n  for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n    if (channel_distortion[i] > distortion[i])\n    distortion[i] = channel_distortion[i];\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/5"}
{"code": "for (y = 0; y < ((ssize_t) ((image->rows - reference->rows) + 1)); y++)\n{\n  double similarity;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(similarity_view, 0, y, similarity_image->columns, 1, exception);\n  if (q == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) ((image->columns - reference->columns) + 1)); x++)\n  {\n    similarity = GetSimilarityMetric(image, reference, reference_statistics, x, y, exception);\n    #pragma omp critical (MagickCore_SimilarityImage)\n    if (similarity < (*similarity_metric))\n    {\n      *similarity_metric = similarity;\n      offset->x = x;\n      offset->y = y;\n    }\n    SetPixelRed(q, ClampToQuantum(QuantumRange - (QuantumRange * similarity)));\n    SetPixelGreen(q, GetPixelRed(q));\n    SetPixelBlue(q, GetPixelRed(q));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(similarity_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_SimilarityImage)\n    proceed = SetImageProgress(image, \"Similarity/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/6"}
{"code": "for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n  distortion[i] /= ((double) image->columns) * image->rows;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/7"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    break;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    if ((channel & OpacityChannel) != 0)\n    {\n      if (image->matte != MagickFalse)\n        alpha = (MagickRealType) (QuantumScale * GetPixelAlpha(p));\n      if (reconstruct_image->matte != MagickFalse)\n        beta = (MagickRealType) (QuantumScale * GetPixelAlpha(q));\n    }\n    if ((channel & RedChannel) != 0)\n    {\n      distance = fabs((alpha * GetPixelRed(p)) - (beta * GetPixelRed(q)));\n      distortion[RedChannel] += distance;\n      distortion[CompositeChannels] += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    if ((channel & GreenChannel) != 0)\n    {\n      distance = fabs((alpha * GetPixelGreen(p)) - (beta * GetPixelGreen(q)));\n      distortion[GreenChannel] += distance;\n      distortion[CompositeChannels] += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    if ((channel & BlueChannel) != 0)\n    {\n      distance = fabs((alpha * GetPixelBlue(p)) - (beta * GetPixelBlue(q)));\n      distortion[BlueChannel] += distance;\n      distortion[CompositeChannels] += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      distance = fabs(((double) GetPixelOpacity(p)) - GetPixelOpacity(q));\n      distortion[OpacityChannel] += distance;\n      distortion[CompositeChannels] += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace))\n    {\n      distance = fabs((alpha * GetPixelIndex(indexes + x)) - (beta * GetPixelIndex(reconstruct_indexes + x)));\n      distortion[BlackChannel] += distance;\n      distortion[CompositeChannels] += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    p++;\n    q++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/8"}
{"code": "for (i = 0; i <= ((ssize_t) CompositeChannels); i++)\n  distortion[i] = 0.0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/9"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      distortion[RedChannel] += ((area * QuantumScale) * (GetPixelRed(p) - image_statistics[RedChannel].mean)) * (GetPixelRed(q) - reconstruct_statistics[RedChannel].mean);\n    if ((channel & GreenChannel) != 0)\n      distortion[GreenChannel] += ((area * QuantumScale) * (GetPixelGreen(p) - image_statistics[GreenChannel].mean)) * (GetPixelGreen(q) - reconstruct_statistics[GreenChannel].mean);\n    if ((channel & BlueChannel) != 0)\n      distortion[BlueChannel] += ((area * QuantumScale) * (GetPixelBlue(p) - image_statistics[BlueChannel].mean)) * (GetPixelBlue(q) - reconstruct_statistics[BlueChannel].mean);\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n      distortion[OpacityChannel] += ((area * QuantumScale) * (GetPixelOpacity(p) - image_statistics[OpacityChannel].mean)) * (GetPixelOpacity(q) - reconstruct_statistics[OpacityChannel].mean);\n    if ((((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace)) && (reconstruct_image->colorspace == CMYKColorspace))\n      distortion[BlackChannel] += ((area * QuantumScale) * (GetPixelIndex(indexes + x) - image_statistics[OpacityChannel].mean)) * (GetPixelIndex(reconstruct_indexes + x) - reconstruct_statistics[OpacityChannel].mean);\n    p++;\n    q++;\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    proceed = SetImageProgress(image, \"Similarity/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/10"}
{"code": "for (i = 0; i < ((ssize_t) CompositeChannels); i++)\n{\n  MagickRealType gamma;\n  gamma = image_statistics[i].standard_deviation * reconstruct_statistics[i].standard_deviation;\n  gamma = 1.0 / ((fabs((double) gamma) <= MagickEpsilon) ? (1.0) : (gamma));\n  distortion[i] = (QuantumRange * gamma) * distortion[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/11"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n    break;\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    MagickRealType distance;\n    distance = fabs(GetPixelRed(p) - ((double) GetPixelRed(q)));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    area++;\n    distance = fabs(GetPixelGreen(p) - ((double) GetPixelGreen(q)));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    area++;\n    distance = fabs(GetPixelBlue(p) - ((double) GetPixelBlue(q)));\n    mean_error_per_pixel += distance;\n    mean_error += distance * distance;\n    if (distance > maximum_error)\n      maximum_error = distance;\n    area++;\n    if (image->matte != MagickFalse)\n    {\n      distance = fabs(GetPixelOpacity(p) - ((double) GetPixelOpacity(q)));\n      mean_error_per_pixel += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    if ((image->colorspace == CMYKColorspace) && (reconstruct_image->colorspace == CMYKColorspace))\n    {\n      distance = fabs(GetPixelIndex(indexes + x) - ((double) GetPixelIndex(reconstruct_indexes + x)));\n      mean_error_per_pixel += distance;\n      mean_error += distance * distance;\n      if (distance > maximum_error)\n        maximum_error = distance;\n      area++;\n    }\n    p++;\n    q++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/12"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const IndexPacket * restrict indexes;\n  const IndexPacket * restrict reconstruct_indexes;\n  const PixelPacket * restrict p;\n  const PixelPacket * restrict q;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  q = GetCacheViewVirtualPixels(reconstruct_view, 0, y, reconstruct_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((const PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  reconstruct_indexes = GetCacheViewVirtualIndexQueue(reconstruct_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    distortion += ((area * QuantumScale) * (GetPixelRed(p) - image_statistics[RedChannel].mean)) * (GetPixelRed(q) - reconstruct_statistics[RedChannel].mean);\n    distortion += ((area * QuantumScale) * (GetPixelGreen(p) - image_statistics[GreenChannel].mean)) * (GetPixelGreen(q) - reconstruct_statistics[GreenChannel].mean);\n    distortion += ((area * QuantumScale) * (GetPixelBlue(p) - image_statistics[BlueChannel].mean)) * (q->blue - reconstruct_statistics[BlueChannel].mean);\n    if (image->matte != MagickFalse)\n      distortion += ((area * QuantumScale) * (GetPixelOpacity(p) - image_statistics[OpacityChannel].mean)) * (GetPixelOpacity(q) - reconstruct_statistics[OpacityChannel].mean);\n    if ((image->colorspace == CMYKColorspace) && (reconstruct_image->colorspace == CMYKColorspace))\n      distortion += ((area * QuantumScale) * (GetPixelIndex(indexes + x) - image_statistics[BlackChannel].mean)) * (GetPixelIndex(reconstruct_indexes + x) - reconstruct_statistics[BlackChannel].mean);\n    p++;\n    q++;\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compare/13"}
{"code": "for (i = 0; i < 4; i++)\n{\n  x = (ssize_t) (code / quantum);\n  code -= quantum * x;\n  tuple[i] = (char) (x + ((int) '!'));\n  quantum /= 85L;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/0"}
{"code": "for (n = image->ascii85->offset; n >= 4; n -= 4)\n{\n  for (q = Ascii85Tuple(p); (*q) != '\\0'; q++)\n  {\n    image->ascii85->line_break--;\n    if ((image->ascii85->line_break < 0) && ((*q) != '%'))\n    {\n      (void) WriteBlobByte(image, '\\n');\n      image->ascii85->line_break = 2 * 36;\n    }\n    (void) WriteBlobByte(image, (unsigned char) (*q));\n  }\n\n  p += 8;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/1"}
{"code": "for (n = 0; n < 4; n++)\n  image->ascii85->buffer[n] = *(p++);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/2"}
{"code": "for (i = 0; i < 1021; i++)\n{\n  mb_hash[i] = (HuffmanTable *) 0;\n  mw_hash[i] = (HuffmanTable *) 0;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/3"}
{"code": "for (y = 0; (y < ((ssize_t) image->rows)) && (null_lines < 3);)\n{\n  PixelPacket * restrict q;\n  ssize_t x;\n  p = scanline;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n    *(p++) = (unsigned char) 0;\n\n  color = MagickTrue;\n  code = 0;\n  count = 0;\n  length = 0;\n  runlength = 0;\n  x = 0;\n  for (;;)\n  {\n    if (byte == EOF)\n      break;\n    if (x >= ((ssize_t) image->columns))\n    {\n      while (runlength < 11)\n      {\n        if ((mask & 0xff) == 0)\n        {\n          byte = ReadBlobByte(image);\n          if (byte == EOF)\n            break;\n          mask = 0x80;\n        }\n        runlength++;\n        bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n        mask >>= 1;\n        if (bit != 0)\n          runlength = 0;\n      }\n\n      ;\n      do\n      {\n        {\n          if ((mask & 0xff) == 0)\n          {\n            byte = ReadBlobByte(image);\n            if (byte == EOF)\n              break;\n            mask = 0x80;\n          }\n          runlength++;\n          bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n          mask >>= 1;\n          if (bit != 0)\n            runlength = 0;\n        }\n        ;\n      }\n      while (((int) bit) == 0);\n      break;\n    }\n    bail = MagickFalse;\n    do\n    {\n      if (runlength < 11)\n      {\n        if ((mask & 0xff) == 0)\n        {\n          byte = ReadBlobByte(image);\n          if (byte == EOF)\n            break;\n          mask = 0x80;\n        }\n        runlength++;\n        bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n        mask >>= 1;\n        if (bit != 0)\n          runlength = 0;\n      }\n      else\n      {\n        {\n          if ((mask & 0xff) == 0)\n          {\n            byte = ReadBlobByte(image);\n            if (byte == EOF)\n              break;\n            mask = 0x80;\n          }\n          runlength++;\n          bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n          mask >>= 1;\n          if (bit != 0)\n            runlength = 0;\n        }\n        ;\n        if (((int) bit) != 0)\n        {\n          null_lines++;\n          if (x != 0)\n            null_lines = 0;\n          bail = MagickTrue;\n          break;\n        }\n      }\n      code = (code << 1) + ((size_t) bit);\n      length++;\n    }\n    while (code == 0);\n    if (bail != MagickFalse)\n      break;\n    if (length > 13)\n    {\n      while (runlength < 11)\n      {\n        if ((mask & 0xff) == 0)\n        {\n          byte = ReadBlobByte(image);\n          if (byte == EOF)\n            break;\n          mask = 0x80;\n        }\n        runlength++;\n        bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n        mask >>= 1;\n        if (bit != 0)\n          runlength = 0;\n      }\n\n      ;\n      do\n      {\n        {\n          if ((mask & 0xff) == 0)\n          {\n            byte = ReadBlobByte(image);\n            if (byte == EOF)\n              break;\n            mask = 0x80;\n          }\n          runlength++;\n          bit = (size_t) (((byte & mask) != 0) ? (0x01) : (0x00));\n          mask >>= 1;\n          if (bit != 0)\n            runlength = 0;\n        }\n        ;\n      }\n      while (((int) bit) == 0);\n      break;\n    }\n    if (color != MagickFalse)\n    {\n      if (length < 4)\n        continue;\n      entry = mw_hash[((length + 3510) * (code + 1178)) % 1021];\n    }\n    else\n    {\n      if (length < 2)\n        continue;\n      entry = mb_hash[((length + 293) * (code + 2695)) % 1021];\n    }\n    if (entry == ((const HuffmanTable *) 0))\n      continue;\n    if ((entry->length != length) || (entry->code != code))\n      continue;\n    switch (entry->id)\n    {\n      case 23:\n\n      case 25:\n      {\n        count += (ssize_t) entry->count;\n        if ((x + count) > ((ssize_t) image->columns))\n          count = ((ssize_t) image->columns) - x;\n        if (count > 0)\n        {\n          if (color != MagickFalse)\n          {\n            x += count;\n            count = 0;\n          }\n          else\n            for (; count > 0; count--)\n            scanline[x++] = (unsigned char) 1;\n\n        }\n        color = (unsigned int) ((color == MagickFalse) ? (MagickTrue) : (MagickFalse));\n        break;\n      }\n\n      case 24:\n\n      case 26:\n\n      case 27:\n      {\n        count += (ssize_t) entry->count;\n        break;\n      }\n\n      default:\n        break;\n\n    }\n\n    code = 0;\n    length = 0;\n  }\n\n  p = scanline;\n  q = QueueCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n    break;\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    index = (IndexPacket) (*(p++));\n    SetPixelIndex(indexes + x, index);\n    SetPixelRGBO(q, image->colormap + ((ssize_t) index));\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    break;\n  proceed = SetImageProgress(image, LoadImageTag, y, image->rows);\n  if (proceed == MagickFalse)\n    break;\n  y++;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/4"}
{"code": "for (k = 0; k < 11; k++)\n{\n  if (0 > 0)\n    byte = byte | bit;\n  bit >>= 1;\n  if (((int) (bit & 0xff)) == 0)\n  {\n    if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n      (void) WriteBlobByte(image, (unsigned char) byte);\n    else\n      Ascii85Encode(image, byte);\n    byte = '\\0';\n    bit = (unsigned char) 0x80;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/5"}
{"code": "for (y = 0; y < ((ssize_t) huffman_image->rows); y++)\n{\n  p = GetVirtualPixels(huffman_image, 0, y, huffman_image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  for (x = 0; x < ((ssize_t) huffman_image->columns); x++)\n  {\n    *(q++) = (unsigned char) ((PixelIntensity(p) >= (((MagickRealType) QuantumRange) / 2.0)) ? (0) : (1));\n    p++;\n  }\n\n  q = scanline;\n  for (n = (ssize_t) width; n > 0;)\n  {\n    for (runlength = 0; (n > 0) && ((*q) == 0); n--)\n    {\n      q++;\n      runlength++;\n    }\n\n    if (runlength >= 64)\n    {\n      if (runlength < 1792)\n        entry = MWTable + ((runlength / 64) - 1);\n      else\n        entry = EXTable + ((MagickMin((size_t) runlength, 2560) - 1792) / 64);\n      runlength -= (long) entry->count;\n      {\n        mask = one << (entry->length - 1);\n        while (mask != 0)\n        {\n          {\n            if ((((entry->code & mask) != 0) ? (1) : (0)) > 0)\n              byte = byte | bit;\n            bit >>= 1;\n            if (((int) (bit & 0xff)) == 0)\n            {\n              if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n                (void) WriteBlobByte(image, (unsigned char) byte);\n              else\n                Ascii85Encode(image, byte);\n              byte = '\\0';\n              bit = (unsigned char) 0x80;\n            }\n          }\n          ;\n          mask >>= 1;\n        }\n\n      }\n      ;\n    }\n    entry = TWTable + MagickMin((size_t) runlength, 63);\n    {\n      mask = one << (entry->length - 1);\n      while (mask != 0)\n      {\n        {\n          if ((((entry->code & mask) != 0) ? (1) : (0)) > 0)\n            byte = byte | bit;\n          bit >>= 1;\n          if (((int) (bit & 0xff)) == 0)\n          {\n            if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n              (void) WriteBlobByte(image, (unsigned char) byte);\n            else\n              Ascii85Encode(image, byte);\n            byte = '\\0';\n            bit = (unsigned char) 0x80;\n          }\n        }\n        ;\n        mask >>= 1;\n      }\n\n    }\n    ;\n    if (n != 0)\n    {\n      for (runlength = 0; ((*q) != 0) && (n > 0); n--)\n      {\n        q++;\n        runlength++;\n      }\n\n      if (runlength >= 64)\n      {\n        entry = MBTable + ((runlength / 64) - 1);\n        if (runlength >= 1792)\n          entry = EXTable + ((MagickMin((size_t) runlength, 2560) - 1792) / 64);\n        runlength -= (long) entry->count;\n        {\n          mask = one << (entry->length - 1);\n          while (mask != 0)\n          {\n            {\n              if ((((entry->code & mask) != 0) ? (1) : (0)) > 0)\n                byte = byte | bit;\n              bit >>= 1;\n              if (((int) (bit & 0xff)) == 0)\n              {\n                if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n                  (void) WriteBlobByte(image, (unsigned char) byte);\n                else\n                  Ascii85Encode(image, byte);\n                byte = '\\0';\n                bit = (unsigned char) 0x80;\n              }\n            }\n            ;\n            mask >>= 1;\n          }\n\n        }\n        ;\n      }\n      entry = TBTable + MagickMin((size_t) runlength, 63);\n      {\n        mask = one << (entry->length - 1);\n        while (mask != 0)\n        {\n          {\n            if ((((entry->code & mask) != 0) ? (1) : (0)) > 0)\n              byte = byte | bit;\n            bit >>= 1;\n            if (((int) (bit & 0xff)) == 0)\n            {\n              if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n                (void) WriteBlobByte(image, (unsigned char) byte);\n              else\n                Ascii85Encode(image, byte);\n              byte = '\\0';\n              bit = (unsigned char) 0x80;\n            }\n          }\n          ;\n          mask >>= 1;\n        }\n\n      }\n      ;\n    }\n  }\n\n  for (k = 0; k < 11; k++)\n  {\n    if (0 > 0)\n      byte = byte | bit;\n    bit >>= 1;\n    if (((int) (bit & 0xff)) == 0)\n    {\n      if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n        (void) WriteBlobByte(image, (unsigned char) byte);\n      else\n        Ascii85Encode(image, byte);\n      byte = '\\0';\n      bit = (unsigned char) 0x80;\n    }\n  }\n\n  ;\n  {\n    if (1 > 0)\n      byte = byte | bit;\n    bit >>= 1;\n    if (((int) (bit & 0xff)) == 0)\n    {\n      if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n        (void) WriteBlobByte(image, (unsigned char) byte);\n      else\n        Ascii85Encode(image, byte);\n      byte = '\\0';\n      bit = (unsigned char) 0x80;\n    }\n  }\n  ;\n  q = scanline;\n  if (GetPreviousImageInList(huffman_image) == ((Image *) 0))\n  {\n    proceed = SetImageProgress(huffman_image, LoadImageTag, y, huffman_image->rows);\n    if (proceed == MagickFalse)\n      break;\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/6"}
{"code": "for (i = 0; i < 6; i++)\n{\n  for (k = 0; k < 11; k++)\n  {\n    if (0 > 0)\n      byte = byte | bit;\n    bit >>= 1;\n    if (((int) (bit & 0xff)) == 0)\n    {\n      if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n        (void) WriteBlobByte(image, (unsigned char) byte);\n      else\n        Ascii85Encode(image, byte);\n      byte = '\\0';\n      bit = (unsigned char) 0x80;\n    }\n  }\n\n  ;\n  {\n    if (1 > 0)\n      byte = byte | bit;\n    bit >>= 1;\n    if (((int) (bit & 0xff)) == 0)\n    {\n      if (LocaleCompare(image_info->magick, \"FAX\") == 0)\n        (void) WriteBlobByte(image, (unsigned char) byte);\n      else\n        Ascii85Encode(image, byte);\n      byte = '\\0';\n      bit = (unsigned char) 0x80;\n    }\n  }\n  ;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/7"}
{"code": "for (index = 0; index < 256; index++)\n{\n  table[index].prefix = -1;\n  table[index].suffix = (short) index;\n  table[index].next = -1;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/8"}
{"code": "for (i = 1; i < ((ssize_t) length); i++)\n{\n  index = (ssize_t) last_code;\n  while (index != (-1))\n    if ((table[index].prefix != ((ssize_t) last_code)) || (table[index].suffix != ((ssize_t) pixels[i])))\n    index = table[index].next;\n  else\n  {\n    last_code = (size_t) index;\n    break;\n  }\n\n  if (last_code != ((size_t) index))\n  {\n    {\n      accumulator += last_code << ((32 - code_width) - number_bits);\n      number_bits += code_width;\n      while (number_bits >= 8)\n      {\n        (void) WriteBlobByte(image, (unsigned char) (accumulator >> 24));\n        accumulator = accumulator << 8;\n        number_bits -= 8;\n      }\n\n    }\n    ;\n    table[next_index].prefix = (ssize_t) last_code;\n    table[next_index].suffix = (short) pixels[i];\n    table[next_index].next = table[last_code].next;\n    table[last_code].next = (ssize_t) next_index;\n    next_index++;\n    if ((next_index >> code_width) != 0)\n    {\n      code_width++;\n      if (code_width > 12)\n      {\n        code_width--;\n        {\n          accumulator += 256UL << ((32 - code_width) - number_bits);\n          number_bits += code_width;\n          while (number_bits >= 8)\n          {\n            (void) WriteBlobByte(image, (unsigned char) (accumulator >> 24));\n            accumulator = accumulator << 8;\n            number_bits -= 8;\n          }\n\n        }\n        ;\n        for (index = 0; index < 256; index++)\n        {\n          table[index].prefix = -1;\n          table[index].suffix = index;\n          table[index].next = -1;\n        }\n\n        next_index = 257UL + 1;\n        code_width = 9;\n      }\n    }\n    last_code = (size_t) pixels[i];\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/9"}
{"code": "for (i = (ssize_t) length; i != 0;)\n{\n  switch (i)\n  {\n    case 1:\n    {\n      i--;\n      (void) WriteBlobByte(image, (unsigned char) 0);\n      (void) WriteBlobByte(image, *pixels);\n      break;\n    }\n\n    case 2:\n    {\n      i -= 2;\n      (void) WriteBlobByte(image, (unsigned char) 1);\n      (void) WriteBlobByte(image, *pixels);\n      (void) WriteBlobByte(image, pixels[1]);\n      break;\n    }\n\n    case 3:\n    {\n      i -= 3;\n      if (((*pixels) == (*(pixels + 1))) && ((*(pixels + 1)) == (*(pixels + 2))))\n      {\n        (void) WriteBlobByte(image, (unsigned char) ((256 - 3) + 1));\n        (void) WriteBlobByte(image, *pixels);\n        break;\n      }\n      (void) WriteBlobByte(image, (unsigned char) 2);\n      (void) WriteBlobByte(image, *pixels);\n      (void) WriteBlobByte(image, pixels[1]);\n      (void) WriteBlobByte(image, pixels[2]);\n      break;\n    }\n\n    default:\n    {\n      if (((*pixels) == (*(pixels + 1))) && ((*(pixels + 1)) == (*(pixels + 2))))\n      {\n        count = 3;\n        while ((((ssize_t) count) < i) && ((*pixels) == (*(pixels + count))))\n        {\n          count++;\n          if (count >= 127)\n            break;\n        }\n\n        i -= count;\n        (void) WriteBlobByte(image, (unsigned char) ((256 - count) + 1));\n        (void) WriteBlobByte(image, *pixels);\n        pixels += count;\n        break;\n      }\n      count = 0;\n      while (((*(pixels + count)) != (*((pixels + count) + 1))) || ((*((pixels + count) + 1)) != (*((pixels + count) + 2))))\n      {\n        packbits[count + 1] = pixels[count];\n        count++;\n        if ((((ssize_t) count) >= (i - 3)) || (count >= 127))\n          break;\n      }\n\n      i -= count;\n      *packbits = (unsigned char) (count - 1);\n      for (j = 0; j <= ((ssize_t) count); j++)\n        (void) WriteBlobByte(image, packbits[j]);\n\n      pixels += count;\n      break;\n    }\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_compress/10"}
{"code": "for (y = 0; y < ((ssize_t) composite_image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket *composite_indexes;\n  const PixelPacket *p;\n  IndexPacket *indexes;\n  PixelPacket *q;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(composite_view, 0, y, composite_image->columns, 1, exception);\n  q = GetCacheViewAuthenticPixels(image_view, x_offset, y + y_offset, composite_image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  composite_indexes = GetCacheViewVirtualIndexQueue(composite_view);\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  (void) CopyMagickMemory(q, p, composite_image->columns * (sizeof(*p)));\n  if ((indexes != ((IndexPacket *) 0)) && (composite_indexes != ((const IndexPacket *) 0)))\n    (void) CopyMagickMemory(indexes, composite_indexes, composite_image->columns * (sizeof(*indexes)));\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_CompositeImage)\n    proceed = SetImageProgress(image, \"Composite/Image\", (MagickOffsetType) y, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const PixelPacket *pixels;\n  double brightness;\n  double hue;\n  double saturation;\n  MagickPixelPacket composite;\n  MagickPixelPacket destination;\n  MagickPixelPacket source;\n  const IndexPacket * restrict composite_indexes;\n  const PixelPacket * restrict p;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  if (modify_outside_overlay == MagickFalse)\n  {\n    if (y < y_offset)\n      continue;\n    if ((y - y_offset) >= ((ssize_t) composite_image->rows))\n      continue;\n  }\n  pixels = (PixelPacket *) 0;\n  p = (PixelPacket *) 0;\n  if ((y >= y_offset) && ((y - y_offset) < ((ssize_t) composite_image->rows)))\n  {\n    p = GetCacheViewVirtualPixels(composite_view, 0, y - y_offset, composite_image->columns, 1, exception);\n    if (p == ((const PixelPacket *) 0))\n    {\n      status = MagickFalse;\n      continue;\n    }\n    pixels = p;\n    if (x_offset < 0)\n      p -= x_offset;\n  }\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  composite_indexes = GetCacheViewVirtualIndexQueue(composite_view);\n  source = zero;\n  destination = zero;\n  hue = 0.0;\n  saturation = 0.0;\n  brightness = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (modify_outside_overlay == MagickFalse)\n    {\n      if (x < x_offset)\n      {\n        q++;\n        continue;\n      }\n      if ((x - x_offset) >= ((ssize_t) composite_image->columns))\n        break;\n    }\n    destination.red = (MagickRealType) GetPixelRed(q);\n    destination.green = (MagickRealType) GetPixelGreen(q);\n    destination.blue = (MagickRealType) GetPixelBlue(q);\n    if (image->matte != MagickFalse)\n      destination.opacity = (MagickRealType) GetPixelOpacity(q);\n    if (image->colorspace == CMYKColorspace)\n      destination.index = (MagickRealType) GetPixelIndex(indexes + x);\n    if (image->colorspace == CMYKColorspace)\n    {\n      destination.red = ((MagickRealType) QuantumRange) - destination.red;\n      destination.green = ((MagickRealType) QuantumRange) - destination.green;\n      destination.blue = ((MagickRealType) QuantumRange) - destination.blue;\n      destination.index = ((MagickRealType) QuantumRange) - destination.index;\n    }\n    composite = destination;\n    if (((pixels == ((PixelPacket *) 0)) || (x < x_offset)) || ((x - x_offset) >= ((ssize_t) composite_image->columns)))\n    {\n      switch (compose)\n      {\n        case DissolveCompositeOp:\n\n        case BlendCompositeOp:\n        {\n          composite.opacity = (MagickRealType) (QuantumRange - (destination_dissolve * (QuantumRange - composite.opacity)));\n          break;\n        }\n\n        case ClearCompositeOp:\n\n        case SrcCompositeOp:\n        {\n          CompositeClear(&destination, &composite);\n          break;\n        }\n\n        case InCompositeOp:\n\n        case SrcInCompositeOp:\n\n        case OutCompositeOp:\n\n        case SrcOutCompositeOp:\n\n        case DstInCompositeOp:\n\n        case DstAtopCompositeOp:\n\n        case CopyOpacityCompositeOp:\n\n        case ChangeMaskCompositeOp:\n        {\n          composite.opacity = (MagickRealType) TransparentOpacity;\n          break;\n        }\n\n        default:\n        {\n          (void) GetOneVirtualMagickPixel(composite_image, x - x_offset, y - y_offset, &composite, exception);\n          break;\n        }\n\n      }\n\n      if (image->colorspace == CMYKColorspace)\n      {\n        composite.red = ((MagickRealType) QuantumRange) - composite.red;\n        composite.green = ((MagickRealType) QuantumRange) - composite.green;\n        composite.blue = ((MagickRealType) QuantumRange) - composite.blue;\n        composite.index = ((MagickRealType) QuantumRange) - composite.index;\n      }\n      SetPixelRed(q, ClampToQuantum(composite.red));\n      SetPixelGreen(q, ClampToQuantum(composite.green));\n      SetPixelBlue(q, ClampToQuantum(composite.blue));\n      if (image->matte != MagickFalse)\n        SetPixelOpacity(q, ClampToQuantum(composite.opacity));\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(indexes + x, ClampToQuantum(composite.index));\n      q++;\n      continue;\n    }\n    source.red = (MagickRealType) GetPixelRed(p);\n    source.green = (MagickRealType) GetPixelGreen(p);\n    source.blue = (MagickRealType) GetPixelBlue(p);\n    if (composite_image->matte != MagickFalse)\n      source.opacity = (MagickRealType) GetPixelOpacity(p);\n    if (composite_image->colorspace == CMYKColorspace)\n      source.index = (MagickRealType) GetPixelIndex((composite_indexes + x) - x_offset);\n    if (composite_image->colorspace == CMYKColorspace)\n    {\n      source.red = ((MagickRealType) QuantumRange) - source.red;\n      source.green = ((MagickRealType) QuantumRange) - source.green;\n      source.blue = ((MagickRealType) QuantumRange) - source.blue;\n      source.index = ((MagickRealType) QuantumRange) - source.index;\n    }\n    switch (compose)\n    {\n      case ClearCompositeOp:\n      {\n        CompositeClear(&destination, &composite);\n        break;\n      }\n\n      case SrcCompositeOp:\n\n      case CopyCompositeOp:\n\n      case ReplaceCompositeOp:\n      {\n        composite = source;\n        break;\n      }\n\n      case NoCompositeOp:\n\n      case DstCompositeOp:\n        break;\n\n      case OverCompositeOp:\n\n      case SrcOverCompositeOp:\n      {\n        MagickPixelCompositeOver(&source, source.opacity, &destination, destination.opacity, &composite);\n        break;\n      }\n\n      case DstOverCompositeOp:\n      {\n        MagickPixelCompositeOver(&destination, destination.opacity, &source, source.opacity, &composite);\n        break;\n      }\n\n      case SrcInCompositeOp:\n\n      case InCompositeOp:\n      {\n        CompositeIn(&source, &destination, &composite);\n        break;\n      }\n\n      case DstInCompositeOp:\n      {\n        CompositeIn(&destination, &source, &composite);\n        break;\n      }\n\n      case OutCompositeOp:\n\n      case SrcOutCompositeOp:\n      {\n        CompositeOut(&source, &destination, &composite);\n        break;\n      }\n\n      case DstOutCompositeOp:\n      {\n        CompositeOut(&destination, &source, &composite);\n        break;\n      }\n\n      case AtopCompositeOp:\n\n      case SrcAtopCompositeOp:\n      {\n        CompositeAtop(&source, &destination, &composite);\n        break;\n      }\n\n      case DstAtopCompositeOp:\n      {\n        CompositeAtop(&destination, &source, &composite);\n        break;\n      }\n\n      case XorCompositeOp:\n      {\n        CompositeXor(&source, &destination, &composite);\n        break;\n      }\n\n      case PlusCompositeOp:\n      {\n        CompositePlus(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case MinusDstCompositeOp:\n      {\n        CompositeMinus(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case MinusSrcCompositeOp:\n      {\n        CompositeMinus(&destination, &source, channel, &composite);\n        break;\n      }\n\n      case ModulusAddCompositeOp:\n      {\n        CompositeModulusAdd(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case ModulusSubtractCompositeOp:\n      {\n        CompositeModulusSubtract(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case DifferenceCompositeOp:\n      {\n        CompositeDifference(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case ExclusionCompositeOp:\n      {\n        CompositeExclusion(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case MultiplyCompositeOp:\n      {\n        CompositeMultiply(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case ScreenCompositeOp:\n      {\n        CompositeScreen(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case DivideDstCompositeOp:\n      {\n        CompositeDivide(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case DivideSrcCompositeOp:\n      {\n        CompositeDivide(&destination, &source, channel, &composite);\n        break;\n      }\n\n      case DarkenCompositeOp:\n      {\n        CompositeDarken(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case LightenCompositeOp:\n      {\n        CompositeLighten(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case DarkenIntensityCompositeOp:\n      {\n        CompositeDarkenIntensity(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case LightenIntensityCompositeOp:\n      {\n        CompositeLightenIntensity(&source, &destination, channel, &composite);\n        break;\n      }\n\n      case MathematicsCompositeOp:\n      {\n        CompositeMathematics(&source, &destination, channel, &geometry_info, &composite);\n        break;\n      }\n\n      case ColorDodgeCompositeOp:\n      {\n        CompositeColorDodge(&source, &destination, &composite);\n        break;\n      }\n\n      case ColorBurnCompositeOp:\n      {\n        CompositeColorBurn(&source, &destination, &composite);\n        break;\n      }\n\n      case LinearDodgeCompositeOp:\n      {\n        CompositeLinearDodge(&source, &destination, &composite);\n        break;\n      }\n\n      case LinearBurnCompositeOp:\n      {\n        CompositeLinearBurn(&source, &destination, &composite);\n        break;\n      }\n\n      case HardLightCompositeOp:\n      {\n        CompositeHardLight(&source, &destination, &composite);\n        break;\n      }\n\n      case OverlayCompositeOp:\n      {\n        CompositeHardLight(&destination, &source, &composite);\n        break;\n      }\n\n      case SoftLightCompositeOp:\n      {\n        CompositeSoftLight(&source, &destination, &composite);\n        break;\n      }\n\n      case LinearLightCompositeOp:\n      {\n        CompositeLinearLight(&source, &destination, &composite);\n        break;\n      }\n\n      case PegtopLightCompositeOp:\n      {\n        CompositePegtopLight(&source, &destination, &composite);\n        break;\n      }\n\n      case VividLightCompositeOp:\n      {\n        CompositeVividLight(&source, &destination, &composite);\n        break;\n      }\n\n      case PinLightCompositeOp:\n      {\n        CompositePinLight(&source, &destination, &composite);\n        break;\n      }\n\n      case ChangeMaskCompositeOp:\n      {\n        if ((composite.opacity > (((MagickRealType) QuantumRange) / 2.0)) || (IsMagickColorSimilar(&source, &destination) != MagickFalse))\n          composite.opacity = (MagickRealType) TransparentOpacity;\n        else\n          composite.opacity = (MagickRealType) OpaqueOpacity;\n        break;\n      }\n\n      case BumpmapCompositeOp:\n      {\n        if (source.opacity == TransparentOpacity)\n          break;\n        CompositeBumpmap(&source, &destination, &composite);\n        break;\n      }\n\n      case DissolveCompositeOp:\n      {\n        MagickPixelCompositeOver(&source, (MagickRealType) (QuantumRange - (source_dissolve * (QuantumRange - source.opacity))), &destination, (MagickRealType) (QuantumRange - (destination_dissolve * (QuantumRange - destination.opacity))), &composite);\n        break;\n      }\n\n      case BlendCompositeOp:\n      {\n        MagickPixelCompositeBlend(&source, source_dissolve, &destination, destination_dissolve, &composite);\n        break;\n      }\n\n      case ThresholdCompositeOp:\n      {\n        CompositeThreshold(&source, &destination, threshold, amount, &composite);\n        break;\n      }\n\n      case ModulateCompositeOp:\n      {\n        ssize_t offset;\n        if (source.opacity == TransparentOpacity)\n          break;\n        offset = (ssize_t) (MagickPixelIntensityToQuantum(&source) - midpoint);\n        if (offset == 0)\n          break;\n        CompositeHSB(destination.red, destination.green, destination.blue, &hue, &saturation, &brightness);\n        brightness += ((0.01 * percent_brightness) * offset) / midpoint;\n        saturation *= 0.01 * percent_saturation;\n        HSBComposite(hue, saturation, brightness, &composite.red, &composite.green, &composite.blue);\n        break;\n      }\n\n      case HueCompositeOp:\n      {\n        if (source.opacity == TransparentOpacity)\n          break;\n        if (destination.opacity == TransparentOpacity)\n        {\n          composite = source;\n          break;\n        }\n        CompositeHSB(destination.red, destination.green, destination.blue, &hue, &saturation, &brightness);\n        CompositeHSB(source.red, source.green, source.blue, &hue, &sans, &sans);\n        HSBComposite(hue, saturation, brightness, &composite.red, &composite.green, &composite.blue);\n        if (source.opacity < destination.opacity)\n          composite.opacity = source.opacity;\n        break;\n      }\n\n      case SaturateCompositeOp:\n      {\n        if (source.opacity == TransparentOpacity)\n          break;\n        if (destination.opacity == TransparentOpacity)\n        {\n          composite = source;\n          break;\n        }\n        CompositeHSB(destination.red, destination.green, destination.blue, &hue, &saturation, &brightness);\n        CompositeHSB(source.red, source.green, source.blue, &sans, &saturation, &sans);\n        HSBComposite(hue, saturation, brightness, &composite.red, &composite.green, &composite.blue);\n        if (source.opacity < destination.opacity)\n          composite.opacity = source.opacity;\n        break;\n      }\n\n      case LuminizeCompositeOp:\n      {\n        if (source.opacity == TransparentOpacity)\n          break;\n        if (destination.opacity == TransparentOpacity)\n        {\n          composite = source;\n          break;\n        }\n        CompositeHSB(destination.red, destination.green, destination.blue, &hue, &saturation, &brightness);\n        CompositeHSB(source.red, source.green, source.blue, &sans, &sans, &brightness);\n        HSBComposite(hue, saturation, brightness, &composite.red, &composite.green, &composite.blue);\n        if (source.opacity < destination.opacity)\n          composite.opacity = source.opacity;\n        break;\n      }\n\n      case ColorizeCompositeOp:\n      {\n        if (source.opacity == TransparentOpacity)\n          break;\n        if (destination.opacity == TransparentOpacity)\n        {\n          composite = source;\n          break;\n        }\n        CompositeHSB(destination.red, destination.green, destination.blue, &sans, &sans, &brightness);\n        CompositeHSB(source.red, source.green, source.blue, &hue, &saturation, &sans);\n        HSBComposite(hue, saturation, brightness, &composite.red, &composite.green, &composite.blue);\n        if (source.opacity < destination.opacity)\n          composite.opacity = source.opacity;\n        break;\n      }\n\n      case CopyRedCompositeOp:\n\n      case CopyCyanCompositeOp:\n      {\n        composite.red = source.red;\n        break;\n      }\n\n      case CopyGreenCompositeOp:\n\n      case CopyMagentaCompositeOp:\n      {\n        composite.green = source.green;\n        break;\n      }\n\n      case CopyBlueCompositeOp:\n\n      case CopyYellowCompositeOp:\n      {\n        composite.blue = source.blue;\n        break;\n      }\n\n      case CopyOpacityCompositeOp:\n      {\n        if (source.matte == MagickFalse)\n        {\n          composite.opacity = (MagickRealType) (QuantumRange - MagickPixelIntensityToQuantum(&source));\n          break;\n        }\n        composite.opacity = source.opacity;\n        break;\n      }\n\n      case CopyBlackCompositeOp:\n      {\n        if (source.colorspace != CMYKColorspace)\n          ConvertRGBToCMYK(&source);\n        composite.index = source.index;\n        break;\n      }\n\n      case BlurCompositeOp:\n\n      case DisplaceCompositeOp:\n\n      case DistortCompositeOp:\n      {\n        composite = source;\n        break;\n      }\n\n      default:\n        break;\n\n    }\n\n    if (image->colorspace == CMYKColorspace)\n    {\n      composite.red = ((MagickRealType) QuantumRange) - composite.red;\n      composite.green = ((MagickRealType) QuantumRange) - composite.green;\n      composite.blue = ((MagickRealType) QuantumRange) - composite.blue;\n      composite.index = ((MagickRealType) QuantumRange) - composite.index;\n    }\n    SetPixelRed(q, ClampToQuantum(composite.red));\n    SetPixelGreen(q, ClampToQuantum(composite.green));\n    SetPixelBlue(q, ClampToQuantum(composite.blue));\n    SetPixelOpacity(q, ClampToQuantum(composite.opacity));\n    if (image->colorspace == CMYKColorspace)\n      SetPixelIndex(indexes + x, ClampToQuantum(composite.index));\n    p++;\n    if (p >= (pixels + composite_image->columns))\n      p = pixels;\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_CompositeImageChannel)\n    proceed = SetImageProgress(image, \"Composite/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(progress,status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y += (ssize_t) texture->rows)\n{\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  for (x = 0; x < ((ssize_t) image->columns); x += (ssize_t) texture->columns)\n  {\n    MagickBooleanType thread_status;\n    thread_status = CompositeImage(image, image->compose, texture, x + texture->tile_offset.x, y + texture->tile_offset.y);\n    if (thread_status == MagickFalse)\n    {\n      status = thread_status;\n      break;\n    }\n  }\n\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TextureImage)\n    proceed = SetImageProgress(image, \"Texture/Image\", (MagickOffsetType) y, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  const IndexPacket *texture_indexes;\n  const PixelPacket *p;\n  IndexPacket *indexes;\n  ssize_t x;\n  PixelPacket *q;\n  size_t width;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(texture_view, texture->tile_offset.x, (y + texture->tile_offset.y) % texture->rows, texture->columns, 1, exception);\n  q = QueueCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if ((p == ((const PixelPacket *) 0)) || (q == ((PixelPacket *) 0)))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  texture_indexes = GetCacheViewVirtualIndexQueue(texture_view);\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x += (ssize_t) texture->columns)\n  {\n    width = texture->columns;\n    if ((x + ((ssize_t) width)) > ((ssize_t) image->columns))\n      width = image->columns - x;\n    (void) CopyMagickMemory(q, p, width * (sizeof(*p)));\n    if ((image->colorspace == CMYKColorspace) && (texture->colorspace == CMYKColorspace))\n    {\n      (void) CopyMagickMemory(indexes, texture_indexes, width * (sizeof(*indexes)));\n      indexes += width;\n    }\n    q += width;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TextureImage)\n    proceed = SetImageProgress(image, \"Texture/Image\", (MagickOffsetType) y, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status) omp_throttle(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/3"}
{"code": "for (y = 0; y < ((ssize_t) composite_image->rows); y++)\n{\n  MagickBooleanType sync;\n  const PixelPacket * restrict p;\n  PixelPacket * restrict r;\n  IndexPacket * restrict destination_indexes;\n  ssize_t x;\n  if (((y + y_offset) < 0) || ((y + y_offset) >= ((ssize_t) image->rows)))\n    continue;\n  p = GetCacheViewVirtualPixels(composite_view, 0, y, composite_image->columns, 1, exception);\n  r = QueueCacheViewAuthenticPixels(destination_view, 0, y, destination_image->columns, 1, &image->exception);\n  if ((p == ((const PixelPacket *) 0)) || (r == ((PixelPacket *) 0)))\n    break;\n  destination_indexes = GetCacheViewAuthenticIndexQueue(destination_view);\n  for (x = 0; x < ((ssize_t) composite_image->columns); x++)\n  {\n    if (((x_offset + x) < 0) || ((x_offset + x) >= ((ssize_t) image->columns)))\n    {\n      p++;\n      continue;\n    }\n    if (fabs(angle_range) > MagickEpsilon)\n    {\n      MagickRealType angle;\n      angle = angle_start + ((angle_range * QuantumScale) * GetPixelBlue(p));\n      blur.x1 = width * cos(angle);\n      blur.x2 = width * sin(angle);\n      blur.y1 = (-height) * sin(angle);\n      blur.y2 = height * cos(angle);\n    }\n    ScaleResampleFilter(resample_filter, (blur.x1 * QuantumScale) * GetPixelRed(p), (blur.y1 * QuantumScale) * GetPixelGreen(p), (blur.x2 * QuantumScale) * GetPixelRed(p), (blur.y2 * QuantumScale) * GetPixelGreen(p));\n    (void) ResamplePixelColor(resample_filter, ((double) x_offset) + x, ((double) y_offset) + y, &pixel);\n    SetPixelPacket(destination_image, &pixel, r, destination_indexes + x);\n    p++;\n    r++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(destination_view, exception);\n  if (sync == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/4"}
{"code": "for (y = 0; y < ((ssize_t) composite_image->rows); y++)\n{\n  MagickBooleanType sync;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  if (((y + y_offset) < 0) || ((y + y_offset) >= ((ssize_t) image->rows)))\n    continue;\n  p = GetCacheViewVirtualPixels(composite_view, 0, y, composite_image->columns, 1, exception);\n  r = QueueCacheViewAuthenticPixels(destination_view, 0, y, destination_image->columns, 1, &image->exception);\n  if ((p == ((const PixelPacket *) 0)) || (r == ((PixelPacket *) 0)))\n    break;\n  destination_indexes = GetCacheViewAuthenticIndexQueue(destination_view);\n  for (x = 0; x < ((ssize_t) composite_image->columns); x++)\n  {\n    if (((x_offset + x) < 0) || ((x_offset + x) >= ((ssize_t) image->columns)))\n    {\n      p++;\n      continue;\n    }\n    offset.x = (((horizontal_scale * (GetPixelRed(p) - ((((MagickRealType) QuantumRange) + 1.0) / 2.0))) / ((((MagickRealType) QuantumRange) + 1.0) / 2.0)) + center.x) + ((compose == DisplaceCompositeOp) ? (x) : (0));\n    offset.y = (((vertical_scale * (GetPixelGreen(p) - ((((MagickRealType) QuantumRange) + 1.0) / 2.0))) / ((((MagickRealType) QuantumRange) + 1.0) / 2.0)) + center.y) + ((compose == DisplaceCompositeOp) ? (y) : (0));\n    (void) InterpolateMagickPixelPacket(image, image_view, UndefinedInterpolatePixel, (double) offset.x, (double) offset.y, &pixel, exception);\n    pixel.opacity = ((MagickRealType) QuantumRange) * (1.0 - ((1.0 - (QuantumScale * pixel.opacity)) * (1.0 - (QuantumScale * GetPixelOpacity(p)))));\n    SetPixelPacket(destination_image, &pixel, r, destination_indexes + x);\n    p++;\n    r++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(destination_view, exception);\n  if (sync == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_composite/5"}
{"code": "for (i = 0; p != ((const CoderInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    coder_map[i++] = p;\n  p = (const CoderInfo *) GetNextValueInSplayTree(coder_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_coder/0"}
{"code": "for (i = 0; p != ((const CoderInfo *) 0);)\n{\n  if ((p->stealth == MagickFalse) && (GlobExpression(p->name, pattern, MagickFalse) != MagickFalse))\n    coder_map[i++] = ConstantString(p->name);\n  p = (const CoderInfo *) GetNextValueInSplayTree(coder_list);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_coder/1"}
{"code": "for (i = 0; i < ((ssize_t) number_coders); i++)\n{\n  if (coder_info[i]->stealth != MagickFalse)\n    continue;\n  if ((path == ((const char *) 0)) || (LocaleCompare(path, coder_info[i]->path) != 0))\n  {\n    if (coder_info[i]->path != ((char *) 0))\n      (void) FormatLocaleFile(file, \"\\nPath: %s\\n\\n\", coder_info[i]->path);\n    (void) FormatLocaleFile(file, \"Magick      Coder\\n\");\n    (void) FormatLocaleFile(file, \"-------------------------------------------------------------------------------\\n\");\n  }\n  path = coder_info[i]->path;\n  (void) FormatLocaleFile(file, \"%s\", coder_info[i]->magick);\n  for (j = (ssize_t) strlen(coder_info[i]->magick); j <= 11; j++)\n    (void) FormatLocaleFile(file, \" \");\n\n  if (coder_info[i]->name != ((char *) 0))\n    (void) FormatLocaleFile(file, \"%s\", coder_info[i]->name);\n  (void) FormatLocaleFile(file, \"\\n\");\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_coder/2"}
{"code": "for (q = (char *) xml; (*q) != '\\0';)\n{\n  GetMagickToken(q, &q, token);\n  if ((*token) == '\\0')\n    break;\n  (void) CopyMagickString(keyword, token, MaxTextExtent);\n  if (LocaleNCompare(keyword, \"<!DOCTYPE\", 9) == 0)\n  {\n    while ((LocaleNCompare(q, \"]>\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleNCompare(keyword, \"<!--\", 4) == 0)\n  {\n    while ((LocaleNCompare(q, \"->\", 2) != 0) && ((*q) != '\\0'))\n      GetMagickToken(q, &q, token);\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<include\") == 0)\n  {\n    while ((((*token) != '/') && ((*(token + 1)) != '>')) && ((*q) != '\\0'))\n    {\n      (void) CopyMagickString(keyword, token, MaxTextExtent);\n      GetMagickToken(q, &q, token);\n      if ((*token) != '=')\n        continue;\n      GetMagickToken(q, &q, token);\n      if (LocaleCompare(keyword, \"file\") == 0)\n      {\n        if (depth > 200)\n          (void) ThrowMagickException(exception, GetMagickModule(), ConfigureError, \"IncludeNodeNestedTooDeeply\", \"`%s'\", token);\n        else\n        {\n          char path[MaxTextExtent];\n          char *xml;\n          GetPathComponent(filename, HeadPath, path);\n          if ((*path) != '\\0')\n            (void) ConcatenateMagickString(path, DirectorySeparator, MaxTextExtent);\n          if ((*token) == (*DirectorySeparator))\n            (void) CopyMagickString(path, token, MaxTextExtent);\n          else\n            (void) ConcatenateMagickString(path, token, MaxTextExtent);\n          xml = FileToString(path, ~0, exception);\n          if (xml != ((char *) 0))\n          {\n            status = LoadCoderList(xml, path, depth + 1, exception);\n            xml = (char *) RelinquishMagickMemory(xml);\n          }\n        }\n      }\n    }\n\n    continue;\n  }\n  if (LocaleCompare(keyword, \"<coder\") == 0)\n  {\n    coder_info = (CoderInfo *) AcquireMagickMemory(sizeof(*coder_info));\n    if (coder_info == ((CoderInfo *) 0))\n      ThrowFatalException(ResourceLimitFatalError, \"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(coder_info, 0, sizeof(*coder_info));\n    coder_info->path = ConstantString(filename);\n    coder_info->exempt = MagickFalse;\n    coder_info->signature = MagickSignature;\n    continue;\n  }\n  if (coder_info == ((CoderInfo *) 0))\n    continue;\n  if (LocaleCompare(keyword, \"/>\") == 0)\n  {\n    status = AddValueToSplayTree(coder_list, ConstantString(coder_info->magick), coder_info);\n    if (status == MagickFalse)\n      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", coder_info->magick);\n    coder_info = (CoderInfo *) 0;\n  }\n  GetMagickToken(q, (const char **) 0, token);\n  if ((*token) != '=')\n    continue;\n  GetMagickToken(q, &q, token);\n  GetMagickToken(q, &q, token);\n  switch (*keyword)\n  {\n    case 'M':\n\n    case 'm':\n    {\n      if (LocaleCompare((char *) keyword, \"magick\") == 0)\n      {\n        coder_info->magick = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'N':\n\n    case 'n':\n    {\n      if (LocaleCompare((char *) keyword, \"name\") == 0)\n      {\n        coder_info->name = ConstantString(token);\n        break;\n      }\n      break;\n    }\n\n    case 'S':\n\n    case 's':\n    {\n      if (LocaleCompare((char *) keyword, \"stealth\") == 0)\n      {\n        coder_info->stealth = IsMagickTrue(token);\n        break;\n      }\n      break;\n    }\n\n    default:\n      break;\n\n  }\n\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_coder/3"}
{"code": "for (i = 0; i < ((ssize_t) ((sizeof(CoderMap)) / (sizeof(*CoderMap)))); i++)\n{\n  CoderInfo *coder_info;\n  const CoderMapInfo *p;\n  p = CoderMap + i;\n  coder_info = (CoderInfo *) AcquireMagickMemory(sizeof(*coder_info));\n  if (coder_info == ((CoderInfo *) 0))\n  {\n    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", coder_info->name);\n    continue;\n  }\n  (void) ResetMagickMemory(coder_info, 0, sizeof(*coder_info));\n  coder_info->path = (char *) \"[built-in]\";\n  coder_info->magick = (char *) p->magick;\n  coder_info->name = (char *) p->name;\n  coder_info->exempt = MagickTrue;\n  coder_info->signature = MagickSignature;\n  status = AddValueToSplayTree(coder_list, ConstantString(coder_info->magick), coder_info);\n  if (status == MagickFalse)\n    (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, \"MemoryAllocationFailed\", \"`%s'\", coder_info->name);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_coder/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  RectangleInfo bounding_box;\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  #pragma omp critical (MagickCore_GetImageBoundingBox)\n  bounding_box = bounds;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetMagickPixelPacket(image, p, indexes + x, &pixel);\n    if ((x < bounding_box.x) && (IsMagickColorSimilar(&pixel, &target[0]) == MagickFalse))\n      bounding_box.x = x;\n    if ((x > ((ssize_t) bounding_box.width)) && (IsMagickColorSimilar(&pixel, &target[1]) == MagickFalse))\n      bounding_box.width = (size_t) x;\n    if ((y < bounding_box.y) && (IsMagickColorSimilar(&pixel, &target[0]) == MagickFalse))\n      bounding_box.y = y;\n    if ((y > ((ssize_t) bounding_box.height)) && (IsMagickColorSimilar(&pixel, &target[2]) == MagickFalse))\n      bounding_box.height = (size_t) y;\n    p++;\n  }\n\n  #pragma omp critical (MagickCore_GetImageBoundingBox)\n  {\n    if (bounding_box.x < bounds.x)\n      bounds.x = bounding_box.x;\n    if (bounding_box.y < bounds.y)\n      bounds.y = bounding_box.y;\n    if (bounding_box.width > bounds.width)\n      bounds.width = bounding_box.width;\n    if (bounding_box.height > bounds.height)\n      bounds.height = bounding_box.height;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/0"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  const int id = GetOpenMPThreadId();\n  if (status == MagickFalse)\n    continue;\n  while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n  {\n    MagickStatusType status;\n    QuantumAny range;\n    status = 0;\n    range = GetQuantumRange(current_depth[id]);\n    if ((channel & RedChannel) != 0)\n      status |= GetPixelRed(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelRed(p), range), range);\n    if ((channel & GreenChannel) != 0)\n      status |= GetPixelGreen(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelGreen(p), range), range);\n    if ((channel & BlueChannel) != 0)\n      status |= GetPixelBlue(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelBlue(p), range), range);\n    if (status == 0)\n      break;\n    current_depth[id]++;\n  }\n\n  p++;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  const int id = GetOpenMPThreadId();\n  const IndexPacket * restrict indexes;\n  const PixelPacket * restrict p;\n  ssize_t x;\n  if (status == MagickFalse)\n    continue;\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    continue;\n  indexes = GetCacheViewVirtualIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n    {\n      MagickStatusType status;\n      QuantumAny range;\n      status = 0;\n      range = GetQuantumRange(current_depth[id]);\n      if ((channel & RedChannel) != 0)\n        status |= GetPixelRed(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelRed(p), range), range);\n      if ((channel & GreenChannel) != 0)\n        status |= GetPixelGreen(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelGreen(p), range), range);\n      if ((channel & BlueChannel) != 0)\n        status |= GetPixelBlue(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelBlue(p), range), range);\n      if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n        status |= GetPixelOpacity(p) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelOpacity(p), range), range);\n      if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n        status |= GetPixelIndex(indexes + x) != ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelIndex(indexes + x), range), range);\n      if (status == 0)\n        break;\n      current_depth[id]++;\n    }\n\n    p++;\n  }\n\n  if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if ((channel & RedChannel) != 0)\n      SetPixelRed(q, ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelRed(q), range), range));\n    if ((channel & GreenChannel) != 0)\n      SetPixelGreen(q, ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelGreen(q), range), range));\n    if ((channel & BlueChannel) != 0)\n      SetPixelBlue(q, ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelBlue(q), range), range));\n    if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n      SetPixelOpacity(q, ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelOpacity(q), range), range));\n    if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n      SetPixelIndex(indexes + x, ScaleAnyToQuantum(ScaleQuantumToAny(GetPixelIndex(indexes + x), range), range));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n  {\n    status = MagickFalse;\n    continue;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/3"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  if ((channel & RedChannel) != 0)\n    p->red = ScaleAnyToQuantum(ScaleQuantumToAny(p->red, range), range);\n  if ((channel & GreenChannel) != 0)\n    p->green = ScaleAnyToQuantum(ScaleQuantumToAny(p->green, range), range);\n  if ((channel & BlueChannel) != 0)\n    p->blue = ScaleAnyToQuantum(ScaleQuantumToAny(p->blue, range), range);\n  if ((channel & OpacityChannel) != 0)\n    p->opacity = ScaleAnyToQuantum(ScaleQuantumToAny(p->opacity, range), range);\n  p++;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/4"}
{"code": "for (id = 0; id < ((ssize_t) number_threads); id++)\n  current_depth[id] = 1;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/5"}
{"code": "for (id = 1; id < ((ssize_t) number_threads); id++)\n  if (depth < current_depth[id])\n  depth = current_depth[id];\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/6"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (IsGrayPixel(p) == MagickFalse)\n    {\n      type = UndefinedType;\n      break;\n    }\n    if ((type == BilevelType) && (IsMonochromePixel(p) == MagickFalse))\n      type = GrayscaleType;\n    p++;\n  }\n\n  if (type == UndefinedType)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/7"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (IsMonochromePixel(p) == MagickFalse)\n    {\n      type = UndefinedType;\n      break;\n    }\n    p++;\n  }\n\n  if (type == UndefinedType)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/8"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  p = GetCacheViewVirtualPixels(image_view, 0, y, image->columns, 1, exception);\n  if (p == ((const PixelPacket *) 0))\n    break;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    if (GetPixelOpacity(p) != OpaqueOpacity)\n      break;\n    p++;\n  }\n\n  if (x < ((ssize_t) image->columns))\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_attribute/9"}
{"code": "for (i = 1; textlist[i] != ((char *) 0); i++)\n  if (strlen(textlist[i]) > length)\n  length = strlen(textlist[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/0"}
{"code": "for (i = 0; textlist[i] != ((char *) 0); i++)\n{\n  annotate_info->affine.tx = geometry_info.xi - image->page.x;\n  annotate_info->affine.ty = geometry_info.psi - image->page.y;\n  (void) CloneString(&annotate->text, textlist[i]);\n  (void) GetTypeMetrics(image, annotate, &metrics);\n  height = (ssize_t) (((metrics.ascent - metrics.descent) + draw_info->interline_spacing) + 0.5);\n  switch (annotate->gravity)\n  {\n    case UndefinedGravity:\n\n    default:\n    {\n      offset.x = annotate_info->affine.tx + ((i * annotate_info->affine.ry) * height);\n      offset.y = annotate_info->affine.ty + ((i * annotate_info->affine.sy) * height);\n      break;\n    }\n\n    case NorthWestGravity:\n    {\n      offset.x = ((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + ((i * annotate_info->affine.ry) * height)) + (annotate_info->affine.ry * (metrics.ascent + metrics.descent));\n      offset.y = ((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + ((i * annotate_info->affine.sy) * height)) + (annotate_info->affine.sy * metrics.ascent);\n      break;\n    }\n\n    case NorthGravity:\n    {\n      offset.x = ((((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + (geometry.width / 2.0)) + ((i * annotate_info->affine.ry) * height)) - ((annotate_info->affine.sx * (metrics.width + metrics.bounds.x1)) / 2.0)) + (annotate_info->affine.ry * (metrics.ascent + metrics.descent));\n      offset.y = (((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + ((i * annotate_info->affine.sy) * height)) + (annotate_info->affine.sy * metrics.ascent)) - ((annotate_info->affine.rx * (metrics.width - metrics.bounds.x1)) / 2.0);\n      break;\n    }\n\n    case NorthEastGravity:\n    {\n      offset.x = (((((((geometry.width == 0) ? (1.0) : (-1.0)) * annotate_info->affine.tx) + geometry.width) + ((i * annotate_info->affine.ry) * height)) - (annotate_info->affine.sx * (metrics.width + metrics.bounds.x1))) + (annotate_info->affine.ry * (metrics.ascent + metrics.descent))) - 1.0;\n      offset.y = (((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + ((i * annotate_info->affine.sy) * height)) + (annotate_info->affine.sy * metrics.ascent)) - (annotate_info->affine.rx * (metrics.width - metrics.bounds.x1));\n      break;\n    }\n\n    case WestGravity:\n    {\n      offset.x = ((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + ((i * annotate_info->affine.ry) * height)) + ((annotate_info->affine.ry * ((metrics.ascent + metrics.descent) - ((number_lines - 1.0) * height))) / 2.0);\n      offset.y = (((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + (geometry.height / 2.0)) + ((i * annotate_info->affine.sy) * height)) + ((annotate_info->affine.sy * ((metrics.ascent + metrics.descent) - ((number_lines - 1.0) * height))) / 2.0);\n      break;\n    }\n\n    case StaticGravity:\n\n    case CenterGravity:\n    {\n      offset.x = ((((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + (geometry.width / 2.0)) + ((i * annotate_info->affine.ry) * height)) - ((annotate_info->affine.sx * (metrics.width + metrics.bounds.x1)) / 2.0)) + ((annotate_info->affine.ry * ((metrics.ascent + metrics.descent) - ((number_lines - 1) * height))) / 2.0);\n      offset.y = ((((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + (geometry.height / 2.0)) + ((i * annotate_info->affine.sy) * height)) - ((annotate_info->affine.rx * (metrics.width + metrics.bounds.x1)) / 2.0)) + ((annotate_info->affine.sy * ((metrics.ascent + metrics.descent) - ((number_lines - 1.0) * height))) / 2.0);\n      break;\n    }\n\n    case EastGravity:\n    {\n      offset.x = (((((((geometry.width == 0) ? (1.0) : (-1.0)) * annotate_info->affine.tx) + geometry.width) + ((i * annotate_info->affine.ry) * height)) - (annotate_info->affine.sx * (metrics.width + metrics.bounds.x1))) + ((annotate_info->affine.ry * ((metrics.ascent + metrics.descent) - ((number_lines - 1.0) * height))) / 2.0)) - 1.0;\n      offset.y = ((((((geometry.height == 0) ? (-1.0) : (1.0)) * annotate_info->affine.ty) + (geometry.height / 2.0)) + ((i * annotate_info->affine.sy) * height)) - (annotate_info->affine.rx * (metrics.width + metrics.bounds.x1))) + ((annotate_info->affine.sy * ((metrics.ascent + metrics.descent) - ((number_lines - 1.0) * height))) / 2.0);\n      break;\n    }\n\n    case SouthWestGravity:\n    {\n      offset.x = ((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + ((i * annotate_info->affine.ry) * height)) - ((annotate_info->affine.ry * (number_lines - 1.0)) * height);\n      offset.y = ((((((geometry.height == 0) ? (1.0) : (-1.0)) * annotate_info->affine.ty) + geometry.height) + ((i * annotate_info->affine.sy) * height)) - ((annotate_info->affine.sy * (number_lines - 1.0)) * height)) + metrics.descent;\n      break;\n    }\n\n    case SouthGravity:\n    {\n      offset.x = ((((((geometry.width == 0) ? (-1.0) : (1.0)) * annotate_info->affine.tx) + (geometry.width / 2.0)) + ((i * annotate_info->affine.ry) * height)) - ((annotate_info->affine.sx * (metrics.width + metrics.bounds.x1)) / 2.0)) - (((annotate_info->affine.ry * (number_lines - 1.0)) * height) / 2.0);\n      offset.y = (((((((geometry.height == 0) ? (1.0) : (-1.0)) * annotate_info->affine.ty) + geometry.height) + ((i * annotate_info->affine.sy) * height)) - ((annotate_info->affine.rx * (metrics.width + metrics.bounds.x1)) / 2.0)) - ((annotate_info->affine.sy * (number_lines - 1.0)) * height)) + metrics.descent;\n      break;\n    }\n\n    case SouthEastGravity:\n    {\n      offset.x = (((((((geometry.width == 0) ? (1.0) : (-1.0)) * annotate_info->affine.tx) + geometry.width) + ((i * annotate_info->affine.ry) * height)) - (annotate_info->affine.sx * (metrics.width + metrics.bounds.x1))) - ((annotate_info->affine.ry * (number_lines - 1.0)) * height)) - 1.0;\n      offset.y = (((((((geometry.height == 0) ? (1.0) : (-1.0)) * annotate_info->affine.ty) + geometry.height) + ((i * annotate_info->affine.sy) * height)) - (annotate_info->affine.rx * (metrics.width + metrics.bounds.x1))) - ((annotate_info->affine.sy * (number_lines - 1.0)) * height)) + metrics.descent;\n      break;\n    }\n\n  }\n\n  switch (annotate->align)\n  {\n    case LeftAlign:\n    {\n      offset.x = annotate_info->affine.tx + ((i * annotate_info->affine.ry) * height);\n      offset.y = annotate_info->affine.ty + ((i * annotate_info->affine.sy) * height);\n      break;\n    }\n\n    case CenterAlign:\n    {\n      offset.x = (annotate_info->affine.tx + ((i * annotate_info->affine.ry) * height)) - ((annotate_info->affine.sx * (metrics.width + metrics.bounds.x1)) / 2.0);\n      offset.y = (annotate_info->affine.ty + ((i * annotate_info->affine.sy) * height)) - ((annotate_info->affine.rx * (metrics.width + metrics.bounds.x1)) / 2.0);\n      break;\n    }\n\n    case RightAlign:\n    {\n      offset.x = (annotate_info->affine.tx + ((i * annotate_info->affine.ry) * height)) - (annotate_info->affine.sx * (metrics.width + metrics.bounds.x1));\n      offset.y = (annotate_info->affine.ty + ((i * annotate_info->affine.sy) * height)) - (annotate_info->affine.rx * (metrics.width + metrics.bounds.x1));\n      break;\n    }\n\n    default:\n      break;\n\n  }\n\n  if (draw_info->undercolor.opacity != TransparentOpacity)\n  {\n    DrawInfo *undercolor_info;\n    undercolor_info = CloneDrawInfo((ImageInfo *) 0, (DrawInfo *) 0);\n    undercolor_info->fill = draw_info->undercolor;\n    undercolor_info->affine = draw_info->affine;\n    undercolor_info->affine.tx = offset.x - (draw_info->affine.ry * metrics.ascent);\n    undercolor_info->affine.ty = offset.y - (draw_info->affine.sy * metrics.ascent);\n    (void) FormatLocaleString(primitive, MaxTextExtent, \"rectangle 0,0 %g,%.20g\", metrics.origin.x, (double) height);\n    (void) CloneString(&undercolor_info->primitive, primitive);\n    (void) DrawImage(image, undercolor_info);\n    (void) DestroyDrawInfo(undercolor_info);\n  }\n  annotate_info->affine.tx = offset.x;\n  annotate_info->affine.ty = offset.y;\n  (void) FormatLocaleString(primitive, MaxTextExtent, \"stroke-width %g line 0,0 %g,0\", metrics.underline_thickness, metrics.width);\n  if (annotate->decorate == OverlineDecoration)\n  {\n    annotate_info->affine.ty -= draw_info->affine.sy * ((metrics.ascent + metrics.descent) - metrics.underline_position);\n    (void) CloneString(&annotate_info->primitive, primitive);\n    (void) DrawImage(image, annotate_info);\n  }\n  else\n    if (annotate->decorate == UnderlineDecoration)\n  {\n    annotate_info->affine.ty -= draw_info->affine.sy * metrics.underline_position;\n    (void) CloneString(&annotate_info->primitive, primitive);\n    (void) DrawImage(image, annotate_info);\n  }\n  status = RenderType(image, annotate, &offset, &metrics);\n  if (status == MagickFalse)\n    break;\n  if (annotate->decorate == LineThroughDecoration)\n  {\n    annotate_info->affine.ty -= (draw_info->affine.sy * ((height + metrics.underline_position) + metrics.descent)) / 2.0;\n    (void) CloneString(&annotate_info->primitive, primitive);\n    (void) DrawImage(image, annotate_info);\n  }\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/1"}
{"code": "for (i = 0; textlist[i] != ((char *) 0); i++)\n  textlist[i] = DestroyString(textlist[i]);\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/2"}
{"code": "for (p = *caption; GetUTFCode(p) != 0; p += GetUTFOctets(p))\n{\n  if (IsUTFSpace(GetUTFCode(p)) != MagickFalse)\n    s = p;\n  for (i = 0; i < ((ssize_t) GetUTFOctets(p)); i++)\n    *(q++) = *(p + i);\n\n  *q = '\\0';\n  status = GetTypeMetrics(image, draw_info, metrics);\n  if (status == MagickFalse)\n    break;\n  width = (size_t) floor(metrics->width + 0.5);\n  if (GetUTFCode(p) != '\\n')\n    if (width <= image->columns)\n    continue;\n  if (s == ((char *) 0))\n  {\n    s = p;\n    while ((IsUTFSpace(GetUTFCode(s)) == MagickFalse) && (GetUTFCode(s) != 0))\n      s += GetUTFOctets(s);\n\n  }\n  if (GetUTFCode(s) != 0)\n  {\n    *s = '\\n';\n    p = s;\n  }\n  else\n    if (split != MagickFalse)\n  {\n    char *target;\n    ssize_t n;\n    target = AcquireString(*caption);\n    n = p - (*caption);\n    CopyMagickString(target, *caption, n + 1);\n    ConcatenateMagickString(target, \"\\n\", strlen(*caption) + 1);\n    ConcatenateMagickString(target, p, strlen(*caption) + 2);\n    (void) DestroyString(*caption);\n    *caption = target;\n    p = (*caption) + n;\n  }\n  s = (char *) 0;\n  q = draw_info->text;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/3"}
{"code": "for (p = *caption; GetUTFCode(p) != 0; p += GetUTFOctets(p))\n  if (GetUTFCode(p) == '\\n')\n  i++;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/4"}
{"code": "for (i = 1; textlist[i] != ((char *) 0); i++)\n{\n  annotate_info->text = textlist[i];\n  status = GetTypeMetrics(image, annotate_info, &extent);\n  if (extent.width > metrics->width)\n    *metrics = extent;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/5"}
{"code": "for (i = 0; i < ((ssize_t) MagickMin(strlen(text), (MaxTextExtent - escapes) - 1)); i++)\n{\n  if ((text[i] == '(') || (text[i] == ')'))\n  {\n    *(p++) = '\\\\';\n    escapes++;\n  }\n  *(p++) = text[i];\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/6"}
{"code": "for (i = 0; i <= ((ssize_t) (strlen(draw_info->text) + 2)); i++)\n{\n  point.x = fabs(((draw_info->affine.sx * i) * draw_info->pointsize) + ((draw_info->affine.ry * 2.0) * draw_info->pointsize));\n  point.y = fabs(((draw_info->affine.rx * i) * draw_info->pointsize) + ((draw_info->affine.sy * 2.0) * draw_info->pointsize));\n  if (point.x > extent.x)\n    extent.x = point.x;\n  if (point.y > extent.y)\n    extent.y = point.y;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/7"}
{"code": "for (y = 0; y < ((ssize_t) annotate_image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  q = GetCacheViewAuthenticPixels(annotate_view, 0, y, annotate_image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n    break;\n  for (x = 0; x < ((ssize_t) annotate_image->columns); x++)\n  {\n    (void) GetFillColor(draw_info, x, y, &fill_color);\n    SetPixelAlpha(q, ClampToQuantum(((QuantumRange - ((MagickRealType) PixelIntensityToQuantum(q))) * (QuantumRange - fill_color.opacity)) / QuantumRange));\n    SetPixelRed(q, fill_color.red);\n    SetPixelGreen(q, fill_color.green);\n    SetPixelBlue(q, fill_color.blue);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(annotate_view, exception);\n  if (sync == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_annotate/8"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  ssize_t index;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    index = ((ssize_t) (GetPixelIndex(indexes + x) + displace)) % image->colors;\n    if (index < 0)\n      index += (ssize_t) image->colors;\n    SetPixelIndex(indexes + x, index);\n    SetPixelRGBO(q, image->colormap + ((ssize_t) index));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colormap/0"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n  image->colormap[i].opacity = (IndexPacket) i;\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colormap/1"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n  pixels[(ssize_t) image->colormap[i].opacity] = (unsigned short) i;\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colormap/2"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  size_t pixel;\n  pixel = (size_t) (i * (QuantumRange / MagickMax(colors - 1, 1)));\n  image->colormap[i].red = (Quantum) pixel;\n  image->colormap[i].green = (Quantum) pixel;\n  image->colormap[i].blue = (Quantum) pixel;\n  image->colormap[i].opacity = OpaqueOpacity;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colormap/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  IndexPacket index;\n  ssize_t x;\n  IndexPacket * restrict indexes;\n  PixelPacket * restrict q;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    index = (IndexPacket) pixels[(ssize_t) GetPixelIndex(indexes + x)];\n    SetPixelIndex(indexes + x, index);\n    SetPixelRGBO(q, image->colormap + ((ssize_t) index));\n    q++;\n  }\n\n  if (SyncCacheViewAuthenticPixels(image_view, exception) == MagickFalse)\n    status = MagickFalse;\n  if (status == MagickFalse)\n    break;\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colormap/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelRed(q))));\n    SetPixelGreen(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelGreen(q))));\n    SetPixelBlue(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelBlue(q))));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/0"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetMagickPixelPacket(image, q, indexes + x, &pixel);\n    ConvertRGBToCMYK(&pixel);\n    SetPixelPacket(image, &pixel, q, indexes + x);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/1"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double brightness;\n  double hue;\n  double saturation;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  hue = 0.0;\n  saturation = 0.0;\n  brightness = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ConvertRGBToHSB(GetPixelRed(q), GetPixelGreen(q), GetPixelBlue(q), &hue, &saturation, &brightness);\n    SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * hue));\n    SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * saturation));\n    SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * brightness));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/2"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double hue;\n  double lightness;\n  double saturation;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  hue = 0.0;\n  saturation = 0.0;\n  lightness = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ConvertRGBToHSL(GetPixelRed(q), GetPixelGreen(q), GetPixelBlue(q), &hue, &saturation, &lightness);\n    SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * hue));\n    SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * saturation));\n    SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * lightness));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/3"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double blackness;\n  double hue;\n  double whiteness;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  hue = 0.0;\n  whiteness = 0.0;\n  blackness = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ConvertRGBToHWB(GetPixelRed(q), GetPixelGreen(q), GetPixelBlue(q), &hue, &whiteness, &blackness);\n    SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * hue));\n    SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * whiteness));\n    SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * blackness));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/4"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double a;\n  double b;\n  double L;\n  double X;\n  double Y;\n  double Z;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  L = 0.0;\n  a = 0.0;\n  b = 0.0;\n  X = 0.0;\n  Y = 0.0;\n  Z = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    ConvertRGBToXYZ(GetPixelRed(q), GetPixelGreen(q), GetPixelBlue(q), &X, &Y, &Z);\n    ConvertXYZToLab(X, Y, Z, &L, &a, &b);\n    SetPixelRed(q, ClampToQuantum(((MagickRealType) QuantumRange) * L));\n    SetPixelGreen(q, ClampToQuantum(((MagickRealType) QuantumRange) * a));\n    SetPixelBlue(q, ClampToQuantum(((MagickRealType) QuantumRange) * b));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/5"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n  logmap[i] = ScaleMapToQuantum((MagickRealType) ((MaxMap * (reference_white + (log10(black + ((((MagickRealType) i) / MaxMap) * (1.0 - black))) / (((gamma / density) * 0.002) / film_gamma)))) / 1024.0));\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/6"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = (ssize_t) image->columns; x != 0; x--)\n  {\n    SetPixelRed(q, logmap[ScaleQuantumToMap(GetPixelRed(q))]);\n    SetPixelGreen(q, logmap[ScaleQuantumToMap(GetPixelGreen(q))]);\n    SetPixelBlue(q, logmap[ScaleQuantumToMap(GetPixelBlue(q))]);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/7"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.33333f * ((MagickRealType) i);\n  y_map[i].x = 0.33334f * ((MagickRealType) i);\n  z_map[i].x = 0.33333f * ((MagickRealType) i);\n  x_map[i].y = 0.50000f * ((MagickRealType) i);\n  y_map[i].y = 0.00000f * ((MagickRealType) i);\n  z_map[i].y = (-0.50000f) * ((MagickRealType) i);\n  x_map[i].z = (-0.25000f) * ((MagickRealType) i);\n  y_map[i].z = 0.50000f * ((MagickRealType) i);\n  z_map[i].z = (-0.25000f) * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/8"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.29900f * ((MagickRealType) i);\n  y_map[i].x = 0.58700f * ((MagickRealType) i);\n  z_map[i].x = 0.11400f * ((MagickRealType) i);\n  x_map[i].y = 0.29900f * ((MagickRealType) i);\n  y_map[i].y = 0.58700f * ((MagickRealType) i);\n  z_map[i].y = 0.11400f * ((MagickRealType) i);\n  x_map[i].z = 0.29900f * ((MagickRealType) i);\n  y_map[i].z = 0.58700f * ((MagickRealType) i);\n  z_map[i].z = 0.11400f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/9"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.299000f * ((MagickRealType) i);\n  y_map[i].x = 0.587000f * ((MagickRealType) i);\n  z_map[i].x = 0.114000f * ((MagickRealType) i);\n  x_map[i].y = (-0.168730f) * ((MagickRealType) i);\n  y_map[i].y = (-0.331264f) * ((MagickRealType) i);\n  z_map[i].y = 0.500000f * ((MagickRealType) i);\n  x_map[i].z = 0.500000f * ((MagickRealType) i);\n  y_map[i].z = (-0.418688f) * ((MagickRealType) i);\n  z_map[i].z = (-0.081312f) * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/10"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.21260f * ((MagickRealType) i);\n  y_map[i].x = 0.71520f * ((MagickRealType) i);\n  z_map[i].x = 0.07220f * ((MagickRealType) i);\n  x_map[i].y = 0.21260f * ((MagickRealType) i);\n  y_map[i].y = 0.71520f * ((MagickRealType) i);\n  z_map[i].y = 0.07220f * ((MagickRealType) i);\n  x_map[i].z = 0.21260f * ((MagickRealType) i);\n  y_map[i].z = 0.71520f * ((MagickRealType) i);\n  z_map[i].z = 0.07220f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/11"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.212600f * ((MagickRealType) i);\n  y_map[i].x = 0.715200f * ((MagickRealType) i);\n  z_map[i].x = 0.072200f * ((MagickRealType) i);\n  x_map[i].y = (-0.114572f) * ((MagickRealType) i);\n  y_map[i].y = (-0.385428f) * ((MagickRealType) i);\n  z_map[i].y = 0.500000f * ((MagickRealType) i);\n  x_map[i].z = 0.500000f * ((MagickRealType) i);\n  y_map[i].z = (-0.454153f) * ((MagickRealType) i);\n  z_map[i].z = (-0.045847f) * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/12"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  MagickRealType v;\n  v = ((MagickRealType) i) / ((MagickRealType) MaxMap);\n  if ((((MagickRealType) i) / ((MagickRealType) MaxMap)) <= 0.04045f)\n    v /= 12.92f;\n  else\n    v = (MagickRealType) pow(((((double) i) / MaxMap) + 0.055) / 1.055, 2.4);\n  x_map[i].x = (1.0f * MaxMap) * v;\n  y_map[i].x = (0.0f * MaxMap) * v;\n  z_map[i].x = (0.0f * MaxMap) * v;\n  x_map[i].y = (0.0f * MaxMap) * v;\n  y_map[i].y = (1.0f * MaxMap) * v;\n  z_map[i].y = (0.0f * MaxMap) * v;\n  x_map[i].z = (0.0f * MaxMap) * v;\n  y_map[i].z = (0.0f * MaxMap) * v;\n  z_map[i].z = (1.0f * MaxMap) * v;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/13"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.4124564f * ((MagickRealType) i);\n  y_map[i].x = 0.3575761f * ((MagickRealType) i);\n  z_map[i].x = 0.1804375f * ((MagickRealType) i);\n  x_map[i].y = 0.2126729f * ((MagickRealType) i);\n  y_map[i].y = 0.7151522f * ((MagickRealType) i);\n  z_map[i].y = 0.0721750f * ((MagickRealType) i);\n  x_map[i].z = 0.0193339f * ((MagickRealType) i);\n  y_map[i].z = 0.1191920f * ((MagickRealType) i);\n  z_map[i].z = 0.9503041f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/14"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.29900f * ((MagickRealType) i);\n  y_map[i].x = 0.58700f * ((MagickRealType) i);\n  z_map[i].x = 0.11400f * ((MagickRealType) i);\n  x_map[i].y = 0.59600f * ((MagickRealType) i);\n  y_map[i].y = (-0.27400f) * ((MagickRealType) i);\n  z_map[i].y = (-0.32200f) * ((MagickRealType) i);\n  x_map[i].z = 0.21100f * ((MagickRealType) i);\n  y_map[i].z = (-0.52300f) * ((MagickRealType) i);\n  z_map[i].z = 0.31200f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/15"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.299000f * ((MagickRealType) i);\n  y_map[i].x = 0.587000f * ((MagickRealType) i);\n  z_map[i].x = 0.114000f * ((MagickRealType) i);\n  x_map[i].y = (-0.168736f) * ((MagickRealType) i);\n  y_map[i].y = (-0.331264f) * ((MagickRealType) i);\n  z_map[i].y = 0.500000f * ((MagickRealType) i);\n  x_map[i].z = 0.500000f * ((MagickRealType) i);\n  y_map[i].z = (-0.418688f) * ((MagickRealType) i);\n  z_map[i].z = (-0.081312f) * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/16"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.29900f * ((MagickRealType) i);\n  y_map[i].x = 0.58700f * ((MagickRealType) i);\n  z_map[i].x = 0.11400f * ((MagickRealType) i);\n  x_map[i].y = (-0.14740f) * ((MagickRealType) i);\n  y_map[i].y = (-0.28950f) * ((MagickRealType) i);\n  z_map[i].y = 0.43690f * ((MagickRealType) i);\n  x_map[i].z = 0.61500f * ((MagickRealType) i);\n  y_map[i].z = (-0.51500f) * ((MagickRealType) i);\n  z_map[i].z = (-0.10000f) * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/17"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickPixelPacket pixel;\n  ssize_t x;\n  PixelPacket * restrict q;\n  size_t blue;\n  size_t green;\n  size_t red;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    red = ScaleQuantumToMap(GetPixelRed(q));\n    green = ScaleQuantumToMap(GetPixelGreen(q));\n    blue = ScaleQuantumToMap(GetPixelBlue(q));\n    pixel.red = ((x_map[red].x + y_map[green].x) + z_map[blue].x) + ((MagickRealType) primary_info.x);\n    pixel.green = ((x_map[red].y + y_map[green].y) + z_map[blue].y) + ((MagickRealType) primary_info.y);\n    pixel.blue = ((x_map[red].z + y_map[green].z) + z_map[blue].z) + ((MagickRealType) primary_info.z);\n    SetPixelRed(q, ScaleMapToQuantum(pixel.red));\n    SetPixelGreen(q, ScaleMapToQuantum(pixel.green));\n    SetPixelBlue(q, ScaleMapToQuantum(pixel.blue));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_RGBTransformImage)\n    proceed = SetImageProgress(image, \"RGBTransform/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/18"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetPixelRed(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelRed(q))));\n    SetPixelGreen(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelGreen(q))));\n    SetPixelBlue(q, ClampToQuantum((MagickRealType) (QuantumRange - GetPixelBlue(q))));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/19"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  MagickPixelPacket pixel;\n  IndexPacket * restrict indexes;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  indexes = GetCacheViewAuthenticIndexQueue(image_view);\n  pixel = zero;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    SetMagickPixelPacket(image, q, indexes + x, &pixel);\n    ConvertCMYKToRGB(&pixel);\n    SetPixelPacket(image, &pixel, q, indexes + x);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/20"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double brightness;\n  double hue;\n  double saturation;\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    Quantum blue;\n    Quantum green;\n    Quantum red;\n    hue = (double) (QuantumScale * GetPixelRed(q));\n    saturation = (double) (QuantumScale * GetPixelGreen(q));\n    brightness = (double) (QuantumScale * GetPixelBlue(q));\n    ConvertHSBToRGB(hue, saturation, brightness, &red, &green, &blue);\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/21"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double hue;\n  double lightness;\n  double saturation;\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    Quantum blue;\n    Quantum green;\n    Quantum red;\n    hue = (double) (QuantumScale * GetPixelRed(q));\n    saturation = (double) (QuantumScale * GetPixelGreen(q));\n    lightness = (double) (QuantumScale * GetPixelBlue(q));\n    ConvertHSLToRGB(hue, saturation, lightness, &red, &green, &blue);\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/22"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double blackness;\n  double hue;\n  double whiteness;\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    Quantum blue;\n    Quantum green;\n    Quantum red;\n    hue = (double) (QuantumScale * GetPixelRed(q));\n    whiteness = (double) (QuantumScale * GetPixelGreen(q));\n    blackness = (double) (QuantumScale * GetPixelBlue(q));\n    ConvertHWBToRGB(hue, whiteness, blackness, &red, &green, &blue);\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/23"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  double a;\n  double b;\n  double L;\n  double X;\n  double Y;\n  double Z;\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  X = 0.0;\n  Y = 0.0;\n  Z = 0.0;\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    Quantum blue;\n    Quantum green;\n    Quantum red;\n    L = QuantumScale * GetPixelRed(q);\n    a = QuantumScale * GetPixelGreen(q);\n    b = QuantumScale * GetPixelBlue(q);\n    ConvertLabToXYZ(L, a, b, &X, &Y, &Z);\n    ConvertXYZToRGB(X, Y, Z, &red, &green, &blue);\n    SetPixelRed(q, red);\n    SetPixelGreen(q, green);\n    SetPixelBlue(q, blue);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/24"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = (ssize_t) image->columns; x != 0; x--)\n  {\n    SetPixelRed(q, logmap[ScaleQuantumToMap(GetPixelRed(q))]);\n    SetPixelGreen(q, logmap[ScaleQuantumToMap(GetPixelGreen(q))]);\n    SetPixelBlue(q, logmap[ScaleQuantumToMap(GetPixelBlue(q))]);\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/25"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.500000f * ((2.000000 * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].x = (-0.333340f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = 0.000000f;\n  z_map[i].y = 0.666665f * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = (-0.500000f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = (-0.333340f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/26"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.000000f;\n  z_map[i].x = (1.402000f * 0.500000f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = ((-0.344136f) * 0.500000f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].y = ((-0.714136f) * 0.500000f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = (1.772000f * 0.500000f) * ((2.000000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = 0.000000f;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/27"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.000000f;\n  z_map[i].x = (1.574800f * 0.50000f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = ((-0.187324f) * 0.50000f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].y = ((-0.468124f) * 0.50000f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = (1.855600f * 0.50000f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = 0.00000f;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/28"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 1.0f * ((MagickRealType) i);\n  y_map[i].x = 0.0f * ((MagickRealType) i);\n  z_map[i].x = 0.0f * ((MagickRealType) i);\n  x_map[i].y = 0.0f * ((MagickRealType) i);\n  y_map[i].y = 1.0f * ((MagickRealType) i);\n  z_map[i].y = 0.0f * ((MagickRealType) i);\n  x_map[i].z = 0.0f * ((MagickRealType) i);\n  y_map[i].z = 0.0f * ((MagickRealType) i);\n  z_map[i].z = 1.0f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/29"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 3.2404542f * ((MagickRealType) i);\n  x_map[i].y = (-0.9692660f) * ((MagickRealType) i);\n  x_map[i].z = 0.0556434f * ((MagickRealType) i);\n  y_map[i].x = (-1.5371385f) * ((MagickRealType) i);\n  y_map[i].y = 1.8760108f * ((MagickRealType) i);\n  y_map[i].z = (-0.2040259f) * ((MagickRealType) i);\n  z_map[i].x = (-0.4985314f) * ((MagickRealType) i);\n  z_map[i].y = 0.0415560f * ((MagickRealType) i);\n  z_map[i].z = 1.0572252f * ((MagickRealType) i);\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/30"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 1.3584000f * ((MagickRealType) i);\n  y_map[i].x = 0.0000000f;\n  z_map[i].x = 1.8215000f * (((MagickRealType) i) - ((MagickRealType) ScaleQuantumToMap(ScaleCharToQuantum(137))));\n  x_map[i].y = 1.3584000f * ((MagickRealType) i);\n  y_map[i].y = (-0.4302726f) * (((MagickRealType) i) - ((MagickRealType) ScaleQuantumToMap(ScaleCharToQuantum(156))));\n  z_map[i].y = (-0.9271435f) * (((MagickRealType) i) - ((MagickRealType) ScaleQuantumToMap(ScaleCharToQuantum(137))));\n  x_map[i].z = 1.3584000f * ((MagickRealType) i);\n  y_map[i].z = 2.2179000f * (((MagickRealType) i) - ((MagickRealType) ScaleQuantumToMap(ScaleCharToQuantum(156))));\n  z_map[i].z = 0.0000000f;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/31"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.47810f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].x = 0.31070f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = (-0.13635f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].y = (-0.32340f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = (-0.55185f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = 0.85030f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/32"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.000000f;\n  z_map[i].x = 0.701000f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = (-0.172068f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].y = 0.357068f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = 0.88600f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = 0.00000f;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/33"}
{"code": "for (i = 0; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = (MagickRealType) i;\n  y_map[i].x = 0.00000f;\n  z_map[i].x = 0.56990f * ((2.0000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].y = (MagickRealType) i;\n  y_map[i].y = (-0.19690f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].y = (-0.29025f) * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  x_map[i].z = (MagickRealType) i;\n  y_map[i].z = 1.01395f * ((2.00000f * ((MagickRealType) i)) - ((MagickRealType) MaxMap));\n  z_map[i].z = 0.00000f;\n}\n", "pragma": "omp parallel for schedule(dynamic,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/34"}
{"code": "for (y = 0; y < ((ssize_t) image->rows); y++)\n{\n  MagickBooleanType sync;\n  MagickPixelPacket pixel;\n  ssize_t x;\n  PixelPacket * restrict q;\n  if (status == MagickFalse)\n    continue;\n  q = GetCacheViewAuthenticPixels(image_view, 0, y, image->columns, 1, exception);\n  if (q == ((PixelPacket *) 0))\n  {\n    status = MagickFalse;\n    continue;\n  }\n  for (x = 0; x < ((ssize_t) image->columns); x++)\n  {\n    size_t blue;\n    size_t green;\n    size_t red;\n    red = ScaleQuantumToMap(GetPixelRed(q));\n    green = ScaleQuantumToMap(GetPixelGreen(q));\n    blue = ScaleQuantumToMap(GetPixelBlue(q));\n    pixel.red = (x_map[red].x + y_map[green].x) + z_map[blue].x;\n    pixel.green = (x_map[red].y + y_map[green].y) + z_map[blue].y;\n    pixel.blue = (x_map[red].z + y_map[green].z) + z_map[blue].z;\n    switch (colorspace)\n    {\n      case YCCColorspace:\n      {\n        pixel.red = QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.red)];\n        pixel.green = QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.green)];\n        pixel.blue = QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.blue)];\n        break;\n      }\n\n      case sRGBColorspace:\n      {\n        if ((QuantumScale * pixel.red) <= 0.0031308)\n          pixel.red *= 12.92f;\n        else\n          pixel.red = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.red, 1.0 / 2.4)) - 0.055);\n        if ((QuantumScale * pixel.green) <= 0.0031308)\n          pixel.green *= 12.92f;\n        else\n          pixel.green = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.green, 1.0 / 2.4)) - 0.055);\n        if ((QuantumScale * pixel.blue) <= 0.0031308)\n          pixel.blue *= 12.92f;\n        else\n          pixel.blue = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.blue, 1.0 / 2.4)) - 0.055);\n        break;\n      }\n\n      default:\n        break;\n\n    }\n\n    SetPixelRed(q, ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.red));\n    SetPixelGreen(q, ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.green));\n    SetPixelBlue(q, ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.blue));\n    q++;\n  }\n\n  sync = SyncCacheViewAuthenticPixels(image_view, exception);\n  if (sync == MagickFalse)\n    status = MagickFalse;\n  if (image->progress_monitor != ((MagickProgressMonitor) 0))\n  {\n    MagickBooleanType proceed;\n    #pragma omp critical (MagickCore_TransformRGBImage)\n    proceed = SetImageProgress(image, \"Transform/Image\", progress++, image->rows);\n    if (proceed == MagickFalse)\n      status = MagickFalse;\n  }\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/35"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  MagickPixelPacket pixel;\n  size_t blue;\n  size_t green;\n  size_t red;\n  red = ScaleQuantumToMap(image->colormap[i].red);\n  green = ScaleQuantumToMap(image->colormap[i].green);\n  blue = ScaleQuantumToMap(image->colormap[i].blue);\n  pixel.red = (x_map[red].x + y_map[green].x) + z_map[blue].x;\n  pixel.green = (x_map[red].y + y_map[green].y) + z_map[blue].y;\n  pixel.blue = (x_map[red].z + y_map[green].z) + z_map[blue].z;\n  switch (colorspace)\n  {\n    case YCCColorspace:\n    {\n      image->colormap[i].red = (Quantum) (QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.red)]);\n      image->colormap[i].green = (Quantum) (QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.green)]);\n      image->colormap[i].blue = (Quantum) (QuantumRange * YCCMap[RoundToYCC((1024.0 * QuantumScale) * pixel.blue)]);\n      break;\n    }\n\n    case sRGBColorspace:\n    {\n      if ((QuantumScale * pixel.red) <= 0.0031308)\n        pixel.red *= 12.92f;\n      else\n        pixel.red = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.red, 1.0 / 2.4)) - 0.055);\n      if ((QuantumScale * pixel.green) <= 0.0031308)\n        pixel.green *= 12.92f;\n      else\n        pixel.green = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.green, 1.0 / 2.4)) - 0.055);\n      if ((QuantumScale * pixel.blue) <= 0.0031308)\n        pixel.blue *= 12.92f;\n      else\n        pixel.blue = ((MagickRealType) QuantumRange) * ((1.055 * pow(QuantumScale * pixel.blue, 1.0 / 2.4)) - 0.055);\n    }\n\n    default:\n    {\n      image->colormap[i].red = ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.red);\n      image->colormap[i].green = ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.green);\n      image->colormap[i].blue = ScaleMapToQuantum((((MagickRealType) MaxMap) * QuantumScale) * pixel.blue);\n      break;\n    }\n\n  }\n\n}\n", "pragma": "omp parallel for schedule(dynamic,4) shared(status)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/36"}
{"code": "for (i = 0; i <= ((ssize_t) (0.018 * MaxMap)); i++)\n{\n  x_map[i].x = 0.003962014134275617f * ((MagickRealType) i);\n  y_map[i].x = 0.007778268551236748f * ((MagickRealType) i);\n  z_map[i].x = 0.001510600706713781f * ((MagickRealType) i);\n  x_map[i].y = (-0.002426619775463276f) * ((MagickRealType) i);\n  y_map[i].y = (-0.004763965913702149f) * ((MagickRealType) i);\n  z_map[i].y = 0.007190585689165425f * ((MagickRealType) i);\n  x_map[i].z = 0.006927257754597858f * ((MagickRealType) i);\n  y_map[i].z = (-0.005800713697502058f) * ((MagickRealType) i);\n  z_map[i].z = (-0.0011265440570958f) * ((MagickRealType) i);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/37"}
{"code": "for (; i <= ((ssize_t) MaxMap); i++)\n{\n  x_map[i].x = 0.2201118963486454 * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  y_map[i].x = 0.4321260306242638 * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  z_map[i].x = 0.08392226148409894 * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  x_map[i].y = (-0.1348122097479598) * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  y_map[i].y = (-0.2646647729834528) * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  z_map[i].y = 0.3994769827314126 * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  x_map[i].z = 0.3848476530332144 * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  y_map[i].z = (-0.3222618720834477) * ((1.099f * ((MagickRealType) i)) - 0.099f);\n  z_map[i].z = (-0.06258578094976668) * ((1.099f * ((MagickRealType) i)) - 0.099f);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/38"}
{"code": "for (i = 0; i < ((ssize_t) image->colors); i++)\n{\n  MagickPixelPacket pixel;\n  red = ScaleQuantumToMap(image->colormap[i].red);\n  green = ScaleQuantumToMap(image->colormap[i].green);\n  blue = ScaleQuantumToMap(image->colormap[i].blue);\n  pixel.red = ((x_map[red].x + y_map[green].x) + z_map[blue].x) + primary_info.x;\n  pixel.green = ((x_map[red].y + y_map[green].y) + z_map[blue].y) + primary_info.y;\n  pixel.blue = ((x_map[red].z + y_map[green].z) + z_map[blue].z) + primary_info.z;\n  image->colormap[i].red = ScaleMapToQuantum(pixel.red);\n  image->colormap[i].green = ScaleMapToQuantum(pixel.green);\n  image->colormap[i].blue = ScaleMapToQuantum(pixel.blue);\n}\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/39"}
{"code": "for (i = 0; i <= ((ssize_t) ((reference_black * MaxMap) / 1024.0)); i++)\n  logmap[i] = (Quantum) 0;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/40"}
{"code": "for (; i < ((ssize_t) ((reference_white * MaxMap) / 1024.0)); i++)\n  logmap[i] = ClampToQuantum((((MagickRealType) QuantumRange) / (1.0 - black)) * (pow(10.0, (((((1024.0 * i) / MaxMap) - reference_white) * (gamma / density)) * 0.002) / film_gamma) - black));\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/41"}
{"code": "for (; i <= ((ssize_t) MaxMap); i++)\n  logmap[i] = (Quantum) QuantumRange;\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/spec_loops/367.imagick/src/magick_colorspace/42"}
