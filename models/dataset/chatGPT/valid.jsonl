{"code": "for (i = 0; i < n; i++)\n{\n  uplus[i] = (u[i] + c1) - (dt * u[i]);\n  sum = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    sum += sigma[(i * n) + j] * u[j];\n  }\n\n  uplus[i] += c2 * (sum - (u[i] * temp_vec[i]));\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kpetrakis/OpenMP-Project/lif1d_omp1/0"}
{"code": "for (i = currow; i < nsize; i++)\n{\n  tmp = matrix[i][currow];\n  if (tmp != 0.0)\n  {\n    big = tmp;\n    irow = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaowei-su/ParallelGaussianElimination/gaussOPENMP/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  weights[i] *= exp(probability[i]);\n  acc += weights[i];\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkhachatrian/openmplab/func/2"}
{"code": "for (i = 0; i < argc; i++)\n{\n  printf(\"argv[%d]: %s\\n\", i, argv[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chpapantonis/Parallel_Programming/OpenMP/main/1"}
{"code": "for (j = 0; j < 10; j++)\n{\n  stddev[j] = 0.0;\n  for (i = 0; i < 10; i++)\n  {\n    stddev[j] += data[i] + mean[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/demo/demo/1"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      wijk = ws[k][j][i];\n      wp1 = ws[k + 1][j][i];\n      wm1 = ws[k - 1][j][i];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dz1tz1 * ((u[k + 1][j][i][0] - (2.0 * u[k][j][i][0])) + u[k - 1][j][i][0]))) - (tz2 * (u[k + 1][j][i][3] - u[k - 1][j][i][3]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dz2tz1 * ((u[k + 1][j][i][1] - (2.0 * u[k][j][i][1])) + u[k - 1][j][i][1]))) + (zzcon2 * ((us[k + 1][j][i] - (2.0 * us[k][j][i])) + us[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][1] * wp1) - (u[k - 1][j][i][1] * wm1)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dz3tz1 * ((u[k + 1][j][i][2] - (2.0 * u[k][j][i][2])) + u[k - 1][j][i][2]))) + (zzcon2 * ((vs[k + 1][j][i] - (2.0 * vs[k][j][i])) + vs[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][2] * wp1) - (u[k - 1][j][i][2] * wm1)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dz4tz1 * ((u[k + 1][j][i][3] - (2.0 * u[k][j][i][3])) + u[k - 1][j][i][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[k + 1][j][i][3] * wp1) - (u[k - 1][j][i][3] * wm1)) + ((((u[k + 1][j][i][4] - square[k + 1][j][i]) - u[k - 1][j][i][4]) + square[k - 1][j][i]) * c2)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dz5tz1 * ((u[k + 1][j][i][4] - (2.0 * u[k][j][i][4])) + u[k - 1][j][i][4]))) + (zzcon3 * ((qs[k + 1][j][i] - (2.0 * qs[k][j][i])) + qs[k - 1][j][i]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[k + 1][j][i][4] * rho_i[k + 1][j][i]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k - 1][j][i][4] * rho_i[k - 1][j][i])))) - (tz2 * ((((c1 * u[k + 1][j][i][4]) - (c2 * square[k + 1][j][i])) * wp1) - (((c1 * u[k - 1][j][i][4]) - (c2 * square[k - 1][j][i])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double a_temp = 0;\n  for (int j = 0; j < 3; j++)\n  {\n    for (int k = 0; k < 3; k++)\n    {\n      water_system[i].Acceleration_total[j] = water_system[i].Acceleration[k][j];\n    }\n\n    a_temp += pow(water_system[i].Acceleration_total[j], 2);\n    if (sqrt(a_temp) > FormerMaxForce)\n    {\n      FormerMaxForce = sqrt(a_temp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DFTheory/Water-system-openMP/water_system/2"}
{"code": "for (; i < size_; i += BYN, p1 += BYN, p2 += BYN)\n  sum += vector_dot_product_pointer16_sse(p1, p2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/6"}
{"code": "for (next_city = 0; next_city < 1000; next_city++)\n{\n  if ((visited_cities[next_city] != (-1)) && (next_city != current_city))\n  {\n    local_prob = ((double) (transitions[current_city][next_city] * heuristic_function(graph, current_city, next_city, beta))) / total_prob;\n    if (local_prob > best_prob)\n    {\n      best_city = next_city;\n    }\n\n    best_prob = fmax(local_prob, best_prob);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) private(next_city, local_prob) reduction(max: best_prob)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lar9482/High-Performance-Computing-Projects/TSP/Ant Colony Attempt/Ant_Colony/1"}
{"code": "for (short i = 0; i < size; i++)\n{\n  if (game->grid[i])\n  {\n    if (find(path.begin(), path.end(), i) == path.end())\n    {\n      valid = false;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marianhlavac/mi-pdp-jes/src/main/2"}
{"code": "for (x = 1; x <= nrl; x++)\n  for (y = 1; y <= NC; y++)\n  for (z = 0; z <= EXTRA; z++)\n{\n  t[1][x][y] += z;\n  t[1][x][y] -= z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/11"}
{"code": "for (i = 1; i < size; i++)\n  for (j = 0; j < row_each; j++)\n  MPI_Send(arr[j + (i * row_each)], 4, (MPI_Datatype) 0x4c000405, i, 0, (MPI_Comm) 0x44000000);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/matrix-dot-product/hybridparallel/7"}
{"code": "for (m = 0; m < interpolation_order; m++)\n  nodes[m] = 1 - (((2 * ((double) m)) / ((double) (interpolation_order - 1))) * L);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/15"}
{"code": "for (i = 1; i <= 10; i++)\n{\n  int currentThread = omp_get_thread_num();\n  sum += i;\n  printf(\"[%d]: Sum = %d\\n\", currentThread, sum);\n  printf(\"[%d]: calculation of the iteration number %d\\n\", currentThread, i);\n}\n\n", "pragma": "#pragma omp for schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IZIDIA/OpenMP-Testing/Main_OpenMP/1"}
{"code": "for (j = 0; j < nx; j++)\n{\n  _mm_store_ps(&bxy[(4 * j) + kk], _mm_load_ps(&bxy[4 * j]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/22"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum_tot += sum_tmp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anderslaunerbaek/HPC/exercises/automatic_parallelixation/openmp/func/1"}
{"code": "for (int i = 0; i < (ifog_t.size() / 4); ++i)\n{\n  for (int j = 0; j < ifog_t[0].size(); ++j)\n  {\n    g_t[i][j] = ifog_t[i + (3 * (ifog_t.size() / 4))][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_3/7"}
{"code": "for (int i = 0; i < results.size(); i++)\n{\n  ((outfile << results[i].second) << \" \") << results[i].first;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atharva1707/K-mer-counting-using-Bloom-filter/sorting/0"}
{"code": "for (int i = 0; i < rank; i++)\n{\n  int irank = i * rank;\n  for (j = 0; j <= i; j++)\n  {\n    small_r[j + irank] = r[j + (indices[i] * m)];\n  }\n\n  for (j = i + 1; j < rank; j++)\n  {\n    small_r[j + irank] = 0.0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/37"}
{"code": "for (pos = 0; pos < (cols * rows); pos++)\n{\n  if (nms[pos] == 128)\n    edge[pos] = 128;\n  else\n    edge[pos] = 255;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aguilarmauri/ProgramacionParalela/src/canny-openmp/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < (k - 1); j++)\n  {\n    pointsArray[i].values[j] += pointsArray[i].velocity[j] * dt;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/PerceptronAlgorithm/4"}
{"code": "for (i = 0; i < cnt; i++)\n{\n  for (j = 0; j < topoinfo->numG; j++)\n  {\n    for (h = 0; h < topoinfo->numR; h++)\n    {\n      if (topoinfo->SourceG[h] == j)\n      {\n        tmp = tmprlt->soln[(topoinfo->numG * i) + j] / tmprlt->paras[topoinfo->ParasPos[h]];\n        if (tmp >= 1)\n        {\n          localnumover[j] = localnumover[j] + 1;\n        }\n        else\n        {\n          localnumdown[j] = localnumdown[j] + 1;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/95"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < 5; j++)\n  {\n    printf(\"Enter element %d of first matrix:\", k);\n    scanf(\"%d\", &a[i][j]);\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/flush/3"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] *= alpha;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/16"}
{"code": "for (i = 0; i < cube_size; i++)\n{\n  graph_lock[i] = (omp_lock_t *) malloc(cube_size * (sizeof(omp_lock_t)));\n  for (j = 0; j < cube_size; j++)\n  {\n    omp_init_lock(&graph_lock[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/3"}
{"code": "for (c1 = 0; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/7"}
{"code": "for (i = 0; i < 5; i++)\n{\n  bvec[i] = ((((bvec[i] - (ablock[i][0] * avec[0])) - (ablock[i][1] * avec[1])) - (ablock[i][2] * avec[2])) - (ablock[i][3] * avec[3])) - (ablock[i][4] * avec[4]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/61"}
{"code": "for (int i = 0; i < len; i++)\n{\n  cnt += hash[i] == 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dunder-Muffin/parallelProgramming/problem5/run/1"}
{"code": "for (int i = 0; i < numBlocks; i++)\n{\n  const int dev = i % ndevs;\n  printf(\"device chosen for iteration %d : %d\\n\", i, dev);\n  OMPVV_START_TIMER;\n  {\n    const int NN = blockWork[i];\n    const int startInd = (i % (numBlocks / ndevs)) * NN;\n    const int endInd = ((i % (numBlocks / ndevs)) + 1) * NN;\n    for (int j = startInd; j <= endInd; j++)\n      sum += b[j] * a[j];\n\n  }\n  OMPVV_STOP_TIMER;\n}\n\n", "pragma": "#pragma omp for schedule(static, gsz)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/ecp-omp/type1/dotProd/bench/2"}
{"code": "for (i = 0; i < n; i++, fprintf(fp, \"\\n\"))\n  for (j = 0; j < n; j++)\n  fprintf(fp, \" %d\", _mat(i, j));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexandrosAlexiou/OpenMP-Exercise/Matrix-Multiplication/mat_mul_inner_for/2"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  ru1 = c3c4 * rho_i[i][j][k];\n  cv[k] = ws[i][j][k];\n  int _imopVarPre1975;\n  double _imopVarPre1976;\n  int _imopVarPre1977;\n  double _imopVarPre1978;\n  int _imopVarPre1985;\n  double _imopVarPre1986;\n  int _imopVarPre1987;\n  double _imopVarPre1988;\n  int _imopVarPre2081;\n  double _imopVarPre2082;\n  int _imopVarPre2083;\n  double _imopVarPre2084;\n  int _imopVarPre2091;\n  double _imopVarPre2092;\n  _imopVarPre1975 = (dzmax + ru1) > dz1;\n  if (_imopVarPre1975)\n  {\n    _imopVarPre1976 = dzmax + ru1;\n  }\n  else\n  {\n    _imopVarPre1976 = dz1;\n  }\n\n  _imopVarPre1977 = (dz5 + (c1c5 * ru1)) > _imopVarPre1976;\n  if (_imopVarPre1977)\n  {\n    _imopVarPre1978 = dz5 + (c1c5 * ru1);\n  }\n  else\n  {\n    _imopVarPre1985 = (dzmax + ru1) > dz1;\n    if (_imopVarPre1985)\n    {\n      _imopVarPre1986 = dzmax + ru1;\n    }\n    else\n    {\n      _imopVarPre1986 = dz1;\n    }\n\n    _imopVarPre1978 = _imopVarPre1986;\n  }\n\n  _imopVarPre1987 = (dz4 + (con43 * ru1)) > _imopVarPre1978;\n  if (_imopVarPre1987)\n  {\n    _imopVarPre1988 = dz4 + (con43 * ru1);\n  }\n  else\n  {\n    _imopVarPre2081 = (dzmax + ru1) > dz1;\n    if (_imopVarPre2081)\n    {\n      _imopVarPre2082 = dzmax + ru1;\n    }\n    else\n    {\n      _imopVarPre2082 = dz1;\n    }\n\n    _imopVarPre2083 = (dz5 + (c1c5 * ru1)) > _imopVarPre2082;\n    if (_imopVarPre2083)\n    {\n      _imopVarPre2084 = dz5 + (c1c5 * ru1);\n    }\n    else\n    {\n      _imopVarPre2091 = (dzmax + ru1) > dz1;\n      if (_imopVarPre2091)\n      {\n        _imopVarPre2092 = dzmax + ru1;\n      }\n      else\n      {\n        _imopVarPre2092 = dz1;\n      }\n\n      _imopVarPre2084 = _imopVarPre2092;\n    }\n\n    _imopVarPre1988 = _imopVarPre2084;\n  }\n\n  rhos[k] = _imopVarPre1988;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/SP/sp-wrongSVE/2"}
{"code": "for (int i = 0; i < repeat; i++)\n  (bilateralFilter < 6) > ((h_src, h_dst, w, h, a_square, variance_I, variance_spatial));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bilateral-omp/main/4"}
{"code": "for (int t = 0; t < omp_get_max_threads(); ++t)\n{\n  for (int j = 0; j < aux->qTail[diameter % 2][t]; ++j)\n  {\n    int u = aux->q[diameter % 2][(t * A->m) + j];\n    candidates[nCandidates] = u;\n    ++nCandidates;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/14"}
{"code": "for (int i = 0; i < procCoords.x_cells_num; i++)\n{\n  p_prev[((procCoords.y_cells_num - 1) * procCoords.x_cells_num) + i] = fi(X1 + ((procCoords.x_cell_pos + i) * hx), Y1 + ((procCoords.y_cell_pos + (procCoords.y_cells_num - 1)) * hy));\n  p[((procCoords.y_cells_num - 1) * procCoords.x_cells_num) + i] = fi(X1 + ((procCoords.x_cell_pos + i) * hx), Y1 + ((procCoords.y_cell_pos + (procCoords.y_cells_num - 1)) * hy));\n}\n\n", "pragma": "            #pragma omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/18"}
{"code": "for (;;)\n{\n  s = get_random_stack();\n  if (s == (-1))\n    break;\n\n  int t = process();\n  omp_set_lock(locks + s);\n  stacks[s].elems[stacks[s].cnt++] = t;\n  omp_unset_lock(locks + s);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/stacks/main/2"}
{"code": "for (int i = rank * len; i < ((rank + 1) * len); i++)\n{\n  ((((cout << \"Thread id = \") << omp_get_thread_num()) << \" Itr = \") << i) << endl;\n  x[i] = i;\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdh266/OpenMP_Practice/array/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  array[i] = value;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/Ludwig/targetDP/targetDP_C/1"}
{"code": "for (size_t l_el = 0; l_el < i_nEls; l_el++)\n{\n  for (unsigned short l_fa = 0; l_fa < i_nElFas; l_fa++)\n  {\n    for (unsigned short l_po = 0; l_po < l_nPtrsSend; l_po++)\n      m_sendPtrs[l_po][(l_el * i_nElFas) + l_fa] = nullptr;\n\n    for (unsigned short l_po = 0; l_po < l_nPtrsRecv; l_po++)\n      m_recvPtrs[l_po][(l_el * i_nElFas) + l_fa] = nullptr;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/parallel/Distributed/3"}
{"code": "for (i = 0; i < n; ++i)\n  tab[i] = rand() % 100;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_9/a/TD_OPENMP_09/1"}
{"code": "for (i = 1; i < (256 - 1); ++i)\n{\n  for (j = 1; j < (256 - 1); ++j)\n  {\n    for (k = 1; k < (256 - 1); ++k)\n    {\n      B[((i * (256 * 256)) + (j * 256)) + k] = ((((((((((((((c11 * A[(((i - 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)]) + (c13 * A[(((i + 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)])) + (c21 * A[(((i - 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)])) + (c23 * A[(((i + 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)])) + (c31 * A[(((i - 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)])) + (c33 * A[(((i + 1) * (256 * 256)) + ((j - 1) * 256)) + (k - 1)])) + (c12 * A[(((i + 0) * (256 * 256)) + ((j - 1) * 256)) + (k + 0)])) + (c22 * A[(((i + 0) * (256 * 256)) + ((j + 0) * 256)) + (k + 0)])) + (c32 * A[(((i + 0) * (256 * 256)) + ((j + 1) * 256)) + (k + 0)])) + (c11 * A[(((i - 1) * (256 * 256)) + ((j - 1) * 256)) + (k + 1)])) + (c13 * A[(((i + 1) * (256 * 256)) + ((j - 1) * 256)) + (k + 1)])) + (c21 * A[(((i - 1) * (256 * 256)) + ((j + 0) * 256)) + (k + 1)])) + (c23 * A[(((i + 1) * (256 * 256)) + ((j + 0) * 256)) + (k + 1)])) + (c31 * A[(((i - 1) * (256 * 256)) + ((j + 1) * 256)) + (k + 1)])) + (c33 * A[(((i + 1) * (256 * 256)) + ((j + 1) * 256)) + (k + 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/3DCONV/3DConvolution/0"}
{"code": "for (i = 1; i < numprocs; ++i)\n{\n  spaceInArrAfterUpdate[i] = spaceInArrAfterUpdate[i - 1] + recvNumUpdatedPoints[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/3"}
{"code": "for (int j = 1; j < (N - 1); j++)\n{\n  if (inputVector[j] == 0)\n  {\n    tempVector[j] = (resultVector[j - 1] + resultVector[j + 1]) / 2;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(T)\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serhii1savchenko/openmpVectorSmoothing/Lab3_OpenMP/3"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  solution[i] = score_new[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank - C\u00f3pia/page_rank/4"}
{"code": "for (int i = 0; i < (size / butterflyOffset); i++)\n{\n  double uR = 1.0;\n  double uI = 0.0;\n  int offset = i * butterflyOffset;\n  for (int j = 0; j < butterflySize; j++)\n  {\n    double temR = (_mas[(2 * ((j + offset) + butterflySize)) * step] * uR) - (_mas[((2 * ((j + offset) + butterflySize)) * step) + 1] * uI);\n    temI = (_mas[(2 * ((j + offset) + butterflySize)) * step] * uI) + (_mas[((2 * ((j + offset) + butterflySize)) * step) + 1] * uR);\n    _mas[(2 * ((j + offset) + butterflySize)) * step] = _mas[(2 * (j + offset)) * step] - temR;\n    _mas[((2 * ((j + offset) + butterflySize)) * step) + 1] = _mas[((2 * (j + offset)) * step) + 1] - temI;\n    _mas[(2 * (j + offset)) * step] += temR;\n    _mas[((2 * (j + offset)) * step) + 1] += temI;\n    uRtmp = uR;\n    uR = (uR * wR) - (uI * wI);\n    uI = (uI * wR) + (uRtmp * wI);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/11. filter (parallel)/fft/3"}
{"code": "for (i = 0; i < 6; i++)\n  for (j = 0; j < 6; j++)\n  newTask->board[i][j] = board[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/3"}
{"code": "for (j = i + 1; j < n; j++)\n  tmp += (-A[(i * n) + j]) * x[j];\n\n", "pragma": "omp for reduction(+: tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mGrad10/Parallel-Gaussian/gaussian/1"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = 0.0;\n  p[j] = 0.0;\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  s->Bt = s->sBt;\n  s->Bt[i] = s->Mcoefs_3d[1][1][i] * x[i];\n  if ((i - (sN + 2)) >= 0)\n    s->Bt[i] += s->Mcoefs_3d[1][0][i] * x[i - (sN + 2)];\n\n  if ((i + (sN + 2)) < N)\n    s->Bt[i] += s->Mcoefs_3d[1][2][i] * x[i + (sN + 2)];\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/151"}
{"code": "for (i = 2; i < (f + 3); i++)\n  for (j = d; j > 0; j--)\n  for (k = 0; k < (d + 2); k++)\n  for (l = 0; l < (d + 4); l++)\n{\n  if (!e)\n    abort();\n\n}\n\n\n\n\n", "pragma": "omp for collapse(2) ordered(4) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/2"}
{"code": "for (row = 0; row < size2; row++)\n{\n  first = stencil_size * row;\n  last = (first + stencil_size) - 1;\n  temp = 0.0;\n  for (col = first; col <= last; col++)\n  {\n    temp += matrix[col] * vector[colIndex[col]];\n  }\n\n  result[row] += temp;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Sparse/sparse/3"}
{"code": "for (int y = 0; y < 16; y++)\n{\n  tempBias = net->bias2_3[y];\n  for (int o0 = 0; o0 < 10; o0++)\n    for (int o1 = 0; o1 < 10; o1++)\n  {\n    temp = features->layer3[y][o0][o1];\n    temp += ((((((((((((((((((((((((features->layer2[0][o0 + 0][o1 + 0] * net->weight2_3[0][y][0][0]) + (features->layer2[0][o0 + 0][o1 + 1] * net->weight2_3[0][y][0][1])) + (features->layer2[0][o0 + 0][o1 + 2] * net->weight2_3[0][y][0][2])) + (features->layer2[0][o0 + 0][o1 + 3] * net->weight2_3[0][y][0][3])) + (features->layer2[0][o0 + 0][o1 + 4] * net->weight2_3[0][y][0][4])) + (features->layer2[0][o0 + 1][o1 + 0] * net->weight2_3[0][y][1][0])) + (features->layer2[0][o0 + 1][o1 + 1] * net->weight2_3[0][y][1][1])) + (features->layer2[0][o0 + 1][o1 + 2] * net->weight2_3[0][y][1][2])) + (features->layer2[0][o0 + 1][o1 + 3] * net->weight2_3[0][y][1][3])) + (features->layer2[0][o0 + 1][o1 + 4] * net->weight2_3[0][y][1][4])) + (features->layer2[0][o0 + 2][o1 + 0] * net->weight2_3[0][y][2][0])) + (features->layer2[0][o0 + 2][o1 + 1] * net->weight2_3[0][y][2][1])) + (features->layer2[0][o0 + 2][o1 + 2] * net->weight2_3[0][y][2][2])) + (features->layer2[0][o0 + 2][o1 + 3] * net->weight2_3[0][y][2][3])) + (features->layer2[0][o0 + 2][o1 + 4] * net->weight2_3[0][y][2][4])) + (features->layer2[0][o0 + 3][o1 + 0] * net->weight2_3[0][y][3][0])) + (features->layer2[0][o0 + 3][o1 + 1] * net->weight2_3[0][y][3][1])) + (features->layer2[0][o0 + 3][o1 + 2] * net->weight2_3[0][y][3][2])) + (features->layer2[0][o0 + 3][o1 + 3] * net->weight2_3[0][y][3][3])) + (features->layer2[0][o0 + 3][o1 + 4] * net->weight2_3[0][y][3][4])) + (features->layer2[0][o0 + 4][o1 + 0] * net->weight2_3[0][y][4][0])) + (features->layer2[0][o0 + 4][o1 + 1] * net->weight2_3[0][y][4][1])) + (features->layer2[0][o0 + 4][o1 + 2] * net->weight2_3[0][y][4][2])) + (features->layer2[0][o0 + 4][o1 + 3] * net->weight2_3[0][y][4][3])) + (features->layer2[0][o0 + 4][o1 + 4] * net->weight2_3[0][y][4][4]);\n    temp += ((((((((((((((((((((((((features->layer2[1][o0 + 0][o1 + 0] * net->weight2_3[1][y][0][0]) + (features->layer2[1][o0 + 0][o1 + 1] * net->weight2_3[1][y][0][1])) + (features->layer2[1][o0 + 0][o1 + 2] * net->weight2_3[1][y][0][2])) + (features->layer2[1][o0 + 0][o1 + 3] * net->weight2_3[1][y][0][3])) + (features->layer2[1][o0 + 0][o1 + 4] * net->weight2_3[1][y][0][4])) + (features->layer2[1][o0 + 1][o1 + 0] * net->weight2_3[1][y][1][0])) + (features->layer2[1][o0 + 1][o1 + 1] * net->weight2_3[1][y][1][1])) + (features->layer2[1][o0 + 1][o1 + 2] * net->weight2_3[1][y][1][2])) + (features->layer2[1][o0 + 1][o1 + 3] * net->weight2_3[1][y][1][3])) + (features->layer2[1][o0 + 1][o1 + 4] * net->weight2_3[1][y][1][4])) + (features->layer2[1][o0 + 2][o1 + 0] * net->weight2_3[1][y][2][0])) + (features->layer2[1][o0 + 2][o1 + 1] * net->weight2_3[1][y][2][1])) + (features->layer2[1][o0 + 2][o1 + 2] * net->weight2_3[1][y][2][2])) + (features->layer2[1][o0 + 2][o1 + 3] * net->weight2_3[1][y][2][3])) + (features->layer2[1][o0 + 2][o1 + 4] * net->weight2_3[1][y][2][4])) + (features->layer2[1][o0 + 3][o1 + 0] * net->weight2_3[1][y][3][0])) + (features->layer2[1][o0 + 3][o1 + 1] * net->weight2_3[1][y][3][1])) + (features->layer2[1][o0 + 3][o1 + 2] * net->weight2_3[1][y][3][2])) + (features->layer2[1][o0 + 3][o1 + 3] * net->weight2_3[1][y][3][3])) + (features->layer2[1][o0 + 3][o1 + 4] * net->weight2_3[1][y][3][4])) + (features->layer2[1][o0 + 4][o1 + 0] * net->weight2_3[1][y][4][0])) + (features->layer2[1][o0 + 4][o1 + 1] * net->weight2_3[1][y][4][1])) + (features->layer2[1][o0 + 4][o1 + 2] * net->weight2_3[1][y][4][2])) + (features->layer2[1][o0 + 4][o1 + 3] * net->weight2_3[1][y][4][3])) + (features->layer2[1][o0 + 4][o1 + 4] * net->weight2_3[1][y][4][4]);\n    temp += ((((((((((((((((((((((((features->layer2[2][o0 + 0][o1 + 0] * net->weight2_3[2][y][0][0]) + (features->layer2[2][o0 + 0][o1 + 1] * net->weight2_3[2][y][0][1])) + (features->layer2[2][o0 + 0][o1 + 2] * net->weight2_3[2][y][0][2])) + (features->layer2[2][o0 + 0][o1 + 3] * net->weight2_3[2][y][0][3])) + (features->layer2[2][o0 + 0][o1 + 4] * net->weight2_3[2][y][0][4])) + (features->layer2[2][o0 + 1][o1 + 0] * net->weight2_3[2][y][1][0])) + (features->layer2[2][o0 + 1][o1 + 1] * net->weight2_3[2][y][1][1])) + (features->layer2[2][o0 + 1][o1 + 2] * net->weight2_3[2][y][1][2])) + (features->layer2[2][o0 + 1][o1 + 3] * net->weight2_3[2][y][1][3])) + (features->layer2[2][o0 + 1][o1 + 4] * net->weight2_3[2][y][1][4])) + (features->layer2[2][o0 + 2][o1 + 0] * net->weight2_3[2][y][2][0])) + (features->layer2[2][o0 + 2][o1 + 1] * net->weight2_3[2][y][2][1])) + (features->layer2[2][o0 + 2][o1 + 2] * net->weight2_3[2][y][2][2])) + (features->layer2[2][o0 + 2][o1 + 3] * net->weight2_3[2][y][2][3])) + (features->layer2[2][o0 + 2][o1 + 4] * net->weight2_3[2][y][2][4])) + (features->layer2[2][o0 + 3][o1 + 0] * net->weight2_3[2][y][3][0])) + (features->layer2[2][o0 + 3][o1 + 1] * net->weight2_3[2][y][3][1])) + (features->layer2[2][o0 + 3][o1 + 2] * net->weight2_3[2][y][3][2])) + (features->layer2[2][o0 + 3][o1 + 3] * net->weight2_3[2][y][3][3])) + (features->layer2[2][o0 + 3][o1 + 4] * net->weight2_3[2][y][3][4])) + (features->layer2[2][o0 + 4][o1 + 0] * net->weight2_3[2][y][4][0])) + (features->layer2[2][o0 + 4][o1 + 1] * net->weight2_3[2][y][4][1])) + (features->layer2[2][o0 + 4][o1 + 2] * net->weight2_3[2][y][4][2])) + (features->layer2[2][o0 + 4][o1 + 3] * net->weight2_3[2][y][4][3])) + (features->layer2[2][o0 + 4][o1 + 4] * net->weight2_3[2][y][4][4]);\n    temp += ((((((((((((((((((((((((features->layer2[3][o0 + 0][o1 + 0] * net->weight2_3[3][y][0][0]) + (features->layer2[3][o0 + 0][o1 + 1] * net->weight2_3[3][y][0][1])) + (features->layer2[3][o0 + 0][o1 + 2] * net->weight2_3[3][y][0][2])) + (features->layer2[3][o0 + 0][o1 + 3] * net->weight2_3[3][y][0][3])) + (features->layer2[3][o0 + 0][o1 + 4] * net->weight2_3[3][y][0][4])) + (features->layer2[3][o0 + 1][o1 + 0] * net->weight2_3[3][y][1][0])) + (features->layer2[3][o0 + 1][o1 + 1] * net->weight2_3[3][y][1][1])) + (features->layer2[3][o0 + 1][o1 + 2] * net->weight2_3[3][y][1][2])) + (features->layer2[3][o0 + 1][o1 + 3] * net->weight2_3[3][y][1][3])) + (features->layer2[3][o0 + 1][o1 + 4] * net->weight2_3[3][y][1][4])) + (features->layer2[3][o0 + 2][o1 + 0] * net->weight2_3[3][y][2][0])) + (features->layer2[3][o0 + 2][o1 + 1] * net->weight2_3[3][y][2][1])) + (features->layer2[3][o0 + 2][o1 + 2] * net->weight2_3[3][y][2][2])) + (features->layer2[3][o0 + 2][o1 + 3] * net->weight2_3[3][y][2][3])) + (features->layer2[3][o0 + 2][o1 + 4] * net->weight2_3[3][y][2][4])) + (features->layer2[3][o0 + 3][o1 + 0] * net->weight2_3[3][y][3][0])) + (features->layer2[3][o0 + 3][o1 + 1] * net->weight2_3[3][y][3][1])) + (features->layer2[3][o0 + 3][o1 + 2] * net->weight2_3[3][y][3][2])) + (features->layer2[3][o0 + 3][o1 + 3] * net->weight2_3[3][y][3][3])) + (features->layer2[3][o0 + 3][o1 + 4] * net->weight2_3[3][y][3][4])) + (features->layer2[3][o0 + 4][o1 + 0] * net->weight2_3[3][y][4][0])) + (features->layer2[3][o0 + 4][o1 + 1] * net->weight2_3[3][y][4][1])) + (features->layer2[3][o0 + 4][o1 + 2] * net->weight2_3[3][y][4][2])) + (features->layer2[3][o0 + 4][o1 + 3] * net->weight2_3[3][y][4][3])) + (features->layer2[3][o0 + 4][o1 + 4] * net->weight2_3[3][y][4][4]);\n    temp += ((((((((((((((((((((((((features->layer2[4][o0 + 0][o1 + 0] * net->weight2_3[4][y][0][0]) + (features->layer2[4][o0 + 0][o1 + 1] * net->weight2_3[4][y][0][1])) + (features->layer2[4][o0 + 0][o1 + 2] * net->weight2_3[4][y][0][2])) + (features->layer2[4][o0 + 0][o1 + 3] * net->weight2_3[4][y][0][3])) + (features->layer2[4][o0 + 0][o1 + 4] * net->weight2_3[4][y][0][4])) + (features->layer2[4][o0 + 1][o1 + 0] * net->weight2_3[4][y][1][0])) + (features->layer2[4][o0 + 1][o1 + 1] * net->weight2_3[4][y][1][1])) + (features->layer2[4][o0 + 1][o1 + 2] * net->weight2_3[4][y][1][2])) + (features->layer2[4][o0 + 1][o1 + 3] * net->weight2_3[4][y][1][3])) + (features->layer2[4][o0 + 1][o1 + 4] * net->weight2_3[4][y][1][4])) + (features->layer2[4][o0 + 2][o1 + 0] * net->weight2_3[4][y][2][0])) + (features->layer2[4][o0 + 2][o1 + 1] * net->weight2_3[4][y][2][1])) + (features->layer2[4][o0 + 2][o1 + 2] * net->weight2_3[4][y][2][2])) + (features->layer2[4][o0 + 2][o1 + 3] * net->weight2_3[4][y][2][3])) + (features->layer2[4][o0 + 2][o1 + 4] * net->weight2_3[4][y][2][4])) + (features->layer2[4][o0 + 3][o1 + 0] * net->weight2_3[4][y][3][0])) + (features->layer2[4][o0 + 3][o1 + 1] * net->weight2_3[4][y][3][1])) + (features->layer2[4][o0 + 3][o1 + 2] * net->weight2_3[4][y][3][2])) + (features->layer2[4][o0 + 3][o1 + 3] * net->weight2_3[4][y][3][3])) + (features->layer2[4][o0 + 3][o1 + 4] * net->weight2_3[4][y][3][4])) + (features->layer2[4][o0 + 4][o1 + 0] * net->weight2_3[4][y][4][0])) + (features->layer2[4][o0 + 4][o1 + 1] * net->weight2_3[4][y][4][1])) + (features->layer2[4][o0 + 4][o1 + 2] * net->weight2_3[4][y][4][2])) + (features->layer2[4][o0 + 4][o1 + 3] * net->weight2_3[4][y][4][3])) + (features->layer2[4][o0 + 4][o1 + 4] * net->weight2_3[4][y][4][4]);\n    temp += ((((((((((((((((((((((((features->layer2[5][o0 + 0][o1 + 0] * net->weight2_3[5][y][0][0]) + (features->layer2[5][o0 + 0][o1 + 1] * net->weight2_3[5][y][0][1])) + (features->layer2[5][o0 + 0][o1 + 2] * net->weight2_3[5][y][0][2])) + (features->layer2[5][o0 + 0][o1 + 3] * net->weight2_3[5][y][0][3])) + (features->layer2[5][o0 + 0][o1 + 4] * net->weight2_3[5][y][0][4])) + (features->layer2[5][o0 + 1][o1 + 0] * net->weight2_3[5][y][1][0])) + (features->layer2[5][o0 + 1][o1 + 1] * net->weight2_3[5][y][1][1])) + (features->layer2[5][o0 + 1][o1 + 2] * net->weight2_3[5][y][1][2])) + (features->layer2[5][o0 + 1][o1 + 3] * net->weight2_3[5][y][1][3])) + (features->layer2[5][o0 + 1][o1 + 4] * net->weight2_3[5][y][1][4])) + (features->layer2[5][o0 + 2][o1 + 0] * net->weight2_3[5][y][2][0])) + (features->layer2[5][o0 + 2][o1 + 1] * net->weight2_3[5][y][2][1])) + (features->layer2[5][o0 + 2][o1 + 2] * net->weight2_3[5][y][2][2])) + (features->layer2[5][o0 + 2][o1 + 3] * net->weight2_3[5][y][2][3])) + (features->layer2[5][o0 + 2][o1 + 4] * net->weight2_3[5][y][2][4])) + (features->layer2[5][o0 + 3][o1 + 0] * net->weight2_3[5][y][3][0])) + (features->layer2[5][o0 + 3][o1 + 1] * net->weight2_3[5][y][3][1])) + (features->layer2[5][o0 + 3][o1 + 2] * net->weight2_3[5][y][3][2])) + (features->layer2[5][o0 + 3][o1 + 3] * net->weight2_3[5][y][3][3])) + (features->layer2[5][o0 + 3][o1 + 4] * net->weight2_3[5][y][3][4])) + (features->layer2[5][o0 + 4][o1 + 0] * net->weight2_3[5][y][4][0])) + (features->layer2[5][o0 + 4][o1 + 1] * net->weight2_3[5][y][4][1])) + (features->layer2[5][o0 + 4][o1 + 2] * net->weight2_3[5][y][4][2])) + (features->layer2[5][o0 + 4][o1 + 3] * net->weight2_3[5][y][4][3])) + (features->layer2[5][o0 + 4][o1 + 4] * net->weight2_3[5][y][4][4]);\n    features->layer3[y][o0][o1] = temp;\n    temp += tempBias;\n    if (temp < 0)\n      temp = 0;\n\n    features->layer3[y][o0][o1] = temp;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NegarNd/CNN-Inference-Acceleration/main_omp/3"}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  clearMatrix(D);\n  int attempt = 0;\n  double ktests[3];\n  int domoretests = 1;\n  while (domoretests)\n  {\n    double start = omp_get_wtime();\n    thrMMB(A, B, D);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n    if (attempt < 3)\n    {\n      ktests[attempt] = elapsed;\n    }\n    else\n    {\n      insertTest(elapsed, ktests);\n    }\n\n    if (attempt == 20)\n      domoretests = 0;\n\n    if ((attempt >= 5) && withinTol(ktests))\n      domoretests = 0;\n\n    attempt++;\n  }\n\n  for (int i = 0; i < 3; i++)\n    printf(\"# %f\\n\", ktests[i]);\n\n  printf(\"# attempts: %d\\n\", attempt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_main_blocked/3"}
{"code": "for (int i = 0; i < MATRIX_SIZE; i++)\n{\n  for (int j = 0; j < MATRIX_SIZE; j++)\n  {\n    for (int k = 0; k < MATRIX_SIZE; k++)\n    {\n      A->data[i][j][k] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW3/matmul3d/2"}
{"code": "for (i = 1; i < nodeNum; i++)\n  for (j = 0; j < i; j++)\n{\n  matrix[i][j] = -matrix[i][j];\n  matrix[j][i] = -matrix[j][i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/4"}
{"code": "for (i = 0; i < 10; i -= 3, j += 2)\n  baz(i);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-1/6"}
{"code": "for (i = 0; i < 9; i++)\n{\n  for (j = 0; j < 9; j++)\n  {\n    printf(\"%d   \", table[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  c[i] = a[i] + b[i];\n  n = i / chunk;\n  t = omp_get_thread_num();\n  if ((i % chunk) == 0)\n    printf(\"Thread %d is doing chunk %d\\n\", t, n);\n\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terbos/HPC-OPENMP/forloop1/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (L * L))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/69"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  long adj1 = vtxPtr[i];\n  long adj2 = vtxPtr[i + 1];\n  long selfLoop = 0;\n  totalEdgeTravel += adj2 - adj1;\n  long numUniqueClusters = 0;\n  if (adj1 != adj2)\n  {\n    long sPosition = vtxPtr[i] + i;\n    double eix;\n    clusterLocalMap[sPosition].Counter = 0;\n    clusterLocalMap[sPosition].cid = C[i];\n    numUniqueClusters++;\n    selfLoop = buildAndLockLocalMapCounter(i, clusterLocalMap, vtxPtr, vtxInd, C, numUniqueClusters, vlocks, clocks, ytype, eix, freedom);\n    maxAndFree(i, clusterLocalMap, vtxPtr, vtxInd, selfLoop, cInfo, C, constantForSecondTerm, numUniqueClusters, vlocks, clocks, ytype, eix, vDegree);\n  }\n  else\n  {\n  }\n\n  totalUniqueComm += numUniqueClusters;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:totalEdgeTravel), reduction(+:totalUniqueComm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/FullSyncOptimization/parallelLouvainMethodFullSync/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if (m_dayOfYear == 1)\n  {\n    m_phuBase[i] = 0.f;\n  }\n\n  if ((m_meanTemp[i] > 0.f) && (m_phuAnn[i] > 0.01f))\n  {\n    m_phuBase[i] += m_meanTemp[i] / m_phuAnn[i];\n  }\n\n  float srMax;\n  MaxSolarRadiation(m_dayOfYear, m_cellLat[i], m_dayLen[i], srMax);\n  float latentHeat = 2.501f - (0.002361f * m_meanTemp[i]);\n  float h0 = srMax * 1.253f;\n  float petValue = (((m_HCoef_pet * h0) * pow(Abs(m_maxTemp[i] - m_minTemp[i]), 0.5f)) * (m_meanTemp[i] + 17.8f)) / latentHeat;\n  m_pet[i] = m_petFactor * Max(0.0f, petValue);\n  float satVaporPressure = SaturationVaporPressure(m_meanTemp[i]);\n  float actualVaporPressure = 0.f;\n  if (m_rhd[i] > 1)\n  {\n    actualVaporPressure = (m_rhd[i] * satVaporPressure) * 0.01f;\n  }\n  else\n  {\n    actualVaporPressure = m_rhd[i] * satVaporPressure;\n  }\n\n  m_vpd[i] = satVaporPressure - actualVaporPressure;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/PET_H/PETHargreaves/0"}
{"code": "for (j = itn; j < nxh; j++)\n{\n  at1 = cimagf(ffc[j]);\n  fxyz[4 * j] = exyz[4 * j] * at1;\n  fxyz[1 + (4 * j)] = exyz[1 + (4 * j)] * at1;\n  fxyz[2 + (4 * j)] = exyz[2 + (4 * j)] * at1;\n  fxyz[4 * (j + k1)] = exyz[4 * (j + k1)] * at1;\n  fxyz[1 + (4 * (j + k1))] = exyz[1 + (4 * (j + k1))] * at1;\n  fxyz[2 + (4 * (j + k1))] = exyz[2 + (4 * (j + k1))] * at1;\n  fxyz[4 * (j + l1)] = exyz[4 * (j + l1)] * at1;\n  fxyz[1 + (4 * (j + l1))] = exyz[1 + (4 * (j + l1))] * at1;\n  fxyz[2 + (4 * (j + l1))] = exyz[2 + (4 * (j + l1))] * at1;\n  fxyz[4 * ((j + k1) + l1)] = exyz[4 * ((j + k1) + l1)] * at1;\n  fxyz[1 + (4 * ((j + k1) + l1))] = exyz[1 + (4 * ((j + k1) + l1))] * at1;\n  fxyz[2 + (4 * ((j + k1) + l1))] = exyz[2 + (4 * ((j + k1) + l1))] * at1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/57"}
{"code": "for (int i = 0; i < ((4 * L) * L); i++)\n{\n  fe2_x += sum_array_1[i];\n  fe2_y += sum_array_2[i];\n  fe2_z += sum_array_3[i];\n}\n\n", "pragma": "              #pragma omp parallel for shared(sum_array_1,sum_array_2,sum_array_3)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/facuMH/HeisenbergModel/OpenMP/main/7"}
{"code": "for (col = 0; col < 1000; col++)\n{\n  *((current + (250 * 1000)) + col) = 100;\n  *((next + (250 * 1000)) + col) = 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShaunJorstad/Hybrid-parallelized-thermal-conduction/jacobiHybrid/3"}
{"code": "for (int32_t i = 0; i != n; ++i)\n{\n  *y = *x;\n  x += incx;\n  y += incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/8"}
{"code": "for (i = 0; i < nbits; i++)\n{\n  if (k & bitmask)\n  {\n    *pQ = addpoints(*pQ, Psums[i], a, p, 0);\n  }\n\n  bitmask = bitmask << 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bumbleblo/ppd-openmp/vow_with_hash/5"}
{"code": "for (size_t ii = 0; ii < ((plength * pwidth) * pheight); ++ii)\n  temp_cpk_model[ii] = cpk_model[ii];\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebastiandaberdaku/VoxMeshSurfOpenMP/src/MolecularSurface/MolecularSurface/1"}
{"code": "for (int j = 0; j < x_points; j++)\n{\n  p[0][j] = p[1][j];\n  p[y_points - 1][j] = p[y_points - 2][j];\n  p_new[0][j] = p_new[1][j];\n  p_new[y_points - 1][j] = p_new[y_points - 2][j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Laplace Equation/2-D_Laplace_Equation/main/2"}
{"code": "for (int i = 0; i < tamanho_vetores; i++)\n  b[i] = i;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/vp/main/1"}
{"code": "for (row = 0; row < rowsize; row++)\n{\n  for (col = 0; col < colsize; col++)\n  {\n    fprintf(fout, \"%02x%02x%02x\", R[row][col], G[row][col], B[row][col]);\n    lineno++;\n    if (lineno == linelen)\n    {\n      fprintf(fout, \"\\n\");\n      lineno = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Alfie-Edwards/CM3103-High-Performance-Computing/OpenMP/Code/blurOMP-Dynamic/4"}
{"code": "for (i = 0; i < MaxNumEig; i++)\n{\n  CountConvgV[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/86"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  for (j = 0; j < nclusters; j++)\n  {\n    partial_new_centers[i][j] = (float *) calloc(nfeatures, sizeof(float));\n    total_size += nfeatures * (sizeof(float));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/kmeans/kmeans_openmp/kmeans_clustering/4"}
{"code": "for (int m = 0; m < ((int) mols.count); m++)\n{\n  memcpy(cosMolBoxRecip[m], cosMolRef[m], (sizeof(double)) * imageTotal);\n  memcpy(sinMolBoxRecip[m], sinMolRef[m], (sizeof(double)) * imageTotal);\n}\n\n", "pragma": "  #pragma omp parallel for default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/7"}
{"code": "for (j = 0; j < 20000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/stream/stream/0"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  R[i] = initial_density(x_init[i]);\n  P[i] = initial_pressure(x_init[i]);\n  U[i] = initial_velocity(x_init[i]);\n}\n\n", "pragma": "#pragma omp for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  t.s->a[i] = i;\n}\n\n", "pragma": "    #pragma omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/10"}
{"code": "for (i = 0; i <= N; i++)\n{\n  x[i] = x_init + (i * step);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe3/Tsouros_num_diff/0"}
{"code": "for (r = 0; r < rows; r++)\n{\n  int c = 0;\n  for (; c < cols; c++)\n  {\n    basetype item = 0;\n    int i = 0;\n    #pragma vector aligned\n    #pragma ivdep\n    for (; i < m; i++)\n    {\n      item += A[(r * a_cols) + i] * B[(i * b_cols) + c];\n    }\n\n    C[(r * cols) + c] = item;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pnookala/MIC_OpenMP_GeMTC/src/Apps/MatrixMul/0"}
{"code": "for (i = L1; i <= L2; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 1; k < (nz - 1); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][1];\n      u21 = rsd[i][j][k][1] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = (rsd[i][j][k][1] * u21) + (C2 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][2] = rsd[i][j][k][2] * u21;\n      flux[i][j][k][3] = rsd[i][j][k][3] * u21;\n      flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u21;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/6"}
{"code": "for (int i = 0; i < NumThreads; ++i)\n  Movers[i]->MaxAge = mxage;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/DMC/DMCOMP/1"}
{"code": "for (int j = l; j <= (r - 1); j++)\n{\n  if (arr[j] <= x)\n  {\n    swap(&arr[i], &arr[j]);\n    i++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikalaki/Vantage_point_tree_C_and_parallelism/vptree/src/vptree_openmp/6"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  n = ((m - 3) + 1) * 5;\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,i1 ,i ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/169"}
{"code": "for (uint32_t i = 0; i < numKeys; i++)\n{\n  free(out[i]);\n  free(keys[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/8"}
{"code": "for (unsigned c = 0; c < Count(); c++)\n{\n  List[c]->ComputeDampingGpu(dt, n, pini, posxy, posz, code, velrhop);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsDamping/4"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nl; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, D[i][j]);\n  if ((((i * ni) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/2mm/2mm/6"}
{"code": "for (i = 0; i < 8; i++)\n{\n  printf(\"loop: %d, thread: %lu, iteration: %d\\n\", loop_index, 0, i);\n  loop_2[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/10"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  unsigned int neighbors_size = mListOfSphericParticles[i]->mNeighbourElements.size();\n  mListOfSphericParticles[i]->mBondElements.resize(neighbors_size);\n  for (unsigned int j = 0; j < mListOfSphericParticles[i]->mBondElements.size(); j++)\n  {\n    mListOfSphericParticles[i]->mBondElements[j] = NULL;\n  }\n\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/11"}
{"code": "for (i = 0; i < nbRawMatrix; ++i)\n{\n  error = 1.0;\n  intiValueLayer(tabLayer[0], i);\n  fillOutc(outc, i);\n  rnnsetstart(tabLayer);\n  rnnset(tabLayer, outc);\n  ajustError(tabLayer[NBLAYER - 1]);\n  error = geterror(tabLayer[NBLAYER - 1], outc);\n  wichError(tabLayer[NBLAYER - 1], outc);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/26"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x[i], nbins, xmin, xmax, edges);\n  values_ot[bin]++;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/14"}
{"code": "for (int i = 0; i < np; i++)\n{\n  const int local_nel = (r == 0) ? (q) : ((i < (np - r)) ? (q) : (q + 1));\n  for (int j = 0; j < local_nel; j++)\n  {\n    printf(\"%d\", (mask[i] >> j) & 0x01);\n  }\n\n  printf(\" \");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/23"}
{"code": "for (int i = 0; i < (height + 2); i++)\n{\n  if ((i == 0) || (i == (width + 1)))\n  {\n    for (int j = 0; j < (width + 2); j++)\n      results[(i * (width + 2)) + j] = 0;\n\n  }\n  else\n  {\n    results[i * (width + 2)] = 0;\n    results[(i * (width + 2)) + (width + 1)] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeorgeMitrakis/raw_image_blur/project_hybrid/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = fib(i);\n}\n\n", "pragma": "omp parallel for schedule(guided, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 3/code4/0"}
{"code": "for (i = 0; i < (LX1 - 1); i++)\n{\n  idmo[iel][face][1][1][i][LX1 - 1] = mor_s_v[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/21"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    res(i, j) = this->mat[i][j] * obj;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/20"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    printf(\"matrizC[%d][%d] = %d \\n\", i, j, matrizC[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucasAlison/threads_parallel/omp_matriz/1"}
{"code": "for (int i = 0; i < ((int) imageSize[box]); i++)\n{\n  cosMolRef[*thisMol][i] = 0.0;\n  sinMolRef[*thisMol][i] = 0.0;\n  for (uint j = 0; j < thisKind.NumAtoms(); j++)\n  {\n    if (particleHasNoCharge[startAtom + j])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(mols.MolStart(*thisMol) + j, kx[box][i], ky[box][i], kz[box][i], molCoords);\n    cosMolRef[*thisMol][i] += thisKind.AtomCharge(j) * cos(dotProduct);\n    sinMolRef[*thisMol][i] += thisKind.AtomCharge(j) * sin(dotProduct);\n  }\n\n  sumRnew[box][i] += lambdaCoef * cosMolRef[*thisMol][i];\n  sumInew[box][i] += lambdaCoef * sinMolRef[*thisMol][i];\n}\n\n", "pragma": "      #pragma omp parallel for default(none) shared(box, lambdaCoef, molCoords, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/1"}
{"code": "for (i = 0; i < ROWS; i++)\n  for (j = 0; j < COLS; j++)\n  mat[i][j] = val;\n\n\n", "pragma": "#pragma omp parallel for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/IDW/0"}
{"code": "for (int i = 0; i < 32; i++)\n{\n  array[i] += i;\n  printf(\"array[%d] = %d\\n\", i, array[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/katelyn18/Simple-OpenMP/homework4/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\" the thread executing random number %d and index %d\\n\", omp_get_thread_num(), i);\n  int num = (rand() % ((upper - lower) + 1)) + lower;\n  arr[i] = num;\n  printf(\"%d and thread number %d \\n\", arr[i], omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/random/0"}
{"code": "for (k = 0; k < 100; ++k)\n{\n  *(matrices + k) = (int **) malloc((sizeof(int)) * 1000);\n  for (i = 0; i < 1000; ++i)\n  {\n    *((*(matrices + k)) + i) = (int *) malloc((sizeof(int)) * 1000);\n    for (j = 0; j < 1000; ++j)\n      *((*((*(matrices + k)) + i)) + j) = rand();\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-4/codes/maxelementcritical/0"}
{"code": "for (int x = 1; x <= iters; x++)\n  i.meanFilterTest(x);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/18"}
{"code": "for (i = 0; i < size; ++i)\n{\n  matrix[i] = &data[size * i];\n}\n\n", "pragma": "omp parallel for private(i) shared(matrix, size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/matrix/0"}
{"code": "for (itrial = 1; itrial <= 4; itrial++)\n{\n  n = powl(10, itrial + 5);\n  deltax = 2. / ((double) n);\n  area = 0.0;\n  gettimeofday(&tstart, 0);\n  for (i = 1; i <= n; i++)\n  {\n    x = (-1.) + (i * deltax);\n    area += sqrt(1. - (x * x)) * deltax;\n  }\n\n  pi = 2. * area;\n  gettimeofday(&tstop, 0);\n  dt = ((double) (tstop.tv_sec - tstart.tv_sec)) + (((double) (tstop.tv_usec - tstart.tv_usec)) * 1.e-6);\n  printf(\"Number of intervals : %12ld, pi = %22.21e, delta = %g, time = %fs\\n\", n, pi, pi - pi_exact, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_2/c_pi/0"}
{"code": "for (p = vla; p < (vla + ((sizeof(vla)) / (sizeof(vla[0])))); p++)\n  *p = ' ';\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.c/pr45784/0"}
{"code": "for (i = 0; i < 20; ++i)\n{\n  printf(\"|    %d   |    %d   |    %d    |    %d    |    %d   |\\n\", nStatic1[i], nStaticN[i], nDynamic1[i], nDynamicN[i], nGuided[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolasenciso/Parallel-and-distributed-computing/openMP/omp_schedule/5"}
{"code": "for (int i = 0; i < A_m; i++)\n{\n  for (int j = 0; j < A_n; j++)\n  {\n    (outfileA << (*A)(i, j)) << \" \";\n  }\n\n  outfileA << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/murraycutforth/openMP-matrix-multiplication/matmult/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  double x_i = a + (h * i);\n  double x_j = a + (h * (i + 1));\n  double d = (f(x_i) + f(x_j)) / 2.0;\n  sum += d * h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture11/Trapezoidal_critical_atomic/Trapezoidal_critical_atomic/0"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  if ((val % div) == 0)\n    return div;\n\n  if (neg)\n  {\n    cntneg--;\n    div = cntneg;\n    neg = 0;\n  }\n  else\n  {\n    cntpos++;\n    div = cntpos;\n    neg = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nms-omp/main/0"}
{"code": "for (int col = 0; col < 7; col++)\n{\n  for (int row = 6; row >= 0; row--)\n  {\n    if (this->board[row][col] == (-1))\n    {\n      positions.push_back(make_pair(row, col));\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, cols * bands, sizeof(float), fsignal);\n  for (j = 0; j < cols; j++)\n  {\n    m = 0;\n    for (k = 0; k < bands; k++)\n    {\n      if (buffer[(k * cols) + j] == nvalue)\n      {\n        m++;\n      }\n\n    }\n\n    if (m == bands)\n    {\n      npixels++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/ODM/3"}
{"code": "for (i = 0; i < iMax; i++)\n{\n  dC = ((2.0 * dC) * Z) + 1.0;\n  Z = (Z * Z) + C;\n  if (cabs(Z) > ER)\n  {\n    u = Z / dC;\n    u = u / cabs(u);\n    reflection = cdot(u, v) + h2;\n    reflection = reflection / (1.0 + h2);\n    if (reflection < 0.0)\n      reflection = 0.0;\n\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adammaj1/Mandelbrot-set-with-blended-gradients/src/d/5"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  for (int j = 0; j < (m_cellFlowCols - 1); j++)\n  {\n    m_cellFlow[i][j] = m_cellFlow[i][j + 1];\n  }\n\n  m_cellFlow[i][m_cellFlowCols - 1] = 0.f;\n  if (m_surfRf[i] <= 0.f)\n    continue;\n\n  int min = CVT_INT(m_iuhCell[i][0]);\n  int max = CVT_INT(m_iuhCell[i][1]);\n  int col = 2;\n  for (int k = min; k <= max; k++)\n  {\n    m_cellFlow[i][k] += (((m_surfRf[i] * 0.001f) * m_iuhCell[i][col]) * m_cellArea) / m_TimeStep;\n    col++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IUH_OL/IUH_OL/2"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_for_private())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_private/1"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aothelal/Parallel-Jacobi-Method-Using-OpenMP/Parallel_Jacobi/2"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  timeStart = omp_get_wtime();\n  PiParallelForOrdered();\n  timeEnd = omp_get_wtime();\n  time += timeEnd - timeStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/pi/10"}
{"code": "for (c1 = (ni > nj) ? (ni) : (nj); c1 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/22"}
{"code": "for (i = 0; i < size; i++)\n{\n  if ((i % 2) == 0)\n  {\n    *((outVectorPar + i) + (size * 3)) = applyFunction(inVector[i]);\n  }\n  else\n  {\n    *((outVectorPar + i) + (size * 3)) = inVector[i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/parallelfor-test/parallelfor/3"}
{"code": "for (int i = 0; i < ((*aNumberOfCentroids) - 1); i++)\n{\n  double dist = calcMinDistanceFromCentroids(aCentroids[i], aCentroids, aNumberOfCentroids);\n  if (dist < minDistance)\n  {\n    minDistance = dist;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/5"}
{"code": "for (int ry = minY; ry < maxY; ++ry)\n  for (int rx = minX; rx < maxX; ++rx)\n  _pImage->setPixel(rx, ry, value);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GuillaumeBouchetEpitech/Qt-OpenMP-Fractales/src/Fractale/0"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt.c, strlen((char *) cur_salt->salt.c), cur_salt->iterations, (unsigned char *) crypt_out[index], 32, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/django_fmt_plug/0"}
{"code": "for (int i = 0; i < board.getCols(); i++)\n{\n  if (board.isColumnEmpty(i))\n  {\n    board.makeMove(i, player);\n    int score = this->minimax(1, maxDepth, false, player);\n    if (score > bestScore)\n    {\n      bestScore = score;\n      bestCol = i;\n    }\n\n    board.undoMove();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/GameMinimax/0"}
{"code": "for (i = 0; i < nverts; i++)\n{\n  ik = (i * nverts) + k;\n  for (j = 0; j < nverts; j++)\n  {\n    if (((i != j) && (i != k)) && (j != k))\n    {\n      kj = (k * nverts) + j;\n      ij = (i * nverts) + j;\n      M[ij] = min(M[ik] + filK[j], M[ij]);\n    }\n\n  }\n\n}\n\n", "pragma": "      #pragma omp for schedule(static, chunk)  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fblupi/grado_informatica-PPR/Practicas/P4/floyd1D/0"}
{"code": "for (i = 1; i <= 1; i++)\n{\n  totaltime += times[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/barrier/shannon_tour_on_shark/2"}
{"code": "for (c = 1; c <= channels_col; ++c)\n{\n  int w_offset = c % ksize;\n  int h_offset = ((c / ksize) % ksize) + 1;\n  if (w_offset == 0)\n  {\n    w_offset = ksize;\n    h_offset--;\n  }\n\n  if (h_offset == 0)\n    h_offset = ksize;\n\n  int c_im = ((c - 1) / ksize) / ksize;\n  for (h = 0; h < height_col; ++h)\n  {\n    for (w = 0; w < width_col; ++w)\n    {\n      int im_row = (h_offset * dilate_rate) + (h * stride);\n      int im_col = (w_offset * dilate_rate) + (w * stride);\n      int col_index = ((((c - 1) * height_col) + h) * width_col) + w;\n      double val = data_col[col_index];\n      printf(\"%d \", col_index);\n      col2im_add_pixel_dilated(data_im, height, width, channels, im_row, im_col, c_im, pad, val);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/im2col/1"}
{"code": "for (i = 0; i < nelem; i++)\n{\n  for (j = 0; j < NCAR; j++)\n  {\n    additions[popul[i]][j] += elem[i][j];\n  }\n\n  additions[popul[i]][NCAR]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/gengrupos_p/6"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] += b[i] + c[i];\n}\n\n", "pragma": "#pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-parallel-for-back2back/test/1"}
{"code": "for (int i = 1; i < y_points; i++)\n{\n  for (int j = 1; j < x_points; j++)\n  {\n    *((u_new + (i * x_points)) + j) = ((*((u + (i * x_points)) + j)) - (((*((u + (i * x_points)) + j)) * (del_t / del_x)) * ((*((u + (i * x_points)) + j)) - (*((u + (i * x_points)) + (j - 1)))))) - (((*((v + (i * x_points)) + j)) * (del_t / del_x)) * ((*((u + (i * x_points)) + j)) - (*((u + ((i - 1) * x_points)) + j))));\n    *((v_new + (i * x_points)) + j) = ((*((v + (i * x_points)) + j)) - (((*((u + (i * x_points)) + j)) * (del_t / del_x)) * ((*((v + (i * x_points)) + j)) - (*((v + (i * x_points)) + (j - 1)))))) - (((*((v + (i * x_points)) + j)) * (del_t / del_x)) * ((*((v + (i * x_points)) + j)) - (*((v + ((i - 1) * x_points)) + j))));\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/2-D_NonLinear_Convection/2-D_Nonlinear_Convection_Dynamic/main/2"}
{"code": "for (i = 0; i < simu_opts->numKD; i++)\n{\n  sprintf(KDIDname, \"%d\", simu_opts->KDID[i]);\n  strcat(fsname[cnt - 1], \"_\");\n  strcat(fsname[cnt - 1], KDIDname);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/57"}
{"code": "for (i = 0; i <= (672 + 1); i++)\n{\n  for (j = 0; j <= (672 + 1); j++)\n  {\n    Temperature_last[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < (5 + 1); j++)\n  {\n    matrix[i][j] = drand48();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/newomp/1"}
{"code": "for (it = 1; it <= 100; it++)\n{\n  update(1, (3600 - 2) + ((iz * 3600) * 3600), table_u + (((1 - iz) * 3600) * 3600));\n  iz = 1 - iz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/spirosdelviniotis/parallel_programming/OpenMP/Pure_OpenMP_main/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  r += v1[i] * v2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/logistic/1"}
{"code": "for (j = 0; j < bands; j++)\n{\n  for (k = 0; k < bands; k++)\n  {\n    for (l = 0; l < cols; l++)\n    {\n      if (buffer[(j * cols) + l] != nvalue)\n      {\n        sumv[j][k] += (buffer[(j * cols) + l] - mean[j]) * (buffer[(k * cols) + l] - mean[k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/ODM/1"}
{"code": "for (i = M - 1; (i > 1) && (j < 3); i--)\n{\n  if (mark[i] == 0)\n  {\n    printf(\"%ld \", (2 * i) + 1);\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA2/sieve2/4"}
{"code": "for (i = 0; i < (sizeB + 1); i++)\n  free(scoreMatrix[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giov8/lcs-openmp/openmp/lcs/9"}
{"code": "for (int i = 0; i < cast_mat->nrow_; ++i)\n{\n  for (int j = cast_mat->mat_.row_offset[i]; j < cast_mat->mat_.row_offset[i + 1]; ++j)\n  {\n    if (levels[j] <= p)\n    {\n      this->mat_.col[jj] = cast_mat->mat_.col[j];\n      this->mat_.val[jj] = val[j];\n      ++jj;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/53"}
{"code": "for (idx_t s = 0; s < ft->nslcs; ++s)\n{\n  eptr[1 + p_map_idx(s, 0, ft)] += ft->sptr[s + 1] - ft->sptr[s];\n  for (idx_t f = ft->sptr[s]; f < ft->sptr[s + 1]; ++f)\n  {\n    eptr[1 + p_map_idx(ft->fids[f], 1, ft)] += 1;\n    for (idx_t jj = ft->fptr[f]; jj < ft->fptr[f + 1]; ++jj)\n    {\n      eptr[1 + p_map_idx(ft->inds[jj], 2, ft)] += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/14"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  sleep_for(milliseconds(500));\n  k += i;\n  fprintf(stdout, \"k = %d, thread id: %d\\n\", k, omp_get_thread_num());\n}\n\n", "pragma": "\t#pragma omp parallel for firstprivate(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/10"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  (KRATOS_ERROR_IF(mHighPoint[i] < mLowPoint[i]) << \"Check limits of the Bounding Box, minimum coordinates exceed maximum coordinates.\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/create_and_destroy/8"}
{"code": "for (int i = 0; i < nDimensions; i++)\n  squared_sum += x[i] * x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/mpiomp/6"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  for (int is = 0; is < ns; is++)\n  {\n    rhons[is][i][j][k] = rhoINIT[is] / FourPI;\n  }\n\n  Ex[i][j][k] = 0.0;\n  Ey[i][j][k] = 0.0;\n  Ez[i][j][k] = 0.0;\n  Bxn[i][j][k] = 0.0;\n  Byn[i][j][k] = 0.0;\n  Bzn[i][j][k] = B0z;\n  for (int m = -3; m < 4; m++)\n    for (int n = -3; n < 4; n++)\n  {\n    kx = ((2.0 * M_PI) * m) / Lx;\n    ky = ((2.0 * M_PI) * n) / Ly;\n    Bxn[i][j][k] += ((-B0x) * ky) * cos(((grid->getXN(i, j, k) * kx) + (grid->getYN(i, j, k) * ky)) + ((2.0 * M_PI) * modes_seed[m + 3][n + 3]));\n    Byn[i][j][k] += (B0x * kx) * cos(((grid->getXN(i, j, k) * kx) + (grid->getYN(i, j, k) * ky)) + ((2.0 * M_PI) * modes_seed[m + 3][n + 3]));\n  }\n\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/76"}
{"code": "for (i = start_n; i < (start_n + length_n); i++)\n{\n  y[i] += a * x[i];\n}\n\n", "pragma": "omp parallel for simd shared(y, x, a, start_n, length_n) private(i) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/axpy/axpy_cpu_omp_kernel/0"}
{"code": "for (i = 0; i < 400; i++)\n{\n  for (k = 0; k < 400; k++)\n  {\n    for (j = 0; j < 400; j++)\n    {\n      if (((matrix_dist[(k * 400) + i] != 99999999) && (matrix_dist[(i * 400) + j] != 99999999)) && (matrix_dist[(k * 400) + j] > (matrix_dist[(k * 400) + i] + matrix_dist[(i * 400) + j])))\n      {\n        matrix_dist[(k * 400) + j] = matrix_dist[(k * 400) + i] + matrix_dist[(i * 400) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/floyd/src/floyd_gpu/4"}
{"code": "for (l = 0; l < D3; l++)\n{\n  __sumskipnan3we__(LInput + (l * D2), D2, LOutputSum + l, LOutputSum2 + l, LOutputCount + l, &flag_isNaN, W);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/sumskipnan_mex/13"}
{"code": "for (i = 0; i < (2 * (1 << 16)); i++)\n  x[i] = -1.0e99;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/EP/ep/2"}
{"code": "for (i = 0; i < (H - h); i++)\n{\n  for (j = 0; j < (W - w); j++)\n  {\n    sadValue = 0;\n    for (m = 0; m < h; m++)\n    {\n      for (n = 0; n < w; n++)\n      {\n        sadValue += abs(img[((i + m) * W) + (j + n)] - im_crop[(m * w) + n]);\n      }\n\n    }\n\n    if (sadValue < min_val)\n    {\n      min_val = sadValue;\n      idx_i = i;\n      idx_j = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhattagoutham/parallel-programming/2_template_matching/sad_omp/2"}
{"code": "for (var = 0; var < 2; var++)\n{\n  int csno = var * 2;\n  for (int var2 = 0; var2 < num_tasks; var2++)\n  {\n    int min = 0;\n    int max = selectedProcessors.size() - 1;\n    int pno = min + (rand() % ((max - min) + 1));\n    int tmpid = selectedProcessors[pno].getId();\n    chrmsm[csno].push_back(tmpid);\n    if ((var2 == (num_tasks - 1)) || (var2 == ((num_tasks - 1) / 2)))\n    {\n      csno++;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(var)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/13"}
{"code": "for (int i = 0; i < nb_thread; i++)\n{\n  for (unsigned long long j = 0; j < size_of_part; j++)\n  {\n    prime[i][j] = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AdrienTurchini/OpenMP/main/2"}
{"code": "for (int i = 0; i < (*rowsNumber); i++)\n{\n  for (int j = 0; j < ((*columnsNumber) + 1); j++)\n  {\n    fscanf(inputFile, \"%c\", &(*twoDMatrix)[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/1"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  matrixData[(i * columns) + 0] = 0;\n  matrixData[((i * columns) + columns) - 1] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/parallel-scan-sky/openmp/src/ScanSky_openmp/4"}
{"code": "for (int i = 0; i < runMax; i++)\n{\n  sumBestOBJ += bestOBJ[i];\n  sumBestITR += bestITR[i];\n  sumbestTime += bestTIME[i];\n  sumTotTIME += totTIME[i];\n  sumImprov += improvObj[i];\n  (((((((((myFile << bestOBJ[i]) << \"\\t\") << bestITR[i]) << \"\\t\") << bestTIME[i]) << \"\\t\") << totTIME[i]) << \"\\t\") << improvObj[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afarasat/ParallelSparseMatrixFactorization_OpenMP/mainDriver/1"}
{"code": "for (int i = 0; i < numOfNodes; ++i)\n{\n  int u = nodes[i];\n  assert((u >= 0) && (u < m));\n  bv->atomicClear(u);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/13"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#3#0\n  for (j = 0; j < 100; j++)\n  {\n    printf(\"%d %d\\n\", a[i][j], b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB113-default-orig-no/4"}
{"code": "for (i = 0; i < n; i += 32)\n{\n  x8 = _mm256_loadu_ps(&data1[i]);\n  y8 = _mm256_loadu_ps(&data2[i]);\n  sum1 = _mm256_add_ps(_mm256_mul_ps(x8, y8), sum1);\n  x8 = _mm256_loadu_ps(&data1[i + 8]);\n  y8 = _mm256_loadu_ps(&data2[i + 8]);\n  sum2 = _mm256_add_ps(_mm256_mul_ps(x8, y8), sum2);\n  x8 = _mm256_loadu_ps(&data1[i + 16]);\n  y8 = _mm256_loadu_ps(&data2[i + 16]);\n  sum3 = _mm256_add_ps(_mm256_mul_ps(x8, y8), sum3);\n  x8 = _mm256_loadu_ps(&data1[i + 24]);\n  y8 = _mm256_loadu_ps(&data2[i + 24]);\n  sum4 = _mm256_add_ps(_mm256_mul_ps(x8, y8), sum4);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp_mic/1"}
{"code": "for (i = 0; i < scene->num_geometries(); i++)\n{\n  scene->get_geometries()[i]->intersection_test(r, inter, &closest_found_t);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miuho/CPU-Raytracing/src/p3/raytracer/0"}
{"code": "for (i = 0; i <= cym; i++)\n{\n  cymh[i] = (((DATA_TYPE) i) + 5) / cxm;\n  cyph[i] = (((DATA_TYPE) i) + 6) / cxm;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/fdtd-apml/fdtd-apml/3"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  A[i] = x[i] + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/allocate/test_allocate_on_device/1"}
{"code": "for (j = 0; j < nsctrellis.stateNb; j++)\n{\n  index = 0;\n  for (n = 0; n < nsctrellis.stateNb; n++)\n  {\n    for (k = 0; k < 2; k++)\n    {\n      if (nsctrellis.nextState[n + (k * nsctrellis.stateNb)] == j)\n      {\n        nsctrellis.prevState[j + (index * nsctrellis.stateNb)] = n;\n        nsctrellis.input[j + (index * nsctrellis.stateNb)] = k;\n        index++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(n,k,j,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_nsc/0"}
{"code": "for (int n_threads = 1; n_threads <= 32; n_threads = (n_threads <= 8) ? (2 * n_threads) : (n_threads + 4))\n{\n  omp_set_num_threads(n_threads);\n  for (int i = 0; i < n_runs; ++i)\n  {\n    start_time = omp_get_wtime();\n    total_sum = omp_sum(x, size);\n    times[i] = omp_get_wtime() - start_time;\n    if (abs(total_sum - warmup_sum) > 0.001)\n      printf(\"Different results in omp_sum with %2d threads: %f\\n\", n_threads, total_sum);\n\n  }\n\n  double avg;\n  double std_dev;\n  compute_statistics(times, n_runs, &avg, &std_dev);\n  printf(\"omp sum (%2d threads) - Average: %fs - Std. deviation: %fs - Sum value: %f\\n\", n_threads, avg, std_dev, total_sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/7"}
{"code": "for (size_t i = params->start_row; i < (params->start_row + params->num_rows); i++)\n{\n  for (size_t j = 0; j < params->IMAGE_WIDTH; j++)\n  {\n    struct pixel_components components_multiplication_sum = {.red = 0.f, .green = 0.f, .blue = 0.f};\n    double kernel_cells_sum = 0.f;\n    const size_t ki_start = (i > KERNEL_RADIUS) ? (0) : (KERNEL_RADIUS - i);\n    const size_t ki_end = (i > (params->IMAGE_HEIGHT - KERNEL_RADIUS)) ? ((params->IMAGE_HEIGHT - i) + KERNEL_RADIUS) : (KERNEL_HEIGHT);\n    const size_t kj_start = (j > KERNEL_RADIUS) ? (0) : (KERNEL_RADIUS - j);\n    const size_t kj_end = (j > (params->IMAGE_WIDTH - KERNEL_RADIUS)) ? ((params->IMAGE_WIDTH - j) + KERNEL_RADIUS) : (KERNEL_WIDTH);\n    for (size_t ki = ki_start; ki < ki_end; ki++)\n    {\n      for (size_t kj = kj_start; kj < kj_end; kj++)\n      {\n        kernel_cells_sum += params->kernel[ki][kj];\n        const uint16_t red = params->input_image[(i + ki) - KERNEL_RADIUS][(((j + kj) - KERNEL_RADIUS) * INPUT_IMAGE_COMPONENTS_NUMBER) + 0];\n        const uint16_t green = params->input_image[(i + ki) - KERNEL_RADIUS][(((j + kj) - KERNEL_RADIUS) * INPUT_IMAGE_COMPONENTS_NUMBER) + 1];\n        const uint16_t blue = params->input_image[(i + ki) - KERNEL_RADIUS][(((j + kj) - KERNEL_RADIUS) * INPUT_IMAGE_COMPONENTS_NUMBER) + 2];\n        components_multiplication_sum.red += red * params->kernel[ki][kj];\n        components_multiplication_sum.green += green * params->kernel[ki][kj];\n        components_multiplication_sum.blue += blue * params->kernel[ki][kj];\n      }\n\n    }\n\n    params->output_image[i][(INPUT_IMAGE_COMPONENTS_NUMBER * j) + 0] = round(components_multiplication_sum.red / kernel_cells_sum);\n    params->output_image[i][(INPUT_IMAGE_COMPONENTS_NUMBER * j) + 1] = round(components_multiplication_sum.green / kernel_cells_sum);\n    params->output_image[i][(INPUT_IMAGE_COMPONENTS_NUMBER * j) + 2] = round(components_multiplication_sum.blue / kernel_cells_sum);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/blurrifier-openmp/main/5"}
{"code": "for (i = 0; i < 20; ++i)\n{\n  if ((i % 3) == 0)\n    sleep(0);\n\n  nDynamic1[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolasenciso/Parallel-and-distributed-computing/openMP/omp_schedule/2"}
{"code": "for (i = 1; i < 30000000; i += 2)\n{\n  a[i] = (a[i] + red) / 2.0;\n  a[i] = (black + a[i + 1]) / 2.0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mars2020/Parallel-OpenMP/part_2/hw1/rb/prb_c/0"}
{"code": "for (int i = 0; i < upsampleValuesMatrix.size(); i++)\n{\n  for (int j = 0; j < upsampleValuesMatrix[0].size(); j++)\n  {\n    upsampleValuesMatrix[i][j] = temp[(temp.size() / 2) + i][(temp[0].size() / 2) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/2"}
{"code": "for (int i = 0; i < numCities; i++)\n{\n  if (arr[getIDFromChar(s[i]) - 1] == 0)\n    arr[getIDFromChar(s[i]) - 1] = 1;\n  else\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/1"}
{"code": "for (int j = i; j < end; j++)\n{\n  if ((contents[j] == '\"') && (r == 1))\n  {\n    end = j;\n    break;\n  }\n\n  if (contents[j] == '\"')\n    r++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Po-Y-H/Parallel-Web-Crawler-by-OpenMP/03_ps/Crawler/2"}
{"code": "for (size_t space_point = 1; space_point < (mesh->space_points - 1); ++space_point)\n{\n  const real_type space = lerp((real_type) space_point, 0.0, (real_type) (mesh->space_points - 1), 0.0, parameters->space_max);\n  const real_type temperature = parameters->initial_condition(space);\n  mesh_Set(mesh, 0, space_point, temperature);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/3"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->ComputeBB();\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      K[i][j] = 0.01 + K[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sharatchandraj/Gaussian-Process-Regression-OpenMP/GPR/11"}
{"code": "for (int i = 0; i < (500000 * 1000); i++)\n{\n  t[i % 500000] = a[i % 500000] / b[i % 500000];\n  t[i % 500000] = t[i % 500000] / b[i % 500000];\n  t[i % 500000] = t[i % 500000] / b[i % 500000];\n}\n\n", "pragma": "omp parallel for shared(t, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicoTolly/stage_openmp/openmp/for-test/0"}
{"code": "for (row = a.begin(); row != a.end(); ++row)\n{\n  for (el = row->begin(); el != row->end(); ++el)\n  {\n    *el = (rand() % 1000) - 500;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_3/parallel_3/4"}
{"code": "for (int i = 0; i < sample_size; i++)\n{\n  const int num_threads = thread_nums[i];\n  printf(\"Running simulation with %d threads\\n\", num_threads);\n  double time_to_complete = simulate_hte(steps);\n  write_performance_data(num_threads, steps, time_to_complete);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eddireeder/heat-transfer-simulation/hte/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/mergesort/4"}
{"code": "for (i = 0; i < max_num_threads; i++)\n{\n  for (j = 0; j < 256; j++)\n  {\n    arr[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JingruGao09/OpenMP_Performance/histogram_creative/histo_creative/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (n = 0; n <= 4; n += 1)\n  {\n    lhs[i][j][k][0][m][n] = 0.0;\n    lhs[i][j][k][1][m][n] = 0.0;\n    lhs[i][j][k][2][m][n] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/46"}
{"code": "for (int j = 0; j < nnodes; j++)\n{\n  processed_nodes[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahmedGHANIM327/openMP/tree_bottomup/main/0"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  for (subcycle = 0; subcycle < 10; subcycle++)\n  {\n    partArray[0]->update_count = 1;\n    partArray[0]->firstZone->value = calc_deposit();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/7"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = d_x * d_y;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/8"}
{"code": "for (int sample_index = 0; sample_index < data.size(); ++sample_index)\n{\n  predictions.push_back(predictSample(data[sample_index]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/7"}
{"code": "for (i = 0; i <= (N - 1); i++)\n  for (j = 0; j <= N; j++)\n  if ((i == j) || (j == N))\n  A[(i * (N + 1)) + j] = 1.f;\nelse\n  A[(i * (N + 1)) + j] = 0.f;\n\n\n\n", "pragma": "omp parallel for shared(A) private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Volodimirich/GaussOpenMp/gaussOp/0"}
{"code": "for (int i = 0; i < ncol; ++i)\n{\n  if (cast_vec->vec_[i] != ((static_cast < ValueType) > 0))\n  {\n    ++nnz_idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/124"}
{"code": "for (int j = 0; j < k; j++)\n{\n  printf(\"Cluster %d; tid=%d\\n\", j + 1, omp_get_thread_num());\n  for (int i = 0; i < n; i++)\n  {\n    if (kc[i] == j)\n    {\n      clust_size[j] += 1;\n      xc[j][clust_size[j] - 1] = x[i];\n      yc[j][clust_size[j] - 1] = y[i];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ManaswitaDatta/Convex-Hull-Using-K-Means-Clustering-in-Hybrid-MPI-OpenMP-Environment/openmp/pc/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"%d \", stack[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Constructs/atomic_construct/0"}
{"code": "for (i = ibeg; i <= ifin; i += 1)\n{\n  iglob = i;\n  for (k = ki1; k <= ki2; k += 1)\n  {\n    phi1[i][k] = 0.40e+00 * (u[i][jbeg][k][4] - ((0.50 * (((u[i][jbeg][k][1] * u[i][jbeg][k][1]) + (u[i][jbeg][k][2] * u[i][jbeg][k][2])) + (u[i][jbeg][k][3] * u[i][jbeg][k][3]))) / u[i][jbeg][k][0]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (iglob,i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/71"}
{"code": "for (j = 1; j <= nrows; j++)\n{\n  nzrow = 0;\n  for (k = jajp1; k < rowstr[j + 1]; k++)\n  {\n    i = colidx[k];\n    x[i] = x[i] + a[k];\n    if ((mark[i] == FALSE) && (x[i] != 0.0))\n    {\n      mark[i] = TRUE;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i;\n    }\n\n  }\n\n  for (k = 1; k <= nzrow; k++)\n  {\n    i = nzloc[k];\n    mark[i] = FALSE;\n    xi = x[i];\n    x[i] = 0.0;\n    if (xi != 0.0)\n    {\n      nza = nza + 1;\n      a[nza] = xi;\n      colidx[nza] = i;\n    }\n\n  }\n\n  jajp1 = rowstr[j + 1];\n  rowstr[j + 1] = nza + rowstr[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/25"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    frct[i][j][k][m] = frct[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,m ,j ,ist ,k ,u21j ,u31j ,u41j ,u51j ,tmp ,u21jm1 ,u31jm1 ,u41jm1 ,u51jm1 ,ty2 ,jst ,jend ,ty3 ,L2 ,ty1 ,dy1 ,dy2 ,dy3 ,dy4 ,dy5 ,dssp ,jend1 ,ny ,nz ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/29"}
{"code": "for (const_iterator r = faces2.begin(); r != faces2.end(); r++)\n  faces.push_back(Rect((smallImg.cols - r->x) - r->width, r->y, r->width, r->height));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/ComputerVision/ufacedetect/4"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  if ((i % 2) == 0)\n    x[i] = 5;\n  else\n    x[i] = -5;\n\n}\n\n", "pragma": "omp parallel for private (i) firstprivate (len)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB011-minusminus-orig-yes/0"}
{"code": "for (int i = 0; i < repeat; ++i)\n  simps_parallel_chunked(fvals, x, N, num_threads, chunk_size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astrophpeter/C-OpenMP-MPI/homework3/src/integrate/3"}
{"code": "for (int i = 0; i < src.rows; i++)\n{\n  for (int j = 0; j < src.cols; j++)\n  {\n    if ((((i < fsize) || (i >= (src.rows - fsize))) || (j < fsize)) || (j >= (src.cols - fsize)))\n    {\n      dst(i, j)[0] = src(i, j)[0];\n      dst(i, j)[1] = src(i, j)[1];\n      dst(i, j)[2] = src(i, j)[2];\n    }\n    else\n    {\n      for (int n = 0; n < k; n++)\n      {\n        dst(i, j)[0] += (int) (temp(i, (j + n) - fsize)[0] * kernel[n]);\n        dst(i, j)[1] += (int) (temp(i, (j + n) - fsize)[1] * kernel[n]);\n        dst(i, j)[2] += (int) (temp(i, (j + n) - fsize)[2] * kernel[n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/separable/2"}
{"code": "form[0] = format(nb.activ)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/5"}
{"code": "for (i = 0; i <= n; i++)\n{\n  reverse_result += smo[0].getP(i) * smo[1].getP(n - i);\n}\n\n", "pragma": "#pragma omp parallel for private(i) reduction(+:reverse_result) shared(smo, n)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Evgentus0/ParallelProgrmming/NormilizingFactor/NormilizingFactor/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%.1e \", M[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yinglyu/openmp-matrix-inversion/ir_openmp/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = 0;\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/already_locked/already_locked/0"}
{"code": "for (int i = 0; i < nIter; i++)\n  sgemm(\"N\", \"N\", &size, &size, &size, &alpha, (float *) At, &size, (float *) Bt, &size, &beta, (float *) Ct, &size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/weiwangudel/RCRdaemon-MIC/test_MICEnergyStat_OpenMPoffload_matrix/matrix/5"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n  for (int k = 1; k < (grid->getNZC() - 1); k++)\n{\n  const double q = q_factor * EMf->getRHOcs(i, j, k, ns);\n  u0 = EMf->getJxs(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (u0 > c)\n  {\n    (cout << \"DRIFT VELOCITY x > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  v0 = EMf->getJys(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (v0 > c)\n  {\n    (cout << \"DRIFT VELOCITY y > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  w0 = EMf->getJzs(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (w0 > c)\n  {\n    (cout << \"DRIFT VELOCITY z > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  for (int ii = 0; ii < npcelx; ii++)\n    for (int jj = 0; jj < npcely; jj++)\n    for (int kk = 0; kk < npcelz; kk++)\n  {\n    double u;\n    double v;\n    double w;\n    sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n    const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n    const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n    const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n    create_new_particle(u, v, w, q, x, y, z);\n  }\n\n\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/7"}
{"code": "for (int i = 0; i < m_numParticles; i++)\n{\n  t->calcForce(m_parts[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KunstDerFuge/PartSim/Space/2"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  eval_multi_UBspline_3d_d(multi_spline, x, y, z, multi_vals);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/8"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    double *_imopVarPre384;\n    double *_imopVarPre385;\n    double (*_imopVarPre386)[5];\n    _imopVarPre384 = rhs[i][j][k];\n    _imopVarPre385 = rhs[i][j - 1][k];\n    _imopVarPre386 = lhs[i][j][k][0];\n    matvec_sub(_imopVarPre386, _imopVarPre385, _imopVarPre384);\n    double (*_imopVarPre390)[5];\n    double (*_imopVarPre391)[5];\n    double (*_imopVarPre392)[5];\n    _imopVarPre390 = lhs[i][j][k][1];\n    _imopVarPre391 = lhs[i][j - 1][k][2];\n    _imopVarPre392 = lhs[i][j][k][0];\n    matmul_sub(_imopVarPre392, _imopVarPre391, _imopVarPre390);\n    double *_imopVarPre396;\n    double (*_imopVarPre397)[5];\n    double (*_imopVarPre398)[5];\n    _imopVarPre396 = rhs[i][j][k];\n    _imopVarPre397 = lhs[i][j][k][2];\n    _imopVarPre398 = lhs[i][j][k][1];\n    binvcrhs(_imopVarPre398, _imopVarPre397, _imopVarPre396);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/56"}
{"code": "for (int i = 0; i < ny; i++)\n  buffW[i] = U(0, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment6/mini_app/operators/3"}
{"code": "for (int i = 0; i < b.np; ++i)\n  ge[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_slmm/1"}
{"code": "for (int s = -1; s <= 1; s++)\n{\n  for (int t = -1; t <= 1; t++)\n  {\n    if (!(((((row + s) <= 0) || ((col + t) <= 0)) || ((col + t) >= width)) || ((row + s) >= height)))\n    {\n      pixelResultX += (sobelMaskX[s + 1][t + 1] * ((int) original[(((3 * (row + s)) * width) + ((col + t) * 3)) + color])) / sobelWeight;\n      pixelResultY += (sobelMaskY[s + 1][t + 1] * ((int) original[(((3 * (row + s)) * width) + ((col + t) * 3)) + color])) / sobelWeight;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DCRobledo/OpenMP-image-filter-system/img-par/image-par/0"}
{"code": "for (int i = 0; i < dataset.dim; i++)\n{\n  if ((i >= init) && (i <= end))\n  {\n    testSet->data[appte] = (float *) calloc(dataset.atts, sizeof(float));\n    for (int u = 0; u < dataset.atts; u++)\n      testSet->data[appte][u] = dataset.data[i][u];\n\n    appte++;\n  }\n  else\n  {\n    trainingSet->data[apptr] = (float *) calloc(dataset.atts, sizeof(float));\n    for (int u = 0; u < dataset.atts; u++)\n      trainingSet->data[apptr][u] = dataset.data[i][u];\n\n    apptr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/16"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = b[i] + c[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/clang/test/CodeGen/opt-record-1/0"}
{"code": "for (int m = 0; m < ts.ROWS; m++)\n{\n  index[m] = ts.value[m * ts.COLS];\n  signal[m] = ts.value[(m * ts.COLS) + 1];\n  uncert[m] = ts.value[(m * ts.COLS) + 2];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mwilchek/HPC-Examples/Project_1/Get_Stats/src/get_data/2"}
{"code": "for (i = 0; i < SZ; i++)\n{\n  for (j = 0; j < SZ; j++)\n  {\n    double *pA;\n    double *pB;\n    double S;\n    S = 0.0;\n    pA = a + (i * SZ);\n    pB = b + j;\n    for (k = SZ; k > 0; k--, pA++, pB += SZ)\n      S += (*pA) * (*pB);\n\n    c[(i * SZ) + j] = S;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/MPP1/algoritmo_1/0"}
{"code": "for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n{\n  this_diff = RefOut[i][j] - C[i][j];\n  if (this_diff < 0)\n    this_diff = (-1.0) * this_diff;\n\n  if (this_diff > 0.000000001)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n      maxdiff = this_diff;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/4"}
{"code": "for (i = 0; i < l; i++)\n  if (y[i] == (+1))\n{\n  alpha[i] = min(1.0, sum_pos);\n  sum_pos -= alpha[i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/28"}
{"code": "for (nncols = 0, i = 0; i < ncols; i++)\n{\n  if (clens[i].key > 0)\n    colmap[clens[i].val] = nncols++;\n  else\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/26"}
{"code": "for (int i = 0; i < num_variates; i++)\n{\n  variates[i] = uniform_int(eng);\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmadsen/neutral-model-cpp/src/parallel_random/0"}
{"code": "for (index = 0; index < count; index += SIMD_KEYS)\n{\n  unsigned char out[20];\n  SHA_CTX ctx;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, out, 20, 0);\n  hmac_sha1(out, 20, (unsigned char *) \"Client Key\", 10, out, 20);\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, out, 20);\n  SHA1_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/xmpp_scram_fmt_plug/1"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.m; j++)\n  {\n    dataSet.C[(i * dataSet.m) + j] = dataSet.A[(i * dataSet.m) + j] + dataSet.B[(i * dataSet.m) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/ParaLab/OpenMP/matrix-addition/mat_add/0"}
{"code": "for (int i = 0; i < shared_params[SEQ_PER_PROC_POSIT]; i++)\n{\n  MPI_Send(pref_sum_arr[i], shared_params[SEQ_LEN_POSIT], MPI_DOUBLE, MASTER_PROC_RANK, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/15"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE] -c CUTOFF\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/4"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    Dyu[IDX(i, 3, k)] = ((((-3.0) * u[IDX(i, 3, k)]) + (4.0 * u[IDX(i, 4, k)])) - u[IDX(i, 5, k)]) * idy_by_2;\n    Dyu[IDX(i, 4, k)] = ((-u[IDX(i, 3, k)]) + u[IDX(i, 5, k)]) * idy_by_2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/6"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  v1 = _mm_load_ps(&x[i]);\n  absval = _mm_andnot_ps(SIGNMASK, v1);\n  zero = _mm_set1_ps(1.0);\n  add = _mm_dp_ps(absval, zero, 0xFF);\n  _mm_store_ps(tmp, add);\n  asum += tmp[0];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:asum) reduction(+:tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/asum/2"}
{"code": "for (int i = 0; i < iArgNumerical; ++i)\n{\n  if (a_stVal.empty())\n    Error(ecINTERNAL_ERROR, m_pTokenReader->GetPos(), funTok.GetAsString());\n\n  stArg.push_back(a_stVal.top());\n  a_stVal.pop();\n  if ((stArg.back().GetType() == tpSTR) && (funTok.GetType() != tpSTR))\n    Error(ecVAL_EXPECTED, m_pTokenReader->GetPos(), funTok.GetAsString());\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/beltoforion/muparser/src/muParserBase/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  A[i] = (((DATA_TYPE) i) + 2) / n;\n  B[i] = (((DATA_TYPE) i) + 3) / n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/jacobi-1d-imper/jacobi-1d-imper/2"}
{"code": "for (int i = 1; i < MAX_SAMPLING; i++)\n{\n  dx[i] = frand(mt_engine);\n  dy[i] = frand(mt_engine);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/seiji19761225/mandelbrot/misc/mandelbrot/1"}
{"code": "for (i = 1; i < vals[0]; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    if (((1 + probNum) % size) == rank)\n    {\n      my_max_i = (gene_lens[i] > my_max_i) ? (gene_lens[i]) : (my_max_i);\n      my_max_j = (gene_lens[j] > my_max_j) ? (gene_lens[j]) : (my_max_j);\n    }\n\n    probNum += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/13"}
{"code": "for (i = 0; i < matrixSize; i++)\n{\n  double tmp = 0;\n  double *MHead = &M[i * matrixSize];\n  for (j = 0; j < matrixSize; j++)\n  {\n    tmp += MHead[j] * V[j];\n  }\n\n  results[i] = tmp;\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/matrix_vector_multiplication/mvm_benchmarking/0"}
{"code": "for (i = 0; i < 256; i++)\n  for (j = 0; j < 256; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoyMitra/android-parallel-benchmarks/openmp/max-array/app/src/main/cpp/matrix-mult/0"}
{"code": "for (i = 0; i < 5; i++)\n  switch (CLASS)\n{\n  case 'S':\n    test_index_array[i] = S_test_index_array[i];\n    test_rank_array[i] = S_test_rank_array[i];\n    break;\n\n  case 'A':\n    test_index_array[i] = A_test_index_array[i];\n    test_rank_array[i] = A_test_rank_array[i];\n    break;\n\n  case 'W':\n    test_index_array[i] = W_test_index_array[i];\n    test_rank_array[i] = W_test_rank_array[i];\n    break;\n\n  case 'B':\n    test_index_array[i] = B_test_index_array[i];\n    test_rank_array[i] = B_test_rank_array[i];\n    break;\n\n  case 'C':\n    test_index_array[i] = C_test_index_array[i];\n    test_rank_array[i] = C_test_rank_array[i];\n    break;\n\n  case 'D':\n    test_index_array[i] = D_test_index_array[i];\n    test_rank_array[i] = D_test_rank_array[i];\n    break;\n\n  case 'E':\n    test_index_array[i] = E_test_index_array[i];\n    test_rank_array[i] = E_test_rank_array[i];\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/17"}
{"code": "for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6 += 1)\n{\n  __pyx_v_i = __pyx_t_6;\n  __pyx_t_2 = (__pyx_v_tmpslice->shape[__pyx_v_i] == 1) != 0;\n  if (__pyx_t_2)\n  {\n    __pyx_v_tmpslice->strides[__pyx_v_i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/19"}
{"code": "for (i = 0; i < 10; i++)\n{\n  result[i] = i;\n  printf(\"%d \", result[i]);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/tests/openmp/unit/for_increment/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  C[i] = A[i] + B[i];\n  printf(\"Thread %d:c[%d]=%f\\n\", tid, i, C[i]);\n}\n\n", "pragma": "omp for schedule(guided, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Labs/Parallel-Computing-Lab/Lab2/sum_2_vectors/0"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float a = 1. + (tn * tn);\n  float b = (-2.) * (xc + (yc * tn));\n  float c = ((xc * xc) + (yc * yc)) - (r * r);\n  float d = (b * b) - ((4. * a) * c);\n  if (d < 0)\n  {\n    continue;\n  }\n\n  d = sqrt(d);\n  float t1 = ((-b) + d) / (2. * a);\n  float t2 = ((-b) - d) / (2. * a);\n  float tmin = (t1 < t2) ? (t1) : (t2);\n  if (tmin < 0)\n  {\n    continue;\n  }\n\n  float xcir = tmin;\n  float ycir = tmin * tn;\n  float nx = xcir - xc;\n  float ny = ycir - yc;\n  float nxy = sqrt((nx * nx) + (ny * ny));\n  nx /= nxy;\n  ny /= nxy;\n  float inx = xcir - 0.;\n  float iny = ycir - 0.;\n  float in = sqrt((inx * inx) + (iny * iny));\n  inx /= in;\n  iny /= in;\n  float dot = (inx * nx) + (iny * ny);\n  float outx = inx - ((2. * nx) * dot);\n  float outy = iny - ((2. * ny) * dot);\n  float tt = (0. - ycir) / outy;\n  if (tt < 0)\n  {\n    continue;\n  }\n\n  numHits++;\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(xcs,ycs,rs,tn) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulienMinato/Using-Cpp-Parallel-Programming/pro1/pro1/0"}
{"code": "for (j = 0; j < bands; j++)\n{\n  for (k = 0; k < cols; k++)\n  {\n    if (buffer[(j * cols) + k] != nvalue)\n    {\n      var[j] += (buffer[(j * cols) + k] - mean[j]) * (buffer[(j * cols) + k] - mean[j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/ODM/0"}
{"code": "for (int i = 0; i < 10; i++)\n  a[i] = computeValue(i);\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture5/Loop_construct_implicit_barrier/Loop_construct_implicit_barrier/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/98"}
{"code": "for (k = 0; k < 10; k++)\n{\n  printf(\"k = %d, threadID = %d\\n\", k, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/7"}
{"code": "for (i = 0; i <= (64 + 1); i++)\n{\n  for (k = 0; k <= (64 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/13"}
{"code": "for (k = 0; k < number_of_partitions; k++)\n{\n  local_offset = k * base_partition_size;\n  for (i = k * base_partition_size; i < min((k + 1) * base_partition_size, input_dwg->size); i++)\n  {\n    local_index = naive_partitioning_convert_to_local_index(i, local_offset);\n    neighbors = input_dwg->edges + i;\n    ((*((*partitions) + k))->edges + local_index)->self_loop = neighbors->self_loop;\n    for (j = 0; j < neighbors->count; j++)\n    {\n      dest = naive_partitioning_convert_to_local_index((neighbors->addr + j)->dest, local_offset);\n      weight = (neighbors->addr + j)->weight;\n      if ((dest >= 0) && (dest < base_partition_size))\n      {\n        if (!dynamic_weighted_graph_insert_force_directed(*((*partitions) + k), local_index, dest, weight))\n        {\n          printf(\"Could not insert edge in partition graph!\\n\");\n          free_partitions(*partitions, number_of_partitions);\n          free(*partitions);\n          return 0;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/version-parallel-naive-partitioning/3"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n    A[i][j] = rand() % n;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw8/main/3"}
{"code": "for (i = 0; i < range; i++)\n{\n  sorted[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/statisticspar/4"}
{"code": "for (i = 0; i < m; ++i)\n  for (j = 0; j < m; ++j)\n{\n  *((C + ((i + 0) * n)) + (j + 0)) = *((c11 + (i * m)) + j);\n  *((C + ((i + 0) * n)) + (j + m)) = *((c12 + (i * m)) + j);\n  *((C + ((i + m) * n)) + (j + 0)) = *((c21 + (i * m)) + j);\n  *((C + ((i + m) * n)) + (j + m)) = *((c22 + (i * m)) + j);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/6"}
{"code": "for (int r = 1; r < (rows + cols); r++)\n{\n  Antena arriba = {miAntena.y - r, miAntena.x};\n  Antena abajo = {miAntena.y + r, miAntena.x};\n  int distancia = manhattan(miAntena, arriba.y, arriba.x);\n  int flag = 0;\n  for (int delta = 0; delta <= r; delta++)\n  {\n    if ((((((arriba.y + delta) >= 0) && ((arriba.y + delta) < rows)) && ((arriba.x + delta) >= 0)) && ((arriba.x + delta) < cols)) && (mapa[arriba.y + delta][arriba.x + delta] > distancia))\n    {\n      mapa[arriba.y + delta][arriba.x + delta] = distancia;\n      flag = 1;\n    }\n\n    if ((((((arriba.y + delta) >= 0) && ((arriba.y + delta) < rows)) && ((arriba.x - delta) >= 0)) && ((arriba.x - delta) < cols)) && (mapa[arriba.y + delta][arriba.x - delta] > distancia))\n    {\n      mapa[arriba.y + delta][arriba.x - delta] = distancia;\n      flag = 1;\n    }\n\n  }\n\n  for (int delta = r - 1; delta >= 0; delta--)\n  {\n    if ((((((abajo.y - delta) >= 0) && ((abajo.y - delta) < rows)) && ((abajo.x + delta) >= 0)) && ((abajo.x + delta) < cols)) && (mapa[abajo.y - delta][abajo.x + delta] > distancia))\n    {\n      mapa[abajo.y - delta][abajo.x + delta] = distancia;\n      flag = 1;\n    }\n\n    if ((((((abajo.y - delta) >= 0) && ((abajo.y - delta) < rows)) && ((abajo.x - delta) >= 0)) && ((abajo.x - delta) < cols)) && (mapa[abajo.y - delta][abajo.x - delta] > distancia))\n    {\n      mapa[abajo.y - delta][abajo.x - delta] = distancia;\n      flag = 1;\n    }\n\n  }\n\n  if (flag == 0)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas5.1b/0"}
{"code": "for (int i = 0; i < omp_get_num_threads(); ++i)\n{\n  if (find_first_array[i] < least_index)\n    least_index = find_first_array[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP Tasks/q2_w/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  xpos_.push_back(xdist(re));\n  ypos_.push_back(ydist(re));\n  mass_.push_back(mdist(re));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jprieto92/parallel-programming-openmp-nbodies/nbody/src/bodiessoa/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/Reduction/3"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/28"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task7/2"}
{"code": "for (size_t i = 0; i < natoms; ++i)\n{\n  frame_com += atom_positions[i] * mass_list[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/22"}
{"code": "for (i = 0; i < 1024; i++)\n  a[i] += b[i] * 2;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/simd-1/4"}
{"code": "for (i = 1; i < (1024 - 1); i++)\n{\n  j = (i % 2) ? (1) : (2);\n  for (; j < (1024 - 1); j += 2)\n  {\n    if ((i == 799) && (j == 799))\n      continue;\n\n    temp[i][j] = 0.25 * (((mat[i - 1][j] + mat[i + 1][j]) + mat[i][j - 1]) + mat[i][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(temp,mat) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunobehnken/OpenMP-Studies/heat_propagation/sor_par32/0"}
{"code": "for (unsigned int i = 0; i < mAcceleration.size(); i++)\n{\n  mAcceleration[i] = (max_allowed_acceleration / norm_acceleration) * mAcceleration[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/multiaxial_control_module_generalized_2d_utilities/5"}
{"code": "for (i = 0; i < 3; i++)\n{\n  force[i] = force[i] * ((1. - ((((All.G * 4.) * bhmdist) * invc) * invc)) + velsq);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/gravtree/10"}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  counters[tid]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/TestParallelFor/0"}
{"code": "for (int i = 0; i < a; i++)\n{\n  printf(\"[%d]\", L[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoEREW/3"}
{"code": "for (int i = 0; i < n; ++i)\n  fill(matr[i], m);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/16"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(stdout, \"%-14u \", topK_array[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/18"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  y[i] = x[i] + 2;\n}\n\n", "pragma": "omp for order(reproducible:concurrent)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/order/test_parallel_for_order_reproducible/1"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  for (int j = 1; j < (m - 1); j++)\n  {\n    const int pos = (i * m) + j;\n    (*mat)[pos] = temp[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minar09/parallel-computing/OpenMP/jacobi_openmp/1"}
{"code": "for (int i = 0; i < N; ++i)\n  if (min > array[i])\n  min = array[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kvitnat/Parallel-programming-lab/OpenMP/omp/2"}
{"code": "for (int i = 1; i < maxThreads; i++)\n{\n  paddingTimeBugffer[0] += paddingTimeBugffer[i];\n  dctTimeBuffer[0] += dctTimeBuffer[i];\n  encodeTimeBuffer[0] += encodeTimeBuffer[i];\n  encodeBlockTimeBuffer[0] += encodeBlockTimeBuffer[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nctu-pp/mjpeg-encoder/core/encoder/MJPEGEncoderOpenMPImpl/0"}
{"code": "for (i = 0; i < a_r; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < a_c; j++)\n  {\n    c[i][j] = a[i][j] + b[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejaswiParuchuri/ParalleProcessing/addmp/0"}
{"code": "for (i = 0; i < prob->l; i++)\n  if (fabs(f.alpha[i]) > 0)\n{\n  model->SV[j] = prob->x[i];\n  model->sv_coef[0][j] = f.alpha[i];\n  model->sv_indices[j] = i + 1;\n  ++j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/53"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j += 1)\n{\n  norm_temp11 = norm_temp11 + (x[j] * z[j]);\n  norm_temp12 = norm_temp12 + (z[j] * z[j]);\n}\n\n", "pragma": "omp parallel for private (j) reduction (+:norm_temp11,norm_temp12)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/3"}
{"code": "for (unsigned c = 0; c < Count(); c++)\n  List[c]->SaveVtkConfig(dp, &sh);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsDamping/2"}
{"code": "for (i = 1; i < 2400; i++)\n{\n  for (j = 0; j < 2400; j++)\n  {\n    ey[(i * 2400) + j] = ey[(i * 2400) + j] - (0.5 * (hz[(i * 2400) + j] - hz[((i - 1) * 2400) + j]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/10"}
{"code": "for (tempCounter1 = 0; tempCounter1 < nodeNumber; tempCounter1++)\n{\n  nodeData[tempCounter1][2] = maxWeight + 1;\n  for (tempCounter2 = 0; tempCounter2 < nodeNumber; tempCounter2++)\n  {\n    if (((graphTable[tempCounter1][tempCounter2] > 0) && (graphTable[tempCounter1][tempCounter2] < nodeData[tempCounter1][2])) && (nodeData[tempCounter2][1] == 0))\n    {\n      nodeData[tempCounter1][2] = graphTable[tempCounter1][tempCounter2];\n      nodeData[tempCounter1][3] = tempCounter2;\n      nodeData[tempCounter1][4] = tempCounter1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(tempCounter1, tempCounter2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YiannisN/Prim_C_Threads_OpenMP/OpenMP/src/farmer/0"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  cast_out->vec_[ai] += (scalar * this->mat_.val[ai]) * cast_in->vec_[ai];\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    cast_out->vec_[ai] += (scalar * this->mat_.val[aj]) * cast_in->vec_[this->mat_.col[aj]];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_mcsr/2"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    first[i][j] = rand() % 255;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiSoJi/Arqui2_Taller02/op_par/4"}
{"code": "for (i = 0; i <= plength; i += 16)\n{\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, password + i, MIN(plength - i, 16));\n  for (j = 0; j < 2000; j++)\n  {\n    SHA1_Final(buf, &ctx);\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, buf, 20);\n  }\n\n  memcpy(output + oindex, buf, 20);\n  oindex += 20;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/kwallet_fmt_plug/3"}
{"code": "for (; i < passLen; i++)\n{\n  pass[i] = optarg[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arthurhoch/des-cipher-openmp/src/des/5"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n  mat[i][j] = ((float) ((rand() % 10) + 1)) / 100;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW4/det/3"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n  for (j = 0; j < ((250 * 1024) / 256); j++)\n  if (i <= j)\n{\n  A[(i * ((250 * 1024) / 256)) + j] = (float) (((i * ((250 * 1024) / 256)) + j) + 1);\n}\nelse\n{\n  A[(i * ((250 * 1024) / 256)) + j] = 0.0;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 1/matmul/2"}
{"code": "for (int i = 0; i < particles->length; i++)\n{\n  particle_t *particle = list_get(particles, i);\n  if (((int) particle->index) == 0)\n  {\n    printf(\"%.2f %.2f\\n\", particle->position.x, particle->position.y);\n    fflush(stdout);\n  }\n\n  total_mass += particle->mass;\n  center_of_mass_x += particle->mass * particle->position.x;\n  center_of_mass_y += particle->mass * particle->position.y;\n}\n\n", "pragma": "omp parallel for reduction(+ : total_mass, center_of_mass_x, center_of_mass_y)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, hydro_data->r0[i] - (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] - (0.5 * hydro_data->r1_size[i]), 0);\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, hydro_data->r0[i] + (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] + (0.5 * hydro_data->r1_size[i]), 0);\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], hydro_data->r2[i]);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, position_phi);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/24"}
{"code": "for (int j = 0; j < 2; j++)\n  test();\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wyh0655/OpenMP_EXA/exa1/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  v_it = _mm512_set1_epi32(k);\n  v_dky = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dky = _mm512_mul_ps(v_dny, v_dky);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  ws = 0.0;\n  wp = 0.0;\n  v_ws = _mm512_set1_pd(0.0);\n  v_wp = _mm512_set1_pd(0.0);\n  v_dk1 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(12336), v_dky);\n  v_dk2 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(771), v_dky);\n  for (j = 0; j < nxhs; j += 2)\n  {\n    v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n    v_dkx = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dkx = _mm512_mul_ps(v_dnx, v_dkx);\n    v_dk1 = _mm512_mask_mov_ps(v_dk1, _mm512_int2mask(3084), v_dkx);\n    v_dk2 = _mm512_mask_mov_ps(v_dk2, _mm512_int2mask(12336), v_dkx);\n    v_afdt = _mm512_mask_loadunpacklo_ps(v_zero, _mm512_int2mask(15), (float *) (&ffc[j + kk]));\n    v_afdt = _mm512_mask_loadunpackhi_ps(v_afdt, _mm512_int2mask(15), (float *) (&ffc[(j + kk) + 8]));\n    v_afdt = _mm512_permute4f128_ps(v_afdt, 0);\n    v_afdt = (int) _mm512_mask_shuffle_epi32((int) v_afdt, _mm512_int2mask(13260), (int) v_afdt, 78);\n    v_afdt = (int) _mm512_mask_shuffle_epi32((int) v_afdt, _mm512_int2mask(21845), (int) v_afdt, 177);\n    v_afdt = _mm512_mul_ps(v_adt, v_afdt);\n    v_zt4 = _mm512_load_ps((float *) (&exyz[4 * (j + kj)]));\n    v_zt3 = _mm512_mask_sub_ps(v_zt4, _mm512_int2mask(43690), v_zero, v_zt4);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    v_zt1 = _mm512_mul_ps(v_dk1, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_dk2, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_mul_ps(v_dth, _mm512_sub_ps(v_zt1, v_zt2));\n    v_zt2 = _mm512_load_ps((float *) (&bxyz[4 * (j + kj)]));\n    v_zt5 = _mm512_sub_ps(v_zt2, v_zt1);\n    v_zt3 = _mm512_mask_sub_ps(v_zt5, _mm512_int2mask(43690), v_zero, v_zt5);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    v_zt1 = _mm512_mul_ps(v_dk1, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_dk2, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_fmadd_ps(v_cdt, _mm512_sub_ps(v_zt1, v_zt2), v_zt4);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + kj)]));\n    v_zt2 = _mm512_mask_mul_ps(v_zero, _mm512_int2mask(16191), v_afdt, v_zt2);\n    v_zt4 = _mm512_sub_ps(v_zt1, v_zt2);\n    v_zt3 = _mm512_mask_sub_ps(v_zt4, _mm512_int2mask(43690), v_zero, v_zt4);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    if (j == 0)\n    {\n      v_zt4 = _mm512_mask_mov_ps(v_zt4, _mm512_int2mask(255), v_zero);\n      _mm512_mask_store_ps((float *) (&exyz[4 * (j + kj)]), _mm512_int2mask(65280), v_zt4);\n    }\n    else\n    {\n      _mm512_store_ps((float *) (&exyz[4 * (j + kj)]), v_zt4);\n    }\n\n    v_zt6 = _mm512_mul_ps(v_anorm, _mm512_mul_ps(v_zt4, v_zt4));\n    v_zt1 = _mm512_mul_ps(v_dk1, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_dk2, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_mul_ps(v_dth, _mm512_sub_ps(v_zt1, v_zt2));\n    v_zt5 = _mm512_sub_ps(v_zt5, v_zt1);\n    if (j == 0)\n    {\n      v_zt5 = _mm512_mask_mov_ps(v_zt5, _mm512_int2mask(255), v_zero);\n      _mm512_mask_store_ps((float *) (&bxyz[4 * (j + kj)]), _mm512_int2mask(65280), v_zt5);\n    }\n    else\n    {\n      _mm512_store_ps((float *) (&bxyz[4 * (j + kj)]), v_zt5);\n    }\n\n    v_zt7 = _mm512_mul_ps(v_anorm, _mm512_mul_ps(v_zt5, v_zt5));\n    v_zt4 = _mm512_load_ps((float *) (&exyz[4 * (j + k1)]));\n    v_zt3 = _mm512_mask_sub_ps(v_zt4, _mm512_int2mask(43690), v_zero, v_zt4);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    v_at2 = _mm512_mask_sub_ps(v_dk1, _mm512_int2mask(12336), v_zero, v_dk1);\n    v_at3 = _mm512_mask_sub_ps(v_dk2, _mm512_int2mask(771), v_zero, v_dk2);\n    v_zt1 = _mm512_mul_ps(v_at2, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_at3, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_mul_ps(v_dth, _mm512_sub_ps(v_zt1, v_zt2));\n    v_zt2 = _mm512_load_ps((float *) (&bxyz[4 * (j + k1)]));\n    v_zt5 = _mm512_sub_ps(v_zt2, v_zt1);\n    v_zt3 = _mm512_mask_sub_ps(v_zt5, _mm512_int2mask(43690), v_zero, v_zt5);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    v_zt1 = _mm512_mul_ps(v_at2, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_at3, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_fmadd_ps(v_cdt, _mm512_sub_ps(v_zt1, v_zt2), v_zt4);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + k1)]));\n    v_zt2 = _mm512_mask_mul_ps(v_zero, _mm512_int2mask(16191), v_afdt, v_zt2);\n    v_zt4 = _mm512_sub_ps(v_zt1, v_zt2);\n    v_zt3 = _mm512_mask_sub_ps(v_zt4, _mm512_int2mask(43690), v_zero, v_zt4);\n    v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n    if (j == 0)\n    {\n      v_zt4 = _mm512_mask_mov_ps(v_zt4, _mm512_int2mask(255), v_zero);\n      _mm512_mask_store_ps((float *) (&exyz[4 * (j + k1)]), _mm512_int2mask(65280), v_zt4);\n    }\n    else\n    {\n      _mm512_store_ps((float *) (&exyz[4 * (j + k1)]), v_zt4);\n    }\n\n    v_zt6 = _mm512_fmadd_ps(v_anorm, _mm512_mul_ps(v_zt4, v_zt4), v_zt6);\n    v_zt1 = _mm512_mul_ps(v_at2, v_zt3);\n    v_zt2 = _mm512_mul_ps(v_at3, v_zt3);\n    v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n    v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n    v_zt1 = _mm512_mul_ps(v_dth, _mm512_sub_ps(v_zt1, v_zt2));\n    v_zt5 = _mm512_sub_ps(v_zt5, v_zt1);\n    if (j == 0)\n    {\n      v_zt5 = _mm512_mask_mov_ps(v_zt5, _mm512_int2mask(255), v_zero);\n      _mm512_mask_store_ps((float *) (&bxyz[4 * (j + k1)]), _mm512_int2mask(65280), v_zt5);\n    }\n    else\n    {\n      _mm512_store_ps((float *) (&bxyz[4 * (j + k1)]), v_zt5);\n    }\n\n    v_zt7 = _mm512_fmadd_ps(v_anorm, _mm512_mul_ps(v_zt5, v_zt5), v_zt7);\n    v_ws = _mm512_add_pd(v_ws, _mm512_cvtpslo_pd(v_zt6));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_zt6, 78));\n    v_ws = _mm512_add_pd(v_ws, v_d);\n    v_wp = _mm512_add_pd(v_wp, _mm512_cvtpslo_pd(v_zt7));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_zt7, 78));\n    v_wp = _mm512_add_pd(v_wp, v_d);\n    _mm512_store_ps((float *) (&bxyz[4 * ((j + kj) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&exyz[4 * ((j + kj) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&bxyz[4 * ((j + k1) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&exyz[4 * ((j + k1) + l1)]), v_zero);\n  }\n\n  for (j = itn; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + kk]);\n    zt1 = (-cimagf(exyz[2 + (4 * (j + kj))])) + (crealf(exyz[2 + (4 * (j + kj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (4 * (j + kj))])) + (crealf(exyz[1 + (4 * (j + kj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[4 * (j + kj)])) + (crealf(exyz[4 * (j + kj)]) * _Complex_I);\n    zt4 = bxyz[4 * (j + kj)] - (dth * (dky * zt1));\n    zt5 = bxyz[1 + (4 * (j + kj))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (4 * (j + kj))] - (dth * ((dkx * zt2) - (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[4 * (j + kj)] + (cdt * (dky * zt1))) - (afdt * cu[4 * (j + kj)]);\n    zt8 = (exyz[1 + (4 * (j + kj))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * (j + kj))]);\n    zt9 = (exyz[2 + (4 * (j + kj))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (4 * (j + kj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[4 * (j + kj)] = zt7;\n    exyz[1 + (4 * (j + kj))] = zt8;\n    exyz[2 + (4 * (j + kj))] = zt9;\n    at1 = anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    ws += (double) at1;\n    zt4 -= dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n    bxyz[4 * (j + kj)] = zt4;\n    bxyz[1 + (4 * (j + kj))] = zt5;\n    bxyz[2 + (4 * (j + kj))] = zt6;\n    at1 = anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    wp += (double) at1;\n    zt1 = (-cimagf(exyz[2 + (4 * (j + k1))])) + (crealf(exyz[2 + (4 * (j + k1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (4 * (j + k1))])) + (crealf(exyz[1 + (4 * (j + k1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[4 * (j + k1)])) + (crealf(exyz[4 * (j + k1)]) * _Complex_I);\n    zt4 = bxyz[4 * (j + k1)] + (dth * (dky * zt1));\n    zt5 = bxyz[1 + (4 * (j + k1))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (4 * (j + k1))] - (dth * ((dkx * zt2) + (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[4 * (j + k1)] - (cdt * (dky * zt1))) - (afdt * cu[4 * (j + k1)]);\n    zt8 = (exyz[1 + (4 * (j + k1))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * (j + k1))]);\n    zt9 = (exyz[2 + (4 * (j + k1))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (4 * (j + k1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[4 * (j + k1)] = zt7;\n    exyz[1 + (4 * (j + k1))] = zt8;\n    exyz[2 + (4 * (j + k1))] = zt9;\n    at1 = anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    ws += (double) at1;\n    zt4 += dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n    bxyz[4 * (j + k1)] = zt4;\n    bxyz[1 + (4 * (j + k1))] = zt5;\n    bxyz[2 + (4 * (j + k1))] = zt6;\n    at1 = anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    wp += (double) at1;\n    bxyz[4 * ((j + kj) + l1)] = zero;\n    bxyz[1 + (4 * ((j + kj) + l1))] = zero;\n    bxyz[2 + (4 * ((j + kj) + l1))] = zero;\n    exyz[4 * ((j + kj) + l1)] = zero;\n    exyz[1 + (4 * ((j + kj) + l1))] = zero;\n    exyz[2 + (4 * ((j + kj) + l1))] = zero;\n    bxyz[4 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    exyz[4 * ((j + k1) + l1)] = zero;\n    exyz[1 + (4 * ((j + k1) + l1))] = zero;\n    exyz[2 + (4 * ((j + k1) + l1))] = zero;\n  }\n\n  _mm512_store_pd(&dd[0], v_ws);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum3 += ws + dd[0];\n  _mm512_store_pd(&dd[0], v_wp);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum4 += wp + dd[0];\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,dkx,afdt,at1,zt1,zt2,zt3,zt4,zt5,zt6,zt7,zt8, zt9,ws,wp,v_it,v_dkx,v_dky,v_dk1,v_dk2,v_afdt,v_at2,v_at3,v_zt1,v_zt2, v_zt3,v_zt4,v_zt5,v_zt6,v_zt7,v_d,v_ws,v_wp,dd) reduction(+:sum3,sum4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/22"}
{"code": "for (int i = 0; i < (N - 2); i += 2)\n{\n  sum += (x[i + 2] - x[i]) * ((fvals[i] + (4 * fvals[i + 1])) + fvals[i + 2]);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(static, 1024) num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astrophpeter/C-OpenMP-MPI/homework3/src/integrate/1"}
{"code": "for (int i = 0; i < (((int) 9) / 3); i++)\n{\n  for (int j = 0; j < (((int) 9) / 3); j++)\n  {\n    check_matrix_fn(&matrix_index[i], &matrix_index[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidatorPthread/5"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n  v[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_collapse_01/0"}
{"code": "for (i = 1; i < (mysize + 1); i++)\n{\n  left_send[i - 1] = matrix[i][1];\n  right_send[i - 1] = matrix[i][mysize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Koutoulakis/Parallel_Programming/MPI/5"}
{"code": "for (char **p = _event_names; *p; p++)\n{\n  free(*p);\n  *p = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/breiters/papi_omp_util/src/papi_util/5"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (n = 0; n < 5; n++)\n  {\n    lhs[i][j][k][0][m][n] = 0.0;\n    lhs[i][j][k][1][m][n] = 0.0;\n    lhs[i][j][k][2][m][n] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/18"}
{"code": "for (i = 0; i < nTHREADS; i++)\n{\n  if (i == (nTHREADS - 1))\n  {\n    partialAddition(vector + (i * subvector_size), last_subvector_size);\n  }\n  else\n  {\n    partialAddition(vector + (i * subvector_size), subvector_size);\n  }\n\n  if (0)\n    printf(\"I'm thread n\u00ba %d, I process the section %d.\\n\", omp_get_thread_num(), i);\n\n}\n\n", "pragma": "omp parallel for num_threads(nTHREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/sum_vector/0"}
{"code": "for (i = k + 1; i <= (n - 1); i++)\n{\n  for (j = k + 1; j <= (n - 1); j++)\n  {\n    A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n  }\n\n  b[i] = b[i] - (A[i][k] * y[k]);\n  A[i][k] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shrmoud/jarvis/hw2/openMPgauss/1"}
{"code": "for (i = 0; i < bands; i++)\n{\n  mpv[i] = buffer2[(i * cols) + maxcol];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a[%d] suma=%d\\n \", omp_get_thread_num(), i, suma);\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/firstlastprivate-clause/0"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    C[(i * 1000) + j] = 0.0;\n    for (int k = 0; k < 1000; ++k)\n    {\n      C[(i * 1000) + j] += A[(i * 1000) + k] * B[(k * 1000) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse (1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/0"}
{"code": "for (i_imopVar88 = 0; i_imopVar88 < 12; i_imopVar88++)\n{\n  for (j_imopVar89 = 0; j_imopVar89 < 12; j_imopVar89++)\n  {\n    for (k_imopVar90 = 0; k_imopVar90 < 12; k_imopVar90++)\n    {\n      for (m_imopVar91 = 0; m_imopVar91 < 5; m_imopVar91++)\n      {\n        u[i_imopVar88][j_imopVar89][k_imopVar90][m_imopVar91] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/46"}
{"code": "for (vi = viend - 1; vi >= vistart; vi--)\n{\n  psum -= nxadj[vi];\n  nxadj[vi] = psum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/11"}
{"code": "for (i = 0; i < N; i++)\n  res[i] = res_block + (i * N);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidbejarcaceres/OpenMP-Matrix-Multiplication/mmOMP/6"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  tmp[j] += j;\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom : tmp)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MJChku/openmp_source/libomptarget/test/offloading/parallel_offloading_map/1"}
{"code": "for (int iter = 0; iter < 6; iter++)\n{\n  float prev = TMPHIST(nBins - 1);\n  float first = TMPHIST(0);\n  int i;\n  for (i = 0; i < (nBins - 1); i++)\n  {\n    float newh = ((prev + TMPHIST(i)) + TMPHIST(i + 1)) / 3.0f;\n    prev = hist[i];\n    hist[i] = newh;\n  }\n\n  hist[i] = ((prev + hist[i]) + first) / 3.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/9"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 4)\n    {\n      int pp = IDX(i, j, k);\n      if (betay[pp] > 0.0)\n      {\n        Dyu[pp] = ((((((-3.0) * u[pp - nx]) - (10.0 * u[pp])) + (18.0 * u[pp + nx])) - (6.0 * u[pp + (2 * nx)])) + u[pp + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp] = (((((-u[pp - (3 * nx)]) + (6.0 * u[pp - (2 * nx)])) - (18.0 * u[pp - nx])) + (10.0 * u[pp])) + (3.0 * u[pp + nx])) * idy_by_12;\n      }\n\n      if (betay[pp + 1] > 0.0)\n      {\n        Dyu[pp + 1] = ((((((-3.0) * u[(pp + 1) - nx]) - (10.0 * u[pp + 1])) + (18.0 * u[(pp + 1) + nx])) - (6.0 * u[(pp + 1) + (2 * nx)])) + u[(pp + 1) + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp + 1] = (((((-u[(pp + 1) - (3 * nx)]) + (6.0 * u[(pp + 1) - (2 * nx)])) - (18.0 * u[(pp + 1) - nx])) + (10.0 * u[pp + 1])) + (3.0 * u[(pp + 1) + nx])) * idy_by_12;\n      }\n\n      if (betay[pp + 2] > 0.0)\n      {\n        Dyu[pp + 2] = ((((((-3.0) * u[(pp + 2) - nx]) - (10.0 * u[pp + 2])) + (18.0 * u[(pp + 2) + nx])) - (6.0 * u[(pp + 2) + (2 * nx)])) + u[(pp + 2) + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp + 2] = (((((-u[(pp + 2) - (3 * nx)]) + (6.0 * u[(pp + 2) - (2 * nx)])) - (18.0 * u[(pp + 2) - nx])) + (10.0 * u[pp + 2])) + (3.0 * u[(pp + 2) + nx])) * idy_by_12;\n      }\n\n      if (betay[pp + 3] > 0.0)\n      {\n        Dyu[pp + 3] = ((((((-3.0) * u[(pp + 3) - nx]) - (10.0 * u[pp + 3])) + (18.0 * u[(pp + 3) + nx])) - (6.0 * u[(pp + 3) + (2 * nx)])) + u[(pp + 3) + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp + 3] = (((((-u[(pp + 3) - (3 * nx)]) + (6.0 * u[(pp + 3) - (2 * nx)])) - (18.0 * u[(pp + 3) - nx])) + (10.0 * u[pp + 3])) + (3.0 * u[(pp + 3) + nx])) * idy_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/28"}
{"code": "for (i = 0; i <= (N - 1); i++)\n  for (j = 0; j <= (N - 1); j++)\n  for (k = 0; k <= (N - 1); k++)\n{\n  localS += (((A[i][j][k] * (i + 1)) * (j + 1)) * (k + 1)) / ((N * N) * N);\n}\n\n\n\n", "pragma": "omp for private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexbuchkin/Sor3D_openmp/sor3d_openmp/2"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  printf(\"%d \", local[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francesc0rtu/Parallel-kd-tree/test/04-for/5"}
{"code": "for (int i = 0; i < m_nCells; ++i)\n{\n  m_sd[i] = m_depCo * m_depCap[i];\n  m_sr[i] = 0.0f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/DEP_FS/DepressionFS/0"}
{"code": "for (int i = 0; i < forwardValues.size(); i++)\n{\n  for (int j = 0; j < forwardValues[0].size(); j++)\n  {\n    if (i == j)\n      identity[i][j] = 1;\n    else\n      identity[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/7"}
{"code": "for (int i = 0; i < omp_get_num_teams(); i++)\n{\n  lastpriv[0] = omp_get_team_num();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-teams-distribute/test/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nk; j++)\n  A[i][j] = ((DATA_TYPE) ((i * (j + 1)) % nk)) / nk;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/blas/gemm/gemm/2"}
{"code": "for (i = 0; i < (2 * N); i++)\n  for (j = i + 1; j < (2 * N); j++)\n{\n  del[0] = x[i][0] - x[j][0];\n  del[1] = x[i][1] - x[j][1];\n  del[2] = x[i][2] - x[j][2];\n  rsq = ((del[0] * del[0]) + (del[1] * del[1])) + (del[2] * del[2]);\n  if (rsq < cutsq)\n    neigh[i][++neigh[i][0]] = j;\n\n}\n\n\n", "pragma": "omp parallel for private (j,del,rsq)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/neighbour-simple/0"}
{"code": "for (int i = 0; i < floor(0.8 * datasize); i++)\n{\n  x_train.push_back(data[i]);\n  y_train.push_back(y[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/22"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    if (!obstacles[ii + (jj * params.nx)])\n    {\n      float local_density = (((((((cells->speed_0[ii + (jj * params.nx)] + cells->speed_1[ii + (jj * params.nx)]) + cells->speed_2[ii + (jj * params.nx)]) + cells->speed_3[ii + (jj * params.nx)]) + cells->speed_4[ii + (jj * params.nx)]) + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_6[ii + (jj * params.nx)]) + cells->speed_7[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)];\n      float u_x = (((cells->speed_1[ii + (jj * params.nx)] + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)]) - ((cells->speed_3[ii + (jj * params.nx)] + cells->speed_6[ii + (jj * params.nx)]) + cells->speed_7[ii + (jj * params.nx)])) / local_density;\n      float u_y = (((cells->speed_2[ii + (jj * params.nx)] + cells->speed_5[ii + (jj * params.nx)]) + cells->speed_6[ii + (jj * params.nx)]) - ((cells->speed_4[ii + (jj * params.nx)] + cells->speed_7[ii + (jj * params.nx)]) + cells->speed_8[ii + (jj * params.nx)])) / local_density;\n      tot_u += sqrtf((u_x * u_x) + (u_y * u_y));\n      tot_cells++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreiCNitu/HPC/lattice-boltzmann/openMP/lbm/4"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"%i \", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/7th/7th/4"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  {\n    sum = sum + i;\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_critical/0"}
{"code": "for (i = 0; i <= nsub; i++)\n{\n  printf(\"  %8d  %8d\\n\", i, indx[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/18"}
{"code": "for (int i = 0; i < N; i++)\n{\n  fprintf(stderr, \"%8.2f | \", 0.0f);\n  for (int j = 0; j < N; j++)\n  {\n    float diff = fabsf(test[i][j] - ref[i][j]);\n    max_err = fmaxf(max_err, diff);\n    min_err = fminf(min_err, diff);\n    verif = verif && (diff < 1e-2);\n  }\n\n  fprintf(stderr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/12"}
{"code": "for (j = 0; j < 102400; j++)\n{\n  LaunchPhoton(out_parm.Rsp, In_Ptr->layerspecs, &photon);\n  do\n    HopDropSpin(In_Ptr, &photon, &tmpOut_Ptr[j], &rand_seed[omp_get_thread_num()]);\n  while (!photon.dead);\n}\n\n", "pragma": "omp parallel for private(photon)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunyenho/MCML_OpenMP/mcmlmain/0"}
{"code": "for (long long c = average + 1; c <= d; c++)\n{\n  second = second + c;\n  counter++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GennadySX/vvrs/lab_1/main/1"}
{"code": "for (int i = 0; i < colNumX; i++)\n{\n  XmatVecTemp = Xmat.col(i);\n  Sigma_iX.col(i) = getPCG1ofSigmaAndVector(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    float temp = 0;\n    for (int k = 0; k < n; k++)\n      temp += A[i][k] * B[k][j];\n\n    C[i][j] = temp;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(A,B,C,n) schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part1/Asgn1/1"}
{"code": "for (int id = 0; id < ((source_height * source_width) * source_nchannel); id++)\n{\n  if (boundary_array[id] == INSIDE_MASK)\n  {\n    outimg[id] = targetimg[id];\n  }\n  else\n  {\n    outimg[id] = srcimg[id];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, CHUNKSIZE1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/9"}
{"code": "for (i = 0; i < (1 << 27); i++)\n  key_buff2[i] = 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/13"}
{"code": "for (int jj = internal_ystart; jj <= internal_ystop; jj++)\n{\n  for (int ji = internal_xstart; ji <= internal_xstop; ji++)\n  {\n    continuity_code(ji, jj, width, ssha_t, sshn_t, sshn_u, sshn_v, hu, hv, un, vn, rdt, area_t);\n    bc_ssh_code(ji, jj, width, istep, ssha_t, tmask, rdt);\n    momentum_u_code(ji, jj, width, ua, un, vn, hu, hv, ht, ssha_u, sshn_t, sshn_u, sshn_v, tmask, dx_u, dx_v, dx_t, dy_u, dy_t, area_u, gphiu, rdt, cbfr, visc, omega, d2r, g);\n    momentum_v_code(ji, jj, width, va, un, vn, hu, hv, ht, ssha_v, sshn_t, sshn_u, sshn_v, tmask, dx_v, dx_t, dy_u, dy_v, dy_t, area_v, gphiv, rdt, cbfr, visc, omega, d2r, g);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_ompopt/0"}
{"code": "for (int v = 0; v < g->n; v++)\n{\n  int cap = residualFlow[IDX(s, v, g->n)];\n  if ((cap > 0) && (s != v))\n  {\n    residualFlow[IDX(s, v, g->n)] = 0;\n    residualFlow[IDX(v, s, g->n)] += cap;\n    netFlowOutS += cap;\n    excessFlow[v] = cap;\n    if (v == t)\n    {\n      netFlowInT += cap;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:netFlowOutS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    qT[(j * n) + i] = q[(i * n) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/first-steps/omp-matmul/1"}
{"code": "for (int i = 0; i < 32; ++i)\n{\n  out[i] = (in >> i) & 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/grn/sw/src/main/0"}
{"code": "for (unsigned int i = 0; i < size; i++)\n{\n  x[i] += dt * s[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo1a/solver/2"}
{"code": "for (i = 0; i < 512; i++)\n{\n  tmp[i] = 0;\n  int j;\n  for (j = 0; j < 512; j++)\n  {\n    tmp[i] = tmp[i] + (A[(i * 512) + j] * x[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/21"}
{"code": "for (i; i < tamano; i++)\n{\n  vector[i] = 1 + (rand() % 20);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dranys/Taller1-OpenMP/saxpy_par/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxy[(3 * j) + (3 * kj)] = at2 * zt1;\n    fxy[(1 + (3 * j)) + (3 * kj)] = at3 * zt1;\n    fxy[(2 + (3 * j)) + (3 * kj)] = zero;\n    fxy[(3 * j) + (3 * k1)] = at2 * zt2;\n    fxy[(1 + (3 * j)) + (3 * k1)] = (-at3) * zt2;\n    fxy[(2 + (3 * j)) + (3 * k1)] = zero;\n    wp += at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n  }\n\n  at1 = crealf(ffc[kk]) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = cimagf(q[kj]) - (crealf(q[kj]) * _Complex_I);\n  fxy[3 * kj] = zero;\n  fxy[1 + (3 * kj)] = at3 * zt1;\n  fxy[2 + (3 * kj)] = zero;\n  fxy[3 * k1] = zero;\n  fxy[1 + (3 * k1)] = zero;\n  fxy[2 + (3 * k1)] = zero;\n  wp += at1 * (q[kj] * conjf(q[kj]));\n  sum1 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/8"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, sizeof(float), cols * bands, fnoise);\n  for (j = 0; j < bands; j++)\n  {\n    for (k = 0; k < cols; k++)\n    {\n      if (buffer[(j * cols) + k] != nvalue)\n      {\n        sum[j] += buffer[(j * cols) + k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/5"}
{"code": "for (i = 0; i <= total; i++)\n  sum0 = sum0 + i;\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/reduction/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n  lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n  lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n  lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n  lhs[0][i][j][k + 1] = lhs[0][i][j][k + 1] + comz1;\n  lhs[1][i][j][k + 1] = lhs[1][i][j][k + 1] - comz4;\n  lhs[2][i][j][k + 1] = lhs[2][i][j][k + 1] + comz5;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,comz1 ,k ,comz4 ,comz6 ,comz5 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/78"}
{"code": "for (j = 0; j < _PB_M; j++)\n{\n  stddev[j] = 0.0;\n  for (i = 0; i < _PB_N; i++)\n    stddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\n\n  stddev[j] /= float_n;\n  stddev[j] = sqrt(stddev[j]);\n  stddev[j] = (stddev[j] <= eps) ? (1.0) : (stddev[j]);\n}\n\n", "pragma": "omp for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/datamining/correlation/correlation/1"}
{"code": "for (i = 0; i < n; i++)\n  z[i] = sqrtf(c[i]);\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Fazendaaa/openmp_tutorial/src/no_wait_2/1"}
{"code": "for (i = 2; i <= till; i++)\n{\n  arr[i * myPrime] = 1;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulgurnani/parallel-seive/eseive/0"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (arr[j] > arr[j + 1])\n    {\n      int temp;\n      temp = arr[j];\n      arr[j] = arr[j + 1];\n      arr[j + 1] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Srinidi-V/openmp/bubble/0"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < n1; i1++)\n    {\n      u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n      u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      r[i3][i2][i1] = ((v[i3][i2][i1] - (a[0] * u[i3][i2][i1])) - (a[2] * ((u2[i1] + u1[i1 - 1]) + u1[i1 + 1]))) - (a[3] * (u2[i1 - 1] + u2[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/11"}
{"code": "for (i = 0; i < LIFE_NUM; i++)\n{\n  row = rand() % MAXROW;\n  col = rand() % MAXROW;\n  if ((((0 <= row) && (row < MAXROW)) && (0 <= col)) && (col < MAXCOL))\n  {\n    map[row][col] = ALIVE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"Game of Life\" with OpenMP/3"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  printf(\"[%d] \", pos->_Cases[1][i * 16]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/3"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/10"}
{"code": "for (y = 1; y < (rows - 1); y++)\n{\n  for (x = 1; x < (columns - 1); x++)\n  {\n    printf(\"%c\", grid[y][x]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp/6"}
{"code": "for (gridpoint[0] = lower[0], u = 0; u < tot_ev_per_dim[0]; gridpoint[0] += dx[0], u++)\n{\n  __assume_aligned(densValues, 64);\n  __assume_aligned(densPosition, 64);\n  double temp;\n  dif_pos[0] = (gridpoint[0] - x0[0]) / dx[0];\n  for (v = 0; v < tot_ev_per_dim[1]; v++)\n  {\n    gridpoint[1] = lower[1] + (dx[1] * v);\n    for (d = 0; d < dim; d++)\n      PCdot_vec[d] = 0;\n\n    for (d = 0; d < dim; d++)\n    {\n      #pragma simd reduction(+:PCdot_vec[d]) assert\n      for (l = 0; l < dim; l++)\n        PCdot_vec[d] += eigenvectors->me[d][l] * gridpoint[l];\n\n    }\n\n    temp = 0;\n    #pragma simd reduction(+:temp) assert\n    for (d = 0; d < dim; d++)\n      temp += (PC[d] - PCdot_vec[d]) * (PC[d] - PCdot_vec[d]);\n\n    temp /= h2;\n    dif_pos[1] = (gridpoint[1] - x0[1]) / dx[1];\n    *PDFitem(pdf, dif_pos, dim) += (((0.5 / cd) * (dim + 2.)) * (1. - temp)) * (fabs(temp) < 1.);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/11"}
{"code": "for (iterator it_1 = block.begin(); it_1 != block.end(); it_1++)\n{\n  for (iterator it_2 = block.begin(); it_2 != block.end(); it_2++)\n  {\n    apply_force(particles[*it_1], particles[*it_2], &dmin, &davg, &navg);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xingyousong/Parallelized-Particle-Simulation-CS267-HW2/serial/0"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (j = jst; j < ny; j++)\n    {\n      tmp = rho_i[k][j][i];\n      u21j = tmp * u[1][k][j][i];\n      u31j = tmp * u[2][k][j][i];\n      u41j = tmp * u[3][k][j][i];\n      u51j = tmp * u[4][k][j][i];\n      tmp = rho_i[k][j - 1][i];\n      u21jm1 = tmp * u[1][k][j - 1][i];\n      u31jm1 = tmp * u[2][k][j - 1][i];\n      u41jm1 = tmp * u[3][k][j - 1][i];\n      u51jm1 = tmp * u[4][k][j - 1][i];\n      flux_G[1][k][i][j] = ty3 * (u21j - u21jm1);\n      flux_G[2][k][i][j] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux_G[3][k][i][j] = ty3 * (u41j - u41jm1);\n      flux_G[4][k][i][j] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/rhs/9"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  for (j = 0; j < num_steps; j++)\n  {\n    for (k = 0; k < num_steps; k++)\n    {\n      x = (((i + j) + k) + 0.5) * step;\n      sum = sum + sin(tan(log(abs(sin(cos(x + 20.0) + 2.0) + 3.0) + 4.0)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter1/hl/0"}
{"code": "for (i = 0; i < sizeOfTableOutput; ++i)\n{\n  nbErrorFind[i] = 0;\n}\n\n", "pragma": "omp for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/15"}
{"code": "for (i = deb1; i <= fin1; i++)\n{\n  table1[i - deb1] = T[i];\n}\n\n", "pragma": "omp parallel for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/mergesort/0"}
{"code": "for (int row = 0; row < m; row++)\n{\n  for (int col = 0; col < n; col++)\n  {\n    mat[row][col] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/par_matrix_vect_mul/0"}
{"code": "for (i = 0; i < ((int) n_b); i++)\n{\n  result[i] = (*a) + b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/14"}
{"code": "for (size_t i = 0; i < LPFOrderOther.size(); i++)\n{\n  if (LPFOrderOther[i][index] > 0)\n    return true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/26"}
{"code": "for (int i = 0; i < exe.length(); i++)\n{\n  if (exe[i] == '\\\\')\n  {\n    pos = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/17"}
{"code": "for (int i = 1; i <= num_threads; i++)\n{\n  omp_set_num_threads(i);\n  start_time = omp_get_wtime();\n  for (int j = 0; j < 100; j++)\n    v_add(x, y, z);\n\n  run_time = omp_get_wtime() - start_time;\n  printf(\" %d thread(s) took %f seconds\\n\", i, run_time);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kishkaru/OpenMP_Demos/OpenMP/vadd_OmpFor/4"}
{"code": "for (i = 0; i < total_bins; i++)\n{\n  if (avg_values_2d[i][8] == 0)\n  {\n    (rebin_ph + i)->type = COMPTONIZED_PHOTON;\n    (rebin_ph + i)->p0 = 1;\n    (rebin_ph + i)->p1 = 0;\n    (rebin_ph + i)->p2 = 0;\n    (rebin_ph + i)->p3 = 0;\n    (rebin_ph + i)->comv_p0 = 0;\n    (rebin_ph + i)->comv_p1 = 0;\n    (rebin_ph + i)->comv_p2 = 0;\n    (rebin_ph + i)->comv_p3 = 0;\n    (rebin_ph + i)->r0 = 0;\n    (rebin_ph + i)->r1 = 0;\n    (rebin_ph + i)->r2 = 0;\n    (rebin_ph + i)->s0 = 1;\n    (rebin_ph + i)->s1 = 0;\n    (rebin_ph + i)->s2 = 0;\n    (rebin_ph + i)->s3 = 0;\n    (rebin_ph + i)->num_scatt = 0;\n    (rebin_ph + i)->weight = 0;\n    (rebin_ph + i)->nearest_block_index = -1;\n    count_weight += (rebin_ph + i)->weight;\n  }\n  else\n  {\n    energy = avg_values_2d[i][11] / avg_values_2d[i][8];\n    phi = avg_values_2d[i][9] / avg_values_2d[i][8];\n    theta = avg_values_2d[i][10] / avg_values_2d[i][8];\n    (rebin_ph + i)->type = COMPTONIZED_PHOTON;\n    (rebin_ph + i)->p0 = energy;\n    (rebin_ph + i)->p1 = (energy * sin((theta * M_PI) / 180)) * cos((phi * M_PI) / 180);\n    (rebin_ph + i)->p2 = (energy * sin((theta * M_PI) / 180)) * sin((phi * M_PI) / 180);\n    (rebin_ph + i)->p3 = energy * cos((theta * M_PI) / 180);\n    (rebin_ph + i)->comv_p0 = 0;\n    (rebin_ph + i)->comv_p1 = 0;\n    (rebin_ph + i)->comv_p2 = 0;\n    (rebin_ph + i)->comv_p3 = 0;\n    rand1 = (M_PI / 180) * (avg_values_2d[i][12] / avg_values_2d[i][8]);\n    (rebin_ph + i)->r0 = ((avg_values_2d[i][0] / avg_values_2d[i][8]) * sin(avg_values_2d[i][1] / avg_values_2d[i][8])) * cos(rand1);\n    (rebin_ph + i)->r1 = ((avg_values_2d[i][0] / avg_values_2d[i][8]) * sin(avg_values_2d[i][1] / avg_values_2d[i][8])) * sin(rand1);\n    (rebin_ph + i)->r2 = (avg_values_2d[i][0] / avg_values_2d[i][8]) * cos(avg_values_2d[i][1] / avg_values_2d[i][8]);\n    (rebin_ph + i)->s0 = avg_values_2d[i][3] / avg_values_2d[i][8];\n    (rebin_ph + i)->s1 = avg_values_2d[i][4] / avg_values_2d[i][8];\n    (rebin_ph + i)->s2 = avg_values_2d[i][5] / avg_values_2d[i][8];\n    (rebin_ph + i)->s3 = avg_values_2d[i][6] / avg_values_2d[i][8];\n    (rebin_ph + i)->num_scatt = avg_values_2d[i][7] / avg_values_2d[i][8];\n    (rebin_ph + i)->weight = avg_values_2d[i][8];\n    (rebin_ph + i)->nearest_block_index = 0;\n    count_weight += (rebin_ph + i)->weight;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/8"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 1; j < m; j++)\n  printf(\"%lf\\n\", b[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB037-truedepseconddimension-orig-yes/2"}
{"code": "for (int i = 0; i <= SZ; ++i)\n{\n  omp_destroy_nest_lock(&lck[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/likecs/Concurrent-Bloom-Filters/bloom-n-par/3"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%d \", particleBC[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/127"}
{"code": "for (int i = 0; i < to_solve->n; i++)\n{\n  free(plays->grid[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/bin/sudoku-omp_bfsv1/0"}
{"code": "for (i = 0; i < intervals; i++)\n{\n  x = (i + 0.5) * width;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for reduction(+:sum) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/S3/opi/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  int idx = bucketsOffsets[i];\n  for (j = 0; j < buckets[i].len; j++)\n  {\n    array[idx] = buckets[i].elems[j];\n    idx++;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg2/6"}
{"code": "for (i = 0; i < local_n0; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n{\n  const int z = ((((i * N) + j) * 2) * Nf) + k;\n  U_tmp[z] = ((V[z] * CW[z]) - (W[z] * CV[z])) + Fx[z];\n  V_tmp[z] = ((W[z] * CU[z]) - (U[z] * CW[z])) + Fy[z];\n  W_tmp[z] = ((U[z] * CV[z]) - (V[z] * CU[z])) + Fz[z];\n}\n\n\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/7"}
{"code": "for (size_t i = 0; i < kernel_size; i++)\n  kernel[i] = (unsigned char) (256 * LCG_random_double(&seed));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/car-omp/main/1"}
{"code": "for (int i = 0; i < loops; i++)\n{\n  n_cores = jac_mp_v3(N, delta, d, max_iter, f, u, u_old);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anderslaunerbaek/HPC/projects/assign_2/main_jac_mp_v3/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x[i] = value;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/2"}
{"code": "for (i = 0; i < w; i++)\n{\n  for (j = 0; j < h; j++)\n  {\n    printf(\"%d\", (M[k][i + (w * j)]) ? (1) : (0));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpolitzer/life/omp/3"}
{"code": "for (size_t p = 0; p < p3Dnpts; p++)\n{\n  for (size_t m = 0; m < nmo; m++)\n  {\n    if (m < nocc)\n      m_o[(p * nocc) + m] = mcgto[(p * nmo) + m];\n    else\n    {\n      pos = m - nocc;\n      m_v[(p * nvirt) + pos] = mcgto[(p * nmo) + m];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/methods/do_qmp2/1"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    E[(i * 128) + j] = 0.0;\n    for (k = 0; k < 128; ++k)\n    {\n      E[(i * 128) + j] += C[(i * 128) + k] * D[(k * 128) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/25"}
{"code": "for (i = 1; i < stopwave; i++)\n{\n  if ((wavelen[i - 1] >= 7.5) && (wavelen[i] < 7.5))\n  {\n    stopFinWave = i - 1;\n  }\n\n  if ((wavelen[i - 1] >= 12.5) && (wavelen[i] < 12.5))\n  {\n    startFinWave = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/17"}
{"code": "for (int i = 3; i < n; i++)\n{\n  if (i == methood(i))\n  {\n    sum += i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex34projecteuler/2"}
{"code": "for (int j = 0; j < x_points; j++)\n{\n  p_new[0][j] = p_new[1][j];\n  p_new[y_points - 1][j] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Cavity Flow/2-D_Cavity_Flow/main/6"}
{"code": "for (i = 0; i < 32768; i++)\n{\n  y[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/11"}
{"code": "for (i = 0; i < numOfPoints; ++i)\n{\n  const double *point = getPointAtLocation(points, i);\n  classified[i] = discFunction(point, W, *w0, k);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roteml8/binary_classification/BinaryClassifier/3"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  for (int j = i * 16; j < ((i * 16) + 16); ++j)\n  {\n    buffer[j] = i;\n  }\n\n  MPIX_Pready(i, &r);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tudasc/CommPart/lib/check_impl/0"}
{"code": "for (long i = 0; i < N; i++)\n{\n  printf(\"thread num: %d\\n\", 0);\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomcz/openmp-tries/src/vectors/1"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  maxtf = fabs(rowval[rowptr[i]]);\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    maxtf = (maxtf < fabs(rowval[j])) ? (fabs(rowval[j])) : (maxtf);\n  }\n\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    rowval[j] = .5 + ((.5 * rowval[j]) / maxtf);\n  }\n\n}\n\n", "pragma": "omp for private(j, maxtf) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/4"}
{"code": "for (int i = 1; i < (y_points - 1); i++)\n{\n  for (int j = 1; j < (x_points - 1); j++)\n  {\n    p_new[i][j] = (((del_y * del_y) * (p[i][j + 1] + p[i][j - 1])) + ((del_x * del_x) * (p[i + 1][j] + p[i - 1][j]))) / (2 * ((del_x * del_x) + (del_y * del_y)));\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Laplace Equation/2-D_Laplace_Equation/main/3"}
{"code": "for (j = 0; j < 20; j++)\n  a[i][j] = (i * 20) + j;\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB053-inneronly1-orig-no/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 27) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    INT_TYPE test_rank = test_rank_array[i];\n    int failed = 0;\n    switch (CLASS)\n    {\n      case 'S':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'W':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n        test_rank += iteration - 1;\n      else\n        test_rank -= iteration - 1;\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'D':\n        if (i < 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'E':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        if (i == 2)\n      {\n        test_rank += iteration - 2;\n        if (iteration > 4)\n          test_rank -= 2;\n        else\n          if (iteration > 2)\n          test_rank -= 1;\n\n\n      }\n      else\n        test_rank -= iteration - 2;\n\n\n        break;\n\n    }\n\n    if (key_rank != test_rank)\n      failed = 1;\n    else\n      passed_verification++;\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/18"}
{"code": "for (int i = 0; i < intervals.divisions; i++)\n{\n  pthread_join(thds[i], &res);\n  *total += *((double *) res);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fol21/parallel-adaptative_quadrature/src/adaptative-quadrature/1"}
{"code": "for (int i = 0; i < ((stringExample.length() - substringExample.length()) + 1); i++)\n{\n  int count = 0;\n  for (int j = 0; j < substringExample.length(); j++)\n  {\n    if (stringExample[i + j] != substringExample[j])\n    {\n      break;\n    }\n\n    count++;\n  }\n\n  if (count == substringExample.length())\n  {\n    result1 = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_7/7/0"}
{"code": "for (int col = k; col < size; col++)\n  U[row][col] = U[row][col] - (L[row][k] * U[k][col]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/5"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  density *= root / ((double) tt->dims[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/2"}
{"code": "for (i = 0; i < nd; i++)\n{\n  for (j = 0; j < np; j++)\n  {\n    pos[(i * nppaddded) + j] = box[i] * r8_uniform_01(seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MD/md_openmp/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a = omp_get_thread_num();\n  (rand() % 11) + 10;\n  printf(\"Thread %d a=%d\\n\", omp_get_thread_num(), a);\n}\n\n", "pragma": "omp parallel for lastprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7/2"}
{"code": "for (y_act = 0; y_act < H; y_act++)\n{\n  for (x_act = 0; x_act < W; x_act++)\n  {\n    fwrite(pixels[(y_act * W) + x_act], 1, sizeof(pixel_t), fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rochii/parallel-mandelbrot/openmp/scripts/mandelbrot_openmp/1"}
{"code": "for (j = 0; j < count; j++)\n{\n  pbkdf2_sha1((const unsigned char *) in[j].v, in[j].length, salt->essid, salt->length, 4096, (unsigned char *) (&out[j]), 32, 0);\n}\n\n", "pragma": "omp parallel for default(none) private(j) shared(count, salt, in, out)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/wpapsk_fmt_plug/0"}
{"code": "for (size_t i = 0; i < last_step.bodies().size(); i++)\n{\n  new_bodies[i] = update_body(last_step.bodies()[i], *quadtree, dt, G, theta);\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(last_step, new_bodies, quadtree, dt, G, theta)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andreastedile/barnes-hut/simulators/barnes-hut-simulator/src/barnes_hut_simulator/0"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  for (int i = 0; i < 1000000; i++)\n  {\n    randomnumber = rand() % 6;\n    dnabig[i] = dna[randomnumber];\n  }\n\n  replacecharacters(dnabig);\n  countA(dnabig);\n  end = clock();\n  total_time = ((double) (end - start)) / CLOCKS_PER_SEC;\n  nStatic1[j] = total_time;\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/0"}
{"code": "for (i = 2; i < 500; i += 500 / 250)\n{\n  init(i, a, b_cpu);\n  Crout_CPU(i, a, b_cpu);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/lu-decomposition/src/lu-decomposition_gpu/4"}
{"code": "for (j = 0; j < n; ++j)\n{\n  if ((!m[j]) && ((min.l + a[(j * n) + min.u]) < l[j]))\n    l[j] = min.l + a[(j * n) + min.u];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scott50301/Dijkstra-s-Algorithm-MPI-OpenMP-/dijkstra_omp/2"}
{"code": "for (k = 0; k < dims[2]; k++)\n{\n  x0 = starts[k];\n  for (j = 0; j < dims[1]; j++)\n  {\n    vranlc(2 * NX, &x0, A, (double *) (&u0[k][j][0]));\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(k,j,x0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/7"}
{"code": "for (i = 0; i < rows; i++)\n{\n  printf(\"|\");\n  for (j = 0; j < columns; j++)\n  {\n    char symbol;\n    if (trails[(((int) i) * columns) + ((int) j)] != (-1))\n      printf(\"%7d\", trails[(((int) i) * columns) + ((int) j)]);\n    else\n      printf(\"       \", trails[(((int) i) * columns) + ((int) j)]);\n\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/13"}
{"code": "for (j = 0; j < n; j++)\n{\n  sum += sigma[(i * n) + j] * u[j];\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kpetrakis/OpenMP-Project/lif1d_omp3/0"}
{"code": "for (i = 0; i < num_elements; i++)\n  vector_a[i] = vector_a[i] + vector_b[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Vector sum/vector_sum/0"}
{"code": "for (int i = 0; i < blocksize; i++)\n{\n  L[i + row_start][i + column_start] = 1;\n  for (int j = 0; j < blocksize; j++)\n  {\n    if (j >= i)\n    {\n      U[i + row_start][j + column_start] = A[i + row_start][j + column_start];\n    }\n    else\n    {\n      L[i + row_start][j + column_start] = A[i + row_start][j + column_start];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q3/7"}
{"code": "for (i = 0; i < n; ++i)\n{\n  m = rand() % 1000;\n  fprintf(fptr, \"%f \", m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_1/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n  for (int j = 0; j < 10; ++j)\n  {\n    if (a[i] > b[j])\n      break;\n\n  }\n\n  switch (i)\n  {\n    case 1:\n      b[i]++;\n      break;\n\n    default:\n      break;\n\n  }\n\n  if (c[i] > 10)\n    break;\n\n  if (c[i] > 11)\n    break;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/50"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i)\n{\n  pred_win.add_request(((i - i_start) * 2) + 0, edge_owner[((i - i_start) * 2) + 0], edge_local[((i - i_start) * 2) + 0], ((i - i_start) * 2) + 0);\n  pred_win.add_request(((i - i_start) * 2) + 1, edge_owner[((i - i_start) * 2) + 1], edge_local[((i - i_start) * 2) + 1], ((i - i_start) * 2) + 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/validate/4"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    potential_diff_array[i][j] = potential_new_array[i][j] - potential_exact_array[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MRLintern/2D_Poisson_Equation_OpenMP/poisson/4"}
{"code": "for (int i = 0; i < 35; i++)\n{\n  printf(\"-\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/value-of-pi/value-of-pie-random-generator/1"}
{"code": "for (i = 0; (i < 20) && (i < num); ++i)\n{\n  if ((Team[i].task.thread_id == team_thread_id) && (Team[i].team_flag == 1))\n  {\n    task = Team[i].itask[thread_num];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaodao90/wrapper/OpenMP/OMP_wrapper/4"}
{"code": "for (index = 0; index < tot_todo; index += inc)\n{\n  {\n    int i;\n    int len = saved_len[index];\n    char *pass = saved_key[index];\n    switch (cur_salt->type)\n    {\n      case 5:\n      {\n        MD5_CTX ctx;\n        MD5_Init(&ctx);\n        MD5_Update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          MD5_Update(&ctx, pass, len);\n\n        MD5_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 256:\n      {\n        SHA256_CTX ctx;\n        SHA256_Init(&ctx);\n        SHA256_Update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          SHA256_Update(&ctx, pass, len);\n\n        SHA256_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 512:\n      {\n        SHA512_CTX ctx;\n        SHA512_Init(&ctx);\n        SHA512_Update(&ctx, cur_salt->salt, cur_salt->len);\n        if ((len && ((128 % len) == 0)) && ((cur_salt->len + (len * cur_salt->rounds)) > 256))\n        {\n          int ex;\n          for (i = 0; i <= cur_salt->rounds; ++i)\n          {\n            SHA512_Update(&ctx, pass, len);\n            if (ctx.total > (128 + cur_salt->len))\n              break;\n\n          }\n\n          ++i;\n          ex = (256 - ctx.total) / len;\n          i += ex;\n          ctx.total += ex * len;\n          jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n          while ((i + (128 / len)) <= cur_salt->rounds)\n          {\n            ctx.total += 128;\n            jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n            i += 128 / len;\n          }\n\n          for (; i <= cur_salt->rounds; ++i)\n            ctx.total += len;\n\n        }\n        else\n        {\n          for (i = 0; i <= cur_salt->rounds; ++i)\n            SHA512_Update(&ctx, pass, len);\n\n        }\n\n        ctx.bIsQnxBuggy = 1;\n        SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n    }\n\n  }\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/qnx_fmt_plug/0"}
{"code": "for (i = 0; i < NSTEPS; i++)\n{\n  printf(\"step: %d\\n\", i);\n  compute(NPARTS, 3, position, velocity, mass, force, &potential, &kinetic);\n  update(NPARTS, 3, position, velocity, force, accel, mass, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zygyz/romp/tests/OmpSCR_v2.0/applications/c_MolecularDynamic/c_md/0"}
{"code": "for (int i = 5; i < 16; i = baz(&i) + i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/54"}
{"code": "for (v = 0; v < G->numNodes; v++)\n{\n  edge_t u_idx;\n  localClustering[v] = 0;\n  for (u_idx = G->begin[v]; u_idx < G->begin[v + 1]; u_idx++)\n  {\n    node_t u = G->node_idx[u_idx];\n    edge_t w_idx;\n    for (w_idx = u_idx + 1; w_idx < G->begin[v + 1]; w_idx++)\n    {\n      node_t w = G->node_idx[w_idx];\n      if (isNeighbour(G, w, u))\n      {\n        localClustering[v] += 1;\n      }\n\n      if (isNeighbour(G, u, w))\n      {\n        localClustering[v] += 1;\n      }\n\n    }\n\n  }\n\n  int neighbours = (int) (G->begin[v + 1] - G->begin[v]);\n  if (neighbours > 1)\n  {\n    localClustering[v] = localClustering[v] / (neighbours * (neighbours - 1));\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/util/graphprop/1"}
{"code": "for (int i = 100; i >= 0; i -= 2)\n{\n  num_its_executed_in_a_chunk++;\n  assert(num_its_executed_in_a_chunk <= CHUNKSIZE);\n}\n\n", "pragma": "omp for schedule(dynamic, CHUNKSIZE) firstprivate(num_its_executed_in_a_chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_ompss.dg/c/success_for_slicer_07/0"}
{"code": "for (i = 0; i < 1024; ++i)\n{\n  OMPVV_TEST_AND_SET(errors, a[i] != 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_map_from/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (x[i] != 0.0)\n  {\n    absxi = fabs(x[i]);\n    if (scale < absxi)\n    {\n      ssq = 1.0 + (ssq * pow(scale / absxi, 2));\n      scale = absxi;\n    }\n    else\n    {\n      ssq = ssq + pow(absxi / scale, 2);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/norm2_noowr/main/1"}
{"code": "for (i = 0; i < n_estimators; i++)\n{\n  totalRows = maxNodesTree[i] + totalRows;\n}\n\n", "pragma": "omp parallel for firstprivate(maxNodesTree) reduction(+:totalRows)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/0"}
{"code": "for (int i = 1; i < (eq_Nx - 1); i++)\n{\n  eq_inv_m[i * eq_Nx] = (-eq_inv_m[(i * eq_Nx) + 1]) * eq_Aa;\n  eq_inv_m[((i * eq_Nx) + eq_Nx) - 1] = (-eq_inv_m[((i * eq_Nx) + eq_Nx) - 2]) * eq_Aa;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/14"}
{"code": "for (j = size; j < (height - size); j++)\n{\n  for (k = size; k < (width - size); k++)\n  {\n    if ((j < ((height / 10) - size)) || (j >= ((height * 0.9) + size)))\n    {\n      int stencil_j;\n      int stencil_k;\n      int t_r = 0;\n      int t_g = 0;\n      int t_b = 0;\n      for (stencil_j = -size; stencil_j <= size; stencil_j++)\n      {\n        for (stencil_k = -size; stencil_k <= size; stencil_k++)\n        {\n          t_r += pi[((j + stencil_j) * width) + (k + stencil_k)].r;\n          t_g += pi[((j + stencil_j) * width) + (k + stencil_k)].g;\n          t_b += pi[((j + stencil_j) * width) + (k + stencil_k)].b;\n        }\n\n      }\n\n      new[(j * width) + k].r = t_r / (((2 * size) + 1) * ((2 * size) + 1));\n      new[(j * width) + k].g = t_g / (((2 * size) + 1) * ((2 * size) + 1));\n      new[(j * width) + k].b = t_b / (((2 * size) + 1) * ((2 * size) + 1));\n    }\n    else\n    {\n      new[(j * width) + k].r = pi[(j * width) + k].r;\n      new[(j * width) + k].g = pi[(j * width) + k].g;\n      new[(j * width) + k].b = pi[(j * width) + k].b;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic, width)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/blur_filter/0"}
{"code": "for (i = 0; i < len2; i++)\n{\n  scoringMatrix[i] = (float *) calloc(len1, sizeof(float));\n  sumMatrix[i] = (float *) calloc(len1, sizeof(float));\n  if ((scoringMatrix[i] == 0) || (sumMatrix[i] == 0))\n  {\n    printf(\"ERROR during scoringMatrix[%d]/sumMatrix[%d] memory allocating!\\n\", i, i);\n    return seq2Result;\n  }\n\n  for (j = 1; j < i; j++)\n    scoringMatrix[i][j] = penalty;\n\n  for (j = i; j <= (maxN + i); j++)\n    scoringMatrix[i][j] = computePairwiseComparison(seq1[j - 1], seq2[i - 1], weights);\n\n}\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/ompFunctions/3"}
{"code": "for (int i = 0; i < kernel.width; i++)\n{\n  kernel1[i] = kernel.pixels[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/4"}
{"code": "for (j = 0; j < 4; j++)\n  for (i = jll; i < kll; i++)\n  for (k = 0; k < 5; k += 2)\n  l++;\n\n\n\n", "pragma": "omp for reduction(+: l) collapse(3)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/11"}
{"code": "for (int i = 0; i < dim.rows; i++)\n  free(grid.cells[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/7"}
{"code": "for (int v = 0; v < 8; v++)\n{\n  const int n1 = i + VOISINS[v][0];\n  const int n2 = j + VOISINS[v][1];\n  CHECK((((n1 >= 0) && (n1 < nrows)) && (n2 >= 0)) && (n2 < ncols));\n  if (Wprec[(n1 * ncols) + n2] == m->no_data)\n    continue;\n\n  CHECK(TERRAIN(m, i, j) > m->no_data);\n  CHECK(Wprec[(i * ncols) + j] > m->no_data);\n  CHECK(Wprec[(n1 * ncols) + n2] > m->no_data);\n  const float Wn = Wprec[(n1 * ncols) + n2] + EPSILON;\n  if (TERRAIN(m, i, j) >= Wn)\n  {\n    W[(i * ncols) + j] = TERRAIN(m, i, j);\n    modif = 1;\n    if (W[(i * ncols) + j] < min_darboux)\n      min_darboux = W[(i * ncols) + j];\n\n  }\n  else\n    if (Wprec[(i * ncols) + j] > Wn)\n  {\n    W[(i * ncols) + j] = Wn;\n    modif = 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/darboux/5"}
{"code": "for (j = 0; j <= 99; j += 1)\n{\n  b[i][j] = b[i][j] + 1;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB113-default-orig-no/3"}
{"code": "for (int col = 0; col < (row - 1); col++)\n{\n  num_threads = omp_get_num_threads();\n  if (col != row)\n  {\n    sum = sum + (A[row][col] * x[col]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+:sum) firstprivate (row, A)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/7/Gauss_Siedel/main/0"}
{"code": "for (i = 0; i < no_of_vertices; i++)\n{\n  last[i] = pagerank[i];\n  pagerank[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham166/pagerank-clusters/02.openmp_implementaion/pagerank/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  (h_file << \"  \") << h[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/heat-mpi/3"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  sOldCsizes[i] = parray[i].size();\n  if (i != me)\n  {\n    MPI_Irecv(&rOldCsizes[i], 1, MPI_GRAPH_TYPE, i, 4, MPI_COMM_WORLD, &rOldCszreqs[i]);\n    MPI_Isend(&sOldCsizes[i], 1, MPI_GRAPH_TYPE, i, 4, MPI_COMM_WORLD, &sOldCszreqs[i]);\n  }\n  else\n  {\n    rOldCszreqs[i] = MPI_REQUEST_NULL;\n    sOldCszreqs[i] = MPI_REQUEST_NULL;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/rebuild/2"}
{"code": "for (i = 2; i < (N - 2); ++i)\n{\n  cur[i] = ((((prev[i - 2] + prev[i - 1]) + prev[i]) + prev[i + 1]) + prev[i + 2]) / 5;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshtburris/CS-475-PA1/stencil_1D/0"}
{"code": "for (int i = 0; i < sumLen; i++)\n{\n  if (indexA >= lenA)\n  {\n    totalAr[i] = arrB[indexB];\n    indexB++;\n  }\n  else\n    if (indexB >= lenB)\n  {\n    totalAr[i] = arrA[indexA];\n    indexA++;\n  }\n  else\n  {\n    if (arrA[indexA] <= arrB[indexB])\n    {\n      totalAr[i] = arrA[indexA];\n      indexA++;\n    }\n    else\n    {\n      totalAr[i] = arrB[indexB];\n      indexB++;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/mergeSort/3"}
{"code": "for (int depth = start_y; depth < end_y; depth++)\n{\n  for (int row = 0; row < boundary_length; row++)\n  {\n    for (int column = start_x; column < end_x; column++)\n    {\n      property_array[((depth * nz_nx) + ((start_z + row) * nx)) + column] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp  parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/HomogenousExtension/5"}
{"code": "for (i = 0; i < num_iters; ++i)\n  printf(\"final_iters[%d] = %d\\n\", i, final_iters[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/worksharing/for/omp_for_static_large_chunk/3"}
{"code": "for (i = 0; i < 16384; i++)\n{\n  for (j = 0; j < 16384; j++)\n  {\n    x2[i] = x2[i] + (a[(j * 16384) + i] * y2[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/MVT/mvt/1"}
{"code": "for (c2 = nm; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/64"}
{"code": "for (; i < ie; i++)\n{\n  Add(data()[i], vec1.data()[i], 0.0, (-1) * vec2.hi[i], (-1) * vec2.lo[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_sub_d/1"}
{"code": "for (itr = 0; itr < itrMax; itr++)\n{\n  if ((itr % NPRINT) == 0)\n  {\n    ((cout << \"===================================================\") << endl) << endl;\n    (((cout << \" \tFIRE MINIMIZATION, itr = \") << itr) << endl) << endl;\n    (cout << \"===================================================\") << endl;\n    if (packingPrintObject.is_open())\n    {\n      (cout << \"\t* Printing SP center positions to file\") << endl;\n      printSystemPositions();\n    }\n\n    if (energyPrintObject.is_open())\n    {\n      (cout << \"\t* Printing SP energy to file\") << endl;\n      printSystemEnergy();\n    }\n\n    (cout << \"\t* Run data:\") << endl;\n    ((cout << \"\t* K \t\t= \") << K) << endl;\n    ((cout << \"\t* F \t\t= \") << F) << endl;\n    ((cout << \"\t* phi \t\t= \") << phi) << endl;\n    ((cout << \"\t* dt \t\t= \") << dt) << endl;\n    ((cout << \"\t* alpha \t= \") << alpha) << endl;\n    (cout << endl) << endl;\n  }\n\n  P = 0.0;\n  vstarnrm = 0.0;\n  fstarnrm = 0.0;\n  for (ci = 0; ci < NCELLS; ci++)\n  {\n    for (d = 0; d < NDIM; d++)\n    {\n      ftmp = cell(ci).cforce(d);\n      vtmp = cell(ci).cvel(d);\n      P += ftmp * vtmp;\n      vstarnrm += vtmp * vtmp;\n      fstarnrm += ftmp * ftmp;\n    }\n\n  }\n\n  vstarnrm = sqrt(vstarnrm);\n  fstarnrm = sqrt(fstarnrm);\n  if (P > 0)\n  {\n    npPos++;\n    npNeg = 0;\n    alphat = alpha;\n    if (npPos > NMIN)\n    {\n      if ((dt * finc) < dtmax)\n        dt *= finc;\n      else\n        dt = dtmax;\n\n      alpha *= falpha;\n    }\n\n  }\n  else\n  {\n    npPos = 0;\n    npNeg++;\n    if (npNeg > NNEGMAX)\n      break;\n\n    if (itr > NMIN)\n    {\n      if ((dt * fdec) > dtmin)\n        dt *= fdec;\n      else\n        dt = dtmin;\n\n      alpha = alpha0;\n      alphat = alpha;\n    }\n\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (d = 0; d < NDIM; d++)\n        cell(ci).setCPos(d, cell(ci).cpos(d) - ((0.5 * dt) * cell(ci).cvel(d)));\n\n    }\n\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (d = 0; d < NDIM; d++)\n        cell(ci).setCVel(d, 0.0);\n\n    }\n\n  }\n\n  if (fstarnrm > 0)\n  {\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (d = 0; d < NDIM; d++)\n      {\n        vtmp = ((1 - alphat) * cell(ci).cvel(d)) + ((alphat * (cell(ci).cforce(d) / fstarnrm)) * vstarnrm);\n        cell(ci).setCVel(d, vtmp);\n      }\n\n    }\n\n  }\n\n  spPosVerlet();\n  resetContacts();\n  sp_Forces(lenscales);\n  sp_VelVerlet();\n  t += dt;\n  F = forceRMS();\n  K = totalKineticEnergy();\n  Fcheck = F;\n  Kcheck = K / NCELLS;\n  if (Fcheck < Ftol)\n    npPMIN++;\n  else\n    npPMIN = 0;\n\n  converged = ((Fcheck < Ftol) && (npPMIN > NMIN)) && (Kcheck < Ktol);\n  if (converged)\n  {\n    (cout << \"\t** FIRE has converged!\") << endl;\n    ((cout << \"\t** Kcheck of Sp particles = \") << Kcheck) << endl;\n    ((cout << \"\t** Fcheck of Sp particles = \") << Fcheck) << endl;\n    ((((cout << \"\t** itr = \") << itr) << \", t = \") << t) << endl;\n    (cout << \"\t** Breaking out of FIRE protocol.\") << endl;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/74"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    arr1[i][j] = j;\n    arr2[i][j] = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/matrix_matrix_openmp/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  fwrite(&autoc_h[i], 1, sizeof(float), file_out);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MiguelazoDS/so2-openmp/C\u00f3digos/paralelo/5"}
{"code": "for (; (i < N) && (j < N); i = (i + incX) + 4, j = (j + incY) + 4)\n{\n  Y[j] = X[i];\n  Y[j + 1] = X[i + 1];\n  Y[j + 2] = X[i + 2];\n  Y[j + 3] = X[i + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/2"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  v1 = _mm_load_ps(&x[i]);\n  v2 = _mm_load_ps(&y[i]);\n  scalar = _mm_set1_ps(a);\n  tmp = _mm_mul_ps(v1, scalar);\n  v2 = _mm_add_ps(v2, tmp);\n  _mm_store_ps(&y[i], v2);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/axpy/2"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((mat2[rowcol] == (-28768)) || (mat8[rowcol] == 28768)) || (mat2[rowcol] <= 0.001))\n  {\n    matOut3[rowcol] = 0.0;\n  }\n  else\n  {\n    if (((mat1[rowcol] * 0.0001) > ndvi_max) && ((mat1[rowcol] * 0.0001) < 0.98))\n      ndvi_max = mat1[rowcol] * 0.0001;\n\n    if (((mat2[rowcol] * 0.001) > albedo_max) && ((mat2[rowcol] * 0.001) < 0.9))\n      albedo_max = mat2[rowcol] * 0.001;\n\n    if (((mat2[rowcol] * 0.001) < albedo_min) && ((mat2[rowcol] * 0.001) > 0.001))\n      albedo_min = mat2[rowcol] * 0.001;\n\n    tempk = mat8[rowcol] * 0.02;\n    etpotd = et_pot_day(mat15[rowcol], tempk, roh_w);\n    matOut3[rowcol] = etpotd;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, tempk, etpotd) shared(N, nX, nY, roh_w, tsw, doy, ndvi_max,albedo_min,albedo_max, mat1,mat2,mat8, mat15, matOut3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta/0"}
{"code": "for (int i = 0; i < rowOMP; i++)\n{\n  for (int j = 0; j < (rowOMP + 1); j++)\n  {\n    (file4 << xOMP[i]) << \";\";\n  }\n\n  file4 << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    double s = 0.0;\n    for (k = 0; k < n; k++)\n    {\n      s += p[(i * n) + k] * q[(k * n) + j];\n    }\n\n    r[(i * n) + j] = s;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/first-steps/omp-matmul/0"}
{"code": "for (int l = 0; l < tmp1.size(); l++)\n{\n  searchName.append((\"tirimageinfo.img_file='\" + tmp1[l]) + \"'\");\n  if ((l + 1) != tmp1.size())\n  {\n    searchName.append(\" or \");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/39"}
{"code": "for (j = 0; j < np; j++)\n{\n  FLOAT xg = x[j];\n  FLOAT yg = y[j];\n  FLOAT mpi_xg = M_PI * xg;\n  FLOAT mpi_yg = M_PI * yg;\n  FLOAT sin_xg = SIN_D(mpi_xg);\n  FLOAT cos_xg = COS_D(mpi_xg);\n  FLOAT sin_yg = SIN_D(mpi_yg);\n  FLOAT cos_yg = COS_D(mpi_yg);\n  FLOAT xtdt = (((((-1) * time_factor) * sin_xg) * sin_xg) * cos_yg) * sin_yg;\n  FLOAT ytdt = (((time_factor * cos_xg) * sin_xg) * sin_yg) * sin_yg;\n  x_out[j] = xg + xtdt;\n  y_out[j] = yg + ytdt;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muellermichel/Hybrid-Fortran/examples/particle/source/particle/0"}
{"code": "for (c = 0; c < 3; c++)\n{\n  int clusterSize = clusters[c].numDatapoints;\n  double *distances = malloc(clusterSize * (sizeof(double)));\n  #pragma acc parallel for\n  for (i = 0; i < clusterSize; i++)\n  {\n    distances[i] = 0.0;\n    for (j = 0; j < clusterSize; j++)\n    {\n      distances[i] += distance(*clusters[c].datapoints[i], *clusters[c].datapoints[j]);\n    }\n\n  }\n\n  int medoidIndex = indexOfSmallestElement(distances, clusterSize);\n  clusters[c].medoid = clusters[c].datapoints[medoidIndex];\n  free(distances);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/57"}
{"code": "for (i = m; i < y; f *= (aa / (++i)) - s)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/46"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  for (int j = 0; j < 4; ++j)\n  {\n    point[i].elements[j] = rand() % 25;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/11"}
{"code": "for (int j = jb; j < je; j++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    Du[IDX(i, j, ke - 3)] = (((((u[IDX(i, j, ke - 6)] - (6.0 * u[IDX(i, j, ke - 5)])) + (15.0 * u[IDX(i, j, ke - 4)])) - (19.0 * u[IDX(i, j, ke - 3)])) + (12.0 * u[IDX(i, j, ke - 2)])) - (3.0 * u[IDX(i, j, ke - 1)])) / spr1;\n    Du[IDX(i, j, ke - 2)] = ((((u[IDX(i, j, ke - 5)] - (6.0 * u[IDX(i, j, ke - 4)])) + (12.0 * u[IDX(i, j, ke - 3)])) - (10.0 * u[IDX(i, j, ke - 2)])) + (3.0 * u[IDX(i, j, ke - 1)])) / spr2;\n    Du[IDX(i, j, ke - 1)] = (((u[IDX(i, j, ke - 4)] - (3.0 * u[IDX(i, j, ke - 3)])) + (3.0 * u[IDX(i, j, ke - 2)])) - u[IDX(i, j, ke - 1)]) / spr3;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/47"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = bt * r3;\n      t2 = 0.5 * (r4 + r5);\n      rhs[0][i][j][k] = -r2;\n      rhs[1][i][j][k] = r1;\n      rhs[2][i][j][k] = bt * (r4 - r5);\n      rhs[3][i][j][k] = (-t1) + t2;\n      rhs[4][i][j][k] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/21"}
{"code": "for (int k = 0; k < width; k++)\n{\n  double x = a[(i * width) + k];\n  double y = b[(k * width) + j];\n  sum += x * y;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa04/mm/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  foo();\n  foo();\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/ordered_messages/2"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  for (k = 0; k < n; k++)\n  A[i][j][k] = (B[i][j][k] = (((DATA_TYPE) ((i + j) + (n - k))) * 10) / n);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/heat-3d/heat-3d/2"}
{"code": "for (size_t k = 0; k < p1Dnpts; k++)\n{\n  for (size_t i = 0; i < nocc; i++)\n  {\n    m1Deps_o[(k * nocc) + i] = pow((double) v1Dpts[k], (double) (-vf[i]));\n  }\n\n  for (size_t a = 0; a < nvirt; a++)\n  {\n    size_t pos_f = a + nocc;\n    m1Deps_v[(k * nvirt) + a] = pow((double) v1Dpts[k], (double) vf[pos_f]);\n  }\n\n  double inv_t = 1.0 / ((double) v1Dpts[k]);\n  for (size_t i = 0; i < nocc; i++)\n  {\n    for (size_t a = 0; a < nvirt; a++)\n    {\n      c1Deps_ov[(((k * nocc) * nvirt) + (i * nvirt)) + a] = (m1Deps_o[(k * nocc) + i] * m1Deps_v[(k * nvirt) + a]) * inv_t;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/methods/do_qmp2/2"}
{"code": "for (j = kmin; j < kmax; j++)\n{\n  for (i = 0; i < kmin; i++)\n  {\n    if (graph[memPos[i][j].first][memPos[i][j].second] > (graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second]))\n    {\n      graph[memPos[i][j].first][memPos[i][j].second] = graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second];\n    }\n\n  }\n\n  for (i = kmax; i < V; i++)\n  {\n    if (graph[memPos[i][j].first][memPos[i][j].second] > (graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second]))\n    {\n      graph[memPos[i][j].first][memPos[i][j].second] = graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/28"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    s = g[j + (2 * (ny - k))];\n    g[j + (2 * (ny - k))] = 0.5 * (cimagf(g[j + (2 * k)] + s) + (crealf(g[j + (2 * k)] - s) * _Complex_I));\n    g[j + (2 * k)] = 0.5 * (crealf(g[j + (2 * k)] + s) + (cimagf(g[j + (2 * k)] - s) * _Complex_I));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mppic2/mppush2/11"}
{"code": "for (i = 0; i < length; i++)\n{\n  if (!set)\n  {\n    set = true;\n    for (int k = 0; k < i; k++)\n    {\n      b++;\n    }\n\n  }\n\n  *(b++) = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Tests/testing/assignment/matrixMult/0"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  if (fabs(Y[i] - ((double) NofRows[i])) > 1.0e-18)\n  {\n    printf(\" Error! in ( %d ) th argument. %lf \\n\", i, Y[i]);\n    iflag = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/SpMV_IB/C/spmv_ib/3"}
{"code": "for (i = 0; i < tam; ++i)\n{\n  aux = vet[i];\n  j = i - 1;\n  while ((j >= 0) && (vet[j] > aux))\n  {\n    vet[j + 1] = vet[j];\n    j = j - 1;\n  }\n\n  vet[j + 1] = aux;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeovanaS/Concurrent-Programming/bucketOpenmp/1"}
{"code": "for (int i = 0; i < step; i++)\n{\n  if (verbose)\n    printf(\"%u \", output[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/permute/0"}
{"code": "for (k = 0; k < (1024 - 4); k++)\n{\n  printf(\"Thread %d working on %d row\\n\", thread_id, k);\n  for (m = 0; m < (1024 - 4); m++)\n  {\n    int l = 0;\n    median = 0;\n    for (i = 0; i < 5; i++)\n    {\n      for (j = 0; j < 5; j++)\n      {\n        window[l] = A[i + k][j + m];\n        l++;\n      }\n\n    }\n\n    for (i = 24; i > 1; i--)\n    {\n      for (j = 0; j < i; j++)\n      {\n        if (window[j] > window[j + 1])\n        {\n          int temp = window[j];\n          window[j] = window[j + 1];\n          window[j + 1] = temp;\n        }\n\n      }\n\n    }\n\n    median = window[12];\n    B[k + 2][m + 2] = median;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RachanaRajSunku/Image-Processing-Algorithm-Implementation-in-MPI-and-OpenMP/omp_median_window5x5/omp_median_w5/0"}
{"code": "for (i = 1; i < size_results; i++)\n{\n  if (results[i] > final_score)\n  {\n    final_class = i;\n    final_score = results[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/NeuralNet/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = 0;\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/openmp/host_function/host_function/1"}
{"code": "for (int i = start_index; i <= end_index; i++)\n{\n  if ((A % i) == 0)\n  {\n    isDiv[i] = true;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab6_OpenMP/Lab6_OpenMP/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (t.s->a[i] != i)\n    printf(\"Error at %d, %d, error %d\\n\", i, t.s->a[i], ++error);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/11"}
{"code": "formula.append((\"+ \" + number(bb)) + \"x^6 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/90"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n  f >> a[(i * n) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Matrix Multiplication/matrix_mul_parallel/0"}
{"code": "for (i = N - 2; i >= 1; i--)\n{\n  for (j = i + 2; j <= N; j++)\n  {\n    for (k = i; k <= (j - l); k++)\n    {\n      ck[i][j] += (ck[i][j - 1] + paired(k, j)) ? (ck[i][k - 1] + ck[k + 1][j - 1]) : (0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/counting/counting/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"%4d\", C[i]);\n  if (i == (N - 1))\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMParrayMulti/3"}
{"code": "for (i = 0; i < dim; i++)\n  for (j = 0; j < dim; j++)\n  printf(\"%lf \", *(mat + (j + (i * dim))));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anishmrao/MultithreadMatrixMul/mattry/3"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  omp_set_lock(&lock);\n  sum += 1;\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/base_mutex/0"}
{"code": "for (size_t i = 0; i < M; i++)\n  (cout << vec[i]) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sncodeGit/openmp_labs/Task3/Task3/1"}
{"code": "for (j = 0; j < dimension; j++)\n{\n  if (data_points[j] != c[j])\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/4"}
{"code": "for (j = 0; j < 8; j++)\n{\n  i = j + i;\n  printf(\"i=%d\\tThread=%d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for firstprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gunjapandey/Introduction-to-OpenMP/l2_prog2/0"}
{"code": "for (long i = 0; i < N1; i++)\n{\n  if (C1[i] == (-1))\n  {\n    C1[i] = nC1;\n    found = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/1"}
{"code": "for (int i = 0; i < numPoint; i++)\n{\n  privateMinDistance = max();\n  for (int j = 0; j < k; j++)\n  {\n    privateDistance = 0;\n    for (int h = 0; h < dimPoint; h++)\n    {\n      privateDistance += pow(dataset[i].dimensions[h] - centroids[j].dimensions[h], 2);\n    }\n\n    privateDistance = sqrt(privateDistance);\n    if (privateDistance < privateMinDistance)\n    {\n      privateMinDistance = privateDistance;\n      clusterLabel = j;\n    }\n\n  }\n\n  dataset[i].clusterId = clusterLabel;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcocalamai/Parallel-Kmeans-OpenMP-and-Cuda/src/KMeans_OpenMP/1"}
{"code": "for (i = 1; i < (num_line - 1); i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    if (counter < 50)\n    {\n      printf(\"RANK %d    resultMatrix[%d][%d] = %d -- send_buf[%d] = %d \\n\", taskid, i, j, resultMatrix[i][j], counter, send_buf[counter]);\n      counter++;\n    }\n    else\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/15"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (*matrix)[i] = (float *) calloc(n, sizeof(float));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/3"}
{"code": "for (int i = 0; i < num_t; i++)\n{\n  (vector < string) > vs;\n  this->lq_vecs.push_back(vs);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Po-Y-H/Parallel-Web-Crawler-by-OpenMP/03_ps/Crawler/0"}
{"code": "for (ix = 0; ix < task_X; ix++)\n  for (iy = 0; iy < task_Y; iy++)\n  *((u + (ix * task_Y)) + iy) = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iokasti/heatTransferSimulation-parallel/openmp/mpi_heat_openmp_functions/3"}
{"code": "for (int i = 0; i < num_data_points; ++i)\n{\n  (cin >> x[i]) >> y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmarKumar-AK/HPC-project-KMeanClustering/main/4"}
{"code": "for (uint i = 0; i < vecIn.size(); i++)\n{\n  vecOut[i] = worker(vecIn[i], str);\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/admiswalker/blog_2019_0421_OpenMP/ex1/main/1"}
{"code": "for (int i = 1; i < (1000000 + 1); i++)\n  F_ptr[i] = F_ptr[i - 1] + 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/2"}
{"code": "for (mat_row = 0; mat_row < local_C->n_bar; mat_row++)\n  MPI_Send(&(*((local_C->entries + (local_C->n_bar * mat_row)) + 0)), local_C->n_bar, (MPI_Datatype) 0x4c00080b, 0, 0, grid->comm);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/13"}
{"code": "for (int i = 0; i < int_val; i++)\n{\n  I_val[i] = I(i);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/14"}
{"code": "for (j = i; j > 0; j--)\n{\n  int dpx = (i + 1) - j;\n  if (dpx <= m)\n  {\n    if (x[dpx - 1] == y[j - 1])\n    {\n      dp[dpx][j] = dp[dpx - 1][j - 1];\n    }\n    else\n    {\n      dp[dpx][j] = min3(dp[dpx - 1][j - 1] + pxy, dp[dpx - 1][j] + pgap, dp[dpx][j - 1] + pgap);\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel2/0"}
{"code": "for (i = 0; i < NUM_THREADS; i++)\n{\n  if (outVector[i] != (sequentialSum + 10))\n  {\n    printf(\"Error: outVector[%d] =%d != %d\\n\", i, outVector[i], sequentialSum + 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/ompcodeletclause-test/ompcodeletclause/5"}
{"code": "for (int g = 0; g < number; g++)\n{\n  x = ((((2.0 * g) * 1.0) - 1.0) / h) * 1.0;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "#pragma omp for schedule(guided, 10) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vkalmykov/lab3openmp/lab3openmp/lab3openmp/0"}
{"code": "for (i = 0; i < 36; i++)\n{\n  m_set_val(x, 0, i, v_get_val(cellx_row, index[i]));\n  m_set_val(y, 0, i, v_get_val(celly_row, index[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/15"}
{"code": "for (int i = 1; i < 3; i++)\n{\n  A[0][j] += A[i][j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanwbrei/openmp_tutorial/src/lcdbroken/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    check = check && (C[(i * N) + j] == N);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/practicas/p3/e3/columnas-matrices/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    (cout << m[i][j]) << \"   \";\n  }\n\n  (cout << endl) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YShoun/matrix-mul/main/3"}
{"code": "for (int i = 0; i < (NThreads - 1); i++)\n{\n  Streams->data[i] = (i + 1) * SizeStream;\n  Cont += SizeStream;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joelchaconcastillo/SolverMontecarlo_MAO/SolverSistemaEcuacionesOpenMPIStreams/MonteCarlo/0"}
{"code": "for (i = 0; i <= (size - 1); i++)\n{\n  for (j = 0; j <= (size - 1); j++)\n  {\n    s += ((matrix[(i * size) + j] * (i + 1)) * (j + 1)) / (size * size);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:s) shared(size, matrix, thread_num) private(i,j) num_threads(thread_num)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hapiny/mpi-openmp-msu-course/omp/2"}
{"code": "for (int i = 0; i < m_landuseNum; i++)\n{\n  m_landuseLookupMap.insert(make_pair(CVT_INT(m_landuseLookup[i][1]), m_landuseLookup[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/management/PLTMGT_SWAT/managementOperation_SWAT/0"}
{"code": "for (i = 0; i < num_hilos; i++)\n  if (registros[i].valor > maximo)\n{\n  maximo = registros[i].valor;\n  registros[num_hilos].valor = maximo;\n  registros[num_hilos].x = registros[i].x;\n  registros[num_hilos].y = registros[i].y;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas4.0/0"}
{"code": "for (j = 1; j < Nme; j++)\n{\n  bnew = b_me[j];\n  cnew = c_me[j];\n  for (i = 0; i < j; i++)\n  {\n    if ((bnew < b_me[i]) | ((bnew == b_me[i]) & (cnew < c_me[i])))\n    {\n      for (k = j; k > i; k--)\n      {\n        b_me[k] = b_me[k - 1];\n        c_me[k] = c_me[k - 1];\n      }\n\n      b_me[i] = bnew;\n      c_me[i] = cnew;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManafMukred/Parallelization_nsertion_Sorting_OpenMP/my_sort-insertion/3"}
{"code": "for (int i = 0; i < this->coo_nnz_; ++i)\n{\n  this->mat_.COO.col[i] = cast_mat->mat_.COO.col[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_hyb/3"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < min(10, m_br); j++)\n    (cout << phc[j]) << \" | \";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/3"}
{"code": "for (int i = 0; i < nSteps; i++)\n{\n  const double x = x_lower_bound + (dx * (((double) i) + 0.5));\n  integral += (1.0 / sqrt(x)) * dx;\n}\n\n", "pragma": "omp parallel for reduction(+: integral)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lechugaa/arquitectura_OpenMP/demo_reduccion_2/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = (T) 0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_dist_schedule_codegen/1"}
{"code": "for (int row1 = 0; row1 < n; row1++)\n{\n  c3[row1] = 0;\n  for (int idx1 = row_ptr[row1]; idx1 < row_ptr[row1 + 1]; idx1++)\n  {\n    c3[row1] += common_neighbors(row1, col_idx[idx1], row_ptr, col_idx);\n  }\n\n  c3[row1] = c3[row1] / 2;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v4/v4_omp/6"}
{"code": "for (int gid = 0; gid < nElem; gid++)\n  d_pBound[gid] = ((gid - valueLeftBound) * sizeElem) + offset;\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/1"}
{"code": "for (int i = 0; i < arr.size(); ++i)\n  sum_red += arr[i];\n\n", "pragma": "#pragma omp parallel for reduction(+:sum_red)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HPC-lab-ITIS/OpenMP-and-MPI/materials/lec_2/code/test_4/1"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vSoundSpeed[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/55"}
{"code": "for (; myxl < myxr; myxl += c_inc)\n  xticks[me].push_back(myxl);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/hw2/p2/0"}
{"code": "for (index = 0; index < count; index += batch_size)\n{\n  unsigned char master[1][32];\n  unsigned char output[24];\n  unsigned char *iv_in;\n  unsigned char iv_out[16];\n  int size;\n  int i;\n  AES_KEY akey;\n  if (cur_salt->version == 5)\n  {\n    for (i = 0; i < batch_size; ++i)\n      pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 16, cur_salt->iterations, master[i], 32, 0);\n\n  }\n  else\n  {\n    for (i = 0; i < batch_size; ++i)\n      pbkdf2_sha512((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, 16, cur_salt->iterations, master[i], 32, 0);\n\n  }\n\n  for (i = 0; i < batch_size; ++i)\n  {\n    size = page_sz - reserve_sz;\n    iv_in = (cur_salt->data + 16) + size;\n    memcpy(iv_out, iv_in, 16);\n    AES_set_decrypt_key(master[i], 256, &akey);\n    AES_cbc_encrypt(cur_salt->data + 16, output + 16, 8, &akey, iv_out, AES_DECRYPT);\n    if (enpass_verify_page(output) == 0)\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/enpass_fmt_plug/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  outptr[i] = devPtr->sag(inptr[i], inptr[i]);\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for map(inptr[:10], outptr[:10]) is_device_ptr(devPtr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/sollve_vv/tests/5.0/application_kernels/declare_target_base_and_derived_class/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = random_value(&my_seed);\n  printf(\"  %6d  %12d  %6d  %14.6g\\n\", my_id, my_seed, i, x[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/randomnumbers/0"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/88"}
{"code": "for (int i = 0; i < mSize; i++)\n  for (int j = 0; j < mSize; j++)\n  sum_par += M[i][j];\n\n\n", "pragma": "omp parallel for shared(M) reduction(+:sum_par)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab7/lab3/0"}
{"code": "for (int dimension = start_2D; dimension <= end_2D; dimension += interval_2D)\n{\n  ikj_algorithmTest(dimension, iterations);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyamramawat/Large_Multiplication_Matrix_OPENMP/19210520_CA670_Assignment_2/Code/6"}
{"code": "for (int i = 0; i < len; i++)\n{\n  char delimit = (char) ((i == (len - 1)) ? ('\\n') : (','));\n  printf(\"%d%c\", data[i], delimit);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robfarr/openmp-prefix-sum/main/1"}
{"code": "for (int i = 0; i < k; i++)\n{\n  for (int j = 0; j < dimension; j++)\n  {\n    centroids[(j * k) + i] = points[(j * n) + i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucabindini/KMeansClustering_OpenMP/KMeans/0"}
{"code": "for (int i = 0; i < M; i++)\n{\n  Rall = Rall + ((C[i] * hann[i]) / sum_hann);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bemoregt/ww1DPOCDisparity/src/ofApp/4"}
{"code": "for (i = 0; i < (4800 / 8); i++)\n  for (j = 0; j < (4800 / 4); j++)\n  a[i][j] = 1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/samples_2016/en/compiler_c/psxe/openmp_samples/openmp_sample/2"}
{"code": "for (int i = 1000000; i > 0; i--)\n{\n  if (steps(i) > value)\n  {\n    value = steps(i);\n    tmp = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex14projecteuler/1"}
{"code": "for (i = 5; i < 16; i += bar(i))\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/17"}
{"code": "for (unsigned int i = 1; i < (image->height - 1); ++i)\n{\n  for (unsigned int j = 1; j < (image->width - 1); ++j)\n  {\n    newImage->matrix[i][j] = image->matrix[i][j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/craciunoiuc/parallel-architectures/OpenMP_version/filters/dummy_filter_openMP/0"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((m != centre) && (m != ind1))\n  {\n    if ((min2 == (-1.0)) || (dist_list[m] < min2))\n    {\n      min2 = dist_list[m];\n      ind2 = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/16"}
{"code": "for (int i = 0; i < spmatrix->hsize; i++)\n{\n  msum += spmatrix->iia[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/matrixio/2"}
{"code": "for (i = 0; i < 5; i++)\n  a[i] += i;\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/g1stavo/parallel-distributed/lab-2/master/2"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  double sum = 0.0;\n  for (j = 0; j <= 99; j += 1)\n  {\n    sum += a[i][j] * v[j];\n  }\n\n  v_out[i] = sum;\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB061-matrixvector1-orig-no/2"}
{"code": "for (int ir = 0; ir < rbins; ir++)\n{\n  r_midpoint[ir] = R_MIN + (rbinwidth * (((double) ir) + 0.5));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/10"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"from thread %d\\n avg = %d\\n\", omp_get_thread_num(), avg);\n  avgReduction += a[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : avgReduction)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/greenmapc/OpenMP-MPI/OpenMP/Task6/2"}
{"code": "for (int i = 0; i < repeat_time; i++)\n{\n  startTime = clock();\n  wall_time = omp_get_wtime();\n  func(delay_times);\n  endTime = clock();\n  full_time += ((double) (endTime - startTime)) / CLOCKS_PER_SEC;\n  full_wall_time += omp_get_wtime() - wall_time;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wwyf/learn_parallel_programming/HW3/HW3-1/loop-parallel-schedule/0"}
{"code": "for (size_t i_node = 0; i_node < rThisGeometry.size(); ++i_node)\n{\n  AtomicDivVector(rThisGeometry[i_node].GetValue(rThisVar), aux);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_processes/internal_variables_interpolation_process/8"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  float c = 0.0;\n  for (k = 0; k < n; k++)\n    c += A[(i * n) + k] * B[(k * n) + j];\n\n  C[(i * n) + j] = c;\n}\n\n\n", "pragma": "omp parallel for shared(A, B, C, n) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/2"}
{"code": "for (int i = 1; i < numTasks; i++)\n{\n  e = ((s + range) - 1) - 1;\n  outMsg.start = s - 1;\n  outMsg.end = e;\n  if (i == (numTasks - 1))\n    outMsg.end = max(e, count - 1);\n\n  s = s + range;\n  rc = MPI_Send(&outMsg, 1, mpi_msg_type, i, 1, MPI_COMM_WORLD);\n  rc = MPI_Send(&count, 1, mpi_msg_type, i, 2, MPI_COMM_WORLD);\n  printf(\"Task %d: Sent message %d %dto task %d with tag 1\\n\", rank, outMsg.start, outMsg.end, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rklohana/Cosine-Similarity-using-TF-IDF-vectors-using-hybrid-openmp-mpi-and-cuda/tfidfstg/1"}
{"code": "for (i = 0; i < Nth; i++)\n{\n  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, Num[i], N, N, 1.0, &A[Pos[i] * N], N, B, N, 0.0, &C[Pos[i] * N], N);\n}\n\n", "pragma": "#pragma omp parallel for private(i) num_threads(Nth)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/8"}
{"code": "for (i = 2; i <= simu_opts->num_ode; i++)\n{\n  count = 0;\n  for (j = 1; j <= cnt; j++)\n  {\n    h = 1;\n    sumpow = 0.0;\n    while (h <= topoinfo->numG)\n    {\n      sumpow = sumpow + pow(tmprlt->y_store[((topoinfo->numG * (i - 1)) + h) - 1] - tmprlt->soln[((topoinfo->numG * (j - 1)) + h) - 1], 2);\n      h++;\n    }\n\n    delta = sqrt(sumpow);\n    if (delta > simu_opts->thrd)\n    {\n      count = count + 1;\n    }\n\n  }\n\n  if (count == cnt)\n  {\n    cnt = cnt + 1;\n    if (cnt <= simu_opts->num_stability)\n    {\n      for (h = 1; h <= topoinfo->numG; h++)\n      {\n        tmprlt->soln[(((cnt - 1) * topoinfo->numG) + h) - 1] = tmprlt->y_store[((topoinfo->numG * (i - 1)) + h) - 1];\n      }\n\n    }\n    else\n    {\n      cnt = simu_opts->num_stability;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/91"}
{"code": "for (int i = 0; i < data_count; i++)\n  data[i] = min_meas + (((max_meas - min_meas) * rand()) / ((double) RAND_MAX));\n\n", "pragma": "#pragma omp parallel for num_threads(hilos)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dess96/Paralela-openmp/Labs cortos/Ejercicio 1/histogram/1"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    matrice[i][j] = 100000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayoubmundia/ProduitMatricielle/omp/3"}
{"code": "for (int i = 1; i < myClones.size(); ++i)\n{\n  myClones[i]->ThreadID = i;\n  myClones[i]->setName(this->getName());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/Particle/make_clones/1"}
{"code": "for (int i = 0; i < characters_size; ++i)\n{\n  if (!m_find)\n  {\n    localData.initialized = 0;\n    str[index] = characters[i];\n    if (index == (maxDepth - 1))\n    {\n      (cout << str) << endl;\n      if (encryptAndCompare(str, localData))\n      {\n        m_find = true;\n        m_password = str;\n        i = characters_size;\n      }\n\n    }\n    else\n    {\n      bruteImpl(str, index + 1, maxDepth, localData);\n    }\n\n  }\n  else\n  {\n    i = characters_size;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jasonjamet/CrackPass/Functions/4"}
{"code": "for (size_t index = startIndex; index < endIndex; index++)\n{\n  double vel_d_0;\n  double vel_dd_0;\n  double p_d_0;\n  double p_dd_0;\n  double vel_d_1;\n  double vel_dd_1;\n  double p_d_1;\n  double p_dd_1;\n  computeSpatialDer(dir, index, offset, computeA, inPressure, inVelocity, neiList0, neiListSize0, LPFOrder0, &vel_d_0, &vel_dd_0, &p_d_0, &p_dd_0);\n  computeSpatialDer(dir, index, offset, computeA, inPressure, inVelocity, neiList1, neiListSize1, LPFOrder1, &vel_d_1, &vel_dd_1, &p_d_1, &p_dd_1);\n  timeIntegration(realDt, multiplier1st, multiplier2nd, gravity, inVolume[index], inVelocity[index], inPressure[index], inSoundSpeed[index], vel_d_0, vel_dd_0, p_d_0, p_dd_0, vel_d_1, vel_dd_1, p_d_1, p_dd_1, &outVolume[index], &outVelocity[index], &outPressure[index]);\n  bool isInvalid = (outPressure[index] < m_fInvalidPressure) || (outVolume[index] < m_fInvalidVolume);\n  if (isInvalid)\n  {\n    printInvalidState(phase, dir, index, positionX[index], positionY[index], positionZ[index], vel_d_0, vel_dd_0, p_d_0, p_dd_0, vel_d_1, vel_dd_1, p_d_1, p_dd_1);\n    bool atLeastOneNonzeroOrder = lowerLPFOrder(index, LPFOrderOther, LPFOrder0, LPFOrder1);\n    if (atLeastOneNonzeroOrder)\n    {\n      index--;\n      continue;\n    }\n    else\n    {\n      phaseSuccess = false;\n      outVolume[index] = inVolume[index];\n      outPressure[index] = inPressure[index];\n      outVelocity[index] = inVelocity[index];\n    }\n\n  }\n\n  outSoundSpeed[index] = m_pEOS->getSoundSpeed(outPressure[index], 1. / outVolume[index]);\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/20"}
{"code": "for (uint64_t i = 0; i < TIMER_NTIMERS; ++i)\n{\n  if (timers[i].seconds_iter > 0)\n  {\n    fprintf(fp, \"%s (sec)\\t\", timer_names[i]);\n  }\n\n  if (timers[i].count_iter > 0)\n  {\n    fprintf(fp, \"%s_COUNTS\\t\", timer_names[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/16"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, 9, (MPI_Datatype) 0x4c000406, T, 9, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/31"}
{"code": "for (i = 0; i < nk; i++)\n  for (j = 0; j < nj; j++)\n  B[i][j] = (((DATA_TYPE) i) * (j + 1)) / nj;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/2mm/2mm/3"}
{"code": "for (i = 2; i <= (NITER_DEFAULT * ((((NX * NX) / 4) + ((NY * NY) / 4)) + ((NZ * NZ) / 4))); i++)\n{\n  ex[i] = ex[i - 1] * ex[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/22"}
{"code": "for (i = 0; i < nEnd; i++)\n{\n  printf(\"%d,\", G->D[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vikky92/HPC/Dijkstra_Algorithm/Dijkstra_OMPMPI/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  int *ARow = &A[i * size];\n  double *BRow = &B[i * size];\n  int iDegree = D[i];\n  for (j = 0; j < size; j++)\n  {\n    BRow[j] = ARow[j] - ((((double) iDegree) * D[j]) / (2 * m));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/2"}
{"code": "for (y = 0; y < GLOBAL_GRID_W; ++y)\n  send_buf_y[y] = buf_grid_values[get_index_row(proc_x_indices.first, y)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/22"}
{"code": "for (i = 0; i < heigth; i++)\n{\n  fwrite(imagen[i], sizeof(float), width, f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NicolasRomeroF/mandelbrot_openmp/mandelbrotp/2"}
{"code": "for (i = 4; i < 846; i++)\n{\n  largeIndex = indexOfLargestElement(buffer_values, 4);\n  largeValue = buffer_values[largeIndex];\n  if (v_scores[i] < largeValue)\n  {\n    buffer[largeIndex] = i;\n    buffer_values[largeIndex] = v_scores[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/36"}
{"code": "for (int i = 0; i < finalRectsCoordinates.size(); i++)\n{\n  if (finalRectsCoordinates.size() > 0)\n  {\n    ((((((((((((((((cout << \"Rectangle \") << i) << \" coordinates  [top-left-corner]: (\") << finalRectsCoordinates[i].topLeftY) << \",\") << finalRectsCoordinates[i].topLeftX) << \")\") << endl) << \"Rectangle \") << i) << \" coordinates  [bottom-right-corner]: (\") << finalRectsCoordinates[i].bottomRightY) << \",\") << finalRectsCoordinates[i].bottomRightX) << \")\") << endl) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/8"}
{"code": "for (int i = 0; i < w; i++)\n{\n  for (int j = 0; j < h; j++)\n  {\n    map[i][j] = 0;\n    if ((((float) rand()) / (RAND_MAX + 1.0)) < 0.75f)\n    {\n      image.setPixel(i, j, Blue);\n      map[i][j] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SamaiMed/Cellular-Automata-SFML-OpenMP/ConsoleApplication/textures/0"}
{"code": "formula.append((\"+ \" + number(g)) + \"x \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/32"}
{"code": "for (i = 2; i < m_size; i++)\n  for (j = 1; j < i; j++)\n  uArray[i][j] = 0;\n\n\n", "pragma": "  #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/3"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n  rank[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-fig/CISC-4335-OpenMP-Rank-Sort/rank_sort/2"}
{"code": "for (int i = 0; i < nrOfIds; i++)\n{\n  training_set[i] = alloc_2d_matrix(nrOfPhotosPerId, histogramSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/3"}
{"code": "for (int n = 0; n < (N - 1); n++)\n{\n  res += x[n + 1] * x[n + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/backup/new_codes/R1ES_omp_alt/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  if (a[i] > maxm)\n  {\n    maxm = a[i];\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) reduction(max:maxm)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoyMitra/android-parallel-benchmarks/openmp/max-array/app/src/main/cpp/findmax/0"}
{"code": "for (i = 0; i < NoofRows; i++)\n{\n  Matrix[i] = (float *) malloc((sizeof(float)) * NoofCols);\n  for (j = 0; j < NoofCols; j++)\n    Matrix[i][j] = ((i * j) * 5) + i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/1"}
{"code": "for (size_t idx_j = idx_i + 1; idx_j < count; idx_j++)\n{\n  if (array[idx_j] < m)\n  {\n    min_idx = idx_j;\n    m = array[min_idx];\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp prallel for reduction(min: m)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/in1gma/openmp-selection-sort-graph-by-g2/selection_sort/0"}
{"code": "for (i = id, sum[id] = 0; i < num_steps; i = i + NUM_THREADS)\n{\n  x = (i + 0.5) * step;\n  sum[id] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moomnightstar/openmp/openmppi/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/47"}
{"code": "for (long window = M + 1; window <= N; window += M)\n{\n  memset(prime, true, M);\n  if (base != window)\n  {\n    base = window;\n    for (long k = 0; k < n_factor; k++)\n    {\n      striker[k] = ((((base + factor[k]) - 1) / factor[k]) * factor[k]) - base;\n    }\n\n  }\n\n  long limit = min((window + M) - 1, N) - base;\n  for (long k = 0; k < n_factor; k++)\n  {\n    striker[k] = mark_multiples(prime, striker[k], factor[k], limit) - M;\n  }\n\n  for (long p = 0; p <= limit; p++)\n  {\n    if (prime[p] == true)\n    {\n      count++;\n    }\n\n  }\n\n  base += M;\n}\n\n", "pragma": "        #pragma omp for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/4_parallel_sieve/parallel_sieve/5"}
{"code": "formula.append((\"+ \" + number(c)) + \"x^5 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/17"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  array[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaheryar3969/OSproject/mergeop/2"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmppvyo7387.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang8/projects/openmp/runtime/test/affinity/format/affinity_values/2"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  t[i] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joulook/Parallel-Processing-Spring-2021/Parallel Jacobi Method/Parallel Jacobi/parallelJacobi/3"}
{"code": "for (i = 0; i < tam; i++)\n{\n  aux[0] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 2/Quest\u00e3o 2/Q2/1"}
{"code": "for (int i = 0; i < num_trees; ++i)\n{\n  trees[i] = createTree();\n}\n\n", "pragma": "    #pragma omp parallel for default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/9"}
{"code": "for (l = 0; l < 11; l++)\n{\n  fprintf(fp, \"%f %f\\n\", x[perm_min[l]], y[perm_min[l]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rawal-p/HPC-OpenMP-Assignment/rawalp_tsp_omp/2"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  X[i] = 0.000001 * i;\n  Y[i] = 0.000003 * i;\n  Z[i] = 0.000005 * i;\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-317896/clang-317896/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = rand() % 50;\n    b[i][j] = rand() % 50;\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DelSquared/OpenMP-Matrix-Multiplication-Parallelisation-Comarison/Parallel/Parallel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d executes loop iteration %d\\n\", omp_get_thread_num(), i);\n  b[i] = 2 * a[i];\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.12-two-for-loops/1"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  for (j = 0; j < 3000; j++)\n    printf(\" %d\", A[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/1"}
{"code": "for (t = 0; t < n; t++)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current[index].S, BF_init_state.S, sizeof(BF_current[index].S));\n    memcpy(BF_current[index].P, BF_init_key[index], sizeof(BF_current[index].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_current[index].P[i] = L0;\n      BF_current[index].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[index].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[index].S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current[index].P[0] ^= BF_exp_key[index][0];\n      BF_current[index].P[1] ^= BF_exp_key[index][1];\n      BF_current[index].P[2] ^= BF_exp_key[index][2];\n      BF_current[index].P[3] ^= BF_exp_key[index][3];\n      BF_current[index].P[4] ^= BF_exp_key[index][4];\n      BF_current[index].P[5] ^= BF_exp_key[index][5];\n      BF_current[index].P[6] ^= BF_exp_key[index][6];\n      BF_current[index].P[7] ^= BF_exp_key[index][7];\n      BF_current[index].P[8] ^= BF_exp_key[index][8];\n      BF_current[index].P[9] ^= BF_exp_key[index][9];\n      BF_current[index].P[10] ^= BF_exp_key[index][10];\n      BF_current[index].P[11] ^= BF_exp_key[index][11];\n      BF_current[index].P[12] ^= BF_exp_key[index][12];\n      BF_current[index].P[13] ^= BF_exp_key[index][13];\n      BF_current[index].P[14] ^= BF_exp_key[index][14];\n      BF_current[index].P[15] ^= BF_exp_key[index][15];\n      BF_current[index].P[16] ^= BF_exp_key[index][16];\n      BF_current[index].P[17] ^= BF_exp_key[index][17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current[index].P[0] ^= u1;\n      BF_current[index].P[1] ^= u2;\n      BF_current[index].P[2] ^= u3;\n      BF_current[index].P[3] ^= u4;\n      BF_current[index].P[4] ^= u1;\n      BF_current[index].P[5] ^= u2;\n      BF_current[index].P[6] ^= u3;\n      BF_current[index].P[7] ^= u4;\n      BF_current[index].P[8] ^= u1;\n      BF_current[index].P[9] ^= u2;\n      BF_current[index].P[10] ^= u3;\n      BF_current[index].P[11] ^= u4;\n      BF_current[index].P[12] ^= u1;\n      BF_current[index].P[13] ^= u2;\n      BF_current[index].P[14] ^= u3;\n      BF_current[index].P[15] ^= u4;\n      BF_current[index].P[16] ^= u1;\n      BF_current[index].P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[index].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/28"}
{"code": "for (int i = 0; i < ((signed) mask.size()); i++)\n{\n  if ((((mask[i][0] < ((signed) img->getHeight())) && (mask[i][0] >= 0)) && (mask[i][1] < ((signed) img->getWidth()))) && (mask[i][1] >= 0))\n    c->fill(img, mask[i][0], mask[i][1]);\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) num_threads(Data::NB_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serrearthur/Fauxtoshop/source/src/base/mask/1"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  tmp[i + ((SIZE * 3) / 4)] = 0;\n  y[i + ((SIZE * 3) / 4)] = 0;\n  for (int j = 0; j < SIZE; j++)\n  {\n    tmp[i + ((SIZE * 3) / 4)] = (A4[(i * SIZE) + j] * x[j]) + tmp[i + ((SIZE * 3) / 4)];\n    y[i + ((SIZE * 3) / 4)] = (B4[(i * SIZE) + j] * x[j]) + y[i + ((SIZE * 3) / 4)];\n  }\n\n  y[i + ((SIZE * 3) / 4)] = (43532.0f * tmp[i + ((SIZE * 3) / 4)]) + (12313.0f * y[i + ((SIZE * 3) / 4)]);\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS) depend(in: c)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/GESUMMV_M/gesummvPL/3"}
{"code": "for (j_imopVar80 = 1; j_imopVar80 < (grid_points[1] - 1); j_imopVar80++)\n{\n  eta_imopVar76 = ((double) j_imopVar80) * dnym1;\n  for (k_imopVar81 = 1; k_imopVar81 < (grid_points[2] - 1); k_imopVar81++)\n  {\n    zeta_imopVar77 = ((double) k_imopVar81) * dnzm1;\n    for (i_imopVar79 = 0; i_imopVar79 < grid_points[0]; i_imopVar79++)\n    {\n      xi_imopVar75 = ((double) i_imopVar79) * dnxm1;\n      exact_solution(xi_imopVar75, eta_imopVar76, zeta_imopVar77, dtemp);\n      for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n      {\n        ue[i_imopVar79][m_imopVar78] = dtemp[m_imopVar78];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m_imopVar78 = 1; m_imopVar78 <= 4; m_imopVar78++)\n      {\n        buf[i_imopVar79][m_imopVar78] = dtpp * dtemp[m_imopVar78];\n      }\n\n      cuf[i_imopVar79] = buf[i_imopVar79][1] * buf[i_imopVar79][1];\n      buf[i_imopVar79][0] = (cuf[i_imopVar79] + (buf[i_imopVar79][2] * buf[i_imopVar79][2])) + (buf[i_imopVar79][3] * buf[i_imopVar79][3]);\n      q[i_imopVar79] = 0.5 * (((buf[i_imopVar79][1] * ue[i_imopVar79][1]) + (buf[i_imopVar79][2] * ue[i_imopVar79][2])) + (buf[i_imopVar79][3] * ue[i_imopVar79][3]));\n    }\n\n    for (i_imopVar79 = 1; i_imopVar79 < (grid_points[0] - 1); i_imopVar79++)\n    {\n      im1 = i_imopVar79 - 1;\n      ip1 = i_imopVar79 + 1;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][0] = (forcing[i_imopVar79][j_imopVar80][k_imopVar81][0] - (tx2 * (ue[ip1][1] - ue[im1][1]))) + (dx1tx1 * ((ue[ip1][0] - (2.0 * ue[i_imopVar79][0])) + ue[im1][0]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][1] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][1] - (tx2 * (((ue[ip1][1] * buf[ip1][1]) + (c2 * (ue[ip1][4] - q[ip1]))) - ((ue[im1][1] * buf[im1][1]) + (c2 * (ue[im1][4] - q[im1])))))) + (xxcon1 * ((buf[ip1][1] - (2.0 * buf[i_imopVar79][1])) + buf[im1][1]))) + (dx2tx1 * ((ue[ip1][1] - (2.0 * ue[i_imopVar79][1])) + ue[im1][1]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][2] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][2] - (tx2 * ((ue[ip1][2] * buf[ip1][1]) - (ue[im1][2] * buf[im1][1])))) + (xxcon2 * ((buf[ip1][2] - (2.0 * buf[i_imopVar79][2])) + buf[im1][2]))) + (dx3tx1 * ((ue[ip1][2] - (2.0 * ue[i_imopVar79][2])) + ue[im1][2]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][3] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][3] - (tx2 * ((ue[ip1][3] * buf[ip1][1]) - (ue[im1][3] * buf[im1][1])))) + (xxcon2 * ((buf[ip1][3] - (2.0 * buf[i_imopVar79][3])) + buf[im1][3]))) + (dx4tx1 * ((ue[ip1][3] - (2.0 * ue[i_imopVar79][3])) + ue[im1][3]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][4] = ((((forcing[i_imopVar79][j_imopVar80][k_imopVar81][4] - (tx2 * ((buf[ip1][1] * ((c1 * ue[ip1][4]) - (c2 * q[ip1]))) - (buf[im1][1] * ((c1 * ue[im1][4]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[ip1][0] - (2.0 * buf[i_imopVar79][0])) + buf[im1][0]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i_imopVar79])) + cuf[im1]))) + (xxcon5 * ((buf[ip1][4] - (2.0 * buf[i_imopVar79][4])) + buf[im1][4]))) + (dx5tx1 * ((ue[ip1][4] - (2.0 * ue[i_imopVar79][4])) + ue[im1][4]));\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      i_imopVar79 = 1;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((5.0 * ue[i_imopVar79][m_imopVar78]) - (4.0 * ue[i_imopVar79 + 1][m_imopVar78])) + ue[i_imopVar79 + 2][m_imopVar78]));\n      i_imopVar79 = 2;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((((-4.0) * ue[i_imopVar79 - 1][m_imopVar78]) + (6.0 * ue[i_imopVar79][m_imopVar78])) - (4.0 * ue[i_imopVar79 + 1][m_imopVar78])) + ue[i_imopVar79 + 2][m_imopVar78]));\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      for (i_imopVar79 = 1 * 3; i_imopVar79 <= ((grid_points[0] - (3 * 1)) - 1); i_imopVar79++)\n      {\n        forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * ((((ue[i_imopVar79 - 2][m_imopVar78] - (4.0 * ue[i_imopVar79 - 1][m_imopVar78])) + (6.0 * ue[i_imopVar79][m_imopVar78])) - (4.0 * ue[i_imopVar79 + 1][m_imopVar78])) + ue[i_imopVar79 + 2][m_imopVar78]));\n      }\n\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      i_imopVar79 = grid_points[0] - 3;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((ue[i_imopVar79 - 2][m_imopVar78] - (4.0 * ue[i_imopVar79 - 1][m_imopVar78])) + (6.0 * ue[i_imopVar79][m_imopVar78])) - (4.0 * ue[i_imopVar79 + 1][m_imopVar78])));\n      i_imopVar79 = grid_points[0] - 2;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * ((ue[i_imopVar79 - 2][m_imopVar78] - (4.0 * ue[i_imopVar79 - 1][m_imopVar78])) + (5.0 * ue[i_imopVar79][m_imopVar78])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/3"}
{"code": "for (x = 1; x < (STENCIL_SIZE_X - 1); x++)\n{\n  for (y = 1; y < (STENCIL_SIZE_Y - 1); y++)\n  {\n    values[next_buffer][x][y] = ((((alpha * values[prev_buffer][x - 1][y]) + (alpha * values[prev_buffer][x + 1][y])) + (alpha * values[prev_buffer][x][y - 1])) + (alpha * values[prev_buffer][x][y + 1])) + ((1.0 - (4.0 * alpha)) * values[prev_buffer][x][y]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(static) shared(values) firstprivate(prev_buffer, next_buffer)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MehdiHALA/Mpi-x-project/src/stencil_omp/0"}
{"code": "for (j = 1; j < (512 - 1); ++j)\n{\n  for (i = 1; i < (512 - 1); ++i)\n  {\n    for (k = 1; k < (512 - 1); ++k)\n    {\n      B[((i * (512 * 512)) + (j * 512)) + k] = ((((((((((((((c11 * A[(((i - 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)]) + (c13 * A[(((i + 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)])) + (c21 * A[(((i - 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)])) + (c23 * A[(((i + 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)])) + (c31 * A[(((i - 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)])) + (c33 * A[(((i + 1) * (512 * 512)) + ((j - 1) * 512)) + (k - 1)])) + (c12 * A[(((i + 0) * (512 * 512)) + ((j - 1) * 512)) + (k + 0)])) + (c22 * A[(((i + 0) * (512 * 512)) + ((j + 0) * 512)) + (k + 0)])) + (c32 * A[(((i + 0) * (512 * 512)) + ((j + 1) * 512)) + (k + 0)])) + (c11 * A[(((i - 1) * (512 * 512)) + ((j - 1) * 512)) + (k + 1)])) + (c13 * A[(((i + 1) * (512 * 512)) + ((j - 1) * 512)) + (k + 1)])) + (c21 * A[(((i - 1) * (512 * 512)) + ((j + 0) * 512)) + (k + 1)])) + (c23 * A[(((i + 1) * (512 * 512)) + ((j + 0) * 512)) + (k + 1)])) + (c31 * A[(((i - 1) * (512 * 512)) + ((j + 1) * 512)) + (k + 1)])) + (c33 * A[(((i + 1) * (512 * 512)) + ((j + 1) * 512)) + (k + 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3DCONV/src/3DConvolution/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  s = 0.0;\n  for (j_ptr = IRP[i]; j_ptr <= (IRP[i + 1] - 1); j_ptr++)\n  {\n    s += VAL[j_ptr] * X[ICOL[j_ptr]];\n  }\n\n  Y[i] = s;\n}\n\n", "pragma": "omp parallel for private(s, j_ptr)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/CG/C/cg/6"}
{"code": "for (unsigned int i = 0; i < array_of_bonds.size(); i++)\n{\n  if (array_of_bonds[i] != NULL)\n  {\n    array_of_bonds[i]->Set(TO_ERASE);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/create_and_destroy/10"}
{"code": "for (int i = 0; i < train_space; i++)\n{\n  double g_rand = 0.02 * ((((double) rand()) / RAND_MAX) - 0.5);\n  int j = train_test_idx[0][i];\n  res[i] = g_rand + gxy(grid(j, 0), grid(j, 1), 0.5, 0.5, 0.2);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/gpr/4"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n{\n  u[i][0] = SCALAR_VAL(1.0);\n  p[i][0] = SCALAR_VAL(0.0);\n  q[i][0] = u[i][0];\n  for (j = 1; j < (_PB_N - 1); j++)\n  {\n    p[i][j] = (-f) / ((d * p[i][j - 1]) + e);\n    q[i][j] = (((((-a) * v[i - 1][j]) + ((SCALAR_VAL(1.0) + (SCALAR_VAL(2.0) * a)) * v[i][j])) - (c * v[i + 1][j])) - (d * q[i][j - 1])) / ((d * p[i][j - 1]) + e);\n  }\n\n  u[i][_PB_N - 1] = SCALAR_VAL(1.0);\n  for (j = _PB_N - 2; j >= 1; j--)\n  {\n    u[i][j] = (p[i][j] * u[i][j + 1]) + q[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/adi/adi/1"}
{"code": "for (i = 0; i < _PB_N; i++)\n  for (j = 0; j < _PB_N; j++)\n  x1[i] = x1[i] + (A[i][j] * y_1[j]);\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/mvt/mvt/0"}
{"code": "for (int i = 0; i < height1; i++)\n{\n  for (int j = 0; j < width1; j++)\n  {\n    for (int k = 0; k < height2; k++)\n    {\n      for (int z = 0; z < width2; z++)\n      {\n        row = (i * height2) + k;\n        column = (j * width2) + z;\n        upsampleValuesMatrix[row][column] = backPropagatedError[i][j] * scale[k][z];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/3"}
{"code": "for (int i = 0; i < SIZE; ++i)\n{\n  bootstrap(groupOfBoardDeques[i], i);\n  _board_deque.boardDeque.insert(_board_deque.boardDeque.end(), groupOfBoardDeques[i].boardDeque.begin(), groupOfBoardDeques[i].boardDeque.end());\n}\n\n", "pragma": "\t\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huaminghuangtw/Parallel-Sudoku-Solver/src/SudokuSolver_ParallelBruteForce/3"}
{"code": "for (int i = 0; i < num; i++)\n{\n  COMM_WORLD.Recv(TmpBuff, fix_buf_size, BYTE, rank, data_tag);\n  memcpy(dst + offset, TmpBuff, fix_buf_size);\n  offset += fix_buf_size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/24"}
{"code": "for (size_t i = 0; n != 0; n >>= 1, ++i)\n{\n  if (n & 1)\n    r = crc64_multiply_(r, crc64_x_pow_2n[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/crc64-omp/CRC64/6"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/126"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double res = 0.0;\n  for (int j = 0; j < n; ++j)\n  {\n    res += cos(((pi * (j + 0.5)) * i) / n) * in(j);\n  }\n\n  ret(i) = 2 * res;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/gtests/transforms_test/2"}
{"code": "for (i = bestOffs2 - SCANWIND; i < end; i++)\n{\n  if (i == bestOffs2)\n    continue;\n\n  corr = (float) calcCrossCorr(refPos + (channels * i), pMidBuffer, norm);\n  float tmp = ((float) (((2 * i) - seekLength) - 1)) / ((float) seekLength);\n  corr = (corr + 0.1f) * (1.0f - ((0.25f * tmp) * tmp));\n  if (corr > bestCorr)\n  {\n    bestCorr = corr;\n    bestOffs = i;\n    best = 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/branches/OpenMPT-1.25/include/soundtouch/source/SoundTouch/TDStretch/1"}
{"code": "for (i = 0; i < (maxthreads * (K + 1)); i++)\n{\n  tempweights[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/8"}
{"code": "for (i = 1; i < intervals; i++)\n{\n  x = step * (i + 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nowke/hpc_lab/1_pi_calculation/pi_calculation/0"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/9"}
{"code": "for (int i = 0; i < nIter; i++)\n{\n  double startTime = dsecnd();\n  doMult(size, A, B, C);\n  double endTime = dsecnd();\n  double runtime = endTime - startTime;\n  maxTime = (maxTime > runtime) ? (maxTime) : (runtime);\n  minTime = (minTime < runtime) ? (minTime) : (runtime);\n  aveTime += runtime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/dotMul_IntelXeonPhi/1"}
{"code": "for (i = 0; i < npts; i++)\n{\n  scenereal[i] = fftarr[i * 2];\n  sceneimag[i] = fftarr[(i * 2) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/9"}
{"code": "for (int i = 0; i < ((size / 2) - 1); ++i)\n{\n  if (T[(2 * i) + 1] > T[(2 * i) + 2])\n  {\n    echanger(T, (2 * i) + 1, (2 * i) + 2);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/bubble/1"}
{"code": "for (c1 = 0; c1 <= (((((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) < (nm + (-1))) ? (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nj > nm) ? (nj) : (nm); c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nk > nm) ? (nk) : (nm); c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = (nj > nk) ? (nj) : (nk); c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/1"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    printf(\"%lf\\t\", mat[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/7"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  buildKernel(&program, \"vecdot_load_balance\", &kernel[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/7"}
{"code": "for (int i = 0; i < agents.size(); i++)\n{\n  h_desiredXs[i] = (*agentCUDA).xs[i];\n  h_desiredYs[i] = (*agentCUDA).ys[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hd-zhao-uu/PedestrianSimulation/libpedsim/ped_model/6"}
{"code": "for (i = 0; i < (100 - 1); ++i)\n{\n  if (tmp_count > count)\n  {\n    printf(\"--------------------\\nTestinternal Error: List too small!!!\\n--------------------\\n\");\n    break;\n  }\n\n  if (tids[i] != tids[i + 1])\n  {\n    tmp_count++;\n    tmp[tmp_count] = 1;\n  }\n  else\n  {\n    tmp[tmp_count]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_schedule_dynamic/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  graph->traverseParallel();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/3"}
{"code": "for (int j = 1; j < max_cols; j++)\n{\n  input_itemsets[j] = (rand() % 10) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nw/needle/2"}
{"code": "for (j = 0; j < this->COLS; j++)\n{\n  for (i = 0; i < (this->ROWS - 3); i++)\n  {\n    window.push_back(board[i][j]);\n    window.push_back(board[i + 1][j]);\n    window.push_back(board[i + 2][j]);\n    window.push_back(board[i + 3][j]);\n    score += evaluateWindow(window, player);\n    window.clear();\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(3) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/Board/3"}
{"code": "for (int i = 0; i < smallImageHeight; i++)\n{\n  for (int j = 0; j < (smallImageWidth * 4); j++)\n  {\n    transposeSmallImageMatrix[j][i] = smallImageMatrix[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aksha/Breast-Tumor-Detection/ravicha_ImageSearch/8"}
{"code": "for (int i = 0; i < l; i++)\n{\n  int soma = 0;\n  for (int j = 0; j < l; j++)\n  {\n    for (int k = 0; k < l; k++)\n    {\n      soma = soma + (matriz1[i][k] * matriz2[k][j]);\n    }\n\n    matrizF[i][j] = soma;\n    soma = 0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidInojosa/Project2-Thread/openmp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  first = (i * 800) / size;\n  end = ((i + 1) * 800) / size;\n  MPI_Bcast(&output[first], 2 * (end - first), (MPI_Datatype) 0x4c00080b, i, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_mpi_omp/4"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  tt->indmap[m] = 0;\n  tt->dims[m] = 1 + inds[m][0];\n  for (idx_t i = 1; i < nnz; ++i)\n  {\n    tt->dims[m] = SS_MAX(tt->dims[m], 1 + inds[m][i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/10"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  wijk = ws[i][j][k];\n  wp1 = ws[i][j][k + 1];\n  wm1 = ws[i][j][k - 1];\n  rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n  rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n  rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n  rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n  rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,wijk ,wp1 ,wm1 ,tz2 ,dz1tz1 ,zzcon2 ,dz2tz1 ,dz3tz1 ,c2 ,dz4tz1 ,con43 ,c1 ,zzcon5 ,zzcon3 ,dz5tz1 ,zzcon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/114"}
{"code": "for (i = 0; i < number_of_words; i++)\n{\n  for (j = 0; j < s; j++)\n  {\n    if (strcasecmp(search_words[i], stop_words[j]) == 0)\n    {\n      p = 1;\n      break;\n    }\n    else\n    {\n      p = 2;\n    }\n\n  }\n\n  if (p != 1)\n  {\n    words[k] = search_words[i];\n    k = k + 1;\n  }\n\n}\n\n", "pragma": "omp simd for reduction(+ : k)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/fff/1"}
{"code": "for (int i = 0; i < (kBuckets - 1); i++)\n{\n  tresholds[i] = kLeftBucketBoundary + ((i + 1) * kBucketWidth);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olszewskip/openmp_notes/locks0/1"}
{"code": "for (i = 0; i < uZ.nx; i++)\n{\n  for (j = 0; j < uZ.ny; j++)\n  {\n    if (fabs(uZ(i, j)) < absuzmin)\n      uZ(i, j) = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/15"}
{"code": "for (; i < c1; i++)\n{\n  if ((a1[i].x != a2[i].x) || (a1[i].y != a2[i].y))\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OmarKhaledm21/K-MEANS_Clustering-C_OpenMP-/K_MEANS_CLUSTERING/3"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  aResiduals[v] = 0.0f;\n  workListCurr[v] = 1;\n  workListNext[v] = 0;\n  activeVertices++;\n  degree = vertices->out_degree[v];\n  edge_idx = vertices->edges_idx[v];\n  for (j = edge_idx; j < (edge_idx + degree); j++)\n  {\n    u = EXTRACT_VALUE(sorted_edges_array[j]);\n    if (graph->vertices->out_degree[u])\n      aResiduals[v] += 1.0f / graph->vertices->out_degree[u];\n\n  }\n\n  aResiduals[v] = ((1.0f - stats->damp) * stats->damp) * aResiduals[v];\n}\n\n", "pragma": "omp parallel for private(edge_idx,degree,v,j,u) shared(workListCurr,workListNext,aResiduals) reduction(+:activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/29"}
{"code": "for (i = k + 1; i < n; i++)\n{\n  for (j = k + 1; j < n; j++)\n  {\n    a[i][j] = a[i][j] - (l[i][k] * u[k][j]);\n  }\n\n}\n\n", "pragma": "omp for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp/3"}
{"code": "for (int i = 0, j = 0; i < 10; ++i)\n  c[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/9"}
{"code": "for (int f = 0; f < num_raw_features; ++f)\n  fill(spat_memoiser_valid[f].begin(), spat_memoiser_valid[f].end(), false);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/19"}
{"code": "for (j = 0; j < image->col; j++)\n{\n  omp_set_lock(&mylocks[image->content[i][j]]);\n  histo[image->content[i][j]]++;\n  omp_unset_lock(&mylocks[image->content[i][j]]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_locks/0"}
{"code": "for (i = 0; i < mat; i++)\n  for (j = 0; j < mat; j++)\n{\n  c[i][j] = 0.0;\n  for (k = 0; k < mat; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n}\n\n\n", "pragma": "omp parallel for private(i,j,k,tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/numeric/lib-shared/openMP/mult-mat/0"}
{"code": "for (i = 0; i < count; i++)\n{\n  featuresB[i].x = (float) ((featuresB[i].x * scale[level]) * 0.5);\n  featuresB[i].y = (float) ((featuresB[i].y * scale[level]) * 0.5);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/5"}
{"code": "for (int i = 0; i <= sN; i++)\n  for (int j = 0; j <= _M; j++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (sN / mpi_size)\n    bi = i / (sN / mpi_size);\n\n  if (_M / mpi_size)\n    bj = j / (_M / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = bi - bj;\n  if (st < 0)\n    st += mpi_size;\n\n  st = (st + mpi_rank) % mpi_size;\n  s->rb = st * (K / mpi_size);\n  s->re = s->rb + (K / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = K + 1;\n\n  for (int k = s->rb; k < s->re; k++)\n  {\n    r[idx(i, j, k)] = s->Mat_3d[1][idx(i, j, k)] * x[idx(i, j, k)];\n    if (k != 0)\n      r[idx(i, j, k)] += s->Mat_3d[0][idx(i, j, k)] * x[idx(i, j, k - 1)];\n\n    if (k != K)\n      r[idx(i, j, k)] += s->Mat_3d[2][idx(i, j, k)] * x[idx(i, j, k + 1)];\n\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/144"}
{"code": "for (int numThreads = 2; numThreads <= 10000; numThreads *= 1.5)\n{\n  w_timer = omp_get_wtime();\n  matrix_multiply(numThreads, X, Y, Z);\n  w_timer = ((double) omp_get_wtime()) - w_timer;\n  printf(\"%5d Threads - Execution Time: %0.2lf ms\\n\", numThreads, 1000.0 * w_timer);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/Q4-Matrix-Multiply/2"}
{"code": "for (int i = 0; i <= max_value; i++)\n{\n  for (int j = 1; j <= count[i]; j++)\n  {\n    arr[index++] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gomathi18/parallel-counting-sort/main/2"}
{"code": "for (j1 = 1; j1 < (512 + 1); j1++)\n{\n  for (j2 = j1; j2 < (512 + 1); j2++)\n  {\n    symmat[(j1 * (512 + 1)) + j2] = 0.0;\n    for (i = 1; i < (512 + 1); i++)\n    {\n      symmat[(j1 * (512 + 1)) + j2] += data[(i * (512 + 1)) + j1] * data[(i * (512 + 1)) + j2];\n    }\n\n    symmat[(j2 * (512 + 1)) + j1] = symmat[(j1 * (512 + 1)) + j2];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/COVAR/covariance/6"}
{"code": "for (i = 0; i < h; i++)\n{\n  for (j = 0; j < w; j++)\n  {\n    out.arr[i][j] = ctruncate(((img1.arr[i][j] - 128) * fact) + 128);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for collapse(2) private(i,j) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Images/Ivpomp/8"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_bitonic_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bitonicsort/6"}
{"code": "for (i = 0; i < 100000000; i++)\n  sum += A[i];\n\n", "pragma": "omp parallel for default(shared) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/05-sum-of-array/05_array_sum/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    if (i == j)\n    temp_mat[(i * n) + j] = 0;\n  else\n  {\n    if ((((i == (j + 1)) || (j == (i + 1))) || ((i == 0) && (j == (n - 1)))) || ((i == (n - 1)) && (j == 0)))\n      temp_mat[(i * n) + j] = 1;\n    else\n      temp_mat[(i * n) + j] = n;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Floyd Warshall/MPI_OpenMp/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j - 1][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/12"}
{"code": "for (int i = ST; i < N; i++)\n  argv[0][i] = argv[0][i] - argv[0][i - ST];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/simd_safelen_messages/0"}
{"code": "for (int i = 0; i < ((int) classifier[p].size()); ++i)\n{\n  if ((flag == 1) && (classifier[p][i][0] == 1e9))\n    continue;\n\n  double sim = similarity(v, p, i, flag);\n  if (sim < mx)\n  {\n    mx = sim;\n    cid = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_openmp/3"}
{"code": "for (i = 0; i < row; i++)\n  matrix[i] = malloc((sizeof(int *)) * col);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/sparceMatrix/sparceMatrix_parallel/1"}
{"code": "for (i = 0; i < 800; i++)\n{\n  for (j = 0; j < 800; j++)\n  {\n    B[i][j] = 1 + (rand() % 100);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/drifter1/openmptutorials/Parallel For Loops/advanced_for/2"}
{"code": "for (; (i < (2 * N)) && (j < (2 * N)); i += incX, j += incY)\n{\n  if (((i + j) % 2) == 1)\n  {\n    if ((i % 2) == 1)\n      dot[0] = dot[0] + (x[i] * y[j]);\n    else\n      dot[0] = dot[0] - (x[i] * y[j]);\n\n  }\n  else\n  {\n    dot[1] = dot[1] + (x[i] * y[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/dot/7"}
{"code": "for (i = 0; i < nc; i += 4)\n{\n  tempnrm[pr] += x[i] * x[i];\n  tempnrm[pr] += x[i + 1] * x[i + 1];\n  tempnrm[pr] += x[i + 2] * x[i + 2];\n  tempnrm[pr] += x[i + 3] * x[i + 3];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at2 = (-ci2) * crealf(ffe[j + kk]);\n    at1 = at2 * cimagf(ffe[j + kk]);\n    at2 = at2 * at2;\n    exy[(3 * j) + (3 * kj)] = at1 * dcu[(3 * j) + (3 * kj)];\n    exy[(1 + (3 * j)) + (3 * kj)] = at1 * dcu[(1 + (3 * j)) + (3 * kj)];\n    exy[(2 + (3 * j)) + (3 * kj)] = at1 * dcu[(2 + (3 * j)) + (3 * kj)];\n    exy[(3 * j) + (3 * k1)] = at1 * dcu[(3 * j) + (3 * k1)];\n    exy[(1 + (3 * j)) + (3 * k1)] = at1 * dcu[(1 + (3 * j)) + (3 * k1)];\n    exy[(2 + (3 * j)) + (3 * k1)] = at1 * dcu[(2 + (3 * j)) + (3 * k1)];\n    wp += at2 * ((((((dcu[(3 * j) + (3 * kj)] * conjf(dcu[(3 * j) + (3 * kj)])) + (dcu[(1 + (3 * j)) + (3 * kj)] * conjf(dcu[(1 + (3 * j)) + (3 * kj)]))) + (dcu[(2 + (3 * j)) + (3 * kj)] * conjf(dcu[(2 + (3 * j)) + (3 * kj)]))) + (dcu[(3 * j) + (3 * k1)] * conjf(dcu[(3 * j) + (3 * k1)]))) + (dcu[(1 + (3 * j)) + (3 * k1)] * conjf(dcu[(1 + (3 * j)) + (3 * k1)]))) + (dcu[(2 + (3 * j)) + (3 * k1)] * conjf(dcu[(2 + (3 * j)) + (3 * k1)])));\n  }\n\n  at2 = (-ci2) * crealf(ffe[kk]);\n  at1 = at2 * cimagf(ffe[kk]);\n  at2 = at2 * at2;\n  exy[3 * kj] = at1 * dcu[3 * kj];\n  exy[1 + (3 * kj)] = at1 * dcu[1 + (3 * kj)];\n  exy[2 + (3 * kj)] = at1 * dcu[2 + (3 * kj)];\n  exy[3 * k1] = zero;\n  exy[1 + (3 * k1)] = zero;\n  exy[2 + (3 * k1)] = zero;\n  wp += at2 * (((dcu[3 * kj] * conjf(dcu[3 * kj])) + (dcu[1 + (3 * kj)] * conjf(dcu[1 + (3 * kj)]))) + (dcu[2 + (3 * kj)] * conjf(dcu[2 + (3 * kj)])));\n  sum1 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,at1,at2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/5"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  sum = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    sum = sum + (a[k] * p[colidx[k]]);\n  }\n\n  q[j] = sum;\n}\n\n", "pragma": "omp parallel for private(k) reduction( +:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clement10601/parallel_hw2_openmp/cg/0"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    a[i][j] = a[i][j + 2] + a[i + 1][j - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab8/lab8/1"}
{"code": "for (k = y_min; k <= y_max; k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= x_max; j++)\n  {\n    energy0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = energy1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/reset_field_kernel_c/1"}
{"code": "for (int i = 0; i < size; i += 2 * stride)\n  index[((2 * stride) + i) - 1] = index[((2 * stride) + i) - 1] + index[(stride + i) - 1];\n\n", "pragma": "         #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CanBoran/Fractal-OpenMP/parallel_compact/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  array[i] = polynomial(array[i], poly, degree);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,1024)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/Cuda-Polynomial/polynomial/1"}
{"code": "for (int i = 0; i < N; i++)\n  printf(\"%lf\\n\", x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/koksing456/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/OpenMP/OpenMP/parallel/4"}
{"code": "for (vi = 0; vi < nvtxs; vi++)\n  xaii[vi].end = xaii[vi + 1].start;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/25"}
{"code": "for (i = 1; i <= 10000000; i = i + 1)\n{\n  buyerIndex = rand() % 100000;\n  bidPrice = (rand() % Buyers[buyerIndex].value) + 1;\n  sellerIndex = rand() % 100000;\n  askPrice = Sellers[sellerIndex].value + (rand() % ((20 - Sellers[sellerIndex].value) + 1));\n  if (((Buyers[buyerIndex].quantityHeld == 0) && (Sellers[sellerIndex].quantityHeld == 1)) && (bidPrice >= askPrice))\n  {\n    transactionPrice = askPrice + (rand() % ((bidPrice - askPrice) + 1));\n    Buyers[buyerIndex].price = transactionPrice;\n    Sellers[sellerIndex].price = transactionPrice;\n    Buyers[buyerIndex].quantityHeld = 1;\n    Sellers[sellerIndex].quantityHeld = 0;\n  }\n\n  ;\n}\n\n", "pragma": "omp parallel for private(buyerIndex, bidPrice, sellerIndex, askPrice, transactionPrice) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp2/0"}
{"code": "for (int YIdx = 0; YIdx < PixelsPerMCU; ++YIdx)\n  LoadY(&MCU[YIdx], &input(row, (InputComponentsPerMCU * MCUIdx) + YIdx));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/interpolators/Cr2sRawInterpolator/0"}
{"code": "for (int i = 1; i < (nxn - 1); i++)\n  for (int j = 1; j < (nyn - 1); j++)\n{\n  imageX[i][j][nzn - 2] = vectorX.get(i, j, nzn - 2);\n  imageY[i][j][nzn - 2] = vectorY.get(i, j, nzn - 2);\n  imageZ[i][j][nzn - 2] = vectorZ.get(i, j, nzn - 2) - ((((Ez[i][j][nzn - 2] - (susxz[i][j] * vectorX.get(i, j, nzn - 2))) - (susyz[i][j] * vectorY.get(i, j, nzn - 2))) - (((Jzh[i][j][nzn - 2] * dt) * th) * FourPI)) / suszz[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/98"}
{"code": "for (temp1 = 1; temp1 < 4.1; temp1 += 0.2)\n{\n  scale[count] = pow(2, temp1);\n  printf(\"scale is %f\", scale[count]);\n  count++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0rky/CWT/cwt/1"}
{"code": "for (int j = 1; j < n; j++)\n{\n  for (int i = 1; i < n; i++)\n  {\n    int temp = checkNeighbours(x, i, j);\n    result[i][j] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for shared (n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gokaytitrek/openmp-gameoflife/main/0"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv16_data[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv16_data[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv16[layer16_index];\n    if (conv16_data[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv16_data[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/62"}
{"code": "for (h = 0; h < height; h++)\n{\n  newImage[0][h] = (double *) malloc((width * 3) * (sizeof(double)));\n  newImage[1][h] = (double *) malloc((width * 3) * (sizeof(double)));\n  newImage[2][h] = (double *) malloc((width * 3) * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berkaybarlas/Parallel-Programming/A1/image_filter/image_blurring_parallel/8"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * SAMPLES), stat[i].e2 / ((((double) (L * L)) * (L * L)) * SAMPLES), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/48"}
{"code": "for (i = 0; i < t->size; i++)\n{\n  for (j = 0; j < tB->size; j++)\n  {\n    gsl_matrix_set(xi_mat, i, j, xi_fun(gsl_vector_get(tB, j), gsl_vector_get(M, j), gsl_vector_get(E, j), gsl_vector_get(t, i), cur));\n  }\n\n}\n\n", "pragma": "omp for schedule(static, chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/0"}
{"code": "for (int a = 0; a < n; a++)\n{\n  scanf(\"%d\", &array[a]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab2-Array_Operations/largest_number/0"}
{"code": "for (long i = 0; i <= NV; i++)\n{\n  edgeListPtr[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadPajekFormat/2"}
{"code": "for (int i = 10000 / 2; i < (3 * (10000 / 4)); i++)\n{\n  task1(gl_taskData.intArrays[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p1/task/4"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  row_offset[i + 1] += row_offset[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/37"}
{"code": "for (int i = 0; i < file.height; i++)\n{\n  for (int j = 0; j < file.width; j++)\n  {\n    double kernel = 0;\n    for (int x = max(j - box_r, 0); x < min((j + box_r) + 1, (int) file.width); x++)\n      kernel += file.pixel_map[i][x];\n\n    kernel /= (box_r + box_r) + 1;\n    new_map[i][j] = round(kernel);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FedosCucumber/OpenMPSchedulingTest/main/0"}
{"code": "for (int row = 0; row < board->dimY; row++)\n{\n  for (int col = 0; col < board->dimX; col++)\n  {\n    int val = board->board[(row * board->dimY) + col].val;\n    if (val > Max)\n      Max = val;\n\n    if (val > 1)\n      Total += val;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/3"}
{"code": "for (i = 0; i < ((2048 / NODESX) + 2); i++)\n{\n  for (j = 0; j < ((2048 / NODESY) + 2); j++)\n  {\n    ii = ((((i + j) % 2) * ((2048 / NODESX) + 2)) + i) / 2;\n    if (ii < (((2048 / NODESX) + 2) / 2))\n    {\n      whites[ii][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / NODESY) + 2) - 1)))\n        whites[ii][j].isGhost = 2;\n      else\n        whites[ii][j].isGhost = 1;\n\n    }\n    else\n      if (ii >= (((2048 / NODESX) + 2) / 2))\n    {\n      blacks[ii - (((2048 / NODESX) + 2) / 2)][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / NODESY) + 2) - 1)))\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 2;\n      else\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 1;\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/133"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  if (percentDiff(y[i], y_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/GESUMMV/src/gesummv/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  img[i] = buf[i] >> 4;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mynameisevan3/GaussianBlur/src/c/gauss/1"}
{"code": "for (i = 0; i < 2000; i++)\n  A[i] = 0;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/critical-2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Entrez un element du tableau---------- \\n\");\n  scanf(\"%f\", &tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hermannwilfried694/OpenMP1/max1/1"}
{"code": "for (i = 0; i < NK;)\n{\n  for (j = 0; j < 4000;)\n  {\n    B[i][j] = ((((double) i) * j) + 1) / 4000;\n    j++;\n  }\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdruix/OMP2MPI/trans/test/5"}
{"code": "for (int i = 0; i < size; ++i)\n  for (int k = 0; k < size; ++k)\n  for (int j = 0; j < size; ++j)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "omp parallel for default(none) shared(A,B,C,size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/weiwangudel/RCRdaemon-MIC/test_MICEnergyStat_OpenMPoffload_matrix/matrix/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  indices[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/URAmiRBin/cuda-determinant/Source Codes/PARALLEL 1/OPENMP Project/Source/4"}
{"code": "for (int i = 0; i < width; ++i)\n{\n  for (int j = 0; j < height; ++j)\n  {\n    output(i, j)->Red = res_col[i][j][0] * RGBV;\n    output(i, j)->Green = res_col[i][j][1] * RGBV;\n    output(i, j)->Blue = res_col[i][j][2] * RGBV;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wingszero/Monte_Carlo_RayTracer/Monte_Carlo_Raytracer/SceneGraph/src/ray_trace/1"}
{"code": "for (int r = lr - 1, c = lc + 1; ((r >= 0) && (c < 7)) && (this->board[r][c] == player); --r, ++c)\n{\n  down++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_root/8"}
{"code": "for (int i = 0; i < MAX_ROWS; ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    _itoa_s(sortedAll[(i * MAX_COLS) + j], numString, 10);\n    int k = 0;\n    char temp = numString[k];\n    while (temp != '\\0')\n    {\n      output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + k] = temp;\n      temp = numString[++k];\n    }\n\n    output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + MAX_CHARS] = '\\t';\n  }\n\n  output[(i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (MAX_COLS * (MAX_CHARS + 1))] = '\\n';\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic, 100) firstprivate(numString) shared(data)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BlurEffect/OpenMP/OpenMPAssignment/02_Sortout_Parallel_For/5"}
{"code": "for (i = 0; i <= length; i++)\n{\n  S[i] = B[i];\n  if (0 != S[i])\n    D[i] = 1;\n  else\n    D[i] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/C/ass3-openmp/3"}
{"code": "for (int i = -1000; i < 1000; i += 3)\n  total += (5 * i) * i;\n\n", "pragma": "omp for schedule(dynamic) reduction(+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonibofarull/mini-openmp/miniomp/test/tfinal/3"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  *(array->tab + i) = rand() % N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/19"}
{"code": "for (index = 0; index < (1 * (SIMD_COEF_32 * 1)); index++)\n  memcpy(saved_key[index], salt, 16 * 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/9"}
{"code": "for (int j = 0; j < cols; j++)\n{\n  jW[j] = j - 1;\n  jE[j] = j + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_srad/srad_v2/srad/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"a[%d] = %d, threadID = %d\\n\", i, a[i], omp_get_thread_num());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/18"}
{"code": "for (i = 0; i < nx; ++i)\n{\n  for (j = 0; j < ny; ++j)\n  {\n    P(i, j) += ((dt / f.u.dx) * (U(i + 1, j) - U(i, j))) + ((dt / f.v.dy) * (V(i, j + 1) - V(i, j)));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/octol/paryee/src/yee_naive_omp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  p[i] = v1[i] * v2[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/tests/omp4/target-test/0"}
{"code": "for (i = 0; i < nygrid; i++)\n  free(dummymask[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/100"}
{"code": "for (int i = 0; i < (NUM_WORDS / 2); i++)\n{\n  printf(\"output[%02d] = %5.2f | %5.2f\\n\", i, output[2 * i], output[(2 * i) + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/fft/sw/src/main/5"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (j = 0; j < ny; j++)\n    {\n      flux[j][0] = rsd[k][j][i][2];\n      u31 = rsd[k][j][i][2] / rsd[k][j][i][0];\n      q = (0.50 * (((rsd[k][j][i][1] * rsd[k][j][i][1]) + (rsd[k][j][i][2] * rsd[k][j][i][2])) + (rsd[k][j][i][3] * rsd[k][j][i][3]))) / rsd[k][j][i][0];\n      flux[j][1] = rsd[k][j][i][1] * u31;\n      flux[j][2] = (rsd[k][j][i][2] * u31) + (C2 * (rsd[k][j][i][4] - q));\n      flux[j][3] = rsd[k][j][i][3] * u31;\n      flux[j][4] = ((C1 * rsd[k][j][i][4]) - (C2 * q)) * u31;\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (ty2 * (flux[j + 1][m] - flux[j - 1][m]));\n      }\n\n    }\n\n    for (j = jst; j < ny; j++)\n    {\n      tmp = 1.0 / rsd[k][j][i][0];\n      u21j = tmp * rsd[k][j][i][1];\n      u31j = tmp * rsd[k][j][i][2];\n      u41j = tmp * rsd[k][j][i][3];\n      u51j = tmp * rsd[k][j][i][4];\n      tmp = 1.0 / rsd[k][j - 1][i][0];\n      u21jm1 = tmp * rsd[k][j - 1][i][1];\n      u31jm1 = tmp * rsd[k][j - 1][i][2];\n      u41jm1 = tmp * rsd[k][j - 1][i][3];\n      u51jm1 = tmp * rsd[k][j - 1][i][4];\n      flux[j][1] = ty3 * (u21j - u21jm1);\n      flux[j][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[j][3] = ty3 * (u41j - u41jm1);\n      flux[j][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      frct[k][j][i][0] = frct[k][j][i][0] + ((dy1 * ty1) * ((rsd[k][j - 1][i][0] - (2.0 * rsd[k][j][i][0])) + rsd[k][j + 1][i][0]));\n      frct[k][j][i][1] = (frct[k][j][i][1] + (((ty3 * C3) * C4) * (flux[j + 1][1] - flux[j][1]))) + ((dy2 * ty1) * ((rsd[k][j - 1][i][1] - (2.0 * rsd[k][j][i][1])) + rsd[k][j + 1][i][1]));\n      frct[k][j][i][2] = (frct[k][j][i][2] + (((ty3 * C3) * C4) * (flux[j + 1][2] - flux[j][2]))) + ((dy3 * ty1) * ((rsd[k][j - 1][i][2] - (2.0 * rsd[k][j][i][2])) + rsd[k][j + 1][i][2]));\n      frct[k][j][i][3] = (frct[k][j][i][3] + (((ty3 * C3) * C4) * (flux[j + 1][3] - flux[j][3]))) + ((dy4 * ty1) * ((rsd[k][j - 1][i][3] - (2.0 * rsd[k][j][i][3])) + rsd[k][j + 1][i][3]));\n      frct[k][j][i][4] = (frct[k][j][i][4] + (((ty3 * C3) * C4) * (flux[j + 1][4] - flux[j][4]))) + ((dy5 * ty1) * ((rsd[k][j - 1][i][4] - (2.0 * rsd[k][j][i][4])) + rsd[k][j + 1][i][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][1][i][m] = frct[k][1][i][m] - (dssp * ((((+5.0) * rsd[k][1][i][m]) - (4.0 * rsd[k][2][i][m])) + rsd[k][3][i][m]));\n      frct[k][2][i][m] = frct[k][2][i][m] - (dssp * (((((-4.0) * rsd[k][1][i][m]) + (6.0 * rsd[k][2][i][m])) - (4.0 * rsd[k][3][i][m])) + rsd[k][4][i][m]));\n    }\n\n    for (j = 3; j < (ny - 3); j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (dssp * ((((rsd[k][j - 2][i][m] - (4.0 * rsd[k][j - 1][i][m])) + (6.0 * rsd[k][j][i][m])) - (4.0 * rsd[k][j + 1][i][m])) + rsd[k][j + 2][i][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][ny - 3][i][m] = frct[k][ny - 3][i][m] - (dssp * (((rsd[k][ny - 5][i][m] - (4.0 * rsd[k][ny - 4][i][m])) + (6.0 * rsd[k][ny - 3][i][m])) - (4.0 * rsd[k][ny - 2][i][m])));\n      frct[k][ny - 2][i][m] = frct[k][ny - 2][i][m] - (dssp * ((rsd[k][ny - 4][i][m] - (4.0 * rsd[k][ny - 3][i][m])) + (5.0 * rsd[k][ny - 2][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/erhs/3"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/51"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i][j + 1][k] = lhs[0][i][j + 1][k] + comz1;\n    lhs[1][i][j + 1][k] = lhs[1][i][j + 1][k] - comz4;\n    lhs[2][i][j + 1][k] = lhs[2][i][j + 1][k] + comz5;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/67"}
{"code": "for (i = 0; i < (thread_num - 1); i++)\n{\n  tmp1 = begin[i] + num_per_thread;\n  end[i] = tmp1;\n  begin[i + 1] = tmp1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/PAC2020/main/0"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  register double ty1 = 0;\n  register double ty2 = 0;\n  register double ty3 = 0;\n  register double ty4 = 0;\n  for (j = 0; j < n; j += 2)\n  {\n    register double t0 = x[j];\n    register double t1 = x[j + 1];\n    register int n2 = 2 * n;\n    register int n3 = 3 * n;\n    k = (i * n) + j;\n    ty1 += (a[k] * t0) + (a[k + 1] * t1);\n    ty2 += (a[k + n] * t0) + (a[(k + 1) + n] * t1);\n    ty3 += (a[k + n2] * t0) + (a[(k + 1) + n2] * t1);\n    ty4 += (a[k + n3] * t0) + (a[(k + 1) + n3] * t1);\n  }\n\n  y[i] = ty1;\n  y[i + 1] += ty2;\n  y[i + 2] += ty3;\n  y[i + 3] += ty4;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_13/mat_vec_row_omp/mat_vec/0"}
{"code": "for (i = 0; i < g->nvertex; i++)\n{\n  if (g->vertex[i].color > max)\n    max = g->vertex[i].color;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michaelwjk/Parallel-graph-coloring/parallel/parallel/5"}
{"code": "for (j = 1; j < (n - 1); j++)\n{\n  for (i = 1; i < (m - 1); i++)\n  {\n    Anew[(j * m) + i] = 0.25 * (((A[(j * m) + (i + 1)] + A[(j * m) + (i - 1)]) + A[((j - 1) * m) + i]) + A[((j + 1) * m) + i]);\n    err = fmax(err, fabs(Anew[(j * m) + i] - A[(j * m) + i]));\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for reduction(max:err) schedule(nonmonotonic:static,1) map(to:A[0:n*m]) map(from:Anew[0:n*m], err)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-4/jacobi-gpu/task1_basic/jacobi.sol/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][1][m] = rsd[i][j][1][m] - (dssp * ((((+5.0) * u[i][j][1][m]) - (4.0 * u[i][j][2][m])) + u[i][j][3][m]));\n  rsd[i][j][2][m] = rsd[i][j][2][m] - (dssp * (((((-4.0) * u[i][j][1][m]) + (6.0 * u[i][j][2][m])) - (4.0 * u[i][j][3][m])) + u[i][j][4][m]));\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/120"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  memcpy(layer_outputs[0] + (s * nodes_per_layer[0]), inputs[s], (sizeof(double)) * nodes_per_layer[0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU7/4"}
{"code": "for (int i = 0; i < input->nRegions; i++)\n{\n  for (int j = 0; j < input->nCities; j++)\n  {\n    measures->city[i][0][j] = find_min(regions[i][j], input->nStudents);\n  }\n\n  measures->region[0][i] = find_min_double(measures->city[i][0], input->nCities);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/0"}
{"code": "for (j = 0; j <= i; j++)\n{\n  cl[j + i] = cl[j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/6"}
{"code": "for (frame_num = 1; frame_num <= Nf; frame_num++)\n{\n  printf(\"\\rProcessing frame %d / %d\", frame_num, Nf);\n  fflush(stdout);\n  MAT *I = get_frame(video, frame_num, 0, 1);\n  int Ih = I->m;\n  int Iw = I->n;\n  for (i = 0; i < Nc; i++)\n  {\n    xc[i][frame_num] = xc[i][frame_num - 1];\n    yc[i][frame_num] = yc[i][frame_num - 1];\n    for (j = 0; j < Np; j++)\n    {\n      r[i][j][frame_num] = r[i][j][frame_num - 1];\n    }\n\n  }\n\n  for (cell_num = 0; cell_num < Nc; cell_num++)\n  {\n    double xci = xc[cell_num][frame_num];\n    double yci = yc[cell_num][frame_num];\n    double *ri = (double *) malloc((sizeof(double)) * Np);\n    for (j = 0; j < Np; j++)\n    {\n      ri[j] = r[cell_num][j][frame_num];\n    }\n\n    double ycavg = 0.0;\n    for (i = (frame_num > 10) ? (frame_num - 10) : (0); i < frame_num; i++)\n    {\n      ycavg += yc[cell_num][i];\n    }\n\n    ycavg = ycavg / ((double) ((frame_num > 10) ? (10) : (frame_num)));\n    int u1 = max((xci - (4.0 * R)) + 0.5, 0);\n    int u2 = min((xci + (4.0 * R)) + 0.5, Iw - 1);\n    int v1 = max((yci - (2.0 * R)) + 1.5, 0);\n    int v2 = min((yci + (2.0 * R)) + 1.5, Ih - 1);\n    MAT *Isub = m_get((v2 - v1) + 1, (u2 - u1) + 1);\n    for (i = v1; i <= v2; i++)\n    {\n      for (j = u1; j <= u2; j++)\n      {\n        m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n      }\n\n    }\n\n    MAT *Ix = gradient_x(Isub);\n    MAT *Iy = gradient_y(Isub);\n    MAT *IE = m_get(Isub->m, Isub->n);\n    for (i = 0; i < Isub->m; i++)\n    {\n      for (j = 0; j < Isub->n; j++)\n      {\n        double temp_x = m_get_val(Ix, i, j);\n        double temp_y = m_get_val(Iy, i, j);\n        m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n      }\n\n    }\n\n    long long MGVF_start_time = get_time();\n    MAT *IMGVF = MGVF(IE, 1, 1);\n    MGVF_time += get_time() - MGVF_start_time;\n    xci = xci - ((double) u1);\n    yci = yci - ((double) (v1 - 1));\n    ycavg = ycavg - ((double) (v1 - 1));\n    long long snake_start_time = get_time();\n    ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n    snake_time += get_time() - snake_start_time;\n    xci = xci + u1;\n    yci = yci + (v1 - 1);\n    xc[cell_num][frame_num] = xci;\n    yc[cell_num][frame_num] = yci;\n    for (j = 0; j < Np; j++)\n    {\n      r[cell_num][j][frame_num] = ri[j];\n      x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n      y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n    }\n\n    m_free(IMGVF);\n    free(ri);\n  }\n\n  if (frame_num == Nf)\n  {\n    FILE *pFile;\n    pFile = fopen(\"result.txt\", \"w+\");\n    for (cell_num = 0; cell_num < Nc; cell_num++)\n      fprintf(pFile, \"\\n%d,%f,%f\", cell_num, xc[cell_num][Nf], yc[cell_num][Nf]);\n\n    fclose(pFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/openmp/leukocyte/OpenMP/track_ellipse/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, Q, (MPI_Datatype) 0x4c000406, T, Q, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/57"}
{"code": "for (int i = 0; i < N; i++)\n  data[i].data[0] = drand48();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/08_quicksort.v0/5"}
{"code": "for (int i = 0; i < K; i++)\n  omp_init_lock(&Mutex[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanRadulescu962/ProjectAPP/OpenMP/tema/2"}
{"code": "for (int j = 0; j < mode; ++j)\n  printf(\"%d\", (j + 1) % 10);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/41"}
{"code": "for (i = 0; i < cache->num_buckets; ++i)\n{\n  cache->thresholds_avgDegrees[i] = quantize_8(thresholds_avgDegrees[i], rDivD_params.scale, rDivD_params.zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/42"}
{"code": "for (i = 0; i < 2; i++)\n{\n  cdata[i] = malloc(ncolumns * (sizeof(double)));\n  cmask[i] = malloc(ncolumns * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/123"}
{"code": "for (unsigned i = 0; i < n; i++)\n{\n  for (long j = 0; j < load; j++)\n    sum += i + j;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp-benchmarks/src/benchmark/benchmark/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  im1 = i - 1;\n  ip1 = i + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n}\n\n", "pragma": "omp parallel for firstprivate(dx1tx1 ,tx2 ,dx2tx1 ,xxcon1 ,c2 ,dx3tx1 ,xxcon2 ,dx4tx1 ,dx5tx1 ,xxcon5 ,xxcon4 ,xxcon3 ,c1 ,i ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/17"}
{"code": "for (i = 0; i < (n + 1); i++)\n{\n  arr1[i] += arr2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artalukd/ParallelEdgeReverse/reverse/2"}
{"code": "for (int i = 1; i < m; i++)\n{\n  for (int j = s + 1; j < (m + 1); j++)\n  {\n    ind[j] += tmp[s];\n  }\n\n  s++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/netweel/Parallel-programming-OpenMP_TBB_std-thread/OpenMP/umnrazr/4"}
{"code": "for (i = 1; i < num_thread; i++)\n{\n  rng[i] = gsl_rng_alloc(rng_t);\n  gsl_rng_set(rng[i], gsl_rng_get(rand));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/10"}
{"code": "for (int j = 1; j < wf.n2; j++)\n{\n  if (abs(wf.x2[j]) < x_SI)\n  {\n    psi_right[index] = wf.wave[wf.in2(j, i_right)];\n    psi_left[index] = wf.wave[wf.in2(j, i_left)];\n    index += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/37"}
{"code": "for (i = 0; i < n; i++)\n{\n  A[i] = (float) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/11"}
{"code": "for (int i = 0; i < numChunks; i++)\n{\n  for (k = 0; k < chunk; k++)\n  {\n    x = ((double) rand()) / ((double) RAND_MAX);\n    y = ((double) rand()) / ((double) RAND_MAX);\n    x = x * r;\n    y = y * r;\n    if (((x * x) + (y * y)) < (r * r))\n    {\n      c++;\n    }\n\n  }\n\n}\n\n", "pragma": "          #pragma omp parallel for shared(numChunks, chunk, l) reduction(+:c) private(k, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laurasgm/HPC-Needles-Dartboard-openMP/dartboard-openMP/0"}
{"code": "for (i = 1; i <= H_aux; i++)\n{\n  for (j = 1; j <= W_aux; j++)\n    fprintf(f_out, \"%d \", harta[i][j]);\n\n  fprintf(f_out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anaMirela/Tema1-APD/tema1/9"}
{"code": "for (int i = 0; i < TOTAL_COLUMN; i++)\n{\n  int x = col_data[i].size();\n  for (int j = 0; j < x; j++)\n  {\n    itr = col_data[i][j];\n    row_data[itr.x][row_pointers[itr.x]].y = itr.y;\n    row_data[itr.x][row_pointers[itr.x]].x = i;\n    temp_row_data[itr.x][row_pointers[itr.x]].x = i;\n    row_pointers[itr.x]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/13"}
{"code": "for (i = 0; i < Core_N; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    fprintf(fcore, \"%d\\t\", CorePermu[pos++]);\n  }\n\n  fprintf(fcore, \"%e\\n\", CoreTensor[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/15"}
{"code": "for (unsigned p = 0; p < GA_POPULATION; p++)\n{\n  printf(\"\\nPrinting fitness for chromosome %i: %f\", p, Fitness[p]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feildawproton/Genetic-Algorithm-with-OpenMP/GA/GA/9"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float nodeIncomingPR = 0.0f;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    u = Nodes->edges_array_dest[j];\n    nodeIncomingPR += riDividedOnDiClause[u];\n  }\n\n  pageRanksNext[v] = nodeIncomingPR;\n}\n\n", "pragma": "omp parallel for reduction(+ : error_total,activeVertices) private(v,j,u,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/31"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  for (int is = 0; is < ns; is++)\n  {\n    if (DriftSpecies[is])\n      rhons[is][i][j][k] = (rhoINIT[is] / (cosh((grid->getYN(i, j, k) - (Ly / 2)) / delta) * cosh((grid->getYN(i, j, k) - (Ly / 2)) / delta))) / FourPI;\n    else\n      rhons[is][i][j][k] = rhoINIT[is] / FourPI;\n\n  }\n\n  Ex[i][j][k] = 0.0;\n  Ey[i][j][k] = 0.0;\n  Ez[i][j][k] = 0.0;\n  Bxn[i][j][k] = B0x * tanh((grid->getYN(i, j, k) - (Ly / 2)) / delta);\n  Byn[i][j][k] = B0y;\n  Bzn[i][j][k] = B0z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/74"}
{"code": "for (k = 0; k < m3[lt]; k++)\n{\n  unsigned long int _imopVarPre203;\n  void *_imopVarPre204;\n  _imopVarPre203 = m2[lt] * (sizeof(double *));\n  _imopVarPre204 = malloc(_imopVarPre203);\n  v[k] = (double **) _imopVarPre204;\n  for (j = 0; j < m2[lt]; j++)\n  {\n    unsigned long int _imopVarPre207;\n    void *_imopVarPre208;\n    _imopVarPre207 = m1[lt] * (sizeof(double));\n    _imopVarPre208 = malloc(_imopVarPre207);\n    v[k][j] = (double *) _imopVarPre208;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/3"}
{"code": "for (i = 0; i < (lDIM * nDIM); i++)\n  free(b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/12"}
{"code": "for (int i = 1; i < n; i++)\n{\n  y += 2 * f(a + (dy * i));\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:y) num_threads(8)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/2_openmp/0"}
{"code": "for (k = klo; k < khi; k++)\n{\n  for (j = jlo; j < jhi; j++)\n  {\n    for (i = ilo + ((((ilo ^ j) ^ k) ^ color000) & 1); i < ihi; i += 2)\n    {\n      int ijk = (i + (j * jStride)) + (k * kStride);\n      double Ax = apply_op_ijk(x_n);\n      double lambda = Dinv_ijk();\n      x_np1[ijk] = x_n[ijk] + (lambda * (rhs[ijk] - Ax));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for if(num_my_blocks >= GPU_THRESHOLD && GPU_OFFLOAD_ENABLE && GPU_ENABLE_SMOOTHER)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/gsrb/0"}
{"code": "for (int i = domain_localRowMin; i < domain_localRowMax; i++)\n{\n  for (int j = 0; j < xmatrix->iia[i]; j++)\n  {\n    xmatrix->val[i][j] *= scalar;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMath/3"}
{"code": "for (unsigned i = 0; i < N; ++i)\n  res = X[i] * Y[i];\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/penzn/omp-wasi-parallel/openmp-offload/dot/0"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double sumRealNew = 0.0;\n  double sumImaginaryNew = 0.0;\n  for (uint m = 0; m < newMol.size(); m++)\n  {\n    uint newMoleculeIndex = molIndexNew[m];\n    double lambdaCoef = GetLambdaCoef(newMoleculeIndex, box);\n    for (uint p = 0; p < lengthNew; ++p)\n    {\n      unsigned long currentAtom = mols.MolStart(newMoleculeIndex) + p;\n      if (particleHasNoCharge[currentAtom])\n      {\n        continue;\n      }\n\n      double dotProductNew = Dot(p, kxRef[box][i], kyRef[box][i], kzRef[box][i], newMol[m].GetCoords());\n      sumRealNew += (thisKindNew.AtomCharge(p) * lambdaCoef) * cos(dotProductNew);\n      sumImaginaryNew += (thisKindNew.AtomCharge(p) * lambdaCoef) * sin(dotProductNew);\n    }\n\n  }\n\n  for (uint m = 0; m < oldMol.size(); m++)\n  {\n    uint oldMoleculeIndex = molIndexOld[m];\n    double lambdaCoef = GetLambdaCoef(oldMoleculeIndex, box);\n    for (uint p = 0; p < lengthOld; ++p)\n    {\n      unsigned long currentAtom = mols.MolStart(oldMoleculeIndex) + p;\n      if (particleHasNoCharge[currentAtom])\n      {\n        continue;\n      }\n\n      double dotProductOld = Dot(p, kxRef[box][i], kyRef[box][i], kzRef[box][i], oldMol[m].GetCoords());\n      sumRealNew -= (thisKindOld.AtomCharge(p) * lambdaCoef) * cos(dotProductOld);\n      sumImaginaryNew -= (thisKindOld.AtomCharge(p) * lambdaCoef) * sin(dotProductOld);\n    }\n\n  }\n\n  if (first_call)\n  {\n    sumRnew[box][i] = sumRref[box][i] + sumRealNew;\n    sumInew[box][i] = sumIref[box][i] + sumImaginaryNew;\n  }\n  else\n  {\n    sumRnew[box][i] += sumRealNew;\n    sumInew[box][i] += sumImaginaryNew;\n  }\n\n  energyRecipNew += ((sumRnew[box][i] * sumRnew[box][i]) + (sumInew[box][i] * sumInew[box][i])) * prefactRef[box][i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(box, first_call, lengthNew, lengthOld, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/15"}
{"code": "for (j = 0; j < limit; j++)\n{\n  nMis = 0;\n  for (i = 0; i < n; i++)\n  {\n    afterSign = sign(f(o.w, pointsArr[i]));\n    error = pointsArr[i].groupIdentifier - afterSign;\n    if (!(error == 0))\n    {\n      nMis += 1;\n      algorithmTraining(k, pointsArr[i], o.w, *alpha, pointsArr[i].groupIdentifier, t);\n    }\n\n  }\n\n  q = ((double) nMis) / ((double) n);\n  if ((q < (*qc)) && (q < o.q))\n  {\n    o.q = q;\n    o.t = t;\n    return o;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/PerceptronAlgorithm/3"}
{"code": "for (i = 0; i < n; i++)\n  newArr[i] = arr[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/raul4247/openmpSortings/OddEvenSort/oddEvenSort/7"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  sum = 0;\n  for (int j = 0; j < dim; j++)\n    sum += A[i][j] * x[j];\n\n  sum -= b;\n  tol += sum * sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/9"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  var++;\n}\n\n", "pragma": "omp teams distribute parallel for reduction(+:var)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB145-atomiccritical-orig-gpu-no/0"}
{"code": "for (long idx = 0; idx < NUM_SLICES; idx++)\n{\n  tmp = idx;\n  {\n    res += tmp;\n    printf(\"tmp = %ld\\r\\n\", tmp);\n  }\n}\n\n", "pragma": "\t\t#pragma omp for ordered reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex4_5_ordered/0"}
{"code": "for (int i = 0; i < 1000000000; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/medasuryatej/advanced_parallel_computation/sum_of_n_numbers/compute_sum/4"}
{"code": "for (ptrdiff_t i = 0; i < (i_size * j_size); ++i)\n{\n  *(data_ + i) = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/0"}
{"code": "for (int x = 0; x < 4; ++x)\n{\n  for (int i = 1; i <= 16; ++i)\n  {\n    operation(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shumbul/High-Performance-Computing/Parallel-Computing-openMP/prog6/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/29"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);\n  startTime = omp_get_wtime();\n  convertToYCbCr_omp(image, 4);\n  duration = omp_get_wtime() - startTime;\n  (logs << duration) << \"\\n\";\n  (((cout << \"FINISHED. Conversion WITH OpenMP, simple and 4 threads took \") << duration) << \" seconds.\") << endl;\n  if (i == 9)\n    imwrite(\"converted_omp_4.png\", image);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/3"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = (alpha * this->vec_[i]) + cast_x->vec_[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/14"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n    printf(\"%d \", matA[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/smm/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (k = 3; k < (nz - 3); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[m][k][j][i] = rtmp_G[m][j][i][k] - (dssp * ((((utmp_G[m][j][i][k - 2] - (4.0 * utmp_G[m][j][i][k - 1])) + (6.0 * utmp_G[m][j][i][k])) - (4.0 * utmp_G[m][j][i][k + 1])) + utmp_G[m][j][i][k + 2]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/rhs/20"}
{"code": "for (i = 0; i < ndevs; i++)\n{\n  *result += device_result[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/sum/sum_ompacc/2"}
{"code": "for (intptr_t i = 0; i <= N; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/sum/sum_reduction/0"}
{"code": "for (int i = 1; i <= Nnode; ++i)\n{\n  NIA[i] += NIA[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lovgager/parallel-methods/FirstTask/FirstTask/3"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  sequence[i] = 256 * fastPow(0.707106781, i);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PaletiKrishnasai/High-Performance-Computing/DesignActivity1/Q3_1/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x = ((-1.0) + (i * delta)) + (delta * 0.5);\n  for (int j = 0; j < N; j++)\n  {\n    y = ((-1.0) + (j * delta)) + (delta * 0.5);\n    u = U[(i * N) + j];\n    fprintf(matrix, \"%g\\t%g\\t%g\\n\", x, y, u);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anderslaunerbaek/HPC/projects/assign_2/func/2"}
{"code": "for (i = 0; i < layer->nbNodes; i++)\n{\n  layer->value[i] /= sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/19"}
{"code": "for (i = 0; i < 750; i++)\n{\n  for (j = 0; j < 750; j++)\n  {\n    C[(i * 750) + j] = (((DATA_TYPE) i) * (j + 3)) / 750;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm_cpu/4"}
{"code": "for (int i = 0; i < width_; i++)\n{\n  for (int j = 0; j < height_; j++)\n  {\n    if (grid_cell_[(i * width_) + j]->organism_ != nullptr)\n    {\n      living_one++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nathan-K-/PC-optimisation/src/World/3"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  size_t ii = i % cX;\n  size_t jj = i / cX;\n  if (ii < jj)\n    continue;\n\n  double *X = X0 + (ii * rX);\n  double *Y = Y0 + (jj * rY);\n  double cc = 0.0;\n  size_t nn = 0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    cc += z;\n    nn++;\n  }\n\n  size_t j = jj + (ii * cX);\n  CC[i] = cc;\n  CC[j] = cc;\n  if (NN != NULL)\n  {\n    NN[i] = (double) nn;\n    NN[j] = (double) nn;\n  }\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/4"}
{"code": "for (int bx = 0; bx < bound; bx++)\n{\n  int by = d - bx;\n  if ((by >= grid_height) || (!mustContinue()))\n    continue;\n\n  alignBlock(bx, by);\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edanssandes/MASA-OpenMP/masa-openmp-1.0.1.1024/src/OpenMPAligner/0"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if (m_rchID[i] > 0)\n  {\n    m_usleC[i] = 0.f;\n    continue;\n  }\n\n  m_usleC[i] = m_aveAnnUsleC[i];\n  if ((m_aveAnnUsleC[i] < 1.e-4f) || FloatEqual(m_aveAnnUsleC[i], NODATA_VALUE))\n  {\n    m_aveAnnUsleC[i] = 0.001f;\n  }\n\n  if ((nullptr != m_rsdCovSoil) && (nullptr != m_landCover))\n  {\n    m_aveAnnUsleC[i] = log(m_aveAnnUsleC[i]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/SERO_MUSLE/SoilErosion_MUSLE/1"}
{"code": "for (partId = 0; partId < CLOMP_numParts; partId++)\n{\n  Zone *zoneArray;\n  Zone *zone;\n  int zoneId;\n  zoneArray = (Zone *) malloc(CLOMP_zoneSize * CLOMP_zonesPerPart);\n  if (zoneArray == ((Zone *) 0))\n  {\n    fprintf(stderr, \"Out of memory allocate zone array\\n\");\n    exit(1);\n  }\n\n  for (zoneId = 0; zoneId < CLOMP_zonesPerPart; zoneId++)\n  {\n    zone = &zoneArray[zoneId];\n    addZone(partArray[partId], zone);\n  }\n\n}\n\n", "pragma": "omp parallel for private(partId) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp/2"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n    sgraphs[color[j]]->rowptr[i]++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/24"}
{"code": "for (i = T_bench; i < T_last; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/8"}
{"code": "for (int j = 0; j < real_subarray_size; j++)\n{\n  tab[((size - offset) - real_subarray_size) + j] = sub_tablo->tab[j + real_subarray_size] + previous_max_suffix;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/3"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  dest_num = i % comm_size;\n  if (dest_num == MASTER_PROC_RANK)\n  {\n    master_seq_nums[tmp_i++] = i;\n    continue;\n  }\n\n  MPI_Send(m_arrays[i], command_line_args.seq_len, MPI_DOUBLE, dest_num, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/5"}
{"code": "for (i = 1; i < (M + 1); i++)\n{\n  for (j = 1; j < (N + 1); j++)\n  {\n    data[(i * (N + 1)) + j] = (((DATA_TYPE) i) * j) / M;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/COVAR/covariance/3"}
{"code": "for (int i = start; i < (start + half); ++i)\n{\n  compare(tab, i, i + half, direction);\n}\n\n", "pragma": "omp parallel for shared(half, tab, start, direction)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pangoso/OpenMP-Bitonic-Sort/bitonic_sort_par/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n{\n  A[i][j] = ((DATA_TYPE) (i + j)) / nj;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/convolution-2d/convolution-2d/1"}
{"code": "for (c1 = 0; c1 <= (n + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (n + (-1)); c2++)\n  {\n    A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n    B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB055-jacobi2d-parallel-no/0"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n    }\n\n  }\n\n  L2 = nx - 1;\n  for (i = ist; i <= L2; i++)\n  {\n    tmp = 1.0 / u[i][j][k][0];\n    u21i = tmp * u[i][j][k][1];\n    u31i = tmp * u[i][j][k][2];\n    u41i = tmp * u[i][j][k][3];\n    u51i = tmp * u[i][j][k][4];\n    tmp = 1.0 / u[i - 1][j][k][0];\n    u21im1 = tmp * u[i - 1][j][k][1];\n    u31im1 = tmp * u[i - 1][j][k][2];\n    u41im1 = tmp * u[i - 1][j][k][3];\n    u51im1 = tmp * u[i - 1][j][k][4];\n    flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n    flux[i][j][k][2] = tx3 * (u31i - u31im1);\n    flux[i][j][k][3] = tx3 * (u41i - u41im1);\n    flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * (((pow2(u21i) + pow2(u31i)) + pow2(u41i)) - ((pow2(u21im1) + pow2(u31im1)) + pow2(u41im1)))) + (((1.0 / 6.0) * tx3) * (pow2(u21i) - pow2(u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n  }\n\n  for (i = ist; i <= iend; i++)\n  {\n    rsd[i][j][k][0] = rsd[i][j][k][0] + ((dx1 * tx1) * ((u[i - 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i + 1][j][k][0]));\n    rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((u[i - 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i + 1][j][k][1]));\n    rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((u[i - 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i + 1][j][k][2]));\n    rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((u[i - 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i + 1][j][k][3]));\n    rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((u[i - 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i + 1][j][k][4]));\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[1][j][k][m] = rsd[1][j][k][m] - (dssp * ((((+5.0) * u[1][j][k][m]) - (4.0 * u[2][j][k][m])) + u[3][j][k][m]));\n    rsd[2][j][k][m] = rsd[2][j][k][m] - (dssp * (((((-4.0) * u[1][j][k][m]) + (6.0 * u[2][j][k][m])) - (4.0 * u[3][j][k][m])) + u[4][j][k][m]));\n  }\n\n  ist1 = 3;\n  iend1 = nx - 4;\n  for (i = ist1; i <= iend1; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n    }\n\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[nx - 3][j][k][m] = rsd[nx - 3][j][k][m] - (dssp * (((u[nx - 5][j][k][m] - (4.0 * u[nx - 4][j][k][m])) + (6.0 * u[nx - 3][j][k][m])) - (4.0 * u[nx - 2][j][k][m])));\n    rsd[nx - 2][j][k][m] = rsd[nx - 2][j][k][m] - (dssp * ((u[nx - 4][j][k][m] - (4.0 * u[nx - 3][j][k][m])) + (5.0 * u[nx - 2][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/69"}
{"code": "for (m = 0; m < ks; m = m + inc)\n{\n  xs[m] = ys[m];\n  xs[m + 1] = ys[m + 1];\n  xs[m + 2] = ys[m + 2];\n  xs[m + 3] = ys[m + 3];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmemspd/memSpeedOMP/7"}
{"code": "for (size_t j = 0; j < kNNNrm; ++j)\n{\n  neighsNrm.push_back(neighs[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = (2 * i) + 1;\n  b[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny01/ocl_tiny01/tiny01/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    for (int k = 0; k < n; k++)\n  {\n    if (gnew[(j * n) + k] > (gnew[(j * n) + i] + gnew[(i * n) + k]))\n      gnew[(j * n) + k] = gnew[(j * n) + i] + gnew[(i * n) + k];\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/u7er/algo_FloydWarshall/floyd/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = 0;\n  x[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/colleeneb/openmp45_examples/04_target_teams_distribute_parallel/0"}
{"code": "for (int i = 0; i < numQueries; ++i)\n{\n  rc_kernel_gold(i, results, refstr, queries, queryAddrs, queryLengths, nodeTexture, childrenTexture, numQueries, match_length);\n}\n\n", "pragma": "   #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/cuda/mummergpu/src/mummergpu_gold/0"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((((x[i] < xmin) || (x[i] >= xmax)) || (y[i] < ymin)) || (y[i] >= ymax))\n    continue;\n\n  bx = calc_bin(x[i], edgesx);\n  by = calc_bin(y[i], edgesy);\n  bin = by + (nby * bx);\n  values_ot[bin]++;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/48"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  if (jouer_coup(&newPos, pos, joueur, i))\n  {\n    ec->_Val[nbv] = valeur_minimax(&newPos, !joueur, alpha, beta, pmax - 1);\n    ec->_Coup[nbv] = i;\n    nbv++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_v2/2"}
{"code": "for (int h = 0; h < (rows * cols); h++)\n{\n  cc_map[i][h] = class_flag[i][h];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/3"}
{"code": "for (j = i + 1; j < num_var; j++)\n  for (k = num_var; k >= 0; k--)\n{\n  var[(j * (num_var + 1)) + k] -= (var[(i * (num_var + 1)) + k] * var[(j * (num_var + 1)) + i]) / var[(i * (num_var + 1)) + i];\n}\n\n\n", "pragma": "\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/workout_3_gaussian_elimination/linearAlgebra_16EE30025/2"}
{"code": "for (i = 0; i < r1; ++i)\n  for (j = 0; j < c1; ++j)\n{\n  printf(\"Enter elements a%d%d -> \", i + 1, j + 1);\n  scanf(\"%d\", &a[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/irajeshegde/OMP-Programs/LA/p6/1"}
{"code": "for (int y = 0; y < Ly; y++)\n  for (int x = 0; x < (Lx / 4); x++)\n{\n  int vv = x + ((Lx / 4) * y);\n  int v = x + (Lx * y);\n  arr[v + ((0 * Lx) / 4)] = ssarr[vv].site4[0];\n  arr[v + ((1 * Lx) / 4)] = ssarr[vv].site4[1];\n  arr[v + ((2 * Lx) / 4)] = ssarr[vv].site4[2];\n  arr[v + ((3 * Lx) / 4)] = ssarr[vv].site4[3];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/heat2d-cuda/lapl_ss/4"}
{"code": "for (size_t i = 0; i < 10; i++)\n{\n  for (size_t j = 0; j < 10; j++)\n  {\n    for (size_t k = 0; k < 10; k++)\n      sum += A[i][k] * B[k][j];\n\n    C[i][j] = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, CHUNK) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/djaliiil/OpenMP/omp_tp1_exo3/0"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((0.75 - TEMP_MIN) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (2048 * 2048)) * 1), stat[i].e2 / ((((double) (2048 * 2048)) * (2048 * 2048)) * 1), stat[i].e4 / ((((((double) (2048 * 2048)) * (2048 * 2048)) * (2048 * 2048)) * (2048 * 2048)) * 1), stat[i].m / 1, stat[i].m2 / 1, stat[i].m4 / 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/7"}
{"code": "for (int i = 0; i <= numcells; i++)\n{\n  R[i] = (R[i] + R2[i]) / 2;\n  RU[i] = (RU[i] + RU2[i]) / 2;\n  RE[i] = (RE[i] + RE2[i]) / 2;\n  U[i] = RU[i] / R[i];\n  P[i] = (GAMMA - 1.0) * (RE[i] - ((0.5 * RU[i]) * U[i]));\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/9"}
{"code": "for (int i = 0; i < (POP_SIZE / 2); i++)\n{\n  for (int j = 0; j <= TOURN_N; j++)\n  {\n    winners[j] = p.pop[rand() % POP_SIZE];\n  }\n\n  while (c < SORT_LIMIT)\n  {\n    for (int l = 0; l < (TOURN_N - 1); l++)\n    {\n      if (fitness(winners[l]) > fitness(winners[l + 1]))\n      {\n        temp = winners[l];\n        winners[l] = winners[l + 1];\n        winners[l + 1] = temp;\n      }\n\n    }\n\n    c++;\n  }\n\n  int flip = rand() % 2;\n  if (flip == 0)\n    offspring[i] = crossoverInj(winners[0], winners[1]);\n  else\n    offspring[i] = crossoverPm(winners[1], winners[0]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/17"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  size_t baseX = i * cols;\n  float sumX = preSum[i];\n  float s2 = preS23[i];\n  for (size_t j = i + 1; j < rows; j++)\n  {\n    size_t baseY = j * cols;\n    float sumXY = 0.0;\n    for (size_t k = 0; k < cols; k++)\n    {\n      float a = vectors[baseX + k];\n      float b = vectors[baseY + k];\n      sumXY += a * b;\n    }\n\n    float sumY = preSum[j];\n    float s3 = preS23[j];\n    float s1 = (sumXY * fCols) - (sumX * sumY);\n    float s4 = sqrtf(s2 * s3);\n    float correlation = s1 / s4;\n    size_t index = getIndex(i, j, rows);\n    output[index] = correlation;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dvhh/massCorrelation/src/correlationOMP/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  arr[i] *= 2;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/easy_mapper/main/1"}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  for (j = 0; j < matrix_size; j++)\n  {\n    a[i][j] = i + j;\n    b[i][j] = (i + j) + 10;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/s27y/openmp_matrixmultip/openmp_matrixmultip/1"}
{"code": "for (unsigned int k = 0; k < max.size(); k++)\n{\n  if (max[k].sum > global_max.sum)\n  {\n    global_max = max[k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ricordel/parallel-sobel/max_subarray/implem/max_subarray/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double x = (i + 0.5) * step;\n  double y = 4.0 / (1 + (x * x));\n  ans += y * step;\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : ans)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ultramagnus007/openmp/pi_p3/0"}
{"code": "for (i = ist; i <= iend; i += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/92"}
{"code": "for (j = 0; j < y; j++)\n{\n  if (dom[i][j][k] == 0)\n  {\n    tmpdy = zdy[j];\n    tmp = min_dt_first(zdx[i], tmpdy);\n    svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / zdx[i];\n    xvel = fabs(vx[i][j][k]) / zdx[i];\n    yvel = fabs(vy[i][j][k]) / tmpdy;\n    max_tmp2 = max_dt_first(svel, xvel);\n    max_tmp3 = max_dt_first(max_tmp2, yvel);\n    rdt1 = max_dt_first(max_tmp3, rdt1);\n    if (viscosity_on_off == 1)\n    {\n      temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n      kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n      s_visc = kin_viscosity / (tmp * tmp);\n      rdt1 = max_dt_first(s_visc, rdt1);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc_first/0"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  perm[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/12"}
{"code": "for (int i = 0; i < n; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/unified_address/unified_address/0"}
{"code": "for (double i = 0; i < A.size(); i++)\n{\n  A[i] = range3(e);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tonyz0x0/parallel-computing/matrix-multiplication-openmp/3"}
{"code": "for (int i = 0; i < 2; ++i)\n  a = 2;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_ast_print/0"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 1; j <= (x_max + 1); j++)\n  {\n    sigma = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    sigma2 = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n    width = celldx[FTNREF1D(j, x_min - 2)];\n    vdiffuw = vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j + 2, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffdw = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffuw2 = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffdw2 = -vdiffdw;\n    auw = fabs(vdiffuw);\n    adw = fabs(vdiffdw);\n    auw2 = fabs(vdiffuw2);\n    wind = 1.0;\n    wind2 = 1.0;\n    limiter = 0.0;\n    if (vdiffdw <= 0.0)\n      wind = -1.0;\n\n    if (vdiffdw2 <= 0.0)\n      wind2 = -1.0;\n\n    limiter = wind * MIN((width * ((((2.0 - sigma) * adw) / width) + (((1.0 + sigma) * auw) / celldx[FTNREF1D(j + 1, x_min - 2)]))) / 6.0, MIN(auw, adw));\n    limiter2 = wind2 * MIN((width * ((((2.0 - sigma2) * adw) / width) + (((1.0 + sigma2) * auw2) / celldx[FTNREF1D(j - 1, x_min - 2)]))) / 6.0, MIN(auw2, adw));\n    if ((vdiffuw * vdiffdw) <= 0.0)\n      limiter = 0.0;\n\n    if ((vdiffuw2 * vdiffdw2) <= 0.0)\n      limiter2 = 0.0;\n\n    if (node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] < 0.0)\n    {\n      advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] + ((1.0 - sigma) * limiter);\n    }\n    else\n    {\n      advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + ((1.0 - sigma2) * limiter2);\n    }\n\n    mom_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(sigma,width,limiter,vdiffuw,vdiffdw,auw,adw,wind,sigma2,limiter2,vdiffuw2,vdiffdw2,auw2,wind2,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/advec_mom_kernel_c/0"}
{"code": "for (j = 0; j < num_particles; j++)\n{\n  for (i = 0; i < dimension; i++)\n  {\n    position[i + (j * dimension)] = (position[i + (j * dimension)] + (velocity[i + (j * dimension)] * size_time_step)) + (((0.5 * acceleration[i + (j * dimension)]) * size_time_step) * size_time_step);\n    velocity[i + (j * dimension)] = velocity[i + (j * dimension)] + ((0.5 * size_time_step) * ((forces[i + (j * dimension)] * rmass) + acceleration[i + (j * dimension)]));\n    acceleration[i + (j * dimension)] = forces[i + (j * dimension)] * rmass;\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPC-Project/openMp/openmp/0"}
{"code": "for (int i = 0; i <= 100000; i++)\n{\n  dot_prod_omp += vector_A[i] * vector_B[i];\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task2/OpenMPtask2/2"}
{"code": "for (i = 0; i < 32768; i++)\n{\n  r[i] = i * M_PI;\n  for (j = 0; j < 32768; j++)\n  {\n    A[(i * 32768) + j] = (((DATA_TYPE) i) * j) / 32768;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/BICG/bicg_cpu/10"}
{"code": "for (int i = 0; i < 4096; i++)\n  m += x1[i], n += x2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/11"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  this_diff = wref[i][j] - w[i][j];\n  if (this_diff < 0)\n    this_diff = (-1.0) * this_diff;\n\n  if (this_diff > 0.0000001)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n      maxdiff = this_diff;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dianchengwangCHN/ParallelComputingLab/PA2/PA2-p2/pa2-p2/5"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*cclass) == 'U')\n  {\n    printf(\"          %2d  %20.13e\\n\", m, xcr[m]);\n  }\n  else\n    if (xcrdif[m] > epsilon)\n  {\n    *verified = FALSE;\n    printf(\" FAILURE: %2d  %20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n  else\n  {\n    printf(\"          %2d  %20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/44"}
{"code": "for (int i = 0; i < (50 / 3); i++)\n  printf(\"---\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/5. N-queens problem/gen06/4"}
{"code": "for (i = 0; i < filesNumber; i++)\n{\n  results.push_back(Result());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/URAmiRBin/cuda-determinant/Source Codes/PARALLEL 3/OPENMP Project/Source/0"}
{"code": "for (int crnt = 1; crnt < 50; crnt++)\n{\n  for (int old = 0; old < crnt; old++)\n  {\n    if ((old == crnt) || (posY[old] == posY[crnt]))\n      collisions++;\n    else\n      if ((posY[crnt] == (posY[old] + (crnt - old))) || (posY[crnt] == (posY[old] - (crnt - old))))\n      collisions++;\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/5. N-queens problem/gen06/9"}
{"code": "for (nnz = 0, i = 0; i < graph->nrows; i++)\n{\n  if (part[i] == pid)\n  {\n    ngraph->nrows++;\n    nnz += graph->rowptr[i + 1] - graph->rowptr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/21"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < len; j++)\n  {\n    printf(\"%lf\", a[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB003-antidep2-orig-yes/1"}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  (*pcounter1[my_ID])++;\n  (*pcounter2[my_ID])++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/RefCount_private/private/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  *(dpc + (4 * i)) = points[i].x;\n  *((dpc + (4 * i)) + 1) = points[i].y;\n  *((dpc + (4 * i)) + 2) = points[i].z;\n  *((dpc + (4 * i)) + 3) = points[i].cid;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/animeshsinghjay/parallel-kmeans/lab1_omp/5"}
{"code": "for (i = 0; i < n1; i++)\n{\n  k = index1[i];\n  for (j = 0; j < nrows; j++)\n  {\n    if (mask[j][k] != 0)\n    {\n      cdata[j][0] = cdata[j][0] + data[j][k];\n      count[j][0] = count[j][0] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/119"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/2"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    for (k = 0; k < z; k++)\n    {\n      if (dom[i][j][k] == 0)\n      {\n        tmpdy = zdy[j];\n        tmpdz = zdz[k];\n        min_tmp1 = min_dt(tmpdy, tmpdz);\n        tmp = min_dt(zdx[i], min_tmp1);\n        svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / tmp;\n        xvel = fabs(vx[i][j][k]) / zdx[i];\n        yvel = fabs(vy[i][j][k]) / tmpdy;\n        zvel = fabs(vz[i][j][k]) / tmpdz;\n        max_tmp1 = max_dt(xvel, yvel);\n        max_tmp2 = max_dt(zvel, svel);\n        max_tmp3 = max_dt(max_tmp1, max_tmp2);\n        rdt1 = max_dt(max_tmp3, rdt1);\n        if (viscosity_on_off == 1)\n        {\n          temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n          kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n          s_visc = kin_viscosity / (tmp * tmp);\n          rdt1 = max_dt(s_visc, rdt1);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc/3"}
{"code": "for (k = 0; k < n; k++)\n  for (j = 0; j < N; j++)\n{\n  loc_C[(k * N) + j] = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/MPIandOpenmp/Mmul_hybrid/5"}
{"code": "for (int i = 0; i < (D_len + 1); i++)\n{\n  ScoreTable[0][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skalogerakis/TUC_Parallel_Computer_Architecture/Smith-Waterman/OpenMP_FineGrained/main/4"}
{"code": "for (i = 0; i < my_num_people; i++)\n{\n  if ((my_states[i] == INFECTED) && (days_infected[i] == disease_duration))\n  {\n    my_recovery_attempts++;\n    if ((random() % 100) < deadliness_factor)\n    {\n      my_states[i] = DEAD;\n      my_num_dead++;\n      my_num_infected--;\n      my_num_deaths++;\n    }\n    else\n    {\n      my_states[i] = IMMUNE;\n      my_num_immune++;\n      my_num_infected--;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:my_recovery_attempts) reduction(+:my_num_dead) reduction(+:my_num_infected) reduction(+:my_num_deaths) reduction(+:my_num_immune)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/6"}
{"code": "for (long i = 0; i < size; i++)\n{\n  second_matrix[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Multiplication_Serial_Parallel/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/clang/test/OpenMP/masked_messages/1"}
{"code": "for (int i = 0; i < img.all; i++)\n{\n  ((file >> img.data[i].red) >> img.data[i].green) >> img.data[i].blue;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elyaishere/sk_high_performance_computing/openmp/Car/0"}
{"code": "for (i = 0; i < V; i++)\n{\n  int distIK = graph[(i * V) + k];\n  if (distIK == infinity)\n    continue;\n\n  for (j = 0; j < V; j++)\n  {\n    if (graph[(i * V) + j] > (distIK + graph[(k * V) + j]))\n    {\n      graph[(i * V) + j] = distIK + graph[(k * V) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j) num_threads(numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/25"}
{"code": "for (i = 0; i <= (1000 + 1); i++)\n{\n  for (j = 0; j <= (1000 + 1); j++)\n  {\n    A[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos de aula/OpenACC/OMP_jacobi/2"}
{"code": "for (int i = 0; i < 16; i = j + i)\n  for (int j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/73"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  r1 = rhs[0][i][j][k];\n  r2 = rhs[1][i][j][k];\n  r3 = rhs[2][i][j][k];\n  r4 = rhs[3][i][j][k];\n  r5 = rhs[4][i][j][k];\n  t1 = bt * r3;\n  t2 = 0.5 * (r4 + r5);\n  rhs[0][i][j][k] = -r2;\n  rhs[1][i][j][k] = r1;\n  rhs[2][i][j][k] = bt * (r4 - r5);\n  rhs[3][i][j][k] = (-t1) + t2;\n  rhs[4][i][j][k] = t1 + t2;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,r1 ,r2 ,r3 ,r4 ,r5 ,t1 ,t2 ,bt ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/84"}
{"code": "for (int i = 0; i < arrLen; i++)\n{\n  int rank = 0;\n  int dupe = 0;\n  for (int j = 0; j < arrLen; j++)\n  {\n    if (i == j)\n    {\n      continue;\n    }\n\n    if (arr[i] > arr[j])\n    {\n      rank++;\n    }\n    else\n      if (arr[i] == arr[j])\n    {\n      dupe++;\n    }\n\n\n  }\n\n  if (returnAr[rank] == arr[i])\n  {\n    continue;\n  }\n\n  for (int j = 0; j <= dupe; j++)\n  {\n    returnAr[rank + j] = arr[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vietNGit/parallelSortOMP/enumSort/0"}
{"code": "for (int _i0 = 2; _i0 < R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 2; _i1 < C; _i1 = _i1 + 1)\n  {\n    Sxy[(_i0 * (2 + C)) + _i1] = (((((((Ixy[(((-1) + _i0) * (2 + C)) + ((-1) + _i1)] + Ixy[(((-1) + _i0) * (2 + C)) + _i1]) + Ixy[(((-1) + _i0) * (2 + C)) + (1 + _i1)]) + Ixy[(_i0 * (2 + C)) + ((-1) + _i1)]) + Ixy[(_i0 * (2 + C)) + _i1]) + Ixy[(_i0 * (2 + C)) + (1 + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + ((-1) + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + _i1]) + Ixy[((1 + _i0) * (2 + C)) + (1 + _i1)];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int rn = rand() % (i + 1);\n  array[i] = i;\n  swap(&array[rn], &array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Bubble_sort_Serial_Parallel/1"}
{"code": "for (int i = 0; i < count; i++)\n{\n  for (struct node *a = buckets[i]; a != 0; a = a->next)\n  {\n    tab[p] = a->val;\n    p++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/mainB/4"}
{"code": "formula.append((\"- \" + number((-1) * dd)) + \"x^4 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/63"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  b[(i * n) + j] = i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimEli/OpenMP/OpenMP/main/3"}
{"code": "for (i = frm0; i <= last_frm; i = i + increment_scatt)\n{\n  if (((0 == 1) && (dim_switch == 1)) && (i >= 3000))\n  {\n    increment_scatt = 10;\n  }\n\n  file_count++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/11"}
{"code": "for (int j = 1; j < (ny - 1); j++)\n{\n  for (int i = 1; i < (nx - 1); i++)\n  {\n    edges[j][i] = (unsigned char) round((255 * (sobel[j][i] - minval)) / (maxval - minval));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhaas80/ncsa-pire/examples/sobel/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    Ex.row(i) += X.row(j) * kernel_matrix_x(i, j);\n    Exyx.row(i) += Exy.row(j) * kernel_matrix_x(i, j);\n  }\n\n  Ex.row(i) /= Kx(i);\n  Exyx.row(i) /= Kx(i);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(ncore)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_sir_solver/0"}
{"code": "for (int j = 0; j < E; j++)\n{\n  int u = (get < 0) > edges[j];\n  int v = (get < 1) > edges[j];\n  int new_dist = weights[j] + dist[u];\n  if ((dist[u] != INT_MAX) && (new_dist < dist[v]))\n    dist[v] = new_dist;\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/4"}
{"code": "for (int i = 0; i < SIZE_X; i++)\n  m_Locks[i] = false;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/1"}
{"code": "for (int i = 0; i < walkers; i++)\n{\n  wlkrs[i][0] = rand() / ((double) 32767);\n  wlkrs[i][1] = rand() / ((double) 32767);\n  index[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/sample_posterior_c_omp/6"}
{"code": "for (i = 0; i < ((nx * ny) * nz); i++)\n{\n  diff = fabs(y_data[i] - sol_data[i]);\n  if (diff > error)\n    error = diff;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/main/1"}
{"code": "for (j = 0; j < npxyz; j++)\n{\n  part[3 + (idimp * j)] = vtx * ranorm();\n  part[4 + (idimp * j)] = vty * ranorm();\n  part[5 + (idimp * j)] = vtz * ranorm();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/34"}
{"code": "for (int k = 0; k < A.Cols; k++)\n{\n  sum += arrayA[i][k] * arrayB[k][j];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haniyeka/Parallel-Programming/Assignment3/Prob3/Prob3/Parallel/2"}
{"code": "for (int c = 0; c < 1000; c++)\n{\n  int x = (int) CitiesX[c];\n  int y = (int) CitiesY[c];\n  if (Map[y][x] == (-999999))\n    Map[y][x] = c;\n  else\n    Map[y][x] = -1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant04/9"}
{"code": "for (int j = 0; j < sizey; j++)\n{\n  for (int i = 0; i < sizex; i++)\n  {\n    cc.V[i + (j * sizex)] = dx * dy;\n    cc.x[i + (j * sizex)] = dx * i;\n    cc.y[i + (j * sizex)] = dy * j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/11"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  spmatrix->val[i] = (real_t *) malloc(msize * (sizeof(real_t)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/4"}
{"code": "for (int k = 0; k < row_index; k++)\n{\n  tempRectangle.topLeftX = oneDArrayOfAllCoorindates[k * 4];\n  tempRectangle.topLeftY = oneDArrayOfAllCoorindates[(k * 4) + 1];\n  tempRectangle.bottomRightX = oneDArrayOfAllCoorindates[(k * 4) + 2];\n  tempRectangle.bottomRightY = oneDArrayOfAllCoorindates[(k * 4) + 3];\n  tempRectangle.flag = 0;\n  collective_coordinates.push_back(tempRectangle);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/5"}
{"code": "for (j = 0; j < len; j++)\n{\n  u[i][j] = 0.5;\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB021-reductionmissing-orig-yes/1"}
{"code": "for (i = 1; i <= (N - 2); i++)\n  for (j = 1; j <= (N - 2); j++)\n{\n  B[i][j] = (((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.;\n}\n\n\n", "pragma": "omp parallel for shared(A,B) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dzhidzhoev/skpod-openmp/jacobi_2d/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  fscanf(fptr, \"%f\", &m);\n  b[i] = m;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_1/3"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  if (cur_salt->hash_id == (0x80 + 1))\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_64 *pbe64;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    sph_whirlpool_context ctx;\n    unsigned char hash[64];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock64 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(2, cur_salt->iterations, MBEDTLS_PKCS12_DERIVE_KEY, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe64 = (pbe_format_v5_64 *) cur_salt->key;\n    memcpy(iv, pbe64->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe64->keyblock, 256, 256);\n    }\n\n    if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe64->iv, 8);\n      AES_set_decrypt_key(key, 256, &aes_key);\n      AES_cbc_encrypt(pbe64->keyblock, out, 160, &aes_key, iv, AES_DECRYPT);\n    }\n\n    sph_whirlpool_init(&ctx);\n    sph_whirlpool(&ctx, out, 90);\n    sph_whirlpool_close(&ctx, hash);\n    p = (struct KGEncryptedBlock64 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n  else\n    if (cur_salt->hash_id == 0x80)\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_32 *pbe32;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    SHA256_CTX ctx;\n    unsigned char hash[32];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock32 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(256, cur_salt->iterations, MBEDTLS_PKCS12_DERIVE_KEY, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe32 = (pbe_format_v5_32 *) cur_salt->key;\n    memcpy(iv, pbe32->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe32->keyblock, 256, 256);\n    }\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe32->iv, 8);\n      AES_set_decrypt_key(key, 256, &aes_key);\n      AES_cbc_encrypt(pbe32->keyblock, out, 128, &aes_key, iv, AES_DECRYPT);\n    }\n\n\n    SHA256_Init(&ctx);\n    SHA256_Update(&ctx, out, 90);\n    SHA256_Final(hash, &ctx);\n    p = (struct KGEncryptedBlock32 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n  else\n    if (cur_salt->hash_id == 10)\n  {\n    unsigned char key[64];\n    int keylen = 0;\n    pbe_format_v5_64 *pbe64;\n    unsigned char out[256] = {0};\n    AES_KEY aes_key;\n    SHA512_CTX ctx;\n    unsigned char hash[64];\n    unsigned char iv[16] = {0};\n    struct KGEncryptedBlock64 *p;\n    if (cur_salt->mode_id == 0xBC000004)\n      keylen = 64;\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n      keylen = 32;\n\n\n    pkcs12_pbe_derive_key(10, cur_salt->iterations, MBEDTLS_PKCS12_DERIVE_KEY, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, cur_salt->salt_size, key, keylen);\n    pbe64 = (pbe_format_v5_64 *) cur_salt->key;\n    memcpy(iv, pbe64->iv, 8);\n    if (cur_salt->mode_id == 0xBC000004)\n    {\n      AES_XTS_decrypt_custom_tweak(key, iv, out, pbe64->keyblock, 256, 256);\n    }\n    else\n      if (cur_salt->mode_id == 0xBC000002)\n    {\n      memcpy(iv + 8, pbe64->iv, 8);\n      AES_set_decrypt_key(key, 256, &aes_key);\n      AES_cbc_encrypt(pbe64->keyblock, out, 160, &aes_key, iv, AES_DECRYPT);\n    }\n\n\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, out, 90);\n    SHA512_Final(hash, &ctx);\n    p = (struct KGEncryptedBlock64 *) out;\n    cracked[index] = 0 == memcmp(hash, p->digest, 32);\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/bestcrypt_fmt_plug/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);\n  (cout << \"Sixth test: Gaussian blur with OpenCV. Starting timer...\") << endl;\n  startTime = omp_get_wtime();\n  GaussianBlur(image, image, Size(5, 5), 1);\n  duration = omp_get_wtime() - startTime;\n  (logs << duration) << \"\\n\";\n  (((cout << \"FINISHED. Gaussian blur with OpenCV took \") << duration) << \" seconds.\") << endl;\n  if (i == 9)\n    imwrite(\"gaussian_opencv.png\", image);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/13"}
{"code": "for (i = 1; i < (buffer_receive[0] + 1); i++)\n{\n  if (arr[n - 1] < buffer_receive[i])\n  {\n    arr[n - 1] = buffer_receive[i];\n  }\n  else\n  {\n  }\n\n}\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/bitonic-sort-project/src/hybrid/bitonic_sort_hybrid/1"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = 1; j < N; j++)\n  {\n    S[i][j] = ((fabs(sin(S[i - 1][j - 1])) + fabs(sin(S[i][j - 1]))) + fabs(sin(S[i - 1][j]))) * 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arlindkryeziu/OpenMP-StencilCode/StencilCode/StencilCode/StencilCode/2"}
{"code": "for (k = 0; k < n; k++)\n{\n  tmp[k].Re = v[k].Re;\n  tmp[k].Im = v[k].Im;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/fft/sw/src/main/2"}
{"code": "for (i = 0; i < NMAX; i++)\n{\n  a[i] = (b[i] = i * 1.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SeymourRu/OpenMPLabs/TestOpenMP/TestOpenMP/TestOpenMP/0"}
{"code": "for (i = 0; i < 1024; i++)\n  for (j = 0; j < 1024; j++)\n  local_sum += a[j];\n\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/007_loop_iteration_variable/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/6"}
{"code": "for (int r = 0; r < rows; r++)\n{\n  for (int c = 0; c < cols; c++)\n  {\n    *((arr + (r * cols)) + c) = (double) ((rows * c) + c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/matrix-multiply/omp-mat-mul/omp-mat-mul/1"}
{"code": "for (int i = 0; i < arg; i++)\n  ;\n\n", "pragma": "omp for reduction(+: a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/target_vla_messages/0"}
{"code": "for (int k = 0; k < argc; ++k)\n  ++k;\n\n", "pragma": "  #pragma omp for private ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_private_messages/0"}
{"code": "for (i = 0; i < 1000; i++)\n  check(accum(i), accum_ref(i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.4/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    x = ((((double) (j - 1)) * x_max) + (((double) (m - j)) * x_min)) / ((double) (m - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (n - i)) * y_min)) / ((double) (n - 1));\n    count[i][j] = 0;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if ((count[i][j] % 2) == 1)\n    {\n      r[i][j] = 255;\n      g[i][j] = 255;\n      b[i][j] = 255;\n    }\n    else\n    {\n      c = (int) (255.0 * sqrt(sqrt(sqrt(((double) count[i][j]) / ((double) count_max)))));\n      r[i][j] = (3 * c) / 5;\n      g[i][j] = (3 * c) / 5;\n      b[i][j] = c;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPMandelbrot/Mandelbrot/0"}
{"code": "for (i = start; i < end; i++)\n{\n  canvas[i] = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP1/inf8601-lab1-2.1.0/src/dragon/2"}
{"code": "for (size_t i = 0; i < n; i++)\n  sum += a[i];\n\n", "pragma": "    #pragma omp parralel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/sum_array/1"}
{"code": "for (i = 1; i < max; i++)\n{\n  for (j = i; j < max; j++)\n  {\n    b = b + (((double) (i + j)) / ((double) (i * j)));\n  }\n\n}\n\n", "pragma": "omp for reduction(+:b) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter5/fs/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = malloc(n * (sizeof(double *)));\n  l[i] = malloc(n * (sizeof(double *)));\n  u[i] = malloc(n * (sizeof(double *)));\n  pi[i] = i;\n  for (j = 0; j < n; j++)\n  {\n    drand48_r(&drand_buf, &a[i][j]);\n    a[i][j] = (a[i][j] + 0.5) / 2;\n    if (i == j)\n    {\n      l[i][j] = 1;\n      drand48_r(&drand_buf, &u[i][j]);\n    }\n    else\n    {\n      if (i > j)\n      {\n        drand48_r(&drand_buf, &l[i][j]);\n        u[i][j] = 0;\n      }\n      else\n      {\n        drand48_r(&drand_buf, &u[i][j]);\n        l[i][j] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  *sum += factor / ((2 * i) + 1);\n  factor = -factor;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omnyyah/Parallel-Programming-Lab/piParallel/0"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (j_imopVar111 = 1; j_imopVar111 < (grid_points[1] - 1); j_imopVar111++)\n  {\n    for (k_imopVar112 = 3; k_imopVar112 < (grid_points[2] - 3); k_imopVar112++)\n    {\n      for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n      {\n        rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * ((((u[i_imopVar110][j_imopVar111][k_imopVar112 - 2][m_imopVar113] - (4.0 * u[i_imopVar110][j_imopVar111][k_imopVar112 - 1][m_imopVar113])) + (6.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113])) - (4.0 * u[i_imopVar110][j_imopVar111][k_imopVar112 + 1][m_imopVar113])) + u[i_imopVar110][j_imopVar111][k_imopVar112 + 2][m_imopVar113]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/24"}
{"code": "for (i = 0; i < G->N; i++)\n{\n  G->D[i] = INF;\n  G->visited[i] = NOT_VISITED;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danyalfaro/Dijkstra/Dijkstra/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  a = prediction[i] - labels[i];\n  if (a == 0)\n    correct++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/14"}
{"code": "for (k = 0; k < (K - 1); ++k)\n{\n  kernel(ls[k], ls[k + 1].x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michimichiamo/neuralnet/nn_omp/4"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total += data[(i * n) + 6];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/13"}
{"code": "for (j = 0; j < 2; j++)\n{\n  distance += (Cities[city1][j] - Cities[city2][j]) * (Cities[city1][j] - Cities[city2][j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex5/tsp5/1"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = strtof(head, &tail);\n    if (tail == head)\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n    if (mat->rsizes[i] < 0)\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n      if (tail == head)\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = (float) strtod(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/38"}
{"code": "for (int i = 0; i < arr.size(); i++)\n{\n  for (int j = 0; j < arr[i].size(); j++)\n  {\n    if (i == j)\n    {\n      arr[i][j] = 1;\n    }\n    else\n    {\n      arr[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/2"}
{"code": "for (int index = 1; index <= 1000000; ++index)\n{\n  Chaining.emplace(index, index);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eduardodextil/PA4_HASH-TABLES-AND-OPENMP/main/1"}
{"code": "for (x = 4; x < (p.ip - 4); x++)\n{\n  for (y = 4; y < (p.jp - 4); y++)\n  {\n    for (z = 4; z < (p.kp - 4); z++)\n    {\n      lap = ((((((((((((coef[0] * tempU1[(((x * p.jp) + y) * p.kp) + z]) + (coef[1] * (tempU1[((((x + 1) * p.jp) + y) * p.kp) + z] + tempU1[((((x - 1) * p.jp) + y) * p.kp) + z]))) + (coef[1] * (tempU1[(((x * p.jp) + (y + 1)) * p.kp) + z] + tempU1[(((x * p.jp) + (y - 1)) * p.kp) + z]))) + (coef[1] * (tempU1[(((x * p.jp) + y) * p.kp) + (z + 1)] + tempU1[(((x * p.jp) + y) * p.kp) + (z - 1)]))) + (coef[2] * (tempU1[((((x + 2) * p.jp) + y) * p.kp) + z] + tempU1[((((x - 2) * p.jp) + y) * p.kp) + z]))) + (coef[2] * (tempU1[(((x * p.jp) + (y + 2)) * p.kp) + z] + tempU1[(((x * p.jp) + (y - 2)) * p.kp) + z]))) + (coef[2] * (tempU1[(((x * p.jp) + y) * p.kp) + (z + 2)] + tempU1[(((x * p.jp) + y) * p.kp) + (z - 2)]))) + (coef[3] * (tempU1[((((x + 3) * p.jp) + y) * p.kp) + z] + tempU1[((((x - 3) * p.jp) + y) * p.kp) + z]))) + (coef[3] * (tempU1[(((x * p.jp) + (y + 3)) * p.kp) + z] + tempU1[(((x * p.jp) + (y - 3)) * p.kp) + z]))) + (coef[3] * (tempU1[(((x * p.jp) + y) * p.kp) + (z + 3)] + tempU1[(((x * p.jp) + y) * p.kp) + (z - 3)]))) + (coef[4] * (tempU1[((((x + 4) * p.jp) + y) * p.kp) + z] + tempU1[((((x - 4) * p.jp) + y) * p.kp) + z]))) + (coef[4] * (tempU1[(((x * p.jp) + (y + 4)) * p.kp) + z] + tempU1[(((x * p.jp) + (y - 4)) * p.kp) + z]))) + (coef[4] * (tempU1[(((x * p.jp) + y) * p.kp) + (z + 4)] + tempU1[(((x * p.jp) + y) * p.kp) + (z - 4)]));\n      tempU2[(((x * p.jp) + y) * p.kp) + z] = ((2. * tempU1[(((x * p.jp) + y) * p.kp) + z]) - tempU2[(((x * p.jp) + y) * p.kp) + z]) + (U3[(((x * p.jp) + y) * p.kp) + z] * lap);\n      if ((((x == ixs) && (y == iys)) && (z == izs)) && ((i + 1) < nt))\n      {\n        tempU2[(((ixs * p.jp) + iys) * p.kp) + izs] = tempU2[(((ixs * p.jp) + iys) * p.kp) + izs] + source[i + 1];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i) private(x,y,z,lap)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesxu90/Speedup-program-using-OpenMP-and-OpenACC-on-CUDA-and-Coprocessor/HW2/openmp/cs280hw2t1/cpu/src/driver/1"}
{"code": "for (iterator i = Agents.begin(); i != Agents.end(); i++)\n{\n  (((((((((((((((((((((out << i->id) << \",\") << i->species) << \",\") << i->connections[0]) << \",\") << i->connections[1]) << \",\") << i->connections[2]) << \",\") << i->connections[3]) << \",\") << i->connections[4]) << \",\") << i->connections[5]) << \",\") << NKspace) << \",\") << k) << \",\") << rounds) << endl;\n  out.flush();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c6/4"}
{"code": "for (int h = -winRadius; h <= winRadius; h++)\n{\n  float *bptr = basePtr_f + (h * cols);\n  float *mptr = matchPtr_f + (h * cols);\n  float tmp_d;\n  float tmp_match_idx;\n  for (int w = -winRadius; w <= winRadius; w++)\n  {\n    float tmp_idx_f;\n    float ceil_idx_f;\n    int floor_idx_i;\n    tmp_d = ((af * (x + w)) + (bf * (y + h))) + cf;\n    if (tmp_d != tmp_d)\n      return 1000.0f;\n\n    tmp_match_idx = ((float) (x + w)) + tmp_d;\n    if ((tmp_match_idx > bound) || (tmp_match_idx < winRadius))\n      return 1000.0f;\n\n    floor_idx_i = (int) tmp_match_idx;\n    match_value = mptr[floor_idx_i - x] + ((mptr[(floor_idx_i + 1) - x] - mptr[floor_idx_i - x]) * (tmp_match_idx - floor(tmp_match_idx)));\n    match_value -= bptr[w];\n    cost += (match_value >= 0) ? (match_value) : ((-1.0f) * match_value);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/freesdyla/Math-424-Semester-Project/stereo/9"}
{"code": "for (int i = 0; i < num_outputs; i++)\n{\n  double sum = 0.0;\n  for (int j = 0; j < num_hidden; j++)\n  {\n    sum += hv[j] * output_weights[i][j];\n  }\n\n  ov[i] = sigmoid(sum);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ghulette/neural-net-openmp/neuralnet/3"}
{"code": "for (int i = 0; i < len; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp for simd schedule(static) simdlen(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utwente-fmt/vercors/examples/openmp/add-spec-simd/0"}
{"code": "for (size_t j = m0; j <= m1; j++)\n{\n  if (((j + 1) % 2) != 0)\n  {\n    for (size_t k = n0_odd; k <= n1_odd; k++)\n    {\n      double x = hex2D.computeX(0, k);\n      double y = hex2D.computeY(j);\n      size_t numNeiFound;\n      m_pNeighbourSearcher->searchNeighbour(x, y, 0, m_fNeiSearchRadius, neiListTemp, neiListDistTemp, numNeiFound);\n      if (!isValidGhostParticle(x, y, 0, neiListTemp, numNeiFound, p + 1))\n        continue;\n\n      if (ghostIndex >= capacity)\n        assert(false);\n\n      positionX[ghostIndex] = x;\n      positionY[ghostIndex] = y;\n      ghostIndex++;\n    }\n\n  }\n  else\n  {\n    for (size_t k = n0_even; k <= n1_even; k++)\n    {\n      double x = hex2D.computeX(1, k);\n      double y = hex2D.computeY(j);\n      size_t numNeiFound;\n      m_pNeighbourSearcher->searchNeighbour(x, y, 0, m_fNeiSearchRadius, neiListTemp, neiListDistTemp, numNeiFound);\n      if (!isValidGhostParticle(x, y, 0, neiListTemp, numNeiFound, p + 1))\n        continue;\n\n      if (ghostIndex >= capacity)\n        assert(false);\n\n      positionX[ghostIndex] = x;\n      positionY[ghostIndex] = y;\n      ghostIndex++;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/3"}
{"code": "for (j = 0; j < n; j++)\n  printf(\"%.4g%s\", v[j], ((j % 10) == 9) ? (\"\\n\") : (\", \"));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Volodimirich/GaussOpenMp/gaussOp/3"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpuweia3fn.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpuweia3fn.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/33"}
{"code": "for (m = 0; m < 5; m++)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (dsspm * ((((rsd[i][j][k - 2][m] - (4.0 * rsd[i][j][k - 1][m])) + (6.0 * rsd[i][j][k][m])) - (4.0 * rsd[i][j][k + 1][m])) + rsd[i][j][k + 2][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(nz ,ist ,jst ,m ,dssp ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/40"}
{"code": "for (int i = 1; i < 800; i++)\n{\n  for (int j = 0; j < 800; j++)\n  {\n    neuron[k][i].charge += weight[k - 1][i][j] * neuron[k - 1][j].active;\n  }\n\n  neuron[k][i].active = tanh(neuron[k][i].charge);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_omp/1"}
{"code": "for (int m = 0; m < src_flat_size; m += 3)\n{\n  x = (m % (src.cols * 3)) / 3;\n  y = m / (src.cols * 3);\n  sum_b = 0.0;\n  sum_g = 0.0;\n  sum_r = 0.0;\n  for (int n = 0; n < (kernel_width * kernel_width); n++)\n  {\n    i = n % kernel_width;\n    j = n / kernel_width;\n    x_tmp = Reflect(src.cols, x - (j - k));\n    y_tmp = Reflect(src.rows, y - (i - k));\n    flat_b_index = (x_tmp * 3) + ((src.cols * 3) * y_tmp);\n    flat_kernel_index = i + (kernel_width * j);\n    sum_b += kernel_flat[flat_kernel_index] * src_flat[flat_b_index];\n    sum_g += kernel_flat[flat_kernel_index] * src_flat[flat_b_index + 1];\n    sum_r += kernel_flat[flat_kernel_index] * src_flat[flat_b_index + 2];\n  }\n\n  dst_flat[m] = sum_b;\n  dst_flat[m + 1] = sum_g;\n  dst_flat[m + 2] = sum_r;\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(num_threads) private(x,y,sum_b,sum_g,sum_r,i,j,x_tmp,y_tmp,flat_b_index,flat_kernel_index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcogualtieri/kernel_image_processing/openmp_kernel_image_processing/2"}
{"code": "for (int row = col + 1; row < mat_size; row++)\n{\n  double alp = A_aug[row][col] / A_aug[col][col];\n  for (int k = 0; k < (mat_size + 1); k++)\n  {\n    A_aug[row][k] = A_aug[row][k] - (alp * A_aug[col][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared (A_aug, mat_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/6/Gauss_Elimination/main/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  int _imopVarPre257;\n  int _imopVarPre258;\n  _imopVarPre257 = d_imopVarPre82[i];\n  _imopVarPre258 = ilog2(_imopVarPre257);\n  logd_imopVarPre85[i] = _imopVarPre258;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/15"}
{"code": "for (i = 0; i < (matrixsize + 1); i++)\n  row[i] = (multiplier * rowj[i]) + row[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/11"}
{"code": "for (i = 0; i < dp->dim; i++)\n{\n  count++;\n  while (cur[count] != ']')\n  {\n    fputc(cur[count], fphost);\n    count++;\n  }\n\n  if (i < (dp->dim - 1))\n  {\n    if (i > 1)\n      fputc(')', fphost);\n\n    fprintf(fphost, \"*%s.range[%d]+\", dp->dname, i + 1);\n  }\n\n  count++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/22"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 1); k++)\n  {\n    forcing[m][i][j][k] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(k ,j ,i ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/13"}
{"code": "for (i = 0; i < size; ++i)\n{\n  func(&result[i], &offset);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/omp-exercises/iterative_scan/1"}
{"code": "for (int i = 0; i < agentSize; i++)\n{\n  agents[i]->computeNextDesiredPosition();\n  move(agents[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hd-zhao-uu/PedestrianSimulation/libpedsim/ped_model/0"}
{"code": "for (i = 0; i < size; i++)\n  a[i] = malloc(size * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/matrix_sum_omp/1"}
{"code": "for (trial = 0; trial < ntrials; trial++)\n{\n  for (i = 0; i < nvars; i++)\n  {\n    startpt[i] = (4.0 * drand48()) - 4.0;\n  }\n\n  jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);\n  printf(\"\\n\\n\\nHOOKE %d USED %d ITERATIONS, AND RETURNED\\n\", trial, jj);\n  for (i = 0; i < nvars; i++)\n    printf(\"x[%3d] = %15.7le \\n\", i, endpt[i]);\n\n  fx = f(endpt, nvars);\n  if (fx < best_fx)\n  {\n    best_trial = trial;\n    best_jj = jj;\n    best_fx = fx;\n    for (i = 0; i < nvars; i++)\n      best_pt[i] = endpt[i];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/its-lito/Parallel-Programming/Code/OpenMP-Tasks/5"}
{"code": "for (int i = 0; i < nE; ++i)\n{\n  ((cin >> from) >> to) >> weight;\n  graph[to][from] = weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/3"}
{"code": "for (uint i = 0; i < mols.GetKindsCount(); ++i)\n{\n  uint numI = molLookup.NumKindInBox(i, box);\n  for (uint j = 0; j < mols.GetKindsCount(); ++j)\n  {\n    uint numJ = molLookup.NumKindInBox(j, box);\n    vir += ((mols.pairVirCorrections[(i * mols.GetKindsCount()) + j] * numI) * numJ) * boxAxes.volInv[box];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/23"}
{"code": "for (int i = 0; i < (3731 - 50); ++i)\n{\n  for (int j = 0; j < (5716 - 50); ++j)\n  {\n    int s = 0;\n    for (int dx = 0; dx < 50; ++dx)\n    {\n      for (int dy = 0; dy < 50; ++dy)\n      {\n        s += data[i + dx][j + dy];\n      }\n\n    }\n\n    ans[i][j] = clamp((s / 50) / 50, 0, 255);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main2/0"}
{"code": "for (i = 0; i < nthreads; i++)\n  for (j = 0; j < numClusters; j++)\n  free(local_newClusters[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/16"}
{"code": "for (i = 0; i < R; i++)\n{\n  for (j = 0; j < C; j++)\n  {\n    sc = (image.at < uchar) > ((i, j));\n    data[(i * C) + j] = ((float) sc.val[0]) / 255;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/main/1"}
{"code": "for (int rw = 0; rw < m_nRows; rw++)\n{\n  switch (m_AggregationType)\n  {\n    case AT_Average:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = 0.f;\n      }\n\n      m_1DData[rw] = ((m_1DData[rw] * m_Counter) + data[rw]) / (m_Counter + 1.f);\n    }\n\n      break;\n\n    case AT_Sum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = 0.f;\n      }\n\n      m_1DData[rw] += data[rw];\n    }\n\n      break;\n\n    case AT_Minimum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = MAXIMUMFLOAT;\n      }\n\n      if (m_1DData[rw] >= data[rw])\n      {\n        m_1DData[rw] = data[rw];\n      }\n\n    }\n\n      break;\n\n    case AT_Maximum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = MISSINGFLOAT;\n      }\n\n      if (m_1DData[rw] <= data[rw])\n      {\n        m_1DData[rw] = data[rw];\n      }\n\n    }\n\n      break;\n\n    default:\n      break;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/7"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  for (size_t j = 0; j < (POPULATION_CNT - 1); j++)\n  {\n    if ((r[i] > parent[j].probability) && (r[i] < parent[j + 1].probability))\n    {\n      pool[i] = parent[j + 1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/9"}
{"code": "for (j = 0; j < 1; j++)\n{\n  keys[GETPOS_1(0, j)] = i & 0xff;\n  keys[GETPOS_1(1, j)] = i >> 8;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/10"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%d \", numNeigh[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/130"}
{"code": "for (size_t i = fromWhere; ((i + str.length()) - 1) < toWhere; i++)\n{\n  long long cur_h = hashs_t[(i + str.length()) - 1];\n  if (i)\n    cur_h -= hashs_t[i - 1];\n\n  if (cur_h == (hash_s * pPower[i]))\n  {\n    openMPInput(i);\n    result = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mserebryaakov/study-parallel-programming/Lab3-OpenMP/4"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/0"}
{"code": "for (i = 0; i < n; ++i)\n  for (k = 0; k < n; ++k)\n  for (j = 0; j < n; ++j)\n  C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];\n\n\n\n", "pragma": "    #pragma omp parallel for default(none) shared(n,A,B,C) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex4-matrix-multi-openmp/1"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    for (int kk = 0; kk < 9; kk++)\n    {\n      total += cells[(ii * params.nx) + jj].speeds[kk];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/borektsioglou/OpenMP/d2q9-bgk/7"}
{"code": "for (i = 0; i < 1000000000; i++)\n{\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vishal-subbu/OpenMP/dot_prod/1"}
{"code": "for (int iter = 0; iter < 10; iter++)\n{\n  deployAnts();\n  allAntsTour(iter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/1"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    B[i][j] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/3"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (tz2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/47"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    a[i][j] = b[i][j];\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t\t#pragma omp parallel for shared(n,b,a) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dhawal777/OpenMp-Basics/question3/solver-jacobi/1"}
{"code": "for (size_t l_ve = 0; l_ve < l_vePerm.size(); l_ve++)\n{\n  size_t l_pe = l_vePerm[l_ve];\n  size_t l_tag = l_veTags[l_pe];\n  if ((m_veTags.size() != 0) && (m_veTags.back() == l_tag))\n    continue;\n\n  m_veTags.push_back(l_tag);\n  for (unsigned short l_di = 0; l_di < 3; l_di++)\n  {\n    m_veCrds.push_back(l_veCrds[(l_pe * 3) + l_di]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/io/Gmsh/1"}
{"code": "for (int i = 0; projectPath[i]; i++)\n{\n  if (projectPath[i] == '/')\n  {\n    idx = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prsousa/TomSeg/segmentation-manager/segmentationmanager/0"}
{"code": "for (int a = 0; a < (padded_X * padded_Y); a++)\n{\n  padded_matrix[a] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mukundc/Image-Processing-and-Optimization/part2/1"}
{"code": "for (i = iLeftTemp; i <= iRightTemp; i++)\n{\n  for (j = 1; j <= (jmax + 1); j++)\n  {\n    umax = (fabs(u[i][j]) > umax) ? (fabs(u[i][j])) : (umax);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i,j) reduction(max:umax)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/9"}
{"code": "for (int j = 0; j < column; ++j)\n{\n  printf(\"Enter a%d%d: \", i + 1, j + 1);\n  scanf(\"%d\", &matrix[i][j]);\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eliah7/OpenMP-Intro/mat_mul_parallel/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j][k - 1][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/118"}
{"code": "for (i = 0; i < ARCHelems; i++)\n{\n  for (j = 0; j < 12; j++)\n  {\n    Me[j] = 0.0;\n    Ce[j] = 0.0;\n    v[j] = 0.0;\n    for (k = 0; k < 12; k++)\n      Ke[j][k] = 0.0;\n\n  }\n\n  for (j = 0; j < 4; j++)\n  {\n    cor[j] = ARCHvertex[i][j];\n  }\n\n  verticesonbnd = 0;\n  for (j = 0; j < 4; j++)\n    if (nodekind[cor[j]] != 1)\n    bv[verticesonbnd++] = j;\n\n\n  if (verticesonbnd == 3)\n  {\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < 3; k++)\n      vertices[j][k] = ARCHcoord[cor[bv[j]]][k];\n\n\n    abe_matrix(vertices, bv, &prop, Ce);\n  }\n\n  for (j = 0; j < 4; j++)\n    for (k = 0; k < 3; k++)\n    vertices[j][k] = ARCHcoord[cor[j]][k];\n\n\n  element_matrices(vertices, &prop, Ke, Me);\n  centroid(vertices, xc);\n  if (xc[2] < (-11.5))\n    alpha = ((2.0 * Damp.zeta) / 100.0) * ((2.0 * PI) * Damp.freq);\n  else\n    alpha = (((4.0 * PI) * Damp.consta) * 0.95) / (prop.cs + Damp.constb);\n\n  for (j = 0; j < 12; j++)\n    Ce[j] = Ce[j] + (alpha * Me[j]);\n\n  if ((source_elms[i] == 2) || (source_elms[i] == 3))\n  {\n    for (j = 0; j < 4; j++)\n    {\n      if (cor[j] == Src.sourcenode)\n      {\n        v[3 * j] = uf[0];\n        v[(3 * j) + 1] = uf[1];\n        v[(3 * j) + 2] = uf[2];\n      }\n      else\n      {\n        v[3 * j] = 0;\n        v[(3 * j) + 1] = 0;\n        v[(3 * j) + 2] = 0;\n      }\n\n    }\n\n    vv12x12(Me, v, Mexv);\n    vv12x12(Ce, v, Cexv);\n    mv12x12(Ke, v);\n    if (source_elms[i] == 3)\n      for (j = 0; j < 12; j++)\n    {\n      v[j] = -v[j];\n      Mexv[j] = -Mexv[j];\n      Cexv[j] = -Cexv[j];\n    }\n\n\n    for (j = 0; j < 4; j++)\n    {\n      V23[ARCHvertex[i][j]][0] += v[j * 3];\n      V23[ARCHvertex[i][j]][1] += v[(j * 3) + 1];\n      V23[ARCHvertex[i][j]][2] += v[(j * 3) + 2];\n      M23[ARCHvertex[i][j]][0] += Mexv[j * 3];\n      M23[ARCHvertex[i][j]][1] += Mexv[(j * 3) + 1];\n      M23[ARCHvertex[i][j]][2] += Mexv[(j * 3) + 2];\n      C23[ARCHvertex[i][j]][0] += Cexv[j * 3];\n      C23[ARCHvertex[i][j]][1] += Cexv[(j * 3) + 1];\n      C23[ARCHvertex[i][j]][2] += Cexv[(j * 3) + 2];\n    }\n\n  }\n\n  for (j = 0; j < 4; j++)\n  {\n    M[ARCHvertex[i][j]][0] += Me[j * 3];\n    M[ARCHvertex[i][j]][1] += Me[(j * 3) + 1];\n    M[ARCHvertex[i][j]][2] += Me[(j * 3) + 2];\n    C[ARCHvertex[i][j]][0] += Ce[j * 3];\n    C[ARCHvertex[i][j]][1] += Ce[(j * 3) + 1];\n    C[ARCHvertex[i][j]][2] += Ce[(j * 3) + 2];\n    for (k = 0; k < 4; k++)\n    {\n      if (ARCHvertex[i][j] <= ARCHvertex[i][k])\n      {\n        kk = ARCHmatrixindex[ARCHvertex[i][j]];\n        while (ARCHmatrixcol[kk] != ARCHvertex[i][k])\n        {\n          kk++;\n          if (kk >= ARCHmatrixindex[ARCHvertex[i][k] + 1])\n          {\n            printf(\"K indexing error!!! %d %d\\n\", ARCHvertex[i][j], ARCHvertex[i][k]);\n            exit(1);\n          }\n\n        }\n\n        for (ii = 0; ii < 3; ii++)\n          for (jj = 0; jj < 3; jj++)\n          K[kk][ii][jj] += Ke[(j * 3) + ii][(k * 3) + jj];\n\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/39"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp49xe89rq.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  cache->verticesMiss[i] = 0;\n  cache->verticesHit[i] = 0;\n  cache->vertices_base_reuse[i] = 0;\n  cache->vertices_total_reuse[i] = 0;\n  cache->vertices_accesses[i] = 0;\n  cache->vertices_base_reuse_region[i] = 0;\n  cache->vertices_total_reuse_region[i] = 0;\n  cache->vertices_accesses_region[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/3"}
{"code": "for (i = 0; i < NE; i++)\n{\n  printf(\"Value of C[0] at %d is %f: correct value: %f\\n\", i, c[i][0], d[i][0]);\n  printf(\"Value of C[1] at %d is %f: correct value: %f\\n\", i, c[i][1], d[i][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nompelis/typedef_gpu_map/test/2"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < columns; ++j)\n  {\n    (cout << ocean[i][j].showAnimal()) << \" \";\n    if (ocean[i][j].type == 1)\n    {\n      fishCount++;\n    }\n\n    if (ocean[i][j].type == 2)\n    {\n      sharkCount++;\n    }\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JJ0421/Planet-Wa-Tor/Finale/6"}
{"code": "for (i = 0; i < (16 + 3); i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"(%d) gets iteration %d\\n\", id, i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/1.for/1"}
{"code": "for (i = 0; i < NGLOB; i++)\n{\n  displx[i] = 0.f;\n  disply[i] = 0.f;\n  displz[i] = 0.f;\n  velocx[i] = 0.f;\n  velocy[i] = 0.f;\n  velocz[i] = 0.f;\n  accelx[i] = 0.f;\n  accely[i] = 0.f;\n  accelz[i] = 0.f;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/specfem3d/omp-for/specfem3D-omp-for/0"}
{"code": "for (i = 0; i < count; i++)\n  processwork(parr[i]);\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_omp25/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  args[i] = (ARGS_FOR_THREAD *) malloc(sizeof(ARGS_FOR_THREAD));\n  args[i]->thread_id = i;\n  args[i]->num_elements = num_elements;\n  args[i]->matrixA = A;\n  args[i]->matrixU = U;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/4"}
{"code": "for (i = 0; i < col; i++)\n  soma += v1[i] * v2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/7"}
{"code": "for (i = 0; i < nf; i++)\n{\n  for (j = fptr[i]; j < fptr[i + 1]; j++)\n    rind[rptr[find[j]]++] = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/29"}
{"code": "for (int i = 0; i < size; i++)\n  printf(\"B[%d]: %f\\n\", i, B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/16"}
{"code": "for (int n = 0; n < num_vertices; n++)\n{\n  cheap[n] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lockfree/2"}
{"code": "for (int i = 0; i < (WIDTH + 2); i++)\n{\n  row[i].setOwner(owner);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yang0228/zombieApocalypse-MPI-OPENMP/stage2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    y[i] = y[i] + (A[i][j] * x[j]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnrn/Introduction-to-Algorithms/MultiThreaded/MatVec/omp/matvec/1"}
{"code": "for (int i = 0; i < count; i++)\n{\n  for (int j = 0; j < 256; j++)\n  {\n    if (occurrences_map[i][j].count > 0)\n      printf(\"%d - %d \\n\", occurrences_map[i][j].code, occurrences_map[i][j].count);\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par2/5"}
{"code": "for (int i = 0; i < N; i++)\n  printf(\"I am from loop two %d\\n\", i + 50);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Barrier_openmp/1"}
{"code": "for (int np = 0; np < nProj; np++)\n{\n  pad_projections(d_pProj, nDetXMap, nDetYMap, nDetXMap, np);\n  d_pProj_tmp = (d_pProj + ((nDetXMap * nDetYMap) * np)) + 1;\n  memset(d_pProj_tmp, 0, nPixY * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  Xid[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/7"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  fprintf(file, \"%0.16lf\\n\", (double) curr_x);\n  curr_x += 0.00000476837158203125;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task10/main/10"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    for (int k = 0; k < n; k++)\n    {\n      product[calc_index(l, m, i, j)] += a[calc_index(l, m, i, k)] * b[calc_index(m, n, k, l)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/bench/bench_zzz/0"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 5; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemafe7/SistemasDistribuidos/p5/2"}
{"code": "for (int k = 0; k < workerCount; ++k)\n{\n  if (totalWork[k] > max)\n  {\n    max = totalWork[k];\n    indexOfMax = k;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(workerCount, totalWork, max, indexOfMax)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/KR/NotWorking/0"}
{"code": "for (int id = 0; id < sizepernode; id++)\n{\n  int node;\n  int index;\n  bool flag;\n  int parent[5] = {0};\n  int pre[NODE_N] = {0};\n  int state[5] = {0};\n  int i;\n  int j;\n  int parN = 0;\n  int tmp;\n  int t;\n  int t1 = 0;\n  int t2 = 0;\n  float ls = 0;\n  int Nij[STATE_N] = {0};\n  D_findComb(parent, id, NODE_N - 1);\n  for (i = 0; i < 4; i++)\n  {\n    if (parent[i] > 0)\n      parN++;\n\n  }\n\n  for (node = 0; node < NODE_N; node++)\n  {\n    j = 1;\n    for (i = 0; i < NODE_N; i++)\n    {\n      if (i != node)\n        pre[j++] = i;\n\n    }\n\n    for (tmp = 0; tmp < parN; tmp++)\n      state[tmp] = 0;\n\n    index = (sizepernode * node) + id;\n    t = 0;\n    while (D_getState(parN, state, t++))\n    {\n      ls = 0;\n      for (tmp = 0; tmp < STATE_N; tmp++)\n        Nij[tmp] = 0;\n\n      for (t1 = 0; t1 < DATA_N; t1++)\n      {\n        flag = true;\n        for (t2 = 0; t2 < parN; t2++)\n        {\n          if (D_data[(t1 * NODE_N) + pre[parent[t2]]] != state[t2])\n          {\n            flag = false;\n            break;\n          }\n\n        }\n\n        if (!flag)\n          continue;\n\n        Nij[D_data[(t1 * NODE_N) + node]]++;\n      }\n\n      tmp = STATE_N - 1;\n      for (t1 = 0; t1 < STATE_N; t1++)\n      {\n        ls += D_LG[Nij[t1]];\n        tmp += Nij[t1];\n      }\n\n      ls -= D_LG[tmp];\n      ls += D_LG[STATE_N - 1];\n      D_localscore[index] += ls;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/1"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  u[i][0] = 1.0;\n  u[i][x_points - 1] = 1.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Linear Convection/2-D_Linear_Convection/main/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  fprintf(foutput, \"%d\\n\", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dzarrr/Tugas-Sister-OpenMP/src/bitonic_sort/3"}
{"code": "for (c1 = (ni > nk) ? (ni) : (nk); c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nl + (-1)) < (nm + (-1))) ? (nl + (-1)) : (nm + (-1))); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/24"}
{"code": "for (int i = 0; i < (ifog.size() / 4); ++i)\n{\n  for (int j = 0; j < ifog[0].size(); ++j)\n  {\n    i_t[i][j] = ifog[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_1/2"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; ++j)\n  {\n    a[(i * s) + j] = (float) (q - ((10 * i) + (5 * j)));\n    b[(i * s) + j] = 0.0f;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/lu-decomposition/src/lu-decomposition_gpu/0"}
{"code": "for (int i = beg; i < left_end; ++i)\n{\n  ltpop[y[a[pvb][i]]] += sample_weight[a[pvb][i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ctiely/gbdt/tree/ClassificationTree/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  printf(\"Sensor Details for Day %d :- \\n\", i + 1);\n  printf(\"Sensor 1 = \");\n  scanf(\"%d\", &s1[i]);\n  printf(\"Sensor 2 = \");\n  scanf(\"%d\", &s2[i]);\n  printf(\"Sensor 3 = \");\n  scanf(\"%d\", &s3[i]);\n  printf(\"Sensor 4 = \");\n  scanf(\"%d\", &s4[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/genericbrian/Parallel-Programming/maxrainfall_dynamic_scheduling/1"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  if (Agents[i].species == 'B')\n  {\n    Agents[i].connection_replace = B_number[counter];\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c8/2"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp196o_xf8.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pepperpots/llvm-project-openmp/runtime/test/affinity/format/affinity_values/1"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < SDMGeom->L_NodeY(); j++)\n  {\n    for (int i = 0; i < KHALO; i++)\n    {\n      indx = IJK(((SNodeX() - KHALO) - PML.x) + i, HALO.y + j, HALO.z + k);\n      indx1 = (i + (j * KHALO)) + ((k * KHALO) * SDMGeom->L_NodeY());\n      var[indx] = bn_rx[(((indx_var - 1) * size) + indx1) + ((time * size) * 9)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/30"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testDrand48(80000000000, i);\n  printf(\"testDrand48 | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc(), stop(), stopt() / 8e10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/3"}
{"code": "for (int i = 0; i != ((int) n_nodes); ++i)\n{\n  mVectorsOfNeighNodes[i].clear();\n  mVectorsOfDistances[i].clear();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/4"}
{"code": "for (i1 = 0; i1 < n1; i1++)\n{\n  z[i3][i2][i1] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(n3 ,i1 ,i2 ,z ,n1 ,n2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/20"}
{"code": "for (int i = 0; i < sectionSize; ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    bucket1[(iArray[i][j] / iExp) % 10]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/16"}
{"code": "for (i = ju; i < ku; i++)\n  l++;\n\n", "pragma": "omp for reduction(+: l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/5"}
{"code": "for (int i = k + 1; i < size; i++)\n{\n  for (int j = k + 1; j < size; j++)\n    a_[i][j] -= __temp[i] * u_r[j];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/new_openmp/1"}
{"code": "for (k = 0; k < n_clus; k++)\n{\n  for (ch = 0; ch < n_ch; ch++)\n  {\n    centers[(k * n_ch) + ch] = 0;\n  }\n\n  counts[k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielemirando/image-segmentation/src/segmentation_omp/6"}
{"code": "for (j = 1; j < (procCoords.y_cells_num - 1); j++)\n{\n  delta_f[(j * procCoords.x_cells_num) + i] = (((f[(j * procCoords.x_cells_num) + i] - recv_message_lr[j]) - (recv_message_rl[j] - f[(j * procCoords.x_cells_num) + i])) / hx2) + (((f[(j * procCoords.x_cells_num) + i] - f[((j - 1) * procCoords.x_cells_num) + i]) - (f[((j + 1) * procCoords.x_cells_num) + i] - f[(j * procCoords.x_cells_num) + i])) / hy2);\n}\n\n", "pragma": "            #pragma omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/12"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) reduction(+:cluster_changes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp2_impl/0"}
{"code": "for (int i = 0; i < this->image.rows; i++)\n{\n  for (int j = 0; j < this->image.cols; j++)\n  {\n    temp(i, j) = this->image(i, j) + img.image(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OluwaseunOjeleye/OpenMP-based-Image-Processing-/image_processing/IP/2"}
{"code": "for (int i = 0; i < numbers; ++i)\n{\n  float rand_x = get_random_number(a, b);\n  float rand_y = get_random_number(a, b);\n  float distance = sqrt((((double) (rand_x - 0.0)) * (rand_x - 0.0)) + ((rand_y - 0.0) * (rand_y - 0.0)));\n  if (distance < radius)\n  {\n    counter += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/monte_carlo_pi/src/main/0"}
{"code": "for (i = 0; i < 10000; i++)\n  for (j = 0; j < 10000; j++)\n  Q[i][j] = (0.001 * i) * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.5/1"}
{"code": "for (unsigned int i = 0; i < no_of_nodes; i++)\n{\n  fscanf(fp, \"%d %d\", &start, &edgeno);\n  s[i] = start;\n  e[i] = edgeno;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_test/0"}
{"code": "for (int i = 0; i < ((height * width) * 3); i++)\n{\n  pic[i] = stretched[pic[i]];\n}\n\n", "pragma": "            #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GermanRandle/contrast-openmp/image-processor/main/8"}
{"code": "for (int i = 0; i < maximum; ++i)\n{\n  if (Prime(i) == 1)\n    count++;\n\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiranor/IT_LR4/main/1"}
{"code": "for (k = 0; k < num_possible_vaules_aux; k++)\n{\n  taules_aux[k] = init_datasetV2(i, j, taules[k].taula);\n  aux += taules_aux[k][0].nelem;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/14"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shafaet/OpenMP-Examples/Parallel Matrix Multiplication/2"}
{"code": "for (i = 0; i < ((int) nParticles); i++)\n{\n  if (gBestFitness == pBestFitness[i])\n    min = i;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/omp_parallel/1"}
{"code": "for (i = 1; i <= 46; i++)\n{\n  R46 = 0.50 * R46;\n  T46 = 2.0 * T46;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/2"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  a = 2;\n}\n\n", "pragma": "  #pragma omp parallel for ordered(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_ast_print/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = (b[i] = i * 1.1f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZishanAhmedOnik/OPENMP/divAndConq/1"}
{"code": "for (char i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/1"}
{"code": "for (size_t whichPt = 0; whichPt < N_value; whichPt++)\n{\n  center_tem[(whichDim * K_value) + data.group[whichPt]] += data.pts[whichPt + (data.N * whichDim)];\n  count[data.group[whichPt]]++;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jimmy3769tw/K-meansClusteringAlgorithm_OpenCLandOpenMP/src/kmeansSOAp/2"}
{"code": "for (c1 = (((ni > nj) ? (ni) : (nj)) > nm) ? ((ni > nj) ? (ni) : (nj)) : (nm); c1 <= (nk + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/23"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, hydro_data->r0[i] - (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] - (0.5 * hydro_data->r1_size[i]), 0);\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, hydro_data->r0[i] + (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] + (0.5 * hydro_data->r1_size[i]), 0);\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], position_phi);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, position_phi);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/26"}
{"code": "for (cnt = 0; cnt < 2; ++cnt)\n  for (int j = cnt; j < (4 + cnt); j++)\n  k = cnt;\n\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_codegen/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  b = 100;\n  d = 10;\n  printf(\"Thread %d, iteration %d: b = %d, c = %d, d = %d, m = %d\\n\", omp_get_thread_num(), i, b, c, d, m);\n  a[i] = omp_get_thread_num();\n  b = omp_get_thread_num();\n  c = omp_get_thread_num();\n  d = omp_get_thread_num();\n  m = omp_get_thread_num();\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i,b) firstprivate(c) lastprivate(d) shared(a,m) schedule(dynamic, 3) num_threads(1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeesooxkim/parallel-programming/main/1"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    arrayX[x] += 1 + (5 * randn(seed, x));\n    arrayY[x] += (-2) + (2 * randn(seed, x));\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/2"}
{"code": "for (i = 1; i < (line + 1); ++i)\n{\n  for (j = 1; j < (col + 1); ++j)\n  {\n    int temp_max = fill_table(table, i, j, qline, dline, match, mismatch, gap, max_table);\n    max_table = temp_max;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(table,qline,dline,match,mismatch,gap,max_table) private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GNtousakis/OpenMP-POSIX-threads/lab1_omp/main/0"}
{"code": "for (size_t i = 0; i < 100000000; ++i)\n  result += 1.0 / (i + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alecsmirnov/nstu-parallel-programming/3/example19/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  allPoints[i].x = allPoints[i].x + (moment * allPoints[i].vX);\n  allPoints[i].y = allPoints[i].y + (moment * allPoints[i].vY);\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Point/2"}
{"code": "for (int i = oldsize; i < tmp->size; i++)\n{\n  tmp->tab[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/3"}
{"code": "for (int i = 0; i < m_nRows; i++)\n{\n  for (int j = 0; j < m_nLayers; j++)\n  {\n    if (!FloatEqual(data[i][j], NODATA_VALUE))\n    {\n      if (FloatEqual(m_2DData[i][j], NODATA_VALUE))\n      {\n        m_2DData[i][j] = 0.f;\n      }\n\n      m_2DData[i][j] = ((m_2DData[i][j] * m_Counter) + data[i][j]) / (m_Counter + 1.f);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/3"}
{"code": "for (int j = 0; j < size_u[0]; j++)\n{\n  for (int k = 0; k < size_u[1]; k++)\n  {\n    u[0][j][k] = 0.0;\n    u[1][j][k] = 0.0;\n    u[2][j][k] = 0.0;\n    vp[j][k] = 1.5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation_static_alloc/1"}
{"code": "for (n = 0; n < N; n++)\n{\n  sum0 = -INFINITY;\n  sum1 = -INFINITY;\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    if (rsctrellis.fm[k])\n    {\n      sum1 = max(sum1, A1[k + (n * rsctrellis.numStates)] + B1[k + (n * rsctrellis.numStates)]);\n      sum0 = max(sum0, A0[k + (n * rsctrellis.numStates)] + B0[k + (n * rsctrellis.numStates)]);\n    }\n    else\n    {\n      sum0 = max(sum0, A1[k + (n * rsctrellis.numStates)] + B1[k + (n * rsctrellis.numStates)]);\n      sum1 = max(sum1, A0[k + (n * rsctrellis.numStates)] + B0[k + (n * rsctrellis.numStates)]);\n    }\n\n  }\n\n  extrinsic_coded[(2 * n) + 1] = (sum0 - sum1) - Lc2I[n];\n}\n\n", "pragma": "#pragma omp parallel for private(n, k, sum0, sum1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/9"}
{"code": "for (i = 0; i < n; ++i)\n  ar.pb((rand() % G) + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Bitonic_sort_OpenMP/3"}
{"code": "for (int i = 0; i < num_regions; ++i)\n{\n  scores[i] = 0;\n  my_scores[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajmorton/prog_parallelisation/mandelbrot_mpi/code/final/2"}
{"code": "for (int i = 2; i < np; i++)\n  dd2_left[i] = (dd1[i] - dd1[i - 1]) / (xp_m[i] - xp_m[i - 2]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/69"}
{"code": "for (i = 0; i < NB; i++)\n{\n  I = i * NB;\n  for (j = 0; j < NB; j++)\n  {\n    tmp = C[I + j];\n    for (k = 0; k < NB; k++)\n    {\n      tmp += A[I + k] * B[(k * NB) + j];\n    }\n\n    C[I + j] = tmp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/matrix_multiplication/dense_algebra_omp/5"}
{"code": "for (uint s = 0; s < lambdaSize; s++)\n{\n  coefDiff = lambda_Coul[s] - lambda_Coul[iState];\n  energyDiff[s].self += coefDiff * en_self;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/31"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < (N - i); j++)\n{\n  c[(i * N) + j] = a[i] * b[j];\n}\n\n\n", "pragma": "omp teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/collapse-nonrectangle/collapse-nonrectangle/0"}
{"code": "for (unsigned long i = 0; i < tiles.size(); ++i)\n{\n  RenderTile(tiles[i], cam, world, ns);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adamleighfish/c3po/src/c3p0/1"}
{"code": "for (k = ki1; k < (ki2 - 1); k++)\n{\n  for (i = ibeg; i < ifin1; i++)\n  {\n    frc2 = frc2 + (((((((phi1[k][i] + phi1[k][i + 1]) + phi1[k + 1][i]) + phi1[k + 1][i + 1]) + phi2[k][i]) + phi2[k][i + 1]) + phi2[k + 1][i]) + phi2[k + 1][i + 1]);\n  }\n\n}\n\n", "pragma": "omp for reduction(+:frc2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/pintgr/4"}
{"code": "for (int j = 0; j < nCols; j++)\n{\n  arrayC[i][j] = arrayA[i][j] + arrayB[i][j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/MatrixOperations/MatrixOperations/Parallel/1"}
{"code": "for (i = 0; i < 10000.0; i++)\n  m[i] = malloc(10000.0 * (sizeof(double *)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HardProxy/OpenMP/prog_in/1"}
{"code": "for (int i = 0; i < nSteps; i++)\n{\n  x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andrinr/uzh-hpc/exercise_session_02/cpi_omp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    c[i][j] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/4.Eigen_Vector_Values/eigen/12"}
{"code": "for (int i = 0; i < testCount; i++)\n{\n  resTime += TestBruteForceMatch(matrix1, matrix2, res1, N, M);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brelok-the-pok/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/7"}
{"code": "for (int i = 0; i < (*tam); i++)\n{\n  vetorInvertido[i] = vet[((*tam) - i) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/13"}
{"code": "for (i = 0; i < size; i++)\n  printf(\"%d  \", arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/24"}
{"code": "for (i = 0; i < life->nrows; i++)\n{\n  free(life->grid[i]);\n  free(life->next_grid[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiTo97/gol/src/cpu/gol/1"}
{"code": "for (j = 1; j <= ma; j++, wptr++)\n  if ((*wptr) > wmax)\n  wmax = *wptr;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reedv/Tircis/tircis_process_cmd_v4/svdfit_d/2"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  random_angle = dist(gen);\n  cell(ci).c_psi += sqrt((dt0 * Dr) * 2) * random_angle;\n  for (d = 0; d < NDIM; d++)\n  {\n    veltmp = cell(ci).cvel(d);\n    aold = cell(ci).vacc(0, d);\n    anew = cell(ci).cforce(d) / cell(ci).getNV();\n    veltmp = anew + (v0 * (((1 - d) * cos(cell(ci).c_psi)) + (d * sin(cell(ci).c_psi))));\n    cell(ci).setCVel(d, veltmp);\n    for (vi = 0; vi < cell(ci).getNV(); vi++)\n      cell(ci).setVAcc(vi, d, anew);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/116"}
{"code": "for (unsigned i = 0; i < N; ++i)\n{\n  data[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/tasking/hidden_helper_task/capacity_mix_threads/0"}
{"code": "for (i = 0; i < NSTEPS; i++)\n{\n  compute(NPARTS, 3, position, velocity, mass, force, &potential, &kinetic);\n  update(NPARTS, 3, position, velocity, force, accel, mass, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_MolecularDynamic/c_md/6"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  neighbor = ((((((d[i - 1] + d[i]) + d[i + 1]) + a[((n * (n - 1)) + i) - 1]) + a[((n * (n - 1)) + i) + 1]) + a[(n * (n - 2)) + i]) + a[((n * (n - 2)) + i) - 1]) + a[((n * (n - 2)) + i) + 1];\n  b[(n * (n - 1)) + i] = find_new_a(a[(n * (n - 1)) + i], neighbor);\n}\n\n", "pragma": "omp for private(i, neighbor) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannisLamp/game-of-life/mpi_openmp/ompi_functions/4"}
{"code": "for (int i = 0; i < chromo_length; i++)\n{\n  dist_matrix[i] = calloc(chromo_length, sizeof(float));\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THRDS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IamFinallyALIVE/Parallelizing-Genetic-Algorithm-for-Estimating-Optimal-Hamilton-Cycle-in-Random-Graphs-using-OpenMp/GA_TSP_Parallel/0"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n  a[i][j] = ((float) rand()) / ((float) 32767);\n\n\n", "pragma": "omp parallel for private(i, j, k, kk, jj, sum) shared(a, b, c, en) default(none) collapse(3) schedule(dynamic, 4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohinarora/OpenMP/Dense_MatMul_OpenMP/M-M_blocked_omp/0"}
{"code": "for (int i = 1; i < 800; i++)\n{\n  for (int j = 0; j < 800; j++)\n  {\n    output[i].charge += final[i][j] * neuron[2 - 1][j].active;\n  }\n\n  output[i].active = tanh(output[i].charge);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_omp/2"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    r = rand() % 100;\n    M[i][j] = r;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Helogizzy/Matrix_Multiplication_OpenMP/main/1"}
{"code": "for (int channel = 0; channel < target_nc; channel++)\n{\n  for (int y = 0; y < target_h; y++)\n  {\n    for (int x = 0; x < target_w; x++)\n    {\n      int id = (x + (y * target_w)) + ((channel * target_w) * target_h);\n      if (boundryPixelArray[id] == BOUNDRY)\n      {\n        if (x < (*boundBoxMinX))\n        {\n          *boundBoxMinX = x;\n        }\n\n        if (x > (*boundBoxMaxX))\n        {\n          *boundBoxMaxX = x;\n        }\n\n        if (y < (*boundBoxMinY))\n        {\n          *boundBoxMinY = y;\n        }\n\n        if (y > (*boundBoxMaxY))\n        {\n          *boundBoxMaxY = y;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/2"}
{"code": "for (i = 0; i < 100; i++)\n  x[t]++;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahmedmokeddem/OpenMP/Exercice2/0"}
{"code": "for (int i = start; i < end; i++)\n{\n  printf(\"%.15f \", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tanghyd/CITS5507Project01/random_array/3"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  fprintf(resultFile, \"C%d  \\n\", i + 1);\n  for (j = 0; j < dimension; j++)\n  {\n    fprintf(resultFile, \"%4.3lf    \", allCenters[i].transactions[j]);\n  }\n\n  fprintf(resultFile, \"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roiedanino/K-Means-Parallel-Implementation/kMeansRoieDanino/Kmeans_Parallel/4"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  re += (X[i].real * Y[i].real) - (X[i].imaginary * Y[i].imaginary);\n  im += (X[i].real * Y[i].imaginary) + (X[i].imaginary * Y[i].real);\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+ : re) reduction(+ : im)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  fprintf(out_file, \"jarak dari node %d: \", i);\n  for (int j = 0; j < N; j++)\n  {\n    fprintf(out_file, \"%d \", matrix[i][j]);\n  }\n\n  fprintf(out_file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/5"}
{"code": "for (int k = y_min; k <= y_max; k++)\n{\n  #pragma ivdep\n  for (int j = x_min; j <= x_max; j++)\n  {\n    energy0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = energy1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_reset_field/1"}
{"code": "for (int jj = internal_ystart; jj <= internal_ystop; jj++)\n{\n  for (int ji = internal_xstart; ji <= (internal_xstop - 1); ji++)\n  {\n    momentum_u_code(ji, jj, width, ua, un, vn, hu, hv, ht, ssha_u, sshn_t, sshn_u, sshn_v, tmask, dx_u, dx_v, dx_t, dy_u, dy_t, area_u, gphiu, rdt, cbfr, visc, omega, d2r, g);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/1"}
{"code": "for (c1 = (c0 + 1) / 2; c1 <= min(c0, (n - 2) / 16); c1 += 1)\n  for (c3 = max(2, ((16 * c0) - (16 * c1)) + 1); c3 <= min(n - 1, ((16 * c0) - (16 * c1)) + 16); c3 += 1)\n  for (c4 = max(0, ((-c1) + ((n + 1) / 16)) - 1); c4 <= min((n - 1) / 16, (-c1) + (((n + c3) - 2) / 16)); c4 += 1)\n  for (c6 = max(max(((-n) + (16 * c1)) + 1, (-n) + c3), ((-16) * c4) - 14); c6 <= min(min(-1, ((-n) + (16 * c1)) + 16), (c3 - (16 * c4)) - 1); c6 += 1)\n  for (c10 = max(16 * c4, (-c6) + 1); c10 <= min((16 * c4) + 15, (c3 - c6) - 1); c10 += 1)\n  c[-c6][c3 - c6] = MIN(c[-c6][c3 - c6], (w[-c6][c3 - c6] + c[-c6][c10]) + c[c10][c3 - c6]);\n\n\n\n\n\n", "pragma": "  #pragma omp parallel for shared(c0) private(c1,c3,c4,c6,c10) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/knuth/knut/4"}
{"code": "for (unsigned int var = 0; var < QwD.size(); var++)\n{\n  if (var == procID)\n  {\n    for (unsigned int var3 = 0; var3 < pt.size(); var3++)\n    {\n      int exist = false;\n      for (unsigned int var2 = 0; var2 < QwD[var].size(); var2++)\n      {\n        if (pt[var3] == QwD[var].at(var2).getTId())\n        {\n          exist = true;\n          break;\n        }\n\n      }\n\n      if (!exist)\n      {\n        QwD[var].push_back(taskList[pt[var3]]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/2"}
{"code": "for (i = 0; i < (n - 1); i++)\n  error += fabs(a[i] - a[i + 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_5/c_red_black/3"}
{"code": "for (i = 0; i < P; i++)\n{\n  sum_sq += (A_next[(i * P) + i] - A_current[(i * P) + i]) * (A_next[(i * P) + i] - A_current[(i * P) + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/8"}
{"code": "for (i = 0; i < (1 << NUM_BUCKETS_LOG_2); i++)\n  for (k = myid + 1; k < num_threads; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/14"}
{"code": "for (int i = 0; i < Nelem; ++i)\n{\n  for (int k = EIA[i]; k < EIA[i + 1]; ++k)\n  {\n    int j = EJA[k];\n    int b = NIA[j];\n    int e = NIA[j + 1] - 1;\n    NJA[e]++;\n    NJA[b + NJA[e]] = i;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lovgager/parallel-methods/FirstTask/FirstTask/4"}
{"code": "for (c = L; c <= H; c++)\n{\n  list2[c - L] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/sieve/sieve.hybrid/0"}
{"code": "for (int y = 0; y < height; y++)\n  for (int x = 0; x < width; x++)\n  convolution_1d_h(red, green, blue, x, y, result);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/gaussian/gaussian2/5"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    m[(100 * k) + i][(100 * l) + j] = b[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/igrishaev/vsu-prp/matrix_fox_omp/6"}
{"code": "for (i = 0; i < Size; i++)\n{\n  fscanf(fp, \"%f\", &Array[i]);\n  Array[i + Size] = Array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AbhishekRamamurthy/OpenMP-Cuda/AutoCo_OpenMP/1"}
{"code": "for (j = 0; j < max_threads; j++)\n{\n  if (active_threads[j])\n    threadsnum++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_auto/2"}
{"code": "for (i = 0; i < num_elems; i++)\n  vec[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/test/vec_add/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  array[i] = value;\n}\n\n", "pragma": "omp parallel for num_threads(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/h4koo/Arquitectura-taller2/src/saxpy_par/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  sum[m] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/16"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  arr[i] = arr[i];\n  printf(\"%d\\n\", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/final_code/main/4"}
{"code": "for (int g = 0; g < I.n_egroups; g++)\n{\n  psi[g] = ((t1[g] + t2[g]) + t3[g]) + t4[g];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/18"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a++;\n  printf(\"Thread %d Iteration %d a=%d\\n\", omp_get_thread_num(), i, a);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  s[i] = left + i;\n  tid = omp_get_thread_num();\n  printf(\"Thread number %d allocated s[%d]=%d\\n\", tid, i, s[i]);\n}\n\n", "pragma": "omp parallel for num_threads(n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/search/1"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  a[i] = (rand() % 100) * 1.0;\n  b[i] = ((rand() % 100) + 500) * 1.0;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,10) num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mazuruk-O/OpenMP_example/OpenMp_1_lab/OpenMP_1_lab/OpenMP_1_lab/0"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericParticles[i]->FirstCalculateRightHandSide(r_process_info, dt);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/2"}
{"code": "for (size_t i = 0; i < config.threads_; ++i)\n  threads.push_back(launch_thread(mask_worker, &next, &seqs, &masking, hard_mask));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/diamond-omp/masking/12"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (A[i][j] != B[i][j])\n    {\n      printf(\"A[%d][%d] = %d, B[%d][%d] = %d\\n\", i, j, A[i][j], i, j, B[i][j]);\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AYaddaden/matrix-multiplication/main/7"}
{"code": "for (i = 0; i < 2; i++)\n{\n  SetRandomSeed(w + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giambagiamba/progressbar/tests/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (sum = 0.0, j = ptr[i]; j < ptr[i + 1]; j++)\n  {\n    if (norm == 2)\n    {\n      sum += val[j] * val[j];\n    }\n    else\n      if (norm == 1)\n    {\n      sum += val[j];\n    }\n\n\n  }\n\n  if (sum > 0)\n  {\n    if (norm == 2)\n    {\n      sum = 1.0 / sqrt(sum);\n    }\n    else\n      if (norm == 1)\n    {\n      sum = 1.0 / sum;\n    }\n\n\n    for (j = ptr[i]; j < ptr[i + 1]; j++)\n    {\n      val[j] *= sum;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,sum) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/3"}
{"code": "for (i = 0; i < num_rows; ++i)\n{\n  getline(&str_srr2[i], &n, f);\n}\n\n", "pragma": "omp parallel for num_threads(n_thread) default(none), shared(num_rows, str_srr2, n, f)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/test/0"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    aMatr3[wI][wJ] = 0;\n    for (wK = 0; wK < SMALLN_MATR; wK += 4)\n    {\n      wTemp[0] = aMatr2[wK][wJ];\n      wTemp[1] = aMatr2[wK + 1][wJ];\n      wTemp[2] = aMatr2[wK + 2][wJ];\n      wTemp[3] = aMatr2[wK + 3][wJ];\n      wV1 = _mm_load_ps(&aMatr1[wI][wK]);\n      wV2 = _mm_load_ps(wTemp);\n      wV3 = _mm_dp_ps(wV1, wV2, 0xFF);\n      _mm_store_ps(wTemp, wV3);\n      aMatr3[wI][wJ] += wTemp[0];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/7"}
{"code": "for (i = 0; i < 64; i++)\n  _counters[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/specfem3d/aos-omp-for/specfem3D-omp-for/12"}
{"code": "for (i = 0; i <= n; i++)\n{\n  primes[i] = true;\n}\n\n", "pragma": "#pragma omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mahmoud-elzorkany/Open_Mp/Eratosthene's Sieve/Eratosthene's Sieve/0"}
{"code": "for (int tt = 0; tt < params.maxIters; tt = tt + 2)\n{\n  av_vels[tt] = timestep(params, cells, tmp_cells, obstacles);\n  av_vels[tt + 1] = timestep(params, tmp_cells, cells, obstacles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abcdrm/LBM-OpenMP/d2q9-bgk/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (omp[i] != seq[i])\n  {\n    puts(\"not equal\");\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ysph/parallel-stuff/b_omp/quick_sort/4"}
{"code": "for (int i = 0; i < i_size_; ++i)\n{\n  for (int j = 0; j < j_size_; ++j)\n  {\n    new_matrix(j, i) = (*this)(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/7"}
{"code": "for (i = 0; i < m_size; i++)\n  m_totFitness += m_population[i].unitFitness;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PushenGao/Parallel-Computing-/GA_Queens_OpenMp/12"}
{"code": "for (j = 1; j <= NODESY; j++)\n  TOPO[0][j] = TOPO[1][j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/70"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    u[i + 1][j] = (-(psi[i + 1][j + 1] - psi[i + 1][j])) / dy;\n    v[i][j + 1] = (psi[i + 1][j + 1] - psi[i][j + 1]) / dx;\n  }\n\n}\n\n", "pragma": "omp parallel for default (shared) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/1"}
{"code": "for (j = 0; j < 100; j++)\n{\n  acc++;\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW3/Q1_1/0"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  printf(\"Outer dimension number %d\\n\", i);\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < (dim2 - 1); k++)\n    {\n      printf(\"%d, \", a[i][j][k]);\n    }\n\n    printf(\"%f\\n\", a[i][j][dim2 - 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/1"}
{"code": "for (k = 1; k <= (*nzv); k += 1)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/19"}
{"code": "for (i = 0; i < length; i++)\n{\n  GDALRasterIO(hBOut[i], GF_Write, 0, 0, nX, nY, lOut[i], nX, nY, GDT_Float32, 0, 0);\n  if (l[i] != 0)\n    free(l[i]);\n\n  if (lOut[i] != 0)\n    free(lOut[i]);\n\n  if (hD[i] != 0)\n    GDALClose(hD[i]);\n\n  if (hDOut[i] != 0)\n    GDALClose(hDOut[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_filling/main/4"}
{"code": "for (i = 0; i < M; i = i + 4)\n{\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[(i * M) + k] * B[(k * M) + j]);\n      r = r + (A[((i * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[((i * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[((i * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[(i * M) + j] = (alpha * r) + (beta * C[(i * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 1) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 1) * M) + j] = (alpha * r) + (beta * C[((i + 1) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 2) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 2) * M) + j] = (alpha * r) + (beta * C[((i + 2) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 3) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 3) * M) + j] = (alpha * r) + (beta * C[((i + 3) * M) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemm/11"}
{"code": "for (size_t k = 0; k < n; k++)\n{\n  double sumreal = 0;\n  double sumimag = 0;\n  for (size_t t = 0; t < n; t++)\n  {\n    double angle = (((2 * M_PI) * t) * k) / n;\n    if (inverse)\n      angle = -angle;\n\n    sumreal += cal_real(inreal[t], inimag[t], angle);\n  }\n\n  if (inverse)\n  {\n    outreal[k] = sumreal / n;\n    outimag[k] = sumimag / n;\n  }\n  else\n  {\n    outreal[k] = sumreal;\n    outimag[k] = sumimag;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_dft/c4_1/dft/0"}
{"code": "for (int i = 0; i < G->size; i++)\n{\n  qsort(G->nodes[i]->neighbours, G->nodes[i]->degree, sizeof(G->nodes[i]->neighbours), compare);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/11"}
{"code": "for (; m < high; m += prime * next_multiple_factor(&wheel_index))\n  sieve.unset(m - low);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primesum/src/lmo/pi_lmo_parallel1/0"}
{"code": "for (a = 0; a < NODE_N; a++)\n{\n  for (j = 0; j < NODE_N; j++)\n  {\n    orders[a][j] = preOrders[a][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/1"}
{"code": "for (j = 0; j < inum[k]; j++)\n{\n  B[i] = pm(A[i]);\n}\n\n", "pragma": "                #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JamesdeLisle/OpenMP-messing/test2/1"}
{"code": "for (int8_t *qt = &q_table[0]; cur_val <= q_point[4]; ++qt, ++cur_val)\n{\n  if (cur_val <= (-q_point[3]))\n  {\n    *qt = -4;\n  }\n  else\n    if (cur_val <= (-q_point[2]))\n  {\n    *qt = -3;\n  }\n  else\n    if (cur_val <= (-q_point[1]))\n  {\n    *qt = -2;\n  }\n  else\n    if (cur_val < 0)\n  {\n    *qt = -1;\n  }\n  else\n    if (cur_val == 0)\n  {\n    *qt = 0;\n  }\n  else\n    if (cur_val < q_point[1])\n  {\n    *qt = 1;\n  }\n  else\n    if (cur_val < q_point[2])\n  {\n    *qt = 2;\n  }\n  else\n    if (cur_val < q_point[3])\n  {\n    *qt = 3;\n  }\n  else\n  {\n    *qt = 4;\n  }\n\n\n\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/FujiDecompressor/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n    ((cout << setw(2)) << a[i][j]) << \" \";\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/2/2/0"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  array[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1a/code/Game_Of_Life/2"}
{"code": "for (int jj = 0; jj < depth; ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int base = kk;\n    buffer[base + (((_chunk.y - HALO_PAD) + jj) * _chunk.x)] = buffer[base + ((((_chunk.y - HALO_PAD) - 1) - jj) * _chunk.x)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/2"}
{"code": "for (i = 1; i < 100; i++)\n{\n  {\n    is_larger = check_i_islarger2(i) && is_larger;\n    sum = sum + i;\n  }\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/parallel_for_ordered/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      for (i = 1; i < (grid_points[0] - 1); i++)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/38"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  unsigned char output[4096] = {0};\n  int i;\n  unsigned char *tag = (cur_salt->ct + cur_salt->ctlen) - cur_salt->tag_len;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    memset(output, 0, 4096);\n    aes_ccm_auth_decrypt(master[i], 256, cur_salt->ctlen - cur_salt->tag_len, cur_salt->iv, 13, cur_salt->add, cur_salt->addlen, cur_salt->ct, output, tag, cur_salt->tag_len);\n    if ((cur_salt->ctlen - cur_salt->tag_len) == 2)\n    {\n      if (strncmp((const char *) output, \"[]\", 2) == 0)\n        cracked[index + i] = 1;\n\n    }\n    else\n    {\n      if (output[0] != '[')\n        cracked[index + i] = 0;\n      else\n        if (strstr((const char *) output, \"\\\"updated\\\"\"))\n        cracked[index + i] = 1;\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/padlock_fmt_plug/0"}
{"code": "for (i = 0; i < n; i++)\n  chunk->checksum += cs[i].checksum;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP2/inf8601-lab2-2.1.3/encode/algo/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int idx = rand() % SIZE;\n  while (data[idx] >= 0)\n    idx = (idx + 1) % SIZE;\n\n  data[idx] = 1;\n  if (i == 0)\n  {\n    head = idx;\n    tail = idx;\n  }\n  else\n    if (i == (size - 1))\n  {\n    prev[idx] = tmp;\n    next[tmp] = idx;\n    tail = idx;\n  }\n  else\n  {\n    prev[idx] = tmp;\n    next[tmp] = idx;\n  }\n\n\n  tmp = idx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/8"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  sum2 = 0.0;\n  aij = ai;\n  jx = kx;\n  #pragma code_align(16)\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = head_x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    x_elem = tail_x[jx];\n    prod = a_elem * x_elem;\n    sum2 = sum2 + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  tmp1 = sum * alpha_i;\n  tmp2 = sum2 * alpha_i;\n  tmp1 = tmp1 + tmp2;\n  y[iy] = tmp1;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum,sum2) shared(a_i,head_x_i,tail_x_i,y_i) private(i,aij,jx,a_elem,prod,x_elem,j,ai,iy,tmp1,tmp2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/14"}
{"code": "for (int i = 0; i < seqLength; ++i)\n{\n  nextHiddenStateEfficient(input_t, h_tminus1, c_tminus1, hiddenSize, miniBatch);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_1/6"}
{"code": "for (j_imopVar111 = 1; j_imopVar111 < (grid_points[1] - 1); j_imopVar111++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n      {\n        rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/27"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1350[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/59"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  for (j = 0; j < Ny; j++)\n  {\n    u_1[i][j] = I(x[i], y[j]);\n    r[i][j] = analytical(x[i], y[j], 0);\n    if (w == 0)\n    {\n      fprintf(f0, \"%f %f %f %f \\n\\n\", x[i], y[j], u_1[i][j], r[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  {\n    arr[i] = (rand() % 500) + 1;\n    printf(\"%d \", arr[i]);\n  }\n  if (((i + 1) % 10) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task12/0"}
{"code": "for (i = 0; i < 32; i++)\n{\n  for (j = 0; j < 32; j++)\n  {\n    C[(i * 32) + j] = 0.0;\n    int k;\n    for (k = 0; k < 32; ++k)\n    {\n      C[(i * 32) + j] += A[(i * 32) + k] * B[(k * 32) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/26"}
{"code": "for (int i_batch = 0; i_batch < training_batch; i_batch++)\n{\n  int dev_id = omp_get_thread_num();\n  int index = i_batch * batch;\n  network->input = X->vals + (index * X->ncols);\n  network->truth = y->vals + (index * y->ncols);\n  tmp_total_batch = read_timer_ms();\n  tmp_forward = read_timer_ms();\n  tmp = read_timer_ms();\n  forward_convolutional_layer(network->layers[0], network->layers[0], network->input, network->layers[0]->output, 1);\n  time_conv1 += read_timer_ms() - tmp;\n  printf(\"conv1    forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv1);\n  tmp = read_timer_ms();\n  forward_pooling_layer(network->layers[0], network->layers[1], network->layers[0]->output, network->layers[1]->output, 1);\n  time_pool1 += read_timer_ms() - tmp;\n  printf(\"maxpool1 forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_pool1);\n  tmp = read_timer_ms();\n  forward_convolutional_layer(network->layers[1], network->layers[2], network->layers[1]->output, network->layers[2]->output, 1);\n  time_conv2 += read_timer_ms() - tmp;\n  printf(\"conv2    forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv2);\n  tmp = read_timer_ms();\n  forward_pooling_layer(network->layers[2], network->layers[3], network->layers[2]->output, network->layers[3]->output, 1);\n  time_pool2 += read_timer_ms() - tmp;\n  printf(\"maxpool2 forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_pool2);\n  tmp = read_timer_ms();\n  forward_connected_layer(network->layers[3], network->layers[4], network->layers[3]->output, network->layers[4]->output, 1);\n  time_connect1 += read_timer_ms() - tmp;\n  printf(\"connect1 forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect1);\n  tmp = read_timer_ms();\n  forward_connected_layer(network->layers[4], network->layers[5], network->layers[4]->output, network->layers[5]->output, 1);\n  time_connect2 += read_timer_ms() - tmp;\n  printf(\"connect2 forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect2);\n  tmp = read_timer_ms();\n  forward_connected_layer(network->layers[5], network->layers[6], network->layers[5]->output, network->layers[6]->output, 0);\n  time_connect3 += read_timer_ms() - tmp;\n  printf(\"connect3 forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect3);\n  tmp = read_timer_ms();\n  forward_softmax_layer(network->layers[6], network->layers[7], network->layers[6]->output, network->layers[7]->output);\n  time_softmax += read_timer_ms() - tmp;\n  printf(\"softmax  forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_softmax);\n  time_forward += read_timer_ms() - tmp_forward;\n  printf(\"forward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_forward);\n  network->cost = compute_loss_function(network->layers[7], network->truth, training_volume, training_epoch);\n  tmp_backward = read_timer_ms();\n  tmp = read_timer_ms();\n  backward_softmax_layer(network->layers[7], network->layers[6], network->layers[7]->delta, network->layers[6]->delta);\n  time_softmax_2 += read_timer_ms() - tmp;\n  printf(\"softmax  backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_softmax_2);\n  tmp = read_timer_ms();\n  backward_connected_layer(network->layers[6], network->layers[5], network->layers[6]->delta, network->layers[5]->delta, 0);\n  time_connect3_2 += read_timer_ms() - tmp;\n  printf(\"connect3 backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect3_2);\n  tmp = read_timer_ms();\n  backward_connected_layer(network->layers[5], network->layers[4], network->layers[5]->delta, network->layers[4]->delta, 1);\n  time_connect2_2 += read_timer_ms() - tmp;\n  printf(\"connect2 backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect2_2);\n  tmp = read_timer_ms();\n  backward_connected_layer(network->layers[4], network->layers[3], network->layers[4]->delta, network->layers[3]->delta, 1);\n  time_connect1_2 += read_timer_ms() - tmp;\n  printf(\"connect1 backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect1_2);\n  tmp = read_timer_ms();\n  backward_pooling_layer(network->layers[3], network->layers[2], network->layers[3]->delta, network->layers[2]->delta, 1);\n  time_pool2_2 += read_timer_ms() - tmp;\n  printf(\"pool2    backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_pool2_2);\n  tmp = read_timer_ms();\n  backward_convolutional_layer(network->layers[2], network->layers[1], network->layers[2]->delta, network->layers[1]->delta, 1);\n  time_conv2_2 += read_timer_ms() - tmp;\n  printf(\"conv2    backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv2_2);\n  tmp = read_timer_ms();\n  backward_pooling_layer(network->layers[1], network->layers[0], network->layers[1]->delta, network->layers[0]->delta, 1);\n  time_pool1_2 += read_timer_ms() - tmp;\n  printf(\"pool1    backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_pool1_2);\n  tmp = read_timer_ms();\n  backward_convolutional_layer(network->layers[0], network->layers[0], network->layers[0]->delta, network->layers[0]->delta, 1);\n  time_conv1_2 += read_timer_ms() - tmp;\n  printf(\"conv1    backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv1_2);\n  time_backward += read_timer_ms() - tmp_backward;\n  printf(\"backward epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_backward);\n  tmp_update = read_timer_ms();\n  float p1 = network->learning_rate / network->batch;\n  float p2 = (-network->decay) * network->batch;\n  float p3 = network->momentum;\n  tmp = read_timer_ms();\n  conv_update(network->layers[0]->n, network->layers[0]->biases, network->layers[0]->bias_updates, network->layers[0]->nweights, network->layers[0]->weights, network->layers[0]->weight_updates, p1, p2, p3);\n  time_conv1_3 += read_timer_ms() - tmp;\n  printf(\"conv1     update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv1_3);\n  tmp = read_timer_ms();\n  conv_update(network->layers[2]->n, network->layers[2]->biases, network->layers[2]->bias_updates, network->layers[2]->nweights, network->layers[2]->weights, network->layers[2]->weight_updates, p1, p2, p3);\n  time_conv2_3 += read_timer_ms() - tmp;\n  printf(\"conv2     update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_conv2_3);\n  tmp = read_timer_ms();\n  n = network->layers[4]->inputs * network->layers[4]->outputs;\n  connect_update(network->layers[4]->outputs, network->layers[4]->biases, network->layers[4]->bias_updates, n, network->layers[4]->weights, network->layers[4]->weight_updates, p1, p2, p3);\n  time_connect1_3 += read_timer_ms() - tmp;\n  printf(\"connect1  update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect1_3);\n  tmp = read_timer_ms();\n  n = network->layers[5]->inputs * network->layers[5]->outputs;\n  connect_update(network->layers[5]->outputs, network->layers[5]->biases, network->layers[5]->bias_updates, n, network->layers[5]->weights, network->layers[5]->weight_updates, p1, p2, p3);\n  time_connect2_3 += read_timer_ms() - tmp;\n  printf(\"connect2  update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect2_3);\n  tmp = read_timer_ms();\n  n = network->layers[6]->inputs * network->layers[6]->outputs;\n  connect_update(network->layers[6]->outputs, network->layers[6]->biases, network->layers[6]->bias_updates, n, network->layers[6]->weights, network->layers[6]->weight_updates, p1, p2, p3);\n  time_connect3_3 += read_timer_ms() - tmp;\n  printf(\"connect3  update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_connect3_3);\n  time_update += read_timer_ms() - tmp_update;\n  printf(\"update epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_update);\n  time_total_batch += read_timer_ms() - tmp_total_batch;\n  printf(\"total_batch epoch# %d batch# %d device# %d: %lf\\n\", i_epoch, i_batch, dev_id, time_total_batch);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(num_dev) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/14"}
{"code": "for (i = 1; i < n; i++)\n{\n  printf(\",%d\", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_10/Ejercicio_1/bitonicSort_openmp/2"}
{"code": "for (int i = 0; i < n2; ++i)\n{\n  for (int j = 0; j < n3; ++j)\n  {\n    int sign = rand() % 2;\n    w2[i][j] = ((double) (rand() % 10)) / (10.0 * n3);\n    if (sign == 1)\n    {\n      w2[i][j] = -w2[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/7"}
{"code": "for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n{\n  colidx[k] = (colidx[k] - firstcol) + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/CG/cg_macc/1"}
{"code": "for (int i = 0; i < M.nrows; i++)\n{\n  sum = 0;\n  for (int j = M.indi[i] - sumnnzm; j < (M.indi[i + 1] - sumnnzm); j++)\n  {\n    sum += M.val[j] * x.val[M.indj[j]];\n  }\n\n  y.val[i] = sum;\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) lastprivate(sum)\t", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/2"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  allClusters[i].x = allPoints[i].x;\n  allClusters[i].y = allPoints[i].y;\n  allClusters[i].id = i;\n  allClusters[i].clusterSize = 0;\n  allClusters[i].diameter = 0;\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Cluster/0"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n  {\n    matA[i][j] = rand() % 10;\n    matB[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/7"}
{"code": "for (k = 0; k < (nz + (2 * hs)); k++)\n{\n  hy_dens_cell[k] = 0.;\n  hy_dens_theta_cell[k] = 0.;\n  for (kk = 0; kk < nqpoints; kk++)\n  {\n    z = (((k_beg + k) - hs) + 0.5) * dz;\n    if (data_spec_int == DATA_SPEC_COLLISION)\n    {\n      collision(0., z, r, u, w, t, hr, ht);\n    }\n\n    if (data_spec_int == DATA_SPEC_THERMAL)\n    {\n      thermal(0., z, r, u, w, t, hr, ht);\n    }\n\n    if (data_spec_int == DATA_SPEC_MOUNTAIN)\n    {\n      mountain_waves(0., z, r, u, w, t, hr, ht);\n    }\n\n    if (data_spec_int == DATA_SPEC_TURBULENCE)\n    {\n      turbulence(0., z, r, u, w, t, hr, ht);\n    }\n\n    if (data_spec_int == DATA_SPEC_DENSITY_CURRENT)\n    {\n      density_current(0., z, r, u, w, t, hr, ht);\n    }\n\n    if (data_spec_int == DATA_SPEC_INJECTION)\n    {\n      injection(0., z, r, u, w, t, hr, ht);\n    }\n\n    hy_dens_cell[k] = hy_dens_cell[k] + (hr * qweights[kk]);\n    hy_dens_theta_cell[k] = hy_dens_theta_cell[k] + ((hr * ht) * qweights[kk]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-omp/main/10"}
{"code": "for (i = 0; i < latent_texture_template.m_nrof_minu; ++i)\n{\n  max_index = distance(psimi, max_element(psimi, psimi + rolled_texture_template.m_nrof_minu));\n  max_val = *(psimi + max_index);\n  tmp_corr[i] = make_tuple(max_val, i, max_index);\n  psimi += rolled_texture_template.m_nrof_minu;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/14"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  H[i] = (double *) malloc(3 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiannisKalopisis/Parallel-image-filter-convolution/src/Project_Parallhla/0"}
{"code": "for (i = 0; i < threadNumber; i++)\n{\n  total += pStrips[i].UpdatePotentialSpillandPushToPQ_FirstTime(pStrips);\n}\n\n", "pragma": "\t#pragma omp parallel for reduction (+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallelfilling/openmp/parallel_priorityflooding/2"}
{"code": "for (size_t j = 0; j < gridLoc.size(); ++j)\n{\n  if (!gridLoc[j].inGrid)\n    continue;\n\n  ++numInGrid;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/7"}
{"code": "for (int row = 0; row < m; row++)\n{\n  out[row] = 0;\n  for (int col = 0; col < n; col++)\n  {\n    out[row] += mat[row][col] * vec[col];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/par_matrix_vect_mul/4"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  pr[i] = d / (N * 1.0);\n  for (int v = 0; v < rev[i].size(); v++)\n  {\n    int ver = rev[i][v];\n    pr[i] += ((prev[ver] * 1.0) / (outdeg[ver] * 1.0)) * (1.0 - d);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/baseline/1"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  qa = mod11A1a(l3[rowcol]);\n  if ((qa == 0) || (qa == 1))\n    lOut[rowcol] = l2[rowcol];\n  else\n    lOut[rowcol] = -28768;\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol, qa) shared (N, l2, l3, lOut)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_LST/lst/0"}
{"code": "for (int i = 0; i < size_nn; i++)\n{\n  int size_out = size_input - ((i + 1) * (r - 1));\n  layers[i] = new_layer(r, size_out);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ajoyola/CUDA_OpenMP_NeuralNetwork/OpenMP_Oyola/model/1"}
{"code": "for (int i = 0; i < matrix_size; i++)\n  for (int j = 0; j < matrix_size; j++)\n  for (int k = 0; k < matrix_size; k++)\n  product_matrix[(j * matrix_size) + i] += matrix_1[(j * matrix_size) + k] * matrix_2[(k * matrix_size) + i];\n\n\n\n", "pragma": "    #pragma omp parallel for num_threads(threads_num)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LuckThemAll/parallel-programming/OpenMP/task5/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int first = i & 1;\n  for (int j = first; j < (size - 1); j += 2)\n  {\n    if (array[j] > array[j + 1])\n      swap(&array[j], &array[j + 1]);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Bubble_sort_Serial_Parallel/2"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    uijk = us[i][j][k];\n    up1 = us[i + 1][j][k];\n    um1 = us[i - 1][j][k];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dx1tx1 * ((u[i + 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i - 1][j][k][0]))) - (tx2 * (u[i + 1][j][k][1] - u[i - 1][j][k][1]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dx2tx1 * ((u[i + 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i - 1][j][k][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[i + 1][j][k][1] * up1) - (u[i - 1][j][k][1] * um1)) + ((((u[i + 1][j][k][4] - square[i + 1][j][k]) - u[i - 1][j][k][4]) + square[i - 1][j][k]) * c2)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dx3tx1 * ((u[i + 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i - 1][j][k][2]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][2] * up1) - (u[i - 1][j][k][2] * um1)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dx4tx1 * ((u[i + 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i - 1][j][k][3]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[i + 1][j][k][3] * up1) - (u[i - 1][j][k][3] * um1)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dx5tx1 * ((u[i + 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i - 1][j][k][4]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[i + 1][j][k][4] * rho_i[i + 1][j][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i - 1][j][k][4] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[i + 1][j][k][4]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[i - 1][j][k][4]) - (c2 * square[i - 1][j][k])) * um1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private (uijk,up1,um1,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/76"}
{"code": "for (int n = 200; n <= 2000; n = n + 200)\n{\n  printf(\"Calculations for %d x %d matrix\\n\\n\", n, n);\n  double sum_serial = 0;\n  double sum_parallel = 0;\n  double sum_of_squares_serial = 0;\n  double sum_of_squares_parallel = 0;\n  double sample_times_serial[SAMPLES];\n  double sample_times_parallel[SAMPLES];\n  populate_matrix(n);\n  for (int i = 0; i < SAMPLES; i++)\n  {\n    double serial = serial_multiplication(n);\n    double parallel = parallel_for_multiplication(n);\n    sample_times_serial[i] = serial;\n    sample_times_parallel[i] = parallel;\n    sum_serial += serial;\n    sum_parallel += parallel;\n  }\n\n  double average1 = sum_serial / SAMPLES;\n  double average2 = sum_parallel / SAMPLES;\n  for (int itr = 0; itr < SAMPLES; itr++)\n  {\n    sum_of_squares_serial += pow(average1 - sample_times_serial[itr], 2);\n    sum_of_squares_parallel += pow(average2 - sample_times_parallel[itr], 2);\n  }\n\n  double sd1 = sqrt(sum_of_squares_serial / (SAMPLES - 1));\n  double sd2 = sqrt(sum_of_squares_parallel / (SAMPLES - 1));\n  printf(\"Average time (mean) for Serial %d x %d with %d samples = %f\\n\", n, n, SAMPLES, average1);\n  printf(\"SD time (sd) for Serial %d x %d with %d samples = %f\\n\\n\", n, n, SAMPLES, sd1);\n  double sample1 = floor(pow(((100 * 1.96) * sd1) / (5 * average1), 2));\n  printf(\"Required sample size for Serial %d x %d is: %f\\n\\n\", n, n, sample1);\n  printf(\"Average time (mean) for Parallel %d x %d with %d samples = %f\\n\", n, n, SAMPLES, average2);\n  printf(\"SD time (sd) for Serial %d x %d with %d samples = %f\\n\\n\", n, n, SAMPLES, sd2);\n  double sample2 = floor(pow(((100 * 1.96) * sd2) / (5 * average2), 2));\n  printf(\"Required sample size for Parallel %d x %d is: %f\\n\\n\", n, n, sample2);\n  printf(\"------------------------------\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vini2/ParallelMatrixMultiplicationUsingOpenMP/old files/MatrixMultiplier/2"}
{"code": "for (int i = 0; i < (nNodesSize - 1); i++)\n{\n  COMM_WORLD.Send((void *) pNodesParam[i], 10, DOUBLE, i + 1, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucaszm7/Mandel2Us/Application/1"}
{"code": "for (i = 0; i < (nca / 2); i++)\n{\n  for (j = 0; j < (nca / 2); j++)\n  {\n    res[in3 + ((i * (nca / 2)) + j)] = ABC[in1 + ((i * (nca / 2)) + j)] + ABC[in2 + ((i * (nca / 2)) + j)];\n  }\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/4"}
{"code": "for (v = 0; v < nvtxs; v++)\n{\n  u = iperm[v];\n  for (j = xadj[u]; j < xadj[u + 1]; j++, jj++)\n  {\n    ngraph->adjncy[jj] = perm[adjncy[j]];\n    if (graph->iadjwgt)\n    {\n      ngraph->iadjwgt[jj] = graph->iadjwgt[j];\n    }\n\n    if (graph->fadjwgt)\n    {\n      ngraph->fadjwgt[jj] = graph->fadjwgt[j];\n    }\n\n  }\n\n  if (graph->ivwgts)\n  {\n    ngraph->ivwgts[v] = graph->ivwgts[u];\n  }\n\n  if (graph->fvwgts)\n  {\n    ngraph->fvwgts[v] = graph->fvwgts[u];\n  }\n\n  if (graph->ivsizes)\n  {\n    ngraph->ivsizes[v] = graph->ivsizes[u];\n  }\n\n  if (graph->fvsizes)\n  {\n    ngraph->fvsizes[v] = graph->fvsizes[u];\n  }\n\n  if (graph->vlabels)\n  {\n    ngraph->vlabels[v] = graph->vlabels[u];\n  }\n\n  ngraph->xadj[v + 1] = jj;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/5"}
{"code": "for (int i = 0; i < (bitString.size() / 2); i++)\n{\n  swap(bitString[i], bitString[(bitString.size() - i) - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/15"}
{"code": "for (int x = 1; x < (pcolumns - 1); x++)\n{\n  fX = yStart + ((x - 1) * deltaX);\n  updateVal = (((((u_old[((prows - 2) * pcolumns) + (x - 1)] + u_old[((prows - 2) * pcolumns) + (x + 1)]) * cx) + ((u_old[((prows - 3) * pcolumns) + x] + u_old[((prows - 1) * pcolumns) + x]) * cy)) + (u_old[((prows - 2) * pcolumns) + x] * cc)) - ((((fX * fX) - 1.0) * ((alpha * (1.0 - (fY * fY))) + 2.0)) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  u[((prows - 2) * pcolumns) + x] = u_old[((prows - 2) * pcolumns) + x] - (relax * updateVal);\n  loop_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:loop_error) private(fX, updateVal, x) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dora-jpg/parallel-jacobi-SOR/HybridMPI/openmpi/4"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    this->operator()(i, j) += rhs;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/9"}
{"code": "for (i = smaller + 1; i <= (my_max_i + 1); i++)\n{\n  dp[i][0] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  sp = 0;\n  sp = a[i] + b[i];\n  if (sp != 0)\n    total *= sp;\n\n}\n\n", "pragma": "#pragma omp for private(i,sp) reduction(*:total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/1"}
{"code": "for (unsigned p = 0; p < Size; p++)\n{\n  unsigned k = (data[p] >> ckmov) & KEYSMASK;\n  data2[p2[k]] = data[p];\n  p2[k]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/8"}
{"code": "for (i = 0; (i < 20) && (i < Team_num); ++i)\n{\n  if ((Team[i].team_flag == 1) && (Team[i].task.thread_id == team_thread_id))\n  {\n    parent_task = Team[i].etask[num];\n    task->parent = parent_task;\n    task->children = 0;\n    task.kind = 1;\n    if (parent_task->children)\n    {\n      task->next_child = parent_task->children;\n      task->prev_child = parent_task->children->prev_child;\n      task->next_child->prev_child = task;\n      task->prev_child->next_child = task;\n    }\n    else\n    {\n      task->next_child = task;\n      task->prev_child = task;\n    }\n\n    parent_task->children = task;\n    if (Team[i]->task_queue)\n    {\n      task->next_queue = team->task_queue;\n      task->prev_queue = team->task_queue->prev_queue;\n      task->next_queue->prev_queue = task;\n      task->prev_queue->next_queue = task;\n    }\n    else\n    {\n      task->next_queue = task;\n      task->prev_queue = task;\n      Team[i].task->queue = task;\n    }\n\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaodao90/wrapper/OpenMP/OMP_wrapper/6"}
{"code": "for (i = 0; i < n; i++)\n  if ((i + 1) != out[i])\n{\n  printf(\"test failed\\n\");\n  exit(0);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa09/silly/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    fscanf(f, \"%d\", &boudget[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/Settlers-economy-OpenMP-/main/2"}
{"code": "for (int i = 0; i < (g->n * g->n); i++)\n{\n  flowMatrix[i] = 0;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/3"}
{"code": "for (int i = 0; i < (procCoords.x_cells_num * procCoords.y_cells_num); i++)\n{\n  priv_norm = max(priv_norm, abs(f1[i] - f2[i]));\n}\n\n", "pragma": "        #pragma omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/1"}
{"code": "for (m = 0; m < nkernels; m++)\n{\n  for (w = 0; w < width; w++)\n  {\n    for (h = 0; h < height; h++)\n    {\n      double sum = 0.0;\n      for (c = 0; c < nchannels; c++)\n      {\n        for (x = 0; x < kernel_order; x++)\n        {\n          for (y = 0; y < kernel_order; y++)\n          {\n            sum += ((double) image[w + x][h + y][c]) * ((double) kernels[m][c][x][y]);\n          }\n\n        }\n\n        output[m][w][h] = (float) sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/4"}
{"code": "for (long i = 0; i < size; i++)\n{\n  RandVec[i] = RngArray[myRank].RandU01();\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  x[i / 2] = i;\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr81887/1"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      flux[i][0] = u[k][j][i][1];\n      u21 = u[k][j][i][1] * rho_i[k][j][i];\n      q = qs[k][j][i];\n      flux[i][1] = (u[k][j][i][1] * u21) + (C2 * (u[k][j][i][4] - q));\n      flux[i][2] = u[k][j][i][2] * u21;\n      flux[i][3] = u[k][j][i][3] * u21;\n      flux[i][4] = ((C1 * u[k][j][i][4]) - (C2 * q)) * u21;\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (tx2 * (flux[i + 1][m] - flux[i - 1][m]));\n      }\n\n    }\n\n    for (i = ist; i < nx; i++)\n    {\n      tmp = rho_i[k][j][i];\n      u21i = tmp * u[k][j][i][1];\n      u31i = tmp * u[k][j][i][2];\n      u41i = tmp * u[k][j][i][3];\n      u51i = tmp * u[k][j][i][4];\n      tmp = rho_i[k][j][i - 1];\n      u21im1 = tmp * u[k][j][i - 1][1];\n      u31im1 = tmp * u[k][j][i - 1][2];\n      u41im1 = tmp * u[k][j][i - 1][3];\n      u51im1 = tmp * u[k][j][i - 1][4];\n      flux[i][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][2] = tx3 * (u31i - u31im1);\n      flux[i][3] = tx3 * (u41i - u41im1);\n      flux[i][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      rsd[k][j][i][0] = rsd[k][j][i][0] + ((dx1 * tx1) * ((u[k][j][i - 1][0] - (2.0 * u[k][j][i][0])) + u[k][j][i + 1][0]));\n      rsd[k][j][i][1] = (rsd[k][j][i][1] + (((tx3 * C3) * C4) * (flux[i + 1][1] - flux[i][1]))) + ((dx2 * tx1) * ((u[k][j][i - 1][1] - (2.0 * u[k][j][i][1])) + u[k][j][i + 1][1]));\n      rsd[k][j][i][2] = (rsd[k][j][i][2] + (((tx3 * C3) * C4) * (flux[i + 1][2] - flux[i][2]))) + ((dx3 * tx1) * ((u[k][j][i - 1][2] - (2.0 * u[k][j][i][2])) + u[k][j][i + 1][2]));\n      rsd[k][j][i][3] = (rsd[k][j][i][3] + (((tx3 * C3) * C4) * (flux[i + 1][3] - flux[i][3]))) + ((dx4 * tx1) * ((u[k][j][i - 1][3] - (2.0 * u[k][j][i][3])) + u[k][j][i + 1][3]));\n      rsd[k][j][i][4] = (rsd[k][j][i][4] + (((tx3 * C3) * C4) * (flux[i + 1][4] - flux[i][4]))) + ((dx5 * tx1) * ((u[k][j][i - 1][4] - (2.0 * u[k][j][i][4])) + u[k][j][i + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][j][1][m] = rsd[k][j][1][m] - (dssp * ((((+5.0) * u[k][j][1][m]) - (4.0 * u[k][j][2][m])) + u[k][j][3][m]));\n      rsd[k][j][2][m] = rsd[k][j][2][m] - (dssp * (((((-4.0) * u[k][j][1][m]) + (6.0 * u[k][j][2][m])) - (4.0 * u[k][j][3][m])) + u[k][j][4][m]));\n    }\n\n    for (i = 3; i < (nx - 3); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (dssp * ((((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][j][nx - 3][m] = rsd[k][j][nx - 3][m] - (dssp * (((u[k][j][nx - 5][m] - (4.0 * u[k][j][nx - 4][m])) + (6.0 * u[k][j][nx - 3][m])) - (4.0 * u[k][j][nx - 2][m])));\n      rsd[k][j][nx - 2][m] = rsd[k][j][nx - 2][m] - (dssp * ((u[k][j][nx - 4][m] - (4.0 * u[k][j][nx - 3][m])) + (5.0 * u[k][j][nx - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/29"}
{"code": "for (i = 0; i < 256; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/31"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    scanf(\"%f\", &a[i][j]);\n    c[j][i] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/normalequation/1"}
{"code": "for (int x = 0; x < R; x++)\n{\n  for (int y = 0; y < C; y++)\n  {\n    if (oldWorld[x][y].type != ROCK)\n    {\n      oldWorld[x][y].type = newWorld[x][y].type;\n      oldWorld[x][y].currentGenFood = newWorld[x][y].currentGenFood;\n      oldWorld[x][y].currentGenProc = newWorld[x][y].currentGenProc;\n      newWorld[x][y].type = EMPTY;\n      newWorld[x][y].currentGenFood = 0;\n      newWorld[x][y].currentGenProc = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arcmarqs/EcosystemSim/src/util/0"}
{"code": "for (n = nelements; n > 1; n--)\n{\n  int sum;\n  int is = 1;\n  int js = 0;\n  result[nelements - n].distance = find_closest_pair(n, distmatrix, &is, &js);\n  result[nelements - n].left = clusterid[is];\n  result[nelements - n].right = clusterid[js];\n  sum = number[is] + number[js];\n  for (j = 0; j < js; j++)\n  {\n    distmatrix[js][j] = (distmatrix[is][j] * number[is]) + (distmatrix[js][j] * number[js]);\n    distmatrix[js][j] /= sum;\n  }\n\n  for (j = js + 1; j < is; j++)\n  {\n    distmatrix[j][js] = (distmatrix[is][j] * number[is]) + (distmatrix[j][js] * number[js]);\n    distmatrix[j][js] /= sum;\n  }\n\n  for (j = is + 1; j < n; j++)\n  {\n    distmatrix[j][js] = (distmatrix[j][is] * number[is]) + (distmatrix[j][js] * number[js]);\n    distmatrix[j][js] /= sum;\n  }\n\n  for (j = 0; j < is; j++)\n    distmatrix[is][j] = distmatrix[n - 1][j];\n\n  for (j = is + 1; j < (n - 1); j++)\n    distmatrix[j][is] = distmatrix[n - 1][j];\n\n  number[js] = sum;\n  number[is] = number[n - 1];\n  clusterid[js] = (n - nelements) - 1;\n  clusterid[is] = clusterid[n - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/88"}
{"code": "for (int k = 0; k < (width * height); k++)\n{\n  int index = centroidIndex[k];\n  imageOut[k * 4] = centroids[index * 3];\n  imageOut[(k * 4) + 1] = centroids[(index * 3) + 1];\n  imageOut[(k * 4) + 2] = centroids[(index * 3) + 2];\n  imageOut[(k * 4) + 3] = 255;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/in-droid/image-compression-k-means/src/k-means-omp/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      for (i = 1; i < (grid_points[0] - 1); i++)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/70"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    masC[i][j] = masA[i][j] + masB[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/7"}
{"code": "for (unsigned int i = 0; i < _interGroups.size(); ++i)\n{\n  if (_interGroups[i].first.BitIsOn(a->GetIdx()) && _interGroups[i].second.BitIsOn(b->GetIdx()))\n    validEle = true;\n\n  if (_interGroups[i].first.BitIsOn(b->GetIdx()) && _interGroups[i].second.BitIsOn(a->GetIdx()))\n    validEle = true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/16"}
{"code": "for (int i = 0; i < toWhichRow; i++)\n{\n  for (int j = 0; j < toWhichColumn; j++)\n  {\n    printf(\"[%d , %d ] = %d  \", i, j, tab[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jacob273/JG.TechLearning.OpenMP/lab1/multiplication/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  cast_vec->vec_[i] = this->mat_.val[DENSE_IND(idx, i, this->nrow_, this->ncol_)];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/13"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/132"}
{"code": "for (sh = 0; sh < sheight; ++sh)\n{\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    for (h = 0; h < 32; h++)\n    {\n      for (w = 0; w < 32; ++w)\n      {\n        for (c = 0; c < 3; ++c)\n        {\n          tile_buf[c][h][w] = img[(((((sh * 32) + h) * width) + ((sw * 32) + w)) * 3) + c];\n        }\n\n      }\n\n    }\n\n    memcpy((void *) (thread_buf + (sw * 3072)), tile_buf, 3072);\n  }\n\n  printf(\"================= sh : %d, copy complete ================\\n\", sh);\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    int min_diff = 2147483647;\n    int min_i = -1;\n    for (i = 0; i < 60000; ++i)\n    {\n      int diff = 0;\n      for (c = 0; c < 3; ++c)\n      {\n        for (h = 0; h < 32; ++h)\n        {\n          for (w = 0; w < 32; ++w)\n          {\n            int pixel_diff = ((int) thread_buf[(((((sw * 3) + c) * 32) + h) * 32) + w]) - ((int) dataset[(((((i * 3) + c) * 32) + h) * 32) + w]);\n            diff += pixel_diff * pixel_diff;\n          }\n\n        }\n\n      }\n\n      if (min_diff > diff)\n      {\n        min_diff = diff;\n        min_i = i;\n      }\n\n    }\n\n    idx[(sh * swidth) + sw] = min_i;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/A/photomosaic/2"}
{"code": "for (i = 1; i < block_x; i++)\n{\n  u[0][i] = u[0][0] + (i * block_y);\n  u[1][i] = u[1][0] + (i * block_y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/11"}
{"code": "for (i = 1; i < (size - 1); i++)\n{\n  for (j = 1; j < (size - 1); j++)\n  {\n    output[(i * size) + j] = ((a * (((input[(((i - 1) * size) + j) - 1] + input[(((i - 1) * size) + j) + 1]) + input[(((i + 1) * size) + j) + 1]) + input[(((i + 1) * size) + j) - 1])) + (b * (((input[((i - 1) * size) + j] + input[((i + 1) * size) + j]) + input[((i * size) + j) + 1]) + input[((i * size) + j) - 1]))) + (c * input[(i * size) + j]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/texasfight/OpenMP_HW1/parallel_script/1"}
{"code": "for (int i = 0; i < sample_size; i++)\n{\n  const int num_threads = thread_nums[i];\n  omp_set_num_threads(num_threads);\n  printf(\"Running simulation with %d threads\\n\", num_threads);\n  double time_to_complete = simulate_hte(steps);\n  write_performance_data(num_threads, steps, time_to_complete);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eddireeder/heat-transfer-simulation/hte/4"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int y = (i * size) + t;\n  pivots_sent[i - 1] = pivots_recvd[y];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zilmarij/Hybrid_MPI-OpenMP_based_Sorting/sort/6"}
{"code": "for (i = nstart; i < nend; i++)\n{\n  for (j = nstart; j < nend; j++)\n  {\n    printf(\"%6.4lf \", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/13"}
{"code": "for (int ax = 0; ax < 3; ax++)\n{\n  if (cpuInv[ax].size() != gpuInv[ax].size())\n  {\n    axErr[ax] = 1;\n    continue;\n  }\n\n  if (memcmp(&cpuInv[ax][0], &gpuInv[ax][0], cpuInv[ax].size() * (sizeof(Vector2i))) != 0)\n    axErr[ax] = 2;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/OpenCLCollider/4"}
{"code": "for (int i = 0; i < previousNum; i++)\n{\n  if ((tgt_min <= pixelList[i][9].toDouble()) && (pixelList[i][9].toDouble() <= tgt_max))\n  {\n    if ((bolo_min <= pixelList[i][4].toDouble()) && (pixelList[i][4].toDouble() <= bolo_max))\n    {\n      if ((pkg_min <= pixelList[i][5].toDouble()) && (pixelList[i][5].toDouble() <= pkg_max))\n      {\n        if ((case_min <= pixelList[i][6].toDouble()) && (pixelList[i][6].toDouble() <= case_max))\n        {\n          if ((sh_min <= pixelList[i][7].toDouble()) && (pixelList[i][7].toDouble() <= sh_max))\n          {\n            if ((lens_min <= pixelList[i][8].toDouble()) && (pixelList[i][8].toDouble() <= lens_max))\n            {\n              tmp.clear();\n              for (int j = 0; j < 25; j++)\n              {\n                tmp.append(pixelList[i][j]);\n              }\n\n              replot.append(tmp);\n              count++;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/48"}
{"code": "for (j = 0; j < m; j++)\n  b[i][j] = 0.5;\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB031-truedepfirstdimension-orig-yes/1"}
{"code": "for (i = 0; i < stages; i++)\n{\n  for (j = 0; j < stages_array[i]; j++)\n  {\n    for (k = 0; k < 3; k++)\n    {\n      for (l = 0; l < 4; l++)\n      {\n        if (fgets(mystring, 12, fp) != NULL)\n          rectangles_array[r_index] = atoi(mystring);\n        else\n          break;\n\n        r_index++;\n      }\n\n      if (fgets(mystring, 12, fp) != NULL)\n      {\n        weights_array[w_index] = atoi(mystring);\n      }\n      else\n        break;\n\n      w_index++;\n    }\n\n    if (fgets(mystring, 12, fp) != NULL)\n      tree_thresh_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha1_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha2_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    tree_index++;\n    if (j == (stages_array[i] - 1))\n    {\n      if (fgets(mystring, 12, fp) != NULL)\n        stages_thresh_array[i] = atoi(mystring);\n      else\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rajanjitenpatel/Face_detection/Parallel_code/haar/6"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  int threadn = omp_get_thread_num();\n  int tot_threads = omp_get_num_threads();\n  int interval = 50000 / tot_threads;\n  int start = threadn * interval;\n  int end = start + interval;\n  printf(\"reduce section thread %d, start %d\\n\", threadn, start);\n  if (end > final_table->tablesize)\n  {\n    end = final_table->tablesize;\n  }\n\n  int i;\n  for (i = start; i < end; i++)\n  {\n    reduce(hash_tables, final_table, 8, i);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(final_table, hash_tables) num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/map-reduce-word-count-openmp-mpi/parallel_read_map/2"}
{"code": "for (i = 0; i < nStudents; i++)\n{\n  sorted[grades[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/statisticspar/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  result[i] = (alpha * x[i]) + y[i];\n}\n\n", "pragma": "#pragma omp parallel for default(none) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/4"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = rand() % max_range;\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/7"}
{"code": "for (int I = 0; I < m; I += BLOCK_SIZE)\n{\n  for (int J = 0; J < p; J += BLOCK_SIZE)\n  {\n    int i_max = min(m, I + BLOCK_SIZE);\n    int j_max = min(p, J + BLOCK_SIZE);\n    for (int i = I; i < i_max; i++)\n    {\n      for (int j = J; j < j_max; j++)\n      {\n        C[(i * p) + j] = 0.0;\n      }\n\n    }\n\n    for (int K = 0; K < n; K += BLOCK_SIZE)\n    {\n      int k_max = min(n, K + BLOCK_SIZE);\n      for (int i = I; i < i_max; i++)\n      {\n        for (int j = J; j < j_max; j++)\n        {\n          for (int k = K; k < k_max; k++)\n          {\n            C[(i * p) + j] += A[(i * n) + k] * B[(k * p) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for collapse(2) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/1"}
{"code": "for (i = 0; i < NV; i++)\n{\n  mind[i] = ohd[0][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/1"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  qa = mod09GAa(l[rowcol]);\n  qa1 = mod09GAc(l3[rowcol], 3);\n  if ((qa == 0) || (qa1 == 0))\n    lOut[rowcol] = l3[rowcol];\n  else\n    lOut[rowcol] = -28768;\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol, qa, qa1) shared (N, l, l3, lOut)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_MOD09GA/mod09ga/0"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.p; j++)\n  {\n    sum = 0;\n    for (k = 0; k < dataSet.m; k++)\n    {\n      sum += dataSet.A[(i * dataSet.m) + k] * dataSet.B[(k * dataSet.p) + j];\n    }\n\n    dataSet.C[(i * dataSet.p) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 40)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fatemehNe/openmp-lab/matrix multiplication/matmulA/0"}
{"code": "for (c1 = 0; c1 <= 127; c1++)\n{\n  for (c2 = 0; c2 <= 127; c2++)\n  {\n    for (c5 = 0; c5 <= 127; c5++)\n    {\n      E[c1][c2] += A[c1][c5] * B[c5][c2];\n    }\n\n    for (c5 = 0; c5 <= 127; c5++)\n    {\n      G[c1][c5] += E[c1][c2] * F[c2][c5];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c5 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/103"}
{"code": "for (i = 0; i < p; i++)\n{\n  displs[i] = offset;\n  scounts[i] = (i == 0) ? ((avg + extra) * col) : (avg * col);\n  if (i == 0)\n    offset += (avg + extra) * col;\n  else\n    offset += avg * col;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/exam_final/final/2"}
{"code": "for (i = 0; i < dom->nx; i++)\n  for (j = 0; j < dom->ny[i]; j++)\n  for (q = 0; q < dom->nq; q++)\n  sum += dom->prim[i][(dom->nq * j) + q];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geoffryan/ompTest/funcs/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (a[i] > pivot)\n  {\n    len_r++;\n  }\n\n  if (a[i] < pivot)\n  {\n    len_l++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/med/2"}
{"code": "for (int i = 0; i < ciclos_red; ++i)\n  vect[i] = _mm256_loadu_ps((const float *) (&wt[i * 8]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/5"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/19"}
{"code": "for (int i = 0; i < ((sizeof(counts)) / (sizeof(*counts))); i++)\n{\n  Log(\"==============================================================================\");\n  double time1 = LaunchCriticalSectionComparison(counts[i], true);\n  double time2 = LaunchCriticalSectionComparison(counts[i], false);\n  Log(\"Array length: \" + to_string(counts[i]));\n  Log(\"omp off / omp on : \" + to_string(time2 / time1));\n  Log(\"==============================================================================\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/Source/2"}
{"code": "for (i = 0; i < 8; i++)\n  b[i] = a;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/004_single_construct/0"}
{"code": "for (i = 1; i < (n + 1); i++)\n{\n  for (j = 1; j < (n + 1); j++)\n  {\n    for (k = 1; k < (n + 1); k++)\n    {\n      a1[(((i * sz) * sz) + (j * sz)) + k] = (((((((((((((((((((((((((a0[(((i * sz) * sz) + ((j - 1) * sz)) + k] + a0[(((i * sz) * sz) + ((j + 1) * sz)) + k]) + a0[((((i - 1) * sz) * sz) + (j * sz)) + k]) + a0[((((i + 1) * sz) * sz) + (j * sz)) + k]) + a0[((((i - 1) * sz) * sz) + ((j - 1) * sz)) + k]) + a0[((((i - 1) * sz) * sz) + ((j + 1) * sz)) + k]) + a0[((((i + 1) * sz) * sz) + ((j - 1) * sz)) + k]) + a0[((((i + 1) * sz) * sz) + ((j + 1) * sz)) + k]) + a0[(((i * sz) * sz) + ((j - 1) * sz)) + (k - 1)]) + a0[(((i * sz) * sz) + ((j + 1) * sz)) + (k - 1)]) + a0[((((i - 1) * sz) * sz) + (j * sz)) + (k - 1)]) + a0[((((i + 1) * sz) * sz) + (j * sz)) + (k - 1)]) + a0[((((i - 1) * sz) * sz) + ((j - 1) * sz)) + (k - 1)]) + a0[((((i - 1) * sz) * sz) + ((j + 1) * sz)) + (k - 1)]) + a0[((((i + 1) * sz) * sz) + ((j - 1) * sz)) + (k - 1)]) + a0[((((i + 1) * sz) * sz) + ((j + 1) * sz)) + (k - 1)]) + a0[(((i * sz) * sz) + ((j - 1) * sz)) + (k + 1)]) + a0[(((i * sz) * sz) + ((j + 1) * sz)) + (k + 1)]) + a0[((((i - 1) * sz) * sz) + (j * sz)) + (k + 1)]) + a0[((((i + 1) * sz) * sz) + (j * sz)) + (k + 1)]) + a0[((((i - 1) * sz) * sz) + ((j - 1) * sz)) + (k + 1)]) + a0[((((i - 1) * sz) * sz) + ((j + 1) * sz)) + (k + 1)]) + a0[((((i + 1) * sz) * sz) + ((j - 1) * sz)) + (k + 1)]) + a0[((((i + 1) * sz) * sz) + ((j + 1) * sz)) + (k + 1)]) + a0[(((i * sz) * sz) + (j * sz)) + (k - 1)]) + a0[(((i * sz) * sz) + (j * sz)) + (k + 1)]) * fac;\n    }\n\n  }\n\n}\n\n", "pragma": "\t #pragma omp parallel for  private(i,j,k) schedule(dynamic) shared(a1) num_threads(th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/herculeshcs/SYCL-OpenCL-OpenMP-Benchmark/27stencil/stencil27-mod/1"}
{"code": "for (int i = 0; i < (rows / 4); i++)\n{\n  for (int j = 0; j < (cols / 4); j++)\n  {\n    map[i][j] += feat36[i][j] + feat37[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) num_threads(THREAD_COUNT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/SaliencyMap/SaliencyMap/2"}
{"code": "for (int i = 0; i < POP_SIZE; i++)\n{\n  if (MUTATION_TYPE == 0)\n    mutate(p.pop[i]);\n  else\n    mutateW(p.pop[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/10"}
{"code": "for (k = 1; k < M; k++)\n{\n  symmat[(k * (M + 1)) + k] = 1.0;\n  for (j = k + 1; j < (M + 1); j++)\n  {\n    symmat[(k * (M + 1)) + j] = 0.0;\n    for (i = 1; i < (N + 1); i++)\n    {\n      symmat[(k * (M + 1)) + j] += data[(i * (M + 1)) + k] * data[(i * (M + 1)) + j];\n    }\n\n    symmat[(j * (M + 1)) + k] = symmat[(k * (M + 1)) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/1"}
{"code": "for (int data_size_MB = 128; data_size_MB < 4096; data_size_MB += 1024)\n{\n  int data_size = ((data_size_MB / (sizeof(int))) * 1024) * 1024;\n  test_scatter_intrinsic(data_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/10"}
{"code": "for (int p = 0; p < N_; p++)\n{\n  if (!particles_[p].getStopPart())\n  {\n    particles_[p].moveParticle(t);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/crawfordhmc/openmp-particle-simulator/engineP/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  x.x += a[i];\n}\n\n", "pragma": "omp parallel for reduction(+:x)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_new_udr_07/0"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  (((cout << i) << \" = \") << pr[i]) << endl;\n  sum += pr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/pagerank/src/omp_pagerank_v1/7"}
{"code": "for (int m = 0; m < dimension; ++m)\n{\n  for (int i = 0; i < dimension; i++)\n  {\n    for (int j = 0; j < dimension; j++)\n    {\n      for (int k = 0; k < dimension; k++)\n      {\n        C[m][i][j] += A[l][m][k] * B[k][i][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(n_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MohamadCM/Parallel-Programming-Practice/OpenMP_3-Tensor multiplication/0"}
{"code": "for (unsigned c2 = 0; c2 < Size; c2++)\n  res[c2] = data[Index[c2]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/14"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  TYPE tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_coal/1"}
{"code": "for (int i = 0; i < SCC[sc].size(); i++)\n{\n  prev[SCC[sc][i]] = d / N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/7"}
{"code": "for (int i = 0; i < (N / 2); i++)\n{\n  f[i] = evenVec[i] + (W[i] * oddVec[i]);\n  f[i + (N / 2)] = evenVec[i] - (W[i] * oddVec[i]);\n}\n\n", "pragma": "    #pragma omp parallel for shared(W)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guiiteixeira/RFFT-Recursive-Fast-Fourier-Transform/parallel_recursive_fft/2"}
{"code": "for (int ib = 0; ib < numBucketsXYZ; ib++)\n{\n  if (bucketPeriodicBC[ib] == (-1))\n  {\n    firstParticleInBucket[ib] = firstParticleInBucket[(ib + numBucketsX) - 2];\n    lastParticleInBucket[ib] = lastParticleInBucket[(ib + numBucketsX) - 2];\n  }\n\n  if (bucketPeriodicBC[ib] == 1)\n  {\n    firstParticleInBucket[ib] = firstParticleInBucket[(ib - numBucketsX) + 2];\n    lastParticleInBucket[ib] = lastParticleInBucket[(ib - numBucketsX) + 2];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/16"}
{"code": "for (int i = 0; i < (N - 1); i++)\n{\n  (file << x[i]) << \",\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victor13165/projet-1-SNHP/CPP/projet1/0"}
{"code": "for (i = 0; i < l; i++)\n{\n  int im = i * m;\n  for (j = 0; j < n; j++)\n  {\n    int jm = j * m;\n    double sum = 0.0;\n    for (k = 0; k < m; k++)\n    {\n      sum += at[k + im] * b[k + jm];\n    }\n\n    c[i + (j * l)] = sum;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/20"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpqqh1jn2d.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpqqh1jn2d.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/36"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  sum[m] = 0.0;\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/61"}
{"code": "for (i = 0; i < 16384; i++)\n{\n  if (percentDiff(s[i], s_outputFromOmp[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/BICG/bicg/5"}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#1#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    c[i][j] = a[i][j] * b[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB098-simd2-orig-no/2"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  if (dead[i] == 1)\n    continue;\n\n  pr[i] = d / (N * 1.0);\n  for (int v = 0; v < rev[i].size(); v++)\n  {\n    int ver = rev[i][v];\n    pr[i] += ((prev[ver] * 1.0) / (outdeg[ver] * 1.0)) * (1.0 - d);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/12"}
{"code": "for (int j = 0; j < numHidden2Nodes; ++j)\n{\n  double err = 0.0;\n  for (int k = 0; k < numOutputs; ++k)\n  {\n    err -= out_err[k] * output_weights[k][j];\n  }\n\n  h2_err[j] = err * act_d(layer2[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/9"}
{"code": "for (i = 0; i < tam; i++)\n{\n  num[i] = (int *) malloc((sizeof(int)) * tam);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adrikei/FinalParalela/src/openmp/1"}
{"code": "for (j = 1; j < (ny - 1); j++)\n  for (i = 1; i < (nx - 1); i++)\n{\n  if ((nms[c] >= tmax) && (out[c] == 0))\n  {\n    out[c] = 255;\n    int nedges = 1;\n    edges[0] = c;\n    do\n    {\n      nedges--;\n      const int t = edges[nedges];\n      int nbs[8];\n      nbs[0] = t - nx;\n      nbs[1] = t + nx;\n      nbs[2] = t + 1;\n      nbs[3] = t - 1;\n      nbs[4] = nbs[0] + 1;\n      nbs[5] = nbs[0] - 1;\n      nbs[6] = nbs[1] + 1;\n      nbs[7] = nbs[1] - 1;\n      for (int k = 0; k < 8; k++)\n        if ((nms[nbs[k]] >= tmin) && (out[nbs[k]] == 0))\n      {\n        out[nbs[k]] = 255;\n        edges[nedges] = nbs[k];\n        nedges++;\n      }\n\n\n    }\n    while (nedges > 0);\n  }\n\n  c++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/12"}
{"code": "for (k = 0; k < ny; k++)\n{\n  for (j = 0; j < nx; j++)\n  {\n    for (i = 0; i < ndim; i++)\n    {\n      amu[i + (ndim * (j + (nxe * k)))] += amu[(i + (ndim * (j + (nxe * k)))) + (nnxye * nz)];\n      amu[(i + (ndim * (j + (nxe * k)))) + (nnxye * nz)] = 0.0;\n    }\n\n  }\n\n  for (i = 0; i < ndim; i++)\n  {\n    amu[i + ((ndim * nxe) * k)] += amu[(i + (ndim * (nx + (nxe * k)))) + (nnxye * nz)];\n    amu[(i + (ndim * (nx + (nxe * k)))) + (nnxye * nz)] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/1"}
{"code": "for (int i = 0; i < (mNumHiddenLayers + 1); i++)\n{\n  updateNeuronLayer(*mNeuronLayers[i], inputs);\n  inputs = mNeuronLayers[i]->mOutActivations;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KawhiX/BP-Network-ParallelComputing/OMP/src/NetWork/2"}
{"code": "for (idx_t j = jbegin; j < jend; ++j)\n{\n  idx_t idx = tt->ind[m][j];\n  ++histogram[idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/12"}
{"code": "for (i = 0; i < (1 << 11); i++)\n  key_buff1[i] += prv_buff1[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/10"}
{"code": "for (int j = 0; j < num_devices; j++)\n{\n  if (j != (num_devices - 1))\n  {\n    bufA[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * NNZ_PER_DEVICE) * order, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufA[j], CL_FALSE, 0, ((sizeof(int)) * NNZ_PER_DEVICE) * order, X.index + ((j * NNZ_PER_DEVICE) * order), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufB[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * NNZ_PER_DEVICE, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufB[j], CL_FALSE, 0, (sizeof(float)) * NNZ_PER_DEVICE, X.value + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufF[j] = clCreateBuffer(context, CL_MEM_WRITE_ONLY, ((sizeof(float)) * rrank) * NNZ_PER_DEVICE, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufF[j], CL_FALSE, 0, ((sizeof(float)) * NNZ_PER_DEVICE) * rrank, Delta + ((j * NNZ_PER_DEVICE) * rrank), 0, NULL, NULL);\n  }\n  else\n  {\n    bufA[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * last) * order, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufA[j], CL_FALSE, 0, ((sizeof(int)) * last) * order, X.index + ((j * NNZ_PER_DEVICE) * order), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufB[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * last, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufB[j], CL_FALSE, 0, (sizeof(float)) * last, X.value + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n    bufF[j] = clCreateBuffer(context, CL_MEM_WRITE_ONLY, ((sizeof(float)) * rrank) * last, NULL, &err);\n    CHECK_ERROR(err);\n    err = clEnqueueWriteBuffer(queues[j], bufF[j], CL_FALSE, 0, ((sizeof(float)) * last) * rrank, Delta + ((j * NNZ_PER_DEVICE) * rrank), 0, NULL, NULL);\n  }\n\n  bufC[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, ((sizeof(int)) * Core_N) * order, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufC[j], CL_FALSE, 0, ((sizeof(int)) * Core_N) * order, CoreT.index, 0, NULL, NULL);\n  CHECK_ERROR(err);\n  bufD[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (sizeof(float)) * Core_N, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufD[j], CL_FALSE, 0, (sizeof(float)) * Core_N, CoreT.value, 0, NULL, NULL);\n  CHECK_ERROR(err);\n  bufE[j] = clCreateBuffer(context, CL_MEM_READ_ONLY, (((sizeof(float)) * order) * max_dim) * rrank, NULL, &err);\n  CHECK_ERROR(err);\n  err = clEnqueueWriteBuffer(queues[j], bufE[j], CL_FALSE, 0, (((sizeof(float)) * order) * max_dim) * rrank, X.FactorM, 0, NULL, NULL);\n  CHECK_ERROR(err);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/12"}
{"code": "for (int i = 0; i < N; i++)\n  if (isValid(r, i, positions))\n{\n  positions[r] = i;\n  ans += dfsQueen(r + 1, N, positions);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/NQueen/main/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  func_param = a + ((i + 0.5) * temp);\n  sum += f2(func_param, intensity) * temp;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic,granularity) reduction(+:sum)     ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akarsh3007/Parallel-Computing/Assignment-4/openmp/numint/1"}
{"code": "for (int j = 0; j < n; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    float dx = points[i].x - points[j].x;\n    float dy = points[i].y - points[j].y;\n    float dz = points[i].z - points[j].z;\n    float sqr_dist = ((dx * dx) + (dy * dy)) + (dz * dz);\n    (*sqr_distances)[(j * n) + i] = sqr_dist <= sqr_radius;\n  }\n\n  (*sqr_distances)[(j * n) + j] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(points, sqr_distances, n, sqr_radius) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload/euclidean_cluster/kernel/0"}
{"code": "for (int i = 0; i < count; i++)\n{\n  BorList *ptr = borFind(localTuples[i].borough, localBorList);\n  if (strcmp(localTuples[i].borough, \"_UNDEF_\") != 0)\n  {\n    if (ptr == 0)\n    {\n      if (localBorList->borName == 0)\n      {\n        localBorList->borName = strdup(localTuples[i].borough);\n        localBorList->dates = malloc(sizeof(DateList));\n        localBorList->dates->day = localTuples[i].day;\n        localBorList->dates->month = localTuples[i].month;\n        localBorList->dates->year = localTuples[i].year;\n        localBorList->dates->lethCount = killed(localTuples[i], 0);\n        localBorList->dates->next = 0;\n        boroughNum++;\n      }\n      else\n      {\n        BorList *newEl = malloc(sizeof(BorList));\n        newEl->borName = strdup(localTuples[i].borough);\n        newEl->dates = malloc(sizeof(DateList));\n        newEl->dates->day = localTuples[i].day;\n        newEl->dates->month = localTuples[i].month;\n        newEl->dates->year = localTuples[i].year;\n        newEl->dates->lethCount = killed(localTuples[i], 0);\n        newEl->dates->next = 0;\n        newEl->next = localBorList;\n        localBorList = newEl;\n        boroughNum++;\n      }\n\n    }\n    else\n    {\n      DateList *newEl = malloc(sizeof(DateList));\n      newEl->day = localTuples[i].day;\n      newEl->month = localTuples[i].month;\n      newEl->year = localTuples[i].year;\n      newEl->lethCount = killed(localTuples[i], 0);\n      newEl->next = ptr->dates;\n      ptr->dates = newEl;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/14"}
{"code": "for (x = 0; x < diameter; x++)\n{\n  for (y = 0; y < diameter; y++)\n  {\n    if (se[(x * diameter) + y])\n    {\n      neighbors[neighY * 2] = (int) (y - center);\n      neighbors[(neighY * 2) + 1] = (int) (x - center);\n      neighY++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/15"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a[%d]/ \", 0, i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/private-clause/1"}
{"code": "for (int row = start_z + boundary_length; row < (end_z - boundary_length); row++)\n{\n  for (int column = start_x + boundary_length; column < (end_x - boundary_length); column++)\n  {\n    deviceMinValue[0] = min(deviceMinValue[0], property_array[(row * nx) + column]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/MinExtension/0"}
{"code": "for (j = 1; j <= ny2; j++)\n{\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k + 1][j][i][m])) + u[k + 2][j][i][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/5"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  after_cluster[i] = pointsCluster(points[i], mean, K);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Projects/PC-Project/parallel code/kmean_omp/0"}
{"code": "for (int i = 0; i < sequencia_dna.length(); i++)\n{\n  sequencia_rna[i] = complemento[sequencia_dna[i]];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/6"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        u[m][i][j][k] = u[m][i][j][k] + rhs[m][i][j][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/0"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/3"}
{"code": "for (long int i = 0; i < interval; i++)\n{\n  double r_x = ((double) (rand_r(&see) % (interval + 1))) / interval;\n  double r_y = ((double) (rand_r(&see) % (interval + 1))) / interval;\n  double tot = (r_x * r_x) + (r_y * r_y);\n  if (tot <= 1.0)\n    c_point++;\n\n  s_point++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ath-90/hpc-openmp-assignment/monte_carlo/0"}
{"code": "for (j = 0; j < nxh; j++)\n{\n  at1 = cimagf(ffc[j]);\n  fxyz[4 * j] += exyz[4 * j] * at1;\n  fxyz[1 + (4 * j)] += exyz[1 + (4 * j)] * at1;\n  fxyz[2 + (4 * j)] += exyz[2 + (4 * j)] * at1;\n  fxyz[4 * (j + k1)] += exyz[4 * (j + k1)] * at1;\n  fxyz[1 + (4 * (j + k1))] += exyz[1 + (4 * (j + k1))] * at1;\n  fxyz[2 + (4 * (j + k1))] += exyz[2 + (4 * (j + k1))] * at1;\n  fxyz[4 * (j + l1)] += exyz[4 * (j + l1)] * at1;\n  fxyz[1 + (4 * (j + l1))] += exyz[1 + (4 * (j + l1))] * at1;\n  fxyz[2 + (4 * (j + l1))] += exyz[2 + (4 * (j + l1))] * at1;\n  fxyz[4 * ((j + k1) + l1)] += exyz[4 * ((j + k1) + l1)] * at1;\n  fxyz[1 + (4 * ((j + k1) + l1))] += exyz[1 + (4 * ((j + k1) + l1))] * at1;\n  fxyz[2 + (4 * ((j + k1) + l1))] += exyz[2 + (4 * ((j + k1) + l1))] * at1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/58"}
{"code": "for (int i = 0; i < numrefs; ++i)\n{\n  minhashes_frequency_filter(ref_hashes[i], ref_hash_lens[i], sketch_size, ref_minhashes[i], ref_min_lens[i], ref_hash_counter, 0, max_samples);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/7"}
{"code": "for (i = 0; i < part_no; i++)\n{\n  x += (par[i].pos.x * par[i].m) / totalM;\n  y += (par[i].pos.y * par[i].m) / totalM;\n}\n\n", "pragma": "omp for private (i, x_aux, y_aux) reduction (+:x,y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/grid/0"}
{"code": "for (int k = 0; k < num; ++k)\n{\n  y[k] = (a * x[k]) + y[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vksmgr/OpenMp/src/openmp/run/2"}
{"code": "for (j = 0; j < procCoords.y_cells_num; j++)\n{\n  send_message_lr[j] = f[((j + 1) * procCoords.x_cells_num) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/3"}
{"code": "for (int i = 0; i < nDimensions; i++)\n{\n  sum += (10 + pow(x[i], 2)) - (10 * cos((2 * 3.14159265358979323846) * x[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/mpiomp/9"}
{"code": "for (unsigned p = 0; p < Count; p++)\n  acesum = acesum + PartAcec[p];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsGaugeItem/6"}
{"code": "for (k = 1; k <= (nz - 1); k += 1)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21k = tmp * rsd[i][j][k][1];\n  u31k = tmp * rsd[i][j][k][2];\n  u41k = tmp * rsd[i][j][k][3];\n  u51k = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i][j][k - 1][0];\n  u21km1 = tmp * rsd[i][j][k - 1][1];\n  u31km1 = tmp * rsd[i][j][k - 1][2];\n  u41km1 = tmp * rsd[i][j][k - 1][3];\n  u51km1 = tmp * rsd[i][j][k - 1][4];\n  flux[i][j][k][1] = tz3 * (u21k - u21km1);\n  flux[i][j][k][2] = tz3 * (u31k - u31km1);\n  flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((1.40e+00 * 1.40e+00) * tz3) * (u51k - u51km1));\n}\n\n", "pragma": "omp parallel for private (u31k,u41k,u51k,u21km1,u31km1,u41km1,u51km1,tmp,u21k,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/48"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/3vilware/OpenMP-/reduction/0"}
{"code": "for (int i = 0; i < NNodes; i++)\n{\n  iterator it = it_begin + i;\n  const double external_radius = sqrt((it->X() * it->X()) + (it->Y() * it->Y()));\n  const double cos_theta = it->X() / external_radius;\n  const double sin_theta = it->Y() / external_radius;\n  it->GetValue(TARGET_STRESS_X) = current_target_stress * cos_theta;\n  it->GetValue(TARGET_STRESS_Y) = current_target_stress * sin_theta;\n  it->GetValue(REACTION_STRESS_X) = mReactionStress[map_index] * cos_theta;\n  it->GetValue(REACTION_STRESS_Y) = mReactionStress[map_index] * sin_theta;\n  it->GetValue(LOADING_VELOCITY_X) = mVelocity[map_index] * cos_theta;\n  it->GetValue(LOADING_VELOCITY_Y) = mVelocity[map_index] * sin_theta;\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DemStructuresCouplingApplication/custom_utilities/multiaxial_control_module_fem_dem_generalized_2d_utilities/3"}
{"code": "for (idx = 0; idx < N; ++idx)\n{\n  dijkstra(graph, idx);\n}\n\n", "pragma": "omp parallel for num_threads (thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EdwardAJ/OpenMP-Parallel-Computing/src/openmp/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  a[i] = rand() % 20;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/ParityTransformSort/0"}
{"code": "for (i = 0; i < size_r; i++)\n{\n  pos = floor((((float) r[i]) / size_r) * nBuckets_r);\n  if (pos < 0)\n    pos = 0;\n\n  if (pos >= nBuckets_r)\n    pos = nBuckets_r - 1;\n\n  bucketsVector[pos].value[bucketsVector[pos].total] = r[i];\n  bucketsVector[pos].total++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PietroPan/Parallel-BucketSort/bucket_sort/2"}
{"code": "for (j = 1; j < (sizeA + 1); j++)\n{\n  if (seqA[j - 1] == seqB[i - 1])\n  {\n    scoreMatrix[i][j] = scoreMatrix[i - 1][j - 1] + 1;\n  }\n  else\n    if (pMatrix[c_i][j] == 0)\n  {\n    scoreMatrix[i][j] = max(scoreMatrix[i - 1][j], 0);\n  }\n  else\n  {\n    scoreMatrix[i][j] = max(scoreMatrix[i - 1][j], scoreMatrix[i - 1][pMatrix[c_i][j] - 1] + 1);\n  }\n\n\n}\n\n", "pragma": "omp parallel for num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giov8/lcs-openmp/openmp/lcs/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  result += arr[i];\n}\n\n", "pragma": "  #pragma omp for reduction(+ :result) schedule(runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkalyanpurr/openMP/reduce_v1/reduce/0"}
{"code": "for (int i = 0; i < L1; i++)\n{\n  for (int j = 0; j < X; j++)\n  {\n    M1[i][j] = 100000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ayoubmundia/ProduitMatricielle/thread/0"}
{"code": "for (int x = 0; x < rows; x++)\n{\n  for (int y = 0; y < columns; y++)\n  {\n    dest_matrix[x][y] = origin_matrix[x][y];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) shared(origin_matrix,dest_matrix)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cesargdm/game-of-life/main/1"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double sumRealNew = 0.0;\n  double sumImaginaryNew = 0.0;\n  double sumRealOld = 0.0;\n  double sumImaginaryOld = 0.0;\n  for (uint p = 0; p < length; ++p)\n  {\n    uint currentAtom = startAtom + p;\n    if (particleHasNoCharge[currentAtom])\n    {\n      continue;\n    }\n\n    double dotProductNew = Dot(p, kxRef[box][i], kyRef[box][i], kzRef[box][i], molCoords);\n    double dotProductOld = Dot(currentAtom, kxRef[box][i], kyRef[box][i], kzRef[box][i], currentCoords);\n    sumRealNew += thisKind.AtomCharge(p) * cos(dotProductNew);\n    sumImaginaryNew += thisKind.AtomCharge(p) * sin(dotProductNew);\n    sumRealOld += thisKind.AtomCharge(p) * cos(dotProductOld);\n    sumImaginaryOld += thisKind.AtomCharge(p) * sin(dotProductOld);\n  }\n\n  sumRnew[box][i] = sumRref[box][i] + (lambdaCoef * (sumRealNew - sumRealOld));\n  sumInew[box][i] = sumIref[box][i] + (lambdaCoef * (sumImaginaryNew - sumImaginaryOld));\n  energyRecipNew += ((sumRnew[box][i] * sumRnew[box][i]) + (sumInew[box][i] * sumInew[box][i])) * prefactRef[box][i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(lambdaCoef, length, molCoords, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/8"}
{"code": "for (int e = 0; e < EXPERIMENT_TIMES; e++)\n{\n  times[e] = gather(input, output, idx, len);\n  if (e == 0)\n  {\n    bool res = true;\n    for (int i = 0; i < len; i++)\n    {\n      if (output[i] != input[idx[i]])\n      {\n        res = false;\n        break;\n      }\n\n    }\n\n    if (!res)\n      log_error(\"Wrong results\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/openmp/test_gather_scatter_CPU/1"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    C[(i * 128) + j] = 0.0;\n    int k;\n    for (k = 0; k < 128; ++k)\n    {\n      C[(i * 128) + j] += A[(i * 128) + k] * B[(k * 128) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/17"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double val = b[i][0];\n  for (int j = 0; j < i; ++j)\n    val -= mat[i][j] * y[j][0];\n\n  y[i][0] = val / mat[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/10"}
{"code": "for (int i = 0; i < MAX_FREE_TASK_GROUPS; ++i)\n{\n  if (freeTaskGroups[i] == NULL)\n  {\n    void *ptr = lAtomicCompareAndSwapPointer((void **) (&freeTaskGroups[i]), tg, NULL);\n    if (ptr == NULL)\n      return;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/7"}
{"code": "for (k = 0; k < argc; k++)\n  ;\n\n", "pragma": "#pragma omp for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/loops_explicit_clauses_codegen/0"}
{"code": "for (int i = 0; i < nErosions; i++)\n  blockErosion(multipleProcessedImg, m, n, SE, seRows, blockDim, blockDim, blockDim);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/delchiaro/parallel-project/src/mainSimpleStructured/0"}
{"code": "for (unsigned ci = 0; ci < ListSize; ci++)\n  npfull += List[ci]->GetNptInit() * List[ci]->GetLayers();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/1"}
{"code": "for (i = 0; i < m1; i++)\n{\n  for (j = 0; j < n2; j++)\n  {\n    res[i][j] = 0;\n    for (k = 0; k < m2; k++)\n    {\n      res[i][j] += a[i][k] * b[k][j];\n    }\n\n    printf(\"%d\\t\", res[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kundan-walunj/OpenMP-Projects/matrix_mul_openmp/0"}
{"code": "for (int i = 0; i < x; i++)\n{\n  for (int j = 0; j < y; j++)\n  {\n    arr[i][j] = rand() % 5;\n    if (i == j)\n    {\n      arr[i][j] *= -1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/koksing456/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/OpenMP/OpenMP/parallel/8"}
{"code": "for (i = 0; i < nDimensions; i++)\n{\n  sum1 = sum1 + gsl_pow_2(x[i]);\n  sum2 = sum2 + cos(c * x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/mpiomp/5"}
{"code": "for (int i = 1; i <= num; i++)\n{\n  if ((num % i) == 0)\n  {\n    aux++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Madureiradaniel/primos-mpi-openmp/questao1/0"}
{"code": "for (int i = 0; i < (nov - 1); i++)\n{\n  double rsum = 0;\n  int rowIndex = xadj[i];\n  for (; rowIndex < xadj[i + 1]; rowIndex++)\n  {\n    rsum += cv[adj[rowIndex]];\n  }\n\n  if (rsum != 0)\n  {\n    rv[i] = 1.0 / rsum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kayagokalp/Sinkhorn-Knopp-Parallel-OpenMP/scalesk_hw1/0"}
{"code": "for (j = 0; j < 700; j++)\n{\n  w[700 - 1][j] = 100.0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/hated_plate_local/2"}
{"code": "for (i = k - 1; i >= 0; --i)\n{\n  temp = Au[index[i]][k] / Au[index[k]][k];\n  Au[index[i]][k] -= temp * Au[index[k]][k];\n  Au[index[i]][size] -= temp * Au[index[k]][size];\n}\n\n", "pragma": "omp for schedule(static, 64) private(temp, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abidrahman/Discovering-OpenMP/static/1"}
{"code": "for (int i = 0; i < con_n; i++)\n{\n  printf(\"(%d,%d)\\n\", con_x[i], con_y[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/pc/4"}
{"code": "for (i = 0; i < 256; i++)\n{\n  histo[i] = 0;\n  for (j = 0; j < num_thread; j++)\n    histo_thread[i][j] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_creative/3"}
{"code": "for (j = i + 1; j < miasteroide.size(); j++)\n{\n  distanciaAst = sqrt(pow(miasteroide[i].x - miasteroide[j].x, 2) + pow(miasteroide[i].y - miasteroide[j].y, 2));\n  if (distanciaAst > dmin)\n  {\n    pendienteAst = (miasteroide[i].y - miasteroide[j].y) / (miasteroide[i].x - miasteroide[j].x);\n    if ((pendienteAst >= 1) || (pendienteAst <= (-1)))\n    {\n      pendienteAst = pendienteAst - trunc(pendienteAst);\n    }\n\n    anguloAst = atan(pendienteAst);\n    fuerza = ((gravity * miasteroide[i].masa) * miasteroide[j].masa) / pow(distanciaAst, 2);\n    if (fuerza > 200)\n    {\n      fuerza = 200;\n    }\n\n    fuerzax[i][j] = fuerza * cos(anguloAst);\n    fuerzay[i][j] = fuerza * sin(anguloAst);\n    fuerzax[j][i] = -fuerzax[i][j];\n    fuerzay[j][i] = -fuerzay[i][j];\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(i,miasteroide,fuerzax,fuerzay) private(j,fuerza,distanciaAst,pendienteAst,anguloAst)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JaimeGarcia17/Asteroides/par/nasteroids-par/3"}
{"code": "for (int j = 1; j < 256; j++)\n{\n  count[j] += count[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vanerk03/Auto-contrast/hw5/2"}
{"code": "for (i = 1; i < (num_line - 1); i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    send_buf[counter] = resultMatrix[i][j];\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/14"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    result = 0;\n    for (k = 0; k < L; k++)\n    {\n      result += A[k + (i * L)] * B[j + (k * N)];\n    }\n\n    res[j + (i * N)] = result;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Tests/testing/myFeed/my_feed/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp[i] = data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/0"}
{"code": "for (i = 0; i < 800; i++)\n{\n  free(c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/10"}
{"code": "for (i = 1; i < (10000.0 - 1); i++)\n{\n  for (j = 1; j < (10000.0 - 1); j++)\n  {\n    m[i][j] = aux[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HardProxy/OpenMP/prog_in/6"}
{"code": "for (i = 0; i < nBuckets_r; i++)\n{\n  quickSort(bucketsVector[i].value, 0, bucketsVector[i].total - 1);\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PietroPan/Parallel-BucketSort/bucket_sort/0"}
{"code": "for (; (i < N) && (j < N); i = (i + incX) + 4, j = (j + incY) + 4)\n{\n  v = _mm_load_ps(X + i);\n  _mm_store_ps(Y + i, v);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/4"}
{"code": "for (iz = 0; iz < nzl; iz++)\n{\n  for (iy = 0; iy < nyl; iy++)\n  {\n    for (ix = 0; ix < nxl; ix++)\n    {\n      tN_new[CELTNDX3(ix, iy, iz)] = tvar[CELTNDX(ix, iy, iz)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ix, iy, iz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/init/1"}
{"code": "for (i = id; i <= l; i++)\n{\n  cout << ((char) xans[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/1"}
{"code": "for (size_t i = 0; i < ((size_t) ((result.height * result.width) * result.bpp)); ++i)\n{\n  size_t shift = (size_t) (i * data.bpp);\n  result.canva[i] = (unsigned char) (((((double) data.canva[shift]) * 0.2126) + (((double) data.canva[shift + 1]) * 0.7152)) + (((double) data.canva[shift + 2]) * 0.0722));\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/DataProviders/Images/1"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  r[i] = i * 3.14159;\n  for (j = 0; j < 4096; j++)\n  {\n    A[(i * 4096) + j] = (((DATA_TYPE) i) * j) / 4096;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/12"}
{"code": "for (j = i + 1; j < size; j++)\n{\n  if (array[j] < array[local_min])\n    local_min = j;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Trees-Over-The-Lake/OpenMP-ACIII/Selection Sort/parallel2/0"}
{"code": "for (; i < size; ++p1, ++p2, ++i)\n  sum += (*p1) * (*p2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/8"}
{"code": "for (int k = 0; k < ctx->level; k++)\n{\n  if (i > 44)\n    break;\n\n  int n = ctx->child_num[k];\n  int m = ctx->num_children[k];\n  if (m == 1)\n    continue;\n\n  printf(\"%c%c \", (n < 62) ? (DIGITS[n]) : ('*'), (m < 62) ? (DIGITS[m]) : ('*'));\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/7"}
{"code": "for (i = its->begin(); i != its->end(); ++i)\n  if ((f->iterator && f->iterator->name_str) && (!strcmp((char *) (*i), (char *) f->iterator->name_str)))\n  break;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/PolyOpt2/polyopt/PastToSage/0"}
{"code": "for (i = 1; i < n; i++)\n{\n  pi += h * f(h * (i - 0.5));\n}\n\n", "pragma": "omp parallel for reduction(+:pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UniversityProjects/Cineca_Parallel_Computing/OpenMP_Code/pi/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  for (j = 0; j < 8; j++)\n  {\n    switch (map[(8 * i) + j])\n    {\n      case 0:\n        glColor3f(0.2, 0.2, 0.2);\n        break;\n\n      case 1:\n        glColor3f(0, 0, 1);\n        break;\n\n      case 2:\n        glColor3f(1, 0, 0);\n        break;\n\n      case 3:\n        glColor3f(0, 1, 0);\n        break;\n\n      case 4:\n        glColor3f(1, 1, 0);\n        break;\n\n      case 5:\n        glColor3f(1, 1, 1);\n        break;\n\n    }\n\n    glBegin(0x0007);\n    glVertex2d((j * 64) + 1, (i * 64) + 1);\n    glVertex2d((j * 64) + 1, ((i * 64) + 64) - 1);\n    glVertex2d(((j * 64) + 64) - 1, ((i * 64) + 64) - 1);\n    glVertex2d(((j * 64) + 64) - 1, (i * 64) + 1);\n    glEnd();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/the-wida/Raycaster-OpenGL-and-OpenMP/main/2"}
{"code": "for (int d = 0; d < NDIM; d++)\n{\n  L.at(d) = 1.0;\n  BoundaryCoor.at(d) = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/0"}
{"code": "for (int j = loop_chunk; j < (n - 1); j += 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    swap(arr[j], arr[j + 1]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) ,shared(arr,loop_chunk, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMPTask/5.assignment-openmp-advanced/5.assignment-openmp-advanced/bubblesort/bubblesort/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, cur_salt->salt, cur_salt->length);\n  MD5_Update(&ctx, saved_key[index], 16);\n  MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/net_md5_fmt_plug/0"}
{"code": "for (int nt = 0; nt < size; nt++)\n{\n  if (nt != (size - 1))\n  {\n    endthread.push_back(((nt + 1) * ((int) (l / size))) - 1);\n  }\n  else\n  {\n    endthread.push_back(l - 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/7"}
{"code": "for (int i = s0; i < e0; i++)\n{\n  int neighbour_1 = adj[i];\n  int s1 = xadj[neighbour_1];\n  int e1 = xadj[neighbour_1 + 1];\n  for (int j = s1; j < e1; j++)\n  {\n    int neighbour_2 = adj[j];\n    if (neighbour_2 == index)\n      continue;\n\n    int s2 = xadj[neighbour_2];\n    int e2 = xadj[neighbour_2 + 1];\n    for (int k = s2; k < e2; k++)\n    {\n      int neighbour_3 = adj[k];\n      if (neighbour_3 == index)\n        continue;\n\n      if (neighbour_3 == neighbour_1)\n        continue;\n\n      int s3 = xadj[neighbour_3];\n      int e3 = xadj[neighbour_3 + 1];\n      for (int n = s3; n < e3; n++)\n      {\n        int neighbour_4 = adj[n];\n        if (neighbour_4 == index)\n        {\n          localcount += 1;\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/2"}
{"code": "for (y = 0; y < h; y++)\n{\n  for (x = 0; x < w; x++)\n  {\n    uint32_t status = random() % 100;\n    if (status < 50)\n    {\n      univ[y][x] = 1;\n    }\n    else\n      if (status < 95)\n    {\n      univ[y][x] = 0;\n    }\n    else\n    {\n      univ[y][x] = 2;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/4"}
{"code": "for (; pidx_darts_counter_temp34 <= (*endPidx); pidx_darts_counter_temp34++)\n{\n  update_part(partArray[pidx_darts_counter_temp34], *deposit);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/74"}
{"code": "for (i = 0; i < OBSERVES; i++)\n{\n  observe[i] = ((float) rand()) / RAND_MAX;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/11"}
{"code": "for (k = ki1; k < ki2; k++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    phi2[k][i] = C2 * (u[k][jfin - 1][i][4] - ((0.50 * (((u[k][jfin - 1][i][1] * u[k][jfin - 1][i][1]) + (u[k][jfin - 1][i][2] * u[k][jfin - 1][i][2])) + (u[k][jfin - 1][i][3] * u[k][jfin - 1][i][3]))) / u[k][jfin - 1][i][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/23"}
{"code": "for (i = 0; i < l; i++)\n{\n  if (iscntrl(p[i]))\n  {\n    p[i] = '\\0';\n    ++n;\n    do\n      ++i;\n    while ((i < l) && iscntrl(p[i]));\n    if (i < l)\n      q[n] = &p[i];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical2/simil3/2"}
{"code": "for (i = 0; i < TableSize; i++)\n  if (Table[i] != i)\n  temp++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/7"}
{"code": "for (long i = 0; i < NumBlocks; i++)\n{\n  for (long j = 0; j < NumBlocks; j++)\n  {\n    A[i][j] = (float *) malloc((BlockSize * BlockSize) * (sizeof(float)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/4"}
{"code": "for (long ci = 0; ci < nv; ci++)\n{\n  bigHolder[colors[ci] + ipost]++;\n}\n\n", "pragma": "\t\t#pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringUtils/0"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  sum1 += (i * i) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/2.norace7/2"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  atot += cell(ci).area();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/21"}
{"code": "for (i = 0, tmp = symtable->symbols; tmp; tmp = tmp->next)\n  if (((tmp->name_str && (!isIterator(tmp->name_str))) && tmp->name_str) && (((char *) tmp->name_str)[0] == 'T'))\n  allsyms[i++] = tmp;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/PolyOpt2/polyopt/PastToSage/2"}
{"code": "for (int ai = 0; ai < cast_mat->nrow_; ++ai)\n{\n  int first_col = cast_mat->mat_.row_offset[ai];\n  for (int ajj = this->mat_.row_offset[ai]; ajj < this->mat_.row_offset[ai + 1]; ++ajj)\n  {\n    for (int aj = first_col; aj < cast_mat->mat_.row_offset[ai + 1]; ++aj)\n    {\n      if (cast_mat->mat_.col[aj] == this->mat_.col[ajj])\n      {\n        this->mat_.val[ajj] = (alpha * this->mat_.val[ajj]) + (beta * cast_mat->mat_.val[aj]);\n        ++first_col;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/54"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        add = rhs[k][j][i][m];\n        rms_local[m] = rms_local[m] + (add * add);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/error/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  free(v[i]);\n  free(M[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/13"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  addedOut[i] = 0;\n  addedIn[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/5"}
{"code": "for (i = 0; i < taille; i++)\n{\n  tab[i] = rand() % 20;\n  printf(\"Nombre de thread  cr\u00e9es par OpenMP: %d \\n \", omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex5/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/14"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) pndi[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/102"}
{"code": "for (int i = 0; i < rows1; i++)\n{\n  result[i] = (int *) malloc((sizeof(int)) * columns2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/promops/lab/main/2"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n  {\n    for (int k = 0; k < nzn; k++)\n    {\n      for (int is = 0; is < ns; is++)\n      {\n        rhons[is][i][j][k] = rhoINIT[is] / FourPI;\n      }\n\n      Ex[i][j][k] = ebc[0];\n      Ey[i][j][k] = ebc[1];\n      Ez[i][j][k] = ebc[2];\n      double blp[3];\n      double a = L_square;\n      double xc = x_center;\n      double zc = z_center;\n      double x = grid->getXN(i, j, k);\n      double z = grid->getZN(i, j, k);\n      double r2 = ((x - xc) * (x - xc)) + ((z - zc) * (z - zc));\n      if (r2 > (a * a))\n      {\n        x_displ = x - xc;\n        z_displ = z - zc;\n        fac1 = (((-B1z) * a) * a) / (r2 * r2);\n        Bx_ext[i][j][k] = ((2 * x_displ) * z_displ) * fac1;\n        By_ext[i][j][k] = 0.0;\n        Bz_ext[i][j][k] = ((z_displ * z_displ) - (x_displ * x_displ)) * fac1;\n      }\n      else\n      {\n        Bx_ext[i][j][k] = 0.0;\n        By_ext[i][j][k] = 0.0;\n        Bz_ext[i][j][k] = 0.0;\n      }\n\n      Bxn[i][j][k] = B0x;\n      Byn[i][j][k] = B0y;\n      Bzn[i][j][k] = B0z;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/83"}
{"code": "for (int i = 0; i < pair_vector.size(); i++)\n{\n  int j = 0;\n  for (j = 0; j < dup_vector.size(); j++)\n  {\n    if (pair_vector[i].first == dup_vector[j][0].first)\n    {\n      dup_vector[j].push_back(pair_vector[i]);\n      break;\n    }\n\n  }\n\n  if (j >= dup_vector.size())\n  {\n    (vector < StringIntPair) > temp;\n    temp.push_back(pair_vector[i]);\n    dup_vector.push_back(temp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akermanmc/ENSC351_L4/word_countMR_OMP/3"}
{"code": "for (i = 0; i < (2 * n); i = i + 2)\n{\n  z0 = 0.0;\n  z1 = 0.0;\n  x[i] = z0;\n  z[i] = z0;\n  x[i + 1] = z1;\n  z[i + 1] = z1;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/fft_openmp/fft_openmp/0"}
{"code": "for (i = 0; i < batch; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    float sum = 0.0;\n    for (k = 0; k < K; k++)\n      sum += input[(i * K) + k] * weights[(j * K) + k];\n\n    output[(i * N) + j] += sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j,k) shared(input,weights,output)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/connect-omp-cpu/0"}
{"code": "for (int i = 0; i < (256 * PAD); i += PAD)\n{\n  if (hist[i])\n  {\n    double val = (((double) (hist[i] - cumulativeMin)) / ((double) ((height * width) - 1))) * 255.0;\n    normalized[i] = round(val);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/12"}
{"code": "for (i = a, l1 = nWdn * i, kp = out + i; i < b; i++, l1 += nWdn, kp++)\n{\n  jp = in + i;\n  {\n    double r1_0;\n    double i1_0;\n    double r1_1;\n    double i1_1;\n    double r1_2;\n    double i1_2;\n    double r1_3;\n    double i1_3;\n    double r1_4;\n    double i1_4;\n    double r1_5;\n    double i1_5;\n    double r1_6;\n    double i1_6;\n    double r1_7;\n    double i1_7;\n    double r1_8;\n    double i1_8;\n    double r1_9;\n    double i1_9;\n    double r1_10;\n    double i1_10;\n    double r1_11;\n    double i1_11;\n    double r1_12;\n    double i1_12;\n    double r1_13;\n    double i1_13;\n    double r1_14;\n    double i1_14;\n    double r1_15;\n    double i1_15;\n    double r1_16;\n    double i1_16;\n    double r1_17;\n    double i1_17;\n    double r1_18;\n    double i1_18;\n    double r1_19;\n    double i1_19;\n    double r1_20;\n    double i1_20;\n    double r1_21;\n    double i1_21;\n    double r1_22;\n    double i1_22;\n    double r1_23;\n    double i1_23;\n    double r1_24;\n    double i1_24;\n    double r1_25;\n    double i1_25;\n    double r1_26;\n    double i1_26;\n    double r1_27;\n    double i1_27;\n    double r1_28;\n    double i1_28;\n    double r1_29;\n    double i1_29;\n    double r1_30;\n    double i1_30;\n    double r1_31;\n    double i1_31;\n    {\n      double r2_0;\n      double i2_0;\n      double r2_2;\n      double i2_2;\n      double r2_4;\n      double i2_4;\n      double r2_6;\n      double i2_6;\n      double r2_8;\n      double i2_8;\n      double r2_10;\n      double i2_10;\n      double r2_12;\n      double i2_12;\n      double r2_14;\n      double i2_14;\n      double r2_16;\n      double i2_16;\n      double r2_18;\n      double i2_18;\n      double r2_20;\n      double i2_20;\n      double r2_22;\n      double i2_22;\n      double r2_24;\n      double i2_24;\n      double r2_26;\n      double i2_26;\n      double r2_28;\n      double i2_28;\n      double r2_30;\n      double i2_30;\n      {\n        double r3_0;\n        double i3_0;\n        double r3_4;\n        double i3_4;\n        double r3_8;\n        double i3_8;\n        double r3_12;\n        double i3_12;\n        double r3_16;\n        double i3_16;\n        double r3_20;\n        double i3_20;\n        double r3_24;\n        double i3_24;\n        double r3_28;\n        double i3_28;\n        {\n          double r4_0;\n          double i4_0;\n          double r4_8;\n          double i4_8;\n          double r4_16;\n          double i4_16;\n          double r4_24;\n          double i4_24;\n          {\n            double r5_0;\n            double i5_0;\n            double r5_16;\n            double i5_16;\n            r5_0 = jp[0 * m].re;\n            i5_0 = jp[0 * m].im;\n            wr = W[16 * l1].re;\n            wi = W[16 * l1].im;\n            tmpr = jp[16 * m].re;\n            tmpi = jp[16 * m].im;\n            r5_16 = (wr * tmpr) - (wi * tmpi);\n            i5_16 = (wi * tmpr) + (wr * tmpi);\n            r4_0 = r5_0 + r5_16;\n            i4_0 = i5_0 + i5_16;\n            r4_16 = r5_0 - r5_16;\n            i4_16 = i5_0 - i5_16;\n          }\n          {\n            double r5_8;\n            double i5_8;\n            double r5_24;\n            double i5_24;\n            wr = W[8 * l1].re;\n            wi = W[8 * l1].im;\n            tmpr = jp[8 * m].re;\n            tmpi = jp[8 * m].im;\n            r5_8 = (wr * tmpr) - (wi * tmpi);\n            i5_8 = (wi * tmpr) + (wr * tmpi);\n            wr = W[24 * l1].re;\n            wi = W[24 * l1].im;\n            tmpr = jp[24 * m].re;\n            tmpi = jp[24 * m].im;\n            r5_24 = (wr * tmpr) - (wi * tmpi);\n            i5_24 = (wi * tmpr) + (wr * tmpi);\n            r4_8 = r5_8 + r5_24;\n            i4_8 = i5_8 + i5_24;\n            r4_24 = r5_8 - r5_24;\n            i4_24 = i5_8 - i5_24;\n          }\n          r3_0 = r4_0 + r4_8;\n          i3_0 = i4_0 + i4_8;\n          r3_16 = r4_0 - r4_8;\n          i3_16 = i4_0 - i4_8;\n          r3_8 = r4_16 + i4_24;\n          i3_8 = i4_16 - r4_24;\n          r3_24 = r4_16 - i4_24;\n          i3_24 = i4_16 + r4_24;\n        }\n        {\n          double r4_4;\n          double i4_4;\n          double r4_12;\n          double i4_12;\n          double r4_20;\n          double i4_20;\n          double r4_28;\n          double i4_28;\n          {\n            double r5_4;\n            double i5_4;\n            double r5_20;\n            double i5_20;\n            wr = W[4 * l1].re;\n            wi = W[4 * l1].im;\n            tmpr = jp[4 * m].re;\n            tmpi = jp[4 * m].im;\n            r5_4 = (wr * tmpr) - (wi * tmpi);\n            i5_4 = (wi * tmpr) + (wr * tmpi);\n            wr = W[20 * l1].re;\n            wi = W[20 * l1].im;\n            tmpr = jp[20 * m].re;\n            tmpi = jp[20 * m].im;\n            r5_20 = (wr * tmpr) - (wi * tmpi);\n            i5_20 = (wi * tmpr) + (wr * tmpi);\n            r4_4 = r5_4 + r5_20;\n            i4_4 = i5_4 + i5_20;\n            r4_20 = r5_4 - r5_20;\n            i4_20 = i5_4 - i5_20;\n          }\n          {\n            double r5_12;\n            double i5_12;\n            double r5_28;\n            double i5_28;\n            wr = W[12 * l1].re;\n            wi = W[12 * l1].im;\n            tmpr = jp[12 * m].re;\n            tmpi = jp[12 * m].im;\n            r5_12 = (wr * tmpr) - (wi * tmpi);\n            i5_12 = (wi * tmpr) + (wr * tmpi);\n            wr = W[28 * l1].re;\n            wi = W[28 * l1].im;\n            tmpr = jp[28 * m].re;\n            tmpi = jp[28 * m].im;\n            r5_28 = (wr * tmpr) - (wi * tmpi);\n            i5_28 = (wi * tmpr) + (wr * tmpi);\n            r4_12 = r5_12 + r5_28;\n            i4_12 = i5_12 + i5_28;\n            r4_28 = r5_12 - r5_28;\n            i4_28 = i5_12 - i5_28;\n          }\n          r3_4 = r4_4 + r4_12;\n          i3_4 = i4_4 + i4_12;\n          r3_20 = r4_4 - r4_12;\n          i3_20 = i4_4 - i4_12;\n          r3_12 = r4_20 + i4_28;\n          i3_12 = i4_20 - r4_28;\n          r3_28 = r4_20 - i4_28;\n          i3_28 = i4_20 + r4_28;\n        }\n        r2_0 = r3_0 + r3_4;\n        i2_0 = i3_0 + i3_4;\n        r2_16 = r3_0 - r3_4;\n        i2_16 = i3_0 - i3_4;\n        tmpr = 0.707106781187 * (r3_12 + i3_12);\n        tmpi = 0.707106781187 * (i3_12 - r3_12);\n        r2_4 = r3_8 + tmpr;\n        i2_4 = i3_8 + tmpi;\n        r2_20 = r3_8 - tmpr;\n        i2_20 = i3_8 - tmpi;\n        r2_8 = r3_16 + i3_20;\n        i2_8 = i3_16 - r3_20;\n        r2_24 = r3_16 - i3_20;\n        i2_24 = i3_16 + r3_20;\n        tmpr = 0.707106781187 * (i3_28 - r3_28);\n        tmpi = 0.707106781187 * (r3_28 + i3_28);\n        r2_12 = r3_24 + tmpr;\n        i2_12 = i3_24 - tmpi;\n        r2_28 = r3_24 - tmpr;\n        i2_28 = i3_24 + tmpi;\n      }\n      {\n        double r3_2;\n        double i3_2;\n        double r3_6;\n        double i3_6;\n        double r3_10;\n        double i3_10;\n        double r3_14;\n        double i3_14;\n        double r3_18;\n        double i3_18;\n        double r3_22;\n        double i3_22;\n        double r3_26;\n        double i3_26;\n        double r3_30;\n        double i3_30;\n        {\n          double r4_2;\n          double i4_2;\n          double r4_10;\n          double i4_10;\n          double r4_18;\n          double i4_18;\n          double r4_26;\n          double i4_26;\n          {\n            double r5_2;\n            double i5_2;\n            double r5_18;\n            double i5_18;\n            wr = W[2 * l1].re;\n            wi = W[2 * l1].im;\n            tmpr = jp[2 * m].re;\n            tmpi = jp[2 * m].im;\n            r5_2 = (wr * tmpr) - (wi * tmpi);\n            i5_2 = (wi * tmpr) + (wr * tmpi);\n            wr = W[18 * l1].re;\n            wi = W[18 * l1].im;\n            tmpr = jp[18 * m].re;\n            tmpi = jp[18 * m].im;\n            r5_18 = (wr * tmpr) - (wi * tmpi);\n            i5_18 = (wi * tmpr) + (wr * tmpi);\n            r4_2 = r5_2 + r5_18;\n            i4_2 = i5_2 + i5_18;\n            r4_18 = r5_2 - r5_18;\n            i4_18 = i5_2 - i5_18;\n          }\n          {\n            double r5_10;\n            double i5_10;\n            double r5_26;\n            double i5_26;\n            wr = W[10 * l1].re;\n            wi = W[10 * l1].im;\n            tmpr = jp[10 * m].re;\n            tmpi = jp[10 * m].im;\n            r5_10 = (wr * tmpr) - (wi * tmpi);\n            i5_10 = (wi * tmpr) + (wr * tmpi);\n            wr = W[26 * l1].re;\n            wi = W[26 * l1].im;\n            tmpr = jp[26 * m].re;\n            tmpi = jp[26 * m].im;\n            r5_26 = (wr * tmpr) - (wi * tmpi);\n            i5_26 = (wi * tmpr) + (wr * tmpi);\n            r4_10 = r5_10 + r5_26;\n            i4_10 = i5_10 + i5_26;\n            r4_26 = r5_10 - r5_26;\n            i4_26 = i5_10 - i5_26;\n          }\n          r3_2 = r4_2 + r4_10;\n          i3_2 = i4_2 + i4_10;\n          r3_18 = r4_2 - r4_10;\n          i3_18 = i4_2 - i4_10;\n          r3_10 = r4_18 + i4_26;\n          i3_10 = i4_18 - r4_26;\n          r3_26 = r4_18 - i4_26;\n          i3_26 = i4_18 + r4_26;\n        }\n        {\n          double r4_6;\n          double i4_6;\n          double r4_14;\n          double i4_14;\n          double r4_22;\n          double i4_22;\n          double r4_30;\n          double i4_30;\n          {\n            double r5_6;\n            double i5_6;\n            double r5_22;\n            double i5_22;\n            wr = W[6 * l1].re;\n            wi = W[6 * l1].im;\n            tmpr = jp[6 * m].re;\n            tmpi = jp[6 * m].im;\n            r5_6 = (wr * tmpr) - (wi * tmpi);\n            i5_6 = (wi * tmpr) + (wr * tmpi);\n            wr = W[22 * l1].re;\n            wi = W[22 * l1].im;\n            tmpr = jp[22 * m].re;\n            tmpi = jp[22 * m].im;\n            r5_22 = (wr * tmpr) - (wi * tmpi);\n            i5_22 = (wi * tmpr) + (wr * tmpi);\n            r4_6 = r5_6 + r5_22;\n            i4_6 = i5_6 + i5_22;\n            r4_22 = r5_6 - r5_22;\n            i4_22 = i5_6 - i5_22;\n          }\n          {\n            double r5_14;\n            double i5_14;\n            double r5_30;\n            double i5_30;\n            wr = W[14 * l1].re;\n            wi = W[14 * l1].im;\n            tmpr = jp[14 * m].re;\n            tmpi = jp[14 * m].im;\n            r5_14 = (wr * tmpr) - (wi * tmpi);\n            i5_14 = (wi * tmpr) + (wr * tmpi);\n            wr = W[30 * l1].re;\n            wi = W[30 * l1].im;\n            tmpr = jp[30 * m].re;\n            tmpi = jp[30 * m].im;\n            r5_30 = (wr * tmpr) - (wi * tmpi);\n            i5_30 = (wi * tmpr) + (wr * tmpi);\n            r4_14 = r5_14 + r5_30;\n            i4_14 = i5_14 + i5_30;\n            r4_30 = r5_14 - r5_30;\n            i4_30 = i5_14 - i5_30;\n          }\n          r3_6 = r4_6 + r4_14;\n          i3_6 = i4_6 + i4_14;\n          r3_22 = r4_6 - r4_14;\n          i3_22 = i4_6 - i4_14;\n          r3_14 = r4_22 + i4_30;\n          i3_14 = i4_22 - r4_30;\n          r3_30 = r4_22 - i4_30;\n          i3_30 = i4_22 + r4_30;\n        }\n        r2_2 = r3_2 + r3_6;\n        i2_2 = i3_2 + i3_6;\n        r2_18 = r3_2 - r3_6;\n        i2_18 = i3_2 - i3_6;\n        tmpr = 0.707106781187 * (r3_14 + i3_14);\n        tmpi = 0.707106781187 * (i3_14 - r3_14);\n        r2_6 = r3_10 + tmpr;\n        i2_6 = i3_10 + tmpi;\n        r2_22 = r3_10 - tmpr;\n        i2_22 = i3_10 - tmpi;\n        r2_10 = r3_18 + i3_22;\n        i2_10 = i3_18 - r3_22;\n        r2_26 = r3_18 - i3_22;\n        i2_26 = i3_18 + r3_22;\n        tmpr = 0.707106781187 * (i3_30 - r3_30);\n        tmpi = 0.707106781187 * (r3_30 + i3_30);\n        r2_14 = r3_26 + tmpr;\n        i2_14 = i3_26 - tmpi;\n        r2_30 = r3_26 - tmpr;\n        i2_30 = i3_26 + tmpi;\n      }\n      r1_0 = r2_0 + r2_2;\n      i1_0 = i2_0 + i2_2;\n      r1_16 = r2_0 - r2_2;\n      i1_16 = i2_0 - i2_2;\n      tmpr = (0.923879532511 * r2_6) + (0.382683432365 * i2_6);\n      tmpi = (0.923879532511 * i2_6) - (0.382683432365 * r2_6);\n      r1_2 = r2_4 + tmpr;\n      i1_2 = i2_4 + tmpi;\n      r1_18 = r2_4 - tmpr;\n      i1_18 = i2_4 - tmpi;\n      tmpr = 0.707106781187 * (r2_10 + i2_10);\n      tmpi = 0.707106781187 * (i2_10 - r2_10);\n      r1_4 = r2_8 + tmpr;\n      i1_4 = i2_8 + tmpi;\n      r1_20 = r2_8 - tmpr;\n      i1_20 = i2_8 - tmpi;\n      tmpr = (0.382683432365 * r2_14) + (0.923879532511 * i2_14);\n      tmpi = (0.382683432365 * i2_14) - (0.923879532511 * r2_14);\n      r1_6 = r2_12 + tmpr;\n      i1_6 = i2_12 + tmpi;\n      r1_22 = r2_12 - tmpr;\n      i1_22 = i2_12 - tmpi;\n      r1_8 = r2_16 + i2_18;\n      i1_8 = i2_16 - r2_18;\n      r1_24 = r2_16 - i2_18;\n      i1_24 = i2_16 + r2_18;\n      tmpr = (0.923879532511 * i2_22) - (0.382683432365 * r2_22);\n      tmpi = (0.923879532511 * r2_22) + (0.382683432365 * i2_22);\n      r1_10 = r2_20 + tmpr;\n      i1_10 = i2_20 - tmpi;\n      r1_26 = r2_20 - tmpr;\n      i1_26 = i2_20 + tmpi;\n      tmpr = 0.707106781187 * (i2_26 - r2_26);\n      tmpi = 0.707106781187 * (r2_26 + i2_26);\n      r1_12 = r2_24 + tmpr;\n      i1_12 = i2_24 - tmpi;\n      r1_28 = r2_24 - tmpr;\n      i1_28 = i2_24 + tmpi;\n      tmpr = (0.382683432365 * i2_30) - (0.923879532511 * r2_30);\n      tmpi = (0.382683432365 * r2_30) + (0.923879532511 * i2_30);\n      r1_14 = r2_28 + tmpr;\n      i1_14 = i2_28 - tmpi;\n      r1_30 = r2_28 - tmpr;\n      i1_30 = i2_28 + tmpi;\n    }\n    {\n      double r2_1;\n      double i2_1;\n      double r2_3;\n      double i2_3;\n      double r2_5;\n      double i2_5;\n      double r2_7;\n      double i2_7;\n      double r2_9;\n      double i2_9;\n      double r2_11;\n      double i2_11;\n      double r2_13;\n      double i2_13;\n      double r2_15;\n      double i2_15;\n      double r2_17;\n      double i2_17;\n      double r2_19;\n      double i2_19;\n      double r2_21;\n      double i2_21;\n      double r2_23;\n      double i2_23;\n      double r2_25;\n      double i2_25;\n      double r2_27;\n      double i2_27;\n      double r2_29;\n      double i2_29;\n      double r2_31;\n      double i2_31;\n      {\n        double r3_1;\n        double i3_1;\n        double r3_5;\n        double i3_5;\n        double r3_9;\n        double i3_9;\n        double r3_13;\n        double i3_13;\n        double r3_17;\n        double i3_17;\n        double r3_21;\n        double i3_21;\n        double r3_25;\n        double i3_25;\n        double r3_29;\n        double i3_29;\n        {\n          double r4_1;\n          double i4_1;\n          double r4_9;\n          double i4_9;\n          double r4_17;\n          double i4_17;\n          double r4_25;\n          double i4_25;\n          {\n            double r5_1;\n            double i5_1;\n            double r5_17;\n            double i5_17;\n            wr = W[1 * l1].re;\n            wi = W[1 * l1].im;\n            tmpr = jp[1 * m].re;\n            tmpi = jp[1 * m].im;\n            r5_1 = (wr * tmpr) - (wi * tmpi);\n            i5_1 = (wi * tmpr) + (wr * tmpi);\n            wr = W[17 * l1].re;\n            wi = W[17 * l1].im;\n            tmpr = jp[17 * m].re;\n            tmpi = jp[17 * m].im;\n            r5_17 = (wr * tmpr) - (wi * tmpi);\n            i5_17 = (wi * tmpr) + (wr * tmpi);\n            r4_1 = r5_1 + r5_17;\n            i4_1 = i5_1 + i5_17;\n            r4_17 = r5_1 - r5_17;\n            i4_17 = i5_1 - i5_17;\n          }\n          {\n            double r5_9;\n            double i5_9;\n            double r5_25;\n            double i5_25;\n            wr = W[9 * l1].re;\n            wi = W[9 * l1].im;\n            tmpr = jp[9 * m].re;\n            tmpi = jp[9 * m].im;\n            r5_9 = (wr * tmpr) - (wi * tmpi);\n            i5_9 = (wi * tmpr) + (wr * tmpi);\n            wr = W[25 * l1].re;\n            wi = W[25 * l1].im;\n            tmpr = jp[25 * m].re;\n            tmpi = jp[25 * m].im;\n            r5_25 = (wr * tmpr) - (wi * tmpi);\n            i5_25 = (wi * tmpr) + (wr * tmpi);\n            r4_9 = r5_9 + r5_25;\n            i4_9 = i5_9 + i5_25;\n            r4_25 = r5_9 - r5_25;\n            i4_25 = i5_9 - i5_25;\n          }\n          r3_1 = r4_1 + r4_9;\n          i3_1 = i4_1 + i4_9;\n          r3_17 = r4_1 - r4_9;\n          i3_17 = i4_1 - i4_9;\n          r3_9 = r4_17 + i4_25;\n          i3_9 = i4_17 - r4_25;\n          r3_25 = r4_17 - i4_25;\n          i3_25 = i4_17 + r4_25;\n        }\n        {\n          double r4_5;\n          double i4_5;\n          double r4_13;\n          double i4_13;\n          double r4_21;\n          double i4_21;\n          double r4_29;\n          double i4_29;\n          {\n            double r5_5;\n            double i5_5;\n            double r5_21;\n            double i5_21;\n            wr = W[5 * l1].re;\n            wi = W[5 * l1].im;\n            tmpr = jp[5 * m].re;\n            tmpi = jp[5 * m].im;\n            r5_5 = (wr * tmpr) - (wi * tmpi);\n            i5_5 = (wi * tmpr) + (wr * tmpi);\n            wr = W[21 * l1].re;\n            wi = W[21 * l1].im;\n            tmpr = jp[21 * m].re;\n            tmpi = jp[21 * m].im;\n            r5_21 = (wr * tmpr) - (wi * tmpi);\n            i5_21 = (wi * tmpr) + (wr * tmpi);\n            r4_5 = r5_5 + r5_21;\n            i4_5 = i5_5 + i5_21;\n            r4_21 = r5_5 - r5_21;\n            i4_21 = i5_5 - i5_21;\n          }\n          {\n            double r5_13;\n            double i5_13;\n            double r5_29;\n            double i5_29;\n            wr = W[13 * l1].re;\n            wi = W[13 * l1].im;\n            tmpr = jp[13 * m].re;\n            tmpi = jp[13 * m].im;\n            r5_13 = (wr * tmpr) - (wi * tmpi);\n            i5_13 = (wi * tmpr) + (wr * tmpi);\n            wr = W[29 * l1].re;\n            wi = W[29 * l1].im;\n            tmpr = jp[29 * m].re;\n            tmpi = jp[29 * m].im;\n            r5_29 = (wr * tmpr) - (wi * tmpi);\n            i5_29 = (wi * tmpr) + (wr * tmpi);\n            r4_13 = r5_13 + r5_29;\n            i4_13 = i5_13 + i5_29;\n            r4_29 = r5_13 - r5_29;\n            i4_29 = i5_13 - i5_29;\n          }\n          r3_5 = r4_5 + r4_13;\n          i3_5 = i4_5 + i4_13;\n          r3_21 = r4_5 - r4_13;\n          i3_21 = i4_5 - i4_13;\n          r3_13 = r4_21 + i4_29;\n          i3_13 = i4_21 - r4_29;\n          r3_29 = r4_21 - i4_29;\n          i3_29 = i4_21 + r4_29;\n        }\n        r2_1 = r3_1 + r3_5;\n        i2_1 = i3_1 + i3_5;\n        r2_17 = r3_1 - r3_5;\n        i2_17 = i3_1 - i3_5;\n        tmpr = 0.707106781187 * (r3_13 + i3_13);\n        tmpi = 0.707106781187 * (i3_13 - r3_13);\n        r2_5 = r3_9 + tmpr;\n        i2_5 = i3_9 + tmpi;\n        r2_21 = r3_9 - tmpr;\n        i2_21 = i3_9 - tmpi;\n        r2_9 = r3_17 + i3_21;\n        i2_9 = i3_17 - r3_21;\n        r2_25 = r3_17 - i3_21;\n        i2_25 = i3_17 + r3_21;\n        tmpr = 0.707106781187 * (i3_29 - r3_29);\n        tmpi = 0.707106781187 * (r3_29 + i3_29);\n        r2_13 = r3_25 + tmpr;\n        i2_13 = i3_25 - tmpi;\n        r2_29 = r3_25 - tmpr;\n        i2_29 = i3_25 + tmpi;\n      }\n      {\n        double r3_3;\n        double i3_3;\n        double r3_7;\n        double i3_7;\n        double r3_11;\n        double i3_11;\n        double r3_15;\n        double i3_15;\n        double r3_19;\n        double i3_19;\n        double r3_23;\n        double i3_23;\n        double r3_27;\n        double i3_27;\n        double r3_31;\n        double i3_31;\n        {\n          double r4_3;\n          double i4_3;\n          double r4_11;\n          double i4_11;\n          double r4_19;\n          double i4_19;\n          double r4_27;\n          double i4_27;\n          {\n            double r5_3;\n            double i5_3;\n            double r5_19;\n            double i5_19;\n            wr = W[3 * l1].re;\n            wi = W[3 * l1].im;\n            tmpr = jp[3 * m].re;\n            tmpi = jp[3 * m].im;\n            r5_3 = (wr * tmpr) - (wi * tmpi);\n            i5_3 = (wi * tmpr) + (wr * tmpi);\n            wr = W[19 * l1].re;\n            wi = W[19 * l1].im;\n            tmpr = jp[19 * m].re;\n            tmpi = jp[19 * m].im;\n            r5_19 = (wr * tmpr) - (wi * tmpi);\n            i5_19 = (wi * tmpr) + (wr * tmpi);\n            r4_3 = r5_3 + r5_19;\n            i4_3 = i5_3 + i5_19;\n            r4_19 = r5_3 - r5_19;\n            i4_19 = i5_3 - i5_19;\n          }\n          {\n            double r5_11;\n            double i5_11;\n            double r5_27;\n            double i5_27;\n            wr = W[11 * l1].re;\n            wi = W[11 * l1].im;\n            tmpr = jp[11 * m].re;\n            tmpi = jp[11 * m].im;\n            r5_11 = (wr * tmpr) - (wi * tmpi);\n            i5_11 = (wi * tmpr) + (wr * tmpi);\n            wr = W[27 * l1].re;\n            wi = W[27 * l1].im;\n            tmpr = jp[27 * m].re;\n            tmpi = jp[27 * m].im;\n            r5_27 = (wr * tmpr) - (wi * tmpi);\n            i5_27 = (wi * tmpr) + (wr * tmpi);\n            r4_11 = r5_11 + r5_27;\n            i4_11 = i5_11 + i5_27;\n            r4_27 = r5_11 - r5_27;\n            i4_27 = i5_11 - i5_27;\n          }\n          r3_3 = r4_3 + r4_11;\n          i3_3 = i4_3 + i4_11;\n          r3_19 = r4_3 - r4_11;\n          i3_19 = i4_3 - i4_11;\n          r3_11 = r4_19 + i4_27;\n          i3_11 = i4_19 - r4_27;\n          r3_27 = r4_19 - i4_27;\n          i3_27 = i4_19 + r4_27;\n        }\n        {\n          double r4_7;\n          double i4_7;\n          double r4_15;\n          double i4_15;\n          double r4_23;\n          double i4_23;\n          double r4_31;\n          double i4_31;\n          {\n            double r5_7;\n            double i5_7;\n            double r5_23;\n            double i5_23;\n            wr = W[7 * l1].re;\n            wi = W[7 * l1].im;\n            tmpr = jp[7 * m].re;\n            tmpi = jp[7 * m].im;\n            r5_7 = (wr * tmpr) - (wi * tmpi);\n            i5_7 = (wi * tmpr) + (wr * tmpi);\n            wr = W[23 * l1].re;\n            wi = W[23 * l1].im;\n            tmpr = jp[23 * m].re;\n            tmpi = jp[23 * m].im;\n            r5_23 = (wr * tmpr) - (wi * tmpi);\n            i5_23 = (wi * tmpr) + (wr * tmpi);\n            r4_7 = r5_7 + r5_23;\n            i4_7 = i5_7 + i5_23;\n            r4_23 = r5_7 - r5_23;\n            i4_23 = i5_7 - i5_23;\n          }\n          {\n            double r5_15;\n            double i5_15;\n            double r5_31;\n            double i5_31;\n            wr = W[15 * l1].re;\n            wi = W[15 * l1].im;\n            tmpr = jp[15 * m].re;\n            tmpi = jp[15 * m].im;\n            r5_15 = (wr * tmpr) - (wi * tmpi);\n            i5_15 = (wi * tmpr) + (wr * tmpi);\n            wr = W[31 * l1].re;\n            wi = W[31 * l1].im;\n            tmpr = jp[31 * m].re;\n            tmpi = jp[31 * m].im;\n            r5_31 = (wr * tmpr) - (wi * tmpi);\n            i5_31 = (wi * tmpr) + (wr * tmpi);\n            r4_15 = r5_15 + r5_31;\n            i4_15 = i5_15 + i5_31;\n            r4_31 = r5_15 - r5_31;\n            i4_31 = i5_15 - i5_31;\n          }\n          r3_7 = r4_7 + r4_15;\n          i3_7 = i4_7 + i4_15;\n          r3_23 = r4_7 - r4_15;\n          i3_23 = i4_7 - i4_15;\n          r3_15 = r4_23 + i4_31;\n          i3_15 = i4_23 - r4_31;\n          r3_31 = r4_23 - i4_31;\n          i3_31 = i4_23 + r4_31;\n        }\n        r2_3 = r3_3 + r3_7;\n        i2_3 = i3_3 + i3_7;\n        r2_19 = r3_3 - r3_7;\n        i2_19 = i3_3 - i3_7;\n        tmpr = 0.707106781187 * (r3_15 + i3_15);\n        tmpi = 0.707106781187 * (i3_15 - r3_15);\n        r2_7 = r3_11 + tmpr;\n        i2_7 = i3_11 + tmpi;\n        r2_23 = r3_11 - tmpr;\n        i2_23 = i3_11 - tmpi;\n        r2_11 = r3_19 + i3_23;\n        i2_11 = i3_19 - r3_23;\n        r2_27 = r3_19 - i3_23;\n        i2_27 = i3_19 + r3_23;\n        tmpr = 0.707106781187 * (i3_31 - r3_31);\n        tmpi = 0.707106781187 * (r3_31 + i3_31);\n        r2_15 = r3_27 + tmpr;\n        i2_15 = i3_27 - tmpi;\n        r2_31 = r3_27 - tmpr;\n        i2_31 = i3_27 + tmpi;\n      }\n      r1_1 = r2_1 + r2_3;\n      i1_1 = i2_1 + i2_3;\n      r1_17 = r2_1 - r2_3;\n      i1_17 = i2_1 - i2_3;\n      tmpr = (0.923879532511 * r2_7) + (0.382683432365 * i2_7);\n      tmpi = (0.923879532511 * i2_7) - (0.382683432365 * r2_7);\n      r1_3 = r2_5 + tmpr;\n      i1_3 = i2_5 + tmpi;\n      r1_19 = r2_5 - tmpr;\n      i1_19 = i2_5 - tmpi;\n      tmpr = 0.707106781187 * (r2_11 + i2_11);\n      tmpi = 0.707106781187 * (i2_11 - r2_11);\n      r1_5 = r2_9 + tmpr;\n      i1_5 = i2_9 + tmpi;\n      r1_21 = r2_9 - tmpr;\n      i1_21 = i2_9 - tmpi;\n      tmpr = (0.382683432365 * r2_15) + (0.923879532511 * i2_15);\n      tmpi = (0.382683432365 * i2_15) - (0.923879532511 * r2_15);\n      r1_7 = r2_13 + tmpr;\n      i1_7 = i2_13 + tmpi;\n      r1_23 = r2_13 - tmpr;\n      i1_23 = i2_13 - tmpi;\n      r1_9 = r2_17 + i2_19;\n      i1_9 = i2_17 - r2_19;\n      r1_25 = r2_17 - i2_19;\n      i1_25 = i2_17 + r2_19;\n      tmpr = (0.923879532511 * i2_23) - (0.382683432365 * r2_23);\n      tmpi = (0.923879532511 * r2_23) + (0.382683432365 * i2_23);\n      r1_11 = r2_21 + tmpr;\n      i1_11 = i2_21 - tmpi;\n      r1_27 = r2_21 - tmpr;\n      i1_27 = i2_21 + tmpi;\n      tmpr = 0.707106781187 * (i2_27 - r2_27);\n      tmpi = 0.707106781187 * (r2_27 + i2_27);\n      r1_13 = r2_25 + tmpr;\n      i1_13 = i2_25 - tmpi;\n      r1_29 = r2_25 - tmpr;\n      i1_29 = i2_25 + tmpi;\n      tmpr = (0.382683432365 * i2_31) - (0.923879532511 * r2_31);\n      tmpi = (0.382683432365 * r2_31) + (0.923879532511 * i2_31);\n      r1_15 = r2_29 + tmpr;\n      i1_15 = i2_29 - tmpi;\n      r1_31 = r2_29 - tmpr;\n      i1_31 = i2_29 + tmpi;\n    }\n    kp[0 * m].re = r1_0 + r1_1;\n    kp[0 * m].im = i1_0 + i1_1;\n    kp[16 * m].re = r1_0 - r1_1;\n    kp[16 * m].im = i1_0 - i1_1;\n    tmpr = (0.980785280403 * r1_3) + (0.195090322016 * i1_3);\n    tmpi = (0.980785280403 * i1_3) - (0.195090322016 * r1_3);\n    kp[1 * m].re = r1_2 + tmpr;\n    kp[1 * m].im = i1_2 + tmpi;\n    kp[17 * m].re = r1_2 - tmpr;\n    kp[17 * m].im = i1_2 - tmpi;\n    tmpr = (0.923879532511 * r1_5) + (0.382683432365 * i1_5);\n    tmpi = (0.923879532511 * i1_5) - (0.382683432365 * r1_5);\n    kp[2 * m].re = r1_4 + tmpr;\n    kp[2 * m].im = i1_4 + tmpi;\n    kp[18 * m].re = r1_4 - tmpr;\n    kp[18 * m].im = i1_4 - tmpi;\n    tmpr = (0.831469612303 * r1_7) + (0.55557023302 * i1_7);\n    tmpi = (0.831469612303 * i1_7) - (0.55557023302 * r1_7);\n    kp[3 * m].re = r1_6 + tmpr;\n    kp[3 * m].im = i1_6 + tmpi;\n    kp[19 * m].re = r1_6 - tmpr;\n    kp[19 * m].im = i1_6 - tmpi;\n    tmpr = 0.707106781187 * (r1_9 + i1_9);\n    tmpi = 0.707106781187 * (i1_9 - r1_9);\n    kp[4 * m].re = r1_8 + tmpr;\n    kp[4 * m].im = i1_8 + tmpi;\n    kp[20 * m].re = r1_8 - tmpr;\n    kp[20 * m].im = i1_8 - tmpi;\n    tmpr = (0.55557023302 * r1_11) + (0.831469612303 * i1_11);\n    tmpi = (0.55557023302 * i1_11) - (0.831469612303 * r1_11);\n    kp[5 * m].re = r1_10 + tmpr;\n    kp[5 * m].im = i1_10 + tmpi;\n    kp[21 * m].re = r1_10 - tmpr;\n    kp[21 * m].im = i1_10 - tmpi;\n    tmpr = (0.382683432365 * r1_13) + (0.923879532511 * i1_13);\n    tmpi = (0.382683432365 * i1_13) - (0.923879532511 * r1_13);\n    kp[6 * m].re = r1_12 + tmpr;\n    kp[6 * m].im = i1_12 + tmpi;\n    kp[22 * m].re = r1_12 - tmpr;\n    kp[22 * m].im = i1_12 - tmpi;\n    tmpr = (0.195090322016 * r1_15) + (0.980785280403 * i1_15);\n    tmpi = (0.195090322016 * i1_15) - (0.980785280403 * r1_15);\n    kp[7 * m].re = r1_14 + tmpr;\n    kp[7 * m].im = i1_14 + tmpi;\n    kp[23 * m].re = r1_14 - tmpr;\n    kp[23 * m].im = i1_14 - tmpi;\n    kp[8 * m].re = r1_16 + i1_17;\n    kp[8 * m].im = i1_16 - r1_17;\n    kp[24 * m].re = r1_16 - i1_17;\n    kp[24 * m].im = i1_16 + r1_17;\n    tmpr = (0.980785280403 * i1_19) - (0.195090322016 * r1_19);\n    tmpi = (0.980785280403 * r1_19) + (0.195090322016 * i1_19);\n    kp[9 * m].re = r1_18 + tmpr;\n    kp[9 * m].im = i1_18 - tmpi;\n    kp[25 * m].re = r1_18 - tmpr;\n    kp[25 * m].im = i1_18 + tmpi;\n    tmpr = (0.923879532511 * i1_21) - (0.382683432365 * r1_21);\n    tmpi = (0.923879532511 * r1_21) + (0.382683432365 * i1_21);\n    kp[10 * m].re = r1_20 + tmpr;\n    kp[10 * m].im = i1_20 - tmpi;\n    kp[26 * m].re = r1_20 - tmpr;\n    kp[26 * m].im = i1_20 + tmpi;\n    tmpr = (0.831469612303 * i1_23) - (0.55557023302 * r1_23);\n    tmpi = (0.831469612303 * r1_23) + (0.55557023302 * i1_23);\n    kp[11 * m].re = r1_22 + tmpr;\n    kp[11 * m].im = i1_22 - tmpi;\n    kp[27 * m].re = r1_22 - tmpr;\n    kp[27 * m].im = i1_22 + tmpi;\n    tmpr = 0.707106781187 * (i1_25 - r1_25);\n    tmpi = 0.707106781187 * (r1_25 + i1_25);\n    kp[12 * m].re = r1_24 + tmpr;\n    kp[12 * m].im = i1_24 - tmpi;\n    kp[28 * m].re = r1_24 - tmpr;\n    kp[28 * m].im = i1_24 + tmpi;\n    tmpr = (0.55557023302 * i1_27) - (0.831469612303 * r1_27);\n    tmpi = (0.55557023302 * r1_27) + (0.831469612303 * i1_27);\n    kp[13 * m].re = r1_26 + tmpr;\n    kp[13 * m].im = i1_26 - tmpi;\n    kp[29 * m].re = r1_26 - tmpr;\n    kp[29 * m].im = i1_26 + tmpi;\n    tmpr = (0.382683432365 * i1_29) - (0.923879532511 * r1_29);\n    tmpi = (0.382683432365 * r1_29) + (0.923879532511 * i1_29);\n    kp[14 * m].re = r1_28 + tmpr;\n    kp[14 * m].im = i1_28 - tmpi;\n    kp[30 * m].re = r1_28 - tmpr;\n    kp[30 * m].im = i1_28 + tmpi;\n    tmpr = (0.195090322016 * i1_31) - (0.980785280403 * r1_31);\n    tmpi = (0.195090322016 * r1_31) + (0.980785280403 * i1_31);\n    kp[15 * m].re = r1_30 + tmpr;\n    kp[15 * m].im = i1_30 - tmpi;\n    kp[31 * m].re = r1_30 - tmpr;\n    kp[31 * m].im = i1_30 + tmpi;\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/12"}
{"code": "for (i = 0; i < N; ++i)\n{\n  solucao[i] = x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmunidario/Algoritmo_Jacobi/omp_jacobi/7"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x[i] = i * 3.14159;\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/ATAX/atax/2"}
{"code": "for (int i = 0; i < L1_NEURONS; i++)\n{\n  y = WL1[i][0];\n  for (int j = 1; j < L1_DIM; j++)\n  {\n    y += vector_in[j - 1] * WL1[i][j];\n  }\n\n  DL1[i] = y;\n  OL1[i] = sigmoid(y);\n}\n\n", "pragma": "omp parallel for private(y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/0"}
{"code": "for (int i = 0; i < (num_linhas * num_colunas); i++)\n{\n  distancia = calcular_distancia_euclidiana(entrada, grid_de_neuronios[i / num_colunas][i % num_colunas].vetor_de_pesos, 3);\n  vetor_de_distancias[i] = distancia;\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(threads_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruteee/Kohhonen/Rede/6"}
{"code": "for (size_t i = 0; i < num_threads; ++i)\n{\n  file_id_maps.emplace_back();\n  dictionaries.emplace_back();\n  word_count_maps.emplace_back();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/colby-j-wise/cpptext/src/processor/1"}
{"code": "for (int i = 0; i < N; i++)\n  temp[i] = root(visited, i + offset, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  ROWS_PLACED[i] = -1;\n  for (int j = 0; j < 8; j++)\n  {\n    VALID_ROWS[i][j] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens2/Queens2.1/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpfsx1gt2p.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbrukman/llvm-openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (int i = k + 1; i < Size; i++)\n{\n  multiplier = pMatrix[(i * Size) + k] / pMatrix[(k * Size) + k];\n  for (int j = k + 1; j <= Size; j++)\n    pMatrix[(i * Size) + j] -= pMatrix[(k * Size) + j] * multiplier;\n\n  pMatrix[(i * Size) + k] = 0;\n  pVector[i] -= pVector[k] * multiplier;\n}\n\n", "pragma": "omp parallel for shared(pMatrix, pVector) private(multiplier) num_threads(NUM_THREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmarotti/less-openmp/src/gaussian_elimination/1"}
{"code": "for (i = 0; i < 1000000000; i++)\n{\n  x = ((double) rand()) / 32767;\n  y = ((double) rand()) / 32767;\n  if (((x * x) + (y * y)) <= 1)\n    A++;\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture14/monte_carlo_omp/0"}
{"code": "for (k = 0; k < layer_size; k++)\n  layer_copy[k] = 0.0f;\n\n", "pragma": "omp parallel for shared(layer_copy)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bayons/OpenMP/Practica/energy_v2/1"}
{"code": "for (i = 0; i < 162; i++)\n{\n  for (j = 0; j < 162; j++)\n  {\n    for (k = 0; k < 162; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/ArithmeticMeasureTool/test/bt_single/1"}
{"code": "for (int axis = 0; axis < 3; axis++)\n{\n  if (!spatialOverlapPeri_axis(axis, id1, id2, minima[(3 * id1) + axis], maxima[(3 * id1) + axis], minima[(3 * id2) + axis], maxima[(3 * id2) + axis], scene->cell->getSize()[axis], periods[axis]))\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/woodem/woo/src/dem/InsertionSortCollider/2"}
{"code": "for (unsigned int idx = 0; idx < _ffdefparams.size(); idx++)\n  if (_ffdefparams[idx]._ipar[0] == type)\n  return _ffdefparams[idx]._ipar[1];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/28"}
{"code": "for (i = 0; i < primesCounter; ++i)\n{\n  int p = primes[i];\n  for (int j = p * p; j <= MAX; j += p)\n    if (j >= MIN)\n    if (isPrimeNumber[j])\n    isPrimeNumber[j] = false;\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/3"}
{"code": "for (i = my_rank - 1; i < end; i++)\n{\n  printf(\"%d \", result[i]);\n  for (int j = 0; j < quantidade[i]; j++)\n    printf(\"#\");\n\n  printf(\"%d \\n\", quantidade[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeGiacomoSimoes/OpenMP/vector_parallel_print/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    Z[i][j] = 0;\n    for (int k = 0; k < n; k++)\n    {\n      Z[i][j] += X[i][k] * Y[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yarensonmez/Seri-ve-Paralel-Matris-Carpimi/paralelproje/paralelproje/1"}
{"code": "for (const_iterator iter = parray.begin(); iter != parray.end(); iter++)\n{\n  copy(iter->begin(), iter->end(), svdata.begin() + cpos);\n  if (me != pproc)\n    MPI_Isend(svdata.data() + cpos, iter->size(), MPI_GRAPH_TYPE, pproc, VertexTag, MPI_COMM_WORLD, &sreqs[pproc]);\n  else\n    sreqs[pproc] = MPI_REQUEST_NULL;\n\n  cpos += iter->size();\n  pproc++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/24"}
{"code": "for (int k = 0; k < nUser; k++)\n{\n  sol_aux = 0;\n  A_aux1 = A_user[k];\n  while (A_aux1 != 0)\n  {\n    B[k][A_aux1->item] = 0;\n    A_aux1 = A_aux1->nextItem;\n  }\n\n  for (int j = 0; j < nItem; j++)\n  {\n    if (B[k][j] > sol_aux)\n    {\n      solution[k] = j;\n      sol_aux = B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/3"}
{"code": "for (j = -tt; j < (tt + 1); j++)\n{\n  for (k = -tt; k < (tt + 1); k++)\n  {\n    if (((((xx + j) >= 0) && ((xx + j) < xsize)) && ((yy + k) >= 0)) && ((yy + k) < ysize))\n    {\n      local_image[((yy + k) * xsize) + (xx + j)] += mm * cubic_kernel(sqrt((((float) j) * ((float) j)) + (((float) k) * ((float) k))), tt);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/rendermodule/3"}
{"code": "for (int i = 0; i < numChunks; i++)\n{\n  for (k = 0; k < chunk; k++)\n  {\n    x = ((double) rand()) / (((double) RAND_MAX) * 2);\n    double alpha = (((double) rand()) / ((double) RAND_MAX)) * rpi;\n    y = (l / 2.0) * sin(alpha);\n    c = c + (x <= y);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for shared(numChunks, chunk, l) reduction(+:c) private(k, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laurasgm/HPC-Needles-Dartboard-openMP/needless-openMP/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  test_data[i] = (rand() % N) + 1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/y-gupta/col757-ass1/q2/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  printf(\"%4d %8d %8d %16lf\\n\", i + 1, (int) table[i][0], (int) table[i][1], table[i][2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alperencubuk/Sequence-Alignment-with-NW-Algorithm/SequenceAlignment/1"}
{"code": "for (int i = 0; i < numTests; ++i)\n{\n  free(test[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/17"}
{"code": "for (size_t i = 0; i < bodyCount; i++)\n{\n  omp_init_lock(&locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dooglz/cputest/main/1"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    calc_rms_kernel(&((double *) arg0.data)[5 * n], &arg1_l[64 * omp_get_thread_num()]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[14].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/calc_rms_kernel_kernel/1"}
{"code": "for (int x = 0; x < GRAIN; x++)\n{\n  for (int y = 0; y < GRAIN; y++)\n  {\n    if (current_array[(x * GRAIN) + y] == 1)\n    {\n      current_array[(x * GRAIN) + y] = 0;\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          compute_new_state(i, j);\n          if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n          {\n            for (int k = max(0, x - 1); k <= min(GRAIN - 1, x + 1); k++)\n              for (int l = max(0, y - 1); l <= min(GRAIN - 1, y + 1); l++)\n              next_array[(k * GRAIN) + l] = 1;\n\n\n          }\n\n          if (next_img(i, j) != 0xFFFF00FF)\n          {\n            next_img(i, j) = 0xFF0000FF;\n          }\n\n        }\n\n      }\n\n    }\n    else\n    {\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          if (next_img(i, j) != 0xFFFF00FF)\n          {\n            next_img(i, j) = 0;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/20"}
{"code": "for (int nt = 0; nt < numThreads; nt++)\n{\n  privLsum[nt] = create_matrix_double(nUsers, nFeatures);\n  privRTsum[nt] = create_matrix_double(nItems, nFeatures);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matFact-omp/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x[i] = rand() % 100;\n  z[i] = (a * x[i]) + y;\n  printf(\"Thread id: %d z[%d] = 2 * %d + 3 = %d \\n\", 0, i, x[i], z[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zuza3012/openmp-tutorial/spaxy/1"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  origin_dist = (x[i] * x[i]) + (y[i] * y[i]);\n  points = (origin_dist < radius) ? (points + 1) : (points);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sand47/ME759-CUDA-Assignments/HW09/montecarlo/0"}
{"code": "for (int i = 0; i < ml; ++i)\n{\n  for (int l = 0; l < nl; ++l)\n    C[i][l] = 0.0;\n\n  for (int k = 0; k < pl; ++k)\n    for (int j = 0; j < nl; ++j)\n    C[i][j] += A[i][k] * B[k][j];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Matmul/Solutions/matmul_stras_par/1"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericParticles[i]->FinalCalculateRightHandSide(r_process_info, dt, gravity);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/4"}
{"code": "for (int i = 0; i < ((int) check.size()); ++i)\n{\n  check[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/4"}
{"code": "for (int i = 1; i < (nprocs + 1); i++)\n  parts[i] = (newGlobalNumVertices * i) / nprocs;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/rebuild/9"}
{"code": "for (j = 0; j < 10; j++)\n{\n  temp = blocking_parallel_static(l, m, n, 8, num_t, j);\n  average_dt += temp[0];\n  average_rate += temp[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/8"}
{"code": "for (i = rb; i < re; i++)\n{\n  p_r[i] -= B[i];\n  err += p_r[i] * p_r[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/40"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxhs; i += 8)\n      {\n        v_t1 = _mm512_load_ps((float *) (&f[i + i1]));\n        v_t2 = _mm512_load_ps((float *) (&f[i + i0]));\n        _mm512_store_ps((float *) (&f[i + i1]), v_t2);\n        _mm512_store_ps((float *) (&f[i + i0]), v_t1);\n      }\n\n      for (i = nxhs; i < nxh; i++)\n      {\n        t1 = f[i + i1];\n        f[i + i1] = f[i + i0];\n        f[i + i0] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = sct[kmr * j];\n        v_t1 = _mm512_set4_ps(cimagf(t1), crealf(t1), cimagf(t1), crealf(t1));\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxhs; i += 8)\n        {\n          v_t2 = _mm512_load_ps((float *) (&f[i + i1]));\n          v_t3 = (int) _mm512_shuffle_epi32((int) v_t1, 160);\n          v_t3 = _mm512_mul_ps(v_t2, v_t3);\n          v_t2 = (int) _mm512_shuffle_epi32((int) v_t2, 177);\n          v_t4 = (int) _mm512_shuffle_epi32((int) v_t1, 245);\n          v_t4 = _mm512_mul_ps(v_t2, v_t4);\n          v_t4 = _mm512_mask_sub_ps(v_t4, _mm512_int2mask(21845), v_zero, v_t4);\n          v_t2 = _mm512_add_ps(v_t3, v_t4);\n          v_t3 = _mm512_load_ps((float *) (&f[i + i0]));\n          v_t4 = _mm512_sub_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[i + i1]), v_t4);\n          v_t4 = _mm512_add_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[i + i0]), v_t4);\n        }\n\n        for (i = nxhs; i < nxh; i++)\n        {\n          t2 = t1 * f[i + i1];\n          f[i + i1] = f[i + i0] - t2;\n          f[i + i0] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2, v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/29"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x.push_back(rand());\n  y.push_back(rand());\n  z.push_back(rand());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/axpyz/1"}
{"code": "for (j_it = 0; j_it < size; j_it++)\n{\n  for (k_it = 0; k_it < size; k_it++)\n  {\n    if ((((((i_it == 0) || (i_it == (((1 << 6) + 2) - 1))) || (j_it == 0)) || (j_it == (((1 << 6) + 2) - 1))) || (k_it == 0)) || (k_it == (((1 << 6) + 2) - 1)))\n    {\n      matrix[j_it][k_it] = 0.;\n    }\n    else\n    {\n      matrix[j_it][k_it] = ((4. + i_it) + j_it) + k_it;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GetsuDer/Sor3D/Source/openmp_code/4"}
{"code": "for (int i = 0; i < chromo_length; ++i)\n{\n  printf(\"\\n|%d|\\t\", i);\n  for (int j = 0; j < chromo_length; j++)\n    printf(\"(%d,%d) = %.4f\\t\", i, j, dist_matrix[i][j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/9"}
{"code": "for (linha = 1; linha < tamanhoParcial; linha++)\n{\n  for (coluna = 1; coluna < tamanhoParcial; coluna++)\n  {\n    processaCelula(linha, coluna);\n  }\n\n}\n\n", "pragma": "omp parallel for private(linha,coluna) shared(matriz) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bruno-braganca/gameOfLife_OpenMP/game_of_life/0"}
{"code": "for (i = 0; i < k; i += B)\n  for (j = k + B; j < N; j += B)\n  FW(A, k, i, j, B);\n\n\n", "pragma": "omp for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/5"}
{"code": "for (int i = 0; i < num; i++)\n{\n  int pos = rand() % 15;\n  res.append(1, arr[pos]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aleri-a/Parallel-Systems--Frequency-calculation-of-characters-/parallel_project/parallel_project/Source/3"}
{"code": "for (int i = 0; i < m_numParticles; i++)\n{\n  vels[i] = m_parts[i]->getVel2();\n  if (vels[i] > maxvel)\n    maxvel = vels[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KunstDerFuge/PartSim/Space/6"}
{"code": "for (l = nzi - 1; l < nzt; l++)\n{\n  ll = nnxhd2 * l;\n  nl = nnxhyd * l;\n  for (k = 0; k < ny; k++)\n  {\n    nk = (nnxhd2 * k) + nl;\n    for (j = 0; j < nxh; j++)\n    {\n      ioff = ((2 * ndim) * j) + ll;\n      for (i = 0; i < ndim; i++)\n      {\n        s[i + ioff] = f[(i + (ndim * (2 * j))) + nk];\n      }\n\n      ioff += ndim;\n      for (i = 0; i < ndim; i++)\n      {\n        s[i + ioff] = f[(i + (ndim * ((2 * j) + 1))) + nk];\n      }\n\n    }\n\n    for (j = 0; j < nxh; j++)\n    {\n      ioff = ((2 * ndim) * j) + ll;\n      for (i = 0; i < ndim; i++)\n      {\n        f[(i + (ndim * (2 * j))) + nk] = s[(2 * i) + ioff];\n        f[(i + (ndim * ((2 * j) + 1))) + nk] = s[((2 * i) + ioff) + 1];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k,l,ll,nl,nk,ioff)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/16"}
{"code": "for (int i = 0; i < num_subgraphs; i++)\n  subgs[i]->dealloc();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/8"}
{"code": "for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n{\n  tmp1 = dt * tx1;\n  tmp2 = dt * tx2;\n  lhs[i][j][k][0][0][0] = (((-tmp2) * fjac[i - 1][j][k][0][0]) - (tmp1 * njac[i - 1][j][k][0][0])) - (tmp1 * dx1);\n  lhs[i][j][k][0][0][1] = ((-tmp2) * fjac[i - 1][j][k][0][1]) - (tmp1 * njac[i - 1][j][k][0][1]);\n  lhs[i][j][k][0][0][2] = ((-tmp2) * fjac[i - 1][j][k][0][2]) - (tmp1 * njac[i - 1][j][k][0][2]);\n  lhs[i][j][k][0][0][3] = ((-tmp2) * fjac[i - 1][j][k][0][3]) - (tmp1 * njac[i - 1][j][k][0][3]);\n  lhs[i][j][k][0][0][4] = ((-tmp2) * fjac[i - 1][j][k][0][4]) - (tmp1 * njac[i - 1][j][k][0][4]);\n  lhs[i][j][k][0][1][0] = ((-tmp2) * fjac[i - 1][j][k][1][0]) - (tmp1 * njac[i - 1][j][k][1][0]);\n  lhs[i][j][k][0][1][1] = (((-tmp2) * fjac[i - 1][j][k][1][1]) - (tmp1 * njac[i - 1][j][k][1][1])) - (tmp1 * dx2);\n  lhs[i][j][k][0][1][2] = ((-tmp2) * fjac[i - 1][j][k][1][2]) - (tmp1 * njac[i - 1][j][k][1][2]);\n  lhs[i][j][k][0][1][3] = ((-tmp2) * fjac[i - 1][j][k][1][3]) - (tmp1 * njac[i - 1][j][k][1][3]);\n  lhs[i][j][k][0][1][4] = ((-tmp2) * fjac[i - 1][j][k][1][4]) - (tmp1 * njac[i - 1][j][k][1][4]);\n  lhs[i][j][k][0][2][0] = ((-tmp2) * fjac[i - 1][j][k][2][0]) - (tmp1 * njac[i - 1][j][k][2][0]);\n  lhs[i][j][k][0][2][1] = ((-tmp2) * fjac[i - 1][j][k][2][1]) - (tmp1 * njac[i - 1][j][k][2][1]);\n  lhs[i][j][k][0][2][2] = (((-tmp2) * fjac[i - 1][j][k][2][2]) - (tmp1 * njac[i - 1][j][k][2][2])) - (tmp1 * dx3);\n  lhs[i][j][k][0][2][3] = ((-tmp2) * fjac[i - 1][j][k][2][3]) - (tmp1 * njac[i - 1][j][k][2][3]);\n  lhs[i][j][k][0][2][4] = ((-tmp2) * fjac[i - 1][j][k][2][4]) - (tmp1 * njac[i - 1][j][k][2][4]);\n  lhs[i][j][k][0][3][0] = ((-tmp2) * fjac[i - 1][j][k][3][0]) - (tmp1 * njac[i - 1][j][k][3][0]);\n  lhs[i][j][k][0][3][1] = ((-tmp2) * fjac[i - 1][j][k][3][1]) - (tmp1 * njac[i - 1][j][k][3][1]);\n  lhs[i][j][k][0][3][2] = ((-tmp2) * fjac[i - 1][j][k][3][2]) - (tmp1 * njac[i - 1][j][k][3][2]);\n  lhs[i][j][k][0][3][3] = (((-tmp2) * fjac[i - 1][j][k][3][3]) - (tmp1 * njac[i - 1][j][k][3][3])) - (tmp1 * dx4);\n  lhs[i][j][k][0][3][4] = ((-tmp2) * fjac[i - 1][j][k][3][4]) - (tmp1 * njac[i - 1][j][k][3][4]);\n  lhs[i][j][k][0][4][0] = ((-tmp2) * fjac[i - 1][j][k][4][0]) - (tmp1 * njac[i - 1][j][k][4][0]);\n  lhs[i][j][k][0][4][1] = ((-tmp2) * fjac[i - 1][j][k][4][1]) - (tmp1 * njac[i - 1][j][k][4][1]);\n  lhs[i][j][k][0][4][2] = ((-tmp2) * fjac[i - 1][j][k][4][2]) - (tmp1 * njac[i - 1][j][k][4][2]);\n  lhs[i][j][k][0][4][3] = ((-tmp2) * fjac[i - 1][j][k][4][3]) - (tmp1 * njac[i - 1][j][k][4][3]);\n  lhs[i][j][k][0][4][4] = (((-tmp2) * fjac[i - 1][j][k][4][4]) - (tmp1 * njac[i - 1][j][k][4][4])) - (tmp1 * dx5);\n  lhs[i][j][k][1][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dx1);\n  lhs[i][j][k][1][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n  lhs[i][j][k][1][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n  lhs[i][j][k][1][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n  lhs[i][j][k][1][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n  lhs[i][j][k][1][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n  lhs[i][j][k][1][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dx2);\n  lhs[i][j][k][1][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n  lhs[i][j][k][1][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n  lhs[i][j][k][1][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n  lhs[i][j][k][1][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n  lhs[i][j][k][1][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n  lhs[i][j][k][1][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dx3);\n  lhs[i][j][k][1][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n  lhs[i][j][k][1][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n  lhs[i][j][k][1][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n  lhs[i][j][k][1][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n  lhs[i][j][k][1][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n  lhs[i][j][k][1][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dx4);\n  lhs[i][j][k][1][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n  lhs[i][j][k][1][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n  lhs[i][j][k][1][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n  lhs[i][j][k][1][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n  lhs[i][j][k][1][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n  lhs[i][j][k][1][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dx5);\n  lhs[i][j][k][2][0][0] = ((tmp2 * fjac[i + 1][j][k][0][0]) - (tmp1 * njac[i + 1][j][k][0][0])) - (tmp1 * dx1);\n  lhs[i][j][k][2][0][1] = (tmp2 * fjac[i + 1][j][k][0][1]) - (tmp1 * njac[i + 1][j][k][0][1]);\n  lhs[i][j][k][2][0][2] = (tmp2 * fjac[i + 1][j][k][0][2]) - (tmp1 * njac[i + 1][j][k][0][2]);\n  lhs[i][j][k][2][0][3] = (tmp2 * fjac[i + 1][j][k][0][3]) - (tmp1 * njac[i + 1][j][k][0][3]);\n  lhs[i][j][k][2][0][4] = (tmp2 * fjac[i + 1][j][k][0][4]) - (tmp1 * njac[i + 1][j][k][0][4]);\n  lhs[i][j][k][2][1][0] = (tmp2 * fjac[i + 1][j][k][1][0]) - (tmp1 * njac[i + 1][j][k][1][0]);\n  lhs[i][j][k][2][1][1] = ((tmp2 * fjac[i + 1][j][k][1][1]) - (tmp1 * njac[i + 1][j][k][1][1])) - (tmp1 * dx2);\n  lhs[i][j][k][2][1][2] = (tmp2 * fjac[i + 1][j][k][1][2]) - (tmp1 * njac[i + 1][j][k][1][2]);\n  lhs[i][j][k][2][1][3] = (tmp2 * fjac[i + 1][j][k][1][3]) - (tmp1 * njac[i + 1][j][k][1][3]);\n  lhs[i][j][k][2][1][4] = (tmp2 * fjac[i + 1][j][k][1][4]) - (tmp1 * njac[i + 1][j][k][1][4]);\n  lhs[i][j][k][2][2][0] = (tmp2 * fjac[i + 1][j][k][2][0]) - (tmp1 * njac[i + 1][j][k][2][0]);\n  lhs[i][j][k][2][2][1] = (tmp2 * fjac[i + 1][j][k][2][1]) - (tmp1 * njac[i + 1][j][k][2][1]);\n  lhs[i][j][k][2][2][2] = ((tmp2 * fjac[i + 1][j][k][2][2]) - (tmp1 * njac[i + 1][j][k][2][2])) - (tmp1 * dx3);\n  lhs[i][j][k][2][2][3] = (tmp2 * fjac[i + 1][j][k][2][3]) - (tmp1 * njac[i + 1][j][k][2][3]);\n  lhs[i][j][k][2][2][4] = (tmp2 * fjac[i + 1][j][k][2][4]) - (tmp1 * njac[i + 1][j][k][2][4]);\n  lhs[i][j][k][2][3][0] = (tmp2 * fjac[i + 1][j][k][3][0]) - (tmp1 * njac[i + 1][j][k][3][0]);\n  lhs[i][j][k][2][3][1] = (tmp2 * fjac[i + 1][j][k][3][1]) - (tmp1 * njac[i + 1][j][k][3][1]);\n  lhs[i][j][k][2][3][2] = (tmp2 * fjac[i + 1][j][k][3][2]) - (tmp1 * njac[i + 1][j][k][3][2]);\n  lhs[i][j][k][2][3][3] = ((tmp2 * fjac[i + 1][j][k][3][3]) - (tmp1 * njac[i + 1][j][k][3][3])) - (tmp1 * dx4);\n  lhs[i][j][k][2][3][4] = (tmp2 * fjac[i + 1][j][k][3][4]) - (tmp1 * njac[i + 1][j][k][3][4]);\n  lhs[i][j][k][2][4][0] = (tmp2 * fjac[i + 1][j][k][4][0]) - (tmp1 * njac[i + 1][j][k][4][0]);\n  lhs[i][j][k][2][4][1] = (tmp2 * fjac[i + 1][j][k][4][1]) - (tmp1 * njac[i + 1][j][k][4][1]);\n  lhs[i][j][k][2][4][2] = (tmp2 * fjac[i + 1][j][k][4][2]) - (tmp1 * njac[i + 1][j][k][4][2]);\n  lhs[i][j][k][2][4][3] = (tmp2 * fjac[i + 1][j][k][4][3]) - (tmp1 * njac[i + 1][j][k][4][3]);\n  lhs[i][j][k][2][4][4] = ((tmp2 * fjac[i + 1][j][k][4][4]) - (tmp1 * njac[i + 1][j][k][4][4])) - (tmp1 * dx5);\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,i) firstprivate (tx1,tx2,dx1,dx2,dx3,dx4,dx5,dt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/55"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  m[i] = mAr;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/8"}
{"code": "for (i = 0; i < Ndim; i++)\n{\n  tmp = x2[i] - x1[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp for private(tmp) reduction(+ : conv)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_par_for/1"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  int j;\n  for (j = 0; j < 4096; j++)\n  {\n    x1[i] = x1[i] + (a[(i * 4096) + j] * y1[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/MVT/src/mvt/3"}
{"code": "for (size_t i = 0; i < (arguments.buffer_size_kb * 128); i++)\n{\n  float_buffer[i] = float_buffer[i] * float_buffer[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-programming-hwr/benchmark-openMP/main/1"}
{"code": "for (int i = nel; i < nelr; i++)\n{\n  areas[i] = areas[last];\n  for (int j = 0; j < NNB; j++)\n  {\n    elements_surrounding_elements[(i * NNB) + j] = elements_surrounding_elements[(last * NNB) + j];\n    for (int k = 0; k < NDIM; k++)\n      normals[(((i * NNB) + j) * NDIM) + k] = normals[(((last * NNB) + j) * NDIM) + k];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/openmp/cfd/euler3d_cpu/6"}
{"code": "for (int i = 0; i < m_nSizePoint; i++)\n{\n  float *pInOne = pIn + (i * ELEMENT_COUNT_POINT);\n  float *pOutOne = pOut + (i * ELEMENT_COUNT_POINT);\n  float *pMatOne = m_pMat + (m_pIndex[i] * ELEMENT_COUNT_MATIRX);\n  pOutOne[0] = (((pMatOne[(0 * 4) + 0] * pInOne[0]) + (pMatOne[(1 * 4) + 0] * pInOne[1])) + (pMatOne[(2 * 4) + 0] * pInOne[2])) + pMatOne[(3 * 4) + 0];\n  pOutOne[1] = (((pMatOne[(0 * 4) + 1] * pInOne[0]) + (pMatOne[(1 * 4) + 1] * pInOne[1])) + (pMatOne[(2 * 4) + 1] * pInOne[2])) + pMatOne[(3 * 4) + 1];\n  pOutOne[2] = (((pMatOne[(0 * 4) + 2] * pInOne[0]) + (pMatOne[(1 * 4) + 2] * pInOne[1])) + (pMatOne[(2 * 4) + 2] * pInOne[2])) + pMatOne[(3 * 4) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultPoint3D/5"}
{"code": "for (i = 0; i < subprob_size; i++)\n{\n  rlcbuff[i] = INITIAL_GRID;\n  rfcbuff[i] = 1.0;\n  rlrbuff[i] = INITIAL_GRID;\n  rfrbuff[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/2"}
{"code": "for (i = 0; i < 2; i++)\n{\n  yc[0][i] = 0.0;\n  yc[0][2 + i] = 1.0;\n  yc[0][4 + i] = 0.0;\n  yc[0][6 + i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/7"}
{"code": "for (int n = 0; n < microenvironment.number_of_densities(); n++)\n{\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_xmin[n])\n  {\n    xmin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_xmax[n])\n  {\n    xmax = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_ymin[n])\n  {\n    ymin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_ymax[n])\n  {\n    ymax = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_zmin[n])\n  {\n    zmin = true;\n  }\n\n  if (default_microenvironment_options.Dirichlet_all[n] || default_microenvironment_options.Dirichlet_zmax[n])\n  {\n    zmax = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/21"}
{"code": "for (size_t i = 0; i < Params.Simulator.NumThreads; i++)\n{\n  Drawings.push_back(Drawing(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/FourierDraw/Source/FourierDraw/0"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_total -= a[x] + b[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_subtract/2"}
{"code": "for (int x = 1; x < (nx + 1); x++)\n{\n  for (int y = 1; y < (ny + 1); y++)\n  {\n    h[x][y] -= ((dt / dx) * (hNetUpdatesRight[x][y] + hNetUpdatesLeft[x][y])) + ((dt / dy) * (hNetUpdatesAbove[x][y] + hNetUpdatesBelow[x][y]));\n    hu[x][y] -= (dt / dx) * (huNetUpdatesRight[x][y] + huNetUpdatesLeft[x][y]);\n    hv[x][y] -= (dt / dy) * (hvNetUpdatesAbove[x][y] + hvNetUpdatesBelow[x][y]);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_DimensionalSplitting/2"}
{"code": "for (int i = 0; i < Dim; i++)\n{\n  if (Vec[i] > MaxVal)\n  {\n    MaxVal = Vec[i];\n    MaxIdx = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/100"}
{"code": "for (int j = 0; j < nt; j++)\n{\n  data[j] = q.front();\n  q.pop();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rushabhk7/Branch_and_bound/Hybrid/bnb_hybrid/2"}
{"code": "for (j = 0; j < layers[i].nOfNeurons; j++)\n{\n  for (int k = 0; k < (layers[i - 1].nOfNeurons + 1); k++)\n  {\n    if (layers[i].neurons[j].deltaW != NULL)\n    {\n      layers[i].neurons[j].deltaW[k] += copys[n][i].neurons[j].deltaW[k];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/22"}
{"code": "for (int x = -3; x <= 3; x++)\n{\n  for (int y = -3; y <= 3; y++)\n  {\n    r = sqrt((x * x) + (y * y));\n    kernel[x + 3][y + 3] = exp((-(r * r)) / s) / (M_PI * s);\n    sum += kernel[x + 3][y + 3];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/gaussianFilterOpenMP/1"}
{"code": "for (unsigned int i = 0; i < NumberOfVertices; ++i)\n{\n  VelocityModulus[i] = norm_2(rVertices[i].FastGetSolutionStepValue(VELOCITY));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/21"}
{"code": "for (j1 = 1; j1 < m1j; j1++)\n{\n  i1 = (2 * j1) - d1;\n  x1[i1] = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n  y1[i1] = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n}\n\n", "pragma": "omp parallel for firstprivate(m1j ,d2 ,d3 ,i1 ,d1 ,i2 ,i3 ,r ,j1 ,j2 ,j3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/6"}
{"code": "for (int i = 0; i < n_grid_r; i++)\n  for (int k = 0; k < n_grid_z; k++)\n  epsilon[i][k] = 1;\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/geometry/1"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_teams_distribute_parallel_for_simd); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/19"}
{"code": "for (int i = start; i < n; i += 2)\n  if (arr[i] > arr[i + 1])\n{\n  temp = arr[i];\n  arr[i] = arr[i + 1];\n  arr[i + 1] = temp;\n  ++changes;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rucha912/Sorting-in-parallel/bubblesort/0"}
{"code": "for (n = 0; n < num_vertices; n++)\n{\n  while (components[n] != components[components[n]])\n  {\n    components[n] = components[components[n]];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2048)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/1"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/55"}
{"code": "for (i = numbars; i < (numprocs * numbars); ++i)\n{\n  rbuf[i % numbars] += rbuf[i];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarimAboshamia/Frequency-Histogram/main/2"}
{"code": "for (int i = 0; i < TOTAL_DIM; i++)\n{\n  dist += fabs(feat1[i] - feat2[i]) * fabs(feat1[i] - feat2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/noritsuna/HandDetectorOpenMP/jni/HandDetector/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/6"}
{"code": "for (int j = 0, k = 0; j < Time_cell; ++j)\n{\n  for (int i = 0; i < Freq_cell; ++i)\n  {\n    HSA_raw[k++] = hsa_map[j][i];\n    if ((hsa_map[j][i] > 1000000000000.0) || (hsa_map[j][i] < (-1000000000000.0)))\n      continue;\n\n    HSA_sum += hsa_map[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/47"}
{"code": "for (int x = 0; x < MAP_SIZE; x++)\n{\n  for (int y = 0; y < MAP_SIZE; y++)\n  {\n    problemData.islandMap[x][y] = perlinNoise.accumulatedOctaveNoise2D_0_1((x * FREQUENCY_WIND) / MAP_SIZE, (y * FREQUENCY_WIND) / MAP_SIZE, OCTAVES_WAVES);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/Utility/0"}
{"code": "for (int i = 0; i < nPlanetas; i++)\n{\n  ((((((fs << fixed) << listaPlanetas[i].x) << \" \") << listaPlanetas[i].y) << \" \") << listaPlanetas[i].masa) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mariabg/openMP2018/par/nasteroids-par/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    int newPath = matrix[(i * n) + k] + rowK[j];\n    if (matrix[(i * n) + j] > newPath)\n    {\n      matrix[(i * n) + j] = newPath;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(i, j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/openmp/0"}
{"code": "for (i = 0; i <= (2000 + 1); i++)\n{\n  for (j = 0; j <= (2000 + 1); j++)\n  {\n    T[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/2D-Laplace-Offload/openmp/laplace_mp/2"}
{"code": "for (int p1 = 0; p1 < divider; p1++)\n  for (int y1 = 0; y1 < divider; y1++)\n{\n  if (y1 == dy)\n    break;\n\n  for (int x1 = 0; x1 < divider; x1++)\n  {\n    if (x1 == dx)\n      break;\n\n    sum += *(((matrixdata + ((x * divider) + x1)) + (((y * divider) + y1) * DtCol)) + ((((p * divider) + p1) * DtCol) * DtRow));\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/26"}
{"code": "for (int i = 0; i < n_grid_r; i++)\n  for (int k = 0; k < n_grid_z; k++)\n  if ((r_size - (dr * i)) <= lenght_sigma_extern)\n  if (((r_size - (dr * (i + 1))) < (((lenght_sigma_extern * dz) * k) / lenght_sigma_left)) && ((r_size - (dr * i)) <= ((lenght_sigma_extern / lenght_sigma_right) * (z_size - (dz * k)))))\n  sigma[i][k] = sigma1 + (((sigma2 - sigma1) / pow(lenght_sigma_extern, 2)) * pow(((dr * (i + 1)) - r_size) + lenght_sigma_extern, 2));\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/geometry/4"}
{"code": "for (int i = 0; i < result.height; i++)\n{\n  for (int j = 0; j < result.width; j++)\n  {\n    for (int k = 0; k < firstArg->width; k++)\n    {\n      result.data[i][j] = result.data[i][j] + (firstArg->data[i][k] * secondArg->data[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PiotrMydlowski/Matrix-Multiplication-Parallel/main/1"}
{"code": "for (int i = 0; i < size; i++)\n  suma[i] = vect1[i] + vect2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/7"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmphhsn90v5.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/projects/openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (j = 0; j < M; j++)\n{\n  r = 0.0;\n  for (k = 0; k < M; k = k + 4)\n  {\n    r = r + (A[((i + 2) * M) + k] * B[(k * M) + j]);\n    r = r + (A[(((i + 2) * M) + k) + 1] * B[((k + 1) * M) + j]);\n    r = r + (A[(((i + 2) * M) + k) + 2] * B[((k + 2) * M) + j]);\n    r = r + (A[(((i + 2) * M) + k) + 3] * B[((k + 3) * M) + j]);\n  }\n\n  C[((i + 2) * M) + j] = (alpha * r) + (beta * C[((i + 2) * M) + j]);\n}\n\n", "pragma": "omp parallel for reduction(+:r) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemm/7"}
{"code": "for (int j = 0; j < 60000; j++)\n{\n  activateNN(INPUT[j]);\n  category = classDecision(OL2);\n  desiredCategory = desiredDecision(j, train_flag);\n  categoryTruth = decisionTruth(category, desiredCategory);\n  if (categoryTruth)\n  {\n    trueDecisioncounter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex4/ex4/2"}
{"code": "for (i2 = 1; i2 < (n2 - 1); i2++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    u1[(((i3 * n2) * n1) + (i2 * n1)) + i1] = ((ou[(((i3 * n2) * n1) + ((i2 - 1) * n1)) + i1] + ou[(((i3 * n2) * n1) + ((i2 + 1) * n1)) + i1]) + ou[((((i3 - 1) * n2) * n1) + (i2 * n1)) + i1]) + ou[((((i3 + 1) * n2) * n1) + (i2 * n1)) + i1];\n    u2[(((i3 * n2) * n1) + (i2 * n1)) + i1] = ((ou[((((i3 - 1) * n2) * n1) + ((i2 - 1) * n1)) + i1] + ou[((((i3 - 1) * n2) * n1) + ((i2 + 1) * n1)) + i1]) + ou[((((i3 + 1) * n2) * n1) + ((i2 - 1) * n1)) + i1]) + ou[((((i3 + 1) * n2) * n1) + ((i2 + 1) * n1)) + i1];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i2,i1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < p; k++)\n    {\n      result[i][j] += first[i][k] * second[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/5"}
{"code": "for (int i = 0; i < chunk; i++)\n{\n  dynarr_2[i] = receivebuf[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/billmats96/Parallel-and-Distributed-Systems/Project 2/src/mpi_threaded_blocking/5"}
{"code": "for (int c = 0; c < kn.cols; c++)\n{\n  for (int r = 0; r < kn.rows; r++)\n  {\n    kn_data[(r * kn.cols) + c] = (float) gaussian2D((float) (c - (kn.cols / 2)), (float) (r - (kn.rows / 2)), sigma);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kka-na/parallel_image_processing/hw7/src/myOpenMP/0"}
{"code": "for (int j = 1; j <= (numBins - 2); j++)\n{\n  bins_apply_force(bins[currRowIndex + j], bins[(upRowIndex + j) - 1], &dmin, &davg, &navg);\n  bins_apply_force(bins[currRowIndex + j], bins[upRowIndex + j], &dmin, &davg, &navg);\n  bins_apply_force(bins[currRowIndex + j], bins[(upRowIndex + j) + 1], &dmin, &davg, &navg);\n  bins_apply_force(bins[currRowIndex + j], bins[(currRowIndex + j) - 1], &dmin, &davg, &navg);\n  self_bins_apply_force(bins[currRowIndex + j], &dmin, &davg, &navg);\n  bins_apply_force(bins[currRowIndex + j], bins[(currRowIndex + j) + 1], &dmin, &davg, &navg);\n}\n\n", "pragma": "#pragma omp for reduction (+:navg) reduction(+:davg) schedule(guided) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosjgm/High-Performance-Computing/N-body-simulation/OpenMP/5"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 10000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      A[(i * 10000) + j] = 0;\n    }\n    else\n    {\n      A[(i * 10000) + j] = (((float) i) * j) / 10000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanafacion/Paralelas/Exercicio12/code-t12/2"}
{"code": "for (i = 0; i < data_count; i++)\n{\n  bin = Which_bin(data[i], bin_maxes, bin_count, min_meas);\n  bin_counts[bin]++;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brenda151295/OpenMP/ejercicio1/0"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  gettimeofday(&T1, 0);\n  fill_array(m1, N, 0, 12);\n  fill_array(m2, N / 2, 12, 10 * 12);\n  map(m1, N, m2, N / 2);\n  merge(m1, m2, N / 2);\n  insert_sort(m2, N / 2);\n  x = reduce(m2, N / 2);\n  gettimeofday(&T2, 0);\n  time_ms = (1000 * (T2.tv_sec - T1.tv_sec)) + ((T2.tv_usec - T1.tv_usec) / 1000);\n  if ((minimal_time_ms == (-1)) || (time_ms < minimal_time_ms))\n    minimal_time_ms = time_ms;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leleyi/Parallel_Computing/lab3/lab3/3"}
{"code": "for (int i = 0; i < list_size; ++i)\n{\n  input_list[i] = next_prime(input_list[i]);\n}\n\n", "pragma": "omp parallel for shared(list_size, input_list)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/labs/Lab6/Software/OpenMP/next_prime/0"}
{"code": "for (int depth = 1;; depth++)\n{\n  T->depth = depth;\n  T->height = 0;\n  T->alpha_start = (T->alpha = (-MAX_SCORE) - 1);\n  T->beta = MAX_SCORE + 1;\n  printf(\"=====================================\\n\");\n  evaluate(T, result);\n  printf(\"depth: %d / score: %.2f / best_move : \", T->depth, 0.01 * result->score);\n  print_pv(T, result);\n  if (DEFINITIVE(result->score))\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adahn/Project_Parallelism/version2/MPI/main/2"}
{"code": "for (int d = 0; d < numDevice; d++)\n{\n  cudaSetDevice(d);\n  cudaDeviceSynchronize();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_mulgpu/1"}
{"code": "for (i = 0; i < 70; i++)\n{\n  for (j = 0; j < 10; j++)\n    for (k = 0; k < 20; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunkSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mkdesilva/parallel-matrix-multiplication/parallel/3"}
{"code": "for (i = 0; i < ny; i++)\n{\n  unew[((nx - 1) * npadded) + i] = f[((nx - 1) * npadded) + i];\n}\n\n", "pragma": "omp for simd aligned(unew:ALIGNMENT, f:ALIGNMENT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/POISSON/poisson_openmp/5"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  (HostVector < ValueType) > sol(this->local_backend_);\n  (HostVector < ValueType) > rhs(this->local_backend_);\n  sol.Allocate(this->nrow_);\n  rhs.Allocate(this->nrow_);\n  rhs.vec_[i] = (static_cast < ValueType) > 1;\n  this->QRSolve(rhs, &sol);\n  for (int j = 0; j < this->ncol_; ++j)\n  {\n    val[DENSE_IND(j, i, this->nrow_, this->ncol_)] = sol.vec_[j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/5"}
{"code": "for (int codeIndex = 0; codeIndex < data->count; codeIndex++)\n{\n  filePath = buf[omp_get_thread_num()];\n  snprintf(filePath, 256 - 1, \"%s/%d.xmap\", companyDir, data->codes[codeIndex]);\n  xmap = xmap_load(filePath);\n  if (xmap == 0)\n  {\n    continue;\n  }\n\n  snprintf(key, (sizeof(key)) - 1, \"unit\");\n  value = xmap_get(xmap, key);\n  sscanf(value, \"%d\", &intValue);\n  data->companys[codeIndex].unit = intValue;\n  snprintf(key, (sizeof(key)) - 1, \"shijou\");\n  value = xmap_get(xmap, key);\n  if (value == 0)\n  {\n    data->companys[codeIndex].shijou = 0;\n  }\n  else\n    if (strcmp(value, \"\u5e02\u5834\u7b2c\u4e00\u90e8\uff08\u5185\u56fd\u682a\uff09\") == 0)\n  {\n    data->companys[codeIndex].shijou = 1;\n  }\n  else\n    if (strcmp(value, \"\u5e02\u5834\u7b2c\u4e8c\u90e8\uff08\u5185\u56fd\u682a\uff09\") == 0)\n  {\n    data->companys[codeIndex].shijou = 2;\n  }\n  else\n  {\n    data->companys[codeIndex].shijou = 3;\n  }\n\n\n\n  snprintf(key, (sizeof(key)) - 1, \"taishaku\");\n  value = xmap_get(xmap, key);\n  if ((value == 0) || (strcmp(value, \"\u8cb8\u501f\u9298\u67c4\") != 0))\n  {\n    data->companys[codeIndex].shijou = 0;\n  }\n  else\n  {\n    data->companys[codeIndex].isKarauriOk = 1;\n  }\n\n  xmap_release(xmap);\n}\n\n", "pragma": "omp parallel for private(filePath,xmap,key,value,intValue)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pgostation/pstock/pstock/strMdata/1"}
{"code": "for (ii = 0; ii < 10; ii++)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for firstprivate(ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/39"}
{"code": "for (j = 0; j < nodes[i].n; j++)\n{\n  n = nodes[i].neighbor[j];\n  CC_seq(n, cc);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/concom/src/concom_ompi/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  struct particle dv = {.x = (f[i].x / m[i]) * dt, .y = (f[i].y / m[i]) * dt, .z = (f[i].z / m[i]) * dt};\n  struct particle dp = {.x = (v[i].x + (dv.x / 2)) * dt, .y = (v[i].y + (dv.y / 2)) * dt, .z = (v[i].z + (dv.z / 2)) * dt};\n  v[i].x += dv.x;\n  v[i].y += dv.y;\n  v[i].z += dv.z;\n  p[i].x += dp.x;\n  p[i].y += dp.y;\n  p[i].z += dp.z;\n  f[i].x = (f[i].y = (f[i].z = 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NievinEvgeny/N-body/parallel-v1/main/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  matrix[i] = (double *) malloc((sizeof(double)) * cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenMPToolsInterface/ompt-test-suite/test/matmult/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    P[i][j] = fabs(B[i][j]) / row_sum[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/1"}
{"code": "for (int x = 1; x <= len; x++)\n{\n  column[0] = x;\n  lastdiag = x - 1;\n  for (int y = 1; y <= len; y++)\n  {\n    olddiag = column[y];\n    column[y] = ((column[y] + 1) < (column[y - 1] + 1)) ? (((column[y] + 1) < (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) ? (column[y] + 1) : (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) : (((column[y - 1] + 1) < (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1)))) ? (column[y - 1] + 1) : (lastdiag + ((s1[y - 1] == s2[x - 1]) ? (0) : (1))));\n    lastdiag = olddiag;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmOMP/1"}
{"code": "for (indice = tamanioMatriz * 2; indice < (tamanioFinal - (2 * tamanioMatriz)); indice++)\n{\n  arbolesContagiando = 0;\n  vecinosVisitados = 0;\n  if (matrizCampo[indice - 1].fila == matrizCampo[indice].fila)\n  {\n    if (matrizCampo[indice - 1].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice - 1].fila >= 0)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if (matrizCampo[indice - 2].fila == matrizCampo[indice].fila)\n  {\n    if (matrizCampo[indice - 2].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice - 2].fila >= 0)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if (matrizCampo[indice + 1].fila == matrizCampo[indice].fila)\n  {\n    if (matrizCampo[indice + 1].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + 1].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if (matrizCampo[indice + 2].fila == matrizCampo[indice].fila)\n  {\n    if (matrizCampo[indice + 2].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + 2].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - tamanioMatriz].fila)\n  {\n    if (matrizCampo[indice - tamanioMatriz].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice - tamanioMatriz].fila >= 0)\n    {\n      vecinosVisitados += 1;\n      ;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - (tamanioMatriz - 1)].fila)\n  {\n    if (matrizCampo[indice - (tamanioMatriz - 1)].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice - (tamanioMatriz - 1)].fila >= 0)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila - 1) == matrizCampo[indice - (tamanioMatriz + 1)].fila)\n  {\n    if (matrizCampo[(indice - tamanioMatriz) + 1].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[(indice - tamanioMatriz) + 1].fila >= 0)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila - 2) == matrizCampo[indice - (2 * tamanioMatriz)].fila)\n  {\n    if (matrizCampo[indice - (2 * tamanioMatriz)].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice - (2 * tamanioMatriz)].fila >= 0)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + tamanioMatriz].fila)\n  {\n    if (matrizCampo[indice + tamanioMatriz].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + tamanioMatriz].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + (tamanioMatriz - 1)].fila)\n  {\n    if (matrizCampo[indice + (tamanioMatriz - 1)].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + (tamanioMatriz - 1)].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila + 1) == matrizCampo[indice + (tamanioMatriz + 1)].fila)\n  {\n    if (matrizCampo[indice + (tamanioMatriz + 1)].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + (tamanioMatriz + 1)].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if ((matrizCampo[indice].fila + 2) == matrizCampo[indice + (2 * tamanioMatriz)].fila)\n  {\n    if (matrizCampo[indice + (2 * tamanioMatriz)].color == 3)\n    {\n      arbolesContagiando += 1;\n    }\n\n    if (matrizCampo[indice + (2 * tamanioMatriz)].fila < tamanioMatriz)\n    {\n      vecinosVisitados += 1;\n    }\n\n  }\n\n  if (matrizCampo[indice].edad < 157)\n  {\n    if (matrizCampo[indice].heridas == 1)\n    {\n      susceptibilidad = 0.35 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.35;\n    }\n\n  }\n\n  if ((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821))\n  {\n    if (matrizCampo[indice].heridas == 1)\n    {\n      susceptibilidad = 0.17 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.17;\n    }\n\n  }\n\n  if (matrizCampo[indice].edad >= 1821)\n  {\n    if (matrizCampo[indice].heridas == 1)\n    {\n      susceptibilidad = 0.63 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.63;\n    }\n\n  }\n\n  matrizAux[indice].edad += 1;\n  if (matrizCampo[indice].color == 4)\n  {\n    matrizAux[indice].semanasInfectado += 1;\n    matrizAux[indice].semanasTotales++;\n  }\n\n  if (matrizCampo[indice].semanasInfectado == 3)\n  {\n    matrizAux[indice].color = 3;\n  }\n\n  if (matrizCampo[indice].color == 3)\n  {\n    matrizAux[indice].semanasTotales++;\n    if ((rand() % 100) <= 85)\n    {\n      matrizAux[indice].color = 2;\n      matrizAux[indice].semanasInfectado = 0;\n      matrizAux[indice].semanasTotales += 1;\n    }\n\n  }\n\n  if (matrizCampo[indice].color == 2)\n  {\n    if (matrizCampo[indice].semanasTotales <= 8)\n    {\n      matrizAux[indice].semanasTotales++;\n    }\n    else\n    {\n      if (matrizCampo[indice].edad < 157)\n      {\n        if ((rand() % 100) > 3)\n        {\n          matrizAux[indice].color = 5;\n          matrizAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizAux[indice].color = 1;\n          matrizAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if ((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821))\n      {\n        if ((rand() % 100) > 15)\n        {\n          matrizAux[indice].color = 5;\n          matrizAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizAux[indice].color = 1;\n          matrizAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if (matrizCampo[indice].edad >= 1821)\n      {\n        if ((rand() % 100) > 53)\n        {\n          matrizAux[indice].color = 5;\n          matrizAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizAux[indice].color = 5;\n          matrizAux[indice].semanasTotales = 0;\n          matrizAux[indice].edad = 57;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (matrizCampo[indice].color == 1)\n  {\n    if (matrizCampo[indice].semanasPodado <= 12)\n    {\n      matrizAux[indice].semanasPodado++;\n    }\n    else\n    {\n      matrizAux[indice].color = 5;\n      matrizAux[indice].semanasPodado = 0;\n    }\n\n  }\n\n  if (matrizCampo[indice].color == 5)\n  {\n    porcentajeEnfermos = arbolesContagiando / vecinosVisitados;\n    probabilidadContagio = ((porcentajeEnfermos + susceptibilidad) * 0.60) + 0.07;\n    if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n    {\n      matrizAux[indice].color = 4;\n    }\n\n  }\n\n  if (semana > 0)\n  {\n    probHeridas = rand() % 101;\n    if ((matrizCampo[indice].edad < 157) && (probHeridas < 23))\n    {\n      matrizAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizAux[indice].heridas = 0;\n    }\n\n    if (((matrizCampo[indice].edad >= 157) && (matrizCampo[indice].edad < 1821)) && (probHeridas < 8))\n    {\n      matrizAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizAux[indice].heridas = 0;\n    }\n\n    if ((matrizCampo[indice].edad >= 1821) && (probHeridas < 37))\n    {\n      matrizAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizAux[indice].heridas = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(indice, susceptibilidad, porcentajeEnfermos, probabilidadContagio, probHeridas, arbolesContagiando, vecinosVisitados) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalOPM1500/2"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    ex[(i * 2048) + j] = ((((DATA_TYPE) i) * (j + 1)) + 1) / 2048;\n    ey[(i * 2048) + j] = ((((DATA_TYPE) (i - 1)) * (j + 2)) + 2) / 2048;\n    hz[(i * 2048) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / 2048;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/FDTD-2D/src/fdtd2d/4"}
{"code": "for (int j = 0; j < mode; ++j)\n{\n  if (EMD_success[j])\n    printf(\"O\");\n  else\n    printf(\"X\");\n\n  if (EMD_success[j])\n  {\n    FindExtrema(result[j], data_len, UpExtrema, UpLength, LowExtrema, LowLength);\n    Spline(result[j], UpEnvelope[j], data_len, UpExtrema, UpLength, 1);\n    Spline(result[j], LowEnvelope[j], data_len, LowExtrema, LowLength, 1);\n    for (int i = 0; i < data_len; ++i)\n    {\n      MeanEnvelope[j][i] = (UpEnvelope[j][i] + LowEnvelope[j][i]) / 2.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/42"}
{"code": "for (cj = 0; cj < NCELLS; cj++)\n{\n  if (cj != ci)\n  {\n    if (contacts(ci, cj) > 0)\n      nc++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/36"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < a[i].size(); j++)\n  {\n    a[i][j].push_back(rand() % 10);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnomDevgun/ParallelComputing/openMP/cp/0"}
{"code": "for (i = 0; i < n; i++)\n  local_res += a[i] * b[i];\n\n", "pragma": "        #pragma omp for schedule(guided, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/vec_dot/1"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (j = grid_points[1] - 3; j >= 0; j--)\n  {\n    j1 = j + 1;\n    j2 = j1 + 1;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/33"}
{"code": "for (int i = 0; i < 7; ++i)\n{\n  int k = 3;\n  for (int j = 0; j < 7; ++j)\n    ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/clang/test/OpenMP/tile_messages/1"}
{"code": "for (int x = 0; x <= limit; x++)\n{\n  tree[x].left = &tree[(2 * x) + 1];\n  tree[x].right = &tree[(2 * x) + 2];\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(hilos)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daferodriguez/DFS/MPI/dfs/0"}
{"code": "for (i = 0; i < partsize; ++i)\n  ly[i] += a * lx[i];\n\n", "pragma": "omp parallel for shared(lx, ly, partsize, a) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/axpy/bkp/axpy_ompacc/0"}
{"code": "for (c1 = 0; c1 <= ((((nj + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(nj + (-1))) + 16) + 1) / 16)) : (-((((-(nj + (-1))) + 16) - 1) / 16))) : ((nj + (-1)) / 16)); c1++)\n{\n  for (c2 = 0; c2 <= ((((nl + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(nl + (-1))) + 16) + 1) / 16)) : (-((((-(nl + (-1))) + 16) - 1) / 16))) : ((nl + (-1)) / 16)); c2++)\n  {\n    for (c7 = 16 * c2; c7 <= ((((16 * c2) + 15) < (nl + (-1))) ? ((16 * c2) + 15) : (nl + (-1))); c7++)\n    {\n      for (c10 = 16 * c1; c10 <= ((((16 * c1) + 15) < (nj + (-1))) ? ((16 * c1) + 15) : (nj + (-1))); c10++)\n      {\n        F[c10][c7] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c7, c2, c10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-tile-no/9"}
{"code": "for (size_t i = 0u; i < n_centroids; ++i)\n{\n  centroids[i] = pixels[rand() % n_pixels];\n  struct pixel tmp = {0.0, 0.0, 0.0};\n  sums[i] = tmp;\n  counts[i] = 0u;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/2"}
{"code": "for (int i = 0; i < MX_SIZE; i++)\n{\n  for (int seg = 0; seg < (MX_SIZE / 32); seg++)\n  {\n    tbB = 0;\n    for (int j = 0; j < 32; j++)\n    {\n      sign = (int) (pB[(seg * 32) + j][i] >= 0);\n      tbB = tbB | (sign << j);\n    }\n\n    bB[i][seg] = tbB;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCMMAbench/1"}
{"code": "for (int i = 0; i < (thnum + 1); i++)\n{\n  offset += temp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/prefixsum/2"}
{"code": "for (n = 0; n < 4; n++)\n{\n  printf(\"thread %d:i=%d\\n\", omp_get_thread_num(), i);\n  i = 100 + omp_get_thread_num();\n}\n\n", "pragma": "omp for lastprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jadhavganesh/OpenMp_File/private/last_private/0"}
{"code": "for (k = level->boxes_in.k - 1; k >= 0; k--)\n{\n  for (j = level->boxes_in.j - 1; j >= 0; j--)\n  {\n    for (i = 0; i < j; i++)\n      printf(\" \");\n\n    for (i = 0; i < level->boxes_in.i; i++)\n    {\n      int b = (i + (j * jStride)) + (k * kStride);\n      printf(\"%4d \", level->rank_of_box[b]);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = g[0];\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for is_device_ptr(g)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_codegen/1"}
{"code": "for (ii = 0; ii < params.ny; ii++)\n{\n  for (jj = 0; jj < params.nx; jj++)\n  {\n    offset = (ii * params.nx) + jj;\n    if (obstacles[offset])\n    {\n      u_x = (u_y = 0.0);\n      pressure = params.density * c_sq;\n    }\n    else\n    {\n      speeds = cells[offset].speeds;\n      local_density = (((((((speeds[0] + speeds[1]) + speeds[2]) + speeds[3]) + speeds[4]) + speeds[5]) + speeds[6]) + speeds[7]) + speeds[8];\n      u_x = (((speeds[1] + speeds[5]) + speeds[8]) - ((speeds[3] + speeds[6]) + speeds[7])) / local_density;\n      u_y = (((speeds[2] + speeds[5]) + speeds[6]) - ((speeds[4] + speeds[7]) + speeds[8])) / local_density;\n      pressure = local_density * c_sq;\n    }\n\n    fprintf(fp, \"%d %d %.12E %.12E %.12E %d\\n\", ii, jj, u_x, u_y, pressure, obstacles[offset]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doraemoncito/boltzmann/boltzmann-openmp/d2q9-bgk/4"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    a[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/multiply/2"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    free(layer_outputs[s][l]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU1/5"}
{"code": "for (j = 0; j < 4; j++)\n  for (i = ji; i < ki; i++)\n  for (k = ki + 10; k < (ji - 10); k += 2)\n  l++;\n\n\n\n", "pragma": "omp parallel for reduction(+: l) collapse(3)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/3"}
{"code": "for (i = 0; i < end; i++)\n{\n  B[i] = A[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  array_of_blocklengths[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeorgeMitrakis/raw_image_blur/project_hybrid/4"}
{"code": "for (ik = 0; ik < nn; ik++)\n{\n  i = ik / n;\n  k = ik % n;\n  if (k <= i)\n  {\n    i = (n - i) - 2;\n    k = (n - k) - 1;\n  }\n\n  mi = m[i];\n  mk = m[k];\n  si = s[i];\n  sk = s[k];\n  sum = 0;\n  for (o = 0; o < l; o++)\n    sum += (((d[(i * l) + o] - mi) * (d[(k * l) + o] - mk)) / si) / sk;\n\n  c[(((nn - (((n - i) * ((n - i) - 1)) / 2)) + k) - i) - 1] = sum / (l - 1);\n}\n\n", "pragma": "omp parallel for private(ik, i, k, mi, si, mk, sk, o)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UP-RS-ESP/CorrCoef/CorrCoef/1"}
{"code": "for (i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction (+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deborasetton/cpar-openmp-mpi-examples/openmp/pi_omp_v3_reduction/0"}
{"code": "for (int i = 0; i < niters; ++i)\n  S.solve(x1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/17"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      exact_solution(xi, eta, zeta, u_exact);\n      for (m = 0; m < 5; m++)\n      {\n        add = u[i][j][k][m] - u_exact[m];\n        rms[m] = rms[m] + (add * add);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/52"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  printf(\"[%d] \", pos->_Cases[0][16 * i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif_padding/4"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    down_v2_kernel_pre(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[1 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[19].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/down_v2_kernel_pre_kernel/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < count[i]; j++)\n  {\n    final[j + cnt] = bucket[i][j];\n  }\n\n  cnt = cnt + count[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HardiChandra/Parallel-Programming-Projects/Project4 Bucket Sort/Project4-BucketSort/Project4-BucketSortCombine/Project4-BucketSortCombine/1"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < rows; j++)\n  {\n    mu[i][j] = data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = _const;\n}\n\n", "pragma": "omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/utils/1"}
{"code": "for (i = 1; i < n; i++)\n  for (j = 0; j < m; j++)\n  b[i][j] = b[i][j - 1];\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/outofbounds-orig-yes/0"}
{"code": "for (i = 0; i < sizeX; ++i)\n{\n  double tmp = 0;\n  for (j = 0; j < sizeY; ++j)\n  {\n    tmp += (a[i][j] * b[i]) + a[i][j];\n  }\n\n  sum += tmp / (k + 1);\n}\n\n", "pragma": "#pragma omp parallel for private(i, j) reduction (+:sum) schedule(guided) num_threads(inner_threads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marufdsi/OpenMP_Nested_Parallelism/TestNested/2"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    C[(i * 512) + j] = 0.0;\n    for (k = 0; k < 512; ++k)\n    {\n      C[(i * 512) + j] += A[(i * 512) + k] * B[(k * 512) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/15"}
{"code": "for (i = idx; i < n; i += num)\n  c[i] = a[i] + b[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/vec_add/1"}
{"code": "for (int k = 0; k < num_threads; k++)\n{\n  prime.insert(prime.end(), p_n[k].start(), p_n[k].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/prime/prime0/prime/0"}
{"code": "for (int v = 0; v < n; v++)\n{\n  if (graph[u][v] == 1)\n  {\n    if (next == 0)\n    {\n      next = createQueue();\n    }\n\n    if (parent[v] == (-1))\n    {\n      enqueue(next, v);\n      parent[v] = u;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/3"}
{"code": "for (int64_t i = 1; i < arrsize; ++i)\n{\n  x1[i] = (a[i] * x1[i - 1]) + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/romansamgin/OpenMP-test/main/1"}
{"code": "for (i = 0; i < 16384; i++)\n{\n  q[i] = 0.0;\n  for (j = 0; j < 16384; j++)\n  {\n    q[i] = q[i] + (A[(i * 16384) + j] * p[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/BICG/bicg/1"}
{"code": "for (int j = 0; j < nov; j++)\n{\n  (((cout << j) << \" \") << arr[j]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/0"}
{"code": "for (i = 0; i < ng; i++)\n  for (j = 0; j < ng; j++)\n  for (k = 0; k < ng; k++)\n{\n  kx = k_base * (i - (ng / 2));\n  ky = k_base * (j - (ng / 2));\n  kz = k_base * (k - (ng / 2));\n  pfft(p_theta, i, j, k)->Re = ((kx * pfft(p_vel_x, i, j, k)->Im) + (ky * pfft(p_vel_y, i, j, k)->Im)) + (kz * pfft(p_vel_z, i, j, k)->Im);\n  pfft(p_theta, i, j, k)->Im = (-1.0) * (((kx * pfft(p_vel_x, i, j, k)->Re) + (ky * pfft(p_vel_y, i, j, k)->Re)) + (kz * pfft(p_vel_z, i, j, k)->Re));\n  pfft(p_theta, i, j, k)->Re = (pfft(p_theta, i, j, k)->Re / normal_hubble_param) / f;\n  pfft(p_theta, i, j, k)->Im = (pfft(p_theta, i, j, k)->Im / normal_hubble_param) / f;\n}\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/window_function/0"}
{"code": "for (int j = 0; j < count1; j++)\n{\n  dxc = xx1[j] - xxi;\n  dyc = yy1[j] - yyi;\n  dzc = zz1[j] - zzi;\n  r2 = ((dxc * dxc) + (dyc * dyc)) + (dzc * dzc);\n  if (r2 < fsrrmax2)\n    m = mass1[j];\n  else\n    m = 0.f;\n\n  f = r2 + mp_rsm2;\n  f = m * ((1.f / (f * sqrtf(f))) - (ma0 + (r2 * (ma1 + (r2 * (ma2 + (r2 * (ma3 + (r2 * (ma4 + (r2 * ma5)))))))))));\n  xi = xi + (f * dxc);\n  yi = yi + (f * dyc);\n  zi = zi + (f * dzc);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/haccmk-omp/haccmk/1"}
{"code": "for (i = 0; i < (m - 1); i++)\n{\n  if (ten[i][ind] > ten[i + 1][ind])\n  {\n    temp = ten[i + 1][ind];\n    ten[i + 1][ind] = ten[i][ind];\n    ten[i][ind] = temp;\n    j_temp = j1[i + 1][ind];\n    j1[i + 1][ind] = j1[i][ind];\n    j1[i][ind] = j_temp;\n    j_temp = j2[i + 1][ind];\n    j2[i + 1][ind] = j2[i][ind];\n    j2[i][ind] = j_temp;\n    j_temp = j3[i + 1][ind];\n    j3[i + 1][ind] = j3[i][ind];\n    j3[i][ind] = j_temp;\n  }\n  else\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/28"}
{"code": "for (int i = 0; i < untill; i++)\n{\n  int work_for = (level * (i + 1)) - 1;\n  int get = work_for - (level / 2);\n  int temp = input[work_for];\n  input[work_for] += input[get];\n  input[get] = temp;\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/prefix_final/1"}
{"code": "for (int i = 0; i < byteLength; ++i)\n{\n  if (keyspace >= (0x7fffffff / valsPerByte))\n  {\n    return -1;\n  }\n\n  keyspace *= valsPerByte;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/md5hash-omp/MD5Hash/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm_set1_epi32(noff);\n  v_moff = _mm_set1_epi32(moff);\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&fxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sfxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&bxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sbxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  nps = 4 * (npp / 4);\n  sum1 = 0.0;\n  v_sum1 = _mm_set1_pd(0.0);\n  for (j = 0; j < nps; j += 4)\n  {\n    v_x = _mm_load_ps(&ppart[j + npoff]);\n    v_y = _mm_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_nn = _mm_cvttps_epi32(v_x);\n    v_mm = _mm_cvttps_epi32(v_y);\n    v_dxp = _mm_sub_ps(v_x, _mm_cvtepi32_ps(v_nn));\n    v_dyp = _mm_sub_ps(v_y, _mm_cvtepi32_ps(v_mm));\n    v_nn = _mm_sub_epi32(v_nn, v_noff);\n    v_mm = _mm_sub_epi32(v_mm, v_moff);\n    v_it = _mm_mul_epu32(v_mxv, _mm_srli_si128(v_mm, 4));\n    v_mm = _mm_mul_epu32(v_mm, v_mxv);\n    v_mm = _mm_add_epi32(v_mm, _mm_slli_si128(v_it, 4));\n    v_nn = _mm_slli_epi32(_mm_add_epi32(v_nn, v_mm), 2);\n    v_amx = _mm_sub_ps(v_one, v_dxp);\n    v_amy = _mm_sub_ps(v_one, v_dyp);\n    _mm_store_si128((int *) ll, v_nn);\n    nn = ll[0];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 0);\n    a = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    e = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 0);\n    nn += 4;\n    a = _mm_add_ps(a, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    e = _mm_add_ps(e, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 0);\n    a = _mm_mul_ps(a, v_at);\n    e = _mm_mul_ps(e, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 0);\n    a = _mm_add_ps(a, _mm_mul_ps(v_dx, v_at));\n    e = _mm_add_ps(e, _mm_mul_ps(v_dy, v_at));\n    nn = ll[1];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 85);\n    b = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    f = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 85);\n    nn += 4;\n    b = _mm_add_ps(b, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    f = _mm_add_ps(f, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 85);\n    b = _mm_mul_ps(b, v_at);\n    f = _mm_mul_ps(f, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 85);\n    b = _mm_add_ps(b, _mm_mul_ps(v_dx, v_at));\n    f = _mm_add_ps(f, _mm_mul_ps(v_dy, v_at));\n    nn = ll[2];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 170);\n    c = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    g = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 170);\n    nn += 4;\n    c = _mm_add_ps(c, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    g = _mm_add_ps(g, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 170);\n    c = _mm_mul_ps(c, v_at);\n    g = _mm_mul_ps(g, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 170);\n    c = _mm_add_ps(c, _mm_mul_ps(v_dx, v_at));\n    g = _mm_add_ps(g, _mm_mul_ps(v_dy, v_at));\n    nn = ll[3];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 255);\n    d = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    h = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 255);\n    nn += 4;\n    d = _mm_add_ps(d, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    h = _mm_add_ps(h, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 255);\n    d = _mm_mul_ps(d, v_at);\n    h = _mm_mul_ps(h, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 255);\n    d = _mm_add_ps(d, _mm_mul_ps(v_dx, v_at));\n    h = _mm_add_ps(h, _mm_mul_ps(v_dy, v_at));\n    _MM_TRANSPOSE4_PS(a, b, c, d);\n    _MM_TRANSPOSE4_PS(e, f, g, h);\n    v_dx = _mm_mul_ps(a, v_qtmh);\n    v_dy = _mm_mul_ps(b, v_qtmh);\n    v_dz = _mm_mul_ps(c, v_qtmh);\n    a = _mm_add_ps(v_dx, _mm_load_ps(&ppart[(j + (2 * nppmx)) + npoff]));\n    b = _mm_add_ps(v_dy, _mm_load_ps(&ppart[(j + (3 * nppmx)) + npoff]));\n    c = _mm_add_ps(v_dz, _mm_load_ps(&ppart[(j + (4 * nppmx)) + npoff]));\n    v_at = _mm_add_ps(_mm_mul_ps(a, a), _mm_mul_ps(b, b));\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(c, c));\n    v_gami = _mm_sqrt_ps(_mm_add_ps(v_one, _mm_mul_ps(v_at, v_ci2)));\n    v_gami = _mm_div_ps(v_one, v_gami);\n    v_at = _mm_mul_ps(v_gami, v_at);\n    v_at = _mm_div_ps(v_at, _mm_add_ps(v_one, v_gami));\n    v_d = _mm_cvtps_pd(v_at);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    v_it = _mm_srli_si128((int) v_at, 8);\n    v_d = _mm_cvtps_pd((int) v_it);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    v_at = _mm_mul_ps(v_qtmh, v_gami);\n    e = _mm_mul_ps(v_at, e);\n    f = _mm_mul_ps(v_at, f);\n    g = _mm_mul_ps(v_at, g);\n    v_vx = _mm_mul_ps(e, e);\n    v_vy = _mm_mul_ps(f, f);\n    v_vz = _mm_mul_ps(g, g);\n    v_at = _mm_add_ps(_mm_add_ps(v_vx, v_vy), v_vz);\n    d = _mm_div_ps(v_two, _mm_add_ps(v_one, v_at));\n    h = _mm_mul_ps(v_half, _mm_sub_ps(v_one, v_at));\n    v_vx = _mm_mul_ps(_mm_add_ps(h, v_vx), a);\n    v_vy = _mm_mul_ps(_mm_add_ps(h, v_vy), b);\n    v_vz = _mm_mul_ps(_mm_add_ps(h, v_vz), c);\n    h = _mm_mul_ps(e, f);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_add_ps(h, g), b));\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_sub_ps(h, g), a));\n    h = _mm_mul_ps(e, g);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_sub_ps(h, f), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_add_ps(h, f), a));\n    h = _mm_mul_ps(f, g);\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_add_ps(h, e), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_sub_ps(h, e), b));\n    v_vx = _mm_add_ps(v_dx, _mm_mul_ps(v_vx, d));\n    v_vy = _mm_add_ps(v_dy, _mm_mul_ps(v_vy, d));\n    v_vz = _mm_add_ps(v_dz, _mm_mul_ps(v_vz, d));\n    v_at = _mm_mul_ps(v_vx, v_vx);\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(v_vy, v_vy));\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(v_vz, v_vz));\n    v_at = _mm_sqrt_ps(_mm_add_ps(v_one, _mm_mul_ps(v_at, v_ci2)));\n    v_at = _mm_div_ps(v_dtc, v_at);\n    v_dx = _mm_add_ps(v_x, _mm_mul_ps(v_vx, v_at));\n    v_dy = _mm_add_ps(v_y, _mm_mul_ps(v_vy, v_at));\n    if (ipbc == 2)\n    {\n      v_at = _mm_cmplt_ps(v_dx, v_edgelx);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dx, v_edgerx));\n      v_x = _mm_and_ps(v_at, v_x);\n      v_dx = _mm_add_ps(_mm_andnot_ps(v_at, v_dx), v_x);\n      v_dxp = _mm_and_ps(v_at, v_vx);\n      v_vx = _mm_sub_ps(_mm_andnot_ps(v_at, v_vx), v_dxp);\n      v_at = _mm_cmplt_ps(v_dy, v_edgely);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dy, v_edgery));\n      v_y = _mm_and_ps(v_at, v_y);\n      v_dy = _mm_add_ps(_mm_andnot_ps(v_at, v_dy), v_y);\n      v_dyp = _mm_and_ps(v_at, v_vy);\n      v_vy = _mm_sub_ps(_mm_andnot_ps(v_at, v_vy), v_dyp);\n    }\n    else\n      if (ipbc == 3)\n    {\n      v_at = _mm_cmplt_ps(v_dx, v_edgelx);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dx, v_edgerx));\n      v_x = _mm_and_ps(v_at, v_x);\n      v_dx = _mm_add_ps(_mm_andnot_ps(v_at, v_dx), v_x);\n      v_dxp = _mm_and_ps(v_at, v_vx);\n      v_vx = _mm_sub_ps(_mm_andnot_ps(v_at, v_vx), v_dxp);\n    }\n\n\n    _mm_store_ps(&ppart[j + npoff], v_dx);\n    _mm_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_vx);\n    _mm_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vy);\n    _mm_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vz);\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * mxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * mxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0 + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n  }\n\n  _mm_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 2; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nps,nn,mm,nm,x,y,vx,vy,vz,dxp,dyp, amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1, rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,p2,gami,qtmg,dtg,sum1,v_noff, v_moff,v_nn,v_mm,v_it,v_x,v_y,v_vx,v_vy,v_vz,v_dxp,v_dyp,v_amx,v_amy, v_dx,v_dy,v_dz,v_gami,v_at,v_d,v_sum1,a,b,c,d,e,f,g,h,ll,dd,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  val = val + 2;\n  val = val * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB159-nobarrier-orig-gpu-no/3"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int x = 0; x < GRAIN; x++)\n  {\n    for (int y = 0; y < GRAIN; y++)\n    {\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          compute_new_state(i, j);\n        }\n\n      }\n\n    }\n\n  }\n\n  swap_images();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/6"}
{"code": "for (int i = 0; i < layer4->outputs; i++)\n{\n  layer4->biases[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/5"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/3"}
{"code": "for (int k = 0; k < K; k++)\n{\n  for (int j = 0; j < total_values; j++)\n  {\n    localSum[k].values[j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/15"}
{"code": "for (j = 0; j < ((int) innerreps); j++)\n{\n  delay(delaylength);\n}\n\n", "pragma": "omp parallel for ordered schedule (static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/benchs/EPCC/syncbench/0"}
{"code": "for (j = 0; j < 64; j++)\n  if ((unsigned int) ((ran >> j) & 1))\n  temp ^= m2[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Random/random/6"}
{"code": "for (int a = 0; a < nkernels; a++)\n{\n  for (int b = 0; b < nchannels; b++)\n  {\n    for (int d = 0; d < kernel_order; d++)\n    {\n      for (int e = 0; e < kernel_order; e++)\n      {\n        kernelsAsFloats[a][d][e][b] = kernels[a][b][d][e];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for simd collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saisankp/Concurrent-Systems/Lab-2-Parallel-Multichannel-Multikernel-Convolution/conv-harness/0"}
{"code": "for (int i = 0; i < procs; i++)\n{\n  ncols[i] = size;\n  nrows[i] = size / procs;\n  nozeros[i] = A.indi[(i + 1) * nrows[i]] - A.indi[i * nrows[i]];\n  sum += nozeros[i];\n  fnz[i] = sum - nozeros[i];\n  if (i > 0)\n    sumnnz[i] = nozeros[i - 1];\n\n  fsearch[i] = i * nrows[i];\n  lsearch[i] = (fsearch[i] + nrows[i]) - 1;\n  sizeindi[i] = nrows[i] + 1;\n  fnzi[i + 1] = nrows[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/11"}
{"code": "for (int np = 1; np <= NPI; np++)\n{\n  fscanf(arq, \"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\\n\", &var1, &var1, &var1, &x, &y, &z, &var1, &xl0, &yl0, &zl0, &var1, &var1, &var1, &var1, &var1, &var1, &var1, &var1, &var1);\n  for (int VeAux = 1; VeAux <= 10; VeAux++)\n  {\n    double Ve = VeAux;\n    Ve = Ve / 2;\n    double vex;\n    double vey;\n    double vez;\n    vex = (vey = (vez = (Ve * Ve) / 3));\n    for (int aux = -14; aux <= 2; aux++)\n    {\n      double gama = pow(10, aux);\n      for (int Xaux = 1; Xaux <= 100; Xaux++)\n      {\n        double X = Xaux;\n        double A = brute_A(y, xl0, gama, X, vex, vey);\n        double B = brute_B(yl0, gama, X, vex, vey);\n        double E = brute_E(y, xl0, X, vex);\n        double G = brute_G(x, yl0, X, vex, vey);\n        for (int t = 1; t <= Tmax; t++)\n        {\n          double fx = dX(t, vey, vex, gama, X, A, B, E, G);\n        }\n\n      }\n\n    }\n\n  }\n\n  lineTime = finalTime;\n  time(&timer2);\n  tm_info = localtime(&timer2);\n  strftime(buffer2, 25, \"%d/%m/%Y %H:%M:%S\", tm_info);\n  finalTime = getRealTime();\n  fprintf(out, \"\\nLinha %d: %f segundos\\n\", np, finalTime - lineTime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonedarts/rendezvous/openCL/rendezvous/rendezvous-serial/0"}
{"code": "for (i = 0; i < n; i++)\n  if (a[i] != (7 * i))\n  err = 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/target-16/2"}
{"code": "for (int path = 0; path < num_paths; path++)\n{\n  const double r_min_half_sigma_sq_dt = (r - ((0.5 * sigma) * sigma)) * dt;\n  const double sigma_sqrt_dt = sigma * sqrt(dt);\n  double S = S0;\n  int offset = path;\n  for (int timestep = 0; timestep < (num_timesteps - 1); ++timestep, offset += num_paths)\n  {\n    S = S * exp(r_min_half_sigma_sq_dt + (sigma_sqrt_dt * samples[offset]));\n    paths[offset] = S;\n  }\n\n  S = S * exp(r_min_half_sigma_sq_dt + (sigma_sqrt_dt * samples[offset]));\n  paths[offset] = payoff(S);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit (NUM_THREADS_PER_BLOCK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aop-omp/main/0"}
{"code": "for (i = 0; i < BuffSZ; i++)\n  HaloFromUP[i] = BuffUP[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erwold/3d-Finite-difference/iso-3dfd_main/0"}
{"code": "for (int i = 0; i < num_read; ++i)\n{\n  temp[cont % 19] = buffer[i];\n  ++cont;\n  if ((cont % 19) == 0)\n  {\n    cont = 0;\n    v.emplace_back(strtoull(temp, &end, 10));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  dest_vect[i] = origin_vect[i];\n}\n\n", "pragma": "omp parallel for shared(origin_vect, dest_vect, size) default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderbonnet/parallel-jacobi-method/src/copy/1"}
{"code": "for (int i = 1; i < np; ++i)\n{\n  MPI_Recv(&tempMin, 1, MPI_DOUBLE, i, i + 100, MPI_COMM_WORLD, &status);\n  MPI_Recv(&tempMax, 1, MPI_DOUBLE, i, i + 110, MPI_COMM_WORLD, &status);\n  if (tempMin < pixel_value_min)\n    pixel_value_min = tempMin;\n\n  if (tempMax > pixel_value_max)\n    pixel_value_max = tempMax;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jianxuecn/cccourse-examples/src/sobel_mpi_omp/0"}
{"code": "for (int i = 0; i < nRegions; i++)\n{\n  for (int j = 0; j < nCities; j++)\n  {\n    for (int k = 0; k < nStudents; k++)\n    {\n      sum += (grades[i][j][k] - avg) * (grades[i][j][k] - avg);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/statisticspar/0"}
{"code": "for (int i = 0; i < n; i++)\n  if (array[i] < x)\n  rank++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leo-ventura/parallel-computing-openmp/src/ranksort/3"}
{"code": "for (int y = 0; y < height; y++)\n  for (int x = 0; x < width; x++)\n  convolution(image, result, x, y);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/gaussian/gaussian2/1"}
{"code": "for (int i = 0; i < 10; ++i)\n  for (int j = 0; j < 10; ++j)\n  foo();\n\n\n", "pragma": "#pragma omp for private(argc,b),firstprivate(argv, c),lastprivate(d,f),reduction(+:e) reduction(min : g), ordered nowait, collapse(2), schedule(dynamic)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_ast_print/1"}
{"code": "for (int i = 0; i < corte; i++)\n{\n  hijo1->imagen[i] = padre1->imagen[i];\n  hijo2->imagen[i] = padre2->imagen[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/0"}
{"code": "for (j = 0, i = 0; i < ncand; i++)\n{\n  marker[cand[i].val] = -1;\n  if (cand[i].key >= minsim)\n  {\n    cand[j++] = cand[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/57"}
{"code": "for (int j = 0; j < nov; j++)\n{\n  startj = txadj[j];\n  endj = txadj[j + 1];\n  double csum = 0;\n  for (int i = startj; i < endj; i++)\n  {\n    csum += 1 * rv[tadj[i]];\n  }\n\n  cv[j] = 1 / csum;\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided) private(startj, endj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buraksekili/Sinkhorn-Knopp-scaling/cpu/main/2"}
{"code": "for (i = 0; i < 150; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/55"}
{"code": "for (int i = n - 1; i >= 0; i--)\n{\n  for (int k = i + 1; k < n; k++)\n    x[i] -= A[i][k] * x[k];\n\n  x[i] = x[i] / A[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/12"}
{"code": "for (k = row_min; k <= row_max; ++k)\n{\n  int tile_row_start = 1 + ((k - 1) * tile_row_size);\n  int tile_row_end = min(tile_row_start + tile_row_size, m + 1);\n  int tile_col_start = 1 + ((diagonal_index - k) * tile_col_size);\n  int tile_col_end = min(tile_col_start + tile_col_size, n + 1);\n  for (int ii = tile_row_start; ii < tile_row_end; ++ii)\n  {\n    for (int jj = tile_col_start; jj < tile_col_end; ++jj)\n    {\n      if (x[ii - 1] == y[jj - 1])\n      {\n        dp[ii][jj] = dp[ii - 1][jj - 1];\n      }\n      else\n      {\n        dp[ii][jj] = min3(dp[ii - 1][jj - 1] + pxy, dp[ii - 1][jj] + pgap, dp[ii][jj - 1] + pgap);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing11/p1/6"}
{"code": "for (int i = 0; i < n_rows_; i++)\n{\n  for (int j = 0; j < n_cols_; j++)\n  {\n    int index = (i * n_cols_) + j;\n    if (pos_index_[index] < 0)\n      continue;\n\n    p_output[counter++] = CVT_FLT(connect_count[index]);\n    int acc_flowin_dir = compressed_dir[index];\n    if (acc_flowin_dir & 1)\n    {\n      if ((j != (n_cols_ - 1)) && (compressed_dir[index + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index + 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 2)\n    {\n      if (((i != (n_rows_ - 1)) && (j != (n_cols_ - 1))) && (compressed_dir[(index + n_cols_) + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index + n_cols_) + 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 4)\n    {\n      if ((i != (n_rows_ - 1)) && (compressed_dir[index + n_cols_] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index + n_cols_]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 8)\n    {\n      if (((i != (n_rows_ - 1)) && (j != 0)) && (compressed_dir[(index + n_cols_) - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index + n_cols_) - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 16)\n    {\n      if ((j != 0) && (compressed_dir[index - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 32)\n    {\n      if (((i != 0) && (j != 0)) && (compressed_dir[(index - n_cols_) - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index - n_cols_) - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 64)\n    {\n      if ((i != 0) && (compressed_dir[index - n_cols_] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index - n_cols_]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 128)\n    {\n      if (((i != 0) && (j != (n_cols_ - 1))) && (compressed_dir[(index - n_cols_) + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index - n_cols_) + 1]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/4"}
{"code": "for (int k = 0; k < MAX_MATRIX_LENGTH; k++)\n{\n  for (i_iter = 0; i_iter < matrixRows; i_iter++)\n  {\n    for (j_iter = 0; j_iter < MAX_MATRIX_LENGTH; j_iter++)\n      matrix_final[i_iter][k] += matrix_0[i_iter][j_iter] * matrix_1[j_iter][k];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiippu/MSMPI-and-OpenMP/M3.T1P/Source/4"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  double cv[PROBLEM_SIZE];\n  double rhoq[PROBLEM_SIZE];\n  double lhs[IMAXP + 1][IMAXP + 1][5];\n  double lhsp[IMAXP + 1][IMAXP + 1][5];\n  double lhsm[IMAXP + 1][IMAXP + 1][5];\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      lhs[0][i][m] = 0.0;\n      lhsp[0][i][m] = 0.0;\n      lhsm[0][i][m] = 0.0;\n      lhs[ny2 + 1][i][m] = 0.0;\n      lhsp[ny2 + 1][i][m] = 0.0;\n      lhsm[ny2 + 1][i][m] = 0.0;\n    }\n\n    lhs[0][i][2] = 1.0;\n    lhsp[0][i][2] = 1.0;\n    lhsm[0][i][2] = 1.0;\n    lhs[ny2 + 1][i][2] = 1.0;\n    lhsp[ny2 + 1][i][2] = 1.0;\n    lhsm[ny2 + 1][i][2] = 1.0;\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      ru1 = c3c4 * rho_i[k][j][i];\n      cv[j] = vs[k][j][i];\n      rhoq[j] = max(max(dy3 + (con43 * ru1), dy5 + (c1c5 * ru1)), max(dymax + ru1, dy1));\n    }\n\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      lhs[j][i][0] = 0.0;\n      lhs[j][i][1] = ((-dtty2) * cv[j - 1]) - (dtty1 * rhoq[j - 1]);\n      lhs[j][i][2] = 1.0 + (c2dtty1 * rhoq[j]);\n      lhs[j][i][3] = (dtty2 * cv[j + 1]) - (dtty1 * rhoq[j + 1]);\n      lhs[j][i][4] = 0.0;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = 1;\n    lhs[j][i][2] = lhs[j][i][2] + comz5;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j][i][4] = lhs[j][i][4] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz6;\n    lhs[j + 1][i][3] = lhs[j + 1][i][3] - comz4;\n    lhs[j + 1][i][4] = lhs[j + 1][i][4] + comz1;\n  }\n\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhs[j][i][0] = lhs[j][i][0] + comz1;\n      lhs[j][i][1] = lhs[j][i][1] - comz4;\n      lhs[j][i][2] = lhs[j][i][2] + comz6;\n      lhs[j][i][3] = lhs[j][i][3] - comz4;\n      lhs[j][i][4] = lhs[j][i][4] + comz1;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = grid_points[1] - 3;\n    lhs[j][i][0] = lhs[j][i][0] + comz1;\n    lhs[j][i][1] = lhs[j][i][1] - comz4;\n    lhs[j][i][2] = lhs[j][i][2] + comz6;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j + 1][i][0] = lhs[j + 1][i][0] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz5;\n  }\n\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhsp[j][i][0] = lhs[j][i][0];\n      lhsp[j][i][1] = lhs[j][i][1] - (dtty2 * speed[k][j - 1][i]);\n      lhsp[j][i][2] = lhs[j][i][2];\n      lhsp[j][i][3] = lhs[j][i][3] + (dtty2 * speed[k][j + 1][i]);\n      lhsp[j][i][4] = lhs[j][i][4];\n      lhsm[j][i][0] = lhs[j][i][0];\n      lhsm[j][i][1] = lhs[j][i][1] + (dtty2 * speed[k][j - 1][i]);\n      lhsm[j][i][2] = lhs[j][i][2];\n      lhsm[j][i][3] = lhs[j][i][3] - (dtty2 * speed[k][j + 1][i]);\n      lhsm[j][i][4] = lhs[j][i][4];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      fac1 = 1.0 / lhs[j][i][2];\n      lhs[j][i][3] = fac1 * lhs[j][i][3];\n      lhs[j][i][4] = fac1 * lhs[j][i][4];\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      }\n\n      lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n      lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n      }\n\n      lhs[j2][i][1] = lhs[j2][i][1] - (lhs[j2][i][0] * lhs[j][i][3]);\n      lhs[j2][i][2] = lhs[j2][i][2] - (lhs[j2][i][0] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhs[j2][i][0] * rhs[k][j][i][m]);\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    fac1 = 1.0 / lhs[j][i][2];\n    lhs[j][i][3] = fac1 * lhs[j][i][3];\n    lhs[j][i][4] = fac1 * lhs[j][i][4];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    }\n\n    lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n    lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n    }\n\n    fac2 = 1.0 / lhs[j1][i][2];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = fac2 * rhs[k][j1][i][m];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      m = 3;\n      fac1 = 1.0 / lhsp[j][i][2];\n      lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n      lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n      lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n      lhsp[j2][i][1] = lhsp[j2][i][1] - (lhsp[j2][i][0] * lhsp[j][i][3]);\n      lhsp[j2][i][2] = lhsp[j2][i][2] - (lhsp[j2][i][0] * lhsp[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsp[j2][i][0] * rhs[k][j][i][m]);\n      m = 4;\n      fac1 = 1.0 / lhsm[j][i][2];\n      lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n      lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n      lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n      lhsm[j2][i][1] = lhsm[j2][i][1] - (lhsm[j2][i][0] * lhsm[j][i][3]);\n      lhsm[j2][i][2] = lhsm[j2][i][2] - (lhsm[j2][i][0] * lhsm[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsm[j2][i][0] * rhs[k][j][i][m]);\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    m = 3;\n    fac1 = 1.0 / lhsp[j][i][2];\n    lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n    lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n    lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n    m = 4;\n    fac1 = 1.0 / lhsm[j][i][2];\n    lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n    lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n    lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n    rhs[k][j1][i][3] = rhs[k][j1][i][3] / lhsp[j1][i][2];\n    rhs[k][j1][i][4] = rhs[k][j1][i][4] / lhsm[j1][i][2];\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m]);\n    }\n\n    rhs[k][j][i][3] = rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3]);\n    rhs[k][j][i][4] = rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4]);\n  }\n\n  for (j = grid_points[1] - 3; j >= 0; j--)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = (rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m])) - (lhs[j][i][4] * rhs[k][j2][i][m]);\n      }\n\n      rhs[k][j][i][3] = (rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3])) - (lhsp[j][i][4] * rhs[k][j2][i][3]);\n      rhs[k][j][i][4] = (rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4])) - (lhsm[j][i][4] * rhs[k][j2][i][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/24"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n  {\n    C[(i * 1500) + j] = (((DATA_TYPE) i) * (j + 3)) / 1500;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm/4"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (j = jst; j <= jend; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n      }\n\n    }\n\n    for (j = jst; j <= L2; j++)\n    {\n      tmp = 1.0 / rsd[i][j][k][0];\n      u21j = tmp * rsd[i][j][k][1];\n      u31j = tmp * rsd[i][j][k][2];\n      u41j = tmp * rsd[i][j][k][3];\n      u51j = tmp * rsd[i][j][k][4];\n      tmp = 1.0 / rsd[i][j - 1][k][0];\n      u21jm1 = tmp * rsd[i][j - 1][k][1];\n      u31jm1 = tmp * rsd[i][j - 1][k][2];\n      u41jm1 = tmp * rsd[i][j - 1][k][3];\n      u51jm1 = tmp * rsd[i][j - 1][k][4];\n      flux[i][j][k][1] = ty3 * (u21j - u21jm1);\n      flux[i][j][k][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[i][j][k][3] = ty3 * (u41j - u41jm1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((1.40e+00 * 1.40e+00) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j = jst; j <= jend; j++)\n    {\n      frct[i][j][k][0] = frct[i][j][k][0] + ((dy1 * ty1) * ((rsd[i][j - 1][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i][j + 1][k][0]));\n      frct[i][j][k][1] = (frct[i][j][k][1] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][1] - flux[i][j][k][1]))) + ((dy2 * ty1) * ((rsd[i][j - 1][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i][j + 1][k][1]));\n      frct[i][j][k][2] = (frct[i][j][k][2] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][2] - flux[i][j][k][2]))) + ((dy3 * ty1) * ((rsd[i][j - 1][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i][j + 1][k][2]));\n      frct[i][j][k][3] = (frct[i][j][k][3] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][3] - flux[i][j][k][3]))) + ((dy4 * ty1) * ((rsd[i][j - 1][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i][j + 1][k][3]));\n      frct[i][j][k][4] = (frct[i][j][k][4] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][4] - flux[i][j][k][4]))) + ((dy5 * ty1) * ((rsd[i][j - 1][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i][j + 1][k][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][1][k][m] = frct[i][1][k][m] - (dsspm * ((((+5.0) * rsd[i][1][k][m]) - (4.0 * rsd[i][2][k][m])) + rsd[i][3][k][m]));\n      frct[i][2][k][m] = frct[i][2][k][m] - (dsspm * (((((-4.0) * rsd[i][1][k][m]) + (6.0 * rsd[i][2][k][m])) - (4.0 * rsd[i][3][k][m])) + rsd[i][4][k][m]));\n    }\n\n    jst1 = 3;\n    jend1 = ny - 4;\n    for (j = jst1; j <= jend1; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (dsspm * ((((rsd[i][j - 2][k][m] - (4.0 * rsd[i][j - 1][k][m])) + (6.0 * rsd[i][j][k][m])) - (4.0 * rsd[i][j + 1][k][m])) + rsd[i][j + 2][k][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][ny - 3][k][m] = frct[i][ny - 3][k][m] - (dsspm * (((rsd[i][ny - 5][k][m] - (4.0 * rsd[i][ny - 4][k][m])) + (6.0 * rsd[i][ny - 3][k][m])) - (4.0 * rsd[i][ny - 2][k][m])));\n      frct[i][ny - 2][k][m] = frct[i][ny - 2][k][m] - (dsspm * ((rsd[i][ny - 4][k][m] - (4.0 * rsd[i][ny - 3][k][m])) + (5.0 * rsd[i][ny - 2][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/3"}
{"code": "for (unsigned p = 0; p < Size; p++)\n{\n  unsigned k = (data[p] >> ckmov) & KEYSMASK;\n  unsigned pk = p2[k];\n  data2[pk] = data[p];\n  index2[pk] = index[p];\n  p2[k]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/9"}
{"code": "for (int x = 0; x < max; ++x)\n{\n  for (int y = 0; y < max; ++y)\n  {\n    for (int k = 0; k < max; ++k)\n    {\n      results[x][y] += m1[x][k] * m2[k][y];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maureenm/openMPAssignment2/naiveParallel/0"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  printf(\"%f \\t\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Diffusion/1-D_Diffusion/main/2"}
{"code": "for (i = iLeft; i <= iRight; i++)\n{\n  g[i][0] = v[i][0];\n  g[i][jmax] = v[i][jmax];\n}\n\n", "pragma": "omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/3"}
{"code": "for (int i = (me * size) / nth; i < (((me + 1) * size) / nth); i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    float cij = a3[(i * size) + j];\n    for (int k = 0; k < size; k++)\n    {\n      a3[(i * size) + j] += a1[(i * size) + k] * a2[(k * size) + j];\n    }\n\n    a3[(i * size) + j] = cij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/1"}
{"code": "for (ll = 0; ll < NUM_VARS; ll++)\n{\n  for (k = 0; k < nz; k++)\n  {\n    for (s = 0; s < hs; s++)\n    {\n      state[(((ll * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + s] = recvbuf_l[(((ll * nz) * hs) + (k * hs)) + s];\n      state[(((((ll * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + nx) + hs) + s] = recvbuf_r[(((ll * nz) * hs) + (k * hs)) + s];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-omp/main/6"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  l[i] = U[i][k] / U[k][k];\n  for (int j = k + 1; j < m; j++)\n    U[i][j] = U[i][j] - (l[i] * U[k][j]);\n\n  b[i] = b[i] - (l[i] * b[k]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Gauss-Fatorization/gauss/0"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    CUTOFF = atoi(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE] -c CUTOFF\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/0"}
{"code": "for (r = 0, pos = 0; r < rows; r++)\n{\n  for (c = 0; c < cols; c++, pos++)\n  {\n    dx = (double) delta_x[pos];\n    dy = (double) delta_y[pos];\n    if (xdirtag == 1)\n      dx = -dx;\n\n    if (ydirtag == (-1))\n      dy = -dy;\n\n    dirim[pos] = (float) angle_radians(dx, dy);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  rank = omp_get_thread_num();\n  printf(\"iteration %d thread %d\\n\", i, rank);\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LiyaSharipova/OpenMP-Tasks/main/0"}
{"code": "for (int j = noOfElements / 2; j > 0; j = j / 2)\n{\n  counter = 0;\n  for (int i = startIndex; (i + j) <= lastIndex; i++)\n  {\n    if (counter < j)\n    {\n      ascendingSwap(i, i + j, ar);\n      counter++;\n    }\n    else\n    {\n      counter = 0;\n      i = (i + j) - 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/richursa/cpuBitonicSort/bitonicSort/0"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    if (diff < fabs(w[i][j] - u[i][j]))\n    {\n      diff = fabs(w[i][j] - u[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 4/heated-plate-parallel/9"}
{"code": "for (int i = 0; i < nBins; i++)\n{\n  hist[i] = ((((TMPHIST(i - 2) + TMPHIST(i + 2)) * 1.0f) / 16.0f) + (((TMPHIST(i - 1) + TMPHIST(i + 1)) * 4.0f) / 16.0f)) + ((TMPHIST(i) * 6.0f) / 16.0f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/8"}
{"code": "for (int i = 0; i < Num_calc; i++)\n{\n  for (int j = 0; j < N; j++)\n    if (manyVout[i][j] != N)\n  {\n    ((((((((cerr << \"Calculation \") << i) << \" Vout[\") << j) << \"] != \") << N) << \", wrong value is \") << manyVout[i][j]) << endl;\n    throw;\n    break;\n  }\n\n\n  deallocate(manyA[i], N * N);\n  deallocate(manyV[i], N);\n  deallocate(manyVout[i], N);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/hands-on/gemv/51-gemv-omp-many-matrices/gemv-omp-many-matrices/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  processInput(imgs);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(2) schedule(static, 8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/0801130205/openMP/main/0"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 0; j <= (n - 1); j += 1)\n  {\n    fprintf(stderr, \"%0.2lf \", X[i][j]);\n    if ((((i * 500) + j) % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB043-adi-parallel-no/6"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int u = leftg[i];\n  next[u] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/komalkurve/Bipartite-Matching-using-openMP/HopcraftParallel/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\t\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/BubbleSort/main/2"}
{"code": "for (k = 0; k < 3; k++)\n{\n  temp = v[j][k];\n  v[j][k] = v[cuboid[(int) pos[j][i][1]][(int) pos[j][i][0]][(int) pos[j][i][2]]][k];\n  v[cuboid[(int) pos[j][i][1]][(int) pos[j][i][0]][(int) pos[j][i][2]]][k] = temp;\n}\n\n", "pragma": "\t\t\t\t#pragma omp parallel for shared(v,cuboid,pos,j,i,delta_t) private(temp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/N-Body-Simulator/manybody-sim-program/7"}
{"code": "for (int i = 0; i < rowsNumber; i++)\n{\n  for (int j = 0; j < columnsNumber; j++)\n  {\n    if (myChunkOfTheFile[(columnsNumber * i) + j] == 1)\n    {\n      coordinates[row_index][col_index] = ((rowsNumber * myProcId) + 1) + i;\n      coordinates[row_index][++col_index] = j + 1;\n      findRightBottomCorner(myChunkOfTheFile, i, j, coordinates, row_index, col_index, rowsNumber, columnsNumber, myProcId);\n      col_index = 0;\n      row_index = row_index + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/3"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    if (scanf(\"%lf\", &aMatr[wI][wJ]) != 1)\n    {\n      fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d%d\\n\", wI, wJ);\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  fprintf(fout, \"%d\\n\", other[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/valeroclemente/AdvanceComputerArchitecture/OpenMP_linux_codes/mergeOpenMP_linux/3"}
{"code": "for (i = 0; i < len; i++)\n{\n  if (numList[i] != 0)\n  {\n    answer[counter] = numList[i];\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theminigundude/CSCI-UA.0480-003-Parallel-Computing-Lab-2/genprime/3"}
{"code": "for (int i = 0; i < (BUFFER_BACKSPACE - 1); i++)\n  gaBackspace[i] = 8;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Michaelangel007/buddhabrot/buddhabrot_omp1/1"}
{"code": "for (int j = 0; j < ((int) red.size()); j++)\n{\n  int col = j % img.width;\n  int row = j / img.width;\n  int result_red = 0;\n  int result_blue = 0;\n  int result_green = 0;\n  for (int s = -2; s < 3; s++)\n  {\n    for (int t = -2; t < 3; t++)\n    {\n      if (((((row + s) >= 0) && ((col + t) >= 0)) && ((col + t) < ((int) img.width))) && ((row + s) < ((int) img.height)))\n      {\n        result_red += m[(s + 3) - 1][(t + 3) - 1] * red[((row + s) * img.width) + (col + t)];\n        result_blue += m[(s + 3) - 1][(t + 3) - 1] * blue[((row + s) * img.width) + (col + t)];\n        result_green += m[(s + 3) - 1][(t + 3) - 1] * green[((row + s) * img.width) + (col + t)];\n      }\n\n    }\n\n  }\n\n  red_copy[j] = result_red / weight;\n  blue_copy[j] = result_blue / weight;\n  green_copy[j] = result_green / weight;\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dgpMakes/photo-filters/parallel/1"}
{"code": "for (x = 0; x < m; x++)\n{\n  int aa = a[x + ((y - 1) * m)];\n  a[x + (y * m)] = (1 + aa) - (a[x + (y * m)] * (aa + 1));\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/1"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n  {\n    printf(\"%d \\n\", c[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yehia67/OpenMP-Examples/matrixMultiplicationParallel/1"}
{"code": "for (long i = 0; i < N; i++)\n{\n  if ((verify_res[i] - res[i]) >= EPSILON)\n  {\n    printf(\"Invalid at pos %ld, res = %0.10f, actual = %0.10f.\\n\", i, res[i], verify_res[i]);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gadube/simple_openmp_examples/mxv_openmp/4"}
{"code": "for (int i = 0; i < count; ++i)\n{\n  if (((a[n1] <= a[half + n2]) && (n1 < half)) || (n2 >= (count - half)))\n  {\n    b[i] = a[n1++];\n  }\n  else\n    if (((a[n1] > a[half + n2]) && (n2 < (count - half))) || (n1 >= half))\n  {\n    b[i] = a[half + (n2++)];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kang235/OpenMP/MergeSort/3"}
{"code": "for (j = 0; j < g->currSize; j++)\n{\n  if (nodes[j].hasAnosia || nodes[j].isDead)\n  {\n    continue;\n  }\n\n  if (nodes[j].isContaminated)\n  {\n    if (isGoingToDie(nodes[j].daysRecovering, seed))\n    {\n      nodes[j].isDead = 1;\n      totalDeaths++;\n      newDeaths++;\n      active--;\n    }\n    else\n    {\n      nodes[j].daysRecovering++;\n      if (nodes[j].daysRecovering == 10)\n      {\n        nodes[j].isContaminated = 0;\n        nodes[j].hasAnosia = 1;\n        recovered++;\n        active--;\n      }\n\n    }\n\n  }\n  else\n  {\n    conn = nodes[j].connectionsHead;\n    while (conn)\n    {\n      if (conn->contaminates == 1)\n      {\n        nodes[j].isContaminated = 1;\n      }\n\n      conn->contaminates = 0;\n      conn = conn->next;\n    }\n\n    if (nodes[j].isContaminated)\n    {\n      newCases++;\n      totalCases++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) private(j, conn) firstprivate(seed) reduction(+ : totalDeaths, newDeaths, recovered, newCases, totalCases) reduction(- : active)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MChatzakis/omp-epidemic-simulation/source/Epidemic/1"}
{"code": "for (int Row = 0; Row < RowN; Row++)\n{\n  if (RowSpVV[Row].Empty())\n  {\n    continue;\n  }\n\n  if (RowSpVV[Row].Last().Key >= ColN)\n  {\n    ColN = RowSpVV[Row].Last().Key + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  C++;\n  printf(\"threadID = %d, %d: %d\\n\", omp_get_thread_num(), i, C);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/11"}
{"code": "for (unsigned int i = 0; i < nthreads; ++i)\n{\n  thread_sum[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkmashaev/OpenMP_Lab2/ParallelSolution/for_tid/0"}
{"code": "for (j = 0; j < N; j++)\n{\n  colSum = 0;\n  for (i = 0; i < N; i++)\n  {\n    if (i != j)\n    {\n      per = (int) (100 * propArray[i]);\n      M[i][j] = propabilityFunction(per);\n      colSum += M[i][j];\n    }\n    else\n    {\n      M[i][j] = 0;\n    }\n\n  }\n\n  if (0 == colSum)\n  {\n    for (i = 0; i < N; i++)\n    {\n      if (i != j)\n      {\n        M[i][j] = propabilityFunction(50);\n        colSum += M[i][j];\n      }\n\n    }\n\n  }\n\n  if (0 == colSum)\n  {\n    per = rand() % N;\n    if (per == j)\n    {\n      if (j != (N - 1))\n      {\n        per++;\n      }\n      else\n      {\n        per--;\n      }\n\n    }\n\n    M[per][j] = 1;\n    colSum = 1;\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    M[i][j] /= colSum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/24"}
{"code": "for (i = 0; i < ARCHnodes; i++)\n{\n  nodekind[i] = (int) nodekindf[i];\n  if (nodekind[i] == 3)\n    nodekind[i] = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/7"}
{"code": "for (i = 0; i < Entries_N; i++)\n{\n  int j;\n  int pre_val = i * order;\n  double ans = 0;\n  int *cach1 = (int *) malloc((sizeof(int)) * order);\n  for (j = 0; j < order; j++)\n    cach1[j] = Indices[pre_val++];\n\n  for (j = 0; j < Core_N; j++)\n  {\n    double temp = CoreTensor[j];\n    int k;\n    int pos = j * order;\n    int val = 0;\n    for (k = 0; k < order; k++)\n    {\n      int mulrow = cach1[k];\n      int mulcol = CorePermu[pos++];\n      temp *= FactorM[(val + (mulrow * Core_dim)) + mulcol];\n      val += mult;\n    }\n\n    ans += temp;\n  }\n\n  free(cach1);\n  Error_T[i] -= ans;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/11"}
{"code": "for (i = 0; i < (MK + 1); i++)\n{\n  t2 = randlc(&t1, t1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/EP/ep/1"}
{"code": "for (int i = 0; i < (numIters / 100); i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].x);\n  }\n\n  fprintf(trajec, \"\\n\");\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].y);\n  }\n\n  fprintf(trajec, \"\\n\");\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].z);\n  }\n\n  fprintf(trajec, \"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/10Kaiser10/n-body-simulation-openMP/src/simulation/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  *(idx + i) = i;\n  for (int j = 0; j < d; j++)\n    *((X_copy + (i * d)) + j) = *((X + (i * d)) + j);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/angrammenos97/VP_Tree/vptree/4"}
{"code": "for (i = 0; i < rows; i++)\n{\n  if (i == (rows - 1))\n    printf(\"%.2f ] \\n\", mean[i]);\n  else\n    printf(\"%.2f , \", mean[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/7"}
{"code": "for (int i = 0; i < tam; i++)\n{\n  for (int j = 0; j < tam; j++)\n  {\n    for (int k = 0; k < 3; k++)\n      imagen[k][i][j] = (i * j) % 256;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/19"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  local_sum += (dx * (f(i * dx) + f((i + 1) * dx))) / 2;\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alekseyen/MIPT_parallel_distribution_5sem/mpi:openmp/3/critical/0"}
{"code": "for (long v = 0; v < NVer; v++)\n{\n  long adj1 = verPtr[v];\n  long adj2 = verPtr[v + 1];\n  if (vtxColor[v] == maxColor)\n  {\n    __sync_fetch_and_add(&unColored, 1);\n    continue;\n  }\n\n  for (long k = adj1; k < adj2; k++)\n  {\n    if (v == verInd[k].tail)\n      continue;\n\n    if (vtxColor[v] == vtxColor[verInd[k].tail])\n    {\n      __sync_fetch_and_add(&myConflicts, 1);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringMultiHashMaxMin/4"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  DEBUG(\"%d->color = %d\\n\", u->label, u_data->color);\n  if ((u_data->color >= 6) || (u_data->color < 0))\n  {\n    WARN(\"%d->color is not between [0, 5]\\n\", u->label);\n    correct = 0;\n  }\n\n  for (int j = 0; j < u->degree; j++)\n  {\n    node *v = *((node **) elem_at(&u->neighbors, j));\n    payload *v_data = v->data;\n    if (u_data->color == v_data->color)\n    {\n      WARN(\"%d->color = %d->color and there's an edge\\n\", u->label, v->label);\n      correct = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/vertex_coloring/5"}
{"code": "for (int i = 0; i < k; i++)\n  b[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task9/1"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  if (i != j)\n  {\n    Bodies[i].calcForce(Bodies[j], fx[j], fy[j]);\n  }\n  else\n  {\n    fx[j] = 0;\n    fy[j] = 0;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muneebabbas/Barnes-Hut-N-Body-Simulation-C-/part2/part2/2"}
{"code": "for (int i = 0; i < N; i++)\n  visited[i + offset] = temp[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/1"}
{"code": "for (S[0] = P, i = 1; i < 26; i++)\n  S[i] = S[i - 1] + Q;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sara7860/Enhancement-of-RC5-Algorithm/project code/parallel/4"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (d_graph_mask[tid])\n  {\n    d_graph_mask[tid] = 0;\n    for (int i = d_graph_nodes[tid].starting; i < (d_graph_nodes[tid].no_of_edges + d_graph_nodes[tid].starting); i++)\n    {\n      int id = d_graph_edges[i];\n      if (!d_graph_visited[id])\n      {\n        d_cost[id] = d_cost[tid] + 1;\n        d_updating_graph_mask[id] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for num_teams(num_of_teams) thread_limit(num_of_threads_per_block)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hyejin97/GPU_programming_openmp-cuda/BFS/bfs/0"}
{"code": "for (i = 0; i < ((ptrdiff_t) (width * height)); ++i)\n{\n  float_out[i] = (bool_in[(size_t) i] == true_is_zero) ? (0.f) : (INFINITY);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chaquator/chaq-sdfgen/openmp/sdfgen/1"}
{"code": "for (i = 0; i < array_size; i++)\n{\n  serial_sum = serial_sum + Check[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/SM/Laborator/lab13/suma/1"}
{"code": "for (j = 0; j < numThreads; j++)\n{\n  thread_params[j]._tid = j;\n  thread_params[j]._ran = ran;\n  thread_params[j]._table = Table;\n  thread_params[j]._blockSize = (1024 * 1024LU) / numThreads;\n  thread_params[j]._logTableSize = logTableSize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/pthread/single_node_lcg/2"}
{"code": "for (int i = 0; i < array_length; i++)\n{\n  output[i] = array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aothelal/Parallel-Jacobi-Method-Using-OpenMP/Parallel_Jacobi/3"}
{"code": "for (int i = 0; i < u->degree; i++)\n{\n  node *v = *((node **) elem_at(&u->neighbors, i));\n  int w = g->adj_mat[u->label][v->label];\n  if ((in_mst[v->label] == 0) && (w < d[v->label]))\n  {\n    d[v->label] = w;\n    parent[v->label] = u->label;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/12"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  a[i] = (rand() % 100) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task6/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  c[i] = a[i] + b[i];\n  (((((cout << \"Thread \") << thread_id) << \" executes iteration \") << i) << \".\") << endl;\n}\n\n", "pragma": "        #pragma omp for ordered schedule(static,1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggrbill/omp-tutorial/src/omp_ordered/0"}
{"code": "for (int i = r - 1; i >= 0; --i)\n{\n  --ld;\n  ++rd;\n  if ((board[i] == ld) || (board[i] == rd))\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nqueen-omp/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  result += x[i] * y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gtrabes/OpenMPExample/openmp_example/2"}
{"code": "for (size_t count = 0; count < ghostCount; count++)\n{\n  m_pParticleData->m_vPositionX[ghostIndex] = xGhost[count];\n  m_pParticleData->m_vPositionY[ghostIndex] = yGhost[count];\n  m_pParticleData->m_vPositionZ[ghostIndex] = zGhost[count];\n  ghostIndex++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/34"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    C[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float x = a + ((i + .5) * ((b - a) / n));\n  switch (functionid)\n  {\n    case 1:\n      res += f1(x, intensity);\n      break;\n\n    case 2:\n      res += f2(x, intensity);\n      break;\n\n    case 3:\n      res += f3(x, intensity);\n      break;\n\n    case 4:\n      res += f4(x, intensity);\n      break;\n\n    default:\n      cout << \"\\nWrong functionid\";\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for reduction (+ : res) schedule (runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgupta180496/OpenMP-Loop/numint/numint/0"}
{"code": "for (int i = 1; i < cities; i++)\n{\n  line(x[i - 1], y[i - 1], x[i], y[i], 127, (unsigned char *) pic, width);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kelldork/OpenMP/tsp_omp/3"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = nppmx * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[(3 * i) + (mxv3 * j)] = fxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[(1 + (3 * i)) + (mxv3 * j)] = fxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[(2 + (3 * i)) + (mxv3 * j)] = fxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[(3 * i) + (mxv3 * j)] = bxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[(1 + (3 * i)) + (mxv3 * j)] = bxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[(2 + (3 * i)) + (mxv3 * j)] = bxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = (3 * (nn - noff)) + (mxv3 * (mm - moff));\n    amx = 1.0 - dxp;\n    amy = 1.0 - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += mxv3;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += mxv3;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[2 + (idimp * (j + npoff))] + dx;\n    acy = ppart[3 + (idimp * (j + npoff))] + dy;\n    acz = ppart[4 + (idimp * (j + npoff))] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0 / sqrtf(1.0 + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0 + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0 / (1.0 + omt);\n    omt = 0.5 * (1.0 - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[2 + (idimp * (j + npoff))] = dx;\n    ppart[3 + (idimp * (j + npoff))] = dy;\n    ppart[4 + (idimp * (j + npoff))] = dz;\n    p2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (dx * dtg);\n    dy = y + (dy * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,ih,nh,x,y,dxp,dyp,amx,amy, dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3, rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery,p2,gami, qtmg,dtg,sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/4"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n{\n  for (int j = 0; j < sizeOfItems; ++j)\n  {\n    if ((neighbor[i] != 0) && (neighbor[j] != 0))\n    {\n      weights[i][j] = (1.0 * collab[i][j]) / sqrt(neighbor[i] * neighbor[j]);\n    }\n    else\n    {\n      weights[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/serial/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    fprintf(f, \"%f \", u[(i * npadded) + j]);\n  }\n\n  fprintf(f, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/POISSON/poisson_openmp/11"}
{"code": "for (int i = nq; i < sz; i++)\n{\n  for (int j = j0; j < sz; j++)\n  {\n    d.ops++;\n    if (!hit(i, j, qs, nq))\n    {\n      qs[nq++] = j;\n      break;\n    }\n\n  }\n\n  if ((i + 1) > nq)\n    break;\n\n  j0 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sroma/queen-bt/qb/1"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      if (betay[pp] > 0.0)\n      {\n        Dyu[pp] = ((((((-3.0) * u[pp - nx]) - (10.0 * u[pp])) + (18.0 * u[pp + nx])) - (6.0 * u[pp + (2 * nx)])) + u[pp + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp] = (((((-u[pp - (3 * nx)]) + (6.0 * u[pp - (2 * nx)])) - (18.0 * u[pp - nx])) + (10.0 * u[pp])) + (3.0 * u[pp + nx])) * idy_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/29"}
{"code": "for (int i = 0; i < num_bin; i++)\n{\n  if (((i * step) >= j) && ((i * step) < (j + 1)))\n  {\n    vec_hist[j] += histogram[i];\n  }\n  else\n  {\n    j++;\n    vec_hist[j] += histogram[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/12"}
{"code": "for (long j = low; j <= (high - 1); j++)\n{\n  if (buf[j] <= pivot)\n  {\n    i++;\n    long t = buf[i];\n    buf[i] = buf[j];\n    buf[j] = t;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zilmarij/Hybrid_MPI-OpenMP_based_Sorting/sort/1"}
{"code": "for (i = 0; i != 10; i++)\n  ++i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/8"}
{"code": "for (i = 0; i < (((2048 / NODESX) + 2) / 2); i++)\n{\n  for (j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    whites[i][j].data = 0;\n    blacks[i][j].data = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/111"}
{"code": "for (int m = 0; m < ts.ROWS; m++)\n{\n  index[m] = ts.value[m * ts.COLS];\n  signal[m] = ts.value[(m * ts.COLS) + 1];\n  uncert[m] = sqrt(fabs(signal[m]));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mwilchek/HPC-Examples/Project_1/Get_Stats/src/get_data/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  PM.start(\"Kernel-Slow\");\n  slowkernel();\n  PM.stop(\"Kernel-Slow\", flop_count, 1);\n  spacer();\n  PM.start(\"Kernel-Fast\");\n  somekernel();\n  PM.stop(\"Kernel-Fast\", flop_count, 1);\n  spacer();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/avr-aics-riken/PMlib/example/test1/main_pmlib/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    scanf(\"%d\", &graph[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sneha711/OpenMP/dijkstra_parallel/2"}
{"code": "for (int i = 1; i < (node_count + 1); i++)\n{\n  sum += inbound_count[i - 1];\n  (*row_ptr)[i] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  vec[i] = size - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pengjintao/OpenMP/07_odd_even_sort/0"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n{\n  key_buff2[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/13"}
{"code": "for (nb = 0; nb < 10; nb++)\n{\n  matmul_openmp(n, A, B, C);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/matmul/3"}
{"code": "for (int i = 0; i < psteps; i++)\n{\n  for (int j = 0; j < qsteps; j++)\n  {\n    if (a[i] == b[j])\n    {\n      sum++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ypatiapd/Parallel-and-distributed-systems/project1/sparse_openMP/6"}
{"code": "for (int i = 0; i < STATES; i++)\n{\n  (cout << results[2 * i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/grn/sw/src/main/6"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n{\n  M[i][j] = value;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amineremache/matrix_mult/matrix_mul_openmp/4"}
{"code": "for (i = 0; i < primesCounter; ++i)\n{\n  int p = primes[i];\n  for (int j = p * p; j <= MAX; j += p)\n    if ((j >= MIN) && isPrimeNumber)\n    isPrimeNumber[j] = false;\n\n\n}\n\n", "pragma": "#pragma omp for nowait private(i) schedule(static, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/4"}
{"code": "for (int i = 0; i < 8000; i++)\n{\n  for (int j = 0; j < 8000; j++)\n  {\n    original_A[i][j] = A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzunny97/LU-OpenMP/LU_decomposition/1"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    neighbor = ((((((a[((i - 1) * n) + (j - 1)] + a[((i - 1) * n) + j]) + a[((i - 1) * n) + (j + 1)]) + a[((i + 1) * n) + (j - 1)]) + a[((i + 1) * n) + j]) + a[((i + 1) * n) + (j + 1)]) + a[(i * n) + (j - 1)]) + a[(i * n) + (j + 1)];\n    b[(i * n) + j] = find_new_a(a[(i * n) + j], neighbor);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,neighbor) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannisLamp/game-of-life/mpi_openmp/ompi_functions/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (max < n)\n  {\n    max = n;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/0"}
{"code": "for (y = height - 1; y >= 0; y--)\n{\n  const uint8_t *scanline = &texelsRGB[(y * width) * 3];\n  for (x = 0; x < width; x++)\n  {\n    uint8_t r = *(scanline++);\n    uint8_t g = *(scanline++);\n    uint8_t b = *(scanline++);\n    fprintf(pFileSave, \"%c\", b);\n    fprintf(pFileSave, \"%c\", g);\n    fprintf(pFileSave, \"%c\", r);\n  }\n\n  if (nExtraBytes)\n    for (i = 0; i < nExtraBytes; i++)\n    fprintf(pFileSave, \"%c\", 0);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Michaelangel007/buddhabrot/buddhabrot_omp1/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    }\n\n    lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(fac1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/102"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if ((((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || (mat16[rowcol] == (-28768))) || (mat17[rowcol] == (-28768)))\n  {\n  }\n  else\n  {\n    tempk = mat8[rowcol] * 0.02;\n    dem = mat14[rowcol];\n    temp = (int) (tempk + (0.00627 * dem));\n    if (temp > 250)\n    {\n      histogramT[temp] = histogramT[temp] + 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/3"}
{"code": "for (unsigned i = 0; i < size; ++i)\n{\n  for (unsigned j = 0; j < size; ++j)\n  {\n    m[(i * size) + j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/9"}
{"code": "for (int k = 0; k < n; k++)\n{\n  R[k] = (double *) malloc(n * (sizeof(double)));\n  D[k] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/2"}
{"code": "for (int j = 0; j <= (N - 4); j += 4)\n{\n  double *C_ij = (C + i) + (j * lda);\n  c_col_0 = _mm_load_pd(C_ij);\n  c_col_1 = _mm_load_pd(C_ij + lda);\n  c_col_2 = _mm_load_pd(C_ij + (2 * lda));\n  c_col_3 = _mm_load_pd(C_ij + (3 * lda));\n  int a_row_k_first_half;\n  int A_pos = ((((i / 8) * 8) * lda) + (0 * 8)) + (i % 8);\n  for (int k = 0; k < K; ++k)\n  {\n    a_row_k_first_half = _mm_load_pd((A + A_pos) + (k * 8));\n    b_k0 = _mm_set1_pd(B[k + (j * lda)]);\n    b_k1 = _mm_set1_pd(B[k + ((j + 1) * lda)]);\n    b_k2 = _mm_set1_pd(B[k + ((j + 2) * lda)]);\n    b_k3 = _mm_set1_pd(B[k + ((j + 3) * lda)]);\n    c_col_0 = _mm_fmadd_pd(a_row_k_first_half, b_k0, c_col_0);\n    c_col_1 = _mm_fmadd_pd(a_row_k_first_half, b_k1, c_col_1);\n    c_col_2 = _mm_fmadd_pd(a_row_k_first_half, b_k2, c_col_2);\n    c_col_3 = _mm_fmadd_pd(a_row_k_first_half, b_k3, c_col_3);\n    _mm_store_pd(C_ij, c_col_0);\n    _mm_store_pd(C_ij + lda, c_col_1);\n    _mm_store_pd(C_ij + (2 * lda), c_col_2);\n    _mm_store_pd(C_ij + (3 * lda), c_col_3);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/4"}
{"code": "for (; depth < (nmodes - 1); ++depth)\n{\n  left = fptr[depth][left];\n  right = fptr[depth][right];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/4"}
{"code": "for (int j = 0; j < ArrayColumn; j++)\n{\n  if (R[index][j] != 0)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tttran67/Parallel-Programming-Lab5_OpenMP/special/newomp/main/0"}
{"code": "for (i = 1; i < (n + 1); ++i)\n{\n  for (j = 1; j < (n + 1); ++j)\n  {\n    output_temp[i][j] = input_temp[i][j] + ((c * (delta_t / (delta_s * delta_s))) * ((((input_temp[i + 1][j] + input_temp[i - 1][j]) - (4 * input_temp[i][j])) + input_temp[i][j + 1]) + input_temp[i][j - 1]));\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(auto) shared(input_temp, output_temp) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/benludwin/ParallizationTechniques/OpenMP/parallel/heat/1"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((((m != centre) && (m != ind1)) && (m != ind2)) && (m != ind3))\n  {\n    if ((min4 == (-1.0)) || (dist_list[m] < min4))\n    {\n      min4 = dist_list[m];\n      ind4 = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/18"}
{"code": "for (int i = 0; i < n; i++)\n{\n  dist[i] = INF;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sunnlo/BellmanFord/openmp_bellman_ford/3"}
{"code": "for (int gid = 0; gid < N; gid++)\n{\n  int t;\n  int i;\n  int j;\n  float h_state[5] = {0, 0, 0, 0, 0};\n  float c_state[5] = {0, 0, 0, 0, 0};\n  float i_state[5] = {0, 0, 0, 0, 0};\n  float f_state[5] = {0, 0, 0, 0, 0};\n  float o_state[5] = {0, 0, 0, 0, 0};\n  float g_state[5] = {0, 0, 0, 0, 0};\n  for (t = 0; t < SAMPLE_TEST_LEN; ++t)\n  {\n    for (j = 0; j < 5; ++j)\n    {\n      i_state[j] = inW[j] * x[(gid * SAMPLE_TEST_LEN) + t];\n      for (i = 0; i < 5; ++i)\n        i_state[j] += h_state[i] * intW[(j * 5) + i];\n\n      i_state[j] += intB[j];\n      i_state[j] = sigmoid(i_state[j]);\n    }\n\n    for (j = 0; j < 5; ++j)\n    {\n      f_state[j] = inW[5 + j] * x[(gid * SAMPLE_TEST_LEN) + t];\n      for (i = 0; i < 5; ++i)\n        f_state[j] += h_state[i] * intW[(25 + (j * 5)) + i];\n\n      f_state[j] += intB[5 + j];\n      f_state[j] = sigmoid(f_state[j]);\n    }\n\n    for (j = 0; j < 5; ++j)\n    {\n      o_state[j] = inW[10 + j] * x[(gid * SAMPLE_TEST_LEN) + t];\n      for (i = 0; i < 5; ++i)\n        o_state[j] += h_state[i] * intW[(50 + (j * 5)) + i];\n\n      o_state[j] += intB[10 + j];\n      o_state[j] = sigmoid(o_state[j]);\n    }\n\n    for (j = 0; j < 5; ++j)\n    {\n      g_state[j] = inW[15 + j] * x[(gid * SAMPLE_TEST_LEN) + t];\n      for (i = 0; i < 5; ++i)\n        g_state[j] += h_state[i] * intW[(75 + (j * 5)) + i];\n\n      g_state[j] += intB[15 + j];\n      g_state[j] = tanhf(g_state[j]);\n    }\n\n    for (j = 0; j < 5; ++j)\n    {\n      c_state[j] = (c_state[j] * f_state[j]) + (g_state[j] * i_state[j]);\n      h_state[j] = tanhf(c_state[j]) * o_state[j];\n    }\n\n    y[(gid * SAMPLE_TEST_LEN) + t] = outB[0];\n    for (j = 0; j < 5; ++j)\n      y[(gid * SAMPLE_TEST_LEN) + t] += h_state[j] * outW[j];\n\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(WGS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/clink-omp/main/7"}
{"code": "for (i = 0; i < wh[1].size(); i++)\n{\n  temp = 0.0;\n  for (j = 0; j < wh.size(); j++)\n    temp += wh[j][i] * x[j];\n\n  temp += bh[i];\n  hidden[i] = sigmoid(temp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchParallel/6"}
{"code": "for (i = 0; i < 12; i++)\n{\n  for (j = 0; j < 12; j++)\n  {\n    for (k = 0; k < 12; k++)\n    {\n      tmp1 = 6.0 / m;\n      a[i][j][k] = tmp1 + 4;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,tmp1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB170-nestedloops-orig-no/0"}
{"code": "for (i = 0; i < g_n; i++)\n{\n  axi = 0.0;\n  for (j = 0; j < g_n; j++)\n  {\n    axi = axi + (g_a[i + (j * g_n)] * g_x_old[j]);\n  }\n\n  g_x[i] = g_x_old[i] + ((g_b[i] - axi) / g_a[i + (i * g_n)]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/jacobi/jacobi_kernel/1"}
{"code": "for (j = 1; j <= ny2; j++)\n{\n  double cv[PROBLEM_SIZE];\n  double rhos[PROBLEM_SIZE];\n  double lhs[IMAXP + 1][IMAXP + 1][5];\n  double lhsp[IMAXP + 1][IMAXP + 1][5];\n  double lhsm[IMAXP + 1][IMAXP + 1][5];\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      lhs[0][i][m] = 0.0;\n      lhsp[0][i][m] = 0.0;\n      lhsm[0][i][m] = 0.0;\n      lhs[nz2 + 1][i][m] = 0.0;\n      lhsp[nz2 + 1][i][m] = 0.0;\n      lhsm[nz2 + 1][i][m] = 0.0;\n    }\n\n    lhs[0][i][2] = 1.0;\n    lhsp[0][i][2] = 1.0;\n    lhsm[0][i][2] = 1.0;\n    lhs[nz2 + 1][i][2] = 1.0;\n    lhsp[nz2 + 1][i][2] = 1.0;\n    lhsm[nz2 + 1][i][2] = 1.0;\n  }\n\n  for (i = 1; i <= nx2; i++)\n  {\n    for (k = 0; k <= (nz2 + 1); k++)\n    {\n      ru1 = c3c4 * rho_i[k][j][i];\n      cv[k] = ws[k][j][i];\n      rhos[k] = max(max(dz4 + (con43 * ru1), dz5 + (c1c5 * ru1)), max(dzmax + ru1, dz1));\n    }\n\n    for (k = 1; k <= nz2; k++)\n    {\n      lhs[k][i][0] = 0.0;\n      lhs[k][i][1] = ((-dttz2) * cv[k - 1]) - (dttz1 * rhos[k - 1]);\n      lhs[k][i][2] = 1.0 + (c2dttz1 * rhos[k]);\n      lhs[k][i][3] = (dttz2 * cv[k + 1]) - (dttz1 * rhos[k + 1]);\n      lhs[k][i][4] = 0.0;\n    }\n\n  }\n\n  for (i = 1; i <= nx2; i++)\n  {\n    k = 1;\n    lhs[k][i][2] = lhs[k][i][2] + comz5;\n    lhs[k][i][3] = lhs[k][i][3] - comz4;\n    lhs[k][i][4] = lhs[k][i][4] + comz1;\n    k = 2;\n    lhs[k][i][1] = lhs[k][i][1] - comz4;\n    lhs[k][i][2] = lhs[k][i][2] + comz6;\n    lhs[k][i][3] = lhs[k][i][3] - comz4;\n    lhs[k][i][4] = lhs[k][i][4] + comz1;\n  }\n\n  for (k = 3; k <= (nz2 - 2); k++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      lhs[k][i][0] = lhs[k][i][0] + comz1;\n      lhs[k][i][1] = lhs[k][i][1] - comz4;\n      lhs[k][i][2] = lhs[k][i][2] + comz6;\n      lhs[k][i][3] = lhs[k][i][3] - comz4;\n      lhs[k][i][4] = lhs[k][i][4] + comz1;\n    }\n\n  }\n\n  for (i = 1; i <= nx2; i++)\n  {\n    k = nz2 - 1;\n    lhs[k][i][0] = lhs[k][i][0] + comz1;\n    lhs[k][i][1] = lhs[k][i][1] - comz4;\n    lhs[k][i][2] = lhs[k][i][2] + comz6;\n    lhs[k][i][3] = lhs[k][i][3] - comz4;\n    k = nz2;\n    lhs[k][i][0] = lhs[k][i][0] + comz1;\n    lhs[k][i][1] = lhs[k][i][1] - comz4;\n    lhs[k][i][2] = lhs[k][i][2] + comz5;\n  }\n\n  for (k = 1; k <= nz2; k++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      lhsp[k][i][0] = lhs[k][i][0];\n      lhsp[k][i][1] = lhs[k][i][1] - (dttz2 * speed[k - 1][j][i]);\n      lhsp[k][i][2] = lhs[k][i][2];\n      lhsp[k][i][3] = lhs[k][i][3] + (dttz2 * speed[k + 1][j][i]);\n      lhsp[k][i][4] = lhs[k][i][4];\n      lhsm[k][i][0] = lhs[k][i][0];\n      lhsm[k][i][1] = lhs[k][i][1] + (dttz2 * speed[k - 1][j][i]);\n      lhsm[k][i][2] = lhs[k][i][2];\n      lhsm[k][i][3] = lhs[k][i][3] - (dttz2 * speed[k + 1][j][i]);\n      lhsm[k][i][4] = lhs[k][i][4];\n    }\n\n  }\n\n  for (k = 0; k <= (grid_points[2] - 3); k++)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    for (i = 1; i <= nx2; i++)\n    {\n      fac1 = 1.0 / lhs[k][i][2];\n      lhs[k][i][3] = fac1 * lhs[k][i][3];\n      lhs[k][i][4] = fac1 * lhs[k][i][4];\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      }\n\n      lhs[k1][i][2] = lhs[k1][i][2] - (lhs[k1][i][1] * lhs[k][i][3]);\n      lhs[k1][i][3] = lhs[k1][i][3] - (lhs[k1][i][1] * lhs[k][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhs[k1][i][1] * rhs[k][j][i][m]);\n      }\n\n      lhs[k2][i][1] = lhs[k2][i][1] - (lhs[k2][i][0] * lhs[k][i][3]);\n      lhs[k2][i][2] = lhs[k2][i][2] - (lhs[k2][i][0] * lhs[k][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k2][j][i][m] = rhs[k2][j][i][m] - (lhs[k2][i][0] * rhs[k][j][i][m]);\n      }\n\n    }\n\n  }\n\n  k = grid_points[2] - 2;\n  k1 = grid_points[2] - 1;\n  for (i = 1; i <= nx2; i++)\n  {\n    fac1 = 1.0 / lhs[k][i][2];\n    lhs[k][i][3] = fac1 * lhs[k][i][3];\n    lhs[k][i][4] = fac1 * lhs[k][i][4];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    }\n\n    lhs[k1][i][2] = lhs[k1][i][2] - (lhs[k1][i][1] * lhs[k][i][3]);\n    lhs[k1][i][3] = lhs[k1][i][3] - (lhs[k1][i][1] * lhs[k][i][4]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhs[k1][i][1] * rhs[k][j][i][m]);\n    }\n\n    fac2 = 1.0 / lhs[k1][i][2];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k1][j][i][m] = fac2 * rhs[k1][j][i][m];\n    }\n\n  }\n\n  for (k = 0; k <= (grid_points[2] - 3); k++)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    for (i = 1; i <= nx2; i++)\n    {\n      m = 3;\n      fac1 = 1.0 / lhsp[k][i][2];\n      lhsp[k][i][3] = fac1 * lhsp[k][i][3];\n      lhsp[k][i][4] = fac1 * lhsp[k][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsp[k1][i][2] = lhsp[k1][i][2] - (lhsp[k1][i][1] * lhsp[k][i][3]);\n      lhsp[k1][i][3] = lhsp[k1][i][3] - (lhsp[k1][i][1] * lhsp[k][i][4]);\n      rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhsp[k1][i][1] * rhs[k][j][i][m]);\n      lhsp[k2][i][1] = lhsp[k2][i][1] - (lhsp[k2][i][0] * lhsp[k][i][3]);\n      lhsp[k2][i][2] = lhsp[k2][i][2] - (lhsp[k2][i][0] * lhsp[k][i][4]);\n      rhs[k2][j][i][m] = rhs[k2][j][i][m] - (lhsp[k2][i][0] * rhs[k][j][i][m]);\n      m = 4;\n      fac1 = 1.0 / lhsm[k][i][2];\n      lhsm[k][i][3] = fac1 * lhsm[k][i][3];\n      lhsm[k][i][4] = fac1 * lhsm[k][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsm[k1][i][2] = lhsm[k1][i][2] - (lhsm[k1][i][1] * lhsm[k][i][3]);\n      lhsm[k1][i][3] = lhsm[k1][i][3] - (lhsm[k1][i][1] * lhsm[k][i][4]);\n      rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhsm[k1][i][1] * rhs[k][j][i][m]);\n      lhsm[k2][i][1] = lhsm[k2][i][1] - (lhsm[k2][i][0] * lhsm[k][i][3]);\n      lhsm[k2][i][2] = lhsm[k2][i][2] - (lhsm[k2][i][0] * lhsm[k][i][4]);\n      rhs[k2][j][i][m] = rhs[k2][j][i][m] - (lhsm[k2][i][0] * rhs[k][j][i][m]);\n    }\n\n  }\n\n  k = grid_points[2] - 2;\n  k1 = grid_points[2] - 1;\n  for (i = 1; i <= nx2; i++)\n  {\n    m = 3;\n    fac1 = 1.0 / lhsp[k][i][2];\n    lhsp[k][i][3] = fac1 * lhsp[k][i][3];\n    lhsp[k][i][4] = fac1 * lhsp[k][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsp[k1][i][2] = lhsp[k1][i][2] - (lhsp[k1][i][1] * lhsp[k][i][3]);\n    lhsp[k1][i][3] = lhsp[k1][i][3] - (lhsp[k1][i][1] * lhsp[k][i][4]);\n    rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhsp[k1][i][1] * rhs[k][j][i][m]);\n    m = 4;\n    fac1 = 1.0 / lhsm[k][i][2];\n    lhsm[k][i][3] = fac1 * lhsm[k][i][3];\n    lhsm[k][i][4] = fac1 * lhsm[k][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsm[k1][i][2] = lhsm[k1][i][2] - (lhsm[k1][i][1] * lhsm[k][i][3]);\n    lhsm[k1][i][3] = lhsm[k1][i][3] - (lhsm[k1][i][1] * lhsm[k][i][4]);\n    rhs[k1][j][i][m] = rhs[k1][j][i][m] - (lhsm[k1][i][1] * rhs[k][j][i][m]);\n    rhs[k1][j][i][3] = rhs[k1][j][i][3] / lhsp[k1][i][2];\n    rhs[k1][j][i][4] = rhs[k1][j][i][4] / lhsm[k1][i][2];\n  }\n\n  k = grid_points[2] - 2;\n  k1 = grid_points[2] - 1;\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[k][i][3] * rhs[k1][j][i][m]);\n    }\n\n    rhs[k][j][i][3] = rhs[k][j][i][3] - (lhsp[k][i][3] * rhs[k1][j][i][3]);\n    rhs[k][j][i][4] = rhs[k][j][i][4] - (lhsm[k][i][3] * rhs[k1][j][i][4]);\n  }\n\n  for (k = grid_points[2] - 3; k >= 0; k--)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    for (i = 1; i <= nx2; i++)\n    {\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = (rhs[k][j][i][m] - (lhs[k][i][3] * rhs[k1][j][i][m])) - (lhs[k][i][4] * rhs[k2][j][i][m]);\n      }\n\n      rhs[k][j][i][3] = (rhs[k][j][i][3] - (lhsp[k][i][3] * rhs[k1][j][i][3])) - (lhsp[k][i][4] * rhs[k2][j][i][3]);\n      rhs[k][j][i][4] = (rhs[k][j][i][4] - (lhsm[k][i][3] * rhs[k1][j][i][4])) - (lhsm[k][i][4] * rhs[k2][j][i][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/25"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][1024];\n  int i;\n  int len[1];\n  unsigned char *pin[1];\n  unsigned char *pout[1];\n  for (i = 0; i < 1; ++i)\n  {\n    len[i] = strlen(saved_key[i + index]);\n    pin[i] = (unsigned char *) saved_key[i + index];\n    pout[i] = master[i];\n  }\n\n  pbkdf2_sha1_sse((const unsigned char **) pin, len, (unsigned char *) cur_salt->salt, 8, 1000, pout, 1024, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    SHA512_CTX ctx;\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, master[i], 1024);\n    SHA512_Final((unsigned char *) crypt_out[index + i], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/solarwinds_fmt_plug/1"}
{"code": "for (column = 0; column < (*width); column++)\n{\n  tmp = dst[column];\n  for (fixedy = column, y = 0; y < ringbufSize; y++, fixedy += *width)\n    ringbuf[y] = dst[fixedy];\n\n  for (position = column, row = 0; row < halfkRowPlusWidth; row += *width)\n  {\n    sum = 0.f;\n    for (x = 0; x < (halfkColumnPlus1 - fixedy); x++)\n      sum += kernel[x];\n\n    y = 1;\n    for (sum *= tmp; x < ksizeLimit; x++, y++)\n      sum += kernel[x] * ringbuf[y];\n\n    dst[position] = sum + (kernel[x] * ringbuf[y]);\n    position += *width;\n  }\n\n  for (fixedy = 1; row < ymax; row += *width)\n  {\n    sum = 0.f;\n    for (x = 0; x < (halfkColumnPlus1 - fixedy); x++)\n      sum += kernel[x] * tmp;\n\n    y = fixedy;\n    for (fixedy++; x < ksizeLimit; x++, y++)\n      sum += kernel[x] * ringbuf[y];\n\n    dst[position] = sum + (kernel[x] * ringbuf[y]);\n    position += *width;\n  }\n\n  tmp = ringbuf[ringbufSizeLimit];\n  temp = ksizeMinus2;\n  for (fixedy = ringbufMax; row < (*height); row += *width, temp--)\n  {\n    y = fixedy;\n    fixedy++;\n    sum = 0.f;\n    for (x = 0; x < temp; x++, y++)\n      sum += kernel[x] * ringbuf[y];\n\n    for (sum2 = 0.f; x < ksizePlus1; x++)\n      sum2 += kernel[x];\n\n    sum += sum2 * tmp;\n    dst[position] = sum;\n    position += *width;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 250; j++)\n  {\n    a[i][j] = i + j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wahmingchen/parallel-computing/matrix_multiplication_with_MPI/mpi_mm/2"}
{"code": "for (int i = 0; i < total; i++)\n{\n  penalties[i] = answers[i].task_penalty;\n  alignmentHash = calculate(alignmentHash.append(answers[i].task_hash));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/4"}
{"code": "for (int i = 2; i < argc; i++)\n{\n  if (string(argv[i]) == \"-s\")\n  {\n    silent = true;\n    continue;\n  }\n\n  if (string(argv[i]) == \"-gl\")\n  {\n    fType = GaussLow;\n    continue;\n  }\n\n  if (string(argv[i]) == \"-gh\")\n  {\n    fType = GaussHigh;\n    continue;\n  }\n\n  if (string(argv[i]) == \"-bl\")\n  {\n    fType = BattervortLow;\n    continue;\n  }\n\n  if (string(argv[i]) == \"-bh\")\n  {\n    fType = BattervortHigh;\n    continue;\n  }\n\n  printf(\"%s\\n\", helpString);\n  exit(1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/21"}
{"code": "for (int i = 0; i < ALTURA; ++i)\n{\n  for (int j = 0; j < ANCHURA; ++j)\n  {\n    buffer[((i * ANCHURA) + j) + ((ALTURA * ANCHURA) * 2)] = matrizPixeles[i][j].b;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danielsto/arcos-openmp/Paralela/ARCfmtut_par/5"}
{"code": "for (k = 0; k < np; k++)\n{\n  for (i = 0; i < nd; i++)\n  {\n    f[i + (k * nd)] = 0.0;\n  }\n\n  for (j = 0; j < np; j++)\n  {\n    if (k != j)\n    {\n      d = dist(nd, pos + (k * nd), pos + (j * nd), rij);\n      if (d < PI2)\n      {\n        d2 = d;\n      }\n      else\n      {\n        d2 = PI2;\n      }\n\n      pe = pe + (0.5 * pow(sin(d2), 2));\n      for (i = 0; i < nd; i++)\n      {\n        f[i + (k * nd)] = f[i + (k * nd)] - ((rij[i] * sin(2.0 * d2)) / d);\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < nd; i++)\n  {\n    ke = ke + (vel[i + (k * nd)] * vel[i + (k * nd)]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/md_open_mp/0"}
{"code": "for (k = 0; k < g->n[i].top; k++)\n  if (g->n[i].adj[k] == j)\n{\n  omp_unset_lock(&g->n[i].mutex);\n  return;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/sol/part3b.sol.2/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 100; j++)\n  {\n    int sum = 0;\n    for (int k = 0; k < 100; k++)\n    {\n      sum += a[i][k] * b[k][j];\n    }\n\n    c[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a,b,c)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/noah-vaati/OpenMP-Matrix-Multiplier/OpenMP Matrix Multiplication/q2/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%10f \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaokun-X/openmp_archive/merge/4"}
{"code": "for (int i = 0; i < ((strlen(string) - strlen(substring)) + 1); i++)\n{\n  int matches_count = 0;\n  for (int j = 0; j < strlen(substring); j++)\n  {\n    if (string[i + j] != substring[j])\n      break;\n\n    matches_count++;\n  }\n\n  if (matches_count == strlen(substring))\n  {\n    result = i;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task7/OpenMPtask7/0"}
{"code": "for (int k = 0; k < 1; k++)\n{\n  for (int i = 3; i <= (((int) height) + 2); i++)\n  {\n    for (int j = 3; j <= (((int) width) + 2); j++)\n    {\n      output_image[((((i - 3) * width) * 4) + ((j - 3) * 4)) + 0] = find_avg(i, j, 0, rgb_image, kernel);\n      output_image[((((i - 3) * width) * 4) + ((j - 3) * 4)) + 1] = find_avg(i, j, 1, rgb_image, kernel);\n      output_image[((((i - 3) * width) * 4) + ((j - 3) * 4)) + 2] = find_avg(i, j, 2, rgb_image, kernel);\n      output_image[((((i - 3) * width) * 4) + ((j - 3) * 4)) + 3] = 255;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/gaussianFilterOpenMP/3"}
{"code": "for (int i = 0; i < clusters_amount; i++)\n{\n  new_cluster[i].cluster_points = (Point *) realloc(new_cluster[i].cluster_points, (sizeof(Point)) * new_cluster[i].size);\n}\n\n", "pragma": "#pragma omp parallel for shared(new_cluster)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  diffsum += fabs(A[i] - B[i]);\n  sum += fabs(B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/axpy_ompacc/3"}
{"code": "for (row = 0; row < RowCount; row++)\n{\n  for (col = 0; col < ColCount; col++)\n  {\n    CellArray[row][col] = MiddleInit;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-omp-examples/heat1/4"}
{"code": "for (i3 = j + 1; i3 < N; i3++)\n{\n  a[i3][j] = a[i3][j] / local_a_jj;\n}\n\n", "pragma": "omp simd for private(i3) aligned(a:64) suitable(N)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/2"}
{"code": "for (int i = 0; i < n; i++)\n  random_vector.push_back(i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/natviv-zz/svm-dual-cd/cd-svm/0"}
{"code": "for (i = 0; i < num_its; i++)\n  cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, n, n, n, alpha, A, n, B, n, beta, C_itlmkl_cpumic, n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/7"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 4)\n    {\n      int pp = IDX(i, j, k);\n      if (betax[pp] > 0.0)\n      {\n        Dxu[pp] = ((((((-3.0) * u[pp - 1]) - (10.0 * u[pp])) + (18.0 * u[pp + 1])) - (6.0 * u[pp + 2])) + u[pp + 3]) * idx_by_12;\n      }\n      else\n      {\n        Dxu[pp] = (((((-u[pp - 3]) + (6.0 * u[pp - 2])) - (18.0 * u[pp - 1])) + (10.0 * u[pp])) + (3.0 * u[pp + 1])) * idx_by_12;\n      }\n\n      if (betax[pp + 1] > 0.0)\n      {\n        Dxu[pp + 1] = ((((((-3.0) * u[pp]) - (10.0 * u[pp + 1])) + (18.0 * u[pp + 2])) - (6.0 * u[pp + 3])) + u[pp + 4]) * idx_by_12;\n      }\n      else\n      {\n        Dxu[pp + 1] = (((((-u[pp - 2]) + (6.0 * u[pp - 1])) - (18.0 * u[pp])) + (10.0 * u[pp + 1])) + (3.0 * u[pp + 2])) * idx_by_12;\n      }\n\n      if (betax[pp + 2] > 0.0)\n      {\n        Dxu[pp + 2] = ((((((-3.0) * u[pp + 1]) - (10.0 * u[pp + 2])) + (18.0 * u[pp + 3])) - (6.0 * u[pp + 4])) + u[pp + 5]) * idx_by_12;\n      }\n      else\n      {\n        Dxu[pp + 2] = (((((-u[pp - 1]) + (6.0 * u[pp])) - (18.0 * u[pp + 1])) + (10.0 * u[pp + 2])) + (3.0 * u[pp + 3])) * idx_by_12;\n      }\n\n      if (betax[pp + 3] > 0.0)\n      {\n        Dxu[pp + 3] = ((((((-3.0) * u[pp + 2]) - (10.0 * u[pp + 3])) + (18.0 * u[pp + 4])) - (6.0 * u[pp + 5])) + u[pp + 6]) * idx_by_12;\n      }\n      else\n      {\n        Dxu[pp + 3] = (((((-u[pp]) + (6.0 * u[pp + 1])) - (18.0 * u[pp + 2])) + (10.0 * u[pp + 3])) + (3.0 * u[pp + 4])) * idx_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/24"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  processor *p = cur->data;\n  if (leader == (-1))\n    leader = p->x;\n\n  if (leader != p->x)\n  {\n    1(\"Node %d disagrees; wants %d as leader instead of %d\\n\", i, p->x, leader);\n    disagreement = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/leader_elect_dp/3"}
{"code": "for (i = 0; i < tile_dim; i++)\n  for (k = 0; k < tile_dim; k++)\n  local_ta[(i * tile_dim) + k] = target_tile[(i * tile_dim) + k];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rzambre/bspmm/bspmm_multiple/0"}
{"code": "forwardViterbi(subMat, transitionMat, emissionMat, obArray, size, start)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/6"}
{"code": "for (int idz = 0; idz < DATAZSIZE; idz++)\n{\n  for (int idy = 0; idy < DATAYSIZE; idy++)\n  {\n    for (int idx = 0; idx < DATAXSIZE; idx++)\n    {\n      f[idz][idy][idx] = freeEnergy(c[idz][idy][idx], e_AA, e_BB, e_AB) + ((gamma / 2.0) * (((GradientX(c, dx, dy, dz, idx, idy, idz) * GradientX(c, dx, dy, dz, idx, idy, idz)) + (GradientY(c, dx, dy, dz, idx, idy, idz) * GradientY(c, dx, dy, dz, idx, idy, idz))) + (GradientZ(c, dx, dy, dz, idx, idy, idz) * GradientZ(c, dx, dy, dz, idx, idy, idz))));\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/che-omp/main/1"}
{"code": "for (int g = 0; g < 2; g++)\n{\n  for (int i = 0; i <= N; i++)\n  {\n    Matrix[g][i][0] = 1.0 - (h * i);\n    Matrix[g][i][N] = h * i;\n    Matrix[g][0][i] = 1.0 - (h * i);\n    Matrix[g][N][i] = h * i;\n  }\n\n  Matrix[g][N][0] = 0.0;\n  Matrix[g][0][N] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/jacobi/2"}
{"code": "for (size_t i = 0; i < (network.size() - 1); i++)\n{\n  network[i].theta += adavec[i].adadelta_algorithm(network[i].grad, _gamma, _eplison);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatheusNBDG/Neural-Network/network/4"}
{"code": "for (i = 0; i < (mDIM * lDIM); i++)\n  posix_memalign((double **) (&a[i]), getpagesize(), (BSIZE * BSIZE) * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/16"}
{"code": "for (i = 0; i < n; i++)\n{\n  value = value + a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task2_simplex/simplex_modified_for_omp/simplex/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (E[(i * N) + j] != E_CLOUD[(i * N) + j])\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/16"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_updating_graph_mask[tid] == 1)\n  {\n    h_graph_mask[tid] = 1;\n    h_graph_visited[tid] = 1;\n    stop = 1;\n    h_updating_graph_mask[tid] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/bfs/src/bfs-AI-AI/7"}
{"code": "for (int i = 0; i < num_verts; ++i)\n  in_degree_list[i + 1] = in_degree_list[i] + temp_counts[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  TempX[i] = F[i];\n  for (g = 0; g < N; g++)\n  {\n    if (i != g)\n      TempX[i] -= A[i][g] * X[g];\n\n  }\n\n  TempX[i] /= A[i][i];\n}\n\n", "pragma": "    #pragma omp parallel for private(i,g,norm) shared(TempX)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nmatkheev/Jacobi_omp/main/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  arr[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/minimum_element_openmp_of_-a-_array/minElementRevised/1"}
{"code": "for (q = 0; q < 1024; q++)\n{\n  for (k = q + 1; k < 1024; k++)\n  {\n    x_diff = pos[q][0] - pos[k][0];\n    y_diff = pos[q][1] - pos[k][1];\n    z_diff = pos[q][2] - pos[k][2];\n    dist = sqrt(((x_diff * x_diff) + (y_diff * y_diff)) + (z_diff * z_diff));\n    dist_cubed = (dist * dist) * dist;\n    force_qk[0] = (((1 * masses[q]) * masses[k]) / dist_cubed) * x_diff;\n    force_qk[1] = (((1 * masses[q]) * masses[k]) / dist_cubed) * y_diff;\n    force_qk[2] = (((1 * masses[q]) * masses[k]) / dist_cubed) * z_diff;\n    loc_forces[my_rank][q][0] -= force_qk[0];\n    loc_forces[my_rank][q][1] -= force_qk[1];\n    loc_forces[my_rank][q][2] -= force_qk[2];\n    loc_forces[my_rank][k][0] += force_qk[0];\n    loc_forces[my_rank][k][1] += force_qk[1];\n    loc_forces[my_rank][k][2] += force_qk[2];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwwwwwOwO/Parallel-program/nbody/OpenMP_solver/1"}
{"code": "for (unsigned int i = 0; i < travel.flights.size(); i++)\n{\n  result += travel.flights[i].cost * travel.flights[i].discout;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoLR548/CPguacamole/Tarefa12/main/0"}
{"code": "for (int j = 1; j < (nj - 1); j++)\n{\n  for (int i = 1; i < (ni - 1); i++)\n  {\n    int i00 = i + (ni * j);\n    int im10 = (i - 1) + (ni * j);\n    int ip10 = (i + 1) + (ni * j);\n    int i0m1 = i + (ni * (j - 1));\n    int i0p1 = i + (ni * (j + 1));\n    double d2tdx2 = (temp_in[im10] - (2 * temp_in[i00])) + temp_in[ip10];\n    double d2tdy2 = (temp_in[i0m1] - (2 * temp_in[i00])) + temp_in[i0p1];\n    temp_out[i00] = temp_in[i00] + (tfac * (d2tdx2 + d2tdy2));\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcarter108/cisc372_proj/heat_omp/0"}
{"code": "for (int jj = 0; jj < N; jj++)\n  myresult += heavy_work_0(array[jj]);\n\n", "pragma": "omp parallel for reduction(+:myresult)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_sections/01_sections_nested/0"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n    for (int k = 0; k < nzn; k++)\n  {\n    pZZsn[is][i][j][k] += invVOL * moments[i][j][k][9];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/11"}
{"code": "for (j = 0; j < nrows; j++)\n{\n  if (j > 0)\n  {\n    j1 = rowstr[j] - nzloc[j - 1];\n  }\n  else\n  {\n    j1 = 0;\n  }\n\n  j2 = rowstr[j + 1] - nzloc[j];\n  nza = rowstr[j];\n  for (k = j1; k < j2; k++)\n  {\n    a[k] = v[nza];\n    colidx[k] = iv[nza];\n    nza = nza + 1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/13"}
{"code": "for (int i = 0; i < v2; i++)\n  smoother7p_3dfun(array3d, N, function_3d);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/multigrid/5"}
{"code": "for (int k = 0; k < 10; ++k)\n{\n  for (int i = 0; i < argc; ++i)\n    foo();\n\n}\n\n", "pragma": "  #pragma omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/teams_distribute_private_messages/0"}
{"code": "for (k = 3 * 1; k <= ((grid_points[2] - 3) - 1); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/144"}
{"code": "for (int k = 0; k < 4; k++)\n  for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    matrix_local[i][j][k] = 0.0;\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/0"}
{"code": "for (i = 0; i < ncand; i++)\n  cand[i].key = cand[i].key / ((rsums[cand[i].val] + mysum) - cand[i].key);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/33"}
{"code": "for (int j = 0; j < n; j++)\n{\n  A[j][0] = 1.0;\n  Anew[j][0] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbertDeFusco/openmp-workshop/src/laplace2d/laplace2d/0"}
{"code": "for (j = 1; j < (Ny - 1); j++)\n{\n  for (i = 1; i < (Nx - 1); i++)\n  {\n    Un[i][j] = (((I[i][j] + (dt * V[i][j])) + (((((I[i + 1][j] - (2. * I[i][j])) + I[i - 1][j]) * cx) * cx) / 2.)) + (((((I[i][j + 1] - (2. * I[i][j])) + I[i][j - 1]) * cy) * cy) / 2.)) + (((((dt * dt) * c) * c) * (1. + (1.0 / 2.))) * ((Y[j] * (Ly - Y[j])) + (X[i] * (Lx - X[i]))));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saggelit/OpenMp/project2020parallel/4"}
{"code": "for (i = k + 1; i <= (n - 1); i++)\n{\n  L[i][k] = A[i][k] / A[k][k];\n  for (j = k; j <= (n - 1); j++)\n  {\n    A[i][j] = A[i][j] - (L[i][k] * A[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(L,A) private(j,i) schedule(guided)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markopand/Code/LU algorithm OpenMP/0"}
{"code": "for (int i = 0; i < N; i++)\n  result += x[i] * y[i];\n\n", "pragma": "    #pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment6/mini_app/linalg/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    unsigned int neighbors = countNeighbors(board, size, size, i, j);\n    if (board[i][j] == ' ')\n    {\n      if (neighbors == 3)\n      {\n        auxBoard[i][j] = 'x';\n      }\n      else\n      {\n        auxBoard[i][j] = ' ';\n      }\n\n    }\n    else\n    {\n      if ((neighbors < 2) || (neighbors > 3))\n      {\n        auxBoard[i][j] = ' ';\n      }\n      else\n      {\n        auxBoard[i][j] = 'x';\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(h,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bernardoduarte/PPD/OpenMP/assignments/02_game_of_life/prog/0"}
{"code": "for (currentPoint = 0; currentPoint < N; ++currentPoint)\n{\n  ompThreadId = omp_get_thread_num();\n  step = ompThreadId * K;\n  nextPointIndex = currentPoint + 1;\n  while (nextPointIndex < N)\n  {\n    if (pointToClusterMapping[nextPointIndex] != pointToClusterMapping[currentPoint])\n    {\n      nextPointIndex++;\n      continue;\n    }\n\n    int index = 0;\n    double expoDistance = 0;\n    while (index < DIMENSIONS)\n    {\n      double *firstPoint = pointsArray + (currentPoint * DIMENSIONS);\n      double *secondPoint = pointsArray + (nextPointIndex * DIMENSIONS);\n      double oneLine = firstPoint[index] - secondPoint[index];\n      expoDistance += oneLine * oneLine;\n      index++;\n    }\n\n    distance = sqrt(expoDistance);\n    int currentThreadIndex = step + pointToClusterMapping[currentPoint];\n    if (distance > threadForCalcDiameters[currentThreadIndex])\n      threadForCalcDiameters[currentThreadIndex] = distance;\n\n    nextPointIndex++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(ompThreadId,nextPointIndex,step,distance) shared(threadForCalcDiameters)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Oreldm/KMeans-Parallel-Programming/Parallel_kMeans_204739825/Parallel_kMeans_204739825/main/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  const double *point = getPointAt(points, i);\n  calcResults[i] = prediction(weights, *w0, point, k);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yotamMoshe7/C-Classification-Problem-Precepton/MPI_OMP_CUDA/PerceptronClassification/4"}
{"code": "for (unsigned I = First; I < Last; ++I)\n{\n  if (find(S, E, I) != E)\n  {\n    --Skipped;\n    continue;\n  }\n\n  ((Out << \"'\") << getOpenMPSimpleClauseTypeName(K, I)) << \"'\";\n  if (((I + Skipped) + 2) == Last)\n    Out << \" or \";\n  else\n    if (((I + Skipped) + 1) != Last)\n    Out << \", \";\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/lib/Sema/SemaOpenMP/2"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n  count[(arr[i] / exp) % 10]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/6"}
{"code": "for (cRow = 0; cRow < locRows; cRow++)\n{\n  MPI_File_seek(imgf, ((initRow + cRow) * (3 * totalCols)) + initCol, MPI_SEEK_SET);\n  cpoint = &img[(cRow * (3 * (locCols + 2))) + 3];\n  MPI_File_write(imgf, cpoint, locCols, (MPI_Datatype) 0x4c00010d, (MPI_Status *) 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/odygsim/parallelImageConvolution/op_mpi_image_conv/7"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (i = 0; i < fftblock; i++)\n  {\n    xout[k][j][i + ii].real = y0[k][i].real;\n    xout[k][j][i + ii].imag = y0[k][i].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,ii ,x ,fftblock ,k ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/14"}
{"code": "for (int i = 0; i < numsOfParts[indexGroup - 1]; i++)\n{\n  if (island[i + explored] == 1)\n  {\n    found = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/5"}
{"code": "for (int py = 0; py < nPixX; py++)\n{\n  for (int px = 0; px < nPixY; px++)\n  {\n    const int pos = (((nPixX * nPixY) * nz) + (py * nPixY)) + px;\n    int coordA = (py * nPixYMap) + px;\n    int coordB = ((py + 1) * nPixYMap) + px;\n    int coordC = coordA + 1;\n    int coordD = coordB + 1;\n    double gamma = atan(((d_pObjX[py] + (dx / 2.0)) - tubeX) / (rtubeZ - d_pObjZ[nz]));\n    double alpha = atan(((d_pObjY[px] + (dy / 2.0)) - rtubeY) / (rtubeZ - d_pObjZ[nz]));\n    double dA;\n    double dB;\n    double dC;\n    double dD;\n    dA = d_sliceI[coordA];\n    dB = d_sliceI[coordB];\n    dC = d_sliceI[coordC];\n    dD = d_sliceI[coordD];\n    if ((dC == 0) && (dD == 0))\n    {\n      dC = dA;\n      dD = dB;\n    }\n\n    d_pVolume[pos] += (((dD - dC) - dB) + dA) * (((du * dv) * dz) / (((cos(alpha) * cos(gamma)) * dx) * dy));\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/7"}
{"code": "for (int i = 0; i < groupSize; i++)\n{\n  if (strchr(group[i], *charSeq1) && strchr(group[i], *mutantChar))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shabtai204/Parallel-implementation-of-Sequence-Alignment/OpenMP/3"}
{"code": "for (int i = 0; i < 60000; i++)\n{\n  activateNN(data_train[i]);\n  evaluate(class_train[i], confusionMatrixTrain);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/11"}
{"code": "for (int k = 0; k < 1000000; ++k)\n{\n  sum += arr[k];\n}\n\n", "pragma": "omp parallel for num_threads(3) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/lab6ex2/0"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/85"}
{"code": "for (int k = 0; k < ACols; ++k)\n{\n  value += matrixA[(i * ACols) + k] * matrixB[(k * BCols) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/hip-openmp/matrixmul_omp_for/matrixmul/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp94cyhj_e.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/projects/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (int i = 0; i < 5001; i++)\n{\n  histogram[i] = 0;\n  histogramAns[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parhamDm/omp-histogram/histogram/histogram/0"}
{"code": "for (int i = 0; i < 256; i++)\n  if (a[i] != (((((i & 3) == 0) && (i >= 8)) && (i < (8 + (48 * 4)))) ? (((i - 8) / 4) + 16) : (0)))\n  __builtin_abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/linear-1/6"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  for (j = 0; j < 10; ++j)\n  {\n    for (k = 0; k < 10; ++k)\n      x[i][j][k] = k;\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr56883/3"}
{"code": "for (iel = 0; iel < neltold; iel++)\n{\n  if (!skip[iel])\n  {\n    ich[iel] = 0;\n    if (!iftouch(iel))\n    {\n      iftemp = 0;\n      for (i = 0; i < NSIDES; i++)\n      {\n        if (cbc[iel][i] == 3)\n        {\n          iftemp = 1;\n        }\n\n      }\n\n      if (!iftemp)\n      {\n        if (!(*if_coarsen))\n          *if_coarsen = 1;\n\n        ich[iel] = 2;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(iel,i,iftemp) shared(if_coarsen)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/11"}
{"code": "for (i = 0; i < total_gpudevs; i++)\n  gpu_selection[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/runtime/homp_dev/2"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm512_set1_epi32(noff);\n  v_moff = _mm512_set1_epi32(moff);\n  v_loff = _mm512_set1_epi32(loff);\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  v_edgelx = _mm512_set1_ps(edgelx);\n  v_edgely = _mm512_set1_ps(edgely);\n  v_edgelz = _mm512_set1_ps(edgelz);\n  v_edgerx = _mm512_set1_ps(edgerx);\n  v_edgery = _mm512_set1_ps(edgery);\n  v_edgerz = _mm512_set1_ps(edgerz);\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  nps = 4 * (nn / 4);\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &fxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &fxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sfxyz[m], v_at);\n        _mm512_packstorehi_ps(&sfxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  memset((void *) (&ncl[26 * l]), 0, 26 * (sizeof(int)));\n  nps = 16 * (npp / 16);\n  sum1 = 0.0;\n  v_sum1 = _mm512_set1_pd(0.0);\n  for (j = 0; j < nps; j += 16)\n  {\n    v_x = _mm512_load_ps(&ppart[j + npoff]);\n    v_y = _mm512_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_z = _mm512_load_ps(&ppart[(j + (2 * nppmx)) + npoff]);\n    v_nn = _mm512_cvtfxpnt_round_adjustps_epi32(v_x, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_mm = _mm512_cvtfxpnt_round_adjustps_epi32(v_y, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_ll = _mm512_cvtfxpnt_round_adjustps_epi32(v_z, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_nn, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_sub_ps(v_x, v_dxp);\n    v_dyp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_mm, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dyp = _mm512_sub_ps(v_y, v_dyp);\n    v_dzp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_ll, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dzp = _mm512_sub_ps(v_z, v_dzp);\n    v_nn = _mm512_sub_epi32(v_nn, v_noff);\n    v_mm = _mm512_sub_epi32(v_mm, v_moff);\n    v_ll = _mm512_sub_epi32(v_ll, v_loff);\n    v_it = _mm512_mullo_epi32(v_mxyv4, v_ll);\n    v_it = _mm512_add_epi32(v_it, _mm512_mullo_epi32(v_mxv4, v_mm));\n    v_nn = _mm512_add_epi32(_mm512_slli_epi32(v_nn, 2), v_it);\n    v_amx = _mm512_sub_ps(v_one, v_dxp);\n    v_amy = _mm512_sub_ps(v_one, v_dyp);\n    v_amz = _mm512_sub_ps(v_one, v_dzp);\n    v_dx1 = _mm512_mul_ps(v_dxp, v_dyp);\n    v_dyp = _mm512_mul_ps(v_amx, v_dyp);\n    v_amx = _mm512_mul_ps(v_amx, v_amy);\n    v_amy = _mm512_mul_ps(v_dxp, v_amy);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_mul_ps(v_amx, a);\n    v_dx = _mm512_fmadd_ps(v_amy, p, v_dx);\n    v_dy = _mm512_mul_ps(v_amx, b);\n    v_dy = _mm512_fmadd_ps(v_amy, q, v_dy);\n    v_dz = _mm512_mul_ps(v_amx, c);\n    v_dz = _mm512_fmadd_ps(v_amy, r, v_dz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_fmadd_ps(v_dyp, a, v_dx);\n    v_dx = _mm512_fmadd_ps(v_dx1, p, v_dx);\n    v_dx = _mm512_mul_ps(v_amz, v_dx);\n    v_dy = _mm512_fmadd_ps(v_dyp, b, v_dy);\n    v_dy = _mm512_fmadd_ps(v_dx1, q, v_dy);\n    v_dy = _mm512_mul_ps(v_amz, v_dy);\n    v_dz = _mm512_fmadd_ps(v_dyp, c, v_dz);\n    v_dz = _mm512_fmadd_ps(v_dx1, r, v_dz);\n    v_dz = _mm512_mul_ps(v_amz, v_dz);\n    v_nn = _mm512_add_epi32(v_nn, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_dx = _mm512_fmadd_ps(v_dzp, v_vx, v_dx);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_dy = _mm512_fmadd_ps(v_dzp, v_vy, v_dy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_dz = _mm512_fmadd_ps(v_dzp, v_vz, v_dz);\n    v_dxp = _mm512_load_ps(&ppart[(j + (3 * nppmx)) + npoff]);\n    v_dyp = _mm512_load_ps(&ppart[(j + (4 * nppmx)) + npoff]);\n    v_dzp = _mm512_load_ps(&ppart[(j + (5 * nppmx)) + npoff]);\n    v_vx = _mm512_fmadd_ps(v_qtm, v_dx, v_dxp);\n    v_vy = _mm512_fmadd_ps(v_qtm, v_dy, v_dyp);\n    v_vz = _mm512_fmadd_ps(v_qtm, v_dz, v_dzp);\n    v_dxp = _mm512_add_ps(v_dxp, v_vx);\n    v_dyp = _mm512_add_ps(v_dyp, v_vy);\n    v_dzp = _mm512_add_ps(v_dzp, v_vz);\n    v_at = _mm512_mul_ps(v_dxp, v_dxp);\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dyp, v_dyp));\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dzp, v_dzp));\n    v_sum1 = _mm512_add_pd(v_sum1, _mm512_cvtpslo_pd(v_at));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_at, 78));\n    v_sum1 = _mm512_add_pd(v_sum1, v_d);\n    v_dx = _mm512_fmadd_ps(v_vx, v_dt, v_x);\n    v_dy = _mm512_fmadd_ps(v_vy, v_dt, v_y);\n    v_dz = _mm512_fmadd_ps(v_vz, v_dt, v_z);\n    v_mm = _mm512_setzero_epi32();\n    msk1 = _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dx;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_1, v_1);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dx, v_anx, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dx, v_anx);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_1);\n        msk2 = _mm512_cmp_ps_mask(v_dx, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dx, v_anx);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anx, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dy;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_3, v_3);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dy, v_any, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dy, v_any);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_3);\n        msk2 = _mm512_cmp_ps_mask(v_dy, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dy, v_any);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_any, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dz;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_9, v_9);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dz, v_anz, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dz, v_anz);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_9);\n        msk2 = _mm512_cmp_ps_mask(v_dz, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dz, v_anz);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anz, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n    }\n\n    _mm512_store_ps(&ppart[j + npoff], v_dx);\n    _mm512_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm512_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_dz);\n    _mm512_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vx);\n    _mm512_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vy);\n    _mm512_store_ps(&ppart[(j + (5 * nppmx)) + npoff], v_vz);\n    _mm512_store_epi32(kk, v_mm);\n    for (i = 0; i < 16; i++)\n    {\n      mm = kk[i];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + i) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nn = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    dx = amz * ((dx + (dyp * sfxyz[nn + (4 * mxv)])) + (dx1 * sfxyz[(nn + (4 * mxv)) + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[(nn + (4 * mxv)) + 1])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[(nn + (4 * mxv)) + 2])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 2) + 4]));\n    mm = nn + (4 * mxyv);\n    vx = (amx * sfxyz[mm]) + (amy * sfxyz[mm + 4]);\n    vy = (amx * sfxyz[mm + 1]) + (amy * sfxyz[(mm + 1) + 4]);\n    vz = (amx * sfxyz[mm + 2]) + (amy * sfxyz[(mm + 2) + 4]);\n    dx = dx + (dzp * ((vx + (dyp * sfxyz[mm + (4 * mxv)])) + (dx1 * sfxyz[(mm + (4 * mxv)) + 4])));\n    dy = dy + (dzp * ((vy + (dyp * sfxyz[(mm + (4 * mxv)) + 1])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 1) + 4])));\n    dz = dz + (dzp * ((vz + (dyp * sfxyz[(mm + (4 * mxv)) + 2])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 2) + 4])));\n    dxp = ppart[(j + (3 * nppmx)) + npoff];\n    dyp = ppart[(j + (4 * nppmx)) + npoff];\n    dzp = ppart[(j + (5 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    vz = dzp + (qtm * dz);\n    dxp += vx;\n    dyp += vy;\n    dzp += vz;\n    sum1 += ((dxp * dxp) + (dyp * dyp)) + (dzp * dzp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    dz = z + (vz * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  _mm512_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,ii,noff,moff,loff,npp,npoff,nps,nn,mm,ll,ih,nh,x,y,z, dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,vx,vy,vz,edgelx,edgely,edgelz, edgerx,edgery,edgerz,sum1,v_noff,v_moff,v_loff,v_nn,v_mm,v_ll,v_it,v_x, v_y,v_z,v_dxp,v_dyp,v_dzp,v_amx,v_amy,v_amz,v_dx1,v_dx,v_dy,v_dz,v_vx, v_vy,v_vz,v_at,v_edgelx,v_edgely,v_edgelz,v_edgerx,v_edgery,v_edgerz, v_d,v_sum1,a,b,c,d,e,f,g,p,q,r,s,msk1,msk2,kk,dd,sfxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic3/kncmpush3/1"}
{"code": "for (int row = 0; row < n; row++)\n{\n  (cout << vec[row]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/par_matrix_vect_mul/3"}
{"code": "for (int i = 0; i < (piratesInGroups.size() - 1); i++)\n{\n  ((cout << \"\u041d\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043e \u0435\u0449\u0451 \") << unsearched) << \" \u043a\u0432\u0430\u0434\u0440\u0430\u0442. \u043c. \u043e\u0441\u0442\u0440\u043e\u0432\u0430. \\n\";\n  ((cout << \"\u041d\u0430\u0437\u043d\u0430\u0447\u044c\u0442\u0435 \u0433\u0440\u0443\u043f\u043f\u0435 \u2116\") << (i + 1)) << \" \u0440\u0430\u0437\u043c\u0435\u0440 \u0443\u0447\u0430\u0441\u0442\u043a\u0430 \u043e\u0441\u0442\u0440\u043e\u0432\u0430 (1 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e): \";\n  cin >> input;\n  area = repeatInput(checkInput(input));\n  while ((area > unsearched) || (area > ((width * height) / numberGroups)))\n  {\n    ((cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0431\u043e\u043b\u044c\u0448\u043e\u0435 \u0447\u0438\u0441\u043b\u043e. \u0417\u0430\u043c\u0435\u0447\u0430\u043d\u0438\u0435: \u0433\u0440\u0443\u043f\u043f\u0435 \u043d\u0435\u043b\u044c\u0437\u044f \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0435 \") << ((width * height) / numberGroups)) << \" \u043a\u0432. \u043c. \\n\";\n    cout << \"\u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0451 \u0440\u0430\u0437: \";\n    cin >> input;\n    area = repeatInput(checkInput(input));\n  }\n\n  numsOfParts.push_back(area);\n  unsearched -= area;\n  cout << \"\\n \\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/3"}
{"code": "for (int j = 0; j < ndr; j++)\n{\n  for (int i = 0; i < P; i++)\n  {\n    double temp = B(i, j);\n    NewB(i, j) = B(i, j) + epsilon;\n    G(i, j) = (local_f(NewB, X, Y, bw, ncore) - F0) / epsilon;\n    NewB(i, j) = temp;\n  }\n\n}\n\n", "pragma": "  #pragma omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_local_solver/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    YTF[i][j] = YF[j][i];\n    YTD[i][j] = YD[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yemrecakir/ParalelMatrisCarpimi/Blockmatrixopenmp/Blockmatrixopenmp/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/79"}
{"code": "for (index = 0; index < count; index += SIMD_PARA_SHA1 * SIMD_COEF_32)\n{\n  SHA_CTX ctx;\n  if (new_keys)\n  {\n    SHA1_Init(&ipad_ctx[index]);\n    SHA1_Update(&ipad_ctx[index], ipad[index], 64);\n    SHA1_Init(&opad_ctx[index]);\n    SHA1_Update(&opad_ctx[index], opad[index], 64);\n  }\n\n  memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n  SHA1_Update(&ctx, cur_salt.salt, cur_salt.length);\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n  memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n  SHA1_Update(&ctx, crypt_key[index], 20);\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/rakp_fmt_plug/3"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 1 * 3; j <= ((grid_points[1] - (3 * 1)) - 1); j++)\n  {\n    forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/7"}
{"code": "for (k = i + 1; k < m; k++)\n{\n  if (max.val < fabs(a[k][i]))\n  {\n    max.val = fabs(a[k][i]);\n    max.index = k;\n  }\n\n}\n\n", "pragma": "omp parallel for private(k) reduction(maximum:max)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaeldcampbell/GaussianEliminationParallel/src/openMPGaussianElimination/0"}
{"code": "for (i = 0; i < index; i++)\n{\n  city_prob[i] /= sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/13"}
{"code": "for (l = 0; l < D3; l++)\n{\n  double count;\n  __sumskipnan2wer__(LInput + (l * D2), D2, LOutputSum + l, &count, &flag_isNaN, W);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/sumskipnan_mex/14"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((pos >> i) & 1)\n  {\n    p = 1 << i;\n    int t = dfs(lv + 1, row | p, (dia1 | p) << 1, (dia2 | p) >> 1, mask);\n    sum += t;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, chunk) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yatin2410/HPC_N_QUEENS/For_Cluster/201601454-201601458-nqueen-design3/parallel_measurement/0"}
{"code": "for (i = 0; i < 11; i++)\n{\n  printf(\"Static1 Hello World %d\\n\", i);\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-dynamic/1"}
{"code": "for (int ii = 1; ii < nR; ++ii)\n{\n  real_t r = x0 + (ii * dR);\n  buf[ii] /= r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/5"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t i;\n  for (i = 0; i < totalPartitions; ++i)\n  {\n    uint32_t k;\n    uint32_t src;\n    uint32_t dest;\n    float weight = 0.0001f;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      src = partition->edgeList->edges_array_src[k];\n      dest = partition->edgeList->edges_array_dest[k];\n      weight = partition->edgeList->edges_array_weight[k];\n      stats->vector_output[dest] += weight * stats->vector_input[src];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/21"}
{"code": "for (int j = 1; j < sum; j++)\n{\n  if ((j <= m) && ((sum - j) <= n))\n  {\n    if (ar[j - 1] == br[(sum - j) - 1])\n    {\n      C[((j * n) + sum) - j] = C[((((j - 1) * n) + sum) - j) - 1] + 1;\n    }\n    else\n    {\n      C[((j * n) + sum) - j] = max(C[(((j * n) + sum) - j) - 1], C[(((j - 1) * n) + sum) - j]);\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp for schedule(runtime) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shiva49814/OpenMPTasks/LCS/4"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  max_value = (arr[i] > max_value) ? (arr[i]) : (max_value);\n}\n\n", "pragma": "#pragma omp parallel for reduction(max: max_value)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gomathi18/parallel-counting-sort/main/3"}
{"code": "for (int i = 0; i < getVertexNumber(gr); i++)\n{\n  F[i] = 0;\n  X[i] = 0;\n  C[i] = -1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/1"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    A[i][j] = ((double) (rand() % 100)) / 10.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Matmul/Solutions/matmul_recur_par/4"}
{"code": "for (int i = 0; i < get_npart(); ++i)\n{\n  particles_[i].mass = n * unif_d(gen);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nbody-omp/GSimulation/3"}
{"code": "for (i = n - 1; 0 <= i; i--)\n{\n  bvec[i] = i4 % 2;\n  i4 = i4 / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/15"}
{"code": "for (long idx_x = 0; idx_x < NUM_X; idx_x++)\n{\n  for (long idx_y = 0; idx_y < NUM_Y; idx_y++)\n  {\n    long sum = 0;\n    for (long mul_slice = 0; mul_slice < NUM_X; mul_slice++)\n      sum += m1[mul_slice][idx_y] * m2[idx_x][mul_slice];\n\n    m3[idx_x][idx_y] = sum;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex6_2_easy_MatMul/2"}
{"code": "for (uint16_t i = 0; i < n_groups; ++i)\n{\n  for (uint32_t j = 0; j < n_obs; ++j)\n  {\n    gamma_Z(i, j) -= m[j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/rcg/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  points.push_back(&pts.at(j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/9"}
{"code": "for (uint32_t l = 0; l < nnz; l++)\n  col[col_coo[l] - isOneBased]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v3/v3_omp/3"}
{"code": "for (int j = 0; j < 2048; ++j)\n{\n  count1[center[j]]++;\n  for (int m = 0; m < 256; m++)\n  {\n    tep[center[j]].elements[m] += point[j].elements[m] * 100000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+kmeans/9"}
{"code": "for (i = 0; i < num_of_clusters; i++)\n{\n  if (counts[i] <= 1)\n  {\n    memcpy(c[i], c1[i], (sizeof(double)) * dimension);\n  }\n  else\n  {\n    for (j = 0; j < dimension; j++)\n    {\n      c[i][j] = c1[i][j] / counts[i];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/OpenMP version/kmeans/0"}
{"code": "for (i = 0; i < 10; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/o5logon_fmt_plug/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  tmp_orgn2ch[CVT_INT(m_subbsnID[i])] += m_surfRfSedOrgN[i];\n  tmp_orgp2ch[CVT_INT(m_subbsnID[i])] += m_surfRfSedOrgP[i];\n  tmp_minpa2ch[CVT_INT(m_subbsnID[i])] += m_surfRfSedAbsorbMinP[i];\n  tmp_minps2ch[CVT_INT(m_subbsnID[i])] += m_surfRfSedSorbMinP[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrSED/NutrientTransportSediment/3"}
{"code": "for (int i = 0, j = 0; i < this->nrow_; ++i)\n{\n  if (cast_agg->vec_[i] >= 0)\n  {\n    col[j] = cast_agg->vec_[i];\n    val[j] = 1.0;\n    ++j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/94"}
{"code": "for (n = 0; n <= 4; n += 1)\n{\n  lhs[i][j][k][0][m][n] = 0.0;\n  lhs[i][j][k][1][m][n] = 0.0;\n  lhs[i][j][k][2][m][n] = 0.0;\n}\n\n", "pragma": "omp parallel for private (n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/47"}
{"code": "for (int i = 0; i < V; i++)\n{\n  for (int j = 0; j < V; j++)\n  {\n    if (dist[i][j] != INF)\n      (((((cout << i) << \" -> \") << j) << \" : \") << dist[i][j]) << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  c[i][j] += a[j][k] * b[k][j];\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/threeparallel/2"}
{"code": "for (i = 0; i < 4000;)\n{\n  for (j = 0; j < 4000;)\n  {\n    B[i][j] = ((((double) i) * j) + 1) / 4000;\n    j++;\n  }\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdruix/OMP2MPI/trans/test/2"}
{"code": "for (k = 0; k < 256; k++)\n{\n}\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dumitrux/Parallelism-FIB/Laboratorio/Lab1/Material-lab1/lab1/3dfft/3dfft_omp/5"}
{"code": "for (int i = j * NN; i < ((j + 1) * NN); i++)\n{\n  Res[i] = i;\n  CUs[i] = omp_ext_get_smid();\n  if (i == 1)\n    printf(\"i= %d\\n\", i);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/Threads1xxx/Threads1xxx/0"}
{"code": "for (i = 0; i < mat2_1d; i++)\n{\n  matr2[i] = malloc(mat2_2d * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (k = 0; k < n; k++)\n  {\n    c2[i][j] += a[i][k] * b[k][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DelSquared/OpenMP-Matrix-Multiplication-Parallelisation-Comarison/Tests/AlgorithmTest/1"}
{"code": "for (unsigned int i = 0; i < (((L / NODESX) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((L / 5) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/112"}
{"code": "for (i = 0; i < K_global; i++)\n  points_inside_cluster_count[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/3"}
{"code": "for (int i = 0; i < vector.size(); i++)\n{\n  (cout << vector[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/7"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixMul/matrixMul_openMP/0"}
{"code": "for (i = 0; i < l; i++)\n  sum_alpha += alpha[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/25"}
{"code": "for (int i = 0; i < num_inner_loop_instructions; ++i)\n{\n  vmovntdq(ptr[rdi + (i * 64)], zmm0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/3"}
{"code": "for (i = 0; i < real_colli; i++)\n{\n  colli = colli_time + colli_queue[i];\n  if (colli->pa == (-1))\n  {\n    P_a = particles + colli->pb;\n    P_a->vx = (-1) * P_a->vx;\n    P_a->vy = (-1) * P_a->vy;\n    P_a->x_n = P_a->x + ((1 - (2 * colli->time)) * P_a->vx);\n    P_a->y_n = P_a->y + ((1 - (2 * colli->time)) * P_a->vy);\n    bound_pos(P_a);\n  }\n  else\n    if (colli->pa == (-2))\n  {\n    P_a = particles + colli->pb;\n    P_a->vx = (-1) * P_a->vx;\n    P_a->x_n = P_a->x + ((1 - (2 * colli->time)) * P_a->vx);\n    P_a->y_n = P_a->y + P_a->vy;\n    bound_pos(P_a);\n  }\n  else\n    if (colli->pa == (-3))\n  {\n    P_a = particles + colli->pb;\n    P_a->vy = (-1) * P_a->vy;\n    P_a->y_n = P_a->y + ((1 - (2 * colli->time)) * P_a->vy);\n    P_a->x_n = P_a->x + P_a->vx;\n    bound_pos(P_a);\n  }\n  else\n  {\n    P_a = particles + colli->pa;\n    P_b = particles + colli->pb;\n    P_a->x_n = P_a->x + (colli->time * P_a->vx);\n    P_a->y_n = P_a->y + (colli->time * P_a->vy);\n    P_b->x_n = P_b->x + (colli->time * P_b->vx);\n    P_b->y_n = P_b->y + (colli->time * P_b->vy);\n    Dx = P_b->x_n - P_a->x_n;\n    Dy = P_b->y_n - P_a->y_n;\n    Delta = 1 - colli->time;\n    dx1 = (Dx * P_a->vx) + (Dy * P_a->vy);\n    dy1 = (Dx * P_a->vy) - (Dy * P_a->vx);\n    dx2 = (Dx * P_b->vx) + (Dy * P_b->vy);\n    dy2 = (Dx * P_b->vy) - (Dy * P_b->vx);\n    DDpDD = (Dx * Dx) + (Dy * Dy);\n    if (DDpDD != 0)\n    {\n      P_a->vx = ((dx2 * Dx) - (dy1 * Dy)) / DDpDD;\n      P_a->vy = ((dx2 * Dy) + (dy1 * Dx)) / DDpDD;\n      P_b->vx = ((dx1 * Dx) - (dy2 * Dy)) / DDpDD;\n      P_b->vy = ((dx1 * Dy) + (dy2 * Dx)) / DDpDD;\n    }\n\n    P_a->x_n = P_a->x_n + (Delta * P_a->vx);\n    P_a->y_n = P_a->y_n + (Delta * P_a->vy);\n    bound_pos(P_a);\n    P_b->x_n = P_b->x_n + (Delta * P_b->vx);\n    P_b->y_n = P_b->y_n + (Delta * P_b->vy);\n    bound_pos(P_b);\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for shared(real_colli,colli_time,colli_queue,particles) private(colli,P_a,P_b,Dx,Dy,Delta,dx1,dy1,dx2,dy2,DDpDD) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nexuslrf/Parallelizable_Particle_Collision_Simulation/collision_grid_p/0"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (i == j)\n    {\n      (Sf << \" \") << S[i];\n    }\n    else\n    {\n      Sf << \" 0.0\";\n    }\n\n  }\n\n  Sf << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lixueclaire/Parallel-SVD/OMP_SVD/13"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[k][j][i][m] = u[k][j][i][m] + (tmp2 * rsd[k][j][i][m]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/ssor/3"}
{"code": "for (int I = 0; I < ArgNum; ++I)\n{\n  Ptrs[I] = (void *) (((intptr_t) TgtArgs[I]) + TgtOffsets[I]);\n  Args[I] = &Ptrs[I];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/openmp/libomptarget/plugins/cuda/src/rtl/1"}
{"code": "for (int i = 1; i <= n; i++)\n  czyPierwsza[i] = true;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  bigBuckets[i].elems = 0;\n  bigBuckets[i].len = 0;\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg3/0"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  int start = g_graph_nodes[vid].starting;\n  int no_of_edges = g_graph_nodes[vid].no_of_edges;\n  int end = start + no_of_edges;\n  int min_cost = MAX_COST;\n  for (int i = start; i < end; i++)\n  {\n    int id;\n    int neighbor_cost;\n    if (stale_mode == 0)\n    {\n      id = g_graph_edges[i];\n      neighbor_cost = g_cost[id];\n    }\n    else\n    {\n      neighbor_cost = g_cost_ind[i];\n    }\n\n    if (min_cost > neighbor_cost)\n    {\n      min_cost = neighbor_cost;\n    }\n\n  }\n\n  int my_cost = g_cost[vid];\n  if (my_cost > min_cost)\n  {\n    g_cost[vid] = min_cost;\n    *g_over = true;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/CC/kernel/0"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm1_start = wtime();\n  sssp_cpu(0, g);\n  btm1_sum += wtime() - btm1_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/0"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  sum += array[i];\n}\n\n", "pragma": "omp parallel for default(shared) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prateek18597/OpenMP-Programs/5_SumArray/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    C[(i * 1024) + j] = ((((DATA_TYPE) i) * j) + 2) / 1024;\n    C_OMP[(i * 1024) + j] = ((((DATA_TYPE) i) * j) + 2) / 1024;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm_cpu/2"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  double *variables = &data0[5 * n_op];\n  for (int j = 0; j < NVAR; j++)\n  {\n    variables[j] = ff_variable_ompkernel[j];\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/initialize_variables_kernel_omp4kernel_func/0"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  difference = p[i].x - xMean;\n  xVariance += difference * difference;\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/4"}
{"code": "for (int i = 0; i < dataLength; i++)\n{\n  for (int x = 0; x < dimensions; x++)\n  {\n    newCentroids[(clustId[i] * dimensions) + x] += points[(i * dimensions) + x];\n  }\n\n  pointsInCluster[clustId[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/loremacchia/kMeans/omp/main/3"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 5; j++)\n  A[i][j].y.l[3][3] += 20;\n\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/shared-1/0"}
{"code": "for (j = 0; j < nx; j++)\n{\n  for (i = 0; i < ndim; i++)\n  {\n    amu[i + (ndim * j)] += amu[(i + (ndim * (j + (nxe * ny)))) + (nnxye * nz)];\n    amu[(i + (ndim * (j + (nxe * ny)))) + (nnxye * nz)] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/21"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n    result_vect[i] += Matr[(i * N) + j] * vect[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/matrix_vector_multiplication/0"}
{"code": "for (it = dataCount.begin(); it != dataCount.end(); it++)\n{\n  if (it->second > maxVal)\n  {\n    ans = it->first;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hafeezali/Parallel-Decision-Tree-Classifier/dtc_openmp/4"}
{"code": "for (i = 0; i < 30; i++)\n{\n  for (j = 0; j < 30; j++)\n  {\n    C[(i * 30) + j] *= 4546;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYRK/syrk/32"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  sigma1_np1_jac[i] = ((-(dx * dx)) / (dt * dt)) - (1.0 / (dx * dx));\n  sigma2_np1_jac[i] = ((dx * dx) / (dt * dt)) + (1.0 / (dx * dx));\n  sigma1_n_jac[i] = 1;\n  sigma2_n_jac[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/13"}
{"code": "for (i = 1; i < f; i++)\n{\n  for (j = 1; j < e; j++)\n  {\n    M[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/3"}
{"code": "for (c = 0; c < nr_class; c++)\n  for (i = 0; i < count[c]; i++)\n{\n  int j = i + (rand() % (count[c] - i));\n  swap(index[start[c] + j], index[start[c] + i]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/67"}
{"code": "for (i = 0; i < numOfClusters; i++)\n  clusters[i].centeroid = calculateAverageOfProducts(i, clusters[i].size, products, numOfProducts, numberOfWeeks);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MichaelSabbah/K-MEANS-parallel-project/K-MEANS_Parallel/K-MEANS/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((((int) v[i]) % 2) == 0)\n    loceven.push_back((int) v[i]);\n\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xsovao/openmp/openmp/openmp/2"}
{"code": "for (i = 0; i < ((int) length); i++)\n{\n  sum += arr[i];\n}\n\n", "pragma": "omp parallel for default(none) private (i) shared(arr, length) reduction(+:sum) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/4"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  calcForce(&pos[i], pos, &force[i], 1000);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/1"}
{"code": "for (i = 0; i < ((2048 / NODESX) + 2); i++)\n{\n  for (j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    ii = ((((i + j) % 2) * ((2048 / NODESX) + 2)) + i) / 2;\n    if (ii < (((2048 / NODESX) + 2) / 2))\n    {\n      whites[ii][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / 5) + 2) - 1)))\n        whites[ii][j].isGhost = 2;\n      else\n        whites[ii][j].isGhost = 1;\n\n    }\n    else\n      if (ii >= (((2048 / NODESX) + 2) / 2))\n    {\n      blacks[ii - (((2048 / NODESX) + 2) / 2)][j].ii = i;\n      if ((((i == 0) || (j == 0)) || (i == (((2048 / NODESX) + 2) - 1))) || (j == (((2048 / 5) + 2) - 1)))\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 2;\n      else\n        blacks[ii - (((2048 / NODESX) + 2) / 2)][j].isGhost = 1;\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/104"}
{"code": "for (wJ = wI; wJ < (wI + (BIGN / 4)); wJ++)\n{\n  wReturned += aVect1[wJ] * aVect2[wJ];\n}\n\n", "pragma": "omp parallel for reduction(+:wReturned) firstprivate(wI) private(wJ)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vectb/4"}
{"code": "for (size_t i = 0; i < g.n_edge_ranges; ++i)\n{\n  char *newmsg;\n  {\n    asprintf(&newmsg, \"%s%s[len=%zu]\", msg, (i == 0) ? (\"\") : (\", \"), g.edge_ranges[i].compressed_size);\n    xfree(msg);\n    msg = newmsg;\n  }\n  nedges_local += g.edge_ranges[i].compressed_size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/11"}
{"code": "for (int64_t x = 0; x < 10000; x++)\n  check(f1, f2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primesum/src/test/0"}
{"code": "for (i = 0; i < edgeList->num_vertices; ++i)\n{\n  edgeList->mask_array[i] = 0;\n  edgeList->label_array[i] = i;\n  edgeList->inverse_label_array[i] = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/2"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  lhsinitj(ny2 + 1, nx2);\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      ru1 = c3c4 * rho_i[k][j][i];\n      cv[j] = vs[k][j][i];\n      rhoq[j] = max(max(dy3 + (con43 * ru1), dy5 + (c1c5 * ru1)), max(dymax + ru1, dy1));\n    }\n\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      lhs[j][i][0] = 0.0;\n      lhs[j][i][1] = ((-dtty2) * cv[j - 1]) - (dtty1 * rhoq[j - 1]);\n      lhs[j][i][2] = 1.0 + (c2dtty1 * rhoq[j]);\n      lhs[j][i][3] = (dtty2 * cv[j + 1]) - (dtty1 * rhoq[j + 1]);\n      lhs[j][i][4] = 0.0;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = 1;\n    lhs[j][i][2] = lhs[j][i][2] + comz5;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j][i][4] = lhs[j][i][4] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz6;\n    lhs[j + 1][i][3] = lhs[j + 1][i][3] - comz4;\n    lhs[j + 1][i][4] = lhs[j + 1][i][4] + comz1;\n  }\n\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhs[j][i][0] = lhs[j][i][0] + comz1;\n      lhs[j][i][1] = lhs[j][i][1] - comz4;\n      lhs[j][i][2] = lhs[j][i][2] + comz6;\n      lhs[j][i][3] = lhs[j][i][3] - comz4;\n      lhs[j][i][4] = lhs[j][i][4] + comz1;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = grid_points[1] - 3;\n    lhs[j][i][0] = lhs[j][i][0] + comz1;\n    lhs[j][i][1] = lhs[j][i][1] - comz4;\n    lhs[j][i][2] = lhs[j][i][2] + comz6;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j + 1][i][0] = lhs[j + 1][i][0] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz5;\n  }\n\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhsp[j][i][0] = lhs[j][i][0];\n      lhsp[j][i][1] = lhs[j][i][1] - (dtty2 * speed[k][j - 1][i]);\n      lhsp[j][i][2] = lhs[j][i][2];\n      lhsp[j][i][3] = lhs[j][i][3] + (dtty2 * speed[k][j + 1][i]);\n      lhsp[j][i][4] = lhs[j][i][4];\n      lhsm[j][i][0] = lhs[j][i][0];\n      lhsm[j][i][1] = lhs[j][i][1] + (dtty2 * speed[k][j - 1][i]);\n      lhsm[j][i][2] = lhs[j][i][2];\n      lhsm[j][i][3] = lhs[j][i][3] - (dtty2 * speed[k][j + 1][i]);\n      lhsm[j][i][4] = lhs[j][i][4];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      fac1 = 1.0 / lhs[j][i][2];\n      lhs[j][i][3] = fac1 * lhs[j][i][3];\n      lhs[j][i][4] = fac1 * lhs[j][i][4];\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      }\n\n      lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n      lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n      }\n\n      lhs[j2][i][1] = lhs[j2][i][1] - (lhs[j2][i][0] * lhs[j][i][3]);\n      lhs[j2][i][2] = lhs[j2][i][2] - (lhs[j2][i][0] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhs[j2][i][0] * rhs[k][j][i][m]);\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    fac1 = 1.0 / lhs[j][i][2];\n    lhs[j][i][3] = fac1 * lhs[j][i][3];\n    lhs[j][i][4] = fac1 * lhs[j][i][4];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    }\n\n    lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n    lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n    }\n\n    fac2 = 1.0 / lhs[j1][i][2];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = fac2 * rhs[k][j1][i][m];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      m = 3;\n      fac1 = 1.0 / lhsp[j][i][2];\n      lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n      lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n      lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n      lhsp[j2][i][1] = lhsp[j2][i][1] - (lhsp[j2][i][0] * lhsp[j][i][3]);\n      lhsp[j2][i][2] = lhsp[j2][i][2] - (lhsp[j2][i][0] * lhsp[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsp[j2][i][0] * rhs[k][j][i][m]);\n      m = 4;\n      fac1 = 1.0 / lhsm[j][i][2];\n      lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n      lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n      lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n      lhsm[j2][i][1] = lhsm[j2][i][1] - (lhsm[j2][i][0] * lhsm[j][i][3]);\n      lhsm[j2][i][2] = lhsm[j2][i][2] - (lhsm[j2][i][0] * lhsm[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsm[j2][i][0] * rhs[k][j][i][m]);\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    m = 3;\n    fac1 = 1.0 / lhsp[j][i][2];\n    lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n    lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n    lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n    m = 4;\n    fac1 = 1.0 / lhsm[j][i][2];\n    lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n    lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n    lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n    rhs[k][j1][i][3] = rhs[k][j1][i][3] / lhsp[j1][i][2];\n    rhs[k][j1][i][4] = rhs[k][j1][i][4] / lhsm[j1][i][2];\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m]);\n    }\n\n    rhs[k][j][i][3] = rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3]);\n    rhs[k][j][i][4] = rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4]);\n  }\n\n  for (j = grid_points[1] - 3; j >= 0; j--)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = (rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m])) - (lhs[j][i][4] * rhs[k][j2][i][m]);\n      }\n\n      rhs[k][j][i][3] = (rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3])) - (lhsp[j][i][4] * rhs[k][j2][i][3]);\n      rhs[k][j][i][4] = (rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4])) - (lhsm[j][i][4] * rhs[k][j2][i][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,j1,j2,m, ru1,fac1,fac2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/y_solve/0"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      exact(i, j, k, u000ijk);\n      for (m = 0; m < 5; m++)\n      {\n        tmp = u000ijk[m] - u[k][j][i][m];\n        errnm[m] = errnm[m] + (tmp * tmp);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/11"}
{"code": "for (i = 0; i < 512; i++)\n{\n  X[i] = Y[i] + Z[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/1"}
{"code": "for (b = 0; b < batch; b++)\n{\n  sum = 0;\n  for (i = 0; i < N; i++)\n  {\n    if (input[(b * N) + i] > largest)\n      largest = input[(b * N) + i];\n\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    e = exp(input[(b * N) + i] - largest);\n    output[(b * N) + i] = e;\n    sum += e;\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    output[(b * N) + i] = output[(b * N) + i] / sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,largest,e) shared(input,output) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-cpu/6"}
{"code": "for (int i = 0; i < (10000 - 1); i++)\n{\n  float min = 1000000;\n  float minn[2];\n  int th = -1;\n  int thh[2];\n  for (int j = 0; j < 10000; j++)\n  {\n    int flag = 1;\n    for (int k = 0; k < i; k++)\n    {\n      if (j == diad[k])\n      {\n        flag = 0;\n        break;\n      }\n\n    }\n\n    if (((dist[diad[i]][j] != 0) && (flag == 1)) && (min > dist[diad[i]][j]))\n    {\n      min = dist[diad[i]][j];\n      minn[1] = minn[0];\n      minn[0] = min;\n      th = j;\n      thh[1] = thh[0];\n      thh[0] = th;\n    }\n\n  }\n\n  int d = rand() % 2;\n  diad[i + 1] = thh[d];\n  tdist = tdist + minn[d];\n}\n\n", "pragma": "omp parallel for reduction(+:tdist)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitrisbro/ParallelC/TravelSalesmanProblem/version5/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  if (lookingFor == numbers[i])\n  {\n    foundNumber = 1;\n  }\n\n  if (foundNumber)\n  {\n    i = size;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maximus1094/ParallelisingAlgos/linsearchpar/0"}
{"code": "for (int i = 0; i < TOP_X; i++)\n{\n  int randIndex;\n  randIndex = rand() % 100;\n  if (randIndex < MUTATE_RATE)\n  {\n    int temp;\n    int randIndexGene1;\n    randIndexGene1 = rand() % CITIES;\n    int randIndexGene2;\n    randIndexGene2 = rand() % CITIES;\n    while (randIndexGene1 == randIndexGene2)\n      randIndexGene2 = rand() % CITIES;\n\n    temp = offsprings[i].itinerary[randIndexGene1];\n    offsprings[i].itinerary[randIndexGene1] = offsprings[i].itinerary[randIndexGene2];\n    offsprings[i].itinerary[randIndexGene2] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stahtews/TravellingSalesman-GeneticAlgorithm-OpenMp/tsp/0"}
{"code": "for (index = 0; index < count; index += inc)\n{\n  pkcs12_pbe_derive_key(algo, cur_salt->iteration_count, MBEDTLS_PKCS12_DERIVE_MAC_KEY, (unsigned char *) saved_key[index], saved_len[index], cur_salt->salt, salt_len, (unsigned char *) crypt_out[index], BINARY_SIZE);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/zed_fmt_plug/0"}
{"code": "for (int i = 2; (i * i) <= number; i++)\n{\n  if ((number % i) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Droidverine/PrimeCounter/Openmp_prime/0"}
{"code": "for (i = 0; i < n; i += 2)\n  a[i] = 0.5 * (a[i] + a[i - 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_5/c_red_black/2"}
{"code": "for (i = 0; i < 25; i++)\n{\n  for (j = 0; j < 25; j++)\n  {\n    C[(i * 25) + j] *= 2123.0f;\n    for (k = 0; k < 25; ++k)\n    {\n      C[(i * 25) + j] += (32412.0f * A[(i * 25) + k]) * B[(k * 25) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GEMM/gemm/19"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = IA[i]; j < IA[i + 1]; j++)\n  {\n    if (JA[j] != i)\n    {\n      A[j] = cos(i * JA[j]);\n      SUM[i] += 1.5 * fabs(A[j]);\n    }\n\n  }\n\n  for (int j = IA[i]; j < IA[i + 1]; j++)\n  {\n    if (JA[j] == i)\n    {\n      A[j] = SUM[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/11"}
{"code": "for (j = 0; j <= (_PB_MAXGRID - 1); j++)\n  for (i = j; i <= (_PB_MAXGRID - 1); i++)\n  for (cnt = 0; cnt <= (_PB_LENGTH - 1); cnt++)\n  diff[j][i][cnt] = sum_tang[j][i];\n\n\n\n", "pragma": "omp for private (i, cnt) collapse(2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/medley/reg_detect/reg_detect/0"}
{"code": "for (unsigned int i = 0; i < (N - 1); i++)\n{\n  result += (4 / (1 + (((((double) i) + 0.5) / ((double) N)) * ((((double) i) + 0.5) / ((double) N))))) * (1 / ((double) N));\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+: result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vashaty/OpenMPPI/mainwindow/0"}
{"code": "for (int x = 0; x < VIEW_WIDTH; ++x)\n{\n  for (int y = 0; y < VIEW_HEIGHT; ++y)\n  {\n    if (m_image.getPixel(x, y) != Black)\n    {\n      m_image.setPixel(x, y, colourGradient(m_mu[x][y]));\n    }\n    else\n    {\n      m_image.setPixel(x, y, Black);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(6)\t\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Adamstanners123/Interactive-Mandelbrot/source/Mandlebrot/Mandlebrot/Mandlebrot/0"}
{"code": "for (int i = 0; i < h; i++)\n{\n  for (int j = 0; j < w; j++)\n  {\n    fscanf(fin, \"%c\", &picsels[i][j].r);\n    fscanf(fin, \"%c\", &picsels[i][j].g);\n    fscanf(fin, \"%c\", &picsels[i][j].b);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MONICgh/OpenMP/lab04/1"}
{"code": "for (i = 0; i < M; i += incX)\n{\n  r = 0.0;\n  indice = i * M;\n  x4[0] = X[i];\n  x4[1] = X[i];\n  xv4 = _mm_load_pd(x4);\n  for (j = 0; j < M; j += 2)\n  {\n    a1 = _mm_load_pd((A + indice) + j);\n    dot = _mm_dp_pd(a1, xv4, 0xFF);\n    _mm_store_pd(r4, dot);\n    r += r4[0];\n  }\n\n  Y[i] = (beta * Y[i]) + (alpha * r);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemv/4"}
{"code": "for (int i = 0; i < n; i++)\n  vec[i] = (rand() % RMAX) / (RMAX / 10.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/12_omp_mat_vec_mul/2"}
{"code": "for (i = 0; i < nbMax; i++)\n{\n  vector1[i] = rand();\n  vector2[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pyhro36/TD-1-OpenMP/vecteur-vecteur/main_vect/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  Current_Edges = Edges_Per_Vertex[i];\n  while (Current_Edges < 25)\n  {\n    Random_Vertex = rand() % 1000;\n    Random_Dist = (rand() % 1000) + 1;\n    if ((Random_Vertex != i) && (Graph[Random_Vertex + (i * 1000)] == 0))\n    {\n      Graph[Random_Vertex + (i * 1000)] = Random_Dist;\n      Graph[(Random_Vertex * 1000) + i] = Random_Dist;\n      Edges_Per_Vertex[i] += 1;\n      Current_Edges += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VishalVishnani/CUDA-pthread-openMP-implementation-of-Graph-Algorithms/Dijkstra/6"}
{"code": "for (int iter = 0; iter < niter; iter++)\n{\n  for (i = 1; i < (n - 1); i++)\n  {\n    for (j = 1; j < (m - 1); j += 2)\n    {\n      int shift;\n      if ((i % 2) == 0)\n      {\n        shift = 1;\n      }\n      else\n      {\n        shift = 0;\n      }\n\n      int index = getIndex(i, j + shift, m);\n      int pos_l = getIndex(i - 1, j + shift, m);\n      int pos_r = getIndex(i + 1, j + shift, m);\n      int pos_u = getIndex(i, (j + 1) + shift, m);\n      int pos_d = getIndex(i, (j - 1) + shift, m);\n      T[index] = (((1.0 - alpha) * T[index]) + ((alpha / 4.0) * (((T[pos_l] + T[pos_r]) + T[pos_u]) + T[pos_d]))) + b[index];\n    }\n\n  }\n\n  for (i = 1; i < (n - 1); i++)\n  {\n    for (j = 2; j < (m - 1); j += 2)\n    {\n      int shift;\n      if ((i % 2) == 0)\n      {\n        shift = -1;\n      }\n      else\n      {\n        shift = 0;\n      }\n\n      int index = getIndex(i, j + shift, m);\n      int pos_l = getIndex(i - 1, j + shift, m);\n      int pos_r = getIndex(i + 1, j + shift, m);\n      int pos_u = getIndex(i, (j + 1) + shift, m);\n      int pos_d = getIndex(i, (j - 1) + shift, m);\n      T[index] = (((1.0 - alpha) * T[index]) + ((alpha / 4.0) * (((T[pos_l] + T[pos_r]) + T[pos_u]) + T[pos_d]))) + b[index];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/serial_mg/3"}
{"code": "for (c1 = 0; c1 <= 127; c1++)\n{\n  for (c2 = 0; c2 <= 127; c2++)\n  {\n    G[c1][c2] = 0;\n    F[c1][c2] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/33"}
{"code": "for (ei_new = 0; ei_new < public.in2_sub_rows; ei_new++)\n{\n  pos_ori = ei_new;\n  sum = 0;\n  #pragma loop name kernel#9#0\n  for (position = pos_ori; position < (pos_ori + public.in2_sub_elem); position = position + public.in2_sub_rows)\n  {\n    private.d_in2_sub[position] = private.d_in2_sub[position] + sum;\n    sum = private.d_in2_sub[position];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/10"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((((x[i] < axx.amin) || (x[i] >= axx.amax)) || (y[i] < axy.amin)) || (y[i] >= axy.amax))\n    continue;\n\n  by = calc_bin(y[i], axy.amin, normy);\n  bx = calc_bin(x[i], axx.amin, normx);\n  bin = by + (nby * bx);\n  values_ot[bin] += w[i];\n  variances_ot[bin] += w[i] * w[i];\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/45"}
{"code": "for (unsigned j = 0; j < size_v; ++j)\n{\n  float samp = ((float) rand()) / ((float) RAND_MAX);\n  if (myRBM.Vp[j] > samp)\n  {\n    myRBM.Vs[j] = 1;\n  }\n  else\n  {\n    myRBM.Vs[j] = 0;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/9"}
{"code": "for (int j = 0; j < ndr; j++)\n{\n  for (int i = 0; i < P; i++)\n  {\n    double temp = B(i, j);\n    NewB(i, j) = B(i, j) + epsilon;\n    G(i, j) = (seff_f(NewB, X, Y, kernel_matrix_y, bw, ncore) - F0) / epsilon;\n    NewB(i, j) = temp;\n  }\n\n}\n\n", "pragma": "  #pragma omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_seff_solver/1"}
{"code": "for (i = 0; i < 128; i++)\n{\n  x[i / 64][i % 3][(i / 4) & 1].t += i;\n  if ((i & 15) == 1)\n    y[0].t *= 3;\n\n  if ((i & 31) == 2)\n    y[1].t *= 7;\n\n  if ((i & 63) == 3)\n    y[2].t *= 17;\n\n  z[i / 32].t += i & 3;\n  if (i < 4)\n    z[i].t += i;\n\n  a[i / 32].t |= 1ULL << (i & 30);\n  w[0][i & 1].t &= ~(1L << ((i / 17) * 3));\n  if ((i % 79) > b[0])\n    b[0] = i % 79;\n\n  if ((i % 13) > b[1])\n    b[1] = i % 13;\n\n  if ((i % 23) > b[2])\n    b[2] = i % 23;\n\n  if ((i % 85) > b[3])\n    b[3] = i % 85;\n\n  if ((i % 192) > b[4])\n    b[4] = i % 192;\n\n}\n\n", "pragma": "omp parallel for reduction(+:x[0:p1 + 1][:p2], z[:p3]) reduction(*:y[:p4]) reduction(|:a[:p5]) reduction(&:w[0:p6 - 1][:p6]) reduction(maxb:b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-10/0"}
{"code": "for (i = 0; i < dom->nx; i++)\n{\n  double x = 0.5 * (dom->ximh[i] + dom->ximh[i + 1]);\n  int j;\n  for (j = 0; j < dom->ny[i]; j++)\n  {\n    double y = 0.5 * (dom->yjmh[i][j] + dom->yjmh[i][j + 1]);\n    source_prim(dom->prim[i] + (nq * j), x, y, nq);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geoffryan/ompTest/funcs/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    printf(\"%f\\t\", A[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/2"}
{"code": "for (int i = 1; i < numNodes; i++)\n{\n  sum += pointsPerNode[i - 1];\n  datasetDisp[i] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/5"}
{"code": "for (k = n - 1; k > 0; --k)\n{\n  long double tmp = data[k - 1] - mean;\n  s += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/4"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  mor_s_v[1][i] = idmo[ntemp4][jjface[face]][0][0][LX1 - 1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/15"}
{"code": "for (i = 0; i < 100000000; i++)\n  a[i] = 0.00000001 * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_13/mat_vec_row_omp/moj_program/1"}
{"code": "for (i = 0; i < 1000; i++)\n  R[i] = (double *) malloc((sizeof(double)) * 3);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/7"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    wp[i][j] = 0.25 * (((up[i - 1][j] + up[i + 1][j]) + up[i][j - 1]) + up[i][j + 1]);\n    if (my_diff[tid] < fabs(wp[i][j] - up[i][j]))\n      my_diff[tid] = fabs(wp[i][j] - up[i][j]);\n\n  }\n\n}\n\n", "pragma": "omp for schedule(OMP_SCHED)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/Jacobi/2"}
{"code": "for (i = 0; i < numprocs; ++i)\n{\n  recvNum[i] = sendNum[i] / DIMS;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/0"}
{"code": "for (int i = 0; i < np; i++)\n{\n  int pid = omp_get_thread_num();\n  int j;\n  printf(\"For process id:%d\\n\", pid);\n  for (j = (pid * sizeblock) + 1; (j < n) && (j < ((pid + 1) * sizeblock)); j++)\n  {\n    arr[j] += arr[j - 1];\n  }\n\n  for (j = pid * sizeblock; (j < n) && (j < ((pid + 1) * sizeblock)); j++)\n  {\n    printf(\"%d \", arr[j]);\n  }\n\n  if (pid != (omp_get_num_threads() - 1))\n    arr2[pid + 1] = arr[j - 1];\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for shared(arr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nshul/High_Performance_Computing/openMP/prefixsum/0"}
{"code": "for (size_t l = 0; l < n_layers; l++)\n{\n  layer_outputs[l] = malloc(((sizeof(double)) * n_samples) * nodes_per_layer[l]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU7/3"}
{"code": "for (int j = 0; j < 9; ++j)\n{\n  L += ((1.0 - array[j]) * (1.0 - array[j])) + ((100.0 * (array[j + 1] - (array[j] * array[j]))) * (array[j + 1] - (array[j] * array[j])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p3abcd/1"}
{"code": "for (i = 0; i < 256; i++)\n{\n  for (j = 0; j < 256; j++)\n    fprintf(fp, \"%d \", (i * 256) + j);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/PKU-HPC/Testing on Intel Xeon E5 CPUs/ProblemScale/256*256/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    pressure[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = pressure[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/18"}
{"code": "for (i = 0; i < size; i++)\n{\n  coe_i = 10 * exp(lamda * i);\n  j = (size - 1) + i;\n  coe[j] = coe_i;\n  j = (size - 1) - i;\n  coe[j] = coe_i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lud/omp/lud_omp_one_file/8"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n{\n  rhs_x[i][0] = (f_t[i - 1][0] + f_t[i + 1][0]) - (2 * f_t[i][0]);\n  rhs_y[i][0] = (f_t[i][0] + f_t[i][2]) - (2 * f_t[i][1]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mircuz/travelling_wave/travelling_wave/support/7"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n  printf(\"%d \", _bins[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/14"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  if (global_max < local_max[i])\n  {\n    global_max = local_max[i];\n  }\n\n  if (global_min > local_min[i])\n  {\n    global_min = local_min[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JiyanBlack/MPI-HPC-Project2/examQuestion/1"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      DzDzu[pp] = (((((-u[pp - (2 * n)]) + (16.0 * u[pp - n])) - (30.0 * u[pp])) + (16.0 * u[pp + n])) - u[pp + (2 * n)]) * idz_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/21"}
{"code": "for (;;)\n{\n  mincos = 2;\n  for (int i = 0; i < components; i++)\n  {\n    cosine = roundFloat(turnPoint(last, beforelast, convex_hull[i]) * INFINITE) / INFINITE;\n    if (cosine < mincos)\n    {\n      minind = i;\n      mincos = cosine;\n      maxlen = betweenPoints(last, convex_hull[i]);\n    }\n    else\n      if (cosine == mincos)\n    {\n      len = betweenPoints(last, convex_hull[i]);\n      if (len > maxlen)\n      {\n        minind = i;\n        maxlen = len;\n      }\n\n    }\n\n\n  }\n\n  beforelast = last;\n  last = convex_hull[minind];\n  if (last == convex_hull[m])\n    break;\n\n  result.push_back(convex_hull[minind]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ysph/parallel-stuff/b_omp/convex_hull/1"}
{"code": "for (k = 0; k < 512; k++)\n{\n  float x = fx[k];\n  float y = fy[k];\n  float z = fz[k];\n  for (l = 0; l < 512; l++)\n  {\n    calculate_force_soa(p1x, p1y, p1z, p1m, p2x, p2y, p2z, p2m, &x, &y, &z, i + k, j + l, k, l);\n  }\n\n  fx[k] = x;\n  fy[k] = y;\n  fz[k] = z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_39_nbody/4"}
{"code": "for (int x = 0; x < WIDTH; x++)\n{\n  for (int y = 0; y < HEIGHT; y++)\n  {\n    int neighbours = 0;\n    if (x > 0)\n    {\n      if ((y > 0) && board_temp[x - 1][y - 1])\n        neighbours++;\n\n      if (board_temp[x - 1][y])\n        neighbours++;\n\n      if ((y < (HEIGHT - 2)) && board_temp[x - 1][y + 1])\n        neighbours++;\n\n    }\n\n    if ((y > 0) && board_temp[x][y - 1])\n      neighbours++;\n\n    if ((y < (HEIGHT - 2)) && board_temp[x][y + 1])\n      neighbours++;\n\n    if (x < (WIDTH - 2))\n    {\n      if ((y > 0) && board_temp[x + 1][y - 1])\n        neighbours++;\n\n      if (board_temp[x + 1][y])\n        neighbours++;\n\n      if ((y < (HEIGHT - 2)) && board_temp[x + 1][y + 1])\n        neighbours++;\n\n    }\n\n    if (board_temp[x][y] && ((neighbours < 2) || (neighbours > 3)))\n      board[x][y] = false;\n    else\n      if ((!board_temp[x][y]) && (neighbours == 3))\n      board[x][y] = true;\n\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3xi0/Game-of-Life/main/0"}
{"code": "for (i = 0; i < _PB_NJ; i++)\n  for (j = 0; j < _PB_NL; j++)\n{\n  F[i][j] = 0;\n  for (k = 0; k < _PB_NM; ++k)\n    F[i][j] += C[i][k] * D[k][j];\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/3mm/3mm/1"}
{"code": "for (int j = 0; j < this->nnz_; ++j)\n{\n  this->mat_.val[j] = val[j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/2"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValue = 0;\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = qBlue(srcImage->pixel(jj + j, ii + i));\n        pixelValue += weight[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    if (pixelValue > 255)\n      pixelValue = 255;\n\n    if (pixelValue < 0)\n      pixelValue = 0;\n\n    dstImage->setPixel(jj, ii, QColor(pixelValue, pixelValue, pixelValue).rgba());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/sobel/sobel1/0"}
{"code": "for (i = 0; i < (1 << TOTAL_KEYS_LOG_2); i++)\n{\n  x = randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/50"}
{"code": "for (j = 0; j < nc; j++)\n{\n  somme = 0;\n  for (k = 0; k < nl; k++)\n  {\n    somme += A[i][k] * B[k][j];\n  }\n\n  (*C)[i][j] = somme;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex7/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (5.0 * u[m][i][j][k])));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/36"}
{"code": "for (int j = startIndex; j < (arrLength - 1); j += 2)\n{\n  if (isLeftToRight && (arr[j] > arr[j + 1]))\n  {\n    SwapIntegersInArray(j, j + 1, arr);\n  }\n  else\n    if ((!isLeftToRight) && (arr[j] < arr[j + 1]))\n  {\n    SwapIntegersInArray(j, j + 1, arr);\n  }\n\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(nThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/ShearSort_Comprehension/C++_Code/Main/0"}
{"code": "for (i = 1; i < (nx + 1); i++)\n{\n  for (j = 1; j < (ny + 1); j++)\n  {\n    dt_sum = 0;\n    dt[i][j] = comp_CCL(i, j, dt_max);\n    do\n    {\n      dt_sum = dt_sum + dt[i][j];\n      if (dt_sum < dt_max)\n      {\n        D1V_old[i][j] = D1V[i][j];\n        comp_concentrations(i, j, dt[i][j]);\n        Rush_Larsen(i, j, dt[i][j]);\n        comp_voltage(i, j, dt[i][j]);\n      }\n      else\n      {\n        dt[i][j] = dt_max - (dt_sum - dt[i][j]);\n        D1V_old[i][j] = D1V[i][j];\n        comp_concentrations(i, j, dt[i][j]);\n        Rush_Larsen(i, j, dt[i][j]);\n        comp_voltage(i, j, dt[i][j]);\n        break;\n      }\n\n      it[i][j] = comp_currents(i, j, dt[i][j]);\n      D1V[i][j] = (-it[i][j]) + (-stim);\n      dt[i][j] = comp_CCL(i, j, dt[i][j]);\n    }\n    while (true);\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j, dt_sum) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/LRd2000-model/2D model/FDM02_LRd00_CCL_openmp/7"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if (notdone[i] && (dist[i] < local_min_dist))\n  {\n    local_min_dist = dist[i];\n    local_min_idx = i;\n  }\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/dijkstra/dijkstra/2"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  visited[i] = 0;\n  R[i] = -1;\n  oneLevel[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/reverseCuthillMcKee/8"}
{"code": "for (k = 0; k < nm1; k++)\n{\n  kp1 = k + 1;\n  l = (isamax(n - k, (a + k) + (k * lda), 1) + k) - 1;\n  ipvt[k] = l + 1;\n  if (a[l + (k * lda)] == 0.0)\n  {\n    info = k + 1;\n    return info;\n  }\n\n  if (l != k)\n  {\n    t = a[l + (k * lda)];\n    a[l + (k * lda)] = a[k + (k * lda)];\n    a[k + (k * lda)] = t;\n  }\n\n  t = (-1.0) / a[k + (k * lda)];\n  sscal((n - k) - 1, t, (a + kp1) + (k * lda), 1);\n  if (l != k)\n  {\n    sswap((n - k) - 1, (a + l) + (kp1 * lda), lda, (a + k) + (kp1 * lda), lda);\n  }\n\n  msaxpy((n - k) - 1, (n - k) - 1, (a + k) + (kp1 * lda), n, (a + kp1) + (k * lda), (a + kp1) + (kp1 * lda));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/13"}
{"code": "for (int x = 0; x < n; x++)\n{\n  for (int y = 0; y < n; y++)\n  {\n    newMatrix[x][y] = myMatrix[y][x];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/doddapanenipurna/GaussianProcessRegression/gpr/12"}
{"code": "for (int i = 0; i < N; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d\\nSet c[%d] = %d\\n\", omp_get_thread_num(), i, c[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 3) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/greenmapc/OpenMP-MPI/OpenMP/Task7/1"}
{"code": "for (i = 0; i < 180; i++)\n  for (j = 0; j < (180 - 1); j++)\n  x_matrix[i][j] = (((double) j) * h) * x_matrix[i][180 - 1];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/5"}
{"code": "for (int i = 0; i < P; i++)\n{\n  sum_sq += (A_next[(i * P) + i] - A_current[(i * P) + i]) * (A_next[(i * P) + i] - A_current[(i * P) + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/8"}
{"code": "for (size_t i = 0; i < result.size(); ++i)\n{\n  result[i] = input[i] / val;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/libs/Math/SimpleMath/2"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  for (long long j = 0; j < n; j++)\n  {\n    a[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/matrix product & sum/1"}
{"code": "for (int i = 0; i < columnsMinValues.size(); i++)\n{\n  ((((cout << \"min of column <\") << i) << \">: \") << columnsMinValues[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelaziz321/hybrid-mpi-openmp-example/main/3"}
{"code": "for (k = 0; k <= 20; k++)\n{\n  aaaa = 0;\n  start = getclock();\n  for (j = 0; j < innerreps; j++)\n  {\n    delay(delaylength);\n    aaaa += 1;\n  }\n\n  times[k] = ((getclock() - start) * 1.0e6) / ((double) innerreps);\n  if (aaaa < 0)\n    printf(\"%d\\n\", aaaa);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/epcc-c/syncbench/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sum = 0;\n  for (int j = 0; j < size; j++)\n    sum += A[i][j] * x[j];\n\n  sum -= b;\n  er += sum * sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/12"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  for (i = iend - 1; i >= ist; i--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[j][i][m] = tv[j][i][m] + (omega * ((((((((((udy[j][i][0][m] * v[k][j + 1][i][0]) + (udx[j][i][0][m] * v[k][j][i + 1][0])) + (udy[j][i][1][m] * v[k][j + 1][i][1])) + (udx[j][i][1][m] * v[k][j][i + 1][1])) + (udy[j][i][2][m] * v[k][j + 1][i][2])) + (udx[j][i][2][m] * v[k][j][i + 1][2])) + (udy[j][i][3][m] * v[k][j + 1][i][3])) + (udx[j][i][3][m] * v[k][j][i + 1][3])) + (udy[j][i][4][m] * v[k][j + 1][i][4])) + (udx[j][i][4][m] * v[k][j][i + 1][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[j][i][0][m];\n      tmat[m][1] = d[j][i][1][m];\n      tmat[m][2] = d[j][i][2][m];\n      tmat[m][3] = d[j][i][3][m];\n      tmat[m][4] = d[j][i][4][m];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    tv[j][i][1] = tv[j][i][1] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    tv[j][i][2] = tv[j][i][2] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    tv[j][i][2] = tv[j][i][2] - (tv[j][i][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][3] * tmp);\n    tv[j][i][4] = tv[j][i][4] / tmat[4][4];\n    tv[j][i][3] = tv[j][i][3] - (tmat[3][4] * tv[j][i][4]);\n    tv[j][i][3] = tv[j][i][3] / tmat[3][3];\n    tv[j][i][2] = (tv[j][i][2] - (tmat[2][3] * tv[j][i][3])) - (tmat[2][4] * tv[j][i][4]);\n    tv[j][i][2] = tv[j][i][2] / tmat[2][2];\n    tv[j][i][1] = ((tv[j][i][1] - (tmat[1][2] * tv[j][i][2])) - (tmat[1][3] * tv[j][i][3])) - (tmat[1][4] * tv[j][i][4]);\n    tv[j][i][1] = tv[j][i][1] / tmat[1][1];\n    tv[j][i][0] = (((tv[j][i][0] - (tmat[0][1] * tv[j][i][1])) - (tmat[0][2] * tv[j][i][2])) - (tmat[0][3] * tv[j][i][3])) - (tmat[0][4] * tv[j][i][4]);\n    tv[j][i][0] = tv[j][i][0] / tmat[0][0];\n    v[k][j][i][0] = v[k][j][i][0] - tv[j][i][0];\n    v[k][j][i][1] = v[k][j][i][1] - tv[j][i][1];\n    v[k][j][i][2] = v[k][j][i][2] - tv[j][i][2];\n    v[k][j][i][3] = v[k][j][i][3] - tv[j][i][3];\n    v[k][j][i][4] = v[k][j][i][4] - tv[j][i][4];\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/buts/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result += grid[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j) reduction(+ : result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DAToneli/highlife/pcd_omp_game_of_life/0"}
{"code": "for (int i = 0; i < 1e9; i++)\n{\n  moveCity();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project3/Random-Search/2"}
{"code": "for (i = 0; i < 10000; i++)\n  for (j = 0; j < 10000; j++)\n  for (k = 0; k < 10000; k++)\n  res[i][j] += mat[i][k] * mat[k][j];\n\n\n\n", "pragma": "omp for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acutisC/openmp_intro/code/multithread/1"}
{"code": "for (size_t i = 0; i < point_cloud.size(); i++)\n{\n  float x_adjusted = point_cloud[i].x + x_max;\n  int bin = (x_adjusted / (2 * x_max)) * number_partitions;\n  bin = (bin == number_partitions) ? (number_partitions - 1) : (bin);\n  partitioned_points[bin].push_back(point_cloud[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Hull/ConvexHullParallel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = (-1) * y[i];\n  printf(\"#\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/looptest_1/0"}
{"code": "for (j = 1; j < (256 + 1); j++)\n{\n  stddev[j] = 0.0;\n  for (i = 1; i < (256 + 1); i++)\n  {\n    stddev[j] += (data[(i * (256 + 1)) + j] - mean[j]) * (data[(i * (256 + 1)) + j] - mean[j]);\n  }\n\n  stddev[j] /= 3214212.01f;\n  stddev[j] = sqrt(stddev[j]);\n  if (stddev[j] <= 0.005f)\n  {\n    stddev[j] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/23"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (arr[i] != (-1))\n    ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/void-mckenzie/OpenMP-Work/Programs/parallel_sieve_of_eratosthenes/2"}
{"code": "for (int i = 0; i < heightA; ++i)\n{\n  int sum = 0;\n  for (int k = 0; k < lengthA; ++k)\n  {\n    sum += A[i][k] * vector[i];\n  }\n\n  res[i] = sum;\n}\n\n", "pragma": "#pragma omp parallel for if(threading) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task3/1"}
{"code": "for (unsigned i = 0; i < n; ++i)\n{\n  a[i] = numb;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/4"}
{"code": "for (ii = 0; ii < params.ny; ii++)\n{\n  for (jj = 0; jj < params.nx; jj++)\n  {\n    if (!obstacles[(ii * params.nx) + jj])\n    {\n      local_density = 0.0;\n      for (kk = 0; kk < 9; kk++)\n      {\n        local_density += cells[(ii * params.nx) + jj].speeds[kk];\n      }\n\n      inverselocal_density = 1 / local_density;\n      u_x = (((cells[(ii * params.nx) + jj].speeds[1] + cells[(ii * params.nx) + jj].speeds[5]) + cells[(ii * params.nx) + jj].speeds[8]) - ((cells[(ii * params.nx) + jj].speeds[3] + cells[(ii * params.nx) + jj].speeds[6]) + cells[(ii * params.nx) + jj].speeds[7])) * inverselocal_density;\n      u_y = (((cells[(ii * params.nx) + jj].speeds[2] + cells[(ii * params.nx) + jj].speeds[5]) + cells[(ii * params.nx) + jj].speeds[6]) - ((cells[(ii * params.nx) + jj].speeds[4] + cells[(ii * params.nx) + jj].speeds[7]) + cells[(ii * params.nx) + jj].speeds[8])) * inverselocal_density;\n      tot_u += sqrt((u_x * u_x) + (u_y * u_y));\n      tot_cells = tot_cells + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:tot_u) reduction(+:tot_cells) private(u_x) private(u_y) private(jj) private(local_density) private(inverselocal_density) private(kk)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sd12832/High-Performance-Computing-Files/d2q9-bgk-OpenMP/4"}
{"code": "for (int i = 0; i < 500; i++)\n  for (int j = 0; j < 500; j++)\n  node3weights[i][j] = 0.25;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/16"}
{"code": "for (pos = 0; pos < (SIZE * SIZE); pos++)\n{\n  row = pos % SIZE;\n  column = pos / SIZE;\n  if (grid[pos] == ALIVE)\n  {\n    aliveCells++;\n    glColor3f(0.0, 0.6, 0.0);\n  }\n  else\n    glColor3f(0.0, 0.0, 0.0);\n\n  glVertex2i(row, column);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilisG/Game-of-Life-in-OpenMP-and-OpenCL/Game of Life/Game_of_Life_parallel_CPU/main/3"}
{"code": "for (i = 0; i < icompact_num_mesh; i++)\n{\n  i_target = MC_compact_ind[i];\n  for (j = 0; j < MC_ind[i_target]; j++)\n  {\n    i_particle = MC[(20 * i_target) + j];\n    for (k = j + 1; k < MC_ind[i_target]; k++)\n    {\n      k_particle = MC[(20 * i_target) + k];\n      inum_collision += CollisionDetect(i_particle, k_particle, X, V, V_old, F);\n    }\n\n    if ((i_target + 1) < imax_num_mesh)\n    {\n      for (k = 0; k < MC_ind[i_target + 1]; k++)\n      {\n        k_particle = MC[(20 * (i_target + 1)) + k];\n        inum_collision += CollisionDetect(i_particle, k_particle, X, V, V_old, F);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i_target,j,i_particle,k_particle,k) reduction(+:inum_collision)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/DEM/C/dem/2"}
{"code": "for (int i = 0; i < h.num_bins; i++)\n  h.bin_maxes[i] = min_meas + (bin_width * (i + 1));\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/epielemeier/oc-openmp-histogram/histogram/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  r[i] = b[i] - tmp[i];\n  sum += r[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/7"}
{"code": "for (int i = 0; i < (No * No); i++)\n{\n  matrix[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tukzGobetse/DICs-Labs/lab2/lab2opm/3"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n{\n  nVMCWalkers[ip] = wClones[ip]->getActiveWalkers();\n  (app_log() << wClones[ip]->getActiveWalkers()) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/5"}
{"code": "for (i = 0; i < (MAX_KEY - 1); i++)\n  work_buff[i + 1] += work_buff[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/8"}
{"code": "for (i = 0; i < n; i++)\n  sum += list[i];\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/MC-SD02-I/OmpReduction/0"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/53"}
{"code": "for (int i = 0; i < 10; i++)\n  (cout << i) << endl;\n\n", "pragma": "\t#pragma omp parallel for if(parallelism_enabled)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wynnliam/openmp-learning/if_parallelism/0"}
{"code": "for (int i = 0; i < alphabets.size(); i++)\n{\n  ((((cout << \"Alphabet[\") << i) << \"]: \") << alphabets[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/benchmarks/benchmark2_old/4"}
{"code": "for (i = 0; i < 100000; ++i)\n{\n  resta[i] = A[i] - B[i];\n}\n\n", "pragma": "omp parallel for private(i) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_sections/main/2"}
{"code": "for (size_t i = 0; i < I2PQ_size; ++i)\n{\n  I2PQ[i] = Index2(shellArray[i * 2], shellArray[(i * 2) + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD_Parallel/4"}
{"code": "for (int i = 0; i < tmp_img.rows; i++)\n{\n  for (int j = k; j < (tmp_img.cols - k); j++)\n  {\n    float tmp[3] = {0.0, 0.0, 0.0};\n    float kernelSum[3] = {0.0, 0.0, 0.0};\n    for (int u = j - k; u <= (j + k); u++)\n    {\n      for (int c = 0; c < 3; c++)\n      {\n        tmp[c] += ((float) tmp_img(i, u)[c]) * exp((-((u - j) * (u - j))) / ((2.0 * sigma) * sigma));\n        kernelSum[c] += exp((-((u - j) * (u - j))) / ((2.0 * sigma) * sigma));\n      }\n\n    }\n\n    for (int c = 0; c < 3; c++)\n    {\n      dst(i, j - k)[c] = (unsigned char) (tmp[c] / kernelSum[c]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IacopomC/openMp-CUDA-Image-Processing/image_openmp/2"}
{"code": "for (int i = 0; i < (n + 2); ++i)\n{\n  for (int j = 0; j < (n + 2); ++j)\n  {\n    if ((((i == 0) || (j == 0)) || (i == (n + 1))) || (j == (n + 1)))\n    {\n      input_temp[i][j] = 100.0;\n      output_temp[i][j] = 100.0;\n    }\n    else\n    {\n      input_temp[i][j] = -100.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/benludwin/ParallizationTechniques/OpenMP/parallel/heat/0"}
{"code": "for (int sj = (me * n) / nth; sj < (((me + 1) * n) / nth); sj += BLOCKSIZE)\n  for (int si = 0; si < n; si += BLOCKSIZE)\n  for (int sk = 0; sk < n; sk += BLOCKSIZE)\n  do_block(n, si, sj, sk, A, B, C);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/6"}
{"code": "for (vj = nvtxs - 1; vj >= (nvtxs - maxhmsize); vj--)\n{\n  if (((xadj[vj + 1] - uxadj[vj]) == 1) || (xadj[vj] == uxadj[vj]))\n    continue;\n\n  nlocal = 0;\n  if ((xadj[vj + 1] - uxadj[vj]) == (nvtxs - vj))\n  {\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (ei = uxadj[vi]; adjncy[ei] > vj; ei++)\n        ;\n\n      nlocal += ei - uxadj[vi];\n      nprobes += ei - uxadj[vi];\n    }\n\n  }\n  else\n  {\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 1;\n\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (eiend = uxadj[vi]; adjncy[eiend] > vj; eiend++)\n        ;\n\n      for (ei = uxadj[vi]; ei < eiend; ei++)\n        nlocal += hmap[adjncy[ei]];\n\n      nprobes += ei - uxadj[vi];\n    }\n\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej]] = 0;\n\n  }\n\n  if (nlocal > 0)\n    ntriangles += nlocal;\n\n}\n\n", "pragma": "omp for schedule(dynamic,DBSIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/15"}
{"code": "for (i = 1930; i <= 1943; i++)\n{\n  years_bag[j] = i;\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/0"}
{"code": "for (ii = 0; ii < NUM_THREADS; ii++)\n{\n  int start;\n  int end;\n  int px_idx;\n  int px_x;\n  int px_y;\n  int px_value;\n  start = part * ii;\n  end = start + part;\n  if (ii == (NUM_THREADS - 1))\n    end = total_px;\n\n  for (px_idx = 0; px_idx < end; px_idx++)\n  {\n    px_x = px_idx / im_width;\n    px_y = px_idx - ((px_x * im_width) + 1);\n    px_value = image(px_x, px_y);\n    result_mat(ii, px_value) = result_mat(ii, px_value) + 1;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static, NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thanhphamvan/histogram_octave/hist_omp/0"}
{"code": "for (i = 0; i < (N - 1); i++)\n  for (j = 0; j < ((N - 1) - i); j++)\n  if (p[j] > p[j + 1])\n{\n  temp = p[j];\n  p[j] = p[j + 1];\n  p[j + 1] = temp;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ssskz/Classical_Sort_Algorithm/BubbleAlgorithm/0"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n  arr1[i][j] = rand() % 10;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task2/0"}
{"code": "for (int i = 0; i < ((1 << 6) + 2); i++)\n{\n  access_to_matrix[0][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GetsuDer/Sor3D/Source/openmp_code/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  {\n    printf(\"tid %d value = %f\\n\", i, vec_ptr[(N - 1) - i]);\n  }\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/tests/map/map_threads/0"}
{"code": "for (j = 0; j < 1024; j++)\n{\n  for (i = 0; i < 1024; i++)\n  {\n    s[j] = s[j] + (r[i] * A[(i * 1024) + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/20"}
{"code": "for (int i = 0; i < rowsM1; i++)\n{\n  r[i] = (int *) calloc(colsM2, sizeof(int *));\n  for (int j = 0; j < colsM2; j++)\n  {\n    int sum = 0;\n    for (int k = 0; k < colsRows; k++)\n    {\n      sum += m1[i][k] * m2[k][j];\n    }\n\n    r[i][j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/als-movie-recommender/main/11"}
{"code": "for (int ci = 0; ci < NCELLS; ci++)\n{\n  for (int d = 0; d < NDIM; d++)\n  {\n    system_p[d] += cell(ci).momentum(d);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/90"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 1); k++)\n  {\n    forcing[m][i][j][k] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/6"}
{"code": "for (i = 0; i < nz; ++i)\n  ++AtrowIndexFrom1[Acol[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/7"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  eta = ((double) j) * dnym1;\n  for (i = 0; i <= (grid_points[0] - 1); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][j][i][m] = temp[m];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/28"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,i ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/108"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/19"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    centroid[i].x[j] = (rand() % 1500) - 750;\n    centroid_p[i].x[j] = centroid[i].x[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MahmoudAshraf97/OpenMP-KMeans-Clustering/Q1/9"}
{"code": "for (int i = 1; i < nGpyrLayers; i++)\n{\n  sigma_pre = powf(k, (float) (i - 1)) * sigma0;\n  sigma = sigma_pre * k;\n  sig[i] = sqrtf((sigma * sigma) - (sigma_pre * sigma_pre));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/3"}
{"code": "for (j = 1; j < N; j = j + 3)\n  a[j] = b[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-8/no_loop_8/1"}
{"code": "for (int i = 0; i < p; ++i)\n  prows[i] *= columns;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rdb987/2DConvolution/src/hpc_conv_hybrid/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  ival = (int) sample(arr[i]);\n  hist[ival]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram/1"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        for (n = 0; n < 5; n++)\n        {\n          lhs[i][j][k][0][m][n] = 0.0;\n          lhs[i][j][k][1][m][n] = 0.0;\n          lhs[i][j][k][2][m][n] = 0.0;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/47"}
{"code": "for (i = 0; i < n; i++)\n{\n  a = b + i;\n}\n\n", "pragma": "omp parallel for private(i), firstprivate(b), lastprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter7/fig7.7-first-lastprivate/0"}
{"code": "for (miel = 0; miel < nelt; miel++)\n{\n  iel = mt_to_id_old[miel];\n  if (ich[iel] == 4)\n  {\n    ntemp = (front[miel] - 1) * 7;\n    mielnew = miel + ntemp;\n  }\n  else\n  {\n    ntemp = front[miel] * 7;\n    mielnew = miel + ntemp;\n  }\n\n  mt_to_id[mielnew] = iel;\n  ref_front_id[iel] = nelt + ntemp;\n}\n\n", "pragma": "omp parallel for default(shared) private(miel,iel,ntemp,mielnew)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/9"}
{"code": "for (int i = 0; i < input->nRegions; i++)\n{\n  for (int j = 0; j < input->nCities; j++)\n  {\n    measures->city[i][3][j] = calculate_average(regions[i][j], input->nStudents);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/3"}
{"code": "for (i = 0; i < v_count; i++)\n{\n  tmpQ[0] = _mm256_broadcast_ss(&Q[i][0]);\n  tmpQ[1] = _mm256_broadcast_ss(&Q[i][1]);\n  tmpQ[2] = _mm256_broadcast_ss(&Q[i][2]);\n  tmpQ[3] = _mm256_broadcast_ss(&Q[i][3]);\n  tmpQ[4] = _mm256_broadcast_ss(&Q[i][4]);\n  tmpQ[5] = _mm256_broadcast_ss(&Q[i][5]);\n  tmpQ[6] = _mm256_broadcast_ss(&Q[i][6]);\n  tmpQ[7] = _mm256_broadcast_ss(&Q[i][7]);\n  tmpX[0] = _mm256_broadcast_ss(&X[i][0]);\n  tmpX[1] = _mm256_broadcast_ss(&X[i][1]);\n  tmpX[2] = _mm256_broadcast_ss(&X[i][2]);\n  tmpX[3] = _mm256_broadcast_ss(&X[i][3]);\n  tmpX[4] = _mm256_broadcast_ss(&X[i][4]);\n  tmpX[5] = _mm256_broadcast_ss(&X[i][5]);\n  tmpX[6] = _mm256_broadcast_ss(&X[i][6]);\n  tmpX[7] = _mm256_broadcast_ss(&X[i][7]);\n  tmpY[0] = _mm256_broadcast_ss(&Y[i][0]);\n  tmpY[1] = _mm256_broadcast_ss(&Y[i][1]);\n  tmpY[2] = _mm256_broadcast_ss(&Y[i][2]);\n  tmpY[3] = _mm256_broadcast_ss(&Y[i][3]);\n  tmpY[4] = _mm256_broadcast_ss(&Y[i][4]);\n  tmpY[5] = _mm256_broadcast_ss(&Y[i][5]);\n  tmpY[6] = _mm256_broadcast_ss(&Y[i][6]);\n  tmpY[7] = _mm256_broadcast_ss(&Y[i][7]);\n  tmpZ[0] = _mm256_broadcast_ss(&Z[i][0]);\n  tmpZ[1] = _mm256_broadcast_ss(&Z[i][1]);\n  tmpZ[2] = _mm256_broadcast_ss(&Z[i][2]);\n  tmpZ[3] = _mm256_broadcast_ss(&Z[i][3]);\n  tmpZ[4] = _mm256_broadcast_ss(&Z[i][4]);\n  tmpZ[5] = _mm256_broadcast_ss(&Z[i][5]);\n  tmpZ[6] = _mm256_broadcast_ss(&Z[i][6]);\n  tmpZ[7] = _mm256_broadcast_ss(&Z[i][7]);\n  vcps = _mm256_setzero_ps();\n  for (m = 0; m < 8; m++)\n  {\n    diff[0] = _mm256_sub_ps(tmpX[m], X[i]);\n    diff[1] = _mm256_sub_ps(tmpY[m], Y[i]);\n    diff[2] = _mm256_sub_ps(tmpZ[m], Z[i]);\n    r_vec = _mm256_fmadd_ps(diff[0], diff[0], _mm256_setzero_ps());\n    r_vec = _mm256_fmadd_ps(diff[1], diff[1], r_vec);\n    r_vec = _mm256_fmadd_ps(diff[2], diff[2], r_vec);\n    r_vec = _mm256_rsqrt_ps(r_vec);\n    result = _mm256_mul_ps(tmpQ[m], Q[i]);\n    result = _mm256_mul_ps(result, r_vec);\n    result = _mm256_and_ps(mask[m], result);\n    vcps = _mm256_add_ps(vcps, result);\n  }\n\n  _mm256_store_ps(tmp_add, vcps);\n  Energy += ((((((tmp_add[0] + tmp_add[1]) + tmp_add[2]) + tmp_add[3]) + tmp_add[4]) + tmp_add[5]) + tmp_add[6]) + tmp_add[7];\n  for (j = i + 1; j < v_count; j++)\n  {\n    vcps = _mm256_setzero_ps();\n    for (m = 0; m < 8; m++)\n    {\n      diff[0] = _mm256_sub_ps(tmpX[m], X[j]);\n      diff[1] = _mm256_sub_ps(tmpY[m], Y[j]);\n      diff[2] = _mm256_sub_ps(tmpZ[m], Z[j]);\n      r_vec = _mm256_fmadd_ps(diff[0], diff[0], _mm256_setzero_ps());\n      r_vec = _mm256_fmadd_ps(diff[1], diff[1], r_vec);\n      r_vec = _mm256_fmadd_ps(diff[2], diff[2], r_vec);\n      r_vec = _mm256_rsqrt_ps(r_vec);\n      result = _mm256_mul_ps(tmpQ[m], Q[j]);\n      vcps = _mm256_fmadd_ps(result, r_vec, vcps);\n    }\n\n    _mm256_store_ps(tmp_add, vcps);\n    Energy += ((((((tmp_add[0] + tmp_add[1]) + tmp_add[2]) + tmp_add[3]) + tmp_add[4]) + tmp_add[5]) + tmp_add[6]) + tmp_add[7];\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmpQ, tmpX, tmpY, tmpZ, i, j, m, diff, r_vec, vcps, tmp_add, result) reduction(+ : Energy) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/elect_energy_avx2/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int binIndex = find_binIndex(particles[i].x, particles[i].y, binWidth, gridSize);\n  particles[i].ax = (particles[i].ay = 0);\n  omp_set_lock(locks + binIndex);\n  bins[binIndex].particles.push_back(i);\n  omp_unset_lock(locks + binIndex);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jkaugust/Comparison-of-serial-OpenMP-and-MPI-programming-paradigms/openmp/1"}
{"code": "for (int i = 1; i <= n_rows; i++)\n{\n  nodes[i] = (graph_node){.inc_degree = 0, .out_nodes = 0};\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kounelisagis/OpenMP-Topological-Sorting-Algorithm/parallel/2"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  double Li_curr[K_count];\n  double Rj_curr[K_count];\n  double Li_update[K_count];\n  double Rj_update[K_count];\n  int row_index = x_row_array[vid];\n  int column_index = x_col_array[vid];\n  double Xij = x_val_array[vid];\n  for (int k = 0; k < K_count; ++k)\n  {\n    Li_curr[k] = L_table[(row_index * K_count) + k];\n    if (stale_mode == 0)\n    {\n      Rj_curr[k] = R_table[(column_index * K_count) + k];\n    }\n    else\n    {\n      Rj_curr[k] = R_table_ind[(vid * K_count) + k];\n    }\n\n  }\n\n  double LiRj = 0.0;\n  for (int k = 0; k < K_count; ++k)\n  {\n    LiRj = LiRj + (Li_curr[k] * Rj_curr[k]);\n  }\n\n  for (int k = 0; k < K_count; ++k)\n  {\n    double gradient = 0.0;\n    double Li_value = Li_curr[k];\n    double Rj_value = Rj_curr[k];\n    gradient = (((-2) * Xij) * Rj_value) + ((2 * LiRj) * Rj_value);\n    Li_update[k] = (-gradient) * step_size;\n    gradient = (((-2) * Xij) * Li_value) + ((2 * LiRj) * Li_value);\n    Rj_update[k] = (-gradient) * step_size;\n  }\n\n  for (int k = 0; k < K_count; ++k)\n  {\n    atomicAdd(&L_table[(row_index * K_count) + k], Li_update[k]);\n    atomicAdd(&R_table[(column_index * K_count) + k], Rj_update[k]);\n  }\n\n  atomicAdd(&loss_sum, (double) pow(Xij - LiRj, 2));\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/MAT_FACT/kernel/1"}
{"code": "for (int i = 0; i < matr_A.row; i++)\n{\n  for (int j = 0; j < matr_Bt.row; j++)\n  {\n    for (int k = 0; k < matr_A.col; k++)\n    {\n      matr_C.tab[i][j] += matr_A.tab[i][k] * matr_Bt.tab[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/0"}
{"code": "for (int t = 0; t < NumQs; t++)\n  fprintf(pFile, \"%.3lf,\", *(qval + t));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/15"}
{"code": "for (i = 0; i < 100; i++)\n  a[i] = a[i] + 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/doall1-orig-no/0"}
{"code": "for (i = 0; i < n; i++)\n  if (eivec[i] == 0)\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/25"}
{"code": "for (i = 0; i <= 5; i++)\n{\n  fibbonaci[i].n = 38 + i;\n  fibbonaci[i].result = fib(38 + i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcinbogiel/OpenMP_examples/My solutions/exercise_6/0"}
{"code": "for (part = 0; part < 3; part++)\n{\n  isok1 = 0;\n  words = startWords;\n  repeats = startRepeats;\n  for (p = 0; p < 3; p++)\n  {\n    size_x = words * (sizeof(float));\n    x_cpu = (float *) _mm_malloc(size_x, 16);\n    if (x_cpu == 0)\n    {\n      printf(\" ERROR WILL EXIT\\n\");\n      printf(\" Press Enter\\n\");\n      g = getchar();\n      exit(1);\n    }\n\n    for (i = 0; i < words; i++)\n    {\n      x_cpu[i] = newdata;\n    }\n\n    start_time();\n    runTests();\n    end_time();\n    fpmops = ((float) words) * ((float) opwd);\n    mflops = ((((float) repeats) * fpmops) / 1000000.0f) / ((float) secs);\n    fprintf(outfile, \"%15s %9d %5d %8d %10.6f %8.0f \", title[0], words, opwd, repeats, secs, mflops);\n    printf(\"%15s %9d %5d %8d %10.6f %8.0f \", title[0], words, opwd, repeats, secs, mflops);\n    isok1 = 0;\n    float one = x_cpu[0];\n    if (one == newdata)\n    {\n      isok2 = 1;\n      isok1 = 1;\n    }\n\n    for (i = 1; i < words; i++)\n    {\n      if (one != x_cpu[i])\n      {\n        isok1 = 1;\n        if (count1 < 10)\n        {\n          errors[0][count1] = x_cpu[i];\n          errors[1][count1] = one;\n          erdata[0][count1] = i;\n          erdata[1][count1] = words;\n          erdata[2][count1] = opwd;\n          erdata[3][count1] = repeats;\n          count1 = count1 + 1;\n        }\n\n      }\n\n    }\n\n    if (isok1 == 0)\n    {\n      fprintf(outfile, \" %10.6f   Yes\\n\", x_cpu[0]);\n      printf(\" %10.6f   Yes\\n\", x_cpu[0]);\n    }\n    else\n    {\n      fprintf(outfile, \"   See later   No\\n\");\n      printf(\"   See log     No\\n\");\n    }\n\n    _mm_free(x_cpu);\n    words = words * 10;\n    repeats = repeats / 10;\n    if (repeats < 1)\n      repeats = 1;\n\n  }\n\n  fprintf(outfile, \"\\n\");\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NiramayVaidya/Linux_OpenMP_Benchmark_Results/code_and_results_files/32_bit/openmp/code/OpenMPMFLOPS/2"}
{"code": "for (int i = 1; i < dims[0][2]; i++)\n{\n  randlc(&start, an);\n  starts[i] = start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/FT/ft/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,m ,j ,ist ,k ,u21j ,u31j ,u41j ,u51j ,tmp ,u21jm1 ,u31jm1 ,u41jm1 ,u51jm1 ,ty2 ,jst ,jend ,ty3 ,L2 ,ty1 ,dy1 ,dy2 ,dy3 ,dy4 ,dy5 ,dssp ,ny ,nz ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/79"}
{"code": "for (g6 = 0; g6 < 1; ++g6)\n{\n  int zk;\n  for (zk = 0; zk < 1; ++zk)\n  {\n    oh += zk / (zk + 1);\n    for (;;)\n    {\n    }\n\n  }\n\n  a6 = &zk;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/monellz/libgomp-aid/gcc/testsuite/gcc.dg/gomp/pr88105/0"}
{"code": "for (int i = start; i < end; i++)\n{\n  int new_assignment = get_closest_center(centers, data[i]);\n  if (new_assignment != assignments[i])\n  {\n    changed++;\n    assignments[i] = new_assignment;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_parakmeans/0"}
{"code": "for (i = 0; i < 350; i++)\n{\n  omp_rank = omp_get_thread_num();\n  for (j = 0; j < 350; j++)\n  {\n    M1[i][j] = 0;\n    for (int k = 0; k < 350; k++)\n    {\n      for (int k = 0; k < 100; k++)\n        M3[i][j] = M3[i][j] + (M1[i][k] * M2[k][j]);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PaletiKrishnasai/High-Performance-Computing/Week2/Matrix_mul_mp/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\t %d\\t\\t %d\\t\\t %d\\n\", i, a[i], b[i], c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A-Nikhil/OpenMP-Programming/Lab_1/vectorAdd/2"}
{"code": "for (i = 0; i < cache->sets; i++)\n{\n  if (cache->cacheLines[i])\n    free(cache->cacheLines[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/5"}
{"code": "for (int j = k + 1; j < size; j++)\n  a_[i][j] -= _val * _r1[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/3"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < cols; ++j)\n  {\n    const int out_offset = i + (j * rows);\n    double red = 0;\n    double green = 0;\n    double blue = 0;\n    for (int x = i - radius; x <= (i + radius); ++x)\n    {\n      for (int y = j - radius; y <= (j + radius); ++y)\n      {\n        if ((((x >= 0) && (x < rows)) && (y >= 0)) && (y < cols))\n        {\n          int kxx = x - (i - radius);\n          int kyy = y - (j - radius);\n          const int in_offset = x + (y * rows);\n          const int k_offset = kxx + (kyy * dim);\n          red += kernel[k_offset] * in[in_offset].red;\n          green += kernel[k_offset] * in[in_offset].green;\n          blue += kernel[k_offset] * in[in_offset].blue;\n        }\n\n      }\n\n    }\n\n    out[out_offset].red = red;\n    out[out_offset].green = green;\n    out[out_offset].blue = blue;\n    intensity[out_offset] = ((out[out_offset].red + out[out_offset].green) + out[out_offset].blue) / 3.0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishig25/2017Block2/patterns/stencil/openmp/0"}
{"code": "for (i = 0; i < 80; i++)\n{\n  for (j = 1; j < 80; j++)\n  {\n    ex[(i * (80 + 1)) + j] = ex[(i * (80 + 1)) + j] - (0.5 * (hz[(i * 80) + j] - hz[(i * 80) + (j - 1)]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/36"}
{"code": "for (i = 1; i < (N + 1); i++)\n{\n  if (mx[i] > max)\n    max = mx[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/second/functions/6"}
{"code": "for (int i = 0; i < a.length; i++)\n{\n  sum = sum + (a.val[i] * b.val[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) lastprivate(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/5"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  if (hDist[i] > 0)\n    printf(\"I = %d, count = %d, fraction = %f\\n\", i, hDist[i], ((real_t) hDist[i]) / ((real_t) hsize));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/8"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 3; k <= (grid_points[2] - 4); k += 1)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/76"}
{"code": "for (int j = 0; j < omp_p; j++)\n{\n  unsigned int seed = (j * p) + myrank;\n  size_t start = (j * N) / omp_p;\n  size_t end = ((j + 1) * N) / omp_p;\n  for (unsigned int i = start; i < end; i++)\n  {\n    in[i] = rand_r(&seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hsundar/usort/src/main/1"}
{"code": "for (int i = 0; i < numVertices; i++)\n{\n  for (int j = 0; j < numVertices; j++)\n  {\n    randomValue = rand() % 20;\n    if (randomValue == 0)\n    {\n      randomValue = 9999;\n    }\n\n    randomGraph[i][j] = randomValue;\n    randomGraph[j][i] = randomValue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JFcoZC/PrimMSTParallelOpenMP/PrimSTPOpenMP/3"}
{"code": "for (i = 1; i < iteration_cnt; i++)\n{\n  memcpy(&ctx1, &tmp_ctx1, (sizeof(SHA_CTX)) - (64 + (sizeof(unsigned int))));\n  SHA1_Update(&ctx1, (unsigned char *) tmp_hash, SHA_DIGEST_LENGTH);\n  SHA1_Final((unsigned char *) tmp_hash, &ctx1);\n  memcpy(&ctx2, &tmp_ctx2, (sizeof(SHA_CTX)) - (64 + (sizeof(unsigned int))));\n  SHA1_Update(&ctx2, (unsigned char *) tmp_hash, SHA_DIGEST_LENGTH);\n  SHA1_Final((unsigned char *) tmp_hash, &ctx2);\n  for (j = 0; j < 4; j++)\n    _key[j] ^= tmp_hash[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash2_fmt_plug/7"}
{"code": "for (v = 0; v < cache->numPropertyRegions; ++v)\n{\n  printf(\" -----------------------------------------------------\\n\");\n  printf(\"| %-25s | %-24u| \\n\", \"ID\", v);\n  printf(\" -----------------------------------------------------\\n\");\n  printf(\"| %-25s | %-24u| \\n\", \"size (Bytes)\", cache->propertyRegions[v].size);\n  printf(\"| %-25s | %-24u| \\n\", \"data_type_size (Bytes)\", cache->propertyRegions[v].data_type_size);\n  printf(\"| %-25s | 0x%-22lx| \\n\", \"base_address\", cache->propertyRegions[v].base_address);\n  printf(\" -----------------------------------------------------\\n\");\n  printf(\"| %-25s | %-24u| \\n\", \"fraction\", cache->propertyRegions[v].fraction);\n  printf(\"| %-25s | 0x%-22lx| \\n\", \"lower_bound\", cache->propertyRegions[v].lower_bound);\n  printf(\"| %-25s | 0x%-22lx| \\n\", \"hot_bound\", cache->propertyRegions[v].hot_bound);\n  printf(\"| %-25s | 0x%-22lx| \\n\", \"warm_bound\", cache->propertyRegions[v].warm_bound);\n  printf(\"| %-25s | 0x%-22lx| \\n\", \"upper_bound\", cache->propertyRegions[v].upper_bound);\n  printf(\" -----------------------------------------------------\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/50"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  tmp = tmp + (qbnew[0][0][i - 1] * tx[0][i][0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/9"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  processor *p = cur->data;\n  if (p->new_x != p->x)\n    something_changed = 1;\n\n  p->x = p->new_x;\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/leader_elect_dp/1"}
{"code": "for (int j = 1; j < (n - 1); j++)\n{\n  for (int i = 1; i < (m - 1); i++)\n  {\n    A[j][i] = Anew[j][i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jefflarkin/GTC16-S6510/c99/01-threaded-fused/laplace2d/1"}
{"code": "for (i = 254; 1 <= i; i--)\n{\n  de = -log((ve / de) + exp(-de));\n  ke[i + 1] = (uint32_t) ((de / te) * m2);\n  te = de;\n  fe[i] = (float) exp(-de);\n  we[i] = (float) (de / m2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/ziggurat_openmp_original/12"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  p[j] = r[j] + (beta * p[j]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/10"}
{"code": "for (u = 0; u < nb_usr; u++)\n{\n  for (n = 1; n <= block_len; n++)\n  {\n    nom = -INFINITY;\n    denom = -INFINITY;\n    for (s = 0; s < chtrellis.stateNb; s++)\n    {\n      for (k = 0; k < chtrellis.numInputSymbols; k++)\n      {\n        in_chips = dec2bin(nb_usr, k);\n        buffer = ((A[s + ((n - 1) * chtrellis.stateNb)] + B[chtrellis.nextState[s + (k * chtrellis.stateNb)] + (n * chtrellis.stateNb)]) - (sqr(rec_sig[n - 1] - chtrellis.output[s + (k * chtrellis.stateNb)]) / (2 * sigma2))) + (to_vec(in_chips) * apriori_data.get_col(n - 1));\n        if (in_chips[u])\n        {\n          nom = max(nom, buffer);\n        }\n        else\n        {\n          denom = max(denom, buffer);\n        }\n\n      }\n\n    }\n\n    extrinsic_data(u, n - 1) = (nom - denom) - apriori_data(u, n - 1);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(u,n,s,k,nom,denom,in_chips,buffer)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_mud/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  _minI = 0;\n  _maxI = 0;\n  _min = matrix[0][0];\n  _max = matrix[0][0];\n  _total = 0;\n  for (j = 0; j < size; j++)\n  {\n    _temp = matrix[i][j];\n    _total += _temp;\n    if (_temp < _min)\n    {\n      _min = _temp;\n      _minI = (i * size) + j;\n    }\n    else\n      if (_temp > _max)\n    {\n      _max = _temp;\n      _maxI = (i * size) + j;\n    }\n\n\n  }\n\n  printf(\"%d (%d): %d %d %d\\n\", omp_get_thread_num(), i, _min, _max, _total);\n}\n\n", "pragma": "omp for reduction(+ : total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannesrabo/concurrent-programming/hw2/matrixSum-openmp-new/0"}
{"code": "for (int nL1 = 0; nL1 < np->num_units_in_layer[0]; nL1++)\n{\n  neural_net[0][nL1] = np->layer_weight_matrices[0][nL1][0];\n  for (int k = 0; k < np->num_inputs; k++)\n  {\n    neural_net[0][nL1] += np->layer_weight_matrices[0][nL1][k + 1] * dataset->data[example][k];\n  }\n\n  neural_net[0][nL1] = 1 / (1 + exp((-1.0) * neural_net[0][nL1]));\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DaveK2301/C-neural-nets_MLP/NN_functions_OMP/0"}
{"code": "for (i = 0; i < 729; i++)\n{\n  for (j = 0; j < 729; j++)\n  {\n    b[i][j] = ((double) ((i * j) + 1)) / ((double) (729 * 729));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IKrepo/OpenMP_Scheduling/Part A/Part_A_Mean/5"}
{"code": "for (size_t i = 0; i < 5; i++)\n{\n  a[i] = i * 0.5;\n  b[i] = i * 2.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hermannwilfried694/OpenMP1/for/1"}
{"code": "for (unsigned j = 0; j < I; ++j)\n{\n  unsigned r1 = 0;\n  for (unsigned r = 0; r < P1; ++r)\n    r1 += R1[r];\n\n  unsigned R2[P2];\n  for (unsigned r = 0; r < P2; ++r)\n    R2[r] = (ii + r) + 7;\n\n  Arr(A, i, j, 0) += r1;\n  Arr(B, i, j, 0) += r1;\n  for (unsigned k = 0; k < I; ++k)\n  {\n    unsigned r2 = 0;\n    for (unsigned r = 0; r < P2; ++r)\n      r2 += R2[r];\n\n    Arr(A, i, j, k) += r2;\n    Arr(B, i, j, k) += r2;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-data-sharing-many-teams/test/1"}
{"code": "for (i = 1; i < n; i++)\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n\n", "pragma": "omp for nowait linear(i,j) collapse(456) ordered(i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor10/0"}
{"code": "for (int i = iters.size() - 1; i >= 0; i--)\n{\n  N_strs[i] = iter_i(i) + N_strs[i + 1];\n  if (i < (((int) iters.size()) - 1))\n  {\n    out += \",const int _N\" + N_strs[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/einsxiao/evawiz/evawiz/src/evacc/syntax_launch_kernel/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  sum += a[i] + b[i];\n  printf(\"%d\\n\", sum);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Sum_of_arrays_using_reduction/0"}
{"code": "for (j = 0; j < n; j++)\n  d[j] = e[j] * f;\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q7/2"}
{"code": "for (it = arr.begin(); it != arr.end(); ++it)\n{\n  delete * it;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/scan/2"}
{"code": "for (k = 1; k < 5; k++)\n  courant += fabs(coef[k]) * 6;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesxu90/Speedup-program-using-OpenMP-and-OpenACC-on-CUDA-and-Coprocessor/HW2/openmp/cs280hw2t1/cpu/src/driver/3"}
{"code": "for (i = 1; i < (2048 + 1); i++)\n{\n  for (j = 1; j < (2048 + 1); j++)\n  {\n    if (percentDiff(symmat[(i * (2048 + 1)) + j], symmat_outputFromGpu[(i * (2048 + 1)) + j]) > 1.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/COVAR/src/covariance/1"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n      fprintf(stderr, \"OK\\n\");\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(stderr, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(stderr, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(stderr, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static/7"}
{"code": "for (int i = 0; i < 1; i++)\n{\n  for (int j = 0; j < 40; j++)\n  {\n    printf(\"**\");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jacob273/JG.TechLearning.OpenMP/lab1/multiplication/4"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttx2 * speed[i - 1][j][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttx2 * speed[i + 1][j][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttx2 * speed[i - 1][j][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttx2 * speed[i + 1][j][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/59"}
{"code": "for (uint32_t px = 0; px < (pOutImage->width * pOutImage->height); px++)\n{\n  unNormalizedGradient.data[px] = norm2(pInMatrixX->data[px], pInMatrixY->data[px]);\n}\n\n", "pragma": "omp parallel for shared(unNormalizedGradient)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ricordel/parallel-sobel/sobel/implem_omp/4"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  a = i * 50;\n  printf(\"\\n\");\n}\n\n", "pragma": "omp parallel for firstprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/djaliiil/OpenMP/test/0"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  x = drandom();\n  y = drandom();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc = Ncirc + 1;\n\n}\n\n", "pragma": "omp for private(x, y, test) firstprivate(r) reduction(+ : Ncirc)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adaickalavan/OpenMP-Tim-Mattson/apps/pi_mc/0"}
{"code": "for (i = 0; i < 999; ++i)\n{\n  j = P[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/simd/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    b[i] = b[i] + (a[i + (j * lda)] * x[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/11"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%f\", *((mat + (i * n)) + j));\n    if (j == (n - 1))\n    {\n      printf(\"\\n\");\n    }\n    else\n    {\n      printf(\", \");\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/2"}
{"code": "for (int i = 0; i < NUMBODIES; ++i)\n{\n  p[i].for_x = fx[i];\n  p[i].for_y = fy[i];\n  p[i].for_z = fz[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GChaitanya2001/HP3-OpenMP/Many Body Simulation/many-body-sim-program/1"}
{"code": "for (int cout = 0; cout < kernel.Cout; cout++)\n{\n  for (int cin = 0; cin < kernel.Cin; cin++)\n  {\n    for (int hk = 0; hk < kernel.H; hk++)\n    {\n      for (int wk = 0; wk < kernel.W; wk++)\n      {\n        posH = hk * kernel.dilH;\n        posW = wk * kernel.dilW;\n        kernel_idx = find_kernel_idx(cout, cin, hk, wk, kernel);\n        kernel_idx_new = find_CCHW_idx(cout, cin, posH, posW, kernel.Cout, kernel.Cin, newH, newW);\n        B_dil[kernel_idx_new] = kernel.data[kernel_idx];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/utils/10"}
{"code": "for (j = 0; j < NRA; j++)\n  a[j] = (double *) malloc((sizeof(double)) * NCA);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TELESIO/OpenMP4.5/example/MatrixMultiplication/cpu/mm/0"}
{"code": "for (int i = claster_start + 1; i <= claster_end; i++)\n{\n  x = ((2.0 * i) - 1) / (2.0 * n);\n  sum += 4.0 / (1 + (x * x));\n}\n\n", "pragma": "#pragma omp parallel for private(x) shared(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EternalNeophyte/mpi-labs/MPILabs/6"}
{"code": "for (int kx = 1; kx <= kx_max; kx++)\n{\n  for (int ky = 1; ky <= ky_max; ky++)\n  {\n    BL[kx][ky] = Zmin;\n    WL[kx][ky] = Zmin;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/69"}
{"code": "for (int i = 0; i < length; i++)\n{\n  unsigned long x = data[i];\n  x -= (x >> 1) & m1;\n  x = (x & m2) + ((x >> 2) & m2);\n  x = (x + (x >> 4)) & m4;\n  result[i] = (x * h01) >> 56;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/4"}
{"code": "for (i = 0; i < NUM_BUCKETS; i++)\n  for (k = myid + 1; k < num_procs; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/11"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/70"}
{"code": "for (i = 1; i < num_proc; i++)\n{\n  MPI_Send(&co1, 1, MPI_DOUBLE, i, tag, 1);\n  MPI_Send(&co2, 1, MPI_DOUBLE, i, tag, 1);\n  MPI_Send(&co3, 1, MPI_DOUBLE, i, tag, 1);\n  MPI_Send(&co4, 1, MPI_DOUBLE, i, tag, 1);\n  MPI_Send(&numOfCharsInSeq1, 1, MPI_INT, i, tag, 1);\n  MPI_Send(seq1[0], numOfCharsInSeq1, MPI_CHAR, i, tag, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/asafsuryano/Parallel-Sequence-alignment/src/parallel_project/1"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  x[j] = norm_temp2 * z[j];\n}\n\n", "pragma": "omp parallel for default(shared) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/4"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  ((cout << \"\\n\") << arr[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/bubble_sort_openmp/2"}
{"code": "for (i = 0; i < n; i += 1)\n{\n  free(year[i].Res);\n  free(year[i].P);\n  free(year[i].Cost);\n  free(year[i].B);\n  free(year[i].CostC);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elf11/Parallel-Processing/OpenMP/paralel/8"}
{"code": "for (col = 0; col <= (public.in2_pad_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_pad_rows - 1); row += 1)\n  {\n    if ((((row > (public.in2_pad_add_rows - 1)) && (row < (public.in2_pad_add_rows + public.in2_rows))) && (col > (public.in2_pad_add_cols - 1))) && (col < (public.in2_pad_add_cols + public.in2_cols)))\n    {\n      ori_row = row - public.in2_pad_add_rows;\n      ori_col = col - public.in2_pad_add_cols;\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = private.d_in2_sqr[(ori_col * public.in2_rows) + ori_row];\n    }\n    else\n    {\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/17"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/118"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * (((5.0 * u[i][j][k][m_imopVar133]) - (4.0 * u[i][j][k + 1][m_imopVar133])) + u[i][j][k + 2][m_imopVar133]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/70"}
{"code": "for (i = 0; i < num_vertices; ++i)\n{\n  edgeList->mask_array[i] = edgeListmem->mask_array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/3"}
{"code": "for (int i = 0; i < num; i++)\n{\n  long double sum = 0;\n  long double tmp;\n  if (pairs[i + 1].first <= 0)\n  {\n    for (int j = 0; j < 14; j++)\n      sum += pow(pairs[i + 1].first, j) * gostTo0[j];\n\n    tmp = abs(pairs[i + 1].second - sum);\n  }\n  else\n  {\n    for (int j = 0; j < 11; j++)\n      sum += pow(pairs[i + 1].first, j) * gostTo1000[j];\n\n    tmp = abs(pairs[i + 1].second - sum);\n  }\n\n  if (error < tmp)\n    error = tmp;\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SultanGG505/Parall_OpenMP/MethodOfLessCubs/MethodOfLessCubs/7"}
{"code": "for (m = 1; m <= nnnnn; m++)\n{\n  k = ((int) ((m - 1) / nnn)) + 1;\n  j = ((int) (((m - 1) - ((k - 1) * nnn)) / (n1 - 2))) + 1;\n  i = (m - ((j - 1) * (n1 - 2))) - ((k - 1) * nnn);\n  vv[i][j][k] = r[m - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Restriction/0"}
{"code": "for (int i = 0; i < n; i++)\n  if (node_type[offset[i]] == marker)\n  offset[count++] = offset[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/7"}
{"code": "for (int i = 0; i < N; i++)\n{\n  kernel_matrix(i, i) = diag;\n  for (int j = 0; j < i; j++)\n  {\n    u = sum(pow(X.row(i) - X.row(j), 2));\n    if ((u > (-1)) && (u < 1))\n      kernel_matrix(j, i) = pow(1 - (u * u), 3);\n\n    kernel_matrix(i, j) = kernel_matrix(j, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/utilities/2"}
{"code": "for (i = 1; i < n; i++)\n{\n  if (A[i].valid)\n  {\n    ;\n  }\n\n  ;\n  edge *msg;\n  for (msg = A[i].unprocessed_msgs; msg != 0; msg = msg->next)\n  {\n    ;\n  }\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tjj5036/kcore-openmp/parallel_kcore/8"}
{"code": "for (size_t aid = 0; aid < m_atoms.size(); ++aid)\n{\n  m_atoms[aid]->calculate_position(m_dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-zero/CppMD/sources/solvers/md_solver/3"}
{"code": "for (int k = 0; k < c_len; k++)\n{\n  P_Matrix[k] = (short *) calloc(len_b + 1, sizeof(short));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v1/row_wise_v1/2"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n  for (k = i; k < 2048; k++)\n  B[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP1/PA2-Prob1-bobo/2"}
{"code": "for (int i = 0; i <= sen.length(); i++)\n{\n  if (endword > finLength)\n  {\n    break;\n  }\n\n  senWord = substring(start, endword, sen);\n  if (senWord.compare(word) == 0)\n  {\n    count++;\n    if (endword > finLength)\n    {\n      break;\n    }\n\n  }\n\n  start += 1;\n  endword += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Francis-Alex-Kuzhippallil/Parallel-Word-Search-Using-OpenMP/Optimized Parallel Execution/1"}
{"code": "for (j = 0; j < numprocs; j++)\n{\n  if (j < (procs_per_angle * num_angles))\n  {\n    incl_procs[count] = j;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/1"}
{"code": "for (int var = 0; var < 2; var++)\n{\n  int tc = var * chrmsm[var].size();\n  for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++)\n  {\n    Lastst = Lastet + 1;\n    taskList[tc].setStarttime(Lastst);\n    Lastet = Lastst + ((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    taskList[tc].setEndtime(Lastet);\n    taskList[tc].setExectime((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    taskListNoDup.push_back(taskList[tc]);\n    tc++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/18"}
{"code": "for (i = 0; i < size; ++i)\n{\n  printf(\"tid = %d, a[%d] = %d, b[%d] = %d\\n\", tids[i], i, a[i], i, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dmitriyklebanov/made_2020_hpc/3/src/omp_privateshared/2"}
{"code": "for (i = 0; i < M; i++)\n{\n  U[i + 1][N] = U[i + 1][0];\n  V[i][0] = V[i][N];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/14"}
{"code": "for (i = 0; i <= N; i++)\n{\n  fibbonaci[i].n = 38 + i;\n  fibbonaci[i].result = fib(38 + i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcinbogiel/OpenMP_examples/My solutions/exercise_6/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] = x[i] + (a / (i + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment9/Task1/Dependency/7"}
{"code": "for (int i = 0; i <= (nx + 1); i++)\n{\n  for (int j = 0; j <= (ny + 1); j++)\n  {\n    b[i][j] = i_asagiScenario.getBathymetryAndDynamicDisplacement(offsetX + ((i - 0.5f) * dx), offsetY + ((j - 0.5f) * dy), i_time);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_WaveAccumulationBlock/3"}
{"code": "for (int i = 0; i < m3.n; i++)\n{\n  for (int j = 0; j < m3.m; j++)\n  {\n    m3.values[i][j] *= product;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(thread)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/niosega/Matrix-OpenMp/matrix/2"}
{"code": "for (i = 0; i < nx; i++)\n{\n  currWorld[i] = ((char *) (currWorld + nx)) + (i * ny);\n  nextWorld[i] = ((char *) (nextWorld + nx)) + (i * ny);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harunsasmaz/Game-Of-Life/source code/life-prl/1"}
{"code": "for (i = 0; i < (itersperthr * nthreads); i++)\n{\n  delay(delaylength);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/epcc-c/schedbench/0"}
{"code": "for (k = 0; k < 256; k++)\n  for (j = 0; j < 256; j++)\n  for (i = 0; i < 256; i++)\n{\n  in_fftw[k][j][i][0] = (float) ((sin((M_PI * ((float) i)) / 64.0) + sin((M_PI * ((float) i)) / 32.0)) + sin(M_PI * (((float) i) / 16.0)));\n  in_fftw[k][j][i][1] = 0;\n}\n\n\n\n", "pragma": "omp for schedule(static,1) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dumitrux/Parallelism-FIB/Laboratorio/Lab1/Material-lab1/lab1/3dfft/3dfft_omp/0"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    G[(i * 3000) + j] = 0;\n    for (k = 0; k < 3000; ++k)\n    {\n      G[(i * 3000) + j] += E[(i * 3000) + k] * F[(k * 3000) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm_cpu/10"}
{"code": "for (i = 0; i < 20000; i++)\n  for (j = 0; j < 20000; j++)\n  graph[i][j] = rand() % 10;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Parth-31/Parallel-Prims-Algorithm-using-OpenMP/Code/primspar/4"}
{"code": "for (int i = 0; i < numRuns; ++i)\n{\n  memset(C_serial, 0, (size * size) * (sizeof(int)));\n  double startTime = currentSeconds();\n  matmul_serial2(size, A, B, C_serial);\n  double endTime = currentSeconds();\n  minSerial = min(minSerial, endTime - startTime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artalukd/toRustOrNot/C++/matrixmultiply/main/4"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = 0; j < col; j++)\n  {\n    *((arr + (i * col)) + j) = ((4.0 * rand()) / RAND_MAX) - 2.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muyuuuu/High-performance-computing/\u7b2c\u4e09\u6b21\u4f5c\u4e1a(\u77e9\u9635\u5e76\u884c\u4e58\u6cd5)/matrix/0"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->vertices[i] == frontier_id)\n  {\n    int start_edge = g->outgoing_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->outgoing_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int neighbor_node = g->outgoing_edges[neighbor];\n      if (frontier->vertices[neighbor_node] == NOT_FRONTIER_MARKER)\n      {\n        next_frontier_cnt++;\n        distances[neighbor_node] = distances[i] + 1;\n        frontier->vertices[neighbor_node] = frontier_id + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:next_frontier_cnt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zonghan0904/2020_Fall_PP/HW3/part2/breadth_first_search/bfs/0"}
{"code": "for (int i = 0; i < m_chNumber; i++)\n{\n  int order = (int) m_streamOrder[i];\n  m_reachLayers[order].push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/KinWavSed_CH/KinWavSed_CH/4"}
{"code": "for (i = 0; i < valptr; i++)\n  printf(\"%c\", val[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TransientObject/ParallelizeAlgos/lib/huffman_compression_main_proj/openmp_version/8"}
{"code": "for (int v = 0; v < nvtxs; ++v)\n{\n  for (ssize_t e = xadj[v]; e < xadj[v + 1]; ++e)\n  {\n    printf(\"(%2d, %2d) perm[%2d, %2d] = %d\\n\", v + 1, adjncy[e] + 1, vault->iperm[v] + 1, vault->iperm[adjncy[e]] + 1, adjwgt[e]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/27"}
{"code": "for (i = 0; i < (numprocs - 1); i++)\n{\n  MPI_Send((all_points + (*my_points_size)) + (i * slave_portion), slave_portion, *MPI_Point_type, i + 1, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/5"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  ws = 0.0;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + kk]);\n    zt1 = (-cimagf(exyz[2 + (3 * (j + kj))])) + (crealf(exyz[2 + (3 * (j + kj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + kj))])) + (crealf(exyz[1 + (3 * (j + kj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + kj)])) + (crealf(exyz[3 * (j + kj)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + kj)] - (dth * (dky * zt1));\n    zt5 = bxyz[1 + (3 * (j + kj))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (3 * (j + kj))] - (dth * ((dkx * zt2) - (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + kj)] + (cdt * (dky * zt1))) - (afdt * cu[3 * (j + kj)]);\n    zt8 = (exyz[1 + (3 * (j + kj))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (3 * (j + kj))]);\n    zt9 = (exyz[2 + (3 * (j + kj))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (3 * (j + kj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + kj)] = zt7;\n    exyz[1 + (3 * (j + kj))] = zt8;\n    exyz[2 + (3 * (j + kj))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n    bxyz[3 * (j + kj)] = zt4;\n    bxyz[1 + (3 * (j + kj))] = zt5;\n    bxyz[2 + (3 * (j + kj))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    zt1 = (-cimagf(exyz[2 + (3 * (j + k1))])) + (crealf(exyz[2 + (3 * (j + k1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + k1))])) + (crealf(exyz[1 + (3 * (j + k1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + k1)])) + (crealf(exyz[3 * (j + k1)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + k1)] + (dth * (dky * zt1));\n    zt5 = bxyz[1 + (3 * (j + k1))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (3 * (j + k1))] - (dth * ((dkx * zt2) + (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + k1)] - (cdt * (dky * zt1))) - (afdt * cu[3 * (j + k1)]);\n    zt8 = (exyz[1 + (3 * (j + k1))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (3 * (j + k1))]);\n    zt9 = (exyz[2 + (3 * (j + k1))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (3 * (j + k1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + k1)] = zt7;\n    exyz[1 + (3 * (j + k1))] = zt8;\n    exyz[2 + (3 * (j + k1))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 += dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n    bxyz[3 * (j + k1)] = zt4;\n    bxyz[1 + (3 * (j + k1))] = zt5;\n    bxyz[2 + (3 * (j + k1))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * ((j + kj) + l1)] = zero;\n    bxyz[1 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[2 + (3 * ((j + kj) + l1))] = zero;\n    exyz[3 * ((j + kj) + l1)] = zero;\n    exyz[1 + (3 * ((j + kj) + l1))] = zero;\n    exyz[2 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[3 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    exyz[3 * ((j + k1) + l1)] = zero;\n    exyz[1 + (3 * ((j + k1) + l1))] = zero;\n    exyz[2 + (3 * ((j + k1) + l1))] = zero;\n  }\n\n  afdt = adt * cimagf(ffc[kk]);\n  zt1 = (-cimagf(exyz[2 + (3 * kj)])) + (crealf(exyz[2 + (3 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(exyz[3 * kj])) + (crealf(exyz[3 * kj]) * _Complex_I);\n  zt4 = bxyz[3 * kj] - (dth * (dky * zt1));\n  zt6 = bxyz[2 + (3 * kj)] + (dth * (dky * zt3));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exyz[3 * kj] + (cdt * (dky * zt1))) - (afdt * cu[3 * kj]);\n  zt9 = (exyz[2 + (3 * kj)] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * kj)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exyz[3 * kj] = zt7;\n  exyz[1 + (3 * kj)] = zero;\n  exyz[2 + (3 * kj)] = zt9;\n  ws += anorm * ((zt7 * conjf(zt7)) + (zt9 * conjf(zt9)));\n  zt4 -= dth * (dky * zt1);\n  zt6 += dth * (dky * zt3);\n  bxyz[3 * kj] = zt4;\n  bxyz[1 + (3 * kj)] = zero;\n  bxyz[2 + (3 * kj)] = zt6;\n  wp += anorm * ((zt4 * conjf(zt4)) + (zt6 * conjf(zt6)));\n  bxyz[3 * k1] = zero;\n  bxyz[1 + (3 * k1)] = zero;\n  bxyz[2 + (3 * k1)] = zero;\n  exyz[3 * k1] = zero;\n  exyz[1 + (3 * k1)] = zero;\n  exyz[2 + (3 * k1)] = zero;\n  bxyz[3 * (kj + l1)] = zero;\n  bxyz[1 + (3 * (kj + l1))] = zero;\n  bxyz[2 + (3 * (kj + l1))] = zero;\n  exyz[3 * (kj + l1)] = zero;\n  exyz[1 + (3 * (kj + l1))] = zero;\n  exyz[2 + (3 * (kj + l1))] = zero;\n  bxyz[3 * (k1 + l1)] = zero;\n  bxyz[1 + (3 * (k1 + l1))] = zero;\n  bxyz[2 + (3 * (k1 + l1))] = zero;\n  exyz[3 * (k1 + l1)] = zero;\n  exyz[1 + (3 * (k1 + l1))] = zero;\n  exyz[2 + (3 * (k1 + l1))] = zero;\n  sum3 += ws;\n  sum4 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,dkx,afdt,zt1,zt2,zt3,zt4,zt5,zt6,zt7,zt8,zt9, ws,wp) reduction(+:sum3,sum4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/20"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    unew[i + 1][j] = (uold[i + 1][j] + ((tdts8 * (z[i + 1][j + 1] + z[i + 1][j])) * (((cv[i + 1][j + 1] + cv[i][j + 1]) + cv[i][j]) + cv[i + 1][j]))) - (tdtsdx * (h[i + 1][j] - h[i][j]));\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/7"}
{"code": "for (int i = 1; i <= TMAX; ++i)\n{\n  avg_times[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vidit23/ParallelProgramming/Assignment-1/Q3/q3/2"}
{"code": "for (i = 0; i < DATA; i++)\n  m[i] /= 1.0 * N;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/9"}
{"code": "for (i = 0; i < N; i++)\n  xi[i] = (((-1) * (i + 1)) * rand()) * 1.0E-6;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/nbody/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  static int tmp = 0;\n  tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/2018-static-origin-yes/0"}
{"code": "for (i = 0; i < cols; i++)\n{\n  result[i] = 0;\n  int j = 0;\n  for (j = 0; j < 4; j++)\n  {\n    result[i] += matrix[j][i] * vector[j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ric0rdanza/HPC_Openmp_GEMV/hpc-mpi/0"}
{"code": "for (int i = 0; i < N3; i++)\n{\n  if (abs(f[i].real() - g[i].real()) > 1e-3)\n    wrong = true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/test/fft/2"}
{"code": "for (int k = 1; k <= n; k++)\n{\n  c[i][j][k] = a[i][k] * b[k][j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/MatricesCREW/2"}
{"code": "for (j = 0; j < K; j++)\n  if (i != j)\n{\n  devidedDistances += clusters[i].diameter / sqrt((pow(clusters[i].centerX - clusters[j].centerX, 2) + pow(clusters[i].centerY - clusters[j].centerY, 2)) + pow(clusters[i].centerZ - clusters[j].centerZ, 2));\n}\n\n\n", "pragma": "#pragma omp parallel for reduction(+ : devidedDistances)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SlavKhizverg/Parallel-Computation---written-in-C-using-openMP-and-MPI/ParallelProject/Source/8"}
{"code": "for (i = 0; i < order; i += Tile_order)\n  for (j = 0; j < order; j += Tile_order)\n  for (it = i; it < MIN(order, i + Tile_order); it++)\n  for (jt = j; jt < MIN(order, j + Tile_order); jt++)\n{\n  B[jt + (order * it)] += A[it + (order * jt)];\n  A[it + (order * jt)] += 1.0;\n}\n\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Transpose/transpose/3"}
{"code": "for (int u = 0; u < (H - 1); u++)\n{\n  ch_image[(u * W) + 0] = BLACKPIXEL;\n  ch_image[(u * W) + (W - 1)] = BLACKPIXEL;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filipe3x/esqueletizacao_openmp/skeletonize/4"}
{"code": "for (int i = (N / 8) * 5; i < ((N / 4) * 3); i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n  {\n    total *= sp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task7/4"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    double sum = 0;\n    for (k = 0; k < K; k++)\n    {\n      sum += matrixA[(i * K) + k] * matrixB[(k * N) + j];\n    }\n\n    matrixC[(i * N) + j] = (alpha * sum) + (beta * matrixC[(i * N) + j]);\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(2) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/lds-prob3/lds-prob3/3"}
{"code": "for (i = 1; i < (Nx - 1); ++i)\n  for (j = 1; j < (Ny - 1); ++j)\n  un[i][j] = ((((2 * u[i][j]) - uo[i][j]) + (cx2 * ((u[i - 1][j] - (2 * u[i][j])) + u[i + 1][j]))) + (cy2 * ((u[i][j - 1] - (2 * u[i][j])) + u[i][j + 1]))) + (((((dt2 * 2) * c) * c) * (1 + (t / 2))) * ((y[j] * (Ly - y[j])) + (x[i] * (Lx - x[i]))));\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/set/2020/exercise2/9"}
{"code": "for (i = 0; i < (15000 * numOfProcesses); i++)\n{\n  if (TFIDF_atRoot[i].numDocsWithWord != (-1))\n  {\n    sprintf(strings[stringsCounter], \"%s@%s\\t%.16f\\n\", TFIDF_atRoot[i].document, TFIDF_atRoot[i].word, TFIDF_atRoot[i].TFIDF_value);\n    stringsCounter++;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NTHREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deepakguptancsu/TFIDF-implementation-parallel-computing/TFIDF_mpi_omp/3"}
{"code": "for (i = 0; i < numOfThreads; i++)\n  mergeHistogram(workerHistogram, histograms[i], N);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eladshoham1/Parallel_Computation_MPI_OpenMP_CUDA/main/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    C[(i * N) + j] = 0;\n    for (int k = 0; k < N; k++)\n      C[(i * N) + j] += A[(i * N) + k] * B[(k * N) + j];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RahimACM/matrix-multiplication-optimization/matrix_multiplication/2"}
{"code": "for (c_col = 0; c_col < N; c_col++)\n{\n  for (c_row = 0; c_row < M; c_row++)\n  {\n    sum = 0.0;\n    for (inner = 0; inner < K; inner++)\n    {\n      sum += A[(c_row * LDA) + inner] * B[(inner * LDB) + c_col];\n    }\n\n    C[(c_row * LDC) + c_col] = (alpha * sum) + (beta * C[(c_row * LDC) + c_col]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.hsa.c/tiling-1/4"}
{"code": "for (i = 1; i <= N; i++)\n{\n  int currentThread = omp_get_thread_num();\n  result += i;\n  printf(\"[%d]: Sum = %d\\n\", currentThread, result);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IZIDIA/OpenMP-Testing/Main_OpenMP/0"}
{"code": "for (int i = 0; i < size_matrix; i++)\n{\n  int adder = 0;\n  for (int j = 0; j < size_matrix; j++)\n  {\n    adder += matrix_A[i][j] * matrix_B[j][a];\n  }\n\n  matrix_Out[i][a] = adder;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/8"}
{"code": "for (j = 0; j < n; j++)\n  c[j] = 2.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daperador/Ejemplos-OpenMP/Prueba5/1"}
{"code": "for (int i = 0; i < 2048; i += 8)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    OMPVV_TEST_AND_SET(errors, a[i + j] != (j + 1));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_schedule_private/3"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    fread(&target[x][y], sizeof(pixel), 1, image_file);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tino415/papp-openmp/main_mpi/2"}
{"code": "for (i = 1; i < numberOfPopulations; i++)\n{\n  if (populations[i].best.evaluationValue < best.evaluationValue)\n    best = populations[i].best;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/20"}
{"code": "for (l = 0; l <= (ub - 1); l += 1)\n{\n  int l8 = l * 8;\n  real8 h1 = m[((t1 + l8) * 4) + 1];\n  real8 h2 = m[((t1 + l8) * 4) + 2];\n  real8 h3 = m[((t1 + l8) * 4) + 3];\n  nel = nell[l];\n  p[nell[l]] += (d__[l] * 64.) * (((h1 * h1) + (h2 * h2)) + (h3 * h3));\n}\n\n", "pragma": "omp parallel for private (nel,l) firstprivate (ub,t1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_livenessTest/0"}
{"code": "for (j = kmin; j < kmax; j++)\n{\n  unsigned short distKJ = graph[k][j];\n  if (distKJ == infinity)\n    continue;\n\n  for (i = 0; i < kmin; i++)\n  {\n    if (graph[i][j] > (graph[i][k] + graph[k][j]))\n    {\n      graph[i][j] = graph[i][k] + graph[k][j];\n    }\n\n  }\n\n  for (i = kmax; i < V; i++)\n  {\n    if (graph[i][j] > (graph[i][k] + graph[k][j]))\n    {\n      graph[i][j] = graph[i][k] + graph[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/8"}
{"code": "for (int k = 0; k < (nconformations * nlig); k += nlig)\n{\n  for (int i = 0; i < atoms_l; i++)\n  {\n    e_desolv = 0;\n    ind1 = ligtype[i];\n    miatomo[0] = *((lig_x + k) + i);\n    miatomo[1] = *((lig_y + k) + i);\n    miatomo[2] = *((lig_z + k) + i);\n    solv_asp_1 = a_params[ind1].asp;\n    solv_vol_1 = a_params[ind1].vol;\n    for (int j = 0; j < atoms_r; j++)\n    {\n      e_desolv = 0;\n      ind2 = rectype[j];\n      solv_asp_2 = a_params[ind2].asp;\n      solv_vol_2 = a_params[ind2].vol;\n      difx = rec_x[j] - miatomo[0];\n      dify = rec_y[j] - miatomo[1];\n      difz = rec_z[j] - miatomo[2];\n      mod2x = difx * difx;\n      mod2y = dify * dify;\n      mod2z = difz * difz;\n      difx = (mod2x + mod2y) + mod2z;\n      dist = sqrtf(difx);\n      e_desolv = ((((solv_asp_1 * solv_vol_2) + ((QASP * fabs(ql[i])) * solv_vol_2)) + (solv_asp_2 * solv_vol_1)) + ((QASP * fabs(qr[j])) * solv_vol_1)) * exp((-difx) / (2 * G_D_2));\n      temp_desolv += e_desolv;\n    }\n\n  }\n\n  energy[k / nlig] = temp_desolv;\n  temp_desolv = 0;\n}\n\n", "pragma": "  #pragma omp parallel for private(i, j, e_desolv, ind1, miatomo, solv_asp_1, solv_vol_1, ind2, solv_asp_2, solv_vol_2, difx, dify, difz, mod2x, mod2y, mod2z, dist) reduction(+:temp_desolv)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cmperez7/practica-pp-2020-2021/practica/practica-pp-2020-2021/solver_omp/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/6"}
{"code": "for (i = 0; i < n_estimators; i++)\n{\n  rows_count = 0;\n  file = fopen(fn[i], \"r\");\n  for (c = getc(file); c != EOF; c = getc(file))\n  {\n    if (c == '\\n')\n    {\n      rows_count++;\n    }\n\n  }\n\n  maxNodesTree[i] = rows_count - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/8"}
{"code": "for (i = 1; i < (N + 1); i++)\n{\n  for (j = 1; j < (M + 1); j++)\n  {\n    data[(i * (M + 1)) + j] -= mean[j];\n    data[(i * (M + 1)) + j] /= sqrt(3214212.01f) * stddev[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/4"}
{"code": "for (int x = 0; x < gridSize; x++)\n{\n  float val = binSize * x;\n  if (x < (gridSize - 1))\n    fprintf(f, \"%f,\", val);\n  else\n    fprintf(f, \"%f\\n\", val);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jarreddebeer/cuda-median-filter/cuda-files/hpc.omp/0"}
{"code": "for (int ii = begin; ii < end; ++ii)\n{\n  loop_body(ii);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/xt-raja/test/0"}
{"code": "for (int j = 0; j <= (wf.n2 + 1); j++)\n{\n  for (int i = 0; i <= (wf.n1 + 1); i++)\n  {\n    result.push_back(wf.wave[wf.in2(j, i)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/22"}
{"code": "for (i = 0; i < c->nnz; ++i)\n  c->A[i] = r->A[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/7"}
{"code": "for (j = 1; j <= i__1; ++j)\n{\n  if ((*beta) == 0.f)\n  {\n    i__2 = j;\n    for (i__ = 1; i__ <= i__2; ++i__)\n    {\n      c__[i__ + (j * c_dim1)] = 0.f;\n    }\n\n  }\n  else\n    if ((*beta) != 1.f)\n  {\n    i__2 = j;\n    for (i__ = 1; i__ <= i__2; ++i__)\n    {\n      c__[i__ + (j * c_dim1)] = (*beta) * c__[i__ + (j * c_dim1)];\n    }\n\n  }\n\n\n  i__2 = *k;\n  for (l = 1; l <= i__2; ++l)\n  {\n    if (a[j + (l * a_dim1)] != 0.f)\n    {\n      temp = (*alpha) * a[j + (l * a_dim1)];\n      i__3 = j;\n      for (i__ = 1; i__ <= i__3; ++i__)\n      {\n        c__[i__ + (j * c_dim1)] += temp * a[i__ + (l * a_dim1)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/15"}
{"code": "for (int i = 0; i < n; i++)\n{\n  A[i] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/24"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n  for (int j = 0; j < NUM_THREADS; j++)\n  _output[i] += localBins[j][i];\n\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/7"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,comz1 ,comz4 ,comz6 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/56"}
{"code": "for (a = 0; a < dimention; a++)\n{\n  for (b = 0; b < dimention; b++)\n  {\n    printf(\"%.2x ,\", Input1[a][b][0]);\n    printf(\"%.2x ,\", Input1[a][b][1]);\n    printf(\"%.2x \\t\", Input1[a][b][2]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ojani-Eguia/ImageGeneratorTest/OpenMP/ParShader/3"}
{"code": "for (int i = 0; i < K; i++)\n{\n  (((cout << \"Cluster \") << i) << \" contains: \") << endl;\n  int count = 0;\n  for (int j = 0; j < numPoints; j++)\n  {\n    if (i == globalMembership[j])\n    {\n      ((cout << \"Point \") << dataset[j].id) << endl;\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/19"}
{"code": "for (int j = 0; j < adj[v].size(); j++)\n{\n  int ver = adj[v][j];\n  {\n    if (vis[ver] == 0)\n    {\n      vis[ver] = v;\n      q.push_back(ver);\n      flag = 1;\n    }\n\n  }\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/par1/2"}
{"code": "for (j = 0; j < numThreads; j++)\n{\n  pthread_create(&threads[j], 0, thread_func_update, (void *) (&thread_params[j]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/pthread/single_node_lcg/3"}
{"code": "for (i = 0; i < (N * N); i++)\n{\n  (cout << B[i]) << \" \";\n  if (((i + 1) % N) == 0)\n  {\n    cout << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NekIP/OpenMP/openmp/ConsoleApplication2/ConsoleApplication2/3"}
{"code": "for (int i = MIN; i < MAX; i++)\n{\n  int sum = false;\n  for (int j = 0; j < maxThreadsCount; j++)\n  {\n    sum |= isNumberPrime[j][i];\n  }\n\n  if (!sum)\n  {\n    primeNumbers[i] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/macluczak/Primes-OpenMP/sito-domen/4"}
{"code": "for (int aux = 0; aux < 10; aux++)\n  result[aux] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/infernanda/ProgramacaoParalelaBMHS/dna_openmp/4"}
{"code": "for (int i = 0; i < N; ++i)\n  B[i] = A[i];\n\n", "pragma": "        #pragma omp target teams distribute parallel for if(target:execution_space_gpu) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/vasp1/vasp1/4"}
{"code": "for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n{\n  for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n  {\n    for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/0"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  r[i] = SRand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/8"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    forcing[i][j][k][m] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/single_messages/1"}
{"code": "for (unsigned i = 0; i < m_hashNum; i++)\n{\n  tempHashValues[i] = rol(varSeed, i) ^ hVal;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcgsc/abyss/vendor/btl_bloomfilter/pythonInterface/BloomFilter_pythonwrapper/1"}
{"code": "for (int it = 0; it < n_trials; it++)\n{\n  int id = omp_get_thread_num();\n  population[id]->propagateUntilOut(population[id]->centralPerson(), prob_spread[ip], rand);\n  percent_infected[ip] += population[id]->getPercentInfected();\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) reduction(+ : percent_infected[ip])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elc139/t4-pangolim/omp_virus/omp_virus/1"}
{"code": "for (i = 0; i < Size; i++)\n{\n  printf(\"%7.4f \", pVec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Matrix Multiplication/Parallel/main/2"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x;\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/2-integral/IntegralParallel_v4/IntegralParallel_v4/Origem/0"}
{"code": "for (unsigned int i = 0; i < ctr_size; ++i)\n{\n  result[i] += (ctr_converted >> (((ctr_size - 1) - i) * 8)) & ((int64_t) 0xFF);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/franneck94/CUDA-AES/AES OpenMP/Mode/1"}
{"code": "for (idx = 0; idx < count; idx += SIMD_COEF_32 * SIMD_PARA_SHA1)\n{\n  SHA_CTX ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[40 + 20];\n  unsigned char *cp = &tmp[len];\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, saved_plain[idx], len);\n  SHA1_Update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 20;\n  SHA1_Final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, tmp, len);\n    SHA1_Final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/16"}
{"code": "for (x.x() = aabb.min().x() + (dx / 2.); x.x() < aabb.max().x(); x.x() += dx)\n{\n  for (x.y() = aabb.min().y() + (dx / 2.); x.y() < aabb.max().y(); x.y() += dx)\n  {\n    for (x.z() = aabb.min().z() + (dx / 2.); x.z() < aabb.max().z(); x.z() += dx)\n    {\n      for (size_t i = 0; i < centers.size(); i++)\n      {\n        if ((x - centers[i]).squaredNorm() < pow(radii[i], 2))\n        {\n          volume += dv;\n          Sg += dv * x;\n          Ig += (dv * ((x.dot(x) * Identity()) - (x * x.transpose()))) + Matrix3r(Constant((dv * pow(dx, 2)) / 6.).asDiagonal());\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/Clump/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  int id = omp_get_thread_num();\n  for (j = 0; j < i; j++)\n  {\n    temp = a[i][j];\n    a[i][j] = a[j][i];\n    a[j][i] = temp;\n  }\n\n  printf(\"Thread %d\\n\", id);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/flush/0"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    identify_differences(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[5 * n], &((double *) arg2.data)[5 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[23].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/identify_differences_kernel/0"}
{"code": "for (i = 0; i < (size - 1); i++)\n{\n  temp = malloc(sizeof(struct nodo));\n  p->next = temp;\n  p = temp;\n  p->inputdata = (firstnum + i) + 1;\n  p->outdata = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/listaenlazada/1"}
{"code": "for (i = ID; i < 20; i += nthreads)\n{\n  v[i] = i;\n  printf(\"v[%d] = %d, ID = %d\\n\", i, v[i], ID);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eliBiagioli/OpenMP_esercizi/prova_C/prova3/0"}
{"code": "for (uint_fast32_t i = 0; i < iter; i++)\n{\n  to_solve->empty_sq[i] = (square *) malloc(iter * (sizeof(square)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/omp/sudoku-omp_BPsubqueues/0"}
{"code": "for (int i = 0; i < (POP_SIZE - 1); i++)\n{\n  if (fitness(p.pop[i]) > fitness(p.pop[i + 1]))\n  {\n    temp = p.pop[i];\n    p.pop[i] = p.pop[i + 1];\n    p.pop[i + 1] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/12"}
{"code": "for (int i = 0; i < e_count; i++)\n{\n  float dx = edgeList[i].node1.position.x - edgeList[i].node2.position.x;\n  float dy = edgeList[i].node1.position.y - edgeList[i].node2.position.y;\n  float dSquare = (dx * dx) + (dy * dy);\n  if (dSquare > 0.01)\n  {\n    float d = sqrt(dSquare);\n    float fa = dSquare / k;\n    edgeList[i].node1.displacement.x -= (dx / d) * fa;\n    edgeList[i].node1.displacement.y -= (dy / d) * fa;\n    edgeList[i].node2.displacement.x += (dx / d) * fa;\n    edgeList[i].node2.displacement.y += (dy / d) * fa;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(e_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pravinpoudel/force-directed-openmp/force-directed-graph-openmp/force-directed-graph-openmp/0"}
{"code": "for (int i = 0; i < tmp->numNodes; i++)\n{\n  fprintf(fp, \"%d \", tmp->globalVertices[i] + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/13"}
{"code": "for (int i_counter = 4; i_counter < pnHalfed; i_counter++)\n{\n  if ((pn % i_counter) == 0)\n  {\n    primIndicator = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (compare_floats(a[i], b[i]) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/benchmark_double/3"}
{"code": "for (i = 0; i < m1; i++)\n{\n  temp1 = i * n1;\n  for (j = 0; j < n2; j++)\n  {\n    sum = 0.0;\n    temp2 = j * m2;\n    for (k = 0; k < n1; k++)\n    {\n      sum += M_1[temp1 + k] * M_2_T[temp2 + k];\n    }\n\n    result[(i * n2) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, k, sum, temp1, temp2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/1"}
{"code": "for (int n = 10; n <= 100; n += 2)\n{\n  a = (int *) calloc(n, sizeof(int));\n  D = (int **) calloc(n, sizeof(int *));\n  for (int i = 0; i < n; i++)\n  {\n    D[i] = (int *) calloc(n, sizeof(int));\n  }\n\n  if (rank == 0)\n  {\n    getMatrix(D, n);\n    results = (int *) calloc(np, sizeof(int));\n  }\n\n  genSolution(a, n);\n  aux = makeCopy(a, n);\n  for (int i = 0; i < n; i++)\n  {\n    MPI_Bcast(D[i], n, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  }\n\n  cost = getCost(D, a, n);\n  newCost = room_assign(D, a, aux, cost, n, rank, nthreads);\n  MPI_Gather(&newCost, 1, (MPI_Datatype) 0x4c000405, results, 1, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  if (rank == 0)\n  {\n    fprintf(fp, \"%d %d %d\\n\", n, cost, getMin(results, np));\n  }\n\n  Free(a, aux, D, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Mini Project - ROOM ASSIGNMENT/mpi_room_assignment/1"}
{"code": "for (c2 = (nk > nl) ? (nk) : (nl); c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/10"}
{"code": "for (int octant = 0; octant < NOCTANT; ++octant)\n  for (int im = 0; im < dims.nm; ++im)\n  for (int ia = 0; ia < (dims.na - 2); ++ia)\n{\n  const int randvalue = 37 + ((im + (dims.nm * ia)) % 19);\n  m_from_a[M_FROM_A_ADDR(dims.na, im, ia, octant)] += -randvalue;\n  m_from_a[M_FROM_A_ADDR(dims.na, im, ia + 1, octant)] += 2 * randvalue;\n  m_from_a[M_FROM_A_ADDR(dims.na, im, ia + 2, octant)] += -randvalue;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/minisweep-omp/main/3"}
{"code": "for (int i = 0; i < N; i += incX)\n{\n  *Y = add_complexe_float(*Y, mult_complexe_float(*alpha, *X));\n  j += incY;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elegaanz/MN-TP2/src/axpy/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (arr[i] > max_val_seq)\n  {\n    max_val_seq = arr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/max_vector_element/1"}
{"code": "for (i = 0; i < n; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/compparalela/openmp/omp8/if/0"}
{"code": "for (dest = 1; dest < nprocs; dest++)\n{\n  next_year = dest - 1;\n  MPI_Send(&years_bag[next_year], 1, (MPI_Datatype) 0x4c000405, dest, 1, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/1"}
{"code": "for (i = 0; i < P; i++)\n{\n  sum_sq += v_col[i] * v_col[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/2"}
{"code": "for (k = 0; k < dims[0][2]; k++)\n{\n  x0 = start;\n  vranlc((2 * 64) * dims[0][1], &x0, 1220703125.0, tmp);\n  t = 1;\n  for (j = 0; j < dims[0][1]; j++)\n    for (i = 0; i < 64; i++)\n  {\n    u0[k][j][i].real = tmp[t++];\n    u0[k][j][i].imag = tmp[t++];\n  }\n\n\n  if (k != dims[0][2])\n    dummy = randlc(&start, an);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/37"}
{"code": "for (int i = 0; i < numrefs; ++i)\n{\n  calc_hashes(ref_seqs[i], ref_lens[i], kmer, ref_hashes[i], ref_hash_lens[i], ref_hash_counter);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/6"}
{"code": "for (i = 0; i < (len - 1); i++)\n  task(&a[0], i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB114-if-orig-yes/0"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at2 = (-ci2) * crealf(ffe[j]);\n  at1 = at2 * cimagf(ffe[j]);\n  at2 = at2 * at2;\n  exy[3 * j] = at1 * dcu[3 * j];\n  exy[1 + (3 * j)] = at1 * dcu[1 + (3 * j)];\n  exy[2 + (3 * j)] = at1 * dcu[2 + (3 * j)];\n  exy[(3 * j) + k1] = zero;\n  exy[(1 + (3 * j)) + k1] = zero;\n  exy[(2 + (3 * j)) + k1] = zero;\n  wp += at2 * (((dcu[3 * j] * conjf(dcu[3 * j])) + (dcu[1 + (3 * j)] * conjf(dcu[1 + (3 * j)]))) + (dcu[2 + (3 * j)] * conjf(dcu[2 + (3 * j)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/21"}
{"code": "for (int i = ls_image; i < dim_image; i++)\n{\n  for (int j = ls_image; j < dim_image; j++)\n  {\n    int ii;\n    int jj;\n    int acumulador = 0;\n    int num = 0;\n    for (int m = 0; m < 5; m++)\n    {\n      int *krow = kernel[m];\n      ii = i + (m - 2);\n      int *irow = image[ii];\n      for (int n = 0; n < 5; n++)\n      {\n        jj = j + (n - 2);\n        if ((ii < dim_image) && (jj < dim_image))\n        {\n          acumulador += krow[n] * irow[jj];\n          num++;\n        }\n\n      }\n\n    }\n\n    result[i][j] = acumulador / num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/ConvolutionOpenMP/convolucion/9"}
{"code": "for (int i = 0; i < m; i++)\n{\n  data[(i * n) + 3] -= media[3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/8"}
{"code": "for (i = 0; i < 800; i++)\n{\n  a[i] = (double *) malloc((sizeof(double)) * 800);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/1"}
{"code": "for (i = 0; i < (the_index * the_index); i++)\n{\n  int row = i / the_index;\n  int column = i % the_index;\n  int k;\n  for (k = 0; k < the_index; k++)\n  {\n    simple_mult((double (*)[1024]) (&C[row * b][column * b]), (double (*)[1024]) (&A[row * b][k * b]), (double (*)[1024]) (&B[k * b][column * b]), b);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/msagor/parallel_matrix_block_multiplication/matrix_block_multiplication_in_parallel_using_openMP/mult/0"}
{"code": "for (i = 0; 16 > i; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  add = rhs[m][i][j][k];\n  rms[m] = rms[m] + (add * add);\n}\n\n", "pragma": "omp parallel for firstprivate(m ,j ,k ,add ,rms ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/10"}
{"code": "for (int i = 0; i < row_size; ++i)\n{\n  for (int j = 0; j < col_size; ++j)\n  {\n    copyTo[i][j] = copyFrom[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment3/game-of-life/openmp/GameOfLife/6"}
{"code": "for (i = rank; i < 1000000000; i += size)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x, i), reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PashalisTsirts/Pi-Calculation-MPI-OpenMP/Pi/pi_mpi-openmp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  numbers.push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stride-Apollo/proto-TBB/proto2/0"}
{"code": "for (int i = 0; i < data.conf.input_length; ++i)\n{\n  sum += p_array[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(arq, \"%lu\", &vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunobehnken/OpenMP-Studies/rank_sort/rank_sort_par32/1"}
{"code": "for (int i = 0; i < nvertices; i++)\n{\n  wxcoords[i] = vertices[i]->getX();\n  wycoords[i] = vertices[i]->getY();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Guiming/ParallelRipleysKfunction/spp_mpi/SpatialPointPattern/9"}
{"code": "for (int i = 0; i < NNZ; i++)\n{\n  (cout << val[i]) << \"\\t\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/matxvec_sparse/matxvec_sparse/3"}
{"code": "for (i = 0; i < bheight; ++i)\n  memmove(&data[(i * bwidth) * channels], &data[(((i + 1) * (bwidth + 2)) + 1) * channels], (bwidth * channels) * (sizeof(unsigned char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/8"}
{"code": "for (int z = 1; z < ((NZr + (1 * 2)) - 1); z++)\n{\n  for (int y = 1; y < ((NYr + (1 * 2)) - 1); y++)\n  {\n    for (int x = 1; x < (NX - 1); x++)\n    {\n      k1[(x + (y * NX)) + ((z * NX) * (NYr + (1 * 2)))] = ((((((coeffs[0][1] * u_chunk[((x - 1) + (y * NX)) + ((z * NX) * (NYr + (1 * 2)))]) + (coeffs[0][2] * u_chunk[(x + ((y - 1) * NX)) + ((z * NX) * (NYr + (1 * 2)))])) + (coeffs[0][3] * u_chunk[(x + (y * NX)) + (((z - 1) * NX) * (NYr + (1 * 2)))])) + (coeffs[0][1] * u_chunk[((x + 1) + (y * NX)) + ((z * NX) * (NYr + (1 * 2)))])) + (coeffs[0][2] * u_chunk[(x + ((y + 1) * NX)) + ((z * NX) * (NYr + (1 * 2)))])) + (coeffs[0][3] * u_chunk[(x + (y * NX)) + (((z + 1) * NX) * (NYr + (1 * 2)))])) + (coeffs[0][0] * u_chunk[(x + (y * NX)) + ((z * NX) * (NYr + (1 * 2)))]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for if (ENABLE_PARALLEL)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/suicide-squad/heat-equation/modules/Kirill/app/runge_naive/0"}
{"code": "for (x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    tmp[x + (y * L)] = res[x + (y * L)] + (p.scale[lev] * (((phi[((x + 1) % L) + (y * L)] + phi[(((x - 1) + L) % L) + (y * L)]) + phi[x + (((y + 1) % L) * L)]) + phi[x + ((((y - 1) + L) % L) * L)]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/0"}
{"code": "for (i = 0; i < (batch * N); i++)\n{\n  output[i] += input[i];\n}\n\n", "pragma": "#pragma omp parallel for shared(output,input)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-cpu/7"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    printf(\"%f \", ELEM(A, an, i, j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/non-automated/strassen/strassen/0"}
{"code": "for (i = 0; i < (3 * (colsNumber / sqrt_comm_sz)); i = i + 3)\n{\n  for (int c = 0; c <= 2; c++)\n  {\n    topRow[i + c] = myArray[0][i + c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/6"}
{"code": "for (int j = 0; j < pattern.length(); j++)\n{\n  temp += text_string[i + j];\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q3_b/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    cont++;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/paralelo5/0"}
{"code": "for (j = 1; j <= ndelta; j++)\n{\n  for (k = 0; k <= nly; k++)\n  {\n    new_dw = ((ETA * delta[j]) * ly[k]) + (MOMENTUM * oldw[k][j]);\n    w[k][j] += new_dw;\n    oldw[k][j] = new_dw;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/10"}
{"code": "for (i = 4; i < width; i++)\n{\n  for (j = 4; j < depth; j++)\n  {\n    for (k = 1; k < (height + 1); k++)\n    {\n      data[offset(i, j, k)] = (((((((((((4 * data[offset(i, j, k)]) + data[offset(i - 1, j, k)]) + data[offset(i, j - 1, k)]) + data[offset(i - 2, j, k)]) + data[offset(i, j - 2, k)]) + data[offset(i + 1, j, k)]) + data[offset(i, j + 1, k)]) + data[offset(i + 2, j, k)]) + data[offset(i, j + 2, k)]) + data[offset(i, j, k - 1)]) + data[offset(i, j, k + 1)]) / 14;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petrosgk/Atmospheric-Model-Simulation/AtmModelMPI/1"}
{"code": "for (int oy = 1; oy < (height - 1); oy += 4)\n{\n  for (int x = 1; x < (width - 1); x++)\n  {\n    for (int iy = 0; iy < 4; iy++)\n    {\n      int y = oy + iy;\n      gridA[(y * width) + x] = 0.25 * (((gridB[((y * width) + x) + 1] + gridB[((y * width) + x) - 1]) + gridB[((y + 1) * width) + x]) + gridB[((y - 1) * width) + x]);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/te42kyfo/omp_jacobi/main6/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp6n0lq2bd.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (int i = 0; i < r; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    a[i][j] = rand() % 100;\n    b[i][j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ajit-Kumar/Concurrent_Programming/matrix/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  particles[i].ax = (particles[i].ay = 0);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vjeganat/MD_simulations/Openmp_neighbor_lists/openmp/0"}
{"code": "for (i = 0; i < NUM_ITEMS; i++)\n{\n  int j;\n  for (j = 0; j < ARRAY_SIZE; j++)\n  {\n    result[j] += a[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(a) reduction(+:[ARRAY_SIZE]result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_array_reduction_01/0"}
{"code": "for (; p1 != end; ++p1)\n  sum += ((*p1) > 0) ? (*p1) : (-1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/11"}
{"code": "for (i = 0; i < LOOPCOUNT; ++i)\n{\n  bit_or = bit_or | logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1) private(i) reduction(| : bit_or)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_parallel_reduction/5"}
{"code": "for (int k = 1; k < 20; k++)\n  A[i][j][k] = A[i - 1][j][k];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/3.norace5/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_set_schedule_0())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/worksharing/for/bug_set_schedule_0/0"}
{"code": "for (i = 0; i < SIMD_WIDTH; i++)\n{\n  FutureValueX[i] = strike[i] * exp((-rate[i]) * time[i]);\n  if (otype[i] == 0)\n  {\n    OptionPrice[i] = (sptprice[i] * NofXd1[i]) - (FutureValueX[i] * NofXd2[i]);\n  }\n  else\n  {\n    NegNofXd1[i] = 1.0 - NofXd1[i];\n    NegNofXd2[i] = 1.0 - NofXd2[i];\n    OptionPrice[i] = (FutureValueX[i] * NegNofXd2[i]) - (sptprice[i] * NegNofXd1[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/black_scholes/blackscholes.simd/6"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  u[i] = ((((-2.0) * nu) * ((((-(2.0 * x[i])) * exp((-(x[i] * x[i])) / (4.0 * nu))) / (4.0 * nu)) - ((((2.0 * x[i]) - (4.0 * pi)) * exp(((-(x[i] - (2.0 * pi))) * (x[i] - (2.0 * pi))) / (4.0 * nu))) / (4.0 * nu)))) / (exp(((-(x[i] - (2.0 * pi))) * (x[i] - (2.0 * pi))) / (4.0 * nu)) + exp((-(x[i] * x[i])) / (4.0 * nu)))) + 4.0;\n  u_new[i] = u[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Burgers Equation/1D_Burgers_Equation/main/1"}
{"code": "for (int i = 1; i < 50; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    if (gene[i] == gene[j])\n    {\n      for (int k = 0; k < 50; k++)\n      {\n        if (inGene[k] == 0)\n        {\n          gene[i] = k;\n          inGene[k] = 1;\n          k = 50;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/5. N-queens problem/gen06/12"}
{"code": "for (i = 0; i < ((int) n_b); i++)\n{\n  result[i] = (*a) > b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/31"}
{"code": "for (int j = 0; j < (p - k); j++)\n{\n  errors += closest_indices[i][j] != i;\n}\n\n", "pragma": "omp parallel for reduction(+:errors)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gulsumgudukbay/Parallel-P3-FaceRecognition/FaceDetection/src/lbp_omp/2"}
{"code": "for (int n = 0; n < 10; ++n)\n  printf(\" %d\", n);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/camiloalsuarez/OpenMp/parallel-loop-1/0"}
{"code": "for (int ij = 0; ij < azbuka; ij++)\n  resAll[ij] += resThr[ij];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aleri-a/Parallel-Systems--Frequency-calculation-of-characters-/parallel_project/parallel_project/Source/2"}
{"code": "for (int i = 0; i < NUM_RUNS; ++i)\n{\n  double startTime = currentSeconds();\n  mandelbrot_row_parallel(numThreads, x0, y0, x1, y1, width, height, maxIterations, output_parallel_row);\n  double endTime = currentSeconds();\n  minThread = min(minThread, endTime - startTime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artalukd/toRustOrNot/C++/mandelbrot/main/7"}
{"code": "for (int j = 0; j < 5; j++)\n{\n  printf(\"%d \\t\", vect1[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP1EX3/3"}
{"code": "for (int i = 0; i < cast_mat_A->nrow_; ++i)\n{\n  row_offset[i + 1] += row_offset[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/42"}
{"code": "for (i = 0; i < row; i++)\n  for (j = 0; j < col; j++)\n{\n  matrix[i][j] = rand() % 30;\n  x = ((float) rand()) / ((float) 32767);\n  if (x < prob)\n    matrix[i][j] = 0;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/sparceMatrix/sparceMatrix_parallel/2"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = 0; j < col; j++)\n  {\n    trans[(j * col) + i] = mat[(i * col) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, chunk) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-8-caches/matrices/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcksber/CMU_15-418_hw3/examples/loop/0"}
{"code": "for (int i = 0; i < IONtypes.size(); i++)\n  for (int j = 0; j < tspecies(membersize, i); j++)\n  IONlist.push_back(IONtypes[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FRSingleOMP/0"}
{"code": "for (int i = 0; i < noOfElements; i++)\n{\n  printf(\"%d \", arrWrite[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AniMahajan20/Parallel-Computing/HyperQuickSort using OpenMP/hyperquicksort_openmp/1"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  sdL[i] = (dL[i] = L / ((double) N));\n  sZ[i] = (Z[i] = (i * L) / ((double) N));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/51"}
{"code": "for (long i = 0; i < size; i++)\n{\n  first_matrix[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Multiplication_Serial_Parallel/1"}
{"code": "for (unsigned int i = 0; i < ((L / NODESX) + 2); i++)\n  gre[i] = got[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/117"}
{"code": "for (int i = 0; i < 2000000; i++)\n{\n  if (isprime(i) == 1)\n  {\n    tmpsum += i;\n  }\n\n  if ((i % 50000) == 0)\n  {\n    printf(\"we are at this point %d id :: %d\\n\", i, omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex10projecteuler/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (percentDiff(B[i][j], B_output[i][j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/polybench-acc/OpenMP/stencils/jacobi-2d-imper/jacobi-2d-imper/2"}
{"code": "for (i = 0; i < normalizeNum; i++)\n{\n  for (int j = 0; j < buckets[i].size(); j++)\n  {\n    arr_ordered[index++] = buckets[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_2_Sorting/cpu_parallel_sort/6"}
{"code": "for (int i = 0; i < d; i++)\n{\n  v[i] = 1;\n  sum += (abs(k[x[0]][x[1]][i]) + abs(k[mod(x[0] - v[0], Nt)][mod(x[1] - v[1], Ns)][i])) + (2 * (a[x[0]][x[1]][i] + a[mod(x[0] - v[0], Nt)][mod(x[1] - v[1], Ns)][i]));\n  v[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/4"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    w[i][j] = ((float) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_backprop/backprop/3"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  int id = omp_get_thread_num();\n  for (int j = 0; j < i; j++)\n  {\n    omp_set_lock(&writelock);\n    temp = a[i][j];\n    a[i][j] = a[j][i];\n    a[j][i] = temp;\n    omp_unset_lock(&writelock);\n  }\n\n  printf(\"Thread %d\\n\", id);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/mp3/0"}
{"code": "for (int i = 0; i < ((nr_class * (nr_class - 1)) / 2); i++)\n  fprintf(fp, \" %g\", model->probA[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/88"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  histogram[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fralomba/Parallel-Histogram-Equalization/code/OMP_histogram_equalization/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      b[i] = rand() % (n + 1);\n      A[i][j] = 1;\n    }\n    else\n    {\n      A[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/10"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i;\n  b[i] = 0;\n  c[i] = i + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/loop_fission/0"}
{"code": "for (uint32_t i = 0; i < vLPNumIter.size(); ++i)\n{\n  mplPrint(kNONE, \"%u %u %u %u %u %u %u\\n\", vLP1NonInteger.at(i), vLP1HalfInteger.at(i), vLP2NonInteger.at(i), vLP2HalfInteger.at(i), vLPEndNonInteger.at(i), vLPEndHalfInteger.at(i), vLPNumIter.at(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/5"}
{"code": "for (int i = 0; i < 16; i++)\n  printf(\"b[%d] = %d\\n\", i, b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture10/ExplicitBarrier_example2/ExplicitBarrier_example2/2"}
{"code": "for (uint64_t i = 0; i < size; i++)\n{\n  array[i] = (rand() % max_int) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulwankhede/OpenMP/parallel/0"}
{"code": "for (int32_t j = 0; j < 10; ++j)\n  for (int32_t i = 0; i < 20; i++)\n  a.x += a.y;\n\n\n", "pragma": "\t\t#pragma omp for reduction(my_add : a) collapse(2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_03/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task9/1"}
{"code": "for (int x = x_M / balance_factor; x < x_M; x++)\n{\n  for (int y = y_m; y < y_M; y++)\n  {\n    if (t1)\n      ut1[(x * size_u[0]) + y] = ut0[(x * size_u[0]) + y] + 1;\n    else\n      if (t0)\n      ut0[(x * size_u[0]) + y] = ut1[(x * size_u[0]) + y] + 1;\n\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/time_marching_cpu_gpu/1"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  for (size_t k = 0; k < size; k++)\n  {\n    for (size_t j = 0; j < size; j++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/dotprod/src/main/3"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  r[i] = i * M_PI;\n  for (j = 0; j < 1024; j++)\n  {\n    A[(i * 1024) + j] = (((DATA_TYPE) i) * j) / 1024;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/28"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  free(globalBoard[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qazwse/RedBlueOpenMP/orbs/6"}
{"code": "for (k = 0; k < V; k++)\n{\n  for (i = 0; i < V; i++)\n  {\n    for (j = 0; j < V; j++)\n    {\n      if ((dist[i][k] + dist[k][j]) < dist[i][j])\n        dist[i][j] = dist[i][k] + dist[k][j];\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    E[(i * 2048) + j] = 0;\n    for (k = 0; k < 2048; ++k)\n    {\n      E[(i * 2048) + j] += A[(i * 2048) + k] * B[(k * 2048) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3MM/3mm/8"}
{"code": "for (k = 0; k < size; k++)\n  for (l = 0; l < size; l++)\n{\n  matrix_A[k][l] = 2;\n  matrix_B[k][l] = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/parprog_matrix/3"}
{"code": "for (; j < N; j = (j + incY) + 4)\n{\n  Y[j] = X[j];\n  Y[j + 1] = X[j + 1];\n  Y[j + 2] = X[j + 2];\n  Y[j + 3] = X[j + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/3"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  fileout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DFTheory/Water-system-openMP/water_system/0"}
{"code": "for (int i = 0; i < len_arr; i++)\n{\n  x_sum = x_sum + x[i];\n  y_sum = y_sum + y[i];\n}\n\n", "pragma": "omp parallel for reduction(+:x_sum, y_sum) firstprivate(x,y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/13/Linear_Regression/main/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/137"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMParrayAvg/0"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  result[i] = 0.0;\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    result[i] += this->operator()(i, j) * rhs[j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/15"}
{"code": "for (L = 0; L < N; L++)\n{\n  termo_linha[L] = A[(L * N) + 0] * A[(L * N) + 1];\n  for (K = 1; K < P; K++)\n    termo_linha[L] += A[(L * N) + (2 * K)] * A[((L * N) + (2 * K)) + 1];\n\n}\n\n", "pragma": "omp parallel for default(none) private(L,K,P) shared(N,A,termo_linha)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cleversonledur/ParallelMPIcode/winogradPar/1"}
{"code": "for (i = 0; i < size; i++)\n  free(subMat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/22"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  sumalocal += a[i];\n  printf(\"thread %d suma de a[%d]=%d sumalocal=%d \\n\", tid, i, a[i], sumalocal);\n}\n\n", "pragma": "omp for private(i) schedule(static) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/if_clause_modificado/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  processor *p = processors + i;\n  p->good = (rand() % 100) > 10;\n  p->b = rand() % 2;\n  p->vote = p->b;\n  p->d = 0;\n  p->decided = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/byzantine/3"}
{"code": "for (int i = 0; i < len; i++)\n{\n  output[idx[i]] = input[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/3"}
{"code": "for (int h = 0; h < tamlinha; h++)\n{\n  matriz[linha][h] = matriz[i][h];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Landecrispim/Metodo-de-Gauss-cpp-OpenMP/guss/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  arrayX[i] = x_j[i];\n  arrayY[i] = y_j[i];\n  weights[i] = 1 / ((double) n);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jason11ac/OpenMP-Optimization/func/7"}
{"code": "for (int ax = 0; ax < 3; ax++)\n{\n  for (size_t i = 0; i < (cpuBounds[ax].size() - 1); i++)\n  {\n    if (cpuBounds[ax][i].coord > cpuBounds[ax][i + 1].coord)\n    {\n      ok = false;\n      LOG_ERROR(\"cpuBounds[{}][{}].coord=>cpuBounds[{}][{}].coord: {}>{}\", ax, i, ax, i + 1, cpuBounds[ax][i].coord, cpuBounds[ax][i + 1].coord);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/woodem/woo/src/dem/OpenCLCollider/1"}
{"code": "for (int ii = 0; ii < fsize; ii++)\n{\n  zeroReal3(s->atoms->f[ii]);\n  s->atoms->U[ii] = 0.;\n  pot->dfEmbed[ii] = 0.;\n  pot->rhobar[ii] = 0.;\n}\n\n", "pragma": "omp for schedule(static,fsize/omp_get_num_threads())", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/0"}
{"code": "for (i = 2; i < (grid_x - 1); i += 2)\n  for (j = 2; j < (grid_y - 1); j += 2)\n  grid[i][j] = 0.2 * (((grid[i - 1][j] + grid[i + 1][j]) + grid[i][j - 1]) + grid[i][j + 1]);\n\n\n", "pragma": "            #pragma omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wwwennie/MP-OpenMP_tutorial/OpenMP/OpenMP_tut/checker/cpp_checker_omp/2"}
{"code": "for (int i = 0; i < dataArr.size(); i++)\n{\n  encodedStream << encoder.Encode2(dataArr[i]);\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MeetSable/Huffman-encoding-and-Adaptive-Huffman-encoding-OpenMP/adaptiveHuffman/4"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n{\n  for (j = 1; j < (_PB_N - 1); j++)\n  {\n    for (k = 1; k < (_PB_N - 1); k++)\n    {\n      A[i][j][k] = (((SCALAR_VAL(0.125) * ((B[i + 1][j][k] - (SCALAR_VAL(2.0) * B[i][j][k])) + B[i - 1][j][k])) + (SCALAR_VAL(0.125) * ((B[i][j + 1][k] - (SCALAR_VAL(2.0) * B[i][j][k])) + B[i][j - 1][k]))) + (SCALAR_VAL(0.125) * ((B[i][j][k + 1] - (SCALAR_VAL(2.0) * B[i][j][k])) + B[i][j][k - 1]))) + B[i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/heat-3d/heat-3d/1"}
{"code": "for (int i = 0; i < n; i++)\n  array2[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hpc-sandbox/graph-dev/test-class-instance-offload/test/0"}
{"code": "for (int i = 0; i < A.get_row(); i++)\n{\n  for (int j = A.row_ptr[i]; j < A.row_ptr[i + 1]; j++)\n  {\n    y[i] += A.val[j] * x[A.col_ind[j]];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/matrix/spmv/0"}
{"code": "for (index = 0; index < count; index += inc)\n{\n  SHA_CTX ctx;\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  SHA1_Update(&ctx, (unsigned char *) saved_salt->data.c, saved_salt->len);\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/salted_sha1_fmt_plug/0"}
{"code": "for (int i = 0; i < colNumX; i++)\n{\n  XmatVecTemp = Xmat.col(i);\n  Sigma_iX1.col(i) = getPCG1ofSigmaAndVector_LOCO(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/16"}
{"code": "for (int i = 0; i < (numOfFiles + 2); i++)\n  if (entry = readdir(d))\n{\n  if ((!strcmp(entry->d_name, \".\")) || (!strcmp(entry->d_name, \"..\")))\n    ;\n  else\n    evalute(d, entry, strFinal, dirName);\n\n}\n\n\n", "pragma": "omp for private(entry) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ricardoreais/exam-evaluator/exam-evaluator/0"}
{"code": "for (int j = 0; j < j_size_; ++j)\n{\n  (*this)(i, j) -= obj(i, j);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/4"}
{"code": "for (i = 0; i <= (1022 + 1); i++)\n{\n  for (j = 0; j <= (1022 + 1); j++)\n  {\n    A[i][j] = 20;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielchristo/prog-dist/trabalho_2/4.gauss_seidel/gauss_seidel/1"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (j_imopVar111 = 1; j_imopVar111 < (grid_points[1] - 1); j_imopVar111++)\n  {\n    for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n    {\n      uijk = us[i_imopVar110][j_imopVar111][k_imopVar112];\n      up1 = us[i_imopVar110 + 1][j_imopVar111][k_imopVar112];\n      um1 = us[i_imopVar110 - 1][j_imopVar111][k_imopVar112];\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][0] = (rhs[i_imopVar110][j_imopVar111][k_imopVar112][0] + (dx1tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][0] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][0])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][0]))) - (tx2 * (u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] - u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1]));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][1] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][1] + (dx2tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][1])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][1] * up1) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][1] * um1)) + ((((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] - square[i_imopVar110 + 1][j_imopVar111][k_imopVar112]) - u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]) + square[i_imopVar110 - 1][j_imopVar111][k_imopVar112]) * c2)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][2] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][2] + (dx3tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][2] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][2])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][2]))) + (xxcon2 * ((vs[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * vs[i_imopVar110][j_imopVar111][k_imopVar112])) + vs[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) - (tx2 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][2] * up1) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][2] * um1)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][3] = ((rhs[i_imopVar110][j_imopVar111][k_imopVar112][3] + (dx4tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][3] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][3])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][3]))) + (xxcon2 * ((ws[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * ws[i_imopVar110][j_imopVar111][k_imopVar112])) + ws[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) - (tx2 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][3] * up1) - (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][3] * um1)));\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][4] = ((((rhs[i_imopVar110][j_imopVar111][k_imopVar112][4] + (dx5tx1 * ((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] - (2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][4])) + u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]))) + (xxcon3 * ((qs[i_imopVar110 + 1][j_imopVar111][k_imopVar112] - (2.0 * qs[i_imopVar110][j_imopVar111][k_imopVar112])) + qs[i_imopVar110 - 1][j_imopVar111][k_imopVar112]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4] * rho_i[i_imopVar110 + 1][j_imopVar111][k_imopVar112]) - ((2.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][4]) * rho_i[i_imopVar110][j_imopVar111][k_imopVar112])) + (u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4] * rho_i[i_imopVar110 - 1][j_imopVar111][k_imopVar112])))) - (tx2 * ((((c1 * u[i_imopVar110 + 1][j_imopVar111][k_imopVar112][4]) - (c2 * square[i_imopVar110 + 1][j_imopVar111][k_imopVar112])) * up1) - (((c1 * u[i_imopVar110 - 1][j_imopVar111][k_imopVar112][4]) - (c2 * square[i_imopVar110 - 1][j_imopVar111][k_imopVar112])) * um1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/52"}
{"code": "for (long long i = 0; i < (len - (pid * n)); i++)\n{\n  val = rand() % 2;\n  vec.push_back(val);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(nt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhasamritasarmah/mpi_openmp_programming_basics/mpi_omp_drakes_equation_problem_formulation/1"}
{"code": "for (int k = 0; k < nElements; ++k)\n{\n  if ((k % 2) != 0)\n    continue;\n\n  if (k >= pow(2, d))\n    summs[k] = arr[k] + arr[k - pow(2, d)];\n  else\n    summs[k] = arr[k];\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_2/parallel_2/0"}
{"code": "for (i = 0; i < 10000; i++)\n  x[i] = 0.0001 * (10000 - i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_13/mat_vec_row_omp/moj_program/2"}
{"code": "for (unsigned int j = 0; j < microenvironment.mesh.y_coordinates.size(); j++)\n{\n  int K = microenvironment.mesh.z_coordinates.size() - 1;\n  ;\n  for (unsigned int i = 0; i < microenvironment.mesh.x_coordinates.size(); i++)\n  {\n    microenvironment.add_dirichlet_node(microenvironment.voxel_index(i, j, K), default_microenvironment_options.Dirichlet_zmax_values);\n    microenvironment.set_substrate_dirichlet_activation(microenvironment.voxel_index(i, j, K), default_microenvironment_options.Dirichlet_zmax);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/27"}
{"code": "for (i = 0; i < NUM_THREADS; i++)\n  pi += sum[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhbink/OpenMP-Caculating-Pi/code/201614790222/1"}
{"code": "for (int i = 0; i < q->size; i++)\n{\n  if (max == M->current[i])\n  {\n    counter = counter + 1;\n    found = 1;\n  }\n\n  if ((found == 1) && (max != M->current[i]))\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/11"}
{"code": "for (; cycle < cycles; cycle++)\n{\n  if ((curPe == 0) && (nextPe == 0))\n    break;\n\n  nc += curPe;\n  if (curPe > nwv)\n    nwv = curPe;\n\n  int *pb = curP;\n  int i = curPe;\n  while ((i--) > 0)\n    pending[*(pb++)] = false;\n\n  pb = curP;\n  i = curPe;\n  while ((i--) > 0)\n    updateCellAstar(*(pb++));\n\n  if ((displayInt > 0) && ((cycle % displayInt) == 0))\n    displayFn(this);\n\n  curPe = nextPe;\n  nextPe = 0;\n  pb = curP;\n  curP = nextP;\n  nextP = pb;\n  if (curPe == 0)\n  {\n    curT += priInc;\n    curPe = overPe;\n    overPe = 0;\n    pb = curP;\n    curP = overP;\n    overP = pb;\n  }\n\n  if (potarr[startCell] < POT_HIGH)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/11"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  pi += f(i * h);\n  pi += 1.0;\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:pi) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture14/pi_omp/0"}
{"code": "for (i = 3; i <= (grid_points[0] - 4); i += 1)\n{\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/15"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < I; j++)\n  {\n    setA[i][j] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"[rand() % 62];\n  }\n\n  setA[i][I] = '\\0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tassosblackg/HammingDistance/HD_openmpA/2"}
{"code": "for (i = 0; i < NODE_N; i++)\n  for (j = 0; j < NODE_N; j++)\n  graph[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/9"}
{"code": "for (int k = 0; k < N; k++)\n  for (int i = k + 1; i < N; i++)\n  for (int j = 0; j < N; j++)\n  A[i][j] += A[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    scanf(\"%d\", &g[i][j]);\n    if (g[i][j] == 0)\n      g[i][j] = 0x3f3f3f3f;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/FastDPComputing/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 1; j < m; j++)\n    b[i][j] = (i * m) + j;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB037-truedepseconddimension-orig-yes/0"}
{"code": "for (i = 0; i < 8; i += 1)\n{\n  a = x + D[i][0];\n  b = y + D[i][1];\n  if ((((a >= 0) && (a <= 7)) && (b >= 0)) && (b <= 7))\n    if ((conf.mat[a][b] * mode) == 'r')\n    return 1;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/5"}
{"code": "for (int i = 0; i < myRows; i++)\n{\n  for (int j = 0; j < WORLD_SIZE; j++)\n  {\n    if (myWorld[i][j] == ALIVE)\n      computeNeigh(myWorld, newWorld, upper, below, i, j, myRows, windDirection, windForce);\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parrallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattNot/fireEmulation/main/2"}
{"code": "for (it = 0; it <= 100; it++)\n{\n  MPI_Startall(4, reqs_send[old]);\n  MPI_Startall(4, reqs_rcv[old]);\n  for (i = xoffset + 2; i < (xoffset + myxsize); i++)\n  {\n    for (j = yoffset + 2; j < (yoffset + myysize); j++)\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  MPI_Waitall(4, reqs_rcv[old], (MPI_Status *) 1);\n  start = xoffset + 1;\n  end = (xoffset + myxsize) + 1;\n  for (i = start; i < end; i++)\n  {\n    j = yoffset + 1;\n    if (((((i - 1) != 0) && (i != NXPROB)) && ((j - 1) != 0)) && (j != NYPROB))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n    j = yoffset + myysize;\n    if (((((i - 1) != 0) && (i != NXPROB)) && ((j - 1) != 0)) && (j != NYPROB))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  start = yoffset + 2;\n  end = yoffset + myysize;\n  for (j = start; j < end; j++)\n  {\n    i = xoffset + 1;\n    if (((((i - 1) != 0) && (i != NXPROB)) && ((j - 1) != 0)) && (j != NYPROB))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n    i = xoffset + myxsize;\n    if (((((i - 1) != 0) && (i != NXPROB)) && ((j - 1) != 0)) && (j != NYPROB))\n    {\n      u[1 - old][i][j] = (u[old][i][j] + (parms.cx * ((u[old][i + 1][j] + u[old][i - 1][j]) - (2.0 * u[old][i][j])))) + (parms.cy * ((u[old][i][j + 1] + u[old][i][j - 1]) - (2.0 * u[old][i][j])));\n    }\n\n  }\n\n  MPI_Waitall(4, reqs_send[old], (MPI_Status *) 1);\n  old = 1 - old;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/14"}
{"code": "for (r = 1; r < (ROWS - 1); r++)\n{\n  for (c = 1; c < (COLUMNS - 1); c++)\n  {\n    setVal(cells, r, c, rand() % 2);\n    setVal(tempCells, r, c, getVal(cells, r, c));\n  }\n\n}\n\n", "pragma": "omp parallel for private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IsaacLehman/Game-of-Life/GameOfLife/0"}
{"code": "for (i = 0; i < nz; i++)\n  fprintf(file, \"%d %d %10.3g\\n\", I[i] + 1, J[i] + 1, val[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/dense/8"}
{"code": "for (t2 = lbp; t2 <= ubp; t2++)\n{\n  for (t3 = t2; t3 <= floor(((double) (N - 1)) / ((double) 16)); t3++)\n  {\n    for (t4 = 16 * t2; t4 <= (((((N - 2) < ((16 * t2) + 15)) ? (N - 2) : ((16 * t2) + 15)) < ((16 * t3) + 14)) ? (((N - 2) < ((16 * t2) + 15)) ? (N - 2) : ((16 * t2) + 15)) : ((16 * t3) + 14)); t4++)\n    {\n      lbv = ((16 * t3) > (t4 + 1)) ? (16 * t3) : (t4 + 1);\n      ubv = ((N - 1) < ((16 * t3) + 15)) ? (N - 1) : ((16 * t3) + 15);\n      #pragma ivdep\n      #pragma vector always\n      for (t5 = lbv; t5 <= ubv; t5++)\n      {\n        Pbp[t4][t5] = ((Q[0][t4] * Q[t5][N - 1]) * Qbp[t4][t5]) / Q[0][N - 1];\n        ;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(lbv,ubv,t3,t4,t5,t6,t7)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_pb_traco/0"}
{"code": "for (m = 1; m <= (mmax / 2); m++)\n{\n  for (i = (2 * m) - 1; i <= n; i += istep)\n  {\n    j = i + mmax;\n    tempr = (wr[q][m - 1] * data[j]) - (wi[q][m - 1] * data[j + 1]);\n    tempi = (wr[q][m - 1] * data[j + 1]) + (wi[q][m - 1] * data[j]);\n    data[j] = data[i] - tempr;\n    data[j + 1] = data[i + 1] - tempi;\n    data[i] = data[i] + tempr;\n    data[i + 1] = data[i + 1] + tempi;\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,i,j,tempr,tempi)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/william96ming/Openmp-pthreads-implementation-on-FFT/FFT_DIT_omp/1"}
{"code": "for (iteration = 0; (iteration < maxIterations) && (converged != fullyConverged); iteration++)\n{\n  for (z = 1; z < (OMP_zMax - 1); z++)\n  {\n    for (y = 1; y < (OMP_yMax - 1); y++)\n    {\n      for (x = 1; x < (OMP_xMax - 1); x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        double uInd = u[xyzInd];\n        g[xyzInd] = 1.0 / sqrt((((((epsilon + OMP_SQR(uInd - u[xyzInd + 1])) + OMP_SQR(uInd - u[xyzInd - 1])) + OMP_SQR(uInd - u[xyzInd + OMP_xMax])) + OMP_SQR(uInd - u[xyzInd - OMP_xMax])) + OMP_SQR(uInd - u[xyzInd + xyMax])) + OMP_SQR(uInd - u[xyzInd - xyMax]));\n      }\n\n    }\n\n  }\n\n  memcpy(conv, u, (((sizeof(double)) * OMP_xMax) * OMP_yMax) * OMP_zMax);\n  OMP_GaussianBlur(conv, Ksigma, 3);\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        double r = (conv[xyzInd] * f[xyzInd]) / sigma2;\n        r = (r * (2.38944 + (r * (0.950037 + r)))) / (4.65314 + (r * (2.57541 + (r * (1.48937 + r)))));\n        conv[xyzInd] -= f[xyzInd] * r;\n      }\n\n    }\n\n  }\n\n  OMP_GaussianBlur(conv, Ksigma, 3);\n  converged = 0;\n  for (z = 1; z < (OMP_zMax - 1); z++)\n  {\n    for (y = 1; y < (OMP_yMax - 1); y++)\n    {\n      for (x = 1; x < (OMP_xMax - 1); x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        int xyz_xmin = xyzInd - 1;\n        int xyz_xplu = xyzInd + 1;\n        int xyz_ymin = xyzInd - OMP_xMax;\n        int xyz_yplu = xyzInd + OMP_xMax;\n        int xyz_zmin = xyzInd - xyMax;\n        int xyz_zplu = xyzInd + xyMax;\n        double g_xmin = g[xyz_xmin];\n        double g_xplu = g[xyz_xplu];\n        double g_ymin = g[xyz_ymin];\n        double g_yplu = g[xyz_yplu];\n        double g_zmin = g[xyz_zmin];\n        double g_zplu = g[xyz_zplu];\n        double oldVal = u[xyzInd];\n        double newVal = (oldVal + (dt * (((((((u[xyz_xmin] * g_xmin) + (u[xyz_xplu] * g_xplu)) + (u[xyz_ymin] * g_ymin)) + (u[xyz_yplu] * g_yplu)) + (u[xyz_zmin] * g_zmin)) + (u[xyz_zplu] * g_zplu)) - (gamma * conv[xyzInd])))) / (1.0 + (dt * (((((g_xplu + g_xmin) + g_yplu) + g_ymin) + g_zplu) + g_zmin)));\n        if (fabs(oldVal - newVal) < epsilon)\n        {\n          converged++;\n        }\n\n        u[xyzInd] = newVal;\n      }\n\n    }\n\n  }\n\n  if (converged > lastConverged)\n  {\n    printf(\"%d pixels have converged on iteration %d\\n\", converged, iteration);\n    lastConverged = converged;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/dompDeblur/2"}
{"code": "for (i = 0; i < ncolors; i++)\n  SHIFTCSR(j, nrows, smats[i]->rowptr);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/18"}
{"code": "for (i = 1; i <= 12; i++)\n{\n  A = (((A ^ B) << (B & (32 - 1))) | ((A ^ B) >> (32 - (B & (32 - 1))))) + S[2 * i];\n  B = (((B ^ A) << (A & (32 - 1))) | ((B ^ A) >> (32 - (A & (32 - 1))))) + S[(2 * i) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sara7860/Enhancement-of-RC5-Algorithm/project code/parallel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  ((cout << \"\\nEnter Elements of Row: \") << (i + 1)) << \"\\n\";\n  for (j = 0; j < n; j++)\n    cin >> ary[i][j];\n\n  completed[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/void-mckenzie/OpenMP-Work/Programs/travelling_salesman/0"}
{"code": "for (idx_t n = 1; n < nnz; ++n)\n{\n  int newfib = 0;\n  for (idx_t m = 0; m < (nmodes - 1); ++m)\n  {\n    if (ttinds[m][n] != ttinds[m][n - 1])\n    {\n      newfib = 1;\n      break;\n    }\n\n  }\n\n  if (newfib)\n  {\n    ft->fptr[fib] = n;\n    ft->fids[fib] = ttinds[1][n];\n    if (ft->tiled != SPLATT_NOTILE)\n    {\n      ft->sids[fib] = ttinds[0][n];\n    }\n\n    ++fib;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/ftensor/3"}
{"code": "for (k = 0; k < div; k++)\n{\n  for (i = 0; i < num_volatility; i++)\n    op[k].implied_vol[i] = newton_raphson(op[k].V_market[i][0], low_vol, epsilon, op[k].S, op[k].K[i], op[k].r, op[k].T, op[k].V_market[i][1]);\n\n}\n\n", "pragma": "omp parallel for default(private) shared(low_vol, epsilon, op) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DomenicoNatella/implied_volatility/implied_vol_newton_ver2/0"}
{"code": "for (int i = 0; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    A->data[(i * N) + j] = ((float) rand()) / ((float) 32767);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uscheedella/Image-Interpolation/labs/lab07/code/matrix/2"}
{"code": "for (int j = 1; j < (n - 1); j++)\n{\n  for (int i = 1; i < (m - 1); i++)\n  {\n    Anew[j][i] = 0.25 * (((A[j][i + 1] + A[j][i - 1]) + A[j - 1][i]) + A[j + 1][i]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbertDeFusco/openmp-workshop/src/laplace2d/laplace2d/1"}
{"code": "for (i = ci; i < csize; i++, bi++)\n  C[i] = B[bi];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/valeroclemente/AdvanceComputerArchitecture/OpenMP_linux_codes/mergeOpenMP_linux/5"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  printf(\"PID: %d thread %d time %f\\n\", pid, i, timer_threads[pid][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eferos93/mandelbrotSet/src/mandelbrot_set/2"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = (float) strtod(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->fvsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->ivsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/19"}
{"code": "for (i = 1; i < argc; i++)\n  if (argv[i][0] == '-')\n{\n  switch (argv[i][1])\n  {\n    case 'N':\n      sscanf(argv[i + 1], \"%d\", &N);\n      break;\n\n    case 'M':\n      sscanf(argv[i + 1], \"%d\", &M);\n      break;\n\n    case 'a':\n      sscanf(argv[i + 1], \"%lf\", &accuracy);\n      break;\n\n    case 'o':\n      sscanf(argv[i + 1], \"%lf\", &omega);\n      break;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/10"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  for (size_t j = 0; j < size; j++)\n  {\n    for (size_t k = 0; k < size; k++)\n    {\n      c[i][j] += a[i][k] * b[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/dotprod/src/main/2"}
{"code": "for (int u = 0; u < ((M * M) * 2); u++)\n{\n  printf(\"%f \", *(BP + u));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/10"}
{"code": "for (size_t i = 0; i < num_of_organisms; i++)\n{\n  organism_update(&env.grid[i]);\n}\n\n", "pragma": "omp parallel for num_threads(num_threads) schedule(static, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/1"}
{"code": "for (int col = 3 - 1; col >= 0; col--)\n{\n  x[col] /= A[col][col];\n  for (int row = 0; row < col; row++)\n    x[row] -= A[row][col] * x[col];\n\n}\n\n", "pragma": "omp parallel for schedule(static,1) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elard28/OpenMPparalelos/e4/1"}
{"code": "for (i = 0; i < iter; i++)\n{\n  byte1 = byte_array_get(array, 2 * i);\n  byte2 = byte_array_get(array, (2 * i) + 1);\n  ret = do_or_pair(byte1, byte2);\n  byte_array_set(aux, i, ret);\n}\n\n", "pragma": "omp for schedule(static, chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sudipta1411/bitsor/do_or/1"}
{"code": "for (unsigned i = 0; i < ((I * I) * I); ++i)\n  if (B[i] != ReferenceB[i])\n{\n  printf(\"Error B[i] != ReferenceB[i] at %08x: %08x != %08x\\n\", i, B[i], ReferenceB[i]);\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-data-sharing-many-teams/test/4"}
{"code": "for (int j = 0; j <= _M; j++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (_M / mpi_size)\n    bi = j / (_M / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = (bj + bi) % mpi_size;\n  st = ((mpi_size + st) - mpi_rank) % mpi_size;\n  s->rb = st * (sN / mpi_size);\n  s->re = s->rb + (sN / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = sN + 1;\n\n  if (s->re != (sN + 1))\n    x[idx(s->re, j, k)] = rbp[0][0];\n\n  if (s->rb != 0)\n    x[idx(s->rb - 1, j, k)] = rbp[1][0];\n\n  rbp[1]++;\n  rbp[0]++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/142"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    C[(i * M) + j] *= beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk/2"}
{"code": "for (unsigned int i = 0; i < number; i++)\n  if (is_alive[i])\n  back_velocity_to_rz_single(i);\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/8"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  for (j = 0; j < nclusters; j++)\n  {\n    local_new_centers[i][j] = (float *) calloc(nfeatures, sizeof(float));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ubivam/OpenMP-Examples/kmeans/kmeans_clustering/3"}
{"code": "for (i = 0; i < N; i++)\n  printf_s(\"4: Thread: %d, a[%d] = %d\\n\", omp_get_thread_num(), i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_programing_CSharp/LU9_barrierCriticalMasterOrdered/LU9/MasterAndCritical/3"}
{"code": "for (i = 0; i < (2 * (nendmembers - 1)); i++)\n{\n  for (j = 0; j < (2 * (nendmembers - 1)); j++)\n  {\n    fprintf(report, \" %lf\", sqr[i][j]);\n  }\n\n  fprintf(report, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/15"}
{"code": "for (i = 0; i < rows1; i++)\n{\n  for (j = 0; j < columns2; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < columns1; k++)\n    {\n      result[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(matrix1, matrix2, result) private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/promops/lab/main/3"}
{"code": "for (i = 1; i <= n; i++)\n  all_nums[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jing2018/OpenMP-programming-in-C/sieve_of_eratoshtenes_v3/1"}
{"code": "for (k = y_min; k <= y_max; k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= x_max; j++)\n  {\n    left_flux = (((xarea[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * (((xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + xvel0[FTNREF2D(j, k + 1, x_max + 5, x_min - 2, y_min - 2)]) + xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + xvel0[FTNREF2D(j, k + 1, x_max + 5, x_min - 2, y_min - 2)])) * 0.25) * dt) * 0.5;\n    right_flux = (((xarea[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] * (((xvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] + xvel0[FTNREF2D(j + 1, k + 1, x_max + 5, x_min - 2, y_min - 2)]) + xvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) + xvel0[FTNREF2D(j + 1, k + 1, x_max + 5, x_min - 2, y_min - 2)])) * 0.25) * dt) * 0.5;\n    bottom_flux = (((yarea[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] * (((yvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + yvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)])) * 0.25) * dt) * 0.5;\n    top_flux = (((yarea[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)] * (((yvel0[FTNREF2D(j, k + 1, x_max + 5, x_min - 2, y_min - 2)] + yvel0[FTNREF2D(j + 1, k + 1, x_max + 5, x_min - 2, y_min - 2)]) + yvel0[FTNREF2D(j, k + 1, x_max + 5, x_min - 2, y_min - 2)]) + yvel0[FTNREF2D(j + 1, k + 1, x_max + 5, x_min - 2, y_min - 2)])) * 0.25) * dt) * 0.5;\n    total_flux = ((right_flux - left_flux) + top_flux) - bottom_flux;\n    volume_change[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] / (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + total_flux);\n    min_cell_volume = MIN((((volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + right_flux) - left_flux) + top_flux) - bottom_flux, MIN((volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + right_flux) - left_flux, (volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + top_flux) - bottom_flux));\n    recip_volume = 1.0 / volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    energy_change = (((pressure[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] / density0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) + (viscosity[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] / density0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)])) * total_flux) * recip_volume;\n    energy1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = energy0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] - energy_change;\n    density1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = density0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] * volume_change[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(right_flux,left_flux,top_flux,bottom_flux,total_flux,min_cell_volume,energy_change,recip_volume,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/PdV_kernel_c/0"}
{"code": "for (int i = 20; i < limit; i++)\n{\n  if (divide(i))\n  {\n    printf(\"the number is equal to %d  \\n\", i);\n    control = 1;\n  }\n\n  if ((i % 100000000) == 0)\n  {\n    printf(\"***thread id : %d, limit = %d point = %d\\n\", omp_get_thread_num(), limit, i);\n  }\n\n  if ((control == 0) && (i == (limit - 1)))\n  {\n    limit += limit;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex5projecteuler/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  result[i] = sin(i);\n}\n\n", "pragma": "omp for parallel schedule ( dynamic, 1 )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filipecosta90/Parallel-Computing-Paradigms/aula3/exec3/0"}
{"code": "for (size_t i = 0; i < num; ++i)\n{\n  res += a[i] * b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_dot_product/c1_1/dprod/0"}
{"code": "for (int i = 0; i < n_moves; i++)\n{\n  MPI_Status status;\n  tree_t cChildSend;\n  result_t cChildResult;\n  play_move(T, moves[i], &cChildSend);\n  const int cDest = giveMeFreeMachine();\n  MPI_Send(&cChildSend, 1, mpi_tree_t, cDest, 1, 1);\n  MPI_Recv(&cChildResult, 1, mpi_result_t, cDest, 1, 1, &status);\n  machines[cDest] = 1;\n  int child_score = -cChildResult.score;\n  if (child_score > result->score)\n  {\n    result->score = child_score;\n    result->best_move = moves[i];\n    result->pv_length = cChildResult.pv_length + 1;\n    for (int j = 0; j < cChildResult.pv_length; j++)\n      result->PV[j + 1] = cChildResult.PV[j];\n\n    result->PV[0] = moves[i];\n  }\n\n  if (ALPHA_BETA_PRUNING && (child_score >= T->beta))\n    ab = 1;\n\n  T->alpha = MAX(T->alpha, child_score);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adahn/Project_Parallelism/version2/MPI/main/1"}
{"code": "for (i = 0; i < 7; i++)\n{\n  printf(\"Run %d \\n\", i);\n  train8(G, i);\n  sleep(2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/train8/1"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = b[i] + c[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/restrictpointer2-orig-no/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 1; j < SIZE; j++)\n  {\n    ex[(i * (SIZE + 1)) + j] = ex[(i * (SIZE + 1)) + j] - (0.5 * (hz[(i * SIZE) + j] - hz[(i * SIZE) + (j - 1)]));\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/FDTD2D/fdtd2d/2"}
{"code": "for (k = nz / 2; k < (3 * (nz / 4)); k++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    for (i = 1; i < (nx - 1); i++)\n    {\n      Anext[Index3D(nx, ny, i, j, k)] = (((((A0[Index3D(nx, ny, i, j, k + 1)] + A0[Index3D(nx, ny, i, j, k - 1)]) + A0[Index3D(nx, ny, i, j + 1, k)]) + A0[Index3D(nx, ny, i, j - 1, k)]) + A0[Index3D(nx, ny, i + 1, j, k)]) + A0[Index3D(nx, ny, i - 1, j, k)]) - ((6.0 * A0[Index3D(nx, ny, i, j, k)]) / (fac * fac));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/stencil/3dHeat/Variations/heat_ompv2/2"}
{"code": "for (int i = 0; i < N; i++)\n  result += x[i] * x[i];\n\n", "pragma": "    #pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment6/mini_app/linalg/1"}
{"code": "for (int i = 1; i < (grid.shape[0] - 1); ++i)\n{\n  for (int j = 1; j < (grid.shape[1] - 1); ++j)\n  {\n    for (int k = 1; k < (grid.shape[2] - 1); ++k)\n    {\n      c_norm = max(abs(grid(i, j, k) - groundTruth(i, j, k)), c_norm);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(max : c_norm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/CpuSolver/5"}
{"code": "for (iter = 0; iter < 200; ++iter)\n{\n  color[iter][0] = 255 - iter;\n  color[iter][1] = 255 - iter;\n  color[iter][2] = 255 - iter;\n  if ((iter % 2) == 0)\n  {\n    color[iter][0] = color[iter][2];\n    int temp = color[iter][1];\n    color[iter][1] = 255;\n    color[iter][2] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saumyabhadani95/Mandelbrot-set-parallel/OpenMPMandelbrot/1"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = cast_y->vec_[i] * cast_x->vec_[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/29"}
{"code": "for (i = 1; i <= (16 + 1); i++)\n{\n  double *_imopVarPre209;\n  double _imopVarPre210;\n  _imopVarPre209 = &t1;\n  _imopVarPre210 = randlc(_imopVarPre209, t1);\n  t2 = _imopVarPre210;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/EP/ep/2"}
{"code": "for (int process_iter = 0; process_iter < processes_count; process_iter++)\n{\n  chunk_size[process_iter] += 1;\n  remaining_blocks--;\n  if (remaining_blocks == 0)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/4"}
{"code": "for (i = 0; i < numIterations; i++)\n{\n  int dummy = 1;\n  int threadId = omp_get_thread_num();\n  struct timeval tvBegin;\n  struct timeval tvEnd;\n  struct timeval tvDiff;\n  gettimeofday(&tvBegin, 0);\n  gettimeofday(&tvEnd, 0);\n  if (sleepTime)\n  {\n    while ((tvEnd.tv_usec - tvBegin.tv_usec) < sleepTime)\n    {\n      int i;\n      int j;\n      for (i = 0; i < 10000; ++i)\n      {\n        dummy *= 2;\n      }\n\n      gettimeofday(&tvEnd, 0);\n    }\n\n    printf(\"Thread Num : %d, Sleep Duration (usec): %d, Execution Time: %ld, Theoritical Time: %ld\\n\", threadId, sleepTime, tvEnd.tv_usec - tvBegin.tv_usec, sleepTime);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pnookala/MIC_OpenMP/src/MIC_OpenMP/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 1; j < n; ++j)\n  {\n    if (A[j] < A[j - 1])\n    {\n      int temp = A[j];\n      A[j] = A[j - 1];\n      A[j - 1] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/bubblesort/0"}
{"code": "for (int i = 0; i < n; i = i + (2 * size))\n{\n  merge(arr, i, min(i + size, n), min(i + (2 * size), n), arr1);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ManjunathBirajdar/OpenMP-Parallelism/openmp-looping-parallelism/mergesort/mergesort/1"}
{"code": "for (i = c + 32ULL; i > c; i -= 1ULL)\n  a[(i - 1ULL) - c] -= 4;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.c-c++-common/pr81875/0"}
{"code": "for (long i = 2; i <= max_num_threads; i *= 2)\n{\n  res[i] = piMcParallel(i);\n  printf(\"#threads: %ld time: %lf\\n\", i, res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q7/q7/1"}
{"code": "for (i = 0; i < size; ++i)\n  index[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abidrahman/Discovering-OpenMP/static/3"}
{"code": "for (int i = 0; i < (*w); i++)\n{\n  (*gauss_Kernel)[i] = (*gauss_Kernel)[i] / sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcoisgood/High-Performance-Computing/2.Canny-Edge-Detector with openMP/canny_edge/2"}
{"code": "for (unsigned int i = 0; i < corrs.size(); ++i)\n{\n  for (int j = 0; j < corrs[i]->get_Np(); ++j)\n  {\n    gsl_vector_set(p, p_idx, fc.p0[i][j]);\n    gsl_vector_set(ss, p_idx, 0.1 * fc.p0[i][j]);\n    ++p_idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/10"}
{"code": "for (row = xoffset + 1; row < ((xoffset + 1) + myxsize); row++)\n{\n  MPI_Recv(&u[0][row][yoffset + 1], 1, row_type, source, msgtype, 1, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/38"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, u21i, u31i, u41i, u51i, u21im1, u31im1, u41im1, u51im1, i, ist1, iend1, m) firstprivate(jst, ist)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/13"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  sum += column[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidator/3"}
{"code": "for (int i = 0; i < kernel.width; i++)\n{\n  for (int j = 0; j < kernel.height; j++)\n  {\n    kernel.pixels[i][j] /= kernel.divisor;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/3"}
{"code": "for (i = 0; i < number_of_rows_A; i++)\n{\n  for (j = 0; j < number_of_columns_B; j++)\n    printf(\"%6.2f   \", C[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaarrmiinnn/parallel_matrix_multiplication/mm_regular_row/6"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  dkx = dnx * ((float) j);\n  afdt = adt * cimagf(ffc[j]);\n  zt1 = (-cimagf(exy[2 + (4 * j)])) + (crealf(exy[2 + (4 * j)]) * _Complex_I);\n  zt2 = (-cimagf(exy[1 + (4 * j)])) + (crealf(exy[1 + (4 * j)]) * _Complex_I);\n  zt5 = bxy[1 + (4 * j)] + (dth * (dkx * zt1));\n  zt6 = bxy[2 + (4 * j)] - (dth * (dkx * zt2));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n  zt8 = (exy[1 + (4 * j)] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * j)]);\n  zt9 = (exy[2 + (4 * j)] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (4 * j)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n  exy[4 * j] = zero;\n  exy[1 + (4 * j)] = zt8;\n  exy[2 + (4 * j)] = zt9;\n  at1 = anorm * ((zt8 * conjf(zt8)) + (zt9 * conjf(zt9)));\n  ws += (double) at1;\n  zt5 += dth * (dkx * zt1);\n  zt6 -= dth * (dkx * zt2);\n  bxy[4 * j] = zero;\n  bxy[1 + (4 * j)] = zt5;\n  bxy[2 + (4 * j)] = zt6;\n  at1 = anorm * ((zt5 * conjf(zt5)) + (zt6 * conjf(zt6)));\n  wp += (double) at1;\n  bxy[(4 * j) + k1] = zero;\n  bxy[(1 + (4 * j)) + k1] = zero;\n  bxy[(2 + (4 * j)) + k1] = zero;\n  exy[(4 * j) + k1] = zero;\n  exy[(1 + (4 * j)) + k1] = zero;\n  exy[(2 + (4 * j)) + k1] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/34"}
{"code": "for (int i = 0; i < vector_len; i++)\n{\n  printf(\"%d\\n\", result[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmpi_calculate_matrix/src/Dong_ziqi/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%f\\n\", c[i]);\n  fprintf(fp, \"%f\\n\", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/vector/2"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      vijk = vs[k][j][i];\n      vp1 = vs[k][j + 1][i];\n      vm1 = vs[k][j - 1][i];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dy1ty1 * ((u[k][j + 1][i][0] - (2.0 * u[k][j][i][0])) + u[k][j - 1][i][0]))) - (ty2 * (u[k][j + 1][i][2] - u[k][j - 1][i][2]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dy2ty1 * ((u[k][j + 1][i][1] - (2.0 * u[k][j][i][1])) + u[k][j - 1][i][1]))) + (yycon2 * ((us[k][j + 1][i] - (2.0 * us[k][j][i])) + us[k][j - 1][i]))) - (ty2 * ((u[k][j + 1][i][1] * vp1) - (u[k][j - 1][i][1] * vm1)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dy3ty1 * ((u[k][j + 1][i][2] - (2.0 * u[k][j][i][2])) + u[k][j - 1][i][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[k][j + 1][i][2] * vp1) - (u[k][j - 1][i][2] * vm1)) + ((((u[k][j + 1][i][4] - square[k][j + 1][i]) - u[k][j - 1][i][4]) + square[k][j - 1][i]) * c2)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dy4ty1 * ((u[k][j + 1][i][3] - (2.0 * u[k][j][i][3])) + u[k][j - 1][i][3]))) + (yycon2 * ((ws[k][j + 1][i] - (2.0 * ws[k][j][i])) + ws[k][j - 1][i]))) - (ty2 * ((u[k][j + 1][i][3] * vp1) - (u[k][j - 1][i][3] * vm1)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dy5ty1 * ((u[k][j + 1][i][4] - (2.0 * u[k][j][i][4])) + u[k][j - 1][i][4]))) + (yycon3 * ((qs[k][j + 1][i] - (2.0 * qs[k][j][i])) + qs[k][j - 1][i]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[k][j + 1][i][4] * rho_i[k][j + 1][i]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k][j - 1][i][4] * rho_i[k][j - 1][i])))) - (ty2 * ((((c1 * u[k][j + 1][i][4]) - (c2 * square[k][j + 1][i])) * vp1) - (((c1 * u[k][j - 1][i][4]) - (c2 * square[k][j - 1][i])) * vm1)));\n    }\n\n  }\n\n  j = 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n    }\n\n  }\n\n  j = 2;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((((-4.0) * u[k][j - 1][i][m]) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n    }\n\n  }\n\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 3;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])));\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((u[k][j - 2][i][m] - (4. * u[k][j - 1][i][m])) + (5. * u[k][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/7"}
{"code": "for (n = nzi - 1; n < nzt; n++)\n{\n  nn = nxhyd * n;\n  for (k = 1; k < nyh; k++)\n  {\n    joff = nnxhd * k;\n    k1 = ((nnxhd * ny) - joff) + nn;\n    joff += nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      t1 = cimagf(f[jj + k1]) + (crealf(f[jj + k1]) * _Complex_I);\n      f[jj + k1] = conjf(f[jj + joff] - t1);\n      f[jj + joff] += t1;\n    }\n\n  }\n\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nnxhd * k) + nn;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (nnxhd * k1) + nn;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[(4 * i) + k1];\n        t2 = f[(1 + (4 * i)) + k1];\n        t3 = f[(2 + (4 * i)) + k1];\n        f[(4 * i) + k1] = f[(4 * i) + joff];\n        f[(1 + (4 * i)) + k1] = f[(1 + (4 * i)) + joff];\n        f[(2 + (4 * i)) + k1] = f[(2 + (4 * i)) + joff];\n        f[(4 * i) + joff] = t1;\n        f[(1 + (4 * i)) + joff] = t2;\n        f[(2 + (4 * i)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (nnxhd * (j + k1)) + nn;\n        j2 = (nnxhd * (j + k2)) + nn;\n        t1 = conjf(sct[kmr * j]);\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[(4 * i) + j2];\n          t3 = t1 * f[(1 + (4 * i)) + j2];\n          t4 = t1 * f[(2 + (4 * i)) + j2];\n          f[(4 * i) + j2] = f[(4 * i) + j1] - t2;\n          f[(1 + (4 * i)) + j2] = f[(1 + (4 * i)) + j1] - t3;\n          f[(2 + (4 * i)) + j2] = f[(2 + (4 * i)) + j1] - t4;\n          f[(4 * i) + j1] += t2;\n          f[(1 + (4 * i)) + j1] += t3;\n          f[(2 + (4 * i)) + j1] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxyz / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < ny; k++)\n    {\n      joff = (nnxhd * k) + nn;\n      for (jj = 0; jj < 3; jj++)\n      {\n        t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n        t1 = f[(jj + (4 * j)) + joff] + t2;\n        t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n        f[(jj + (4 * j)) + joff] = t1 + t2;\n        f[(jj + (4 * (nxh - j))) + joff] = conjf(t1 - t2);\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nnxhd * k) + nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      f[(jj + (4 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (4 * nxhh)) + joff]);\n      f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n    }\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (i = 0; i < ny; i++)\n      {\n        joff = (nnxhd * i) + nn;\n        t1 = f[(4 * j1) + joff];\n        t2 = f[(1 + (4 * j1)) + joff];\n        t3 = f[(2 + (4 * j1)) + joff];\n        f[(4 * j1) + joff] = f[(4 * j) + joff];\n        f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n        f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n        f[(4 * j) + joff] = t1;\n        f[(1 + (4 * j)) + joff] = t2;\n        f[(2 + (4 * j)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = conjf(sct[kmr * j]);\n        for (i = 0; i < ny; i++)\n        {\n          joff = (nnxhd * i) + nn;\n          t2 = t1 * f[((4 * j) + k2) + joff];\n          t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n          t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n          f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n          f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n          f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n          f[((4 * j) + k1) + joff] += t2;\n          f[((1 + (4 * j)) + k1) + joff] += t3;\n          f[((2 + (4 * j)) + k1) + joff] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (i = 0; i < ny; i++)\n  {\n    joff = (nnxhd * i) + nn;\n    for (j = 0; j < nxh; j++)\n    {\n      f[(3 + (4 * j)) + joff] = cimagf(f[(2 + (4 * j)) + joff]) + (cimagf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n      at1 = crealf(f[(2 + (4 * j)) + joff]);\n      f[(2 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (cimagf(f[(1 + (4 * j)) + joff]) * _Complex_I);\n      at2 = crealf(f[(1 + (4 * j)) + joff]);\n      f[(1 + (4 * j)) + joff] = at1 + (0.0 * _Complex_I);\n      f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,jj,j1,j2,nn,joff,at1,at2,t1,t2, t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/41"}
{"code": "for (i = 0; i < numOfThreads; i++)\n  free(histograms[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eladshoham1/Parallel_Computation_MPI_OpenMP_CUDA/main/4"}
{"code": "for (int i = 32; i <= 127; i++)\n{\n  local_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/diga_freq_par/5"}
{"code": "for (z = 0; z < 64; z += 8)\n  e *= bar(z, c, &d, &s);\n\n", "pragma": "omp for schedule(static, 1) reduction(task, *: d) reduction (*: e)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/task-reduction-8/1"}
{"code": "for (int i = 0; i < linpack_params->n; i++)\n{\n  dy[i] = dy[i] + (da * dx[i]);\n}\n\n", "pragma": "\t\t\t #pragma omp parallel for num_threads(num_thr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/32"}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%d %d %d\\n\", a[i][0], a[i][1], a[i][2]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srahul00/Connected-Components-OpenMP/OSAssignmentOpenMP/0"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  cast_prolong->mat_.row_offset[i + 1] += cast_prolong->mat_.row_offset[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/110"}
{"code": "for (i = 2; i < 2000000; i++)\n{\n  H[i] = 3.5 / ((7.0 / N[i - 1]) + (2.0 / H[i]));\n  N[i] = (N[i] / (N[i] + 2.5)) + (3.5 / N[i]);\n  J[i] = ((H[i - 1] / N[i - 2]) + (3.5 / H[i - 1])) / (H[i - 1] + N[i - 2]);\n}\n\n", "pragma": "omp parallel for shared(H) shared(J) shared(N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/8"}
{"code": "for (int i = 1; i < ((sizeof(shiftArray)) / (sizeof(shiftArray[0]))); i++)\n{\n  shiftArray[i] = e >> (16 * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/triod315/PDC/Lab3/Lab3/Lab3/0"}
{"code": "for (i = 0; i < (num_cols * num_vectors); i++)\n  y_data[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/7"}
{"code": "for (k = 0; k < n; k++)\n{\n  for (i = 0; i < n; i++)\n  {\n    r = B[i][k];\n    for (j = 0; j < n; j++)\n    {\n      A[i][j] += r * C[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kothiga/Matrix-Matrix-Parallel/MatMultOpenMP/13"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 3; j++)\n    for (k = 0; k < 3; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A-Nikhil/OpenMP-Programming/Lab_3/matrixMultiplication/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = i + 1; j < n; j++)\n  {\n    tmp = m[i][j];\n    m[i][j] = m[j][i];\n    m[j][i] = tmp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnx4015/CompParaleDist/Code/OpenMPCodeOptimization/multParalleli/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      uijk = us[i][j][k];\n      up1 = us[i + 1][j][k];\n      um1 = us[i - 1][j][k];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dx1tx1 * ((u[0][i + 1][j][k] - (2.0 * u[0][i][j][k])) + u[0][i - 1][j][k]))) - (tx2 * (u[1][i + 1][j][k] - u[1][i - 1][j][k]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dx2tx1 * ((u[1][i + 1][j][k] - (2.0 * u[1][i][j][k])) + u[1][i - 1][j][k]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[1][i + 1][j][k] * up1) - (u[1][i - 1][j][k] * um1)) + ((((u[4][i + 1][j][k] - square[i + 1][j][k]) - u[4][i - 1][j][k]) + square[i - 1][j][k]) * c2)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dx3tx1 * ((u[2][i + 1][j][k] - (2.0 * u[2][i][j][k])) + u[2][i - 1][j][k]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[2][i + 1][j][k] * up1) - (u[2][i - 1][j][k] * um1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dx4tx1 * ((u[3][i + 1][j][k] - (2.0 * u[3][i][j][k])) + u[3][i - 1][j][k]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[3][i + 1][j][k] * up1) - (u[3][i - 1][j][k] * um1)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dx5tx1 * ((u[4][i + 1][j][k] - (2.0 * u[4][i][j][k])) + u[4][i - 1][j][k]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[4][i + 1][j][k] * rho_i[i + 1][j][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i - 1][j][k] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[4][i + 1][j][k]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[4][i - 1][j][k]) - (c2 * square[i - 1][j][k])) * um1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/25"}
{"code": "for (i = 0; i < HWC_connect1_weights; i++)\n  fprintf(f, \"%lf \", network->layers[4]->weights[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/17"}
{"code": "for (i = 0; i <= (33 + 1); i++)\n{\n  for (k = 0; k <= (33 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/26"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (((char) x) == seqA[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqB[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqC[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqD[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqE[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqF[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqG[i])\n    counter[char_id]++;\n\n  if (((char) x) == seqH[i])\n    counter[char_id]++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnasKhedr/introduction-to-openMP/omp_code/0"}
{"code": "for (j = 0; j < size; j++)\n{\n  buffer[j] = vec[i] + (j * vec[i + 1]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timbo-rafa/parallel_programming/prodcons/prod_cons_paralelo/0"}
{"code": "for (int i = 0; i < 2; ++i)\n{\n  ++pvar, ++lvar;\n}\n\n", "pragma": "#pragma omp for linear(pvar, lvar)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_linear_codegen/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    printf(\"%d \", *((arr + (i * size)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SboneloMdluli/ELEN4020-Lab2/OpenMP/digOpenMp/2"}
{"code": "for (int i = 0; i < (m_nSizePoint * ELEMENT_COUNT_POINT); i++)\n{\n  if (fabs(m_pOut[i] - m_pOutRef[i]) > 1.0e-3)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultPoint3D/4"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->AssignToFlock(omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/9"}
{"code": "for (int i = 3, last = (int) ((double) sqrt(number)); i <= last; i += 2)\n{\n  if ((number % i) == 0)\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Katherine506/C-OpenMP-MPI/CI0117-2020-S2/Laboratorios/7/count_primes_cyclic/count_primes_cyclic/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  labelsCount[i] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/3"}
{"code": "for (i = 1; i < t; i += 2)\n{\n  if (generation[i].distance > generation[i + 1].distance)\n  {\n    tmp = generation.at(i + 1);\n    generation.at(i + 1) = generation.at(i);\n    generation.at(i) = tmp;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prachi220/Parallel-Programming/Travelling Salesman Problem/tsp_2014CS50289/5"}
{"code": "for (i = 2; i <= 100000; i++)\n{\n  if (ifprime[i] == 'y')\n  {\n    for (j = i * i; j <= 10000000000; j += i)\n      ifprime[j] = 'n';\n\n  }\n\n}\n\n", "pragma": "omp for private(i,j) schedule(runtime)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training5/b0521229-train5/0"}
{"code": "for (nedges = 0, vi = 0; vi < nvtxs; vi++)\n{\n  for (ei = xadj[vi], eiend = xadj[vi + 1]; ei < eiend; ei++)\n  {\n    if (adjwgt[ei] > 0)\n    {\n      xaii[vi].start++;\n      xaii[adjncy[ei]].start++;\n      edges[nedges].vi = vi;\n      edges[nedges].vj = adjncy[ei];\n      sups[nedges] = adjwgt[ei];\n      nedges++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/20"}
{"code": "for (int j = 0; j < numOfPoints; j++)\n{\n  i = allPoints[j].clusterId;\n  allClusters[i].x += allPoints[j].x;\n  allClusters[i].y += allPoints[j].y;\n  allClusters[i].z += allPoints[j].z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpqozxscyo.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sx-aurora-dev/openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (int i = 0; i < i_size_; ++i)\n{\n  for (int j = 0; j < j_size_; ++j)\n  {\n    (*this)(i, j) += obj(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/1"}
{"code": "for (j = 0; j < size; j++)\n  a[j] += b[j] + (3.0 * c[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Refcount/refcount/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nl; j++)\n{\n  if ((((i * ni) + j) % 20) == 0)\n    fprintf(POLYBENCH_DUMP_TARGET, \"\\n\");\n\n  fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, D[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/2mm/2mm/5"}
{"code": "for (i = 0; i < dim; i++)\n{\n  j = A[i] / w;\n  if (j > (n_buckets - 1))\n    j = n_buckets - 1;\n\n  k = j + (my_id * n_buckets);\n  b_index = buckets[k].index++;\n  B[b_index] = A[i];\n}\n\n", "pragma": "omp for private(i, b_index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adricarda/parallel-Bucket-Sort/parallelBucketSort/parallelBucketSort/1"}
{"code": "for (i = 0; i < (100000000 - 2); i++)\n{\n  if (final_array[i] > final_array[i + 1])\n  {\n    sorted = 'N';\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training6/b0521229-train6/7"}
{"code": "for (int i = 0; i < vector_size; ++i)\n  vector[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LuckThemAll/parallel-programming/OpenMP/task4/0"}
{"code": "for (int i = 0; i < lab; i++)\n{\n  layer8[i] = exp(layer8[i]);\n  sum += layer8[i];\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/22"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  for (int j = 0; j < 5; ++j)\n  {\n    K[i][j] = n;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmunidario/Trab02-Grupo20-B/paralelo/0"}
{"code": "for (int i = 0; i < set_1.size(); ++i)\n{\n  if (!contains(set_2, set_1[i]))\n    res.push_back(set_1[i]);\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kiiitG/homework4_openmp/main/3"}
{"code": "for (int i = 0; i < pack.size; ++i)\n{\n  if ((x % pack.prime_nums[i]) == 0)\n  {\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task6/main/4"}
{"code": "for (int transNumber = 0; transNumber < MatrixOrder; transNumber++)\n{\n  resultValue += firstParaMatrix[row][transNumber] * secondParaMatrix[transNumber][col];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/poodarchu/parallel-computing/OpenMP/mat_vec_mult/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  guess = log(guess);\n  guess = exp(sqrt(guess) / guess);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_sections/01_sections_nested/5"}
{"code": "for (j = 1; j < (height - 1); j++)\n{\n  for (i = 1; i < (width - 1); i++)\n  {\n    if ((edges[j * i] >= tmax) && (grayscaleData[j * i] == 0))\n    {\n      grayscaleData[j * i] = 255;\n      int nedges = 1;\n      temp[0] = j * i;\n      do\n      {\n        nedges--;\n        const int t = temp[nedges];\n        int nbs[8];\n        nbs[0] = t - width;\n        nbs[1] = t + width;\n        nbs[2] = t + 1;\n        nbs[3] = t - 1;\n        nbs[4] = nbs[0] + 1;\n        nbs[5] = nbs[0] - 1;\n        nbs[6] = nbs[1] + 1;\n        nbs[7] = nbs[1] - 1;\n        for (int k = 0; k < 8; k++)\n          if ((edges[nbs[k]] >= tmin) && (grayscaleData[nbs[k]] == 0))\n        {\n          grayscaleData[nbs[k]] = 255;\n          temp[nedges] = nbs[k];\n          nedges++;\n        }\n\n\n      }\n      while (nedges > 0);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/canny-edge-detection/OpenMP/processor/4"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpjg7jsr5a.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/affinity/format/affinity_values/2"}
{"code": "for (uint32_t i = 0; i < numKeys; i++)\n{\n  MurmurHash3_x64_128(d_keys + d_length[i], length[i], i, d_out + (i * 2));\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/6"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (i = 0; i < fftblock; i++)\n  {\n    y0[k][i].real = x[k][j][i + ii].real;\n    y0[k][i].imag = x[k][j][i + ii].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,ii ,x ,fftblock ,k ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/12"}
{"code": "for (int i = 0; i < 10; i++)\n  q_SortParral(mas, n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/sort/1"}
{"code": "for (unsigned int i = 0; i < mesh.voxels.size(); i++)\n{\n  if (mesh.voxels[i].is_Dirichlet == true)\n  {\n    for (unsigned int j = 0; j < dirichlet_value_vectors[i].size(); j++)\n    {\n      if (dirichlet_activation_vectors[i][j] == true)\n      {\n        density_vector(i)[j] = dirichlet_value_vectors[i][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/4"}
{"code": "for (idx_t j = 0; j < J; ++j)\n{\n  lambda[j] = SS_MAX(lambda[j], 1.);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/7"}
{"code": "for (int i = 0; i < MAX; i++)\n  sum += a[i];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/reduction/1"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    density1[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/6"}
{"code": "for (int i = 0; i < A->m; ++i)\n{\n  assert(levels[i] != INT_MAX);\n  ++prefixSum[levels[i] + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/5"}
{"code": "for (i = 0; i < 2000; i++)\n  im[i] = (int *) malloc(2000 * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment2/Asgn2/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (1 != fscanf(f_b, \"%lg\\n\", &b[i]))\n    errx(1, \"parse error entry %d\\n\", i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/16"}
{"code": "for (i = 0; i < 64; i++)\n{\n  ;\n}\n\n", "pragma": "omp for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/ordered-3/3"}
{"code": "for (int i = 0; i < MAXSIZE; i++)\n{\n  x_vals[i] = (i + 1) * INDEL;\n  y_vals[i] = x_vals[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bergerom/nw_parallel/nw-openmp/5"}
{"code": "for (i = i2; i <= ((((i2 + 256) < len) ? (i2 + 256) : (len)) - 1); i += 1)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB097-target-teams-distribute-orig-no/2"}
{"code": "for (i = 0; i < 214700000; i++)\n{\n  int threadid = omp_get_thread_num();\n  if (x[i] > mval[threadid])\n  {\n    mval[threadid] = x[i];\n    mloc[threadid] = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_false_sharing/0"}
{"code": "for (j = strlen(MaxB) - 1; j > (-1); --j)\n{\n  OptB[k] = MaxB[j];\n  ++k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/12"}
{"code": "for (i = 0; i < dataset.n_data; ++i)\n{\n  errors[i] += errors_delta_b;\n  errors[i] += errors_delta_alpha1 * kernelFunction(dataset.data[alpha1_index], dataset.data[i]);\n  errors[i] += errors_delta_alpha2 * kernelFunction(dataset.data[alpha2_index], dataset.data[i]);\n}\n\n", "pragma": "\t\t\t\t\t\t\t\t\t\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elixir-code/HPC-Lab/Project/SVM-OpenMP/svm-openmp-codes/src/svm/3"}
{"code": "for (vert1 = thread_num; vert1 < (g->num_vertices - 1); vert1 += num_threads)\n{\n  for (vert2 = vert1 + 1; vert2 < g->num_vertices; vert2++)\n  {\n    this_dist = tmg_distance_latlng(&g->vertices[vert1]->w.coords, &g->vertices[vert2]->w.coords);\n    if (this_dist < local_distance)\n    {\n      local_distance = this_dist;\n      local_v1 = vert1;\n      local_v2 = vert2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SienaCSISParallelProcessing/openmp-closestpairs/byvertex/openmp_closest_byvertex/0"}
{"code": "for (int i = 1; i < cities; i++)\n{\n  if (minx > posx[i])\n  {\n    minx = posx[i];\n  }\n\n  if (maxx < posx[i])\n  {\n    maxx = posx[i];\n  }\n\n  if (miny > posy[i])\n  {\n    miny = posy[i];\n  }\n\n  if (maxy < posy[i])\n  {\n    maxy = posy[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xyzst/OMP-and-TSP/tsp_omp/0"}
{"code": "for (i = 0; i < NL; i++)\n{\n  for (j = 0; j < NJ; j++)\n  {\n    C[(i * NL) + j] = (((DATA_TYPE) i) * (j + 3)) / NL;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/4"}
{"code": "for (j = actualStart; j < (actualStart + threadDataCount[threadId]); j++)\n{\n  data[j] = sliced[slicingCount++];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/10"}
{"code": "for (size_t i = 0; i < available_blocks_should_be; i++)\n{\n  const void *pointer = chunk.pGetData() + ((i * block_size_after_alignment) / (sizeof(BlockType)));\n  (((KRATOS_CHECK_EQUAL(chunk.Has(pointer), true) << chunk) << \" should have the pointer \") << pointer) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/tests/cpp_tests/sources/test_chunk/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/26"}
{"code": "for (uint64_t i = 0; i < m; i++)\n  for (uint64_t j = 0; j < n; j++)\n{\n  float accum = 0;\n  for (uint64_t k = 0; k < l; k++)\n    accum += A[(i * l) + k] * B[(k * n) + j];\n\n  C[(i * n) + j] = accum;\n}\n\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JGU-HPC/parallelprogrammingbook/chapter3/matrix_matrix_mult_transposed/matrix_mult/2"}
{"code": "for (int l = 0; l < nnz; l++)\n{\n  int col_l;\n  col_l = col_coo[l] - isOneBased;\n  int dst = col[col_l];\n  row[dst] = row_coo[l] - isOneBased;\n  col[col_l]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v4/v4_omp/4"}
{"code": "for (j = 1; j < (((2048 / 5) + 2) - 1); j++)\n{\n  i = 1;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    gnt[j] = whites[ii][j].data;\n  else\n    if (ii >= (((2048 / 1) + 2) / 2))\n    gnt[j] = blacks[ii - (((2048 / 1) + 2) / 2)][j].data;\n\n\n  i = ((2048 / 1) + 2) - 2;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    gst[j] = whites[ii][j].data;\n  else\n    if (ii >= (((2048 / 1) + 2) / 2))\n    gst[j] = blacks[ii - (((2048 / 1) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/11"}
{"code": "for (i = 0; i < num_elements; i++)\n  input_data[i] = floorf((500 - 1) * (rand() / ((float) 32767)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/histogram/1"}
{"code": "for (i = start_stage; i < cascade->count; i++)\n{\n  double stage_sum = 0;\n  for (j = 0; j < cascade->stage_classifier[i].count; j++)\n  {\n    stage_sum += icvEvalHidHaarClassifier(cascade->stage_classifier[i].classifier + j, variance_norm_factor, p_offset);\n  }\n\n  if (stage_sum < cascade->stage_classifier[i].threshold)\n  {\n    result = -i;\n    EXIT;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvhaar/3"}
{"code": "for (int i = 0; i < A->m; ++i)\n{\n  assert(levels[i] != INT_MAX);\n  ++local_count[(tid * numLevels) + levels[i]];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 0; i <= (grid_points[0] - 1); i++)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      for (k = 0; k <= (grid_points[2] - 1); k++)\n      {\n        rhs[m][i][j][k] = forcing[m][i][j][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/5"}
{"code": "for (i = vMax; (i >= 0) && (retain > 0); i--)\n{\n  retain -= hist[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/thresh/2"}
{"code": "for (i = 0; i < 4; i++)\n{\n  prod += u[i] * v[i];\n  printf(\"Thread in use: %d\\n\", thread_id);\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/dot_product/0"}
{"code": "for (uint64_t i = 0; i < 20; i++)\n  array[i] += i;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_01/3"}
{"code": "for (i = 0; i < n; i++)\n  result += x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/3"}
{"code": "for (i = 1; i <= (size - 2); i = i + 2)\n{\n  if (arr[i] > arr[i + 1])\n  {\n    tmp = arr[i + 1];\n    arr[i + 1] = arr[i];\n    arr[i] = tmp;\n    isSorted = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/raul4247/openmpSortings/OddEvenSort/oddEvenSort/5"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  for (k = 0; k < n; k++)\n  c_flat[(i * n) + j] += a_flat[(i * n) + k] * b_trans[(j * n) + k];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/mat_mul/6"}
{"code": "for (int i = 0; i < row; i++)\n  matrix[i] = (double *) malloc((sizeof(double)) * col);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/18"}
{"code": "for (int r = 0; r < reps; r++)\n{\n  createTownSet(current, size);\n  rounds = 0;\n  while (sizeTownSet(current, pops, size) <= (totalPop / 2))\n  {\n    unionTownSet(current, townSets[rand() % size], size);\n    rounds++;\n  }\n\n  totalRounds += rounds;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = sqrt(2.0 / ((double) (n + 1))) * sin((((double) ((i + 1) * j_one)) * pi) / ((double) (n + 1)));\n  printf(\"thread %d doing iteration %d \\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for num_threads(16)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/matVec-mpi/1"}
{"code": "for (k = 0; k < SIZE; k++)\n{\n  for (i = 0; i < SIZE; i++)\n  {\n    for (j = i + 1; j < SIZE; j++)\n    {\n      int l;\n      int cnt = 0;\n      int first = 0;\n      int second = 0;\n      int position[2];\n      for (l = 0; l < SIZE; l++)\n      {\n        if (forward_map[k][l][i] == 0)\n        {\n          first |= 1 << l;\n          if (cnt <= 1)\n            position[cnt] = l;\n          else\n          {\n            cnt = 0;\n            break;\n          }\n\n          cnt++;\n        }\n\n        if (forward_map[k][l][j] == 0)\n          second |= 1 << l;\n\n      }\n\n      if ((cnt == 2) && (second == first))\n      {\n        for (l = 0; l < SIZE; l++)\n        {\n          forward_map[k][position[0]][l] = 1;\n          forward_map[k][position[1]][l] = 1;\n        }\n\n        forward_map[k][position[0]][j] = 0;\n        forward_map[k][position[0]][i] = 0;\n        forward_map[k][position[1]][j] = 0;\n        forward_map[k][position[1]][i] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/15"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Send(&n, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/main/0"}
{"code": "for (k = 0; k < k_max; k++)\n{\n  if (matrixResult[k_indexer[k]] == k_indexer[k])\n    numBlocks++;\n\n}\n\n", "pragma": "omp for schedule(dynamic, k_max/omp_get_num_threads()), private(k), reduction(+:numBlocks)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/parallel-scan-sky/openmp/src/ScanSky_openmp/2"}
{"code": "for (long j = 0; j < arraySize; ++j)\n{\n  A[j] = j * 3.14;\n  B[j] = 2.1 * j;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime) num_threads(nworkers)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/test_dotprod_parfor/0"}
{"code": "for (int k = 0; k < n; ++k)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    for (int j = 0; j < n; ++j)\n    {\n      C.at[i][j] += A.at[i][k] * B.at[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RonRahaman/openmp_tutorial/src/dgemm/0"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n{\n  double cij = C[i + (j * n)];\n  for (int k = 0; k < n; k++)\n    cij += A[i + (k * n)] * B[k + (j * n)];\n\n  C[i + (j * n)] = cij;\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-naive/0"}
{"code": "for (int region = 0; region < num_regions; ++region)\n{\n  x_min = atof(argv[(region * 6) + 1]);\n  x_max = atof(argv[(region * 6) + 2]);\n  i_min = atof(argv[(region * 6) + 3]);\n  i_max = atof(argv[(region * 6) + 4]);\n  num = atoi(argv[(region * 6) + 5]);\n  maxiter = atoi(argv[(region * 6) + 6]);\n  my_scores[region] = mandelbrotSetCount(x_min, x_max, i_min, i_max, num, maxiter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajmorton/prog_parallelisation/mandelbrot_mpi/code/final/3"}
{"code": "for (j = 0; j < 2000; j++)\n{\n  for (k = 0; k < 2000; k++)\n    for (i = 0; i < 2000; i++)\n    c[j][i] = c[j][i] + (a[k][i] * b[k][j]);\n\n\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dianchengwangCHN/ParallelComputingLab/PA2/PA2-p2/pa2-p2/0"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (d_graph_mask[tid])\n  {\n    d_graph_mask[tid] = 0;\n    for (int i = d_graph_nodes[tid].starting; i < (d_graph_nodes[tid].no_of_edges + d_graph_nodes[tid].starting); i++)\n    {\n      int id = d_graph_edges[i];\n      if (!d_graph_visited[id])\n      {\n        d_cost[id] = d_cost[tid] + 1;\n        d_updating_graph_mask[id] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(MAX_THREADS_PER_BLOCK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bfs-omp/bfs/2"}
{"code": "for (j = 1; j <= NLat; j++)\n{\n  for (i = 1; i <= NLon; i++)\n  {\n    m = idx(j, i);\n    ierr = fscanf(fp, \" %f \", &fval);\n    Node(m, iTopo) = fval;\n    Node(m, iTime) = -1;\n    Node(m, iD) = -fval;\n    if (Node(m, iD) < 0)\n    {\n      Node(m, iD) = 0.0f;\n    }\n    else\n      if (Node(m, iD) < Par.dmin)\n    {\n      Node(m, iD) = Par.dmin;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/2"}
{"code": "for (j = 0; j < (32 * no_of_processes); j++)\n{\n  if (TFIDF_buff[j].numDocsWithWord != (-1))\n  {\n    sprintf(strings[cursor], \"%s@%s\\t%.16f\", TFIDF_buff[j].document, TFIDF_buff[j].word, TFIDF_buff[j].TFIDF_val);\n    cursor++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lkmokadam/TFIDF_MPI_OpenMP/TFIDF_extra/9"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  weights[x] = 1 / ((float) Nparticles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/8"}
{"code": "for (int i = 0; i < (*tasks); i++)\n{\n  options[i] = malloc((*level) * (sizeof(int)));\n  for (int j = 0; j < (*level); j++)\n  {\n    if (fscanf(cp, \"%d \", &options[i][j]) != 1)\n    {\n      err(1, \"Erreur de lecture du fichier %s\", cp_filename);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/24"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  for (y = 0; y < countOnes; y++)\n  {\n    indX = roundDouble(arrayX[x]) + objxy[(y * 2) + 1];\n    indY = roundDouble(arrayY[x]) + objxy[y * 2];\n    ind[(x * countOnes) + y] = fabs((double) ((((indX * IszY) * Nfr) + (indY * Nfr)) + k));\n    if (ind[(x * countOnes) + y] >= max_size)\n      ind[(x * countOnes) + y] = 0;\n\n  }\n\n  likelihood[x] = 0;\n  for (y = 0; y < countOnes; y++)\n    likelihood[x] += (pow(I[ind[(x * countOnes) + y]] - 100, 2) - pow(I[ind[(x * countOnes) + y]] - 228, 2)) / 50.0;\n\n  likelihood[x] = likelihood[x] / ((double) countOnes);\n}\n\n", "pragma": "omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.ref/0"}
{"code": "for (int i = 0; i <= m_nReaches; i++)\n{\n  m_percSubbasin[i] = 0.f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/GW_RSVR/GWaterReservoir/1"}
{"code": "for (i = 0; i < 15; i++)\n{\n  for (j = 0; j < 7; j++)\n  {\n    b[i][j] = i * j;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_mm/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = ((((double) ((n - i) - 1)) * a) + (((double) i) * b)) / ((double) (n - 1));\n  total_q = total_q + f(x);\n}\n\n", "pragma": "omp parallel for default(none) private(i, x) reduction(+:total_q) schedule(static, 100)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/OpenMP_Quad_Worksharing_C/quad/0"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    w[i][j] = mean;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhin-kakkad/SteadyStateHeatEquation/Project_parallel/6"}
{"code": "for (i = 0; i < NMAX[k]; i++)\n{\n  sum = 0;\n  for (j = 0; j < NMAX[k]; j++)\n    sum += a[i][j];\n\n  printf(\"\u0421\u0443\u043c\u043c\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441\u0442\u0440\u043e\u043a\u0438 %d \u0440\u0430\u0432\u043d\u0430 %f\\n\", i, sum);\n}\n\n", "pragma": "#pragma omp for private(i,j,sum) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab2/Lab2/Lab2/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    u[i][j] = w[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/7"}
{"code": "for (i = rb; i < re; i++)\n  c[1] += p_q[0][i] * p_w[1][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/12"}
{"code": "for (i = 0; i < 8; i++)\n{\n  t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n  t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n  t0 = (*(o0++) = lotus_magic_table[ARCH_INDEX((*(i0++)) ^ t0)]);\n  t1 = (*(o1++) = lotus_magic_table[ARCH_INDEX((*(i1++)) ^ t1)]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus5_fmt_plug/6"}
{"code": "for (int i = lower; i <= steps; i++)\n{\n  double x = (0.5 + i) * step;\n  double y = f(x);\n  local_integral = local_integral + calc_rect(y, step);\n}\n\n", "pragma": "omp for schedule(static,16)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rivaldodb23/parallel-integral-calculator/calcintegral/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/115"}
{"code": "for (i = 1; i < counter_size; i++)\n{\n  count[i] += count[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jessinra/IF3230-Radix-Sort-OpenMP/src/radix_sort/2"}
{"code": "for (i = 0; i < max; i = i + 2)\n{\n  store[k][i] = store[k - 1][i] + store[k - 1][i + 1];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kazuyachue/Parallel_Computing/Cuda/sum/0"}
{"code": "for (int i = 0; i < ((int) nTrials); ++i)\n{\n  data->angles[i] = data->prng.rand(M_PI);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedronCycle/3"}
{"code": "for (unsigned c = 0; c < Count(); c++)\n{\n  string > lines;\n  List[c]->GetConfig(lines);\n  Log->Print(lines);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsDamping/1"}
{"code": "for (int i = N / 4; i < ((N / 4) * 2); i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/8"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  const double sign_q = qom[is] / fabs(qom[is]);\n  for (int i = 1; i < nxn; i++)\n    for (int k = 1; k < nzn; k++)\n  {\n    xd = grid->getXN(i, 1, k) - x_center;\n    zd = grid->getZN(i, 1, k) - z_center;\n    if (((xd * xd) + (zd * zd)) <= (R * R))\n    {\n      rhons[is][i][1][k] = (sign_q * rhoINIT[is]) / FourPI;\n      rhons[is][i][2][k] = (sign_q * rhoINIT[is]) / FourPI;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/43"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  sum = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    sum += a[k] * p[colidx[k]];\n  }\n\n  q[j] = sum;\n  d += p[j] * q[j];\n}\n\n", "pragma": "omp parallel for private(k, sum) reduction(+:d)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nctu-homeworks/PP-hw2/cg/4"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  sum2 = 0.0;\n  aij = ai;\n  jx = kx;\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = head_x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    x_elem = tail_x[jx];\n    prod = a_elem * x_elem;\n    sum2 = sum2 + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  sum = sum + sum2;\n  y[iy] = sum;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum,sum2) shared(a_i,head_x_i,tail_x_i,y_i) private(i,aij,jx,a_elem,prod,x_elem,j,ai,iy)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/0"}
{"code": "for (i = 0; i < Number_Documents; i++)\n{\n  fprintf(resultfile, \"%d %d\\n\", i, finalresult[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/16"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    if ((arr[i][j] % 3) == 0)\n    {\n      num++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/farit2000/OpenMP_tests/tasks/5/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  chunk = 10;\n  A[i] = (B[i] = i * 1.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Labs/Parallel-Computing-Lab/Lab2/sum_2_vectors/1"}
{"code": "for (int i = 0; i < a->num_strings; i++)\n{\n  int step = 1 << where_to;\n  int j = (-1) + ((i + 1) * step);\n  if (i == 0)\n  {\n    answer[j] = (f[i] - (a->b(i) * answer[j + step])) / a->c(i);\n    answer_oc[j] = true;\n  }\n  else\n    if (i == (a->num_strings - 1))\n  {\n    answer[j] = (f[i] - (a->a(i) * answer[j - step])) / a->c(i);\n    answer_oc[j] = true;\n  }\n  else\n    if (!answer_oc[j])\n  {\n    answer[j] = ((f[i] - (a->a(i) * answer[j - step])) - (a->b(i) * answer[j + step])) / a->c(i);\n    answer_oc[j] = true;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonshting/mipt-openmp-mpi/openmp-mpi/06/main_parallel/0"}
{"code": "for (i = 1; i <= n; i++)\n{\n  ip = indx[i - 1];\n  sum = b[ip - 1];\n  b[ip - 1] = b[i - 1];\n  if (ii)\n  {\n    for (j = ii; j <= (i - 1); j++)\n    {\n      sum -= A(i - 1, j - 1) * b[j - 1];\n    }\n\n  }\n  else\n    if (sum)\n  {\n    ii = i;\n  }\n\n\n  b[i - 1] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/72"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n  printf(\"rank:%d, i:%d, j:%d, arr[i][j]:%d\\n\", rank, i, j, arr[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/matrix-dot-product/hybridparallel/4"}
{"code": "for (int i = 0; i < locks.size(); i++)\n{\n  omp_destroy_lock(&locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/E-BAO/Particles-Simulation/openmp/3"}
{"code": "for (int i = 0; i < numBuckets; ++i)\n{\n  for (int j = 0; j < num_threads; ++j)\n  {\n    histogramRadixFrequency[i] += local_histogram[(j * numBuckets) + i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/3"}
{"code": "for (int i = 0; i < RowN; i++)\n{\n  Result[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/8"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  int j;\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, cur_salt->salt, 8);\n  SHA512_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n  for (j = 1; j <= 65536; j++)\n  {\n    SHA512_CTX ctx;\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, (unsigned char *) crypt_out[index], 64);\n    SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ecryptfs_fmt_plug/3"}
{"code": "for (size_t i = 0, j = 0; i < m_cloud.size(); ++i)\n{\n  m_vertGL[j] = m_cloud[i][0];\n  m_vertGL[j + 1] = m_cloud[i][1];\n  m_vertGL[j + 2] = m_cloud[i][2];\n  m_vertGL[j + 3] = m_norms[i][0];\n  m_vertGL[j + 4] = m_norms[i][1];\n  m_vertGL[j + 5] = m_norms[i][2];\n  j += 6;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/0"}
{"code": "for (i = 0; i < (series->count - lag); i++)\n{\n  numerator += (series->data[i] - mean1) * (series->data[i + lag] - mean2);\n}\n\n", "pragma": "omp parallel for reduction (+: numerator)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/5"}
{"code": "for (j = 0; j < array_num; j++)\n{\n  if (((dim_switch_3d == 0) && (fabs(ph_x - (*(x + j))) < block_dist)) && (fabs(ph_y - (*(y + j))) < block_dist))\n  {\n    dist = pow(pow(ph_x - (*(x + j)), 2.0) + pow(ph_y - (*(y + j)), 2.0), 0.5);\n    if (dist < dist_min)\n    {\n      dist_min = dist;\n      min_index = j;\n    }\n\n  }\n  else\n    if ((((dim_switch_3d == 1) && (fabs(ph_x - (*(x + j))) < block_dist)) && (fabs(ph_y - (*(y + j))) < block_dist)) && (fabs(ph_z - (*(z + j))) < block_dist))\n  {\n    dist = pow((pow(ph_x - (*(x + j)), 2.0) + pow(ph_y - (*(y + j)), 2.0)) + pow(ph_z - (*(z + j)), 2.0), 0.5);\n    if (dist < dist_min)\n    {\n      dist_min = dist;\n      min_index = j;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/12"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 0; k <= (grid_points[2] - 3); k += 1)\n    {\n      k1 = k + 1;\n      k2 = k + 2;\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n      rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n      lhs[n + 1][i][j][k2] = lhs[n + 1][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 3][i][j][k]);\n      lhs[n + 2][i][j][k2] = lhs[n + 2][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 4][i][j][k]);\n      rhs[m][i][j][k2] = rhs[m][i][j][k2] - (lhs[n + 0][i][j][k2] * rhs[m][i][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (k1,k2,fac1,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/211"}
{"code": "for (int i = 0; i < N; i++)\n{\n  dijkstra(N, graph, i, solutionMatrix);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avisenna01/Djikstra-OpenMP/src/dijkstra_omp/0"}
{"code": "for (a = x0; a <= x1; a++)\n{\n  array[transformer(y0, a)] = V0 / 2;\n  array[transformer(y1, a)] = (-V0) / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanclopezr/openmp_first/openmpi/3"}
{"code": "for (int i = 0; i < num_conflicts; ++i)\n{\n  for (int j = 0; j < (maxd + 1); ++j)\n  {\n    forbidden[i][j] = false;\n  }\n\n  int v = conflicts[i];\n  for (int j = 0; j < m[v]; ++j)\n  {\n    int u = adj_list[v][j];\n    if (colors[u] >= 0)\n      forbidden[i][colors[u]] = true;\n\n  }\n\n  for (int j = 0; j < (maxd + 1); ++j)\n  {\n    if (forbidden[i][j] == false)\n    {\n      colors[v] = j;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Vertex-Coloring/parallel-omp/1"}
{"code": "for (i = 0; i < nsize; i++)\n{\n  for (j = 0; j < nsize; j++)\n  {\n    c1 = 0.0;\n    for (k = 0; k < nsize; k++)\n    {\n      c2 = matrix.a2[i][k] * matrix.a2[j][k];\n      c3 = matrix.b2[i][k] * matrix.b2[j][k];\n      c1 = (c1 + c2) + c3;\n    }\n\n    matrix.c2[i][j] = matrix.c2[i][j] + (c1 / ((float) nsize));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avr-aics-riken/PMlib/example/test3/sub_kernel/0"}
{"code": "for (size_t i = 0; i <= (gast.size() - 1); ++i)\n{\n  {\n    calcularDistancia(gast[i], gast, planetas, n_threads);\n    calcularMovimientoNormal(gast[i], gast, planetas, n_threads);\n    calcularFuerzaX(gast[i], gast, planetas, n_threads);\n    calcularFuerzaY(gast[i], gast, planetas, n_threads);\n    calcularMovimientoAsteriode(gast[i], n_threads);\n    calcularRebotePared(gast[i]);\n  }\n}\n\n", "pragma": "                    #pragma omp parallel for ordered num_threads(n_threads) firstprivate(planetas)                     ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Montware/sequential-vs-openmp/_old_par/main/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    short tmpShortDistance = 0;\n    tmpShortDistance = 0.5 + (100 * sqrt((((coordinateMatrix[i][0] - coordinateMatrix[j][0]) * (coordinateMatrix[i][0] - coordinateMatrix[j][0])) + ((coordinateMatrix[i][1] - coordinateMatrix[j][1]) * (coordinateMatrix[i][1] - coordinateMatrix[j][1]))) + ((coordinateMatrix[i][2] - coordinateMatrix[j][2]) * (coordinateMatrix[i][2] - coordinateMatrix[j][2]))));\n    {\n      distanceArray[tmpShortDistance] += 1;\n    }\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) reduction(+:distanceArray[:maximumLengthResolution])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PerJNilsson/C---OpenMP/cell_distance/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/17"}
{"code": "for (size_t q = 0; q < Nqd; q++)\n{\n  PolPol.setZero();\n  PolPol = (quads(q, 2) * Polt.block(q, 0, 1, k + 1).transpose()) * Poltau.block(q, 0, 1, k + 1);\n  Kdq.setZero();\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, g.next(i)) = Knext(q, i);\n  }\n\n  K += kron(Kdq, PolPol);\n  Kdq.setZero();\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, g.prev(i)) = Kprev(q, i);\n  }\n\n  K += kron(Kdq, PolPol.transpose());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/14"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    for (k = 0; k < 2048; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amineremache/matrix_mult/matrix_mul_openmp/0"}
{"code": "for (i = 0; i < (len * threads); i++)\n{\n  a[i] = 2.0;\n  b[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/OpenMP/dotproduct/0"}
{"code": "for (i = 0; i < 10; i++)\n  __tasks[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/examples/pedro-test/1"}
{"code": "for (int tt = 0; tt < params.maxIters; tt++)\n{\n  timestep(params, cells, tmp_cells, obstacles);\n  swp_cells = cells;\n  cells = tmp_cells;\n  tmp_cells = swp_cells;\n  av_vels[tt] = av_velocity(params, cells, obstacles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jerrykress/Lattice-Boltzmann-OpenMP/d2q9-bgk/3"}
{"code": "for (l1 = 0; l1 < interpolation_order; l1++)\n{\n  tmp1 = 1. / sqrt(1 - (nodes[l1] * nodes[l1]));\n  for (l2 = 0; l2 < interpolation_order; l2++)\n  {\n    tmp2 = tmp1 / sqrt(1 - (nodes[l2] * nodes[l2]));\n    for (l3 = 0; l3 < interpolation_order; l3++)\n    {\n      Kweights[count] = tmp2 / sqrt(1 - (nodes[l3] * nodes[l3]));\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/19"}
{"code": "for (index = 0; index < count; index++)\n  if (cracked[index])\n  if (printf(\"\\noriginal: %s\\n\", ciphertext) + printf(\"fail line %u: '%s' p=%p q=%p q-p-1=%u\\n\", 467, p, p, q, (unsigned int) ((q - p) - 1)))\n  return 1;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/openssl_enc_fmt_plug/4"}
{"code": "for (i = 0; i < size; ++i)\n{\n  func(&part, &vec[i]);\n  result[i] = part;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/omp-exercises/iterative_scan/0"}
{"code": "for (int i = 0; i < F->Size; i++)\n  F->data[i] = ParametroRelajacion * (b->data[i] / A->data[(i * A->m) + i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joelchaconcastillo/SolverMontecarlo_MAO/SolverSistemaEcuacionesOpenMP/MonteCarlo/5"}
{"code": "for (k = 0; k < n; k++)\n{\n  if (k != part)\n  {\n    f_part_k[0] = curr[part].s[0] - curr[k].s[0];\n    f_part_k[1] = curr[part].s[1] - curr[k].s[1];\n    len = sqrt((f_part_k[0] * f_part_k[0]) + (f_part_k[1] * f_part_k[1]));\n    len_3 = (len * len) * len;\n    mg = ((-G) * curr[part].m) * curr[k].m;\n    fact = mg / len_3;\n    f_part_k[0] *= fact;\n    f_part_k[1] *= fact;\n    forces[part][0] += f_part_k[0];\n    forces[part][1] += f_part_k[1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/6"}
{"code": "for (i = 1; i < (n + 1); i++)\n{\n  if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].n) == (-1))\n  {\n    {\n      if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n      {\n        fprintf(stdout, \" Bogus input file\\n\");\n      }\n\n    }\n    ;\n    exit(-1);\n  }\n\n  ;\n  gcells[i].alt = (int (*)[2]) malloc(gcells[i].n * (sizeof(int [2])));\n  for (j = 0; j < gcells[i].n; j++)\n  {\n    if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].alt[j][0]) == (-1))\n    {\n      {\n        if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n        {\n          fprintf(stdout, \" Bogus input file\\n\");\n        }\n\n      }\n      ;\n      exit(-1);\n    }\n\n    ;\n    if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].alt[j][1]) == (-1))\n    {\n      {\n        if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n        {\n          fprintf(stdout, \" Bogus input file\\n\");\n        }\n\n      }\n      ;\n      exit(-1);\n    }\n\n    ;\n  }\n\n  if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].left) == (-1))\n  {\n    {\n      if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n      {\n        fprintf(stdout, \" Bogus input file\\n\");\n      }\n\n    }\n    ;\n    exit(-1);\n  }\n\n  ;\n  if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].above) == (-1))\n  {\n    {\n      if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n      {\n        fprintf(stdout, \" Bogus input file\\n\");\n      }\n\n    }\n    ;\n    exit(-1);\n  }\n\n  ;\n  if (__isoc99_fscanf(inputFile, \"%d\", &gcells[i].next) == (-1))\n  {\n    {\n      if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n      {\n        fprintf(stdout, \" Bogus input file\\n\");\n      }\n\n    }\n    ;\n    exit(-1);\n  }\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/floorplan/src/floorplan_ompi/3"}
{"code": "for (i = 0; i < np; i++)\n{\n  for (j = 0; j < nd; j++)\n    f[i][j] = 0.0;\n\n  for (j = 0; j < np; j++)\n  {\n    if (i != j)\n    {\n      d = dist(nd, pos[i], pos[j], rij);\n      pot = pot + (0.5 * v(d));\n      for (k = 0; k < nd; k++)\n      {\n        f[i][k] = f[i][k] - ((rij[k] * dv(d)) / d);\n      }\n\n    }\n\n  }\n\n  kin = kin + dot_prod(nd, vel[i], vel[j]);\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j, k, rij, d) reduction(+ : pot, kin)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_MolecularDynamic/c_md/0"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    if ((arr[j] > arr[i]) || ((arr[j] == arr[i]) && (j < i)))\n    {\n      rank[i]++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tebesfinwo/CISC-4335-OpenMP-Rank-Sort-/Parallel Rank Sort/main/0"}
{"code": "for (i = 2; i < l_Value; ++i)\n{\n  if ((l_Value % i) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/creativeyann17/Prime_C_JAVA/OpenMP/Prime/0"}
{"code": "for (int j = 2; j <= check; j++)\n{\n  if ((i % j) == 0)\n  {\n    isPrimeNumberFound = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/banjarashalin/FluidSimulationSolver/SloverCode/src/SpatialHashing/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/24"}
{"code": "for (i = 0; i < v_size; i++)\n  if (sudoku[i])\n  update_masks(sudoku[i], i / m_size, i % m_size, rows_mask, cols_mask, boxes_mask);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/10"}
{"code": "for (int i = (N / 8) * 3; i < (N / 2); i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n  {\n    total *= sp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/11"}
{"code": "for (int i = 0; i < 32; ++i)\n{\n  (cout << i) << endl;\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daleksla/learning/tools/openmp/basic_for/0"}
{"code": "for (int i = 0; i < 100; i++)\n  foo();\n\n", "pragma": "#pragma omp target parallel for is_device_ptr(k)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_parallel_for_is_device_ptr_ast_print/0"}
{"code": "for (i = 0; i <= (public.endoPoints - 1); i += 1)\n{\n  private[i].point_no = i;\n  private[i].in_pointer = private[i].point_no * public.in_mod_elem;\n  private[i].d_Row = public.d_endoRow;\n  private[i].d_Col = public.d_endoCol;\n  private[i].d_tRowLoc = public.d_tEndoRowLoc;\n  private[i].d_tColLoc = public.d_tEndoColLoc;\n  private[i].d_T = public.d_endoT;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/0"}
{"code": "for (i = 1; i < k; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    if (((1 + probNum) % size) != 0)\n    {\n      probNum += 1;\n      continue;\n    }\n\n    m = genes[i].length();\n    n = genes[j].length();\n    l = m + n;\n    mygetMinimumPenaltyString(dp, genes[i], genes[j], pxy, pgap, xans, yans, m, n);\n    id = 1;\n    for (a = l; a >= 1; a--)\n    {\n      if ((yans[a] == '_') && (xans[a] == '_'))\n      {\n        id = a + 1;\n        break;\n      }\n\n    }\n\n    align1.reserve(id + l);\n    align2.reserve(id + l);\n    for (a = id; a <= l; a++)\n    {\n      align1 += xans[a];\n      align2 += yans[a];\n    }\n\n    memcpy(results[completed_jobs].hash, calculate(calculate(align1).append(calculate(align2))).c_str(), HASH_BUFF);\n    results[completed_jobs].probNum = probNum;\n    results[completed_jobs].penalty = (int) dp[m][n];\n    completed_jobs += 1;\n    align1.clear();\n    align2.clear();\n    probNum++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/8"}
{"code": "for (i = 0; i < argc; ++i)\n  foo();\n\n", "pragma": "  #pragma omp for firstprivate ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_firstprivate_messages/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  d = opendir(train_dir[i]);\n  while (((dir = readdir(d)) != NULL) && (count < img_n))\n  {\n    if ((strcmp(dir->d_name, \"..\") != 0) && (strcmp(dir->d_name, \".\") != 0))\n    {\n      strcpy(img_files[count], train_dir[i]);\n      strcat(img_files[count], dir->d_name);\n      for (int j = 0; j < n_classes; j++)\n      {\n        if (j == i)\n        {\n          y->vals[(count * n_classes) + j] = 1;\n        }\n        else\n        {\n          y->vals[(count * n_classes) + j] = 0;\n        }\n\n      }\n\n      count++;\n    }\n\n  }\n\n  closedir(d);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/10"}
{"code": "for (int i = 1; i < generations; i++)\n{\n  if (0 == 1)\n  {\n    printTable(table, size, threads, i);\n    getchar();\n  }\n\n  newTable = stepGeneration(table, size, threads);\n  table = newTable;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arielfreire/conways-game-of-life/jogo_da_vida/4"}
{"code": "for (int i = 0; i < 10; ++i)\n  (cout << i) << \" \";\n\n", "pragma": "\t#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wynnliam/openmp-learning/static_schedule/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int cur_cols = CVT_INT(data[i][0]);\n  Adjust1DArray(cur_cols, data[i] + 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/ParamInfo/2"}
{"code": "for (unsigned i = 0; i < size_h; i++)\n{\n  for (unsigned j = 0; j < size_v; ++j)\n  {\n    modelRBM.dW[i][j] = (((targetVals[j] - inputRBM.Vs[j]) * inputRBM.Vs[j]) * (1 - inputRBM.Vs[j])) * inputRBM.Hp[i];\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/6"}
{"code": "for (int i = 0; i < SIZE_X; i++)\n{\n  for (int j = 0; j < SIZE_Y; j++)\n  {\n    if ((m_Mesh[i][j] != NULL) && (ZOMBIE == m_Mesh[i][j]->GetType()))\n      (cout << \"0\") << \" \";\n    else\n      if ((m_Mesh[i][j] != NULL) && (HUMAN == m_Mesh[i][j]->GetType()))\n      (cout << \"1\") << \" \";\n    else\n      (cout << \"_\") << \" \";\n\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < k; j++)\n    a[i][j] = rand() % 1000;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task9/0"}
{"code": "for (int y = y0; y < y1; y++)\n{\n  int yLine = WORLD_WIDTH * y;\n  for (int x = x0; x < x1; x++)\n  {\n    int cnt = 0;\n    int group = 0;\n    for (int yy = y - 1; yy <= (y + 1); yy++)\n    {\n      for (int xx = x - 1; xx <= (x + 1); xx++)\n      {\n        if (m_matSrc[(WORLD_WIDTH * yy) + xx].age != CELL_DEAD)\n        {\n          cnt++;\n          group += m_matSrc[(WORLD_WIDTH * yy) + xx].group;\n        }\n\n      }\n\n    }\n\n    updateCell(x, yLine, cnt, group);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iwatake2222/FastGameOfLife/GameOfLife/LogicGroup/2"}
{"code": "for (i = 0; i < number_bodies; i++)\n{\n  V[i][0] = V[i][0] + ((F[i][0] * delta_t) / (2.0 * mass));\n  V[i][1] = V[i][1] + ((F[i][1] * delta_t) / (2.0 * mass));\n  V[i][2] = V[i][2] + ((F[i][2] * delta_t) / (2.0 * mass));\n}\n\n", "pragma": "    #pragma omp parallel for private(i) schedule(guided)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/2"}
{"code": "for (t = 0; t < n; t += 3)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    int i;\n    memcpy(BF_current[index & 1].S, BF_init_state.S, sizeof(BF_current[index & 1].S));\n    memcpy(BF_current[index & 1].P, BF_init_key[index], sizeof(BF_current[index & 1].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      BF_current[index & 1].P[i] = L0;\n      BF_current[index & 1].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[index & 1].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[index & 1].S[3][0xFF]));\n  }\n\n  count = 1 << salt->rounds;\n  do\n  {\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current[index & 1].P[0] ^= BF_exp_key[index][0];\n      BF_current[index & 1].P[1] ^= BF_exp_key[index][1];\n      BF_current[index & 1].P[2] ^= BF_exp_key[index][2];\n      BF_current[index & 1].P[3] ^= BF_exp_key[index][3];\n      BF_current[index & 1].P[4] ^= BF_exp_key[index][4];\n      BF_current[index & 1].P[5] ^= BF_exp_key[index][5];\n      BF_current[index & 1].P[6] ^= BF_exp_key[index][6];\n      BF_current[index & 1].P[7] ^= BF_exp_key[index][7];\n      BF_current[index & 1].P[8] ^= BF_exp_key[index][8];\n      BF_current[index & 1].P[9] ^= BF_exp_key[index][9];\n      BF_current[index & 1].P[10] ^= BF_exp_key[index][10];\n      BF_current[index & 1].P[11] ^= BF_exp_key[index][11];\n      BF_current[index & 1].P[12] ^= BF_exp_key[index][12];\n      BF_current[index & 1].P[13] ^= BF_exp_key[index][13];\n      BF_current[index & 1].P[14] ^= BF_exp_key[index][14];\n      BF_current[index & 1].P[15] ^= BF_exp_key[index][15];\n      BF_current[index & 1].P[16] ^= BF_exp_key[index][16];\n      BF_current[index & 1].P[17] ^= BF_exp_key[index][17];\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current[index & 1].P[0] ^= u1;\n      BF_current[index & 1].P[1] ^= u2;\n      BF_current[index & 1].P[2] ^= u3;\n      BF_current[index & 1].P[3] ^= u4;\n      BF_current[index & 1].P[4] ^= u1;\n      BF_current[index & 1].P[5] ^= u2;\n      BF_current[index & 1].P[6] ^= u3;\n      BF_current[index & 1].P[7] ^= u4;\n      BF_current[index & 1].P[8] ^= u1;\n      BF_current[index & 1].P[9] ^= u2;\n      BF_current[index & 1].P[10] ^= u3;\n      BF_current[index & 1].P[11] ^= u4;\n      BF_current[index & 1].P[12] ^= u1;\n      BF_current[index & 1].P[13] ^= u2;\n      BF_current[index & 1].P[14] ^= u3;\n      BF_current[index & 1].P[15] ^= u4;\n      BF_current[index & 1].P[16] ^= u1;\n      BF_current[index & 1].P[17] ^= u2;\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[index & 1].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/35"}
{"code": "for (int i = a.size() - 1; i >= 0; i--)\n  v.push_back(\"\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/riak16/Parallel-addition/proj_omp/1"}
{"code": "for (int i = 0; i < fila_dinamica; i++)\n{\n  free(fuerzax[i]);\n  free(fuerzay[i]);\n  free(fuerzaxp[i]);\n  free(fuerzayp[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JaimeGarcia17/Asteroides/par/nasteroids-par/6"}
{"code": "for (int i = 0; i < nOctaves; i++)\n{\n  int row_start = i * nGpyrLayers;\n  w = gpyr[row_start].w;\n  h = gpyr[row_start].h;\n  for (int j = 0; j < nDogLayers; j++)\n  {\n    dogPyr[(i * nDogLayers) + j].init(w, h);\n    dstData = dogPyr[(i * nDogLayers) + j].data;\n    srcData1 = gpyr[row_start + j].data;\n    srcData2 = gpyr[(row_start + j) + 1].data;\n    index = 0;\n    while ((index++) < (w * h))\n      *(dstData++) = (*(srcData2++)) - (*(srcData1++));\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/5"}
{"code": "for (i = 0; i < n; i++)\n  cnt[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/24"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  matrice2[i] = malloc((sizeof(int)) * 3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP2EX3/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  h_a[i] = 0.5;\n  h_b[i] = 0.5;\n}\n\n", "pragma": "omp parallel for num_threads (4) schedule (dynamic, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-multiple-omp-parallel-for-combined-schedule-dynamic-chunk-value/0"}
{"code": "for (it = 0; it < total_its; it++)\n{\n  __off_info__->count = 0;\n  omp_offloading_start(__off_info__);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/6"}
{"code": "for (int i = 0; i < vertexCount; ++i)\n{\n  visitedVertex[i] = 0;\n  distancesOfThisVertex[i] = graph[fromVertex][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pancak3/Diameter-OpenMP/onePunch/2"}
{"code": "for (i = 0; i < (nendmembers - 1); i++)\n{\n  fprintf(report, \" %10.5lf  %10.5lf\\n\", hmin[i], hmax[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/9"}
{"code": "for (int i = 0; i < dim; ++i)\n{\n  for (int j = 0; j < dim; ++j)\n  {\n    double dot_product = 0;\n    for (int k = 0; k < dim; ++k)\n    {\n      dot_product += matrix1[i][k] * transposed[j][k];\n    }\n\n    result[i][j] = dot_product;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OC-ComputerScience/matrix/matrix/0"}
{"code": "for (int i = 0; i < proc_num; i++)\n{\n  int points_sending = per;\n  if (leftover_points)\n  {\n    points_sending++;\n    leftover_points--;\n  }\n\n  points_per[i] = points_sending;\n  displacements[i] = sum;\n  sum += points_per[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Podmanic19/Kmeans-using-MPI-and-openMP/main/0"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  l[0][i] = 0;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/lcs/4"}
{"code": "for (i = 1; i <= proc_rows; i++)\n  for (j = 1; j <= proc_columns; j++)\n  matrix[((proc_columns + 2) * i) + j] = DEAD;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yorgosk/game-of-life/MPI_OpenMp/functions_mpi_openmp/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int k = 0; k < n; k++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tsarkarsc/parallel_prog/cpp_files/matmul_parallel/0"}
{"code": "for (int j = 0; j < (ny + 2); j++)\n{\n  int ind = j;\n  temperature[ind] = 85.0;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/gpu-openmp/heat-equation/heat-cpu/cpp/heat/1"}
{"code": "for (int cx = 0; cx < nxc; cx++)\n  for (int cy = 0; cy < nyc; cy++)\n  for (int cz = 0; cz < nzc; cz++)\n{\n  assert_eq((*numpcls_in_bucket_now)[cx][cy][cz], (*numpcls_in_bucket)[cx][cy][cz]);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  dotVect = dotVector(A[i], x_old, n);\n  x[i] = ((b[i] - dotVect) / A[i][i]) + x_old[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/21"}
{"code": "for (j = 0; j < NODE_N; j++)\n{\n  tmp = orders[a][j];\n  orders[a][j] = orders[b][j];\n  orders[b][j] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/20"}
{"code": "for (it = 0; it < num; ++it)\n{\n  temp[cnt[first_lets[it]]++] = str_arr[it];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/20"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\"Enter u[%d]: \", i);\n  scanf(\"%f\", &u[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/dot_product/1"}
{"code": "for (i = 0; i < (V * V); i++)\n{\n  (cout << h_graph[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/22"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int tno = omp_get_thread_num();\n  int temp = lineDist(l, r, P[i]);\n  int k = findSide(l, r, P[i]);\n  if ((k == side) && (temp > max_dist))\n  {\n    max_dist = temp;\n    ind = i;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aman33459/ParallelConvexHull/quickHull/quickhullpara/5"}
{"code": "for (int dest = 1; dest < numtasks; dest++)\n{\n  MPI_Send(&macroPerN, 1, MPI_INT, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(&im1.height, 1, MPI_INT, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(&im1.width, 1, MPI_INT, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(&im2.height, 1, MPI_INT, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(&im2.width, 1, MPI_INT, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(&im1.arrayOfPixels[(macroPerN * macroblockSize) * dest], macroPerN * macroblockSize, MPI_CHAR, dest, 1, MPI_COMM_WORLD);\n  MPI_Send(im2.arrayOfPixels, N, MPI_CHAR, dest, 1, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stivenramireza/motion-vectors-algorithm/pcam/src/bmp/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    matriz_B[i][j] = rand() % 10;\n    (cout << matriz_B[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SidSan97/OMP---Algebra-Linear/OMP - Algebra Linear/main/1"}
{"code": "for (i = 0; i < N; i++)\n  L2[i] = L[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/1"}
{"code": "for (int j = 0; j < errorHistory.size(); ++j)\n{\n  ((cout << \"error: \") << errorHistory.at(j)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muatik/openmp-examples/als-movie-recommender/main/3"}
{"code": "for (j = 0; j < P; j++)\n{\n  float sum = 0;\n  for (i = 0; i < N; i++)\n    sum += b_host[i][j];\n\n  for (i = 0; i < N; i++)\n    b_host[i][j] /= sum;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/minkowski-omp/main/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name init#0#0\n  #pragma cetus parallel\n  for (j = 0; j < 100; j++)\n  {\n    a[i][j] = ((double) i) * j;\n    b[i][j] = ((double) i) * j;\n    c[i][j] = ((double) i) * j;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB060-matrixmultiply-orig-no/0"}
{"code": "for (c = 0; c < k; c++)\n{\n  for (i = 0; i < clusters[c].numDatapoints; i++)\n  {\n    totalCost += distance(datapoints[i], *clusters[c].medoid);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/12"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    grid[i][j].Mnext = 0;\n    freeLinkedList(grid[i][j].par_list);\n    grid[i][j].par_list = initLinkedList();\n  }\n\n}\n\n", "pragma": "omp for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelV/grid/0"}
{"code": "for (i = 0; i < n; i++)\n  sub2(i);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/appendix-a/a.15.1/0"}
{"code": "for (const_iterator p = (data.plaintext.begin() + index) + 8, c = ((data.ciphertext.begin() + data.offset) + index) + 8; p != data.plaintext.end(); ++p, ++c)\n{\n  if (((*c) ^ keysForward.getK()) != (*p))\n    return;\n\n  keysForward.update(*p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimci86/bkcrack/src/Attack/2"}
{"code": "for (i = 0; i < row; i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    a(i, j) = b(i, j) + (scalar * c(i, j));\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for private(i, j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/SREC_workshop/ex3_mpi_mm_gpu_omp/gpuoffload/1"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    a[i][j] = a[i][j + 2] + a[i + 2][j - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab8/lab8j/2"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  int curNode = DijkstraSelectNode(nodeNum, visited, disFromStart);\n  DijkstraUpdate(nodeNum, visited, edges, curNode, disFromStart, prevNode);\n  visited[curNode] = NODE_VISITED;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/3"}
{"code": "for (j = 0; j < 100; j++)\n{\n  printf(\"Buckett id: %u\\telems: \", j);\n  for (k = 0; k < buckets[j].len; k++)\n  {\n    printf(\"%d \", buckets[j].elems[k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg2/8"}
{"code": "for (int i = 0; i < N; i++)\n  quicksort_only_indices(full_A_indices, full_A_pointers[i], full_A_pointers[i + 1] - 1);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andriotis/Parallel-Distributed-Systems-1/openmp/2"}
{"code": "for (int i = 0; i < size; i++)\n  ds[i]->copyNewPosition();\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/zad6/DSEnsemble/3"}
{"code": "for (int i = 0; i < scalar_mom_len; ++i)\n{\n  scalar_mom[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/8"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  count += table[v[i]];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/1"}
{"code": "for (int i = 0; i < dim1; ++i)\n{\n  for (int j = 0; j < dim2; ++j)\n    ((cout << setw(5)) << Matr[(i * dim2) + j]) << \" \";\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/matrix_modified_multiplication/1"}
{"code": "for (int i = pow(2, l); i < max; i++)\n{\n  descente->current[i] = maximum(descente->current[i], montee->current[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/6"}
{"code": "for (our_current_row = 0; our_current_row <= (OUR_NUMBER_OF_ROWS + 1); our_current_row++)\n{\n  exit_if((our_current_grid[our_current_row] = (int *) malloc((NUMBER_OF_COLUMNS + 2) * (sizeof(int)))) == 0, \"malloc(our_current_grid[some_row])\", OUR_RANK);\n  exit_if((our_next_grid[our_current_row] = (int *) malloc((NUMBER_OF_COLUMNS + 2) * (sizeof(int)))) == 0, \"malloc(our_next_grid[some_row])\", OUR_RANK);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andrewpap22/Conway_sGameOfLife/GoL_All_Source_Files/life/3"}
{"code": "for (i = 0; i < numOfProcesses; i++)\n{\n  row = i / sizep;\n  column = i % sizep;\n  edges[(8 * i) + 0] = calculateProcess(row - 1, column - 1, sizep);\n  edges[(8 * i) + 1] = calculateProcess(row - 1, column, sizep);\n  edges[(8 * i) + 2] = calculateProcess(row - 1, column + 1, sizep);\n  edges[(8 * i) + 3] = calculateProcess(row, column - 1, sizep);\n  edges[(8 * i) + 4] = calculateProcess(row, column + 1, sizep);\n  edges[(8 * i) + 5] = calculateProcess(row + 1, column - 1, sizep);\n  edges[(8 * i) + 6] = calculateProcess(row + 1, column, sizep);\n  edges[(8 * i) + 7] = calculateProcess(row + 1, column + 1, sizep);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petros-ioannidis/parallel_CGOL/OPENMP_CGOL/graph_main_openmp/0"}
{"code": "for (int s = 0; s < nb_system; s++)\n{\n  variable_value_t = systems[s].variable_value_t;\n  variable_value_prev_t = systems[s].variable_value_prev_t;\n  value_matrix = systems[s].value_matrix;\n  validation_matrix = systems[s].validation_matrix;\n  system_size = systems[s].system_size;\n  for (int t = 0; t < nb_step; t++)\n  {\n    min = variable_value_prev_t[0];\n    max = variable_value_prev_t[0];\n    for (int i = 0; i < system_size; i++)\n    {\n      variable_value_t[i] = 0;\n      if (min > variable_value_prev_t[i])\n      {\n        min = variable_value_prev_t[i];\n      }\n\n      if (max < variable_value_prev_t[i])\n      {\n        max = variable_value_prev_t[i];\n      }\n\n    }\n\n    for (int i = 0; i < system_size; i++)\n    {\n      for (int j = 0; j < system_size; j++)\n      {\n        variable_value_t[i] += variable_value_prev_t[j] * value_matrix[i][j];\n      }\n\n    }\n\n    for (int i = 0; i < systems[s].system_size; i++)\n    {\n      variable_value_t[i] = ((double) (variable_value_t[i] - min)) / (max - min);\n      variable_value_prev_t[i] = variable_value_t[i];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tye447/TP_OT5_OPENMP/multiple_system_solver/0"}
{"code": "for (int i = 0; i < n; i++)\n  M[i] = (int *) calloc(3, sizeof(int));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/3"}
{"code": "for (int startBit = 0; startBit < 32; startBit += 2 * numBits)\n{\n  radixSortSerialPass(keys, keys_radix, startBit, numBits);\n  radixSortSerialPass(keys_radix, keys, startBit + numBits, numBits);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/12"}
{"code": "for (int i = 0; i < 20; ++i)\n  for (int j = 0; j < 10; ++j)\n  mat[i][j] = (j * 20) + i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_07/3"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, 0, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, yval, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, 0);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, y, zval)] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/mompDeblur/0"}
{"code": "for (unsigned int i = 0; i < ((2048 / NODESX) + 2); i++)\n  gro[i] = get[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/108"}
{"code": "for (i = 0; i < merge_calls; i++)\n{\n  low = n * i;\n  bit_merge(a, low, n, asc);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ram-Aditya/Bitonic-Sort/Bitonic Sort/bitsort_parallel/1"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xnew[i] = (TYPE) 0.0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    if (i != j)\n      xnew[i] += A[(i * Ndim) + j] * xold[j];\n\n  }\n\n  xnew[i] = (b[i] - xnew[i]) / A[(i * Ndim) + i];\n}\n\n", "pragma": "omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_par_dat_reg/0"}
{"code": "for (row = 1; row < (NRows + 1); row++)\n{\n  for (col = 1; col < (NCols + 1); col++)\n  {\n    if (IsOnFire(row, col))\n    {\n      NewTrees[((row - 1) * NCols) + (col - 1)] = Trees[(row * NColsPlusBounds) + col] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(col)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/fire/2"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  N = arr_N[i];\n  int A[N];\n  int B[N];\n  int C[N];\n  fill_arr(A, N);\n  sleep(1);\n  fill_arr(B, N);\n  sleep(1);\n  fill_arr(C, N);\n  printf(\"%d\\t\", N);\n  semaphore(A, B, C, N, 1);\n  semaphore(A, B, C, N, -1);\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DariaVoo/OpenMP_MPI/OpenMP/lab6/1"}
{"code": "for (unsigned int idx = 0; idx < parameter.size(); idx++)\n  if ((((a == parameter[idx].a) && (b == parameter[idx].b)) && (c == parameter[idx].c)) || (((a == parameter[idx].c) && (b == parameter[idx].b)) && (c == parameter[idx].a)))\n{\n  par = &parameter[idx];\n  return par;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/34"}
{"code": "for (int i = 0; i < vec.size(); i++)\n{\n  hi[i] = vec[i].x[0];\n  lo[i] = vec[i].x[1];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/basic_op/vector_copy/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  e_xx += clusterWeightInternal[i];\n  a2_x += cInfo[i].degree * cInfo[i].degree;\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/parallelLouvainMethod/0"}
{"code": "for (int j = 0; j < numParticles; j++)\n{\n  particles[j]->body.move(DELTA);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jdn5126/BarnesHutSimulation/src/barnesHutParallel/1"}
{"code": "for (long pidx_darts_counter_temp863 = *pidx; (pidx_darts_counter_temp863 < endRange) && (pidx_darts_counter_temp863 < this->inputsTPParent->lastIteration863); pidx_darts_counter_temp863++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp863], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/28"}
{"code": "for (int i = 0; i < MAT_ROWS; i += tileSize)\n{\n  for (int j = 0; j < MAT_COLS; j += tileSize)\n  {\n    for (int k = 0; k < MAT_ROWS; k += tileSize)\n    {\n      for (int x = i; x < min(i + tileSize, MAT_ROWS); x++)\n      {\n        for (int y = j; y < min(j + tileSize, MAT_COLS); y++)\n        {\n          for (int z = k; z < min(k + tileSize, MAT_ROWS); z++)\n          {\n            result[(x * MAT_COLS) + y] += mA[(x * MAT_COLS) + z] * mB[z + (MAT_COLS * y)];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/psattiza/matrixMult/main/3"}
{"code": "for (unsigned i = 0; i < ((unsigned) n_ranks); ++i)\n{\n  if (counts[i] > 0)\n  {\n    ++n_packed_messages;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eth-cscs/COSTA/src/costa/grid2grid/communication_data/0"}
{"code": "for (int ix = 0; ix < columns; ix++)\n{\n  vector[ix] = (rand() % 21) - 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/farit2000/OpenMP_tests/tasks/9/0"}
{"code": "for (int i = 0; i < ArraySize; ++i)\n  shared_min_array[i] = A[i][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Smirnov-Mikhail/OpenMP/Task4/Task4/Task4/1"}
{"code": "for (i = 0; i < (batch * N); i++)\n{\n  if (output[i] <= 0)\n    delta[i] = 0;\n\n}\n\n", "pragma": "#pragma omp parallel for shared(output,delta)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-cpu/8"}
{"code": "for (int i = 0; i < dim->rows; i++)\n  grid->cells[i] = (char *) malloc(dim->columns * (sizeof(char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    if (i == j)\n    mat[i][j] = 0;\n  else\n  {\n    if ((((i == (j + 1)) || (j == (i + 1))) || ((i == 0) && (j == (n - 1)))) || ((i == (n - 1)) && (j == 0)))\n      mat[i][j] = 1;\n    else\n      mat[i][j] = n;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Floyd Warshall/OpenMp/2"}
{"code": "for (int i = 0; i < L->n; i++)\n{\n  for (int j = 0; j < L->m; j++)\n  {\n    LSum->data[i] += fabs(L->data[(i * L->m) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joelchaconcastillo/SolverMontecarlo_MAO/SolverSistemaEcuacionesOpenMP/MonteCarlo/2"}
{"code": "for (int i = 0; i < (number_of_processes - 1); i++)\n{\n  sendcounts[i] = (i < n_resto) ? (n_local + 1) : (n_local);\n  displs[i + 1] = displs[i] + sendcounts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Hybrid/dotprod_OMPI/2"}
{"code": "for (m = 1; m <= nnnnn; m++)\n{\n  k = ((int) ((m - 1) / nnn)) + 1;\n  j = ((int) (((m - 1) - ((k - 1) * nnn)) / (n1 - 2))) + 1;\n  i = (m - ((j - 1) * (n1 - 2))) - ((k - 1) * nnn);\n  m = (i + ((j - 1) * (n1 - 2))) + ((k - 1) * nnn);\n  qq[m - 1] = vv[i][j][k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Prolongation/1"}
{"code": "for (int j = 0; j < NUMHID; j++)\n{\n  for (int k = 0; k < NUMOUT; k++)\n  {\n    SumDOW += WeightHO[k][j] * DeltaO[k];\n  }\n\n  DeltaH[j] = (SumDOW * Hidden[j]) * (1.0 - Hidden[j]);\n  for (int i = 0; i < NUMIN; i++)\n    DeltaWeightIH[j][i] = ((eta * tSet[p][i]) * DeltaH[j]) + (alpha * DeltaWeightIH[j][i]);\n\n  SumDOW = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Raptorino/NeuralNetworkMIMD/Code_OpenMP/nn-main/3"}
{"code": "for (int j = 0; j < 5; j++)\n{\n  printf(\"%d \\t\", vect2[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP1EX3/4"}
{"code": "for (i = 0; i < DATA_SIZE; i++)\n{\n  if (data[i] < minimumElement)\n  {\n    minimumElement = data[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(min:minimumElement) default(none) shared(DATA_SIZE, data) num_threads(TOTAL_THREADS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/0"}
{"code": "for (k = current_row; k < 4; k++)\n{\n  row_array[k] = row_array[k] - (value * send_row[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  processor *p = processors + i;\n  int yes = 0;\n  int no = 0;\n  while (!is_ql_queue_empty(vote_ql, i))\n  {\n    vote *v = dequeue(vote_ql, i);\n    if (v->vote)\n      yes++;\n    else\n      no++;\n\n  }\n\n  int maj = 1;\n  int tally = yes;\n  if (no > yes)\n  {\n    maj = 0;\n    tally = no;\n  }\n\n  int threshold;\n  if ((rand() % 2) == 0)\n    threshold = ((5 * N) / 8) + 1;\n  else\n    threshold = ((3 * N) / 4) + 1;\n\n  if (tally > threshold)\n    p->vote = maj;\n  else\n    p->vote = 0;\n\n  if (tally >= ((7 * N) / 8))\n  {\n    p->decided = 1;\n    p->d = maj;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/byzantine/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/98"}
{"code": "for (i = 0; i < size; ++i, ptr1 += size)\n{\n  array1[i] = malloc((size * size) * (sizeof(int)));\n  if (array1[i] == 0)\n  {\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/almazhankapan/game-of-life/game_of_life/1"}
{"code": "for (size_t l_va = 0; l_va < i_nVals; l_va++)\n  if (l_bidsOut[l_va] != g_rank)\n  o_min[l_va] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/parallel/Distributed/6"}
{"code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  for (jj = 0; jj < 3; jj++)\n  {\n    t1 = f[jj + l1];\n    f[jj + l1] = 0.5 * (cimagf(f[jj + ll] + t1) + (crealf(f[jj + ll] - t1) * _Complex_I));\n    f[jj + ll] = 0.5 * (crealf(f[jj + ll] + t1) + (cimagf(f[jj + ll] - t1) * _Complex_I));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/62"}
{"code": "for (j = 0; j < nelements; j++)\n  clusterid[j] = j;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/85"}
{"code": "for (i = 0; i < (H - 1); i++)\n{\n  for (j = 1; j < (W - 1); j++)\n  {\n    if (I[(i * W) + j] == 0)\n    {\n      chan1to0[(i * W) + j] = 0;\n      continue;\n    }\n\n    total = 0;\n    ans = 0;\n    chan1to0[(i * W) + j] = 0;\n    for (k = 0; k < 8; k++)\n    {\n      total += getNeighbor(i, j, k);\n    }\n\n    for (k = 0; k < 7; k++)\n    {\n      if ((getNeighbor(i, j, k) == 0) && (getNeighbor(i, j, k + 1) == 1))\n        ans += 1;\n\n    }\n\n    if ((getNeighbor(i, j, 7) == 0) && (getNeighbor(i, j, 0) == 1))\n      ans += 1;\n\n    if (((((((it % 2) == 0) && (total >= 2)) && (total <= 6)) && (ans == 1)) && (((getNeighbor(i, j, 0) * getNeighbor(i, j, 2)) * getNeighbor(i, j, 4)) == 0)) && (((getNeighbor(i, j, 0) * getNeighbor(i, j, 2)) * getNeighbor(i, j, 6)) == 0))\n    {\n      chan1to0[(i * W) + j] = 1;\n      flag1 = 1;\n    }\n\n    if (((((((it % 2) != 0) && (total >= 2)) && (total <= 6)) && (ans == 1)) && (((getNeighbor(i, j, 0) * getNeighbor(i, j, 4)) * getNeighbor(i, j, 6)) == 0)) && (((getNeighbor(i, j, 2) * getNeighbor(i, j, 4)) * getNeighbor(i, j, 6)) == 0))\n    {\n      chan1to0[(i * W) + j] = 1;\n      flag0 = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for private(i, j, k, ans, total) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filipe3x/esqueletizacao_openmp/skeletonize/2"}
{"code": "for (int o = 0; o < num_t; o++)\n{\n  if (1)\n    printf(\"OMP num threads : %d\\n\", omp_get_num_threads());\n\n  base = 6 * o;\n  printf(\"Base is %d\\n\", base);\n  for (int i = 6 - 1; i > 1; i--)\n  {\n    for (int j = 0; j <= (i - 1); j++)\n    {\n      if (((j + base) + 1) >= 10)\n        break;\n\n      if (tab[(j + base) + 1] < tab[j + base])\n      {\n        int t = tab[(j + base) + 1];\n        tab[(j + base) + 1] = tab[j + base];\n        tab[j + base] = t;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(base)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/tris/bulle-omp/0"}
{"code": "for (i = 0; i < 100; i++)\n  x = i;\n\n", "pragma": "omp parallel for private (i) lastprivate (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/lastprivate-orig-no/0"}
{"code": "for (i = 1; i < (30 - 1); i++)\n{\n  for (j = 1; j < (30 - 1); j++)\n  {\n    int thread = calc_thread(30, 30, i, j);\n    printf(\"%d L: %p\\n\", thread, &mean);\n    printf(\"%d S: %p\\n\", thread, &w[i][j]);\n    w[i][j] = mean;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/6"}
{"code": "for (int i = 0; i < (total_threads + 1); i++)\n{\n  offset += aux_arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarshiniKoduru/OpenMp/prefixsum/prefixsum/0"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_updating_graph_mask_gpu[tid] == 1)\n  {\n    h_graph_mask_gpu[tid] = 1;\n    h_graph_visited_gpu[tid] = 1;\n    stop = 1;\n    h_updating_graph_mask_gpu[tid] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/bfs/src/bfs-AI-AI/5"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      frct[i][j][k][m] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/10"}
{"code": "for (int j = 0; j < 3; j++)\n{\n  vecColor[j] = (rand() % 255) + j;\n}\n\n", "pragma": "             #pragma omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lancelof2019/Watershed-OpenMP/Watershed_Algorithm/functionspace/watershed/watershed/0"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  communicate(pathArr, start, end);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/5"}
{"code": "for (i = 0; i < result->m; i++)\n{\n  for (j = 0; j < result->n; j++)\n  {\n    if (sqrt((float) (((i - radius) * (i - radius)) + ((j - radius) * (j - radius)))) <= radius)\n      m_set_val(result, i, j, 1.0);\n    else\n      m_set_val(result, i, j, 0.0);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/6"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float nodeIncomingPR = 0.0f;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    u = Nodes->dest;\n    Nodes = Nodes->next;\n    nodeIncomingPR += riDividedOnDiClause[u];\n  }\n\n  pageRanksNext[v] = nodeIncomingPR;\n}\n\n", "pragma": "omp parallel for reduction(+ : error_total,activeVertices) private(v,j,u,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/37"}
{"code": "for (int i = 0; i < (size - 1); i += 2)\n{\n  result += array[i] - array[i + 1];\n}\n\n", "pragma": "  #pragma omp parallel for shared(array) reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IlyaCES/openmp_openmpi_labs/6/lab6/0"}
{"code": "for (i = 0; i < n3local; i++)\n{\n  const double vx = 0.5 * (v[i] + vold[i]);\n  t += vx * vx;\n}\n\n", "pragma": "#pragma omp parallel for private(i) default(none) reduction(+:t)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apawloski/miniMD-omp/thermo/2"}
{"code": "for (lev = 1; lev < (p.Lmax + 1); lev++)\n{\n  p.size[lev] = p.size[lev - 1] / 2;\n  p.a[lev] = 2.0 * p.a[lev - 1];\n  p.scale[lev] = 1.0 / (4.0 + (p.m * p.m));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/7"}
{"code": "for (int i = 0; i < chromo_length; i++)\n  Chro->genes[i] = 0;\n\n", "pragma": "omp parallel for num_threads(NUM_THRDS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/5"}
{"code": "for (m = 0; m < BLOCK_SIZE; m++)\n{\n  for (n = 0; n < BLOCK_SIZE; n++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][CC][m][n] * rhs[i + 1][j][k][n]);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(m ,k ,n ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/133"}
{"code": "for (int i = 0; i < N; i++)\n  b[i] = computeVal(i);\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture6/Single_construct/Single_construct/0"}
{"code": "for (u = 0; u < stats->num_vertices; u++)\n{\n  counts += stats->counts[u];\n}\n\n", "pragma": "omp parallel for default(none) reduction (+ : counts) private(u) shared(stats)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/triangleCount/2"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  temp1 = inText[i * 4] ^ zero;\n  temp2 = inText[(i * 4) + 1] ^ zero;\n  temp3 = inText[(i * 4) + 2] ^ zero;\n  temp4 = inText[(i * 4) + 3] ^ zero;\n  switch (i)\n  {\n    case 1:\n      inText[4] = temp4 ^ zero;\n      inText[5] = temp1 ^ zero;\n      inText[6] = temp2 ^ zero;\n      inText[7] = temp3 ^ zero;\n      break;\n\n    case 2:\n      inText[8] = temp3 ^ zero;\n      inText[9] = temp4 ^ zero;\n      inText[10] = temp1 ^ zero;\n      inText[11] = temp2 ^ zero;\n      break;\n\n    case 3:\n      inText[12] = temp2 ^ zero;\n      inText[13] = temp3 ^ zero;\n      inText[14] = temp4 ^ zero;\n      inText[15] = temp1 ^ zero;\n      break;\n\n    default:\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/9"}
{"code": "for (unsigned int y = 0; y < height; y++)\n{\n  double realValue = upperLeftX;\n  for (unsigned int x = 0; x < width; x++)\n  {\n    escapeCounts[(y * width) + x] = isMandelbrotNumber(realValue, imaginaryValue, numberOfIterations);\n    realValue += incrementX;\n  }\n\n  imaginaryValue -= incrementY;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Balta-Stefan/Mandelbrot-viewer/src/MandelbrotCalculatorOLD/2"}
{"code": "for (int i = 0; i < imageHeight; i++)\n{\n  fout << output[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /Mandelbrot/for/0"}
{"code": "for (int dy = y_start; dy < y_end; dy++)\n{\n  for (int dx = x_start; dx < x_end; dx++)\n  {\n    int idx = get_pidx(dy, dx, width);\n    if ((map[idx].x < 0) || (map[idx].x >= width))\n    {\n      (((((((cout << \"Bad X position \") << map[idx].x) << \" at (\") << dx) << \", \") << dy) << \")\") << endl;\n    }\n    else\n      if ((map[idx].y < 0) || (map[idx].y >= height))\n    {\n      (((((((cout << \"Bad Y position \") << map[idx].y) << \" at (\") << dx) << \", \") << dy) << \")\") << endl;\n    }\n    else\n    {\n      int midx = get_pidx(map[idx].y, map[idx].x, width);\n      dst[(idx * N_CHANNELS) + 0] = src[(midx * N_CHANNELS) + 0];\n      dst[(idx * N_CHANNELS) + 1] = src[(midx * N_CHANNELS) + 1];\n      dst[(idx * N_CHANNELS) + 2] = src[(midx * N_CHANNELS) + 2];\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/patchmatch/omp/patchmatch/5"}
{"code": "for (j = 0; j < ((1 * 1024) / 256); j++)\n{\n  printf(\"%g\", B[j * ((1 * 1024) / 256)]);\n  for (k = 1; k < ((1 * 1024) / 256); k++)\n  {\n    printf(\" %g\", B[(j * ((1 * 1024) / 256)) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Matrix_Multiplication_Parallel_Processing_OpenMP_OpenACC/Exploring_OpenMP/matmul/5"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    u[i][j] = ((1.0 - omega) * u[i][j]) + ((omega * ((((u[i - 1][j] + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]) + (h2 * f[i][j]))) / 4.0);\n    resid = u[i][j] - uold[i][j];\n    error += resid * resid;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:error) private(i, j, resid) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thiagowfx/coc-472-CAD/T2/ex1/jacobi/5"}
{"code": "for (int j = 0; j < i; j++)\n{\n  if (g)\n    g = g->next;\n  else\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zcl2016/Gazebo-exercise/gazebo7_7.14.0_exercise/deps/opende/src/collision_space/2"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n  sync.fixes[i] = 0;\n\n", "pragma": "#pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/mesh/17"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (i = ist; i <= iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n      }\n\n    }\n\n    L2 = nx - 1;\n    for (i = ist; i <= L2; i++)\n    {\n      tmp = 1.0 / u[i][j][k][0];\n      u21i = tmp * u[i][j][k][1];\n      u31i = tmp * u[i][j][k][2];\n      u41i = tmp * u[i][j][k][3];\n      u51i = tmp * u[i][j][k][4];\n      tmp = 1.0 / u[i - 1][j][k][0];\n      u21im1 = tmp * u[i - 1][j][k][1];\n      u31im1 = tmp * u[i - 1][j][k][2];\n      u41im1 = tmp * u[i - 1][j][k][3];\n      u51im1 = tmp * u[i - 1][j][k][4];\n      flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][j][k][2] = tx3 * (u31i - u31im1);\n      flux[i][j][k][3] = tx3 * (u41i - u41im1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * (((pow2(u21i) + pow2(u31i)) + pow2(u41i)) - ((pow2(u21im1) + pow2(u31im1)) + pow2(u41im1)))) + (((1.0 / 6.0) * tx3) * (pow2(u21i) - pow2(u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i <= iend; i++)\n    {\n      rsd[i][j][k][0] = rsd[i][j][k][0] + ((dx1 * tx1) * ((u[i - 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i + 1][j][k][0]));\n      rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((u[i - 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i + 1][j][k][1]));\n      rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((u[i - 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i + 1][j][k][2]));\n      rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((u[i - 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i + 1][j][k][3]));\n      rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((u[i - 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i + 1][j][k][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[1][j][k][m] = rsd[1][j][k][m] - (dssp * ((((+5.0) * u[1][j][k][m]) - (4.0 * u[2][j][k][m])) + u[3][j][k][m]));\n      rsd[2][j][k][m] = rsd[2][j][k][m] - (dssp * (((((-4.0) * u[1][j][k][m]) + (6.0 * u[2][j][k][m])) - (4.0 * u[3][j][k][m])) + u[4][j][k][m]));\n    }\n\n    ist1 = 3;\n    iend1 = nx - 4;\n    for (i = ist1; i <= iend1; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[nx - 3][j][k][m] = rsd[nx - 3][j][k][m] - (dssp * (((u[nx - 5][j][k][m] - (4.0 * u[nx - 4][j][k][m])) + (6.0 * u[nx - 3][j][k][m])) - (4.0 * u[nx - 2][j][k][m])));\n      rsd[nx - 2][j][k][m] = rsd[nx - 2][j][k][m] - (dssp * ((u[nx - 4][j][k][m] - (4.0 * u[nx - 3][j][k][m])) + (5.0 * u[nx - 2][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/68"}
{"code": "for (int k = 0; k < num_clusters; ++k)\n{\n  sum_of_x_per_cluster[k] = 0.0;\n  sum_of_y_per_cluster[k] = 0.0;\n  num_points_in_cluster[k] = 0;\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/1"}
{"code": "for (i = 0; i < nc; i += 4)\n{\n  *nrm += x[i] * x[i];\n  *nrm += x[i + 1] * x[i + 1];\n  *nrm += x[i + 2] * x[i + 2];\n  *nrm += x[i + 3] * x[i + 3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/3"}
{"code": "for (long i = 0; i < 10; i++)\n  result++;\n\n", "pragma": "omp for schedule(dynamic,1) reduction(+: result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dave96/libminiomp/test/tworkshare/0"}
{"code": "for (size_t i = 0; i < count; ++i)\n{\n  a[i] = b[i] + (c[i] * d);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_openmp/3"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = (float) strtod(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->fvsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->ivsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = strtof(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/17"}
{"code": "for (i = 0; i < C; i++)\n{\n  E[i] = (double *) malloc(C * (sizeof(double)));\n  if (E[i] == 0)\n  {\n    fprintf(stderr, \"Malloc error.\\n\");\n    return 4;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artem-bondar/parallel-programming/sor_2d_omp/3"}
{"code": "for (int i = 0; i < n_layers; i++)\n{\n  layer[i] = strtol(argv[i + 2], NULL, 10);\n  if (DBG)\n    ((((cout << endl) << \"layer[\") << i) << \"] = \") << layer[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ichaparroc/MLP-PARALLEL/main-openmp-batch/1"}
{"code": "for (i = 0; i < 2; ++i)\n  for (j = 0; j < 2; ++j)\n  for (k = 1; k < 3; ++k)\n{\n  newx = x + (k * ((i * 2) - 1));\n  newy = y + ((k - 3) * ((j * 2) - 1));\n  if ((((newx >= 0) && (newx < 6)) && (newy >= 0)) && (newy < 6))\n  {\n    if (board[newx][newy] <= 0)\n    {\n      move(board, newx, newy, move_num + 1);\n      board[newx][newy] = 0;\n    }\n\n  }\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/1"}
{"code": "for (currentColumn = 1; currentColumn < (subProblemSize[1] + 1); ++currentColumn)\n{\n  splitter[0][tempCounter] = 1;\n  splitter[1][tempCounter++] = currentColumn;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/7"}
{"code": "for (int i = 0; i < (this->nrow_ + 1); ++i)\n{\n  this->mat_.row_offset[i] = row_offsets[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/1"}
{"code": "for (int i = 0; i < len; ++i)\n  gpuData[2] = max(gpuData[2], (T) i);\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256) reduction(max: gpuData[2])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/atomicIntrinsics-omp/main/0"}
{"code": "for (int x = x_m; x <= (x_M / balance_factor); x++)\n{\n  for (int y = y_m; y < y_M; y++)\n  {\n    float r0 = vp[(x * size_u[0]) + y] * vp[(x * size_u[0]) + y];\n    ut1[(x * size_u[0]) + y] = ((((((-3.99999982e-2F) * r0) * r1) * ut0[(x * size_u[0]) + y]) + (9.99999955e-3F * (((((r0 * r1) * ut0[((x * size_u[0]) - 1) + y]) + ((r0 * r1) * ut0[((x - 1) * size_u[0]) + y])) + ((r0 * r1) * ut0[((x + 1) * size_u[0]) + y])) + ((r0 * r1) * ut0[((x * size_u[0]) + 1) + y])))) + (1.99999991F * ut0[(x * size_u[0]) + y])) - (9.99999955e-1F * ut2[(x * size_u[0]) + y]);\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation/0"}
{"code": "for (y = 0; y < rh; y++)\n{\n  d = w * y;\n  for (x = 0; x < rw; x++)\n  {\n    aux = a1[d + x];\n    a1[d + x] = a2[d + x];\n    a2[d + x] = aux;\n  }\n\n}\n\n", "pragma": "omp parallel for private (d, x, aux) schedule (runtime)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PelaezLink/OpenMP_MPI/prac2/restore1/1"}
{"code": "for (int i = 0; i < n_thr; i++)\n  pool_size += pool_new[i].size();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AGorchakov/BNB_test_prelimited/bnb_test_prelim/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  _taskFunc0_((void *) 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/nqueens/src/nqueens_ompi_trim/0"}
{"code": "for (i2 = 0; i2 < l->ny; i2++)\n{\n  for (i1 = 0; i1 < l->nx; i1++)\n  {\n    fprintf(f, \"%d\\n\", l->u0[((i1 + l->nx) % l->nx) + (((i2 + l->ny) % l->ny) * l->nx)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leonshting/mipt-openmp-mpi/openmp-mpi/11/life2d/1"}
{"code": "for (int i = 0; i < CITIES; i++)\n{\n  if (arr[i] == val)\n  {\n    pos = i;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for default( none ) shared( arr,pos,val)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeffyjahfar/TSP_GeneticAlgorithm_openMP/EvalXOverMutate/2"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < cols; j++)\n{\n  if (mapa[(i * cols) + j] > maximo)\n  {\n    maximo = mapa[(i * cols) + j];\n    registros[omp_get_thread_num()].x = i;\n    registros[omp_get_thread_num()].y = j;\n    registros[omp_get_thread_num()].valor = mapa[(i * cols) + j];\n  }\n\n}\n\n\n", "pragma": "omp parallel for shared(mapa,registros) firstprivate(maximo) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas4.6/0"}
{"code": "for (long i = 0; i < N2; i++)\n{\n  long tc = (long) C2[i];\n  if (!isZero2)\n    tc--;\n\n  long Where = commPtr2[tc] + __sync_fetch_and_add(&commAdded2[tc], 1);\n  commIndex2[Where] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/13"}
{"code": "for (i = 1; i < n; i++)\n{\n  if (data[i] < data[i - 1])\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/mainK/5"}
{"code": "for (j1 = 1; j1 < 4096; j1++)\n{\n  symmat[(j1 * (4096 + 1)) + j1] = 1.0;\n  for (j2 = j1 + 1; j2 < (4096 + 1); j2++)\n  {\n    symmat[(j1 * (4096 + 1)) + j2] = 0.0;\n    for (i = 1; i < (4096 + 1); i++)\n    {\n      symmat[(j1 * (4096 + 1)) + j2] += data[(i * (4096 + 1)) + j1] * data[(i * (4096 + 1)) + j2];\n    }\n\n    symmat[(j2 * (4096 + 1)) + j1] = symmat[(j1 * (4096 + 1)) + j2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/8"}
{"code": "for (j = 0; j < n; j++)\n{\n  u[0][j] = 0.0;\n  u[m - 1][j] = 100.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/InitGrid/1"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  double m = distribution(generator);\n  double n = distribution(generator);\n  if (n < cos((m * M_PI) - (M_PI / 2)))\n  {\n    count = count + 1;\n  }\n\n  threads = omp_get_num_threads();\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aayush-patel-1696/High-Performance-Computing/Numerical Integration using OpenMp/monte_carlo_parallel/0"}
{"code": "for (size_t i = 0; i < AllBoids.size(); i++)\n{\n  AllBoids[i]->Act(Params.DeltaTime);\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/5"}
{"code": "for (int i = 0; i < height; ++i)\n{\n  for (int j = 0; j < width; ++j)\n  {\n    if (a[i][j])\n    {\n      (((out << (i + 1)) << ' ') << (j + 1)) << '\\n';\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexSofienko/Game_of_life/life_modulator/4"}
{"code": "for (i = 0; i < a; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    temp = 0;\n    for (k = 0; k < b; k++)\n    {\n      temp += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/17"}
{"code": "for (i = n / 2; i <= n; i++)\n{\n  x = h * (((double) i) - 0.5);\n  area += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/pi2/2"}
{"code": "for (int ii = 0; ii < (num_test * 10); ii++)\n{\n  t0 = clock();\n  index.knnSearch(mesh.vert[test_indeces[ii]].P().V(), kNearest, &ret_index[0], &out_dist_sqr[0]);\n  avgTime += elapsed(t0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dfsp-spirit/cpp_geodesics/third_party/vcglib/apps/sample/trimesh_indexing/trimesh_indexing/3"}
{"code": "for (k = 0; k < size; k++)\n{\n  sum += buffer[k];\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanafacion/Paralelas/Exercicio2/prod_cons/0"}
{"code": "for (int i = block * blockSize; i < ((block * blockSize) + blockSize); i++)\n{\n  array[i] = blockArray[i - (block * blockSize)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shay9000/Genetic-Algorithm-Sudoku-Solver/src/genetic/7"}
{"code": "for (int j = IdThread * SizeStream; j < Streams->data[IdThread]; j++)\n{\n  ptrHybridTaus HyT = (ptrHybridTaus) malloc(sizeof(HybridTaus));\n  HyT->z1 = 2 * omp_get_thread_num();\n  HyT->z2 = 3 * omp_get_thread_num();\n  HyT->z3 = 4 * omp_get_thread_num();\n  HyT->z4 = 5 * omp_get_thread_num();\n  double Xm = 0;\n  for (int i = 0; i < L->n; i++)\n  {\n    Xm += GetTrajectory(L, LSum, F, P, j, Tolerancia, HyT);\n  }\n\n  X->data[j] = Xm / L->n;\n  free(HyT);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joelchaconcastillo/SolverMontecarlo_MAO/SolverSistemaEcuacionesOpenMP/MonteCarlo/7"}
{"code": "for (unsigned int k = 0; k < mesh.voxels.size(); k++)\n{\n  for (unsigned int i = 0; i < number_of_densities(); i++)\n  {\n    gradient_vectors[k][i].resize(3, 0.0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/19"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  wijk = ws[i][j][k];\n  wp1 = ws[i][j][k + 1];\n  wm1 = ws[i][j][k - 1];\n  rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n  rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n  rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n  rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n  rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,wijk ,wp1 ,wm1 ,tz2 ,dz1tz1 ,zzcon2 ,dz2tz1 ,dz3tz1 ,c2 ,dz4tz1 ,con43 ,c1 ,zzcon5 ,zzcon3 ,dz5tz1 ,zzcon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/133"}
{"code": "for (i = 0; i < num; i++)\n  a[i] = (num * num) % 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/VectorDotProduct/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  v_it = _mm512_set1_epi32(k);\n  v_dky = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dky = _mm512_mul_ps(v_dny, v_dky);\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  dky2 = dky * dky;\n  v_dkyz2 = _mm512_mul_ps(v_dky, v_dky);\n  v_dk = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(3084), v_dky);\n  for (j = 0; j < nxhs; j += 2)\n  {\n    v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n    v_dkx = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dkx = _mm512_mul_ps(v_dnx, v_dkx);\n    v_at1 = _mm512_fmadd_ps(v_dkx, v_dkx, v_dkyz2);\n    v_at1 = _mm512_div_ps(v_one, v_at1);\n    v_dk = _mm512_mask_mov_ps(v_dk, _mm512_int2mask(771), v_dkx);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + kj)]));\n    v_zt1 = _mm512_mul_ps(v_dk, v_zt2);\n    v_at = (int) _mm512_shuffle_epi32((int) v_zt1, 78);\n    v_zt1 = _mm512_add_ps(v_at, v_zt1);\n    v_at = _mm512_permute4f128_ps(v_zt1, 177);\n    v_zt1 = _mm512_mul_ps(v_at1, _mm512_add_ps(v_at, v_zt1));\n    if (j == 0)\n    {\n      v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n    }\n\n    v_zt2 = _mm512_sub_ps(v_zt2, _mm512_mul_ps(v_dk, v_zt1));\n    _mm512_store_ps((float *) (&cu[4 * (j + kj)]), v_zt2);\n    v_zt2 = _mm512_load_ps((float *) (&cu[4 * (j + k1)]));\n    v_as = _mm512_mask_sub_ps(v_dk, _mm512_int2mask(3084), v_zero, v_dk);\n    v_zt1 = _mm512_mul_ps(v_as, v_zt2);\n    v_at = (int) _mm512_shuffle_epi32((int) v_zt1, 78);\n    v_zt1 = _mm512_add_ps(v_at, v_zt1);\n    v_at = _mm512_permute4f128_ps(v_zt1, 177);\n    v_zt1 = _mm512_mul_ps(v_at1, _mm512_add_ps(v_at, v_zt1));\n    if (j == 0)\n    {\n      v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n      ;\n    }\n\n    v_zt2 = _mm512_sub_ps(v_zt2, _mm512_mul_ps(v_as, v_zt1));\n    _mm512_store_ps((float *) (&cu[4 * (j + k1)]), v_zt2);\n    _mm512_store_ps((float *) (&cu[4 * ((j + kj) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&cu[4 * ((j + k1) + l1)]), v_zero);\n  }\n\n  for (j = itn; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1.0 / ((dkx * dkx) + dky2);\n    zt1 = at1 * ((dkx * cu[4 * (j + kj)]) + (dky * cu[1 + (4 * (j + kj))]));\n    cu[4 * (j + kj)] -= dkx * zt1;\n    cu[1 + (4 * (j + kj))] -= dky * zt1;\n    zt1 = at1 * ((dkx * cu[4 * (j + k1)]) - (dky * cu[1 + (4 * (j + k1))]));\n    cu[4 * (j + k1)] -= dkx * zt1;\n    cu[1 + (4 * (j + k1))] += dky * zt1;\n    cu[4 * ((j + kj) + l1)] = zero;\n    cu[1 + (4 * ((j + kj) + l1))] = zero;\n    cu[2 + (4 * ((j + kj) + l1))] = zero;\n    cu[4 * ((j + k1) + l1)] = zero;\n    cu[1 + (4 * ((j + k1) + l1))] = zero;\n    cu[2 + (4 * ((j + k1) + l1))] = zero;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kj,dky,dky2,dkx,at1,zt1,v_it,v_dk,v_dkx,v_dky,v_dkyz2, v_at1,v_zt1,v_zt2,v_at,v_as)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/18"}
{"code": "for (i = 0; i < thread_lg; i++)\n  bidx[i] = (i * ((int) num)) / thread_lg;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jk443/pqsort/pqsort/pqsort/2"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  if (num_vectors == 1)\n  {\n    temp = y_data[i];\n    for (jj = A_i[i]; jj < A_i[i + 1]; jj++)\n      temp += A_data[jj] * x_data[A_j[jj]];\n\n    y_data[i] = temp;\n  }\n  else\n    for (j = 0; j < num_vectors; ++j)\n  {\n    temp = y_data[(j * vecstride_y) + (i * idxstride_y)];\n    for (jj = A_i[i]; jj < A_i[i + 1]; jj++)\n    {\n      temp += A_data[jj] * x_data[(j * vecstride_x) + (A_j[jj] * idxstride_x)];\n    }\n\n    y_data[(j * vecstride_y) + (i * idxstride_y)] = temp;\n  }\n\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,jj,temp) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/4"}
{"code": "for (int i = 0; i < (size + 1); i++)\n{\n  if (i >= size)\n  {\n    palette[i] = (Color){.r = 0, .g = 0, .b = 0};\n    continue;\n  }\n\n  double j;\n  if (i == 0)\n  {\n    j = 3.0;\n  }\n  else\n  {\n    j = 3.0 * (log(i) / log(size - 1.0));\n  }\n\n  if (j < 1)\n  {\n    palette[i] = (Color){.r = 0, .g = 255 * j, .b = 0};\n  }\n  else\n    if (j < 2)\n  {\n    palette[i] = (Color){.r = 255 * (j - 1), .g = 255, .b = 0};\n  }\n  else\n  {\n    palette[i] = (Color){.r = 255 * (j - 2), .g = 255, .b = 255};\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abagali1/mandelbrot/parallel/mandelbrot_cuda/2"}
{"code": "for (int i = 0; i < NUM_OF_SECTORS; i++)\n{\n  for (int j = 0; j < SPEED_BUCKETS; j++)\n  {\n    (cout << wr[i][j]) << \"\\t\";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/WindRosePOC/src_MPI/MP+MPI/1"}
{"code": "for (k = 0; k < 1000; k++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    for (i = 0; i < 1000; i++)\n    {\n      mresult[i][j] = mresult[i][j] + (matrixa[i][k] * matrixb[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,i) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Willster419/parallel_computing_uac/PAC2/counters2omp/0"}
{"code": "for (j = 1; j < numOfProcs; j++)\n{\n  MPI_Recv(bufferClusters, numOfClusters, ClusterMPIType, j, 0, MPI_COMM_WORLD, &status);\n  for (int k = 0; k < numOfClusters; k++)\n  {\n    allClusters[k].clusterSize += bufferClusters[k].clusterSize;\n    allClusters[k].x += bufferClusters[k].x;\n    allClusters[k].x /= 2;\n    allClusters[k].y += bufferClusters[k].y;\n    allClusters[k].y /= 2;\n    allClusters[k].z += bufferClusters[k].z;\n    allClusters[k].z /= 2;\n    if (allClusters[k].diameter < bufferClusters[k].diameter)\n    {\n      allClusters[k].diameter = bufferClusters[k].diameter;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/1"}
{"code": "for (int i = nbthreads * granularity; i < n; i++)\n{\n  pr[i + 1] = pr[i + 1] + prefix[nbthreads - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkalyanpurr/openMP/prefixsum/prefixsum/4"}
{"code": "for (i = 1; i < (128 - 1); ++i)\n{\n  for (j = 1; j < (128 - 1); ++j)\n  {\n    for (k = 1; k < (128 - 1); ++k)\n    {\n      if (percentDiff(B[((i * (128 * 128)) + (j * 128)) + k], B_GPU[((i * (128 * 128)) + (j * 128)) + k]) > 0.5)\n      {\n        fail++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3DCONV/3DConvolution/8"}
{"code": "for (unsigned int i = 0; i < v.size(); i++)\n{\n  m_particles[i].node = v[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/gmapping/gridfastslam/gridslamprocessor/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  ah[i] += (b[i] + (k * c[i])) + (l * z[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-target-nowait-dep-implicit/test/2"}
{"code": "for (k = 1; k <= n; k++)\n{\n  temp = k - 1;\n  scanf(\"%lld %lld\", &xk, &yk);\n  matrices[temp].n = xk;\n  p[temp] = xk;\n  p[k] = yk;\n  matrices[temp].m = yk;\n  matrices[temp].matrix = (long long int *) malloc((xk * yk) * (sizeof(long long int)));\n  for (i = 0; i < xk; i++)\n    for (j = 0; j < yk; j++)\n    scanf(\"%lld\", (matrices[temp].matrix + (i * yk)) + j);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunth2001/Software-Programming-for-Performance/Assignment2/Submission/q1/4"}
{"code": "for (unsigned int i = 0; i < 1; i++)\n{\n  sample(whites, blacks, stat);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/27"}
{"code": "for (int i = -1; i <= 1; i++)\n{\n  for (int j = -1; j <= 1; j++)\n  {\n    if ((i == 0) && (j == 0))\n    {\n      continue;\n    }\n\n    int coords[2];\n    coords[0] = my_coordinates[0] + i;\n    coords[1] = my_coordinates[1] + j;\n    MPI_Cart_rank(cart_comm, coords, &adjacent_processes_rank[counter]);\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/1"}
{"code": "for (i = 0; i < size; i++)\n  sum += (x_new[i] - x_old[i]) * (x_new[i] - x_old[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lnugraha/parallelized-sparse-iterative-solvers/new_omp_solvers/1"}
{"code": "for (i = 0; i < 1000000; ++i)\n{\n  if (isPrime(i))\n    l_Count++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/creativeyann17/Prime_C_JAVA/OpenMP/Prime/1"}
{"code": "for (i = 0; i < 73; i++)\n{\n  if (l == (-1))\n  {\n    n = 1;\n    c++;\n  }\n  else\n    if (l == (i - 1))\n    n++;\n  else\n  {\n    if (l >= i)\n      abort();\n\n    if (n < 7)\n      abort();\n\n    n = 1;\n    c++;\n  }\n\n\n  l = i;\n}\n\n", "pragma": "omp for schedule (monotonic :guided , 7) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/monotonic-1/5"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_updating_graph_mask[tid] == 1)\n  {\n    h_graph_mask[tid] = 1;\n    h_graph_visited[tid] = 1;\n    stop = 1;\n    h_updating_graph_mask[tid] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bfs-omp/bfs/1"}
{"code": "for (u = 6; u > 0; u -= 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/20"}
{"code": "for (int n = 1; n <= N; n++)\n{\n  aux = ((1 / (n * pow(X, n))) * (1 / (1 + ((n * gama_w) * (n * gama_w))))) * (vex2_w + (n * gamavey_ww));\n  if ((n % 2) == 0)\n  {\n    aux = -aux;\n  }\n\n  sum += aux;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonedarts/rendezvous/openCL/rendezvous/rendezvous-opencl/1"}
{"code": "for (int i = 0; i < n; i++)\n  s[i] = false;\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/0"}
{"code": "for (int rblock = 0, col = 0; rblock < blocksperrow; rblock++, col += PixelsPerBlock)\n  decompressBlock(rowInput, row, col);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/PanasonicV6Decompressor/0"}
{"code": "for (int i = 0; i < count; i++)\n{\n  for (int thread = 1; thread < threads; thread++)\n  {\n    struct node *head = buckets[i];\n    while ((head != 0) && (head->next != 0))\n    {\n      head = head->next;\n    }\n\n    if (head != 0)\n    {\n      head->next = buckets[i + (thread * count)];\n    }\n    else\n    {\n      head = buckets[i + (thread * count)];\n      buckets[i] = head;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/mainB/2"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  init_array(X);\n  start = _rdtsc();\n  sequential_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X))\n  {\n    fprintf(stderr, \"ERROR: the array is not properly sorted\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/bubble/5"}
{"code": "for (i = 0; i < matrix->m; i++)\n{\n  for (j = 0; j < matrix->n; j++)\n  {\n    sum += m_get_val(matrix, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/leukocyte/OpenMP/track_ellipse.ref/4"}
{"code": "for (i = 0; i < STREAM_ARRAY_SIZE; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/26"}
{"code": "for (int j = 0; j < (length1 + 1); j++)\n{\n  index = j;\n  ScoringMatrix[index] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chrz95/OpenMP_Parallelism/main_OMP_Coarse/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double err = C[i + (j * N)] - Crecur[i + (j * N)];\n    err2 += err * err;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/openmp/matmat_recur/3"}
{"code": "for (k = 0; k <= 1; k++)\n{\n  start = getclock();\n  {\n    for (j = 0; j < innerreps; j++)\n    {\n      delay(delaylength);\n      OMPC_BARRIER(thread_id);\n    }\n\n  }\n  times[k] = ((getclock() - start) * 1.0e6) / ((double) innerreps);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/barrier/shannon_tour_on_shark/6"}
{"code": "for (int i = 0; i < MAX_ROWS; ++i)\n{\n  radixSort(_data[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/1"}
{"code": "for (i = 0; i < g.nvertices; ++i)\n  g.edges[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cathy272272272/Dijkstra/OpenMP/5"}
{"code": "for (j = 0; j < (1000 * 1000); j++)\n{\n  int x = j / 1000;\n  int y = j % 1000;\n  a[x][y] = j;\n  b[x][y] = 2 * j;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh2496/OpenMP-Programming-Problems/P4/p4/0"}
{"code": "for (int ii = 1; ii < (params.ny - 1); ++ii)\n{\n  sendbuf[(ii - 1) * 3] = cells[(ii * params.nx) + line].speeds[6];\n  sendbuf[((ii - 1) * 3) + 1] = cells[(ii * params.nx) + line].speeds[3];\n  sendbuf[((ii - 1) * 3) + 2] = cells[(ii * params.nx) + line].speeds[7];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/23"}
{"code": "for (i = a; i < n; i++)\n{\n  double current = fabs(getValueAtIJ(A, n, i + 1, a));\n  if (current > max)\n  {\n    row = i + 1;\n    max = current;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ktzsh/lu_decomposition/openmp/LUDecomp/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  visitNeighbours(graph, graph_lock, cube_size, update, &list_lock, vector[i]->x, vector[i]->y, vector[i]->z);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/par_grid_list/par_grid_list/0"}
{"code": "for (numt = 1; numt <= size; numt++)\n{\n  omp_set_num_threads(numt);\n  setZero(C);\n  double r1 = mulGuided(A, B, C, (int) floor(((float) size) / numt));\n  double r2 = mulGuidedCol(A, B, C, (int) floor(((float) size) / numt));\n  (((((res << numt) << \",\") << r1) << \",\") << r2) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part1/Asgn12/0"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n{\n  a[(i * N) + j] = (i + j) + 1;\n  b[(i * N) + j] = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZeyuuOne/Lab_1_OpenMP/Lab_1_OpenMP/main/0"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  pongSendBuf[i] = pingRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(pongSendBuf,pingRecvBuf,dataSize,sizeofBuffer) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_multiPingpong/1"}
{"code": "for (int j = 0; j < N; j++)\n  matResult[j] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/3"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/96"}
{"code": "for (i = t; i >= 0; i--)\n  fprintf(out, \"%d\", ans[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/10"}
{"code": "for (p = 0; p < NUM_IONS; p++)\n{\n  double x = domain.x0 + (p * delta_ions);\n  double v = SampleVel(v_thi);\n  AddParticle(&ions, x, v);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sheath-omp/main/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  suma += numeros[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(n, numeros) private(i) reduction(+:suma)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_for_reduction/main/1"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  d = d + (p[j] * q[j]);\n}\n\n", "pragma": "\t\t#pragma omp for reduction(+:d)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/9"}
{"code": "for (i = 1; i <= n; i++)\n{\n  count = 0;\n  for (k = i - 1; k <= (i + 1); k++)\n  {\n    for (l = n - 1; l <= (n + 1); l++)\n    {\n      if ((k != i) || (l != n))\n      {\n        if (cur[k][l] == '1')\n        {\n          count++;\n        }\n\n      }\n\n    }\n\n  }\n\n  if ((count < 2) || (count > 3))\n  {\n    next[i][n] = '0';\n  }\n  else\n    if (count == 3)\n  {\n    next[i][n] = '1';\n  }\n  else\n    if (cur[i][n] == '1')\n  {\n    next[i][n] = '1';\n  }\n  else\n  {\n    next[i][n] = '0';\n  }\n\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dimitris-Mpou/Parallel-GOL/functions/2"}
{"code": "for (int j = 0; j < col; j++)\n  printf(\"j = %d: x = %lf y = %lf z = %lf\\n\", j + 1, obj[0][j], obj[1][j], obj[2][j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/swag2198/Parallel-Programming/OpenMP/Rotation about arbitrary axis/16EE10056_16EE10063/6"}
{"code": "for (int i = 0; i < cluster_amount; i++)\n{\n  points_element[i] = calloc(cluster_points_amount[i], size_of_element);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/28"}
{"code": "for (int i = 1; i < (nz - 1); i++)\n  vector[1][ny - 2][i] += vector[0][ny - 1][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/25"}
{"code": "for (int j = 0; j < m; j++)\n{\n  for (i = 0; i < p; i++)\n  {\n    float x = ((float) rand()) / 32767;\n    pA[j][i] = (x < 0.5) ? (-1) : (1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCMMA/8"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = bt * r1;\n      t2 = 0.5 * (r4 + r5);\n      rhs[0][i][j][k] = bt * (r4 - r5);\n      rhs[1][i][j][k] = -r3;\n      rhs[2][i][j][k] = r2;\n      rhs[3][i][j][k] = (-t1) + t2;\n      rhs[4][i][j][k] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/22"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (a[i] == value)\n    retval = 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1314E1/1/0"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  for (wJ = 0; wJ < BIGN_MATR; wJ++)\n  {\n    if (scanf(\"%f\", &aMatr[wI][wJ]) != 1)\n    {\n      fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d%d\\n\", wI, wJ);\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/11"}
{"code": "for (i = 0; i < 10; i++)\n  if (z[i].t != z2[i])\n  __builtin_abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-10/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\t\", arr[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RetinaInc/QuickSortParallelOpenMP/main/0"}
{"code": "for (int k = 0; k < cmb.size(); k++)\n{\n  mpz_invert(to_be_multiplied.get_mpz_t(), L[cmb[k]].get_mpz_t(), p.get_mpz_t());\n  prod *= to_be_multiplied;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vamartid/NSK-birthday-attack/parallel/Ns/10"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  ttinds[m] = tt->ind[ft->dim_perm[m]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/ftensor/1"}
{"code": "for (int p = instance->ptr[option + 1] - 1; p >= instance->ptr[option]; p--)\n{\n  int item = instance->options[p];\n  if (item == chosen_item)\n    continue;\n\n  uncover(instance, ctx, item);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/5"}
{"code": "for (size_t TID = 0; TID < instaceCountTable1; TID++)\n{\n  size_t temp = indexes[TID];\n  size_t value = temp * degree;\n  indexes[TID] = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/19"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int nodes_start_pos_i = (num_nodes / size) * i;\n  int nodes_local_num_i = num_nodes / size;\n  if (i == (size - 1))\n  {\n    nodes_local_num_i += num_nodes % size;\n  }\n\n  MPI_Status s;\n  MPI_Recv(tmp_logits_space + (nodes_start_pos_i * num_classes), nodes_local_num_i * num_classes, MPI_FLOAT, i, 3, MPI_COMM_WORLD, &s);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyuejohn/Parallel-Programming-for-Graph-Convolutional-Neural-Networks/gcn_hybrid/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  EigenVals.push_back(make_pair(sqrt(abs(E_vals[i])), i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/14"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src = v;\n  uint32_t dest;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    dest = Nodes->edges_array_dest[j];\n    uint32_t comp_src = stats->components[src];\n    uint32_t comp_dest = stats->components[dest];\n    if (comp_src == comp_dest)\n      continue;\n\n    uint32_t comp_high = (comp_src > comp_dest) ? (comp_src) : (comp_dest);\n    uint32_t comp_low = comp_src + (comp_dest - comp_high);\n    if (comp_high == stats->components[comp_high])\n    {\n      change = 1;\n      stats->components[comp_high] = comp_low;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 512)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/12"}
{"code": "for (iter = 0; iter < graph->num_vertices; iter++)\n{\n  comp = stats->components[iter];\n  n = inverselabels[comp];\n  softResetArrayQueue(frontier);\n  enArrayQueueWithBitmap(frontier, n);\n  for (i = frontier->head; i < frontier->tail; i++)\n  {\n    uint32_t u = frontier->queue[i];\n    uint32_t edge_idx = graph->vertices->edges_idx[u];\n    uint32_t out_degree = graph->vertices->out_degree[u];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      uint32_t v = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n      if (stats->components[v] != comp)\n      {\n        pass = 0;\n      }\n\n      if (!isEnArrayQueued(frontier, v))\n        enArrayQueueWithBitmap(frontier, v);\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/26"}
{"code": "for (n = 0; n < MAX_ITER; ++n)\n{\n  double z_r2 = z_r * z_r;\n  double z_i2 = z_i * z_i;\n  if ((z_r2 + z_i2) > 4)\n  {\n    break;\n  }\n\n  z_i = ((2 * z_r) * z_i) + c_i;\n  z_r = (z_r2 - z_i2) + c_r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mareckste/mandelbrot_set/sources/mandelbrot_openmp_mpi_opengl/1"}
{"code": "for (int i = first; i < end; i++)\n{\n  n = m_vParticleKeyIndex[i].index;\n  double dx = search_x - m_vCoordX[n];\n  double dy = search_y - m_vCoordY[n];\n  double dz = search_z - m_vCoordZ[n];\n  double squared_distance = ((dx * dx) + (dy * dy)) + (dz * dz);\n  if (squared_distance < radius_sq)\n  {\n    result[result_index] = m_vParticleKeyIndex[i].index;\n    result_index++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/octree/10"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  printf(\"%d\\t\", array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg1/10"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  p[i] = v1[i] * v2[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/vecmul/0"}
{"code": "for (src = 0; src < 800; src++)\n{\n  for (dst = 0; dst < 800; dst++)\n  {\n    if (src != dst)\n    {\n      distance_matrix[src][dst] = rand() % 20;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuvrajdalia/openmp_project/floydp/1"}
{"code": "for (j = 0; j < 100; j++)\n{\n  a[i][j] = i * j;\n}\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB061-matrixvector1-orig-no/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      vijk = vs[i][j][k];\n      vp1 = vs[i][j + 1][k];\n      vm1 = vs[i][j - 1][k];\n      rhs[i][j][k][0] = (rhs[i][j][k][0] + (dy1ty1 * ((u[i][j + 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j - 1][k][0]))) - (ty2 * (u[i][j + 1][k][2] - u[i][j - 1][k][2]));\n      rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dy2ty1 * ((u[i][j + 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j - 1][k][1]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][1] * vp1) - (u[i][j - 1][k][1] * vm1)));\n      rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dy3ty1 * ((u[i][j + 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j - 1][k][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[i][j + 1][k][2] * vp1) - (u[i][j - 1][k][2] * vm1)) + ((((u[i][j + 1][k][4] - square[i][j + 1][k]) - u[i][j - 1][k][4]) + square[i][j - 1][k]) * c2)));\n      rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dy4ty1 * ((u[i][j + 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j - 1][k][3]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][3] * vp1) - (u[i][j - 1][k][3] * vm1)));\n      rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dy5ty1 * ((u[i][j + 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j - 1][k][4]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[i][j + 1][k][4] * rho_i[i][j + 1][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j - 1][k][4] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[i][j + 1][k][4]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[i][j - 1][k][4]) - (c2 * square[i][j - 1][k])) * vm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(vijk, vp1, vm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/44"}
{"code": "for (i = 0; i < gap_pos1; i++)\n{\n  matrix[i][gap_pos1] = gr_score;\n  matrix[gap_pos1][i] = gr_score;\n  matrix[i][gap_pos2] = gr_score;\n  matrix[gap_pos2][i] = gr_score;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/5"}
{"code": "for (int i = 0; i < length; i++)\n{\n  array[i] = (((double) rand()) / 32767) * 2.0;\n  omp_set_lock(&lock);\n  total += array[i];\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice10/0"}
{"code": "for (int t = 0; t < heightA; t += lineWidth)\n{\n  for (int i = 0; (i < lineWidth) && ((t + i) < heightA); ++i)\n  {\n    for (int j = 0; j < lengthB; ++j)\n    {\n      C[i + t][j] = 0;\n      for (int k = 0; k < size; k++)\n      {\n        C[i + t][j] += A[i + t][k] * B[k][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task4/0"}
{"code": "for (i = 1; i < (((L / 1) + 2) - 1); i++)\n{\n  j = 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    got[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    got[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n  j = ((L / NODESY) + 2) - 2;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    get[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    get[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/87"}
{"code": "for (i = 1; i < (size - 1); i++)\n{\n  for (j = 1; j < (size - 1); j++)\n  {\n    int sum = ((((((A[i + 1][j] + A[i][j + 1]) + A[i - 1][j]) + A[i][j - 1]) + A[i - 1][j - 1]) + A[i - 1][j + 1]) + A[i + 1][j - 1]) + A[i + 1][j + 1];\n    B[i][j] = Populate(i, j, sum, A);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taggelos/GameOfLife/Paradoteo/mpi_openmp/functions/0"}
{"code": "for (int i = 0; i < cut_candidate.size(); i++)\n  cut_candidate[i].print();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joshuaar/MinCut/MinCut/2"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  if (array[i] == 0)\n    primos++;\n\n}\n\n", "pragma": "omp parallel for reduction(+:primos)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leo-ventura/parallel-computing-openmp/src/crivo/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"OMP Thread# %d, pr++=%d, sh++=%d\\n\", omp_get_thread_num(), pr++, sh++);\n}\n\n", "pragma": "omp parallel for firstprivate(pr) shared(sh)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xniu7/jhuclass.pp.openmp/class_examples/firstprivate/0"}
{"code": "for (int i = 0; i < s; i++)\n{\n  data[2 * i] = data2[i] - data[(2 * i) + 1];\n  data[(2 * i) + 1] = data2[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/pquick/1"}
{"code": "for (unsigned int i = 0; i < (((2048 / NODESX) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((2048 / NODESY) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/124"}
{"code": "for (int i = 0; i < BINS; i++)\n{\n  bins[nextBins][i].resize(0);\n}\n\n", "pragma": "            #pragma omp for schedule(static, bins_per_thread)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/E-BAO/Particles-Simulation/openmp/2"}
{"code": "for (ll = 0; ll < NUM_VARS; ll++)\n{\n  for (k = 0; k < nz; k++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      indt = (((ll * nz) * nx) + (k * nx)) + i;\n      indf1 = (((ll * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i;\n      indf2 = ((((ll * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i) + 1;\n      tend[indt] = (-(flux[indf2] - flux[indf1])) / dx;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(3) private(indt,indf1,indf2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-omp/main/2"}
{"code": "for (row = 0; row < out->height; row++)\n{\n  for (col = 0; col < out->width; col++)\n  {\n    out->data[out_offset + col] = conv2D_region(in, in_offset + col, kernel, n);\n  }\n\n  in_offset += in->width;\n  out_offset += out->width;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jeffcav/parallel-convolution/src/conv/2"}
{"code": "for (int i = 0; i < IMAGE_HEIGHT; ++i)\n{\n  for (int j = 0; j < IMAGE_WIDTH; ++j)\n  {\n    fprintf(fptr, \"%d \", img_lbp[i][j]);\n  }\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/egebasturk/Parallel-Computing-Projects/Project3/cs426_project3_code/lbp_omp/8"}
{"code": "for (i = nelements - 1; i >= 1; i--)\n{\n  list_is_sorted = 1;\n  for (j = 0; j < i; j++)\n  {\n    if (vector_serial[j] > vector_serial[j + 1])\n    {\n      aux = vector_serial[j];\n      vector_serial[j] = vector_serial[j + 1];\n      vector_serial[j + 1] = aux;\n      list_is_sorted = 0;\n    }\n\n  }\n\n  if (list_is_sorted == 1)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/bubblesort/1"}
{"code": "for (i = 0; i < (1 << 16); i++)\n{\n  k = key_array[i];\n  key_buff2[bucket_ptrs[k >> shift]++] = k;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/3"}
{"code": "for (int j = 0; j < 5716; ++j)\n{\n  for (int i = 3731; i >= 0; --i)\n  {\n    if (i == 3731)\n      sum[i][j] = 0;\n    else\n      sum[i][j] = sum[i + 1][j] + data[i][j];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main3/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/14"}
{"code": "for (int i = 0; i < 100000000; i++)\n  a = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wyh0655/OpenMP_EXA/exa1/0"}
{"code": "for (k = 1; k < (nn + 1); k++)\n{\n  MX1[k] = MX1[k - 1] + count[k - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXsetup/2"}
{"code": "for (j = 0; j < clusters_count; j++)\n{\n  int l;\n  for (l = 0; l < clusters[j].member_count; ++l)\n  {\n    clusters[j].members[l].x = 0.0;\n    clusters[j].members[l].y = 0.0;\n  }\n\n  clusters[j].member_count = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OmarKhaledm21/K-MEANS_Clustering-C_OpenMP-/K_MEANS_CLUSTERING/9"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((x_px[i] < xmin) || (x_px[i] >= xmax))\n    continue;\n\n  bin = calc_bin(x_px[i], edges);\n  for (ssize_t j = 0; j < nw; ++j)\n  {\n    w_ij = w_px(i, j);\n    values_px(bin, j) += w_ij;\n    variances_px(bin, j) += w_ij * w_ij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/25"}
{"code": "for (unsigned long i = 0; i < vectorProcess.size(); ++i)\n{\n  if (AnalyzeOneFunction(vectorProcess[i]))\n  {\n    vectorProcess.erase(vectorProcess.begin() + i);\n    --i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/src/OAORewriter/13"}
{"code": "for (int jj = 0; jj < N; jj = jj + Nb)\n  for (int kk = 0; kk < N; kk = kk + Nb)\n  for (int i = 0; i < N; i++)\n  for (int j = jj; j < min(jj + Nb, N); ++j)\n{\n  float r = 0;\n  for (int k = kk; k < min(kk + Nb, N); k++)\n    r += A[(i * N) + k] * B[(k * N) + j];\n\n  C[(i * N) + j] += r;\n}\n\n\n\n\n", "pragma": "omp parallel for ordered schedule(static, Nb) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_main_blocked/1"}
{"code": "for (i = 0; i < file_info->K; i++)\n{\n  fprintf(f, \"[%lf, %lf, %lf]\\n\", k_clusters[i].centroid.x, k_clusters[i].centroid.y, k_clusters[i].centroid.z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/5"}
{"code": "for (ii = 0; ii < params.ny; ii++)\n{\n  for (jj = 0; jj < params.nx; jj++)\n  {\n    if (obstacles[(ii * params.nx) + jj])\n    {\n      cells[(ii * params.nx) + jj].speeds[1] = tmp_cells[(ii * params.nx) + jj].speeds[3];\n      cells[(ii * params.nx) + jj].speeds[2] = tmp_cells[(ii * params.nx) + jj].speeds[4];\n      cells[(ii * params.nx) + jj].speeds[3] = tmp_cells[(ii * params.nx) + jj].speeds[1];\n      cells[(ii * params.nx) + jj].speeds[4] = tmp_cells[(ii * params.nx) + jj].speeds[2];\n      cells[(ii * params.nx) + jj].speeds[5] = tmp_cells[(ii * params.nx) + jj].speeds[7];\n      cells[(ii * params.nx) + jj].speeds[6] = tmp_cells[(ii * params.nx) + jj].speeds[8];\n      cells[(ii * params.nx) + jj].speeds[7] = tmp_cells[(ii * params.nx) + jj].speeds[5];\n      cells[(ii * params.nx) + jj].speeds[8] = tmp_cells[(ii * params.nx) + jj].speeds[6];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ii) private(jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sd12832/High-Performance-Computing-Files/d2q9-bgk-OpenMP/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%f \", (float) Cv[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/135"}
{"code": "for (i = 0; i < data.size(); i++)\n{\n  minimum = INT_MAX;\n  for (j = 0; j < means.size(); j++)\n  {\n    distance = Euclidean_Distance(data[i], means[j]);\n    if (minimum > distance)\n    {\n      minimum = distance;\n      index = j;\n    }\n\n  }\n\n  if (index != cluster_number[i])\n  {\n    noChange = false;\n  }\n\n  cluster_number[i] = index;\n}\n\n", "pragma": "\t\t#pragma omp parallel for private(j,minimum,distance,index) schedule( dynamic , chunk_size )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roy-1996/k-means-clustering/kmeans-parallel/5"}
{"code": "for (int i = s; i <= e; ++i)\n{\n  v[i] = temp[i - s];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengling0410/Parallelized-Movie-Recommendation/src/movierecommendation_parallel/2"}
{"code": "for (i = 0; i < 64; i++)\n{\n  ;\n}\n\n", "pragma": "omp for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/ordered-3/4"}
{"code": "for (int i = 0; i < ((sizeof(counts)) / (sizeof(*counts))); i++)\n{\n  Log(\"==============================================================================\");\n  LaunchComplexMultiplication(counts[i], true);\n  LaunchComplexMultiplication(counts[i], false);\n  Log(\"==============================================================================\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/Source/1"}
{"code": "for (i = 0; i < sizeB; i++)\n{\n  printf(\"B[%d]=%d,%s\", i, B[i], (B[i] > 9) ? (\" \") : (\"  \"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/B/ass2-openmp/8"}
{"code": "for (int i = 1; i < (n + 1); ++i)\n{\n  for (int j = 1; j < (n + 1); ++j)\n  {\n    heat += h_new[map(i, j, n + 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arslansadiq/Parallel-Programming-TUM/Assignment12_Hybrid/helper/1"}
{"code": "for (int i = 0; i < nb_nodes; ++i)\n{\n  int k = i * 3;\n  memset(val, 0, (sizeof(double)) * 2);\n  memset(vec, 0, (sizeof(double)) * 4);\n  m[0] = field.tensor[k];\n  m[1] = field.tensor[k + 1];\n  m[2] = m[1];\n  m[3] = field.tensor[k + 2];\n  eigenDecompose(m, val, vec, vec + 2);\n  val[0] = max(abs(val[0]), EPSILON);\n  val[1] = max(abs(val[1]), EPSILON);\n  const double det = val[0] * val[1];\n  const double scale_loc = pow(det, param.scale.exp);\n  val[0] *= scale_loc;\n  val[1] *= scale_loc;\n  m[0] = val[0] * vec[0];\n  m[1] = val[0] * vec[2];\n  m[2] = val[1] * vec[1];\n  m[3] = val[1] * vec[3];\n  h[0] = (vec[0] * m[0]) + (vec[1] * m[2]);\n  h[1] = (vec[0] * m[1]) + (vec[1] * m[3]);\n  h[2] = (vec[2] * m[0]) + (vec[3] * m[2]);\n  h[3] = (vec[2] * m[1]) + (vec[3] * m[3]);\n  assert(abs(h[1] - h[2]) < 1.e-3);\n  field.tensor[k] = h[0];\n  field.tensor[k + 1] = h[1];\n  field.tensor[k + 2] = h[3];\n}\n\n", "pragma": "#pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/metric/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i] = i;\n  for (int j = 0; j < n; j++)\n  {\n    if (j < i)\n    {\n      u[i][j] = 0.0;\n      l[i][j] = drand48();\n    }\n    else\n      if (j == i)\n    {\n      l[i][j] = 1.0;\n      u[i][j] = drand48();\n    }\n    else\n    {\n      u[i][j] = drand48();\n      l[i][j] = 0.0;\n    }\n\n\n    a[i][j] = drand48();\n    a_orig[i][j] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/4"}
{"code": "for (i = 0; i < dim; i++)\n  if (fabs(mat1[i][i] - 1.0) > 1e-6)\n{\n  printf(\"error at %d %lf\", i, mat1[i][i]);\n  fflush(stdout);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj_inv/bench/3"}
{"code": "for (i = 1; i < size; i++)\n{\n  index += C(NODE_N - 1, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/24"}
{"code": "for (i = 0; i < N; i++)\n{\n  Nodes[i].con_size = 0;\n  Nodes[i].To_id = (int *) malloc(sizeof(int));\n}\n\n", "pragma": "omp parallel for private(i) shared(Nodes)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/papadopoulosc/pagerank/1st_parallel/pagerank_openmp/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  v1[i] = (N * 0.1) + (i * 0.1);\n  v2[i] = (N * 0.1) - (i * 0.1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P1/7/SumaVectoresC-parallel/0"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    density1[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = N; j < M; j++)\n  {\n    *((sigmaInv + (i * M)) + j) = 0.0;\n    *((sigmaPtr + (j * N)) + i) = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/10"}
{"code": "for (unsigned n = 0; n < set->natoms; n++)\n{\n  for (int i = 0; i < 3; i++)\n  {\n    if (set->pos.x[n + (i * set->offset)] < domain->min_ext[i])\n    {\n      set->pos.x[n + (i * set->offset)] = domain->min_ext[i];\n      set->speed.dx[n + (i * set->offset)] *= -1;\n      atom_state[n] = SHOCK_PERIOD;\n    }\n\n    if (set->pos.x[n + (i * set->offset)] > domain->max_ext[i])\n    {\n      set->pos.x[n + (i * set->offset)] = domain->max_ext[i];\n      set->speed.dx[n + (i * set->offset)] *= -1;\n      atom_state[n] = SHOCK_PERIOD;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/openmp/3"}
{"code": "for (j = 1; j < (_PB_N - 1); j++)\n  A[j] = B[j];\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/jacobi-1d-imper/jacobi-1d-imper/1"}
{"code": "for (int j = 0; j < graph.size(); ++j)\n{\n  for (int k = 0; k < graph.size(); ++k)\n  {\n    out[j][k] = min(out[j][k], out[j][i] + out[i][k]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/6yryndy4una174/OpenMPtask3/OpenMPtask3/main/3"}
{"code": "for (k = 0; k <= (d[2] - 1); k += 1)\n{\n  for (i = 0; i <= (fftblock - 1); i += 1)\n  {\n    y0[k][i].real = x[k][j][i + ii].real;\n    y0[k][i].imag = x[k][j][i + ii].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/13"}
{"code": "for (node_t i = 0; i < G->numNodes; i++)\n{\n  node_t nodeCluster = comm[i];\n  node_t clusterPos = clusterPositions[nodeCluster];\n  node_t nodePos = cd[clusterPos].commDistance + commpos[i];\n  clusterednodes[nodePos] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/17"}
{"code": "for (int j = 0; j < n2; j++)\n{\n  R[j] = a[(m + 1) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guruprasad-bangi/OpenMp/mergesort/2"}
{"code": "for (int n_threads = 1; n_threads <= 32; n_threads = (n_threads <= 8) ? (2 * n_threads) : (n_threads + 4))\n{\n  omp_set_num_threads(n_threads);\n  for (int i = 0; i < NRUNS; ++i)\n  {\n    fillInput(xr, xi, N);\n    setOutputZero(xr_check, xi_check, N);\n    setOutputZero(Xr_o, Xi_o, N);\n    double start_time = omp_get_wtime();\n    int idft = 1;\n    DFT(idft, xr, xi, Xr_o, Xi_o, N);\n    idft = -1;\n    DFT(idft, Xr_o, Xi_o, xr_check, xi_check, N);\n    times[i] = omp_get_wtime() - start_time;\n    checkResults(xr, xi, xr_check, xi_check, Xr_o, Xi_o, N);\n    if (DEBUG)\n    {\n      printResults(Xr_o, Xi_o, N);\n    }\n\n  }\n\n  double avg;\n  double std_dev;\n  compute_statistics(times, NRUNS, &avg, &std_dev);\n  printf(\"DFTW (%2d threads) - Average: %fs - Std. deviation: %fs\\n\", n_threads, avg, std_dev);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/DFTW/DFTW_omp/1"}
{"code": "for (i = rb; i < re; i++)\n  p_u[i] = p_u[i] - (al * p_d[1][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/21"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  out_degree = vertices->out_degree[v];\n  if (stats->parents[v] < 0)\n  {\n    edge_idx = vertices->edges_idx[v];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      u = EXTRACT_VALUE(sorted_edges_array[j]);\n      if (getBit(bitmapCurr, u))\n      {\n        stats->parents[v] = u;\n        stats->distances[v] = stats->distances[u] + 1;\n        setBitAtomic(bitmapNext, v);\n        nf++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(j,u,v,out_degree,edge_idx) shared(stats,bitmapCurr,bitmapNext,graph,vertices,sorted_edges_array) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/6"}
{"code": "for (int i = 0; i < A.get_row(); i++)\n{\n  y.data()[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/matrix/matrix_spmv_crs/0"}
{"code": "for (k = 0; k < omp_get_max_threads(); k++)\n{\n  for (i = istart[k]; i < iend[k]; i++)\n  {\n    dtemp_t[k] += A[i] * A[i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Reduction/C/reduction/2"}
{"code": "for (i = 0; i < ((4 * TableSize) / 128); i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    ran[j] = (6364136223846793005ULL * ran[j]) + 1;\n    Table[ran[j] >> (64 - logTableSize)] ^= ran[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/serial/single_node_lcg/2"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  sequential_odd_even_transposition_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/odd-even-transposition/9"}
{"code": "for (j = 2; j < (block_dim - 2); j++)\n{\n  neighbors = 0;\n  neighbors += (((((((a[block_dim - 3][j - 1] - '0') + (a[block_dim - 2][j - 1] - '0')) + (a[block_dim - 1][j - 1] - '0')) + (a[block_dim - 1][j] - '0')) + (a[block_dim - 1][j + 1] - '0')) + (a[block_dim - 2][j + 1] - '0')) + (a[block_dim - 3][j + 1] - '0')) + (a[block_dim - 3][j] - '0');\n  if ((a[block_dim - 2][j] == '0') && (neighbors == 3))\n  {\n    b[block_dim - 2][j] = '1';\n  }\n  else\n    if (a[block_dim - 2][j] == '1')\n  {\n    if (neighbors < 2)\n    {\n      b[block_dim - 2][j] = '0';\n    }\n    else\n      if (neighbors < 4)\n    {\n      b[block_dim - 2][j] = '1';\n    }\n    else\n    {\n      b[block_dim - 2][j] = '0';\n    }\n\n\n  }\n  else\n    b[block_dim - 2][j] = '0';\n\n\n}\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoRouv/game-of-life/GOLOpenMP/golOpenMP/4"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (k = 1; k <= (nz - 2); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m) firstprivate (nz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/134"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = shouldArr[i];\n}\n\n", "pragma": "  #pragma omp parallel for num_threads(THREAD_COUNT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/13"}
{"code": "for (m = 0; m < interpolation_order; m++)\n{\n  k = m * N;\n  for (i = 0; i < N; i++)\n  {\n    Sn[k + i].x = LagrangeWeight(interpolation_order, point[i].x, m);\n    Sn[k + i].y = LagrangeWeight(interpolation_order, point[i].y, m);\n    Sn[k + i].z = LagrangeWeight(interpolation_order, point[i].z, m);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/24"}
{"code": "for (iRow = 0; iRow < nRow; iRow++)\n{\n  SumD[iRow] = (int *) malloc(nCol * (sizeof(int)));\n  if (SumD[iRow] == 0)\n  {\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/MatrixAdditionOMP/3"}
{"code": "for (i = 0; i < (2 * (nendmembers - 1)); i++)\n{\n  for (j = 0; j < (2 * (nendmembers - 1)); j++)\n  {\n    fprintf(report, \" %lf\", pro[i][j]);\n  }\n\n  fprintf(report, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/14"}
{"code": "for (c = 0; c < COLUMNS; c++)\n{\n  setVal(cells, 0, c, 0);\n  setVal(tempCells, 0, c, 0);\n  setVal(cells, ROWS - 1, c, 0);\n  setVal(tempCells, ROWS - 1, c, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IsaacLehman/Game-of-Life/GameOfLife/4"}
{"code": "for (i = (*num_ph) - ((total_bins - count_c_ph) + (*num_null_ph)); i < (*num_ph); i++)\n{\n  if ((*ph_orig)[i].type == CS_POOL_PHOTON)\n  {\n    (*ph_orig)[i].type = COMPTONIZED_PHOTON;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/11"}
{"code": "for (i = 0; i < cnt_13; i++)\n{\n  y[i] = x[i] * x[i];\n  if (((i == 0) || (i == (cnt_13 / 2))) || (i == (cnt_13 - 1)))\n  {\n    printf(\"compute13: x[%d] = %f y[%d] = %f \\n\", i, x[i], i, y[i]);\n    fflush(0);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/samples_2016/en/compiler_c/psxe/mic_samples/intro_sampleC/src/sampleC13/6"}
{"code": "for (v6n = 0; v6n < 3; v6n++)\n{\n  int v6m = v6j + v6k;\n  v6i = 8;\n  v6l++;\n}\n\n", "pragma": "omp for private (v6i) firstprivate (v6k) reduction (+:v6l)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/debug-1/0"}
{"code": "for (i = 0; i < 2021; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ksheeraj1161/OpenMP-MPI/OpenMP/sum of N elements using Loop work Sharing with schedule clause/1"}
{"code": "for (i = 0; i < 5000000; i++)\n  fprintf(fp, \"%lf\\n\", z[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/addition/2"}
{"code": "for (i = 1; i < (8192 - 1); ++i)\n{\n  for (j = 1; j < (8192 - 1); ++j)\n  {\n    B[(i * 8192) + j] = ((((((((c11 * A[((i - 1) * 8192) + (j - 1)]) + (c12 * A[((i + 0) * 8192) + (j - 1)])) + (c13 * A[((i + 1) * 8192) + (j - 1)])) + (c21 * A[((i - 1) * 8192) + (j + 0)])) + (c22 * A[((i + 0) * 8192) + (j + 0)])) + (c23 * A[((i + 1) * 8192) + (j + 0)])) + (c31 * A[((i - 1) * 8192) + (j + 1)])) + (c32 * A[((i + 0) * 8192) + (j + 1)])) + (c33 * A[((i + 1) * 8192) + (j + 1)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/2DCONV/src/2DConvolution/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    fprintf(stderr, \"%d \", M[RM(i, j, size)]);\n  }\n\n  fprintf(stderr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artalukd/toRustOrNot/C++/matrixmultiply/main/0"}
{"code": "for (int i = 0; i < 30; i++)\n{\n  sdTotal += ((out[i] - mean) * (out[i] - mean)) / 29;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KasunEdward/OpenMP_Project/OV_Parallel/3"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  for (size_t j = 0; j < i; j++)\n  {\n    temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/6"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    A[i][j] = U_t[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lixueclaire/Parallel-SVD/OMP_SVD/2"}
{"code": "for (unsigned i = 0; i < dists.size(); ++i)\n{\n  if (dists.at(i) != infDist)\n  {\n    (((cerr << i) << \": \") << dists.at(i)) << \", \";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yowgf/delta-stepping/lib/main/appliance/Alg/deltaStepping/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"b[%d][%d] = %d \", i, j, b[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter7/fig7.11-nested-parallel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  float random = ((float) rand()) / ((float) 32767);\n  float_arr[i] = random;\n  printf(\"%f  \", random);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/histogram_plotting/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  c[i] = a[i] + b[i];\n  printf(\"- Thread %d of %d\\n\", omp_get_thread_num() + 1, omp_get_num_threads());\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/12"}
{"code": "for (i = 0; i < neighbor_nodes->count; i++)\n{\n  global_dest_node = naive_partitioning_convert_to_global_index((neighbor_nodes->addr + i)->dest, local_offset);\n  global_dest_community = *(cd->vertex_community + global_dest_node);\n  weight = (neighbor_nodes->addr + i)->weight;\n  if (global_dest_community == current_community)\n    *current_community_k_i_in += weight;\n  else\n    if (!sorted_linked_list_insert(sll, global_dest_community, weight))\n  {\n    printf(\"Cannot insert node in sorted linked list!\");\n    sorted_linked_list_free(sll);\n    free(sll);\n    return 0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/version-parallel-naive-partitioning/4"}
{"code": "for (int timestep = num_timesteps - 2; timestep >= 0; --timestep)\n{\n  (compute_beta_kernel < NUM_THREADS_PER_BLOCK2) > ((num_paths, payoff, d_svds + (16 * timestep), d_paths + (timestep * num_paths), d_cashflows, d_all_out_of_the_money + timestep, d_temp_storage));\n  (update_cashflow_kernel < NUM_THREADS_PER_BLOCK2) > ((update_cashflow_grid, num_paths, payoff, exp_min_r_dt, d_temp_storage, d_paths + (timestep * num_paths), d_all_out_of_the_money + timestep, d_cashflows));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aop-omp/main/7"}
{"code": "for (i = 0; i < count; i++)\n{\n  assigned[i] = 0;\n  for (j = 0; j < k; j++)\n    asgn[j][i] = 0;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char key[SSE_GROUP_SZ_SHA1][24];\n  unsigned char iv[SSE_GROUP_SZ_SHA1][8];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; i++)\n  {\n    pkcs12_pbe_derive_key(1, cur_salt->iterations, MBEDTLS_PKCS12_DERIVE_KEY, (unsigned char *) saved_key[index + i], saved_len[index + i], cur_salt->salt, cur_salt->salt_size, key[i], 24);\n    pkcs12_pbe_derive_key(1, cur_salt->iterations, MBEDTLS_PKCS12_DERIVE_IV, (unsigned char *) saved_key[index + i], saved_len[index + i], cur_salt->salt, cur_salt->salt_size, iv[i], 8);\n  }\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; i++)\n  {\n    unsigned char out[16];\n    unsigned char input[48 + 8];\n    int padbyte;\n    DES_cblock ivec;\n    DES_key_schedule ks1;\n    DES_key_schedule ks2;\n    DES_key_schedule ks3;\n    DES_set_key_unchecked((DES_cblock *) key[i], &ks1);\n    DES_set_key_unchecked((DES_cblock *) (key[i] + 8), &ks2);\n    DES_set_key_unchecked((DES_cblock *) (key[i] + 16), &ks3);\n    memcpy(ivec, iv[i], 8);\n    memcpy(input, saved_key[index + i], saved_len[index + i]);\n    padbyte = 8 - (saved_len[index + i] % 8);\n    if ((padbyte < 8) && (padbyte > 0))\n      memset(input + saved_len[index + i], padbyte, padbyte);\n\n    DES_ede3_cbc_encrypt(input, out, 8, &ks1, &ks2, &ks3, &ivec, 1);\n    cracked[index + i] = !memcmp(out, cur_salt->encrypted_pin, 8);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sap_pse_fmt_plug/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    r[size * i] = r[size * i] + (m[(size * i) + j] * v[size * j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KinseyMcG/Parallel-Matrix/matrix/6"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n  a[i][j] = 1.;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/TAffinity/multf/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (fabs(c_d[i] - validate_d[i]) > EPS_DOUBLE)\n  {\n    ++N_errors;\n    if (!flag)\n    {\n      printf(\"First fail: c_d[%d](%f) != validate_d[%d](%f)\\n\", i, c_d[i], i, validate_d[i]);\n      flag = true;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/examples/openmp/vmul_template/vmul_template/4"}
{"code": "for (int i = 0; i < max.capa; ++i)\n  task.matched[i] = -1;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/matching/2"}
{"code": "for (i = 0; i < quantoPercorrer; i++)\n{\n  lastResults[i] = ((float) vetor_recB[i]) / ((float) matrixAux[i][w + i]);\n  printf(\"%d / %d \\n\", vetor_recB[i], matrixAux[i][w + i]);\n}\n\n", "pragma": "omp parallel for private(i) num_threads(numberOfThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/4"}
{"code": "for (int i = 0; i < N_ROWS; ++i)\n{\n  result.row(i) = lanja.row(i) + adapa.row(i);\n  ((((cout << \"Processing\") << i) << \"  Thread NO:-\") << omp_get_thread_num()) << endl;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chaithanya1996/openmp_learn/hello_world/0"}
{"code": "for (size_t longlong_index = 0; longlong_index < longlong_length; longlong_index++)\n{\n  for (int bit_index = 0; bit_index < ((sizeof(unsigned long long)) * 8); bit_index++)\n  {\n    const uint64_t global_vertex = (longlong_index * ((sizeof(unsigned long long)) * 8)) + bit_index;\n    if ((global_vertex < nglobalverts) && (!is_visited_longlong(global_vertex, marked)))\n    {\n      const int local_neighbors_start = global_vert_to_local_neighbors_offsets[global_vertex];\n      const int local_neighbors_end = global_vert_to_local_neighbors_offsets[global_vertex + 1];\n      for (int i = local_neighbors_start; i < local_neighbors_end; i++)\n      {\n        const uint64_t neighbor_global_vertex = local_min_vertex + global_vert_to_local_neighbors[i];\n        if (is_visited_longlong(neighbor_global_vertex, last_marked) && (!is_visited_longlong(neighbor_global_vertex, marked)))\n        {\n          preds[global_vertex] = neighbor_global_vertex;\n          set_visited_longlong(global_vertex, marking, longlong_length);\n          const uint64_t longlong_index = global_vertex / ((uint64_t) ((sizeof(unsigned long long)) * 8));\n          count_signals++;\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) firstprivate(marked, last_marked, marking, actual_marking, global_vert_to_local_neighbors_offsets, global_vert_to_local_neighbors, preds) reduction(+:count_signals)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/0"}
{"code": "for (int i = 0; i < cyl_geom->n_grid_r; i++)\n{\n  int temp = cyl_geom->n_grid_z;\n  four1->fast_sine_transform(fi, temp, i, true);\n}\n\n", "pragma": "#pragma omp parallel for shared (four1, fi)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/poissonDirichlet/3"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    C[(i * 3072) + j] *= 4546;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk_cpu/9"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    (cout << c[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/6"}
{"code": "for (j = 0; j < n; j++)\n{\n  i = findIndexBin(cfd, 0, n, u[j]);\n  if (i == (-1))\n    i = m;\n\n  x_j[j] = arrayX[i];\n  y_j[j] = arrayY[i];\n}\n\n", "pragma": "omp parallel for num_threads(30) firstprivate(n, m, cfd, u, arrayX, arrayY, x_j, y_j) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jerrylzy/CS33/Lab/openmplab/func/6"}
{"code": "for (i = 0; i < (len - 1); i += 1)\n{\n  for (j = 0; j < len; j += 1)\n  {\n    a[i][j] += a[i + 1][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/antidep2-orig-yes/0"}
{"code": "for (unsigned int i = 0; i < (((L / 1) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((L / 5) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/34"}
{"code": "for (i = 0; i < (N / P); i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    buffSize[j] = M / P;\n    dispA[j] = (((M / P) * (N / P)) * j) + ((M / P) * i);\n    dispB[j] = (M * i) + ((M / P) * j);\n  }\n\n  MPI_Alltoallv(a, buffSize, dispA, (MPI_Datatype) 0x4c000405, b, buffSize, dispB, (MPI_Datatype) 0x4c000405, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/10"}
{"code": "for (int i = 0; i < 30; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUSTechBruce/Multithread-merge_sort/merge_sort/3"}
{"code": "for (r = 0; r < nranks; ++r)\n{\n  size_t size = (whole_size / weighted_nranks) * weights[r];\n  if (r == 0)\n  {\n    size += radius * nx_ny_pad;\n    memcpy(my_data, data_ptr, size * (sizeof(float)));\n  }\n  else\n    if (r < (nranks - 1))\n  {\n    MPI_Send(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1);\n  }\n  else\n  {\n    size += radius * nx_ny_pad;\n    MPI_Send(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1);\n  }\n\n\n  data_ptr += size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erwold/3d-Finite-difference/iso-3dfd_main/3"}
{"code": "for (int c = last_chunk_idx + 1; c < node->num_classes; ++c)\n{\n  node->logits[c] += (message[c] / norm) + (bias_2[c] / node->degree);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_hybrid-simd/7"}
{"code": "for (iRow = 0; iRow < nRow; iRow++)\n{\n  piBuffer[iRow] = (int *) malloc(nCol * (sizeof(int)));\n  if (piBuffer[iRow] == 0)\n  {\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/TransposeUsingOMP/1"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    if (percentDiff(B[(i * 500) + j].value, B_GPU[(i * 500) + j].value) > 0.01)\n    {\n      fail++;\n    }\n\n    if (percentDiff(B[(i * 500) + j].position, B_GPU[(i * 500) + j].position) > 0.01)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/other-nearest/src/other-nearest_gpu/5"}
{"code": "for (int step = 0; step < NSTEPS; step++)\n{\n  navg = 0;\n  davg = 0.0;\n  dmin = 1.0;\n  compute_force_grid(particles, navg, davg, dmin);\n  move_particles(particles, n);\n  if (find_option(argc, argv, \"-no\") == (-1))\n  {\n    if (navg)\n    {\n      output.absavg += davg / navg;\n      output.nabsavg++;\n    }\n\n    if (dmin < output.absmin)\n    {\n      output.absmin = dmin;\n    }\n\n    if (fsave && ((step % SAVEFREQ) == 0))\n    {\n      save(fsave, n, particles);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xingyousong/Parallelized-Particle-Simulation-CS267-HW2/serial/7"}
{"code": "for (j = 8; j >= ((int) (pow(2, i - 1) + 1)); j--)\n{\n  num[j] = num[j] + num[j - ((int) pow(2, i - 1))];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/SumaCREW/0"}
{"code": "for (i = 0; i < nrows; i++)\n  maxlen = gk_max(maxlen, rowptr[i + 1] - rowptr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/22"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpp0d0z4jq.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  if (arr == 0)\n    exit(1);\n\n  int j;\n  for (j = 0; j < d; j++)\n  {\n    arr->x[j] = rand() % 100;\n  }\n\n  wp[i] = *arr;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ImolaFodor/kdtree-parallel-construct/kdtree_build_openmp/1"}
{"code": "for (i = 0; i < (num_rows * num_vectors); i++)\n  y_data[i] *= alpha;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/5"}
{"code": "for (j = 0; j < (*(nb_spqx + i)); j++)\n{\n  int x;\n  int y;\n  int iam2;\n  double sumBlock;\n  double tmp1;\n  double tmp2;\n  double tmp3;\n  double tmp4;\n  iam2 = omp_get_thread_num();\n  y = j / z;\n  x = j % z;\n  sumBlock = 0;\n  sumBlock = SummatoryBlock2D(x, y, z, v, matrixdata, divider);\n  for (int r = 0; r < NumQs; r++)\n    if (sumBlock != 0)\n  {\n    tmp1 = pow(sumBlock / totalsum, *(qval + r));\n    tmp2 = tmp1 / (*((spqxdvsn + r) + (i * NumQs)));\n    tmp3 = log(sumBlock / totalsum);\n    if (isnan(tmp2))\n      tmp2 = 0;\n\n    if (isnan(tmp3))\n      tmp3 = 0;\n\n    if (tmp2 > 0)\n      tmp4 = log(tmp2);\n    else\n      tmp4 = 0;\n\n    *((MiQxThrdvsNumQ_NN + r) + (iam2 * NumQs)) += tmp2 * tmp4;\n    *((MiQxThrdvsNumQ_MM + r) + (iam2 * NumQs)) += tmp2 * tmp3;\n  }\n\n\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/13"}
{"code": "for (i = 0; i < row_size; i++)\n{\n  sum = 0;\n  for (k = matrix.row_offset[i]; k < matrix.row_offset[i + 1]; k++)\n  {\n    sum += matrix.value[k] * x[matrix.column[k]];\n  }\n\n  result[i] = sum;\n}\n\n", "pragma": "omp parallel for private(i,k,sum) shared(matrix)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSROpenMP/0"}
{"code": "for (i = beg; i <= end; ++i)\n  tmp[i] = num[i];\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tonywyb/Lab-on-Parallel-and-Distributed-Computing/HW2/numberofInversionPairs/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  out[i] = in[i] / 2;\n}\n\n", "pragma": "omp target teams distribute parallel for map(to: in[0:n]) map(from: out[0:n])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/liba_bundled/MyDeviceLib/func_2v/0"}
{"code": "for (i = 1; i <= n; i++)\n{\n  x = (-1.) + (i * deltax);\n  area = sqrt(1. - (x * x)) * deltax;\n  if (area < 0.0)\n    printf(\"iter %ld error: %f\\n\", i, area);\n\n}\n\n", "pragma": "omp parallel for private(x,area)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_1/c_kernel/0"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  for (j = 1; j < (columns - 1); j++)\n  {\n    if ((step % 2) == 0)\n    {\n      residual_temporal = surfaceCopy[(i * columns) + j] - surface[(i * columns) + j];\n    }\n    else\n    {\n      residual_temporal = surface[(i * columns) + j] - surfaceCopy[(i * columns) + j];\n    }\n\n    if (residual_temporal > global_residual)\n    {\n      global_residual = residual_temporal;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SantiagoBlascoArnaiz/ParalelaOMP/extinguishing/1"}
{"code": "for (int i = 0; i < nn; i++)\n  czyPierwsza[i] = true;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/8"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    for (int k = 0; k < N; ++k)\n    {\n      if ((((((i == 0) || (j == 0)) || (k == 0)) || (i == (N - 1))) || (j == (N - 1))) || (k == (N - 1)))\n      {\n        u[0][i][j][k] = exact(i, j, k);\n        u[1][i][j][k] = exact(i, j, k);\n      }\n      else\n      {\n        u[0][i][j][k] = 0;\n        u[1][i][j][k] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/canatakan/poisson-solver/poisson-solver/0"}
{"code": "for (i = 1; i <= NLon; i++)\n{\n  for (j = 1; j <= NLat; j++)\n  {\n    m = idx(j, i);\n    if (Node(m, iD) == 0.0f)\n      continue;\n\n    dtLoc = My_min(dtLoc, (0.8 * (Dx * cosdeg(getLat(j)))) / sqrt(Gravity * Node(m, iD)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/4"}
{"code": "for (int i = 0; i < matrixN; i++)\n{\n  for (int j = 0; j < matrixN; j++)\n  {\n    (((cout << left) << setw(5)) << setfill(' ')) << Mat[i][j];\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/1/1/0"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  rv[i] = 1;\n  cv[i] = 1;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(ntInt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buraksekili/Sinkhorn-Knopp-scaling/cpu/main/0"}
{"code": "for (int i = 1; i < n; i++)\n{\n  temp[i] = temp[i - 1] + a[i - 1];\n  if (b[i] != temp[i])\n  {\n    res = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/scan/3"}
{"code": "for (unsigned int step = 0; step < buffer_size; step++)\n{\n  double *step_data = node_it->SolutionStepData().Data(step);\n  for (int j = 0; j < step_data_size; j++)\n  {\n    step_data[j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/create_and_destroy/11"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  tmp[i] = 0;\n  for (int j = 0; j < SIZE; j++)\n  {\n    tmp[i] = tmp[i] + (A1[(i * SIZE) + j] * x[j]);\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/ATAX/ataxPL/0"}
{"code": "for (int i = 1; i < arr_size; i++)\n{\n  if (arr[i] < min)\n  {\n    min = arr[i];\n    minIndex = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/Parallel_implementation_K_Means/Parallel_implementation_K_Means/Main/11"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  for (j = 0; j <= (len - 1); j += 1)\n  {\n    a[i][j] = ((double) i) / 2.0;\n    b[i][j] = ((double) i) / 3.0;\n    c[i][j] = ((double) i) / 7.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB098-simd2-orig-no/0"}
{"code": "for (i = 0; i <= (N - 1); i++)\n{\n  if ((i == 0) || (i == (N - 1)))\n  {\n    func_sum += cos(low_limit + (((upp_limit - low_limit) * i) / (N - 1)));\n  }\n  else\n  {\n    func_sum += 2 * cos(low_limit + (((upp_limit - low_limit) * i) / (N - 1)));\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:func_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aayush-patel-1696/High-Performance-Computing/Numerical Integration using OpenMp/cos_trapezoidal/0"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  a[i] = rand() % 10;\n  b[i] = rand() % 10;\n  printf(\"a = %d, b = %d, current thread = %d\\n\", a[i], b[i], omp_get_thread_num());\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static, 5) num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanTrofimov/parallel-programming/code/iterable/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 23) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    INT_TYPE test_rank = test_rank_array[i];\n    int failed = 0;\n    switch ('S')\n    {\n      case 'S':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'W':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n        test_rank += iteration - 1;\n      else\n        test_rank -= iteration - 1;\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'D':\n        if (i < 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'E':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        if (i == 2)\n      {\n        test_rank += iteration - 2;\n        if (iteration > 4)\n          test_rank -= 2;\n        else\n          if (iteration > 2)\n          test_rank -= 1;\n\n\n      }\n      else\n        test_rank -= iteration - 2;\n\n\n        break;\n\n    }\n\n    if (key_rank != test_rank)\n      failed = 1;\n    else\n      passed_verification++;\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/10"}
{"code": "for (idx_t s = 0; s < ft->nslcs; ++s)\n{\n  const idx_t sid = p_map_idx(s, 0, ft);\n  for (idx_t f = ft->sptr[s]; f < ft->sptr[s + 1]; ++f)\n  {\n    const idx_t fid = p_map_idx(ft->fids[f], 1, ft);\n    eind[eptr[1 + sid]++] = f;\n    eind[eptr[1 + fid]++] = f;\n    for (idx_t jj = ft->fptr[f]; jj < ft->fptr[f + 1]; ++jj)\n    {\n      const idx_t nid = p_map_idx(ft->inds[jj], 2, ft);\n      eind[eptr[1 + nid]++] = f;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/16"}
{"code": "for (int i = 3; i < argc; i++)\n{\n  if ((argv[i] == string(\"-hann\")) || (argv[i] == string(\"--hannwindow\")))\n  {\n    Hann = true;\n  }\n  else\n    if ((argv[i] == string(\"-v\")) || (argv[i] == string(\"--verbose\")))\n  {\n    verbose = true;\n  }\n  else\n    sample_frequency = atof(argv[i]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PascalRomb/fftparallelanalysis/FFTPARALLEL/resources/FFTOpenMP/6"}
{"code": "for (i = 1; i < 36; i++)\n  dsum[i] = dsum[i - 1] + dist[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/13"}
{"code": "formula.append((\"+ \" + number(ee)) + \"x^3 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/96"}
{"code": "for (s = 0; s < N; s++)\n{\n  for (t = 0; t < N; t++)\n  {\n    fscanf(op3, \"%f\", &w);\n    trans[t][s] = w;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jainpranav/OpenMP_Fun/Project2/matrix/12"}
{"code": "for (size_t i = 1; i < proc; i++)\n{\n  count += recvcounts[i - 1];\n  recvcounts[i] = getLength(size(), proc, i) * (sizeof(Body));\n  displs[i] = count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/philipzhux/parallel-n-body/src/body_pool/1"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  test();\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hgc123123/openmp/double_for/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    sum = 0;\n    for (int q = 0; q < n; q++)\n    {\n      sum += matrix_1[i][q] * matrix_2[q][j];\n    }\n\n    matrix_ans[i][j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task4/OpenMPtaks4/1"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = 0; kk < depth; ++kk)\n  {\n    int base = jj * _chunk.x;\n    buffer[base + ((_chunk.x - HALO_PAD) + kk)] = buffer[base + (((_chunk.x - HALO_PAD) - 1) - kk)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/1"}
{"code": "for (i = 3; (i * i) <= n; i = i + 2)\n{\n  if ((n % i) == 0)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment1/lab1_9/1"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"thread %d ejecuta la iteraci\u00f3n %d del bucle\\n\", omp_get_thread_num(), i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P1/1/bucle-for-modificado/0"}
{"code": "for (int i = 0; i < count; ++i)\n{\n  if (list[i][0] == str1)\n  {\n    flag1 = 1;\n    result = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thevoid12/word-search-using-parallel-computing/final/2"}
{"code": "for (int dest = 0; dest < new_no; ++dest)\n{\n  int src = code_map[dest];\n  const double *src_data = (src >= 0) ? (old_wf[src]) : (means.data());\n  memcpy(wf_[dest], src_data, ni * (sizeof(*src_data)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/4"}
{"code": "for (int j = st; j < end; j++)\n  arr[j - st] = s->b_U[idx(i, j, k)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/171"}
{"code": "for (i = 1; i < imax; ++i)\n  for (j = 1; j < jmax; ++j)\n  grid[i][j] = (char) getc(file);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/import-this/pgol/cgol_mpi_omp/8"}
{"code": "for (int j = 0; j < numOfClusters; j++)\n{\n  double temp = allClusters[j].diameter;\n  for (int q = j + 1; q < numOfClusters; q++)\n  {\n    double distance = sqrt(pow(allClusters[q].x - allClusters[j].x, 2) + pow(allClusters[q].y - allClusters[j].y, 2));\n    q += temp / distance;\n    countOfVar++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Cluster/3"}
{"code": "for (i = 0; i < num_workers; i++)\n  MPI_Send(size_buffer, 2, (MPI_Datatype) 0x4c000405, i, 43, (MPI_Comm) 0x44000000);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheTwoOfUs/video-canny-edge-detection/mpi-omp/mpi-omp/7"}
{"code": "for (int i = 0; i < 1000000; i++)\n  sum += x[i] * y[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kishkaru/OpenMP_Demos/OpenMP/dotp_critical/2"}
{"code": "for (i = 0; i <= (size - 1); i++)\n{\n  for (j = 0; j <= (size - 1); j++)\n  {\n    if ((((i == 0) || (i == (size - 1))) || (j == 0)) || (j == (size - 1)))\n    {\n      matrix[(i * size) + j] = 0.;\n    }\n    else\n    {\n      matrix[(i * size) + j] = (1. + i) + j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(size, matrix, thread_num) private(i, j) num_threads(thread_num)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hapiny/mpi-openmp-msu-course/omp/0"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd3 * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[(3 * i) + i1];\n        t2 = f[(1 + (3 * i)) + i1];\n        t3 = f[(2 + (3 * i)) + i1];\n        f[(3 * i) + i1] = f[(3 * i) + i0];\n        f[(1 + (3 * i)) + i1] = f[(1 + (3 * i)) + i0];\n        f[(2 + (3 * i)) + i1] = f[(2 + (3 * i)) + i0];\n        f[(3 * i) + i0] = t1;\n        f[(1 + (3 * i)) + i0] = t2;\n        f[(2 + (3 * i)) + i0] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = sct[kmr * j];\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[(3 * i) + i1];\n          t3 = t1 * f[(1 + (3 * i)) + i1];\n          t4 = t1 * f[(2 + (3 * i)) + i1];\n          f[(3 * i) + i1] = f[(3 * i) + i0] - t2;\n          f[(1 + (3 * i)) + i1] = f[(1 + (3 * i)) + i0] - t3;\n          f[(2 + (3 * i)) + i1] = f[(2 + (3 * i)) + i0] - t4;\n          f[(3 * i) + i0] += t2;\n          f[(1 + (3 * i)) + i0] += t3;\n          f[(2 + (3 * i)) + i0] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2,t3, t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/31"}
{"code": "for (i = 0; i < size; i++)\n{\n  sum += A[i] * x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/power_iteration/eigenvector_benchmarking/0"}
{"code": "for (i = 1; i <= len; i++)\n{\n  if ((b[i] >= low) & (b[i] < high))\n  {\n    b_pr[N] = b[i];\n    c_pr[N] = c[i];\n    N++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Insertion-Sort-Using-OpenMP/insertion_sort_parallel/4"}
{"code": "for (x = 0; x < block_height; x++)\n{\n  for (y = 0; y < block_width; y++)\n  {\n    block[(((next_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] = ((((((alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + (x * (block_width + 2))) + (y + 1)]) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 2) * (block_width + 2))) + (y + 1)])) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + y])) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 2)])) + ((1.0 - (4.0 * alpha)) * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)])) * (1 - block_border[(((next_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)])) + (block_border[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)]);\n    local_converged = local_converged && (fabs(block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] - block[(((current_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)]) > epsilon);\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, y) collapse(2) reduction(&&: local_converged)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MehdiHALA/Mpi-x-project/src/stencil_all/0"}
{"code": "for (i = lo; i < hi; i++)\n{\n  for (j = N - 1; j > i; j--)\n  {\n    a[i][j] += cos(b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cstyl/omp-scheduling/src/loops/workload/3"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    A[i][j] = j * 1;\n    B[i][j] = (i * j) + 2;\n    C[i][j] = j - (i * 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanGit/Threads-OpenMP/Threads-OpenMP/OpenMP/task2_4/1"}
{"code": "for (int i = 1; i < image_height; i++)\n{\n  if (current_task != order[i])\n  {\n    current_task = order[i];\n    printf(\"Task %d \u00ad-> Processing Chunk starting at Row %d\\n\", current_task, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/ImplementationA/1"}
{"code": "for (i = 0, x = 1; i < Size; ++i, ++x)\n{\n  k = 0;\n  for (j = 0; j < Size; ++j)\n  {\n    n = puzzle[(i * Size) + j];\n    if ((n <= (Size * x)) && (n > (Size * (x - 1))))\n    {\n      temp[k++] = n;\n    }\n\n  }\n\n  md = GetDistance(temp, md, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohadesehjm/Multicore-Npuzzle/15p/5"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (j = 0; j < m; j++)\n    if (v_trunc[i] == result[j])\n    break;\n\n\n  if (j == m)\n  {\n    result[m] = v_trunc[i];\n    m++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeGiacomoSimoes/OpenMP/vector_parallel_print/7"}
{"code": "for (int i = 0; i < 16; i = 2 + i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/40"}
{"code": "for (i = 1; i < nv; i++)\n{\n  notdone[i] = 1;\n  mind[i] = ohd[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    double tmp = q[i + (j * m)];\n    q[i + (j * m)] = q[(i * m) + j];\n    q[(i * m) + j] = tmp;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/15"}
{"code": "for (i = rank + 1; i <= n; i += size)\n{\n  double x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kcherenkov/Parallel-Programming-Labs/PiComputation/PiComputation/0"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; j++)\n  {\n    (fout << mat[i][j]) << \",\";\n    if (j == (s - 1))\n      fout << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task4(a+b)/1"}
{"code": "for (int j = 0; j < sim.N; j++)\n{\n  lane_changes += cars[j].lane_change_now;\n  if ((cars[j].lane_change_now * cars[j].lane_change_prev) == 1)\n  {\n    ping_pong_changes += 1;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:lane_changes, ping_pong_changes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\" %f \\t\", vector[i]);\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/9"}
{"code": "for (int i = 0; i < 5; ++i)\n{\n  scanf(\"%d\", &arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ishanjogalekar/Parallel-distributed-computing-programs/Programs/array1/1"}
{"code": "for (j = 0; j < dofn3_s; j++)\n{\n  count1 = j * dofn3_s;\n  fwrite(VT0 + count1, sizeof(double), cutoff.s, ptr_file);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/10"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  a[i][j] += 1;\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB096-doall2-taskloop-collapse-orig-no/0"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    result[i] += exp(this->operator()(i, j) + rhs[j]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) reduction(vec_double_plus:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/16"}
{"code": "for (i = 0; i <= 524287; i += 1)\n{\n  key_buff1[i] += prv_buff1[i];\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/6"}
{"code": "for (int y = 1; y < (height - 1); y++)\n{\n  for (int x = 1; x < (width - 1); x++)\n  {\n    i = (y * width) + x;\n    currentfield[i] = (rand() < (32767 / 10)) ? (1) : (0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/R-Fehler/lab2/gameoflife-kommi/1"}
{"code": "for (int e = 0; e < model.num_edges; ++e)\n{\n  source = model.edges[e];\n  target = model.edges[model.num_edges + e];\n  if (source != target)\n  {\n    nodes[source]->neighbors.push_back(target);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_hybrid-simd/0"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  sum = 0;\n  for (k = 0; k < 1000; k++)\n  {\n    sum += A[i][k] * B[k][j];\n  }\n\n  C[i][j] = sum;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/MatrixMultipy/multiply_parallel_middle_for/0"}
{"code": "for (int i = 0; i < nr_cols; i++)\n{\n  sequential_matrix[0][i] = 250;\n  parallel_matrix[0][i] = 250;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FatbardhKadriu/OpenMP-StencilCode/src/stencil/0"}
{"code": "for (i = 0; i < SIZE_OF_CNT; ++i)\n{\n  const int myid = omp_get_thread_num();\n  if (ends[i] != starts[i])\n  {\n    quick_sort(arr + starts[i], ends[i] - starts[i], level);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(arr, starts, ends, level) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/12"}
{"code": "for (j = 1; j < n; j += 2)\n{\n  if (a[j - 1] > a[j])\n  {\n    aux = a[j];\n    a[j] = a[j - 1];\n    a[j - 1] = aux;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoselinLara/Programaci-n-Paralela/oddEvenSort/0"}
{"code": "for (int k = 0; k < n; k++)\n{\n  q += z[k] * x[k];\n}\n\n", "pragma": "       #pragma omp parallel for reduction(+:q)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/7"}
{"code": "for (i = 0; i < n; ++i)\n  tab[i] = 10;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_9/b/TD_OPENMP_09/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    printf(\"%f \", A[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaaasonwu/HeatDistribution/mpi_heat_distribution/5"}
{"code": "for (j = 0; j < (N + 1); j++)\n{\n  for (i = 0; i < (M + 1); i++)\n    V(ut, i, j) = (0.25 * (((V(u, i, j) + V(u, i - 1, j)) + V(u, i, j - 1)) + V(u, i - 1, j - 1))) - ((0.5 * dt) * ((sy * (((V(u, i, j) + V(u, i, j - 1)) - V(u, i - 1, j)) - V(u, i - 1, j - 1))) + (sx * (((V(u, i, j) + V(u, i - 1, j)) - V(u, i, j - 1)) - V(u, i - 1, j - 1)))));\n\n}\n\n", "pragma": "omp parallel for schedule(static) default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongbozhang85/openmp-cuda-advection-solver/openmp/parAdvect/4"}
{"code": "for (i = 0; i < (128 + 1); i++)\n{\n  for (j = 0; j < (128 + 1); j++)\n  {\n    v[i][j] = vnew[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/15"}
{"code": "for (i = rank; i < total_num_plugs; i += num_processes)\n{\n  receive_plug(&plug_values, &num_ts, rank);\n  median_load = calculate_median_load(plug_values, num_ts);\n  send_float_message(median_load, 0, rank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/3"}
{"code": "for (z = 0; z < size; ++z)\n{\n  if (thread_info.buck_inds[z] == _bucket)\n    return z;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rpych/OpenMP/bucket_sort_1/3"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = i * 40;\n  b[i] = i - 1;\n  c[i] = i;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB070-simd1-orig-no/0"}
{"code": "for (int i = 0; i < CITIES; i++)\n  (((cout << coordinates[i][0]) << \"\\t\") << coordinates[i][1]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stahtews/TravellingSalesman-GeneticAlgorithm-OpenMp/tsp/7"}
{"code": "for (int proc = 0; proc < p; proc++)\n{\n  if (proc == rank)\n  {\n    MPI_Cart_coords(cartcomm, rank, 2, coord);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Cannon's Algorithm/MPI_OpenMp/8"}
{"code": "for (i = 0; i < n; ++i)\n{\n  (((cout << \"Num_threads: \") << omp_get_num_threads()) << \" Thread: \") << omp_get_thread_num();\n  ((cout << \" Iteration: \") << i) << endl;\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/11"}
{"code": "for (v = 0; v < sizeHot[0]; v++)\n{\n  labels[verticesHot[0][v]] = sizeHot[1] + v;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/6"}
{"code": "for (int x = 0; x < itrain_size; x++)\n{\n  ftest[x] = 0;\n  for (int y = 0; y < itest_size; y++)\n  {\n    ftest[x] += k[x][y] * F[x];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/doddapanenipurna/GaussianProcessRegression/gpr/5"}
{"code": "for (i = 0; i < 100; i++)\n  printf(\"[%d]: A = %d | B = %d\\n\", i, A[i], B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLSTS/ThreadProgramming/OpenMP_ArrayMultiplies/1"}
{"code": "for (i = 0; i < (128 / 2); i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    for (m = j + 1; m < 128; m++)\n    {\n      if (selected[(i * 128) + j].value > selected[(i * 128) + m].value)\n      {\n        sel_points aux;\n        aux = selected[(i * 128) + j];\n        selected[(i * 128) + j] = selected[(i * 128) + m];\n        selected[(i * 128) + m] = aux;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/k-nearest/src/k-nearest_gpu/0"}
{"code": "for (i = 1; i < (NARRAY - 1); i += 2)\n{\n  if (v2[i] > v2[i + 1])\n  {\n    tmp = v2[i + 1];\n    v2[i + 1] = v2[i];\n    v2[i] = tmp;\n  }\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelmcs/metodos-de-ordenamiento-OPENMP/trabajofinaltodoenunoparalelo/main/3"}
{"code": "for (i = 0; i < sendcounts[taskid]; i++)\n{\n  printf(\"%d\\t\", rec_buf[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/9"}
{"code": "for (int i = 0; i < P; i++)\n{\n  (*SIGMA)[i] = sqrtf(A_current[(i * P) + i]);\n  if ((*SIGMA)[i] > temp)\n  {\n    printf(\"EXCEPTION!\\n\");\n    exit(0);\n  }\n\n  temp = (*SIGMA)[i];\n  printf(\"%f \", (*SIGMA)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/9"}
{"code": "for (int x = 0; x < num; x++)\n{\n  if (data[x] == 1)\n  {\n    num_x++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/8"}
{"code": "for (i = r3; i < (sz + r3); i++)\n{\n  for (j = c3; j < sz; j++)\n  {\n    r[i][j] = 0.0;\n    for (k = 0; k < sz; k++)\n    {\n      r[i][j] += p[(i - r3) + r1][k + c1] * q[k + r2][(j - c3) + c2];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LalitDhupar/Large-Matrix-Multiplication-Using-OpenMP/Large_Matrix_Multplication_OpenMP/6"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  jglob = j;\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    exact(nx0 - 1, jglob, k, &u[nx - 1][j][k][0]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/143"}
{"code": "for (i = 1; i < n; i++)\n{\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n  print_thread_info(i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adhithadias/openmp-mpi-examples/src/parallel_for/0"}
{"code": "for (int i = 0; i < nStudents; i++)\n{\n  sum += (grades[i] - avg) * (grades[i] - avg);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/statisticspar/7"}
{"code": "for (int c = 0; c < columnas(); c++)\n{\n  arr[c] = num(ins, c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kunkkaharden/Proyecto-de-tesis/source/utiles/matrix/6"}
{"code": "for (i = 0; i < rowB; i++)\n{\n  for (j = 0; j < colB; j++)\n  {\n    matBt[i + (j * rowB)] = matB[(i * colB) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/lab6-2/3"}
{"code": "for (int i = 0; i < m; i++)\n  IP += A[i] * B[i];\n\n", "pragma": "    #pragma omp parallel for schedule (dynamic, 64) reduction (+:IP)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/4"}
{"code": "for (int i = 0; i < P; i++)\n{\n  LocalPositionsX[i].resize(0);\n  LocalPositionsY[i].resize(0);\n  LocalPositionsZ[i].resize(0);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/emaballarin/distnbody-hm/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pierorex/parallelism-homework/practica6/e6/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for collapse(2)      ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_collapse_messages/0"}
{"code": "for (int i = 0; i < K; i++)\n{\n  centroids[i] = malloc(DIM * (sizeof(*centroids[i])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Plutone11011/ParallelKMEANS/main/1"}
{"code": "for (i = 0; i < num_particles; i++)\n{\n  particle_t *particle = &particles[i];\n  particle->x_pos = (((rand() % max_resolution) - (max_resolution / 2)) * 2.0) / max_resolution;\n  particle->y_pos = (((rand() % max_resolution) - (max_resolution / 2)) * 2.0) / max_resolution;\n  particle->x_vel = particle->y_pos;\n  particle->y_vel = particle->x_pos;\n  particle->mass = 1.0 + ((num_particles + i) / total_particle);\n  particle->node = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kawtar921/nbody/nbody_omp/nbody_tools/4"}
{"code": "for (unsigned int i = 0; i < path.size(); ++i)\n{\n  (cout << path.at(i)) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/16"}
{"code": "for (i = 0; i < 1024; i += 32)\n{\n  for (j = 0; j < 1024; j += 32)\n  {\n    for (k = 0; k < 1024; k += 32)\n    {\n      for (y = i; y < (((i + 32) < 1024) ? (i + 32) : (1024)); y++)\n      {\n        for (x = j; x < (((j + 32) < 1024) ? (j + 32) : (1024)); x++)\n        {\n          for (z = k; z < (((k + 32) < 1024) ? (k + 32) : (1024)); z++)\n          {\n            sum += A[y][z] * B[z][x];\n          }\n\n          C[y][x] += sum;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,y,x,z,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/0"}
{"code": "for (j = 1; j < n; j++)\n{\n  for (i = 1; i < n; i++)\n  {\n    vr[j] += (*((ma + i) + (j * n))) * (*(va + i));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannahGulle/Baby_BLAS/OpenMP/openmp/mvv/0"}
{"code": "for (size_t i = 0; i < m_size_of_esi_temp; i++)\n{\n  geno1 = genoVecOneMarkerOld[i];\n  for (int j = 0; j < 4; j++)\n  {\n    int b = geno1 & 1;\n    geno1 = geno1 >> 1;\n    int a = geno1 & 1;\n    if ((b == 1) && (a == 0))\n    {\n      bufferGeno = 3;\n    }\n    else\n      if ((b == 0) && (a == 0))\n    {\n      bufferGeno = 2;\n    }\n    else\n      if ((b == 0) && (a == 1))\n    {\n      bufferGeno = 1;\n    }\n    else\n      if ((b == 1) && (a == 1))\n    {\n      bufferGeno = 0;\n    }\n    else\n    {\n      cout << \"Error GENO!!\\n\";\n      break;\n    }\n\n\n\n\n    m_OneSNP_GenoTemp[ind] = bufferGeno;\n    ind++;\n    geno1 = geno1 >> 1;\n    if (ind >= N)\n    {\n      int indxInOut = 0;\n      for (int indx = 0; indx < Nnomissing; indx++)\n      {\n        m_OneSNP_Geno[indxInOut] = m_OneSNP_GenoTemp[ptrsubSampleInGeno[indx] - 1];\n        if (m_OneSNP_Geno[indxInOut] == 3)\n        {\n          indexNA.push_back(indxInOut);\n        }\n\n        indxInOut = indxInOut + 1;\n      }\n\n      return &m_OneSNP_Geno;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/1"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  ((cout << \"\t\t-- Computing dynamical matrix elements for cell ci = \") << ci) << endl;\n  nv = cell(ci).getNV();\n  calA0 = cell(ci).calA0();\n  l0 = cell(ci).getl0();\n  fl = cell(ci).getkl();\n  kl = fl / l0;\n  kb = cell(ci).getkb();\n  eb = ((kb * nv) * calA0) / ((4.0 * PI) * PI);\n  fb = eb / (l0 * l0);\n  delA = (cell(ci).polygonArea() / cell(ci).geta0()) - 1.0;\n  for (vi = 0; vi < nv; vi++)\n  {\n    vip2 = (vi + 2) % nv;\n    vip1 = (vi + 1) % nv;\n    vim1 = ((vi - 1) + nv) % nv;\n    vim2 = ((vi - 2) + nv) % nv;\n    kx = NDIM * (Mu.at(ci) + vi);\n    ky = (NDIM * (Mu.at(ci) + vi)) + 1;\n    kxp1 = NDIM * (Mu.at(ci) + vip1);\n    kyp1 = (NDIM * (Mu.at(ci) + vip1)) + 1;\n    kxp2 = NDIM * (Mu.at(ci) + vip2);\n    kyp2 = (NDIM * (Mu.at(ci) + vip2)) + 1;\n    lim2x = cell(ci).segment(vim2, 0);\n    lim2y = cell(ci).segment(vim2, 1);\n    lim1x = cell(ci).segment(vim1, 0);\n    lim1y = cell(ci).segment(vim1, 1);\n    lix = cell(ci).segment(vi, 0);\n    liy = cell(ci).segment(vi, 1);\n    lip1x = cell(ci).segment(vip1, 0);\n    lip1y = cell(ci).segment(vip1, 1);\n    lim1 = sqrt((lim1x * lim1x) + (lim1y * lim1y));\n    li = sqrt((lix * lix) + (liy * liy));\n    dlim1_dxi = lim1x / lim1;\n    dlim1_dyi = lim1y / lim1;\n    dli_dxip1 = lix / li;\n    dli_dyip1 = liy / li;\n    dli_dxi = -dli_dxip1;\n    dli_dyi = -dli_dyip1;\n    delim1 = (lim1 / l0) - 1.0;\n    deli = (li / l0) - 1.0;\n    Hl(kx, kx) = kl * ((dlim1_dxi * dlim1_dxi) + (dli_dxi * dli_dxi));\n    Hl(ky, ky) = kl * ((dlim1_dyi * dlim1_dyi) + (dli_dyi * dli_dyi));\n    Hl(kx, ky) = kl * ((dlim1_dxi * dlim1_dyi) + (dli_dxi * dli_dyi));\n    Hl(ky, kx) = Hl(kx, ky);\n    Hl(kx, kxp1) = (kl * dli_dxi) * dli_dxip1;\n    Hl(ky, kyp1) = (kl * dli_dyi) * dli_dyip1;\n    Hl(kx, kyp1) = (kl * dli_dxi) * dli_dyip1;\n    Hl(ky, kxp1) = (kl * dli_dyi) * dli_dxip1;\n    Hl(kxp1, kx) = Hl(kx, kxp1);\n    Hl(kyp1, ky) = Hl(ky, kyp1);\n    Hl(kyp1, kx) = Hl(kx, kyp1);\n    Hl(kxp1, ky) = Hl(ky, kxp1);\n    Sl(kx, kx) = fl * (((delim1 / lim1) * (1.0 - (dlim1_dxi * dlim1_dxi))) + ((deli / li) * (1.0 - (dli_dxi * dli_dxi))));\n    Sl(ky, ky) = fl * (((delim1 / lim1) * (1.0 - (dlim1_dyi * dlim1_dyi))) + ((deli / li) * (1.0 - (dli_dyi * dli_dyi))));\n    Sl(kx, ky) = (-fl) * ((((delim1 / lim1) * dlim1_dxi) * dlim1_dyi) + (((deli / li) * dli_dxi) * dli_dyi));\n    Sl(ky, kx) = Sl(kx, ky);\n    Sl(kx, kxp1) = (fl * (deli / li)) * ((dli_dxip1 * dli_dxip1) - 1.0);\n    Sl(ky, kyp1) = (fl * (deli / li)) * ((dli_dyip1 * dli_dyip1) - 1.0);\n    Sl(kx, kyp1) = ((fl * (deli / li)) * dli_dxip1) * dli_dyip1;\n    Sl(ky, kxp1) = ((fl * (deli / li)) * dli_dyip1) * dli_dxip1;\n    Sl(kxp1, kx) = Sl(kx, kxp1);\n    Sl(kyp1, ky) = Sl(ky, kyp1);\n    Sl(kyp1, kx) = Sl(kx, kyp1);\n    Sl(kxp1, ky) = Sl(ky, kxp1);\n    kapim1 = sqrt(pow(lim1x - lim2x, 2.0) + pow(lim1y - lim2y, 2.0)) / l0;\n    kapi = sqrt(pow(lix - lim1x, 2.0) + pow(liy - lim1y, 2.0)) / l0;\n    kapip1 = sqrt(pow(lip1x - lix, 2.0) + pow(lip1y - liy, 2.0)) / l0;\n    dkapim1_dxi = (lim1x - lim2x) / ((kapim1 * l0) * l0);\n    dkapim1_dyi = (lim1y - lim2y) / ((kapim1 * l0) * l0);\n    dkapi_dxip1 = (lix - lim1x) / ((kapi * l0) * l0);\n    dkapi_dyip1 = (liy - lim1y) / ((kapi * l0) * l0);\n    dkapi_dxi = (-2.0) * dkapi_dxip1;\n    dkapi_dyi = (-2.0) * dkapi_dyip1;\n    dkapip1_dxi = (lip1x - lix) / ((kapip1 * l0) * l0);\n    dkapip1_dyi = (lip1y - liy) / ((kapip1 * l0) * l0);\n    dkapip1_dxip1 = (-2.0) * dkapip1_dxi;\n    dkapip1_dyip1 = (-2.0) * dkapip1_dyi;\n    dkapip1_dxip2 = dkapip1_dxi;\n    dkapip1_dyip2 = dkapip1_dyi;\n    Hb(kx, kx) = eb * (((dkapim1_dxi * dkapim1_dxi) + (dkapi_dxi * dkapi_dxi)) + (dkapip1_dxi * dkapip1_dxi));\n    Hb(ky, ky) = eb * (((dkapim1_dyi * dkapim1_dyi) + (dkapi_dyi * dkapi_dyi)) + (dkapip1_dyi * dkapip1_dyi));\n    Hb(kx, ky) = eb * (((dkapim1_dxi * dkapim1_dyi) + (dkapi_dxi * dkapi_dyi)) + (dkapip1_dxi * dkapip1_dyi));\n    Hb(ky, kx) = Hb(kx, ky);\n    Hb(kx, kxp1) = eb * ((dkapi_dxi * dkapi_dxip1) + (dkapip1_dxi * dkapip1_dxip1));\n    Hb(ky, kyp1) = eb * ((dkapi_dyi * dkapi_dyip1) + (dkapip1_dyi * dkapip1_dyip1));\n    Hb(kx, kyp1) = eb * ((dkapi_dxi * dkapi_dyip1) + (dkapip1_dxi * dkapip1_dyip1));\n    Hb(ky, kxp1) = eb * ((dkapi_dyi * dkapi_dxip1) + (dkapip1_dyi * dkapip1_dxip1));\n    Hb(kx, kxp2) = (eb * dkapip1_dxi) * dkapip1_dxip2;\n    Hb(ky, kyp2) = (eb * dkapip1_dyi) * dkapip1_dyip2;\n    Hb(kx, kyp2) = (eb * dkapip1_dxi) * dkapip1_dyip2;\n    Hb(ky, kxp2) = (eb * dkapip1_dyi) * dkapip1_dxip2;\n    Hb(kxp1, kx) = Hb(kx, kxp1);\n    Hb(kyp1, ky) = Hb(ky, kyp1);\n    Hb(kxp1, ky) = Hb(ky, kxp1);\n    Hb(kyp1, kx) = Hb(kx, kyp1);\n    Hb(kxp2, kx) = Hb(kx, kxp2);\n    Hb(kyp2, ky) = Hb(ky, kyp2);\n    Hb(kyp2, kx) = Hb(kx, kyp2);\n    Hb(kxp2, ky) = Hb(ky, kxp2);\n    Sb(kx, kx) = fb * (((6.0 - ((l0 * dkapim1_dxi) * (l0 * dkapim1_dxi))) - ((l0 * dkapi_dxi) * (l0 * dkapi_dxi))) - ((l0 * dkapip1_dxi) * (l0 * dkapip1_dxi)));\n    Sb(ky, ky) = fb * (((6.0 - ((l0 * dkapim1_dyi) * (l0 * dkapim1_dyi))) - ((l0 * dkapi_dyi) * (l0 * dkapi_dyi))) - ((l0 * dkapip1_dyi) * (l0 * dkapip1_dyi)));\n    Sb(kx, ky) = (-eb) * (((dkapim1_dxi * dkapim1_dyi) + (dkapi_dxi * dkapi_dyi)) + (dkapip1_dxi * dkapip1_dyi));\n    Sb(ky, kx) = Sb(kx, ky);\n    Sb(kx, kxp1) = ((-2) * fb) * ((2.0 - ((l0 * dkapi_dxip1) * (l0 * dkapi_dxip1))) - ((l0 * dkapip1_dxi) * (l0 * dkapip1_dxi)));\n    Sb(ky, kyp1) = ((-2) * fb) * ((2.0 - ((l0 * dkapi_dyip1) * (l0 * dkapi_dyip1))) - ((l0 * dkapip1_dyi) * (l0 * dkapip1_dyi)));\n    Sb(kx, kyp1) = (-eb) * ((dkapi_dxi * dkapi_dyip1) + (dkapip1_dxi * dkapip1_dyip1));\n    Sb(ky, kxp1) = (-eb) * ((dkapi_dyi * dkapi_dxip1) + (dkapip1_dyi * dkapip1_dxip1));\n    Sb(kx, kxp2) = fb * (1.0 - ((l0 * dkapip1_dxi) * (l0 * dkapip1_dxi)));\n    Sb(ky, kyp2) = fb * (1.0 - ((l0 * dkapip1_dyi) * (l0 * dkapip1_dyi)));\n    Sb(kx, kyp2) = ((-eb) * dkapip1_dxi) * dkapip1_dyip2;\n    Sb(ky, kxp2) = ((-eb) * dkapip1_dyi) * dkapip1_dxip2;\n    Sb(kxp1, kx) = Sb(kx, kxp1);\n    Sb(kyp1, ky) = Sb(ky, kyp1);\n    Sb(kxp1, ky) = Sb(ky, kxp1);\n    Sb(kyp1, kx) = Sb(kx, kyp1);\n    Sb(kxp2, kx) = Sb(kx, kxp2);\n    Sb(kyp2, ky) = Sb(ky, kyp2);\n    Sb(kxp2, ky) = Sb(ky, kxp2);\n    Sb(kyp2, kx) = Sb(kx, kyp2);\n    Sa(kx, kyp1) = 0.5 * delA;\n    Sa(ky, kxp1) = (-0.5) * delA;\n    Sa(kyp1, kx) = Sa(kx, kyp1);\n    Sa(kxp1, ky) = Sa(ky, kxp1);\n    da_dxi = 0.5 * (cell(ci).vrel(vim1, 1) - cell(ci).vrel(vip1, 1));\n    da_dyi = 0.5 * (cell(ci).vrel(vip1, 0) - cell(ci).vrel(vim1, 0));\n    for (vj = vi; vj < nv; vj++)\n    {\n      vjp1 = (vj + 1) % nv;\n      vjm1 = ((vj - 1) + nv) % nv;\n      lx = NDIM * (Mu.at(ci) + vj);\n      ly = (NDIM * (Mu.at(ci) + vj)) + 1;\n      da_dxj = 0.5 * (cell(ci).vrel(vjm1, 1) - cell(ci).vrel(vjp1, 1));\n      da_dyj = 0.5 * (cell(ci).vrel(vjp1, 0) - cell(ci).vrel(vjm1, 0));\n      Ha(kx, lx) = da_dxi * da_dxj;\n      Ha(kx, ly) = da_dxi * da_dyj;\n      Ha(ky, lx) = da_dyi * da_dxj;\n      Ha(ky, ly) = da_dyi * da_dyj;\n      Ha(lx, kx) = Ha(kx, lx);\n      Ha(ly, kx) = Ha(kx, ly);\n      Ha(lx, ky) = Ha(ky, lx);\n      Ha(ly, ky) = Ha(ky, ly);\n    }\n\n  }\n\n  for (cj = ci + 1; cj < NCELLS; cj++)\n  {\n    if (contacts(ci, cj) > 0)\n    {\n      eij = 0.5 * (cell(ci).getkint() + cell(cj).getkint());\n      for (vi = 0; vi < nv; vi++)\n      {\n        mxi = NDIM * (Mu.at(ci) + vi);\n        myi = (NDIM * (Mu.at(ci) + vi)) + 1;\n        sij = 0.5 * ((cell(ci).getdel() * l0) + (cell(cj).getdel() * cell(cj).getl0()));\n        for (vj = 0; vj < cell(cj).getNV(); vj++)\n        {\n          dx = cell(ci).distance(cell(cj), vj, vi, 0);\n          dy = cell(ci).distance(cell(cj), vj, vi, 1);\n          dr = sqrt((dx * dx) + (dy * dy));\n          if (dr < sij)\n          {\n            kij = eij / (sij * dr);\n            h = dr / sij;\n            mxj = NDIM * (Mu.at(cj) + vj);\n            myj = (NDIM * (Mu.at(cj) + vj)) + 1;\n            dr_dxi = (-dx) / dr;\n            dr_dyi = (-dy) / dr;\n            Hvv(mxi, mxj) = (-eij) * (dr_dxi * dr_dxi);\n            Hvv(myi, myj) = (-eij) * (dr_dyi * dr_dyi);\n            Hvv(mxi, myj) = (-eij) * (dr_dxi * dr_dyi);\n            Hvv(myi, mxj) = (-eij) * (dr_dyi * dr_dxi);\n            Hvv(mxj, mxi) = Hvv(mxi, mxj);\n            Hvv(myj, myi) = Hvv(myi, myj);\n            Hvv(mxj, myi) = Hvv(myi, mxj);\n            Hvv(myj, mxi) = Hvv(mxi, myj);\n            Svv(mxi, mxj) = (kij * (1.0 - h)) * (dr_dyi * dr_dyi);\n            Svv(myi, myj) = (kij * (1.0 - h)) * (dr_dxi * dr_dxi);\n            Svv(mxi, myj) = ((-kij) * (1.0 - h)) * (dr_dxi * dr_dyi);\n            Svv(myi, mxj) = ((-kij) * (1.0 - h)) * (dr_dxi * dr_dyi);\n            Svv(mxj, mxi) = Svv(mxi, mxj);\n            Svv(myj, myi) = Svv(myi, myj);\n            Svv(mxj, myi) = Svv(myi, mxj);\n            Svv(myj, mxi) = Svv(mxi, myj);\n            Hvv(mxi, mxi) -= Hvv(mxi, mxj);\n            Hvv(myi, myi) -= Hvv(myi, myj);\n            Hvv(mxi, myi) -= Hvv(mxi, myj);\n            Hvv(myi, mxi) -= Hvv(myi, mxj);\n            Hvv(mxj, mxj) -= Hvv(mxi, mxj);\n            Hvv(myj, myj) -= Hvv(myi, myj);\n            Hvv(mxj, myj) -= Hvv(mxi, myj);\n            Hvv(myj, mxj) -= Hvv(myi, mxj);\n            Svv(mxi, mxi) -= Svv(mxi, mxj);\n            Svv(myi, myi) -= Svv(myi, myj);\n            Svv(mxi, myi) -= Svv(mxi, myj);\n            Svv(myi, mxi) -= Svv(myi, mxj);\n            Svv(mxj, mxj) -= Svv(mxi, mxj);\n            Svv(myj, myj) -= Svv(myi, myj);\n            Svv(mxj, myj) -= Svv(mxi, myj);\n            Svv(myj, mxj) -= Svv(myi, mxj);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/58"}
{"code": "for (unsigned int k = 0; k < sz[2]; k++)\n  for (unsigned int j = 0; j < sz[1]; j++)\n  for (unsigned int i = 0; i < sz[0]; i++)\n  if ((((i < 3) || (i >= (sz[0] - 3))) || ((j < 3) || (j >= (sz[0] - 3)))) || ((k < 3) || (k >= (sz[2] - 3))))\n  Du[IDX(i, j, k)] = u[IDX(i, j, k)];\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/48"}
{"code": "for (end_iter = omp_end_pragma_list.rbegin(); end_iter != omp_end_pragma_list.rend(); end_iter++)\n  removeStatement(*end_iter);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/src/frontend/SageIII/ompAstConstruction/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    C_n[i][j] = exp((-(pow(((i - (N / 2)) * L) / N, 2) + pow(((j - (N / 2)) * L) / N, 2))) / ((L * L) / 8));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/milestone-2/advection_simulation/1"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  src = edgeList->edges_array_src[i];\n  dest = edgeList->edges_array_dest[i];\n  row = getPartitionID(num_vertices, num_partitions, src);\n  col = getPartitionID(num_vertices, num_partitions, dest);\n  Partition_idx = (row * num_partitions) + col;\n  Edge_idx = __sync_fetch_and_add(&grid->partitions[Partition_idx].num_edges, 1);\n  grid->partitions[Partition_idx].edgeList->edges_array_src[Edge_idx] = edgeList->edges_array_src[i];\n  grid->partitions[Partition_idx].edgeList->edges_array_dest[Edge_idx] = edgeList->edges_array_dest[i];\n}\n\n", "pragma": "omp parallel for default(none) private(Edge_idx,i,row,col,src,dest,Partition_idx) shared(num_vertices, num_partitions,edgeList,grid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/grid/4"}
{"code": "for (i3 = 1; i3 <= ((n3 - 1) - 1); i3 += 1)\n{\n  for (i2 = 1; i2 <= ((n2 - 1) - 1); i2 += 1)\n  {\n    for (i1 = 1; i1 <= ((n1 - 1) - 1); i1 += 1)\n    {\n      s = s + (r[i3][i2][i1] * r[i3][i2][i1]);\n      a = fabs(r[i3][i2][i1]);\n      if (a > tmp)\n        tmp = a;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/26"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  A[i] = rand() % SIZE;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dudaeitelven/OpenMp/main/1"}
{"code": "for (int i = 0; i < (comm->size() * nthreads); ++i)\n{\n  copy(v, v + Random.state_size(), (ostream_iterator < uint_type) > ((vt_o, \" \")));\n  vt_o << endl;\n  v += Random.state_size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/OhmmsApp/RandomNumberControl/9"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  printf(\"b[%d] = %d\\n\", i, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/02for/1"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, SALTLEN, cur_salt->iterations, master[0], cur_salt->key_length, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    if (pem_decrypt(master[i], cur_salt->iv, cur_salt->ciphertext, cur_salt) == 0)\n      cracked[index + i] = 1;\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pem_fmt_plug/0"}
{"code": "for (i = 0; i < NODE_N; i++)\n{\n  for (j = 0; j < NODE_N; j++)\n    orders[i][j] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/16"}
{"code": "for (i = 1; i <= (_PB_N - 2); i++)\n{\n  for (j = 1; j <= (_PB_N - 2); j++)\n  {\n    A[i][j] = ((((((((A[i - 1][j - 1] + A[i - 1][j]) + A[i - 1][j + 1]) + A[i][j - 1]) + A[i][j]) + A[i][j + 1]) + A[i + 1][j - 1]) + A[i + 1][j]) + A[i + 1][j + 1]) / 9.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/seidel-2d/seidel-2d/0"}
{"code": "for (int i = 1; i < N; ++i)\n{\n  for (int j = 1; (j < N) && (result == 0); ++j)\n  {\n    for (int k = 1; k < N; ++k)\n    {\n      if (((i * i) == ((k * k) + (j * j))) && (((i + k) + j) == N))\n      {\n        result = (i * j) * k;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cyrillwork/EulerProject/tasks/task9/0"}
{"code": "for (i = 0; i < parN; i++)\n{\n  j *= STATE_N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/6"}
{"code": "for (int z = 1; z < numblocchi; z++)\n{\n  p[z] = malloc(16);\n}\n\n", "pragma": "omp parallel for num_threads ( NUMERO_TH_TEST )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/1"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  vector[i] = rand() % 10;\n  printf(\"%d \\n\", vector[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block2/task8/0"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  calc_force(i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment 3/many_body_problem/2"}
{"code": "for (i = 0; i < dataSet->m; i++)\n{\n  for (j = 0; j < dataSet->p; j++)\n  {\n    dataSet->B[(i * dataSet->p) + j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/Parallax/docs/assignment-2/matrix-multiplication/matmul/4"}
{"code": "for (row = xoffset; row < (xoffset + myxsize); row++)\n{\n  for (col = yoffset; col < (yoffset + myysize); col++)\n  {\n    u[0][row + 1][col + 1] = s[0][row][col];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/1"}
{"code": "for (i = 0; i < length; i++)\n{\n  printf(\"index:%d value:%d\\n\", i, A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW1/stockwell_hw1_prefix_sums/3"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  tmp[i] = 0;\n  y[i] = 0;\n  for (j = 0; j < 2048; j++)\n  {\n    tmp[i] = (A[(i * 2048) + j] * x[j]) + tmp[i];\n    y[i] = (B[(i * 2048) + j] * x[j]) + y[i];\n  }\n\n  y[i] = (43532.0f * tmp[i]) + (12313.0f * y[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/6"}
{"code": "for (int i = offset; i < (offset + length); i++)\n{\n  red += a[i] * b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:red)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGMultiOpenMPTarget/4"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    energy[index] = u[index] / density[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_solver_methods/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,j1 ,j ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/180"}
{"code": "for (fase = 0; fase < TOPEF; fase++)\n{\n  if ((fase % 2) == 0)\n    for (i = 1; i < TOPEF; i += 2)\n  {\n    if (v2[i - 1] > v2[i])\n    {\n      tmp = v2[i - 1];\n      v2[i - 1] = v2[i];\n      v2[i] = tmp;\n    }\n\n  }\n\n  else\n    for (i = 1; i < (TOPEF - 1); i += 2)\n  {\n    if (v2[i] > v2[i + 1])\n    {\n      tmp = v2[i + 1];\n      v2[i + 1] = v2[i];\n      v2[i] = tmp;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/2"}
{"code": "for (j = 0; j <= (len - 1); j += 1)\n{\n  a[i][j] = 0.5;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB003-antidep2-orig-yes/1"}
{"code": "for (long j = 0; j < N; j++)\n{\n  int sgn = 1;\n  for (long i = 0; i < M; i++)\n  {\n    for (long k = 0; k < M; k++)\n    {\n      local_val += (sgn * (j + i)) * (j + k);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/magland/openmp_performance_test/main/2"}
{"code": "for (j = 0; j < size_new_seq; j++)\n{\n  addMutantsEachSeq(seq2, size_seq2, &new_seq2, &j, &scores);\n  scores->score = compareDiffrentLenSequences(weights, seq1, new_seq2, size_seq2, &scores);\n  if (scores->score > maxScore)\n  {\n    maxScore = scores->score;\n    mute_loc = scores->mute_loc;\n    offset = scores->offset;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/7"}
{"code": "for (int j = 1; j < dataSize; j++)\n{\n  key = userFitnessData[j];\n  i = j - 1;\n  while ((i >= 0) && (userFitnessData[i] > key))\n  {\n    numberOfComparison++;\n    numberOfSwaps++;\n    userFitnessData[i + 1] = userFitnessData[i];\n    i = i - 1;\n  }\n\n  numberOfComparison++;\n  userFitnessData[i + 1] = key;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dikshay/WearableFitnessCraze/Code/Commands/2"}
{"code": "for (i = 0; i < 8; ++i)\n{\n  histo[i] = malloc(256 * (sizeof(long)));\n  memset(histo[i], 0, 256 * (sizeof(long)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_creative/1"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (int i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_bfs/bfs/3"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  finalProducts[i].currentCluster = tempProducts[i].currentCluster;\n  finalProducts[i].prevCluster = tempProducts[i].prevCluster;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MichaelSabbah/K-MEANS-parallel-project/K-MEANS_Parallel/K-MEANS/13"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    for (k = 0; k < n; ++k)\n    {\n      t[i][j] = omp_get_thread_num();\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a, b, c) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aryanchandrakar/Parallel_Distributed_Computing/open_mp/matrix_multiplication_multithreaded/0"}
{"code": "for (cpt = 0; cpt <= 1000; cpt++)\n{\n  trouve = 0;\n  while (!trouve)\n  {\n    for (j = 2; (j * j) <= i; j++)\n    {\n      if ((i % j) == 0)\n      {\n        break;\n      }\n\n    }\n\n    if ((j * j) > i)\n    {\n      trouve = 1;\n      printf(\"%d\\n\", i);\n    }\n\n    i += 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/faten96/MPI_OpenMP/seq_omp/1"}
{"code": "for (i = 0; i < 10; ++i)\n  main1();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp-loop01/9"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericParticles[i]->ComputeNewNeighboursHistoricalData(temp_neighbours_ids, temp_neighbour_elastic_contact_forces);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/10"}
{"code": "for (k = 0; k < N; k++)\n{\n  tmp += a[i][k] * b[j][k];\n}\n\n", "pragma": "\t\t\t\t#pragma omp for schedule(static, chunk) reduction (+:tmp) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnx4015/CompParaleDist/Code/OpenMPCodeOptimization/multParallelk/0"}
{"code": "for (currentImage = 0; currentImage < 10; currentImage++)\n{\n  printf(\"Imagen %d\\n\", currentImage + 1);\n  processImages(nameOfImages[currentImage], nameOfNewImages[currentImage]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/5"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"%d, \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task7/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    printf(\"%s%d[%d][%d]:%f  \", name, dev, i, j, A[(i * m) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_ompacc_mdev/1"}
{"code": "for (j = 0; j < n; j++)\n{\n  if ((((i == 0) || (i == (n - 1))) || (j == 0)) || (j == (n - 1)))\n  {\n    un[i][j] = 0.;\n  }\n  else\n  {\n    un[i][j] = ((2 * uc[i][j]) - uo[i][j]) + ((VSQR * (dt * dt)) * (((((((uc[i][j - 1] + uc[i][j + 1]) + uc[i + 1][j]) + uc[i - 1][j]) + (0.25 * (((uc[i - 1][j - 1] + uc[i + 1][j - 1]) + uc[i - 1][j + 1]) + uc[i + 1][j + 1]))) - (5 * uc[i][j])) / (h * h)) + f(pebs[i][j], t)));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mnsekh111/OpenMP-ACC/lake/lake_inner_dynamic/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  M[i] = (int *) malloc(size * (sizeof(int)));\n  N[i] = (int *) malloc(size * (sizeof(int)));\n  W[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "omp parallel for private(i), shared(M), shared(N), shared(W)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmotel/zjp-labs/lab6/zad2/main/0"}
{"code": "for (u32 i = 0; i < ((b->capacity / 32) + 1); i += 1)\n{\n  b->map[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chibinz/ParallelBFS/src/bitmap/0"}
{"code": "for (uint i = 0; i < (1L << BLOOM_SIZE); i++)\n{\n  h_isWordInProfileHash[i] = 0x0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/compute-score-omp/main/2"}
{"code": "for (int i = 0; i < cantidad_intervalos; i++)\n{\n  x = (i + 0.5) * base_intervalo;\n  fdx = 4 / (1 + (x * x));\n  acum += fdx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Roberto09/Multiprocessors-Course/openmp_for/main/0"}
{"code": "for (i = N - 1; i >= 0; i--)\n{\n  for (j = i + 1; j <= N; j++)\n  {\n    Q[i][j] = Q[i][j - 1];\n    for (k = 0; k < ((j - i) - l); k++)\n    {\n      Qbp[k + i][j] = (Q[(k + i) + 1][j - 1] * ERT) * paired(k + i, j - 1);\n      Q[i][j] += Q[i][k + i] * Qbp[k + i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mcc_traco/4"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleType[i] == wall) || (particleBC[i] == surface))\n  {\n    double PNDup = 0.0;\n    double PNDdo = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                PNDup += pndi[j] * wS;\n                PNDdo += wS;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    acc[i * 3] = PNDup;\n    acc[(i * 3) + 1] = PNDdo;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/42"}
{"code": "for (i = 0; i < lines; i++)\n{\n  matrix[i] = (char *) malloc(columns * (sizeof(char)));\n  if (matrix[i] == 0)\n  {\n    for (j = 0; j < i; j++)\n    {\n      free(matrix[j]);\n    }\n\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexmustata19/C-OpenMP-Game-of-life/g_omp/6"}
{"code": "for (int i = 0; i < (n - index); i++)\n{\n  for (int j = 0; j < index; j++)\n  {\n    a[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/cpu_parallel_convolution/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  d.set(i, i);\n  d.atomic(i);\n  array2[i] += d.get(i);\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hpc-sandbox/graph-dev/test-class-instance-offload/test/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  compute_force_on_particle(&n->children[i], p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kawtar921/nbody/nbody_omp/nbody_barnes_hut/1"}
{"code": "for (int i = size - 1; i >= 0; i--)\n{\n  if (vet[i])\n  {\n    out |= 1;\n  }\n\n  if (i > 0)\n    out <<= 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danilo94/Genetic-Regulator-Network---With-OpenMP/main/3"}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char passwordBuf[(19 * 2) + 2];\n  int len;\n  len = enc_to_utf16((UTF16 *) passwordBuf, 19, (UTF8 *) saved_key[index], strlen(saved_key[index]));\n  if (len < 0)\n    len = strlen16((UTF16 *) passwordBuf);\n\n  len <<= 1;\n  if (cur_salt->version == 0)\n  {\n    SHA_CTX ctx;\n    SHA1_Init(&ctx);\n    SHA1_Update(&ctx, cur_salt->esalt, 16);\n    SHA1_Update(&ctx, passwordBuf, len);\n    SHA1_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n  else\n  {\n    SHA256_CTX ctx;\n    SHA256_Init(&ctx);\n    SHA256_Update(&ctx, cur_salt->esalt, 16);\n    SHA256_Update(&ctx, passwordBuf, len);\n    SHA256_Final((unsigned char *) crypt_out[index], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/episerver_fmt_plug/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (percentDiff(y[i], y_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/2"}
{"code": "for (int i = 0; i < buf_size; ++i)\n  buffer[i] = max_value - buffer[i];\n\n", "pragma": "omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tdhooks/hybrid-simd/src/hybrid_simd/0"}
{"code": "for (int i = 0; i < _quentityElement; i++)\n{\n  _vecOne[i].x = (rand() % _quentityElement) + 0;\n  _vecOne[i].y = (rand() % _quentityElement) + 0;\n  _vecSecond[i].x = (rand() % _quentityElement) + 0;\n  _vecSecond[i].y = (rand() % _quentityElement) + 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgavrisyuk/OpenMP/main/0"}
{"code": "for (i = 0; i < (((2048 / 1) + 2) / 2); i++)\n{\n  for (j = 0; j < ((2048 / NODESY) + 2); j++)\n  {\n    if (whites[i][j].isGhost == 1)\n    {\n      spin = whites[i][j].data;\n      spin_neigh_n = blacks[i][j].data;\n      spin_neigh_e = blacks[i][j + 1].data;\n      spin_neigh_w = blacks[i][j - 1].data;\n      spin_neigh_s = blacks[i + ((2 * (j % 2)) - 1)][j].data;\n      E += (((spin == spin_neigh_n) + (spin == spin_neigh_e)) + (spin == spin_neigh_w)) + (spin == spin_neigh_s);\n      Mt[spin] += 1;\n      spin = blacks[i][j].data;\n      Mt[spin] += 1;\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:E) schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/67"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  tmp[i] = 0;\n  y[i] = 0;\n  for (j = 0; j < 1024; j++)\n  {\n    tmp[i] = (A[(i * 1024) + j] * x[j]) + tmp[i];\n    y[i] = (B[(i * 1024) + j] * x[j]) + y[i];\n  }\n\n  y[i] = (43532.0f * tmp[i]) + (12313.0f * y[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/9"}
{"code": "for (int i = 0; i < number_threads; i++)\n{\n  count_d_gamma_per_thread[i] = (panel_number_per_thread[i] * max_per_panel) + index_per_panel[i];\n  number_aged_out += number_aged_out_per_thread[i];\n  total_d_gamma += count_d_gamma_per_thread[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/8"}
{"code": "for (j = 0; j < 15; j++)\n{\n  if (line[j] == '(')\n  {\n    continue;\n  }\n\n  if (line[j] == ',')\n  {\n    flag = 1;\n    continue;\n  }\n\n  if (line[j] == ')')\n  {\n    break;\n  }\n\n  if (!flag)\n  {\n    current_x[jx++] = line[j];\n  }\n  else\n  {\n    current_y[jy++] = line[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OmarKhaledm21/K-MEANS_Clustering-C_OpenMP-/K_MEANS_CLUSTERING/4"}
{"code": "for (i = 0; i < ORD; i++)\n{\n  dotp = dotp + (v1[i] * v2[i]);\n}\n\n", "pragma": "        #pragma omp for reduction(+:dotp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/babreu-ncsa/IntroToOpenMP/Ex3_Reductions/dotprod/cpp/solution/dotprod_omp/0"}
{"code": "for (i = 0; i < ncolumns; i++)\n{\n  for (j = 0; j < ncolumns; j++)\n    temp[j] = v[index[j]][i];\n\n  for (j = 0; j < ncolumns; j++)\n    v[j][i] = temp[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/24"}
{"code": "for (double i = 0; i < A.size(); i++)\n{\n  A[i] = (i + range3(e)) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tonyz0x0/parallel-computing/matrix-multiplication-openmp/1"}
{"code": "for (i = 0; i < (*myProductsSize); i++)\n{\n  recvProduct(&(*myProducts)[i], MPI_Product, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/1"}
{"code": "for (int it = 0; it < learning_set_count; ++it)\n{\n  ((((cout << \"to: \") << learning_set[it].str()) << \" is: \") << learning_set[it].dist) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main_fast2/2"}
{"code": "for (int i = 0; i < inum; i++)\n{\n  ix[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  iy[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  iz[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aidw-omp/main/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  if ((line[i] >= 9) && (line[i] <= 19))\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/matrix/2"}
{"code": "for (int i = 0; i < Nx; i++)\n  un1[i] = (double *) malloc(Ny * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/4"}
{"code": "for (i = 1; i < dim; i++)\n  q += fabs(mat[i][0] / mat[i][i]);\n\n", "pragma": "omp for reduction(+:q)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jacobi_column/jacobi_omp_col/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  cityTaken[ant][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/8"}
{"code": "for (col = 0; col < public.in_mod_cols; col++)\n{\n  #pragma loop name kernel#0#0\n  for (row = 0; row < public.in_mod_rows; row++)\n  {\n    ori_row = ((private.d_Row[private.point_no] - 25) + row) - 1;\n    ori_col = ((private.d_Col[private.point_no] - 25) + col) - 1;\n    ori_pointer = (ori_col * public.frame_rows) + ori_row;\n    d_in[(col * public.in_mod_rows) + row] = public.d_frame[ori_pointer];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/3"}
{"code": "for (unsigned int i = 0; i < ((L / 1) + 2); i++)\n  gre[i] = got[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/41"}
{"code": "for (j = 0; j < dataSet.p; j++)\n{\n  sum = 0;\n  for (k = 0; k < dataSet.m; k++)\n  {\n    sum += dataSet.A[(i * dataSet.m) + k] * dataSet.B[(k * dataSet.p) + j];\n  }\n\n  dataSet.C[(i * dataSet.p) + j] = sum;\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 200)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/Parallax/docs/assignment-2/matrix-multiplication/matmul/1"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  while (!is_ql_queue_empty(invite_ql, i))\n  {\n    invitation *invite = dequeue(invite_ql, i);\n    min_invitation(&data->invite, invite);\n  }\n\n  if ((data->invite.y == data->default_leader) && (data->invite.x == data->leader))\n    data->committee = data->leader;\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/4"}
{"code": "for (int i = 0; i < timePoints.size(); i++)\n{\n  if (ISF[i] < exp(-1))\n  {\n    tao = timePoints[i];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/108"}
{"code": "for (int k = 0; k < n; k++)\n{\n  t1 = mat[k][k];\n  for (int j = k + 1; j < n; j++)\n  {\n    mat[k][j] /= t1;\n  }\n\n  mat[k][k] = 1.0;\n  for (int t_id = 0; t_id < THREAD_NUM; t_id++)\n  {\n    sem_post(&sem_workerstart[t_id]);\n  }\n\n  for (int t_id = 0; t_id < THREAD_NUM; t_id++)\n  {\n    sem_wait(&sem_main);\n  }\n\n  for (int t_id = 0; t_id < THREAD_NUM; t_id++)\n  {\n    sem_post(&sem_workerend[t_id]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/16"}
{"code": "for (i = 0; i < idf; i++)\n{\n  double dx = xf[i][0] - xv[0];\n  double dy = xf[i][1] - xv[1];\n  double d2 = (dx * dx) + (dy * dy);\n  double d = sqrt(d2);\n  (*zp)[i][0] = d;\n  (*zp)[i][1] = atan2(dy, dx) - particle->xv[2];\n  pi_to_pi((*zp)[i], 2, 1);\n  (*Hv)[i][0][0] = (-dx) / d;\n  (*Hv)[i][0][1] = (-dy) / d;\n  (*Hv)[i][0][2] = 0;\n  (*Hv)[i][1][0] = dy / d2;\n  (*Hv)[i][1][1] = (-dx) / d2;\n  (*Hv)[i][1][2] = -1;\n  (*Hf)[i][0][0] = dx / d;\n  (*Hf)[i][0][1] = dy / d;\n  (*Hf)[i][1][0] = (-dy) / d2;\n  (*Hf)[i][1][1] = dx / d2;\n  (*Sf)[i][0][0] = (((*Hf)[i][0][0] * ((Pf[0][0] * (*Hf)[i][0][0]) + (Pf[0][1] * (*Hf)[i][0][1]))) + ((*Hf)[i][0][1] * ((Pf[1][0] * (*Hf)[i][0][0]) + (Pf[1][1] * (*Hf)[i][0][1])))) + R[0][0];\n  (*Sf)[i][0][1] = (((*Hf)[i][0][0] * ((Pf[0][0] * (*Hf)[i][1][0]) + (Pf[0][1] * (*Hf)[i][1][1]))) + ((*Hf)[i][0][1] * ((Pf[1][0] * (*Hf)[i][1][0]) + (Pf[1][1] * (*Hf)[i][1][1])))) + R[0][1];\n  (*Sf)[i][1][0] = (((*Hf)[i][1][0] * ((Pf[0][0] * (*Hf)[i][0][0]) + (Pf[0][1] * (*Hf)[i][0][1]))) + ((*Hf)[i][1][1] * ((Pf[1][0] * (*Hf)[i][0][0]) + (Pf[1][1] * (*Hf)[i][0][1])))) + R[1][0];\n  (*Sf)[i][1][1] = (((*Hf)[i][1][0] * ((Pf[0][0] * (*Hf)[i][1][0]) + (Pf[0][1] * (*Hf)[i][1][1]))) + ((*Hf)[i][1][1] * ((Pf[1][0] * (*Hf)[i][1][0]) + (Pf[1][1] * (*Hf)[i][1][1])))) + R[2][2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/fast-slam/simulator/7"}
{"code": "for (int j = this->population - 1; j >= 0; --j)\n{\n  generateRectanglesForImages(this->imagesRectangles + (j * MAX_NUMBER_OF_RECTANGLES));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/1"}
{"code": "for (int i = 0; i < 7; ++i)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/clang/test/OpenMP/tile_messages/0"}
{"code": "for (i = 0; i < n; i++)\n  setB[i] = malloc((I + 1) * (sizeof(char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tassosblackg/HammingDistance/HD_openmpA/1"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(stdout, \"%-14u \", pageRankCorrelationStats_array[x].intersection);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/22"}
{"code": "for (i = 0; i < N; ++i)\n{\n  a[i] += b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vibhatha/OpenMP/code/exp1/OpenMPExamples/6"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"updating aptr[%d] addr:%p\\n\", i, &aptr[i]);\n  aptr[i] = i;\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom: aptr[0:N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/alignedattribute/alignedattribute/0"}
{"code": "for (y = env_height - 1; y >= 0; y--)\n{\n  free(environment[y]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/9"}
{"code": "for (i = 0; i < max_prime; i++)\n{\n  if (static_prime_array[i] != dynamic_prime_array[i])\n  {\n    printf(\"Unequal arrays at %lld\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lukas783/ParallelPrimes/Sieves/2"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA1][32];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 0);\n  }\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    cracked[index + i] = vmx_decrypt(cur_salt, master[i], cur_salt->blob);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vmx_fmt_plug/1"}
{"code": "for (i = 1; i <= n; ++i)\n{\n  remainder = 1;\n  for (digit = 0; (digit < (d + 11)) && remainder; ++digit)\n  {\n    div = remainder / i;\n    mod = remainder % i;\n    digits[digit] += div;\n    remainder = mod * 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonardocreatus/Progama-oParalela-OpenMP/seq/0"}
{"code": "for (int i = 0; i < (pos - 1); i++)\n  cout << \"=\";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markub3327/MazeSolver_GA/main/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"%d \", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Constructs/atomic_construct/1"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  eval_multi_UBspline_3d_s(multi_spline, x, y, z, multi_vals);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/2"}
{"code": "for (iterator = 0; iterator < 100; iterator++)\n{\n  count1 = increment_counter();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/19"}
{"code": "for (int i = 0; i < R; i++)\n{\n  for (int j = 0; j < C; j++)\n  {\n    t_res[(i * C) + j] = res[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/main/3"}
{"code": "for (k = 0; k < V; k++)\n{\n  for (i = 0; i < V; i++)\n  {\n    unsigned short distIK = graph[i][k];\n    if (distIK == infinity)\n      continue;\n\n    for (j = 0; j < V; j++)\n    {\n      if (graph[i][j] > (distIK + graph[k][j]))\n      {\n        graph[i][j] = distIK + graph[k][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/2"}
{"code": "for (i = 0; i < n; ++i)\n{\n  cblas_dgemv(CblasRowMajor, CblasNoTrans, n, n, 1, A, n, &M(B, i, 0, 1), n, 0, &M(C, i, 0, 1), n);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amerinor01/Practica4-HPC/src/esqueleto/0"}
{"code": "for (int i = 0; i < vettore->size(); i++)\n  punti.push_back(vettore->at(i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/francescobongini/Kmeans/Kmeans/Kmeans/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    (cout << mat[i][j]) << \"\\t\";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/priyanka2802/ParallelLUFactorization/RBParLU/2"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  fprintf(stderr, \"%0.2lf \", A[i][j]);\n  if ((((i * n) + j) % 20) == 0)\n  {\n    fprintf(stderr, \"\\n\");\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/polyopt/jacobi-2d-imper_orig_tileonly_size16_tile_8_2_1/2"}
{"code": "for (i = 1; i < nProcesses; i++)\n{\n  int start = (i == 1) ? (0) : (((i - 1) * (heigth / num_workers)) - 1);\n  int end = (i == num_workers) ? (heigth - 1) : (i * (heigth / num_workers));\n  start_send_list[i] = start;\n  end_send_list[i] = end;\n  start_recv_list[i] = (i == 1) ? (start) : (start + 1);\n  end_recv_list[i] = (i == num_workers) ? (end) : (end - 1);\n  dimensions[i] = ((end - start) + 1) * width;\n  dimensions[i] = (type == '5') ? (dimensions[i]) : (3 * dimensions[i]);\n  dimensiune_line = dimensions[i] / ((end - start) + 1);\n  if (max_dimension < dimensions[i])\n    max_dimension = dimensions[i];\n\n  unsigned char *buffer;\n  int dimension = dimensions[i];\n  unsigned char *buff = preparePackage(&input, start, end + 1);\n  MPI_Ssend(buff, dimension, (MPI_Datatype) 0x4c000102, i, 0, 1);\n  free(buff);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/13"}
{"code": "for (i = 0; i < (k + 1); i++)\n{\n  count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tjj5036/kcore-openmp/parallel_kcore/1"}
{"code": "for (i = 0; i < length; i++)\n  for (j = 0; j < length; j++)\n{\n  c[i][j] = (i * j) % 2;\n  W[i][j] = (((DATA_TYPE) i) - j) / length;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/solvers/dynprog/dynprog/2"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = forcing[i][j][k][m];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/30"}
{"code": "for (int i = 0; i < kBuckets; i++)\n{\n  omp_destroy_lock(&histogram_locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olszewskip/openmp_notes/locks0/3"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  int a[2];\n  double b[9];\n  a[0] = i;\n  a[1] = particleType[i];\n  b[0] = pos[i * 3];\n  b[1] = pos[(i * 3) + 1];\n  b[2] = pos[(i * 3) + 2];\n  b[3] = vel[i * 3];\n  b[4] = vel[(i * 3) + 1];\n  b[5] = vel[(i * 3) + 2];\n  b[6] = press[i];\n  b[7] = pressAverage[i] / iterOutput;\n  b[8] = pndi[i];\n  fprintf(fp, \" %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf\\n\", a[0], a[1], b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);\n  pressAverage[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/96"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = b[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utwente-fmt/vercors/examples/openmp/copy-spec/0"}
{"code": "for (i = 1; i < numVertices; ++i)\n{\n  vertex_cnt[i] += vertex_cnt[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iMeanHow/OpenMP/Radix/src/sort/2"}
{"code": "for (int i = 0; i < zSize; i++)\n{\n  T z = acc_z[i];\n  size_t low = 0;\n  size_t high = n;\n  while ((high - low) > 1)\n  {\n    size_t mid = low + ((high - low) / 2);\n    if (z < acc_a[mid])\n      high = mid;\n    else\n      low = mid;\n\n  }\n\n  acc_r[i] = low;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bsearch-omp/main/0"}
{"code": "for (int i = 0; i < bar(j); i++)\n  for (int j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/71"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if ((arr[i] % 2) == 0)\n    e++;\n  else\n    o++;\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) shared(e, o)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Arrays/array_evenodd_count/0"}
{"code": "for (uint p = 0; p < length; p++)\n{\n  cCoords.Set(p, currentCoords[startAtom + p]);\n  MolCharge.push_back(thisKind.AtomCharge(p) * lambdaCoef);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/7"}
{"code": "for (int a = 0; a < numtiles; a++)\n{\n  for (int b = 0; b < numtiles; b++)\n  {\n    double A[subsize * subsize];\n    double B[subsize * subsize];\n    for (int i = 0; i < numtiles; i++)\n    {\n      int idx = 0;\n      for (int j = 0; j < subsize; j++)\n      {\n        for (int k = 0; k < subsize; k++)\n        {\n          A[idx] = ptA[((((a * subsize) + j) * length) + (i * subsize)) + k];\n          B[idx] = ptB[((((i * subsize) + j) * length) + (b * subsize)) + k];\n          idx++;\n        }\n\n      }\n\n      for (int l = 0; l < subsize; l++)\n      {\n        for (int m = 0; m < subsize; m++)\n        {\n          double sum = 0.0;\n          for (int n = 0; n < subsize; n++)\n          {\n            sum += A[(l * subsize) + n] * B[(n * subsize) + m];\n          }\n\n          ptC[((((a * subsize) + l) * length) + (b * subsize)) + m] += sum;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JerryHu1994/CS-759-High-Performance-Computing/HW06/problem1B/0"}
{"code": "for (int i = 0; i < (*w); i++)\n{\n  (*gauss_Kernel)[i] = exp((((-1) * (i - pw)) * (i - pw)) / ((2 * sigma) * sigma));\n  sum += (*gauss_Kernel)[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcoisgood/High-Performance-Computing/3.Canny-Edge-Detector with MPI&openMP+MPI)/openMP+MPI/canny_edge_Mix/3"}
{"code": "for (; i < n; i++)\n{\n  result += (a[i] - b[i]) * (a[i] - b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tinyik/Vector-Optimization/calcDepthOptimized/3"}
{"code": "for (train_counter = 0; train_counter < train_data.n; train_counter++)\n{\n  train_j = train_counter * image_size;\n  z = (px = (px_sum = 0));\n  while (z < image_size)\n  {\n    px = test_data.img[test_j + z] - train_data.img[train_j + z];\n    px_sum += px * px;\n    ++z;\n  }\n\n  if (px_sum < kk[KV - 1].dst)\n  {\n    kk[KV - 1].dst = px_sum;\n    kk[KV - 1].lbl = train_data.lbl[train_counter];\n    qsortk(kk, 0, KV - 1);\n  }\n\n}\n\n", "pragma": "omp for private(train_counter, train_j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xbasics/knn_openmp_mnist/knn_openmp/0"}
{"code": "for (i = 1; i < (subprob_size - 1); i++)\n{\n  j = subprob_size - 1;\n  b[i][j] = 0.2 * ((((a[i][j] + a[i - 1][j]) + a[i + 1][j]) + a[i][j - 1]) + rlcbuff[i]);\n  if (fabs(b[i][j] - a[i][j]) > maxdiff)\n    maxdiff = fabs(b[i][j] - a[i][j]);\n\n}\n\n", "pragma": "omp parallel for reduction(max:maxdiff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/11"}
{"code": "for (int row = 0; row < 16; row++)\n  for (int col = 0; col < 16; col++)\n{\n  for (int e = 0; e < 16; ++e)\n    Cs[row][col] += As[row][e] * Bs[e][col];\n\n}\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/gridify-3/1"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  a[x] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitor_device/0"}
{"code": "for (int i = 0; i < 10; i++)\n  fact = fact * (i + 1);\n\n", "pragma": "omp parallel for reduction(*:fact)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/serial code time taken/0"}
{"code": "for (int k = 0; k < size; ++k)\n{\n  for (int i = 0; i < size; ++i)\n  {\n    for (int j = 0; j < size; ++j)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "      #pragma omp parallel for shared(A, B, C) num_threads(count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abelidze/cluster-parallel/task05.14.03.2019/task/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  jm1 = j - 1;\n  jp1 = j + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (ty2 * (ue[2][jp1] - ue[2][jm1]))) + (dy1ty1 * ((ue[0][jp1] - (2.0 * ue[0][j])) + ue[0][jm1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (ty2 * ((ue[1][jp1] * buf[2][jp1]) - (ue[1][jm1] * buf[2][jm1])))) + (yycon2 * ((buf[1][jp1] - (2.0 * buf[1][j])) + buf[1][jm1]))) + (dy2ty1 * ((ue[1][jp1] - (2.0 * ue[1][j])) + ue[1][jm1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (ty2 * (((ue[2][jp1] * buf[2][jp1]) + (c2 * (ue[4][jp1] - q[jp1]))) - ((ue[2][jm1] * buf[2][jm1]) + (c2 * (ue[4][jm1] - q[jm1])))))) + (yycon1 * ((buf[2][jp1] - (2.0 * buf[2][j])) + buf[2][jm1]))) + (dy3ty1 * ((ue[2][jp1] - (2.0 * ue[2][j])) + ue[2][jm1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (ty2 * ((ue[3][jp1] * buf[2][jp1]) - (ue[3][jm1] * buf[2][jm1])))) + (yycon2 * ((buf[3][jp1] - (2.0 * buf[3][j])) + buf[3][jm1]))) + (dy4ty1 * ((ue[3][jp1] - (2.0 * ue[3][j])) + ue[3][jm1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (ty2 * ((buf[2][jp1] * ((c1 * ue[4][jp1]) - (c2 * q[jp1]))) - (buf[2][jm1] * ((c1 * ue[4][jm1]) - (c2 * q[jm1])))))) + ((0.5 * yycon3) * ((buf[0][jp1] - (2.0 * buf[0][j])) + buf[0][jm1]))) + (yycon4 * ((cuf[jp1] - (2.0 * cuf[j])) + cuf[jm1]))) + (yycon5 * ((buf[4][jp1] - (2.0 * buf[4][j])) + buf[4][jm1]))) + (dy5ty1 * ((ue[4][jp1] - (2.0 * ue[4][j])) + ue[4][jm1]));\n}\n\n", "pragma": "omp parallel for private (jp1,jm1,j) firstprivate (ty2,yycon1,yycon2,yycon3,yycon4,yycon5,dy1ty1,dy2ty1,dy3ty1,dy4ty1,dy5ty1,c1,c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/19"}
{"code": "for (j = 1; j <= npoints; j++)\n{\n  if ((((first + j) - 1) == 1) || (((first + j) - 1) == 400000))\n    newval[j] = 0.0;\n  else\n    newval[j] = ((2.0 * values[j]) - oldval[j]) + (sqtau * ((values[j - 1] - (2.0 * values[j])) + values[j + 1]));\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lk-2020/CFiles/concurrent_wave_testThreads/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  if ((x[i] >= 2.0) && (x[i] <= 4.0))\n    u[i][0] = sin(3.14159265358979323846 * x[i]);\n  else\n    u[i][0] = 0;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe1/Tsouros_exe1/2"}
{"code": "for (int i = 0; i < table_size; i++)\n{\n  int ixj = i ^ j;\n  if (i < ixj)\n  {\n    bool f = (i & k) == 0;\n    int t1 = table[i];\n    int t2 = table[ixj];\n    if (compare_rotations((f) ? (t2) : (t1), (f) ? (t1) : (t2), genome, n))\n    {\n      table[i] = t2;\n      table[ixj] = t1;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(blockSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bwt-omp/bwt/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Row %u : %u \\n\", i, rsum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab4-Matrix_Sums/rowsum/3"}
{"code": "for (int i = apart; i <= len; i++)\n{\n  output[i] += read[i - apart];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robfarr/openmp-prefix-sum/main/0"}
{"code": "for (i1 = 0; i1 < (mm1 - 1); i1++)\n{\n  u[(2 * i3) + 1][2 * i2][2 * i1] = u[(2 * i3) + 1][2 * i2][2 * i1] + (0.5 * z2[i1]);\n  u[(2 * i3) + 1][2 * i2][(2 * i1) + 1] = u[(2 * i3) + 1][2 * i2][(2 * i1) + 1] + (0.25 * (z2[i1] + z2[i1 + 1]));\n}\n\n", "pragma": "omp parallel for firstprivate(mm1 ,u ,i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/10"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  dky = dny * ((float) k);\n  at1 = (ci2 * crealf(ffc[k])) * cimagf(ffc[k]);\n  at2 = dky * at1;\n  zt1 = (-cimagf(cu[2 + (3 * k)])) + (crealf(cu[2 + (3 * k)]) * _Complex_I);\n  zt2 = (-cimagf(cu[3 * k])) + (crealf(cu[3 * k]) * _Complex_I);\n  bxy[3 * k] = at2 * zt1;\n  bxy[1 + (3 * k)] = zero;\n  bxy[2 + (3 * k)] = (-at2) * zt2;\n  bxy[3 * k1] = zero;\n  bxy[1 + (3 * k1)] = zero;\n  bxy[2 + (3 * k1)] = zero;\n  wp += at1 * (((cu[3 * k] * conjf(cu[3 * k])) + (cu[1 + (3 * k)] * conjf(cu[1 + (3 * k)]))) + (cu[2 + (3 * k)] * conjf(cu[2 + (3 * k)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpdpic2/mpdpush2/14"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  for (k = 0; k < 1000; k++)\n  mresult[i][j] = mresult[i][j] + (matrixa[i][k] * matrixb[k][j]);\n\n\n\n", "pragma": "omp parallel for private (i,j,k) shared (mresult, matrixa, matrixb) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Willster419/parallel_computing_uac/PAC2/counters_ww_par/0"}
{"code": "for (i = 0; i < StatesCols; i++)\n{\n  for (j = 0; j < 2; j++)\n    printf(\"%.2f  \", emission[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/19"}
{"code": "for (int i = 0; i < MAT_ROWS; i++)\n{\n  for (int j = 0; j < MAT_COLS; j++)\n  {\n    printf(\"%4d \", result[(i * MAT_COLS) + j]);\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/psattiza/matrixMult/main/6"}
{"code": "for (int i = 0; i < sec; i++)\n{\n  ((cout << \"Section \") << (i + 1)) << endl;\n  for (j = 0; j < items; j++)\n  {\n    cin >> allitems[(i * items) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/prgm2/0"}
{"code": "for (k = 0; k < N; k++)\n{\n  sum = A[i][k] * B[k][j];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:sum) shared(k)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixin2/0"}
{"code": "for (int i = 0; i < num_bin; i++)\n{\n  vec_hist[i] = histogram[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/11"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    dist = getDistance(block[i], blockReceived[j]);\n    tempPoint = (j + (size * receivedFrom)) + 1;\n    for (m = 0; m < k; m++)\n    {\n      if (dist < kNNperBlock[i][m])\n      {\n        swap(&dist, &kNNperBlock[i][m]);\n        swap2(&pointPerkNN[i][m], &tempPoint);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/3"}
{"code": "for (int i = 0; i < input->nRegions; i++)\n{\n  for (int j = 0; j < input->nCities; j++)\n  {\n    measures->city[i][4][j] = calculate_stddev(regions[i][j], measures->city[i][3][j], input->nStudents);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/4"}
{"code": "for (int i = 0; i < sampleSize; i++)\n{\n  cosmul += a[i] * b[i];\n  asize += pow(a[i], 2);\n  bsize += pow(b[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/amplifier XE&schedule/Lab-1-1/4"}
{"code": "for (int i = mpiBegin; i < mpiEnd; i++)\n{\n  lIA[i - mpiBegin] = 0;\n  lIA[(i + 1) - mpiBegin] = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maqayum/Hybrid/main/0"}
{"code": "for (i = 0; i < window_size; i++)\n{\n  temp[0] = window[i][0];\n  temp[1] = window[i][1];\n  temp[2] = window[i][2];\n  for (j = i - 1; (j >= 0) && ((((((int) temp[0]) + ((int) temp[1])) + ((int) temp[2])) / 3) < ((((int) window[j][0]) + ((int) window[j][1])) + (((int) window[j][2]) / 3))); j--)\n  {\n    window[j + 1][0] = window[j][0];\n    window[j + 1][1] = window[j][1];\n    window[j + 1][2] = window[j][2];\n  }\n\n  window[j + 1][0] = temp[0];\n  window[j + 1][1] = temp[1];\n  window[j + 1][2] = temp[2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kawaiibilli/mandelbrot_renderer/cpu_main/0"}
{"code": "for (int pidx = start; pidx < pcls.size(); pidx++)\n{\n  dprintf(\"--- particle %d.%d ---\", ns, pidx);\n  dprintf(\"u[%d] = %+6.4f\", pidx, pcls[pidx].get_u());\n  dprintf(\"v[%d] = %+6.4f\", pidx, pcls[pidx].get_v());\n  dprintf(\"w[%d] = %+6.4f\", pidx, pcls[pidx].get_w());\n  dprintf(\"q[%d] = %+6.4f\", pidx, pcls[pidx].get_q());\n  dprintf(\"x[%d] = %+6.4f\", pidx, pcls[pidx].get_x());\n  dprintf(\"y[%d] = %+6.4f\", pidx, pcls[pidx].get_y());\n  dprintf(\"z[%d] = %+6.4f\", pidx, pcls[pidx].get_z());\n  dprintf(\"t[%d] = %5.0f\", pidx, pcls[pidx].get_t());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/0"}
{"code": "for (j = 0; j < 4; ++j)\n{\n  for (i = 0; i < 5; ++i)\n  {\n    fscanf(fp, \"%f\", &weightVal);\n    inW[(j * 5) + i] = weightVal;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/clink-omp/main/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  putc(out[i][2], fOut);\n  putc(out[i][1], fOut);\n  putc(out[i][0], fOut);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mohsenMahmoodzadeh/Parallel-Gaussian-and-Bilateral-Filter-with-OpenMP-CUDA/code/omp/gaussian_blur_omp/3"}
{"code": "for (x = 0; x < size.width; x++)\n  vsum[x] = (ushort) (sptr[x] * (wsz2 + 2));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvstereobm/1"}
{"code": "for (c3 = (0 > (((-N) + c1) + 1)) ? (0) : (((-N) + c1) + 1); c3 <= ((c1 - 1) / 129); c3 += 1)\n  for (c4 = 0; c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c10 = (0 > (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1)) ? (0) : (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1); c10 <= 1; c10 += 1)\n    {\n      if (c10 == 1)\n      {\n        M[((N - c1) + c3) - 1][c9] = (M[((N - c1) + c3) - 1][c9] > (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1])) ? (M[((N - c1) + c3) - 1][c9]) : (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1]);\n      }\n      else\n      {\n        for (c11 = (128 * c3) + 2; c11 <= ((((-N) + c1) - c3) + c9); c11 += 1)\n          M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n      }\n\n    }\n\n\n  }\n  else\n  {\n    for (c5 = 0; c5 <= (8 * c3); c5 += 1)\n      for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c11 = 16 * c5; c11 <= ((((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) < ((((-N) + c1) - c3) + c9)) ? ((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) : ((((-N) + c1) - c3) + c9)); c11 += 1)\n      M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mea_traco/2"}
{"code": "for (part = 0; part < n; part++)\n  Compute_force(part, forces, curr, n);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/1"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i++)\n{\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      rho_inv = 1.0 / u[0][i][j][k];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[1][i][j][k] * rho_inv;\n      vs[i][j][k] = u[2][i][j][k] * rho_inv;\n      ws[i][j][k] = u[3][i][j][k] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[1][i][j][k] * u[1][i][j][k]) + (u[2][i][j][k] * u[2][i][j][k])) + (u[3][i][j][k] * u[3][i][j][k]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n      aux = (c1c2 * rho_inv) * (u[4][i][j][k] - square[i][j][k]);\n      aux = sqrt(aux);\n      speed[i][j][k] = aux;\n      ainv[i][j][k] = 1.0 / aux;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/23"}
{"code": "for (int j = 0; j < y_size; j++)\n{\n  for (int k = 0; k < x_size; k++)\n  {\n    printf(\"%.f \", u[k + (j * x_size)]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/omp-par-for/2"}
{"code": "for (i = first_line; i < (first_line + blockDimension); i++)\n{\n  for (j = 0; j < blockDimension; j++)\n  {\n    bufc = fgetc(fp);\n    if ((bufc != '.') && (bufc != 'X'))\n    {\n      printf(\"LOOOL rank:%d-i=%d,j=%d,it's |%c|\\n\", my_rank, i, j, bufc);\n    }\n\n    block[(i - first_line) + 1][j + 1] = bufc;\n  }\n\n  fseek(fp, correct_offset, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ippokratoys/Game-Of-Life-MPI-OpenMp-CUDA/openMp/7"}
{"code": "for (long long int i = 0; i < my_bucket_size; ++i)\n{\n  const int key = my_local_keys[i];\n  if ((key < my_min_key) || (key > my_max_key))\n  {\n    printf(\"Rank %d Failed Verification!\\n\", my_rank);\n    printf(\"Key: %d is outside of bounds [%d, %d]\\n\", key, my_min_key, my_max_key);\n    error = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/11"}
{"code": "for (i = 0; i < finalSortedSize; i++)\n{\n  printf(\"%d \", finalSorted[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/11"}
{"code": "for (int i = 0; i < num_pac; i++)\n  Ph_Data[i] = rand() % 2;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/epistatis-omp/main/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    xx = (int) ((-1.0) + (dx * (i - 1)));\n    yy = (int) ((-1.0) + (dy * (j - 1)));\n    u[i][j] = 0.0;\n    f[i][j] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,xx,yy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB057-jacobiinitialize-orig-no/0"}
{"code": "for (int i = 0; i < ((4000000 / 4) * 4); i += 4)\n{\n  vmax = vmaxq_f32(vmax, vld1q_f32(data + i));\n  vmin = vminq_f32(vmin, vld1q_f32(data + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/min_max_reduction/6"}
{"code": "for (int i = 0; i < n2; ++i)\n{\n  for (int j = 0; j < n3; ++j)\n  {\n    (file << global_w2[i][j]) << \" \";\n  }\n\n  file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/5"}
{"code": "for (i = 0; i < initSize; i++)\n{\n  if (populationFitness[i] > fittestFitness)\n  {\n    strcopy(fittest, population[i], dim);\n    fittestFitness = populationFitness[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/18"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[nx - 3][j][k][m] = frct[nx - 3][j][k][m] - (dsspm * (((rsd[nx - 5][j][k][m] - (4.0 * rsd[nx - 4][j][k][m])) + (6.0 * rsd[nx - 3][j][k][m])) - (4.0 * rsd[nx - 2][j][k][m])));\n  frct[nx - 2][j][k][m] = frct[nx - 2][j][k][m] - (dsspm * ((rsd[nx - 4][j][k][m] - (4.0 * rsd[nx - 3][j][k][m])) + (5.0 * rsd[nx - 2][j][k][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dsspm)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/29"}
{"code": "for (i = 0; i < 100; i++)\n  omp_destroy_lock(&lck[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lockarray/4"}
{"code": "for (idx = 0; idx < VECTOR_SIZE; idx++)\n{\n  localMax = (localMax > fArray[idx]) ? (localMax) : (fArray[idx]);\n  localMaxIdx = (localMax > fArray[idx]) ? (localMaxIdx) : (idx);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soltanloo/Fall2020-PP-CAs/CA4/1/main/1"}
{"code": "for (i = 0; i < num_steps; i++)\n  sum = sum + (4.0 / (1.0 + (x[i] * x[i])));\n\n", "pragma": "omp omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mauricio98/Pr-cticaOpenMP/pi_parallel3/0"}
{"code": "for (i = 1; i < (4096 + 1); i++)\n{\n  for (j = 1; j < (4096 + 1); j++)\n  {\n    if (percentDiff(symmat[(i * (4096 + 1)) + j], symmat_outputFromGpu[(i * (4096 + 1)) + j]) > 1.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/10"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  add = u[i][j][k][m] - u_exact[m];\n  rms[m] = rms[m] + (add * add);\n}\n\n", "pragma": "omp parallel for private (add,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/5"}
{"code": "for (int i = 2; i < (GRAIN + 1); i += 2)\n  for (int j = 1; j < (GRAIN + 1); j += 2)\n{\n  if (!tab_unstable[(i * (GRAIN + 2)) + j])\n  {\n    if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n  }\n  else\n  {\n    tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n    changement += tab_unstable[(i * (GRAIN + 2)) + j];\n  }\n\n}\n\n\n", "pragma": "omp for collapse(2) reduction(+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/7"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  for (j = 0; j < 2000; j++)\n  {\n    matrice_res[(i * 2000) + j] = 0.0;\n    for (k = 0; k < 2000; k++)\n    {\n      matrice_res[(i * 2000) + j] += matrice_A[(i * 2000) + k] * matrice_B[(k * 2000) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(nb) private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omar-E-R/tp-programmation-parallel-openMP/TP1/matmul/0"}
{"code": "for (kk = 0; kk < dim_k; kk += blockcopy_tile_k)\n{\n  for (jj = 0; jj < dim_j; jj += blockcopy_tile_j)\n  {\n    for (ii = 0; ii < dim_i; ii += blockcopy_tile_i)\n    {\n      int dim_k_mod = dim_k - kk;\n      if (dim_k_mod > blockcopy_tile_k)\n        dim_k_mod = blockcopy_tile_k;\n\n      int dim_j_mod = dim_j - jj;\n      if (dim_j_mod > blockcopy_tile_j)\n        dim_j_mod = blockcopy_tile_j;\n\n      int dim_i_mod = dim_i - ii;\n      if (dim_i_mod > blockcopy_tile_i)\n        dim_i_mod = blockcopy_tile_i;\n\n      if ((*num_blocks) >= (*allocated_blocks))\n      {\n        int oldSize = *allocated_blocks;\n        if ((*allocated_blocks) == 0)\n        {\n          *allocated_blocks = 1000;\n          *blocks = (blockCopy_type *) malloc((*allocated_blocks) * (sizeof(blockCopy_type)));\n        }\n        else\n        {\n          *allocated_blocks *= 2;\n          *blocks = (blockCopy_type *) realloc((void *) (*blocks), (*allocated_blocks) * (sizeof(blockCopy_type)));\n        }\n\n        if ((*blocks) == 0)\n        {\n          fprintf(stderr, \"realloc failed - append_block_to_list (%d -> %d)\\n\", oldSize, *allocated_blocks);\n          exit(0);\n        }\n\n      }\n\n      (*blocks)[*num_blocks].subtype = subtype;\n      (*blocks)[*num_blocks].dim.i = dim_i_mod;\n      (*blocks)[*num_blocks].dim.j = dim_j_mod;\n      (*blocks)[*num_blocks].dim.k = dim_k_mod;\n      (*blocks)[*num_blocks].read.box = read_box;\n      (*blocks)[*num_blocks].read.ptr = read_ptr;\n      (*blocks)[*num_blocks].read.i = read_i + (read_scale * ii);\n      (*blocks)[*num_blocks].read.j = read_j + (read_scale * jj);\n      (*blocks)[*num_blocks].read.k = read_k + (read_scale * kk);\n      (*blocks)[*num_blocks].read.jStride = read_jStride;\n      (*blocks)[*num_blocks].read.kStride = read_kStride;\n      (*blocks)[*num_blocks].write.box = write_box;\n      (*blocks)[*num_blocks].write.ptr = write_ptr;\n      (*blocks)[*num_blocks].write.i = write_i + (write_scale * ii);\n      (*blocks)[*num_blocks].write.j = write_j + (write_scale * jj);\n      (*blocks)[*num_blocks].write.k = write_k + (write_scale * kk);\n      (*blocks)[*num_blocks].write.jStride = write_jStride;\n      (*blocks)[*num_blocks].write.kStride = write_kStride;\n      (*num_blocks)++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/14"}
{"code": "for (int i = 0; i < count; ++i)\n{\n  for (int j = 0; j < count; ++j)\n  {\n    for (int k = 0; k < count; ++k)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivam-anand/matPar/openmp/one/0"}
{"code": "for (I = 0; I < 10; I++)\n{\n  sum[I] = a[I] + b[I];\n  printf(\"CPU %d \\t Thread: %d Value: %d \\n\", sched_getcpu(), omp_get_thread_num(), sum[I]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 2/Code 1/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double Di = 0.0;\n  double DivV = 0.0;\n  double flagDi = 1.0;\n  double pndAux = 0.0;\n  double posXi = pos[i * 3];\n  double posYi = pos[(i * 3) + 1];\n  double posZi = pos[(i * 3) + 2];\n  double velXi = vel[i * 3];\n  double velYi = vel[(i * 3) + 1];\n  double velZi = vel[(i * 3) + 2];\n  double posMirrorXi = mirrorParticlePos[i * 3];\n  double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n  double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n  double MC[9];\n  MC[0] = correcMatrixRow1[i * 3];\n  MC[1] = correcMatrixRow1[(i * 3) + 1];\n  MC[2] = correcMatrixRow1[(i * 3) + 2];\n  MC[3] = correcMatrixRow2[i * 3];\n  MC[4] = correcMatrixRow2[(i * 3) + 1];\n  MC[5] = correcMatrixRow2[(i * 3) + 2];\n  MC[6] = correcMatrixRow3[i * 3];\n  MC[7] = correcMatrixRow3[(i * 3) + 1];\n  MC[8] = correcMatrixRow3[(i * 3) + 2];\n  double ni = pndi[i];\n  if (ni < 1.0e-8)\n    continue;\n\n  double Pi = press[i];\n  int ix;\n  int iy;\n  int iz;\n  bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n  int minZ = (iz - 1) * ((int) (dim - 2.0));\n  int maxZ = (iz + 1) * ((int) (dim - 2.0));\n  for (int jz = minZ; jz <= maxZ; jz++)\n  {\n    for (int jy = iy - 1; jy <= (iy + 1); jy++)\n    {\n      for (int jx = ix - 1; jx <= (ix + 1); jx++)\n      {\n        int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n        int j = firstParticleInBucket[jb];\n        if (j == (-1))\n          continue;\n\n        double plx;\n        double ply;\n        double plz;\n        getPeriodicLengths(jb, plx, ply, plz);\n        while (true)\n        {\n          double v0ij;\n          double v1ij;\n          double v2ij;\n          double v0imj;\n          double v1imj;\n          double v2imj;\n          double dstij2;\n          double dstimj2;\n          sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n          sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n          if ((dstij2 < reL2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n          {\n            if (j != i)\n            {\n              double dst = sqrt(dstij2);\n              double wL = weight(dst, reL, weightType);\n              double nj = pndi[j];\n              if ((particleType[i] == fluid) && (particleType[j] == fluid))\n              {\n                double pgh = ((-2.0) * ((RHO[i] * RHO[j]) / (RHO[i] + RHO[j]))) * (((gravityX * v0ij) + (gravityY * v1ij)) + (gravityZ * v2ij));\n                double Pj = press[j];\n                Di += (((timeStep / RHO[i]) * coeffViscMultiphase) * ((Pj - Pi) - pgh)) * wL;\n              }\n\n              if (dstij2 < reS2)\n              {\n                double vijx = vel[j * 3] - velXi;\n                double vijy = vel[(j * 3) + 1] - velYi;\n                double vijz = vel[(j * 3) + 2] - velZi;\n                double wS = weight(dst, reS, weightType);\n                if (gradientCorrection == false)\n                {\n                  if (ni > 1.0e-8)\n                  {\n                    DivV += ((((dim / pndSmallZero) * (pndi[j] / ni)) * (((vijx * v0ij) + (vijy * v1ij)) + (vijz * v2ij))) * wS) / dstij2;\n                  }\n\n                }\n                else\n                {\n                  double v0ijC = ((v0ij * MC[0]) + (v1ij * MC[1])) + (v2ij * MC[2]);\n                  double v1ijC = ((v0ij * MC[3]) + (v1ij * MC[4])) + (v2ij * MC[5]);\n                  double v2ijC = ((v0ij * MC[6]) + (v1ij * MC[7])) + (v2ij * MC[8]);\n                  DivV += (((dim / pndSmallZero) * (((vijx * v0ijC) + (vijy * v1ijC)) + (vijz * v2ijC))) * wS) / dstij2;\n                }\n\n              }\n\n            }\n\n          }\n\n          j = nextParticleInSameBucket[j];\n          if (j == (-1))\n            break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n  acc[i * 3] = pndi[i] * (1.0 + (timeStep * ((-DivV) + (Di * flagDi))));\n  velDivergence[i] = DivV;\n  diffusiveTerm[i] = Di;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/38"}
{"code": "for (int i = 0; i < nf; i++)\n{\n  if ((tset[i] = readImg(ifileL[i])) == 0)\n    error = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < L; j++)\n  {\n    temporary = BOLD[(i * L) + j];\n    BOLD_transpose[(j * N) + i] = temporary;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/6"}
{"code": "for (i = 0; i < nOMP; i++)\n  ((((((cout << \"xOMP[\") << (i + 1)) << \"]= \") << setw(7)) << setprecision(6)) << xOMP[i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/11"}
{"code": "for (i = 1; i <= file_num; i++)\n{\n  if (file_num == 1)\n    sprintf(file_name, \"%s%s%04d%s%04d\", INPUT_FOLDER, \"/vel\", SNAPSHOT, \".\", CUR_STEP);\n  else\n    sprintf(file_name, \"%s%s%04d%s%04d%s%02d\", INPUT_FOLDER, \"/vel\", SNAPSHOT, \".\", CUR_STEP, \".\", i);\n\n  fp = fopen(file_name, \"rb\");\n  printf(\"Open %s\\n\", file_name);\n  fseek(fp, 0, 2);\n  file_len = ftell(fp);\n  readby = 0L;\n  if (i == 1)\n  {\n    header_size = ((2 * (sizeof(long int))) + (6 * (sizeof(float)))) + (2 * (sizeof(int)));\n    fseek(fp, header_size, 0);\n    file_len -= header_size;\n  }\n  else\n    rewind(fp);\n\n  while (readby < file_len)\n  {\n    fread(&block_size_1, sizeof(block_size_1), 1, fp);\n    fread(&reader_vel[readby_total], sizeof(char), abs(block_size_1), fp);\n    fread(&block_size_2, sizeof(block_size_2), 1, fp);\n    if (abs(block_size_2) != abs(block_size_1))\n    {\n      printf(\"Inconsistency found in %s\\n\", file_name);\n      warn_and_end(\"End\");\n    }\n\n    readby += abs(block_size_1) + (2 * (sizeof(block_size_1)));\n    readby_total += abs(block_size_1);\n  }\n\n  fclose(fp);\n  printf(\"Finish reading.\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/load_jing/3"}
{"code": "for (int i = 0; i <= nl; i++)\n{\n  free(tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.3/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n    total *= sp;\n\n}\n\n", "pragma": "#pragma omp for private(i,sp) reduction(*:total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab6/Source/0"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_SHA1_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-sha1_fmt_plug/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    }\n\n    lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(fac1, m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/94"}
{"code": "for (int i = 0, ii = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%d \", ii + 1);\n  ii++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/122"}
{"code": "for (size_t i = 0; i < 10; i++)\n  free_bucket(buckets[i]);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/old_openmp/main/2"}
{"code": "for (int y = 0; y < HEI; y++)\n  for (int x = 0; x < WID; x++)\n{\n  float d = 0;\n  int i = 0;\n  do\n    d += F[i] * rsqrt(((X[i] - x) * (X[i] - x)) + ((Y[i] - y) * (Y[i] - y)));\n  while ((++i) < ms);\n  memcpy(manor + (((((HEI - 1) - y) * WID) + x) * 3), col[(d > 255) ? (255) : ((d < 0) ? (0) : ((unsigned char) d))], 3);\n}\n\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/serprex/Metaballs/meta/3"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  for (i = iend - 1; i >= ist; i--)\n  {\n    tmp1 = rho_i[k][j][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    du[j][i][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    du[j][i][1][0] = 0.0;\n    du[j][i][2][0] = 0.0;\n    du[j][i][3][0] = 0.0;\n    du[j][i][4][0] = 0.0;\n    du[j][i][0][1] = ((dt * 2.0) * ((((-tx1) * r43) - ty1) - tz1)) * ((c34 * tmp2) * u[k][j][i][1]);\n    du[j][i][1][1] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * (((tx1 * r43) + ty1) + tz1))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    du[j][i][2][1] = 0.0;\n    du[j][i][3][1] = 0.0;\n    du[j][i][4][1] = 0.0;\n    du[j][i][0][2] = ((dt * 2.0) * (((-tx1) - (ty1 * r43)) - tz1)) * ((c34 * tmp2) * u[k][j][i][2]);\n    du[j][i][1][2] = 0.0;\n    du[j][i][2][2] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * ((tx1 + (ty1 * r43)) + tz1))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    du[j][i][3][2] = 0.0;\n    du[j][i][4][2] = 0.0;\n    du[j][i][0][3] = ((dt * 2.0) * (((-tx1) - ty1) - (tz1 * r43))) * ((c34 * tmp2) * u[k][j][i][3]);\n    du[j][i][1][3] = 0.0;\n    du[j][i][2][3] = 0.0;\n    du[j][i][3][3] = (1.0 + ((((dt * 2.0) * c34) * tmp1) * ((tx1 + ty1) + (tz1 * r43)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    du[j][i][4][3] = 0.0;\n    du[j][i][0][4] = ((-dt) * 2.0) * ((((((((tx1 * ((r43 * c34) - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * (c34 - c1345))) * (u[k][j][i][1] * u[k][j][i][1])) + ((((tx1 * (c34 - c1345)) + (ty1 * ((r43 * c34) - c1345))) + (tz1 * (c34 - c1345))) * (u[k][j][i][2] * u[k][j][i][2]))) + ((((tx1 * (c34 - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * ((r43 * c34) - c1345))) * (u[k][j][i][3] * u[k][j][i][3]))) * tmp3) + (((((tx1 + ty1) + tz1) * c1345) * tmp2) * u[k][j][i][4]));\n    du[j][i][1][4] = (((dt * 2.0) * (((tx1 * ((r43 * c34) - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * (c34 - c1345)))) * tmp2) * u[k][j][i][1];\n    du[j][i][2][4] = (((dt * 2.0) * (((tx1 * (c34 - c1345)) + (ty1 * ((r43 * c34) - c1345))) + (tz1 * (c34 - c1345)))) * tmp2) * u[k][j][i][2];\n    du[j][i][3][4] = (((dt * 2.0) * (((tx1 * (c34 - c1345)) + (ty1 * (c34 - c1345))) + (tz1 * ((r43 * c34) - c1345)))) * tmp2) * u[k][j][i][3];\n    du[j][i][4][4] = (1.0 + ((((dt * 2.0) * ((tx1 + ty1) + tz1)) * c1345) * tmp1)) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = rho_i[k][j][i + 1];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    au[j][i][0][0] = ((-dt) * tx1) * dx1;\n    au[j][i][1][0] = dt * tx2;\n    au[j][i][2][0] = 0.0;\n    au[j][i][3][0] = 0.0;\n    au[j][i][4][0] = 0.0;\n    au[j][i][0][1] = ((dt * tx2) * (((-(u[k][j][i + 1][1] * tmp1)) * (u[k][j][i + 1][1] * tmp1)) + ((C2 * qs[k][j][i + 1]) * tmp1))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[k][j][i + 1][1]));\n    au[j][i][1][1] = (((dt * tx2) * ((2.0 - C2) * (u[k][j][i + 1][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    au[j][i][2][1] = (dt * tx2) * ((-C2) * (u[k][j][i + 1][2] * tmp1));\n    au[j][i][3][1] = (dt * tx2) * ((-C2) * (u[k][j][i + 1][3] * tmp1));\n    au[j][i][4][1] = (dt * tx2) * C2;\n    au[j][i][0][2] = ((dt * tx2) * ((-(u[k][j][i + 1][1] * u[k][j][i + 1][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[k][j][i + 1][2]));\n    au[j][i][1][2] = (dt * tx2) * (u[k][j][i + 1][2] * tmp1);\n    au[j][i][2][2] = (((dt * tx2) * (u[k][j][i + 1][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    au[j][i][3][2] = 0.0;\n    au[j][i][4][2] = 0.0;\n    au[j][i][0][3] = ((dt * tx2) * ((-(u[k][j][i + 1][1] * u[k][j][i + 1][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[k][j][i + 1][3]));\n    au[j][i][1][3] = (dt * tx2) * (u[k][j][i + 1][3] * tmp1);\n    au[j][i][2][3] = 0.0;\n    au[j][i][3][3] = (((dt * tx2) * (u[k][j][i + 1][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    au[j][i][4][3] = 0.0;\n    au[j][i][0][4] = ((dt * tx2) * ((((C2 * 2.0) * qs[k][j][i + 1]) - (C1 * u[k][j][i + 1][4])) * (u[k][j][i + 1][1] * tmp2))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[k][j][i + 1][1] * u[k][j][i + 1][1])) - (((c34 - c1345) * tmp3) * (u[k][j][i + 1][2] * u[k][j][i + 1][2]))) - (((c34 - c1345) * tmp3) * (u[k][j][i + 1][3] * u[k][j][i + 1][3]))) - ((c1345 * tmp2) * u[k][j][i + 1][4])));\n    au[j][i][1][4] = ((dt * tx2) * ((C1 * (u[k][j][i + 1][4] * tmp1)) - (C2 * (((u[k][j][i + 1][1] * u[k][j][i + 1][1]) * tmp2) + (qs[k][j][i + 1] * tmp1))))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[k][j][i + 1][1]);\n    au[j][i][2][4] = ((dt * tx2) * (((-C2) * (u[k][j][i + 1][2] * u[k][j][i + 1][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[k][j][i + 1][2]);\n    au[j][i][3][4] = ((dt * tx2) * (((-C2) * (u[k][j][i + 1][3] * u[k][j][i + 1][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[k][j][i + 1][3]);\n    au[j][i][4][4] = (((dt * tx2) * (C1 * (u[k][j][i + 1][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n    tmp1 = rho_i[k][j + 1][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    bu[j][i][0][0] = ((-dt) * ty1) * dy1;\n    bu[j][i][1][0] = 0.0;\n    bu[j][i][2][0] = dt * ty2;\n    bu[j][i][3][0] = 0.0;\n    bu[j][i][4][0] = 0.0;\n    bu[j][i][0][1] = ((dt * ty2) * ((-(u[k][j + 1][i][1] * u[k][j + 1][i][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[k][j + 1][i][1]));\n    bu[j][i][1][1] = (((dt * ty2) * (u[k][j + 1][i][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    bu[j][i][2][1] = (dt * ty2) * (u[k][j + 1][i][1] * tmp1);\n    bu[j][i][3][1] = 0.0;\n    bu[j][i][4][1] = 0.0;\n    bu[j][i][0][2] = ((dt * ty2) * (((-(u[k][j + 1][i][2] * tmp1)) * (u[k][j + 1][i][2] * tmp1)) + (C2 * (qs[k][j + 1][i] * tmp1)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[k][j + 1][i][2]));\n    bu[j][i][1][2] = (dt * ty2) * ((-C2) * (u[k][j + 1][i][1] * tmp1));\n    bu[j][i][2][2] = (((dt * ty2) * ((2.0 - C2) * (u[k][j + 1][i][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    bu[j][i][3][2] = (dt * ty2) * ((-C2) * (u[k][j + 1][i][3] * tmp1));\n    bu[j][i][4][2] = (dt * ty2) * C2;\n    bu[j][i][0][3] = ((dt * ty2) * ((-(u[k][j + 1][i][2] * u[k][j + 1][i][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[k][j + 1][i][3]));\n    bu[j][i][1][3] = 0.0;\n    bu[j][i][2][3] = (dt * ty2) * (u[k][j + 1][i][3] * tmp1);\n    bu[j][i][3][3] = (((dt * ty2) * (u[k][j + 1][i][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    bu[j][i][4][3] = 0.0;\n    bu[j][i][0][4] = ((dt * ty2) * ((((C2 * 2.0) * qs[k][j + 1][i]) - (C1 * u[k][j + 1][i][4])) * (u[k][j + 1][i][2] * tmp2))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * (u[k][j + 1][i][1] * u[k][j + 1][i][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[k][j + 1][i][2] * u[k][j + 1][i][2]))) - (((c34 - c1345) * tmp3) * (u[k][j + 1][i][3] * u[k][j + 1][i][3]))) - ((c1345 * tmp2) * u[k][j + 1][i][4])));\n    bu[j][i][1][4] = ((dt * ty2) * (((-C2) * (u[k][j + 1][i][1] * u[k][j + 1][i][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[k][j + 1][i][1]);\n    bu[j][i][2][4] = ((dt * ty2) * ((C1 * (u[k][j + 1][i][4] * tmp1)) - (C2 * ((qs[k][j + 1][i] * tmp1) + ((u[k][j + 1][i][2] * u[k][j + 1][i][2]) * tmp2))))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[k][j + 1][i][2]);\n    bu[j][i][3][4] = ((dt * ty2) * (((-C2) * (u[k][j + 1][i][2] * u[k][j + 1][i][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[k][j + 1][i][3]);\n    bu[j][i][4][4] = (((dt * ty2) * (C1 * (u[k][j + 1][i][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = rho_i[k + 1][j][i];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    cu[j][i][0][0] = ((-dt) * tz1) * dz1;\n    cu[j][i][1][0] = 0.0;\n    cu[j][i][2][0] = 0.0;\n    cu[j][i][3][0] = dt * tz2;\n    cu[j][i][4][0] = 0.0;\n    cu[j][i][0][1] = ((dt * tz2) * ((-(u[k + 1][j][i][1] * u[k + 1][j][i][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[k + 1][j][i][1]));\n    cu[j][i][1][1] = (((dt * tz2) * (u[k + 1][j][i][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    cu[j][i][2][1] = 0.0;\n    cu[j][i][3][1] = (dt * tz2) * (u[k + 1][j][i][1] * tmp1);\n    cu[j][i][4][1] = 0.0;\n    cu[j][i][0][2] = ((dt * tz2) * ((-(u[k + 1][j][i][2] * u[k + 1][j][i][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[k + 1][j][i][2]));\n    cu[j][i][1][2] = 0.0;\n    cu[j][i][2][2] = (((dt * tz2) * (u[k + 1][j][i][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    cu[j][i][3][2] = (dt * tz2) * (u[k + 1][j][i][2] * tmp1);\n    cu[j][i][4][2] = 0.0;\n    cu[j][i][0][3] = ((dt * tz2) * (((-(u[k + 1][j][i][3] * tmp1)) * (u[k + 1][j][i][3] * tmp1)) + (C2 * (qs[k + 1][j][i] * tmp1)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[k + 1][j][i][3]));\n    cu[j][i][1][3] = (dt * tz2) * ((-C2) * (u[k + 1][j][i][1] * tmp1));\n    cu[j][i][2][3] = (dt * tz2) * ((-C2) * (u[k + 1][j][i][2] * tmp1));\n    cu[j][i][3][3] = ((((dt * tz2) * (2.0 - C2)) * (u[k + 1][j][i][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    cu[j][i][4][3] = (dt * tz2) * C2;\n    cu[j][i][0][4] = ((dt * tz2) * ((((C2 * 2.0) * qs[k + 1][j][i]) - (C1 * u[k + 1][j][i][4])) * (u[k + 1][j][i][3] * tmp2))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[k + 1][j][i][1] * u[k + 1][j][i][1])) - (((c34 - c1345) * tmp3) * (u[k + 1][j][i][2] * u[k + 1][j][i][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[k + 1][j][i][3] * u[k + 1][j][i][3]))) - ((c1345 * tmp2) * u[k + 1][j][i][4])));\n    cu[j][i][1][4] = ((dt * tz2) * (((-C2) * (u[k + 1][j][i][1] * u[k + 1][j][i][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[k + 1][j][i][1]);\n    cu[j][i][2][4] = ((dt * tz2) * (((-C2) * (u[k + 1][j][i][2] * u[k + 1][j][i][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[k + 1][j][i][2]);\n    cu[j][i][3][4] = ((dt * tz2) * ((C1 * (u[k + 1][j][i][4] * tmp1)) - (C2 * ((qs[k + 1][j][i] * tmp1) + ((u[k + 1][j][i][3] * u[k + 1][j][i][3]) * tmp2))))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[k + 1][j][i][3]);\n    cu[j][i][4][4] = (((dt * tz2) * (C1 * (u[k + 1][j][i][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/jacu/0"}
{"code": "for (int i = 0; i < Tot_N; i++)\n{\n  if (i < N[0])\n  {\n    phi_star[i] = phi[(NUM_POINTS_0 - 1) - i];\n  }\n  else\n    if ((i >= N[0]) && (i < (N[0] + N[1])))\n  {\n    s_l = Ds * ((i - N[0]) + (1.0 / 2.0));\n    z_val = z(s_l, 1);\n    phi_star[i] = -InflowX(z_val, t);\n  }\n  else\n    if ((i >= (N[0] + N[1])) && (i < ((N[0] + N[1]) + N[2])))\n  {\n    phi_star[i] = 0.0;\n  }\n  else\n    if (i >= ((N[0] + N[1]) + N[2]))\n  {\n    phi_star[i] = 0.0;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/7"}
{"code": "for (i2 = 1; i2 < (n2 - 1); i2++)\n{\n  for (i1 = 1; i1 < (n1 - 1); i1++)\n  {\n    s = s + pow(or[(((i3 * n2) * n1) + (i2 * n1)) + i1], 2.0);\n    a = fabs(or[(((i3 * n2) * n1) + (i2 * n1)) + i1]);\n    temp = max(temp, a);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:s) reduction(max:temp) private(i2,i1) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/17"}
{"code": "for (int i = 0; i < n; i++)\n{\n  error = (error + pow(yReal[i] - (frac * xReal[i]), 2)) + pow(yImg[i] - (frac * xImg[i]), 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krishnakinnal/FFT-in-Parallel/fft/0"}
{"code": "for (i = 1; i < (N - 1); i++)\n  for (j = 1; j < (M - 1); j += 2)\n{\n  shift = shift1[i];\n  unew[i][j + shift] = ((1.0 - omega) * uold[i][j + shift]) + ((0.25 * omega) * ((((unew[i + 1][j + shift] + unew[i][(j + shift) + 1]) + unew[i - 1][j + shift]) + unew[i][(j + shift) - 1]) - ((dx * dx) * ((-10.0) * (((x[i] * x[i]) + (y[j + shift] * y[j + shift])) + 5.0)))));\n}\n\n\n", "pragma": "omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/7"}
{"code": "for (unsigned int t = 0; t < n_threads; t++)\n{\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    free(layer_outputs[t][l]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU2/1"}
{"code": "for (i = 0; i < (nca / 2); i++)\n{\n  for (j = 0; j < (nca / 2); j++)\n  {\n    a[((2 * nca) * nca) + ((i * nca) + j)] = ABC[in1 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + (((i * nca) + j) + (nca / 2))] = ABC[in2 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + (((i + (nca / 2)) * nca) + j)] = ABC[in3 + ((i * (nca / 2)) + j)];\n    a[((2 * nca) * nca) + ((((i + (nca / 2)) * nca) + j) + (nca / 2))] = ABC[in4 + ((i * (nca / 2)) + j)];\n  }\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/6"}
{"code": "for (; (i + 7) < n; i += 8)\n{\n  xv[0] = _mm256_load_ps(&x[i + 0]);\n  _mm256_store_ps(&y[i + 0], xv[0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/13"}
{"code": "for (i = 0; i < 2; i++)\n{\n  free(cdata[i]);\n  free(cmask[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/126"}
{"code": "for (i = 0; i < 5; i++)\n{\n  {\n    for (j = 0; j < 5; j++)\n      ;\n\n  }\n}\n\n", "pragma": "omp for collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/collapse-1/5"}
{"code": "for (int node = 0; node < total_nodes; node++)\n{\n  if (node == adjVertex)\n  {\n    if ((parents->items[node] == (-1)) && (node != 0))\n    {\n      int thread_num = omp_get_thread_num();\n      printf(\"\\nAdjacent node of %d vertex (OpenMP Thread No: %d): %d\\n\", vertex, adjVertex, thread_num);\n      printf(\"Parent of %d adjacent vertex (OpenMP Thread No: %d): %d\\n\", adjVertex, vertex, thread_num);\n      parents->items[node] = vertex;\n      printf(\"Add node %d to next queue (OpenMP Thread No: %d)\", node, thread_num);\n      app_Enqueue(next, node);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ata-Pab/Parallel_BFS_OpenMP/parallel_bfs_openmp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  arr[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alb3rtov/ARCO/lab3/results/task1/src/maxmin_parallel/0"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    scanfReturn = fscanf(myFile, \"%d%*c\", &myvar2);\n    if (scanfReturn == 1)\n    {\n    }\n    else\n    {\n      printf(\"error in %d,%d. \\n\", i, j);\n      return 1;\n    }\n\n    if ((i >= start) && (i <= end))\n    {\n      if (pointPerkNN[i - start][j] != myvar2)\n      {\n        errors++;\n      }\n\n    }\n\n    if (i > end)\n    {\n      goto stop2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/5"}
{"code": "for (k = 0; k < n; k++)\n  sum = sum + (a[i][k] * b[k][j]);\n\n", "pragma": "omp parallel for reduction(+:sum) private(k)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/mul_omp_q8/2"}
{"code": "for (unsigned int xIndex = 0; xIndex < query_nb; xIndex++)\n{\n  float *p_dist = &dist[xIndex];\n  int *p_ind = &ind[xIndex];\n  float max_dist = p_dist[0];\n  p_ind[0] = 0;\n  for (int l = 1; l < k; l++)\n  {\n    int curr_row = l * query_nb;\n    float curr_dist = p_dist[curr_row];\n    if (curr_dist < max_dist)\n    {\n      int i = l - 1;\n      for (int a = 0; a < (l - 1); a++)\n      {\n        if (p_dist[a * query_nb] > curr_dist)\n        {\n          i = a;\n          break;\n        }\n\n      }\n\n      for (int j = l; j > i; j--)\n      {\n        p_dist[j * query_nb] = p_dist[(j - 1) * query_nb];\n        p_ind[j * query_nb] = p_ind[(j - 1) * query_nb];\n      }\n\n      p_dist[i * query_nb] = curr_dist;\n      p_ind[i * query_nb] = l;\n    }\n    else\n    {\n      p_ind[l * query_nb] = l;\n    }\n\n    max_dist = p_dist[curr_row];\n  }\n\n  int max_row = (k - 1) * query_nb;\n  for (int l = k; l < ref_nb; l++)\n  {\n    float curr_dist = p_dist[l * query_nb];\n    if (curr_dist < max_dist)\n    {\n      int i = k - 1;\n      for (int a = 0; a < (k - 1); a++)\n      {\n        if (p_dist[a * query_nb] > curr_dist)\n        {\n          i = a;\n          break;\n        }\n\n      }\n\n      for (int j = k - 1; j > i; j--)\n      {\n        p_dist[j * query_nb] = p_dist[(j - 1) * query_nb];\n        p_ind[j * query_nb] = p_ind[(j - 1) * query_nb];\n      }\n\n      p_dist[i * query_nb] = curr_dist;\n      p_ind[i * query_nb] = l;\n      max_dist = p_dist[max_row];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/6"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bx = calc_bin(x[i], nbx, xmin, xmax, edgesx);\n  by = calc_bin(y[i], nby, ymin, ymax, edgesy);\n  bin = by + (nby * bx);\n  values_px[bin] += w[i];\n  variances_px[bin] += w[i] * w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/37"}
{"code": "for (int i = 0; i < input.lookups; i++)\n{\n  uint64_t seed = STARTING_SEED;\n  seed = fast_forward_LCG(seed, 2 * i);\n  double E = LCG_random_double(&seed);\n  int mat = pick_mat(&seed);\n  double macro_xs[4] = {0};\n  calculate_macro_xs(macro_xs, mat, E, input, data.num_nucs, data.mats, data.max_num_nucs, data.concs, data.n_windows, data.pseudo_K0RS, data.windows, data.poles, data.max_num_windows, data.max_num_poles);\n  double max = -DBL_MAX;\n  int max_idx = 0;\n  for (int x = 0; x < 4; x++)\n  {\n    if (macro_xs[x] > max)\n    {\n      max = macro_xs[x];\n      max_idx = x;\n    }\n\n  }\n\n  verification += max_idx + 1;\n  if (i == 0)\n    offloaded_to_device = !omp_is_initial_device();\n\n}\n\n", "pragma": "omp target teams distribute parallel for map(to:data.n_poles[:data.length_n_poles]) map(to:data.n_windows[:data.length_n_windows]) map(to:data.poles[:data.length_poles]) map(to:data.windows[:data.length_windows]) map(to:data.pseudo_K0RS[:data.length_pseudo_K0RS]) map(to:data.num_nucs[:data.length_num_nucs]) map(to:data.mats[:data.length_mats]) map(to:data.concs[:data.length_concs]) map(to:data.max_num_nucs) map(to:data.max_num_poles) map(to:data.max_num_windows) map(tofrom:offloaded_to_device) reduction(+:verification)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/rsbench-omp/simulation/0"}
{"code": "for (ib = 0; ib < len; ib += ibl)\n{\n  for (jb = 0; jb < len; jb += ibl)\n  {\n    for (kb = 0; kb < len; kb += ibl)\n    {\n      for (i = ib; (i < (ib + ibl)) && (i < len); ++i)\n      {\n        for (j = jb; (j < (jb + ibl)) && (j < len); ++j)\n        {\n          for (k = kb; (k < (kb + ibl)) && (k < len); ++k)\n          {\n            res[(len * i) + j] += a[(len * i) + k] * b[(len * k) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(6) private(jb, kb, i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tsuzu/sgx-omp-example/Enclave/Enclave/1"}
{"code": "for (j = 1; j < (512 + 1); j++)\n{\n  stddev[j] = 0.0;\n  for (i = 1; i < (512 + 1); i++)\n  {\n    stddev[j] += (data[(i * (512 + 1)) + j] - mean[j]) * (data[(i * (512 + 1)) + j] - mean[j]);\n  }\n\n  stddev[j] /= 3214212.01f;\n  stddev[j] = sqrt(stddev[j]);\n  stddev[j] = (stddev[j] <= 0.005f) ? (1.0) : (stddev[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/12"}
{"code": "for (int i = 0; i < N_GRIDS; ++i)\n{\n  grids.push_back(Grid3D(shapeX, shapeY, shapeZ));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/CpuSolver/0"}
{"code": "for (int iat = 0; iat < Z.size(); iat++)\n  Z[iat] = mySpecies(qind, GroupID[iat]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/5"}
{"code": "for (int i = 0; i < nsockets; i++)\n{\n  {\n    printf(\"thread %2d: place %d, nplaces %d, nprocs %d, npplaces %d | procs here are: \", me, place, nsockets, nprocs, npplaces);\n    for (int p = 0; p < nprocs; p++)\n      printf(\"%d \", proc_ids[p]);\n\n    printf(\"\\n\");\n    for (int p = 0; p < nbuffers; p++)\n    {\n      printf(\"%s\", buffer[p]);\n      free(buffer[p]);\n    }\n\n  }\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/threads_affinity/03_where_I_am_nested/0"}
{"code": "for (int i = 0; i < (N + 1); i++)\n{\n  scanf(\"%llu\", &dimensions[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10203/fast_matrix/2"}
{"code": "for (int i = 0; i < k; i++)\n  swap_d(_r1 + i, _r2 + i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/0"}
{"code": "for (i = 0; i < 10; i += 2)\n{\n  printf(\"Hello world %d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i].resize(N);\n  B[i].resize(N);\n  C[i].resize(N);\n  for (int j = 0; j < N; j++)\n  {\n    A[i][j] = rand();\n    B[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OlegDydy/kamyshnikov_omp/App_2/App_2/1"}
{"code": "for (i = 0; i < npts; i++)\n{\n  float dist;\n  dist = 0;\n  for (j = 0; j < nfeatures; j++)\n    dist += (pt[j] - pts[i][j]) * (pt[j] - pts[i][j]);\n\n  if (dist < min_dist)\n  {\n    min_dist = dist;\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/kmeans/kmeans_openmp/kmeans_clustering/0"}
{"code": "for (k = lt; k >= (lb + 1); k--)\n{\n  j = k - 1;\n  rprj3_adapt(r[k], m1[k], m2[k], m3[k], r[j], m1[j], m2[j], m3[j], k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/MG/mg_single_adaptive/1"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/45"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"%d \", matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task3/4"}
{"code": "for (i = 0; i < nd; i++)\n{\n  matrix[i] = malloc(nd * (sizeof(double)));\n  for (j = 0; j < nd; j++)\n  {\n    matrix[i][j] = distance(datapoints[i], datapoints[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/13"}
{"code": "for (i_imopVarPre76 = 0; i_imopVarPre76 < (1 << 16); i_imopVarPre76++)\n{\n  key_buff2[i_imopVarPre76] = key_array[i_imopVarPre76];\n  prv_buff1[key_buff2[i_imopVarPre76]]++;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/0"}
{"code": "for (int j = 0; j < size_u[0]; j++)\n{\n  for (int k = 0; k < size_u[1]; k++)\n  {\n    fprintf(arquivo, \"%.10f \", u[0][j][k]);\n  }\n\n  fprintf(arquivo, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation_static_alloc/2"}
{"code": "for (k = matrix.column_offset[i]; k < matrix.column_offset[i + 1]; k++)\n{\n  result[matrix.row[k]] += matrix.value[k] * multiplier;\n}\n\n", "pragma": "omp parallel for private(k) shared(matrix)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/0"}
{"code": "for (int i = start; i < end; ++i)\n{\n  int coarse_index = this->vec_[index[i]];\n  if (coarse_index == (-1))\n  {\n    continue;\n  }\n\n  if (check[coarse_index] == 0)\n  {\n    boundary[ind++] = coarse_index;\n    check[coarse_index] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/44"}
{"code": "for (i = 0; i < number_of_partitions; i++)\n  if (!(*((*partitions) + i) = (dynamic_weighted_graph *) malloc(number_of_partitions * (sizeof(dynamic_weighted_graph)))))\n{\n  printf(\"Couldn't allocate partitions!\\n\");\n  free_partitions(*partitions, number_of_partitions);\n  free(*partitions);\n  return 0;\n}\nelse\n{\n  if (i != (number_of_partitions - 1))\n    dynamic_weighted_graph_init(*((*partitions) + i), base_partition_size);\n  else\n    dynamic_weighted_graph_init(*((*partitions) + i), last_partition_size);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/version-parallel-naive-partitioning/2"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"%d, \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task7/1"}
{"code": "for (i = 0; i < count; i += inner_batch_size)\n{\n  unsigned char keys[SSE_GROUP_SZ_SHA512][64];\n  int lens[SSE_GROUP_SZ_SHA512];\n  int j;\n  for (j = 0; j < inner_batch_size; ++j)\n  {\n    lens[j] = strlen((char *) key_buffer[i + j]);\n    strncpy((char *) keys[j], (char *) key_buffer[i + j], 64);\n    if (psalt->nkeyfiles)\n    {\n      int t;\n      for (t = 0; t < 64; t++)\n        keys[j][t] += psalt->kpool[t];\n\n      lens[j] = 64;\n    }\n\n  }\n\n  if (psalt->hash_type == 1)\n  {\n    unsigned char *pin[SSE_GROUP_SZ_SHA512];\n    unsigned char *pout[SSE_GROUP_SZ_SHA512];\n    for (j = 0; j < SSE_GROUP_SZ_SHA512; ++j)\n    {\n      pin[j] = keys[j];\n      pout[j] = keys[j];\n    }\n\n    pbkdf2_sha512_sse((const unsigned char **) pin, lens, psalt->salt, 64, psalt->num_iterations, pout, sizeof(keys[0]), 0);\n  }\n  else\n    if ((psalt->hash_type == 2) || (psalt->hash_type == 4))\n    pbkdf2_ripemd160((const unsigned char *) keys[0], lens[0], psalt->salt, 64, psalt->num_iterations, keys[0], sizeof(keys[0]), 0);\n  else\n    pbkdf2_whirlpool((const unsigned char *) keys[0], lens[0], psalt->salt, 64, psalt->num_iterations, keys[0], sizeof(keys[0]), 0);\n\n\n  for (j = 0; j < inner_batch_size; ++j)\n  {\n    cracked[i + j] = 0;\n    if ((decrypt_and_verify(keys[j], 0) || decrypt_and_verify(keys[j], 1)) || decrypt_and_verify(keys[j], 2))\n      cracked[i + j] = 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/truecrypt_fmt_plug/9"}
{"code": "for (i = 0; i < 160; i++)\n{\n  wavenum[i] = i;\n  wavelen[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/0"}
{"code": "for (size_t i = 0; i < xforces.size(); ++i)\n{\n  double ax = xforces[i] / mass_[i];\n  double ay = yforces[i] / mass_[i];\n  xvel_[i] += ax * dt;\n  yvel_[i] += ay * dt;\n  xpos_[i] += xvel_[i] * dt;\n  ypos_[i] += yvel_[i] * dt;\n  if (xpos_[i] <= 0)\n  {\n    xpos_[i] = 2;\n    xvel_[i] = -xvel_[i];\n  }\n\n  if (xpos_[i] >= w)\n  {\n    xpos_[i] = w - 2;\n    xvel_[i] = -xvel_[i];\n  }\n\n  if (ypos_[i] <= 0)\n  {\n    ypos_[i] = 2;\n    yvel_[i] = -yvel_[i];\n  }\n\n  if (ypos_[i] >= h)\n  {\n    ypos_[i] = h - 2;\n    yvel_[i] = -yvel_[i];\n  }\n\n  assert((0 <= xpos_[i]) && (xpos_[i] <= w));\n  assert((0 <= ypos_[i]) && (ypos_[i] <= h));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jprieto92/parallel-programming-openmp-nbodies/nbody/src/bodiessoa/3"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NL; j++)\n  {\n    E[(i * NL) + j] = 0.0;\n    for (k = 0; k < NJ; ++k)\n    {\n      E[(i * NL) + j] += C[(i * NJ) + k] * D[(k * NL) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/8"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  (cout << \"\\n\") << a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/parallel_sorts/bsort/3"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  call = call_price(vars[i][0], vars[i][1], vars[i][2], vars[i][3], vars[i][4]);\n  if (maxCall < call)\n    maxCall = call;\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(max: maxCall)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JHeisey/Option-Pricer/optionPriceOpenMP/1"}
{"code": "for (i = 0; i < 25; i++)\n{\n  for (j = 0; j < 25; j++)\n  {\n    C[(i * 25) + j] = ((((DATA_TYPE) i) * j) + 2) / 25;\n    C_OMP[(i * 25) + j] = ((((DATA_TYPE) i) * j) + 2) / 25;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GEMM/gemm/22"}
{"code": "for (long int idx = 0; idx < N; ++idx)\n{\n  sum += vec0[idx] * vec1[idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/dot/0"}
{"code": "for (int i = 0; i < qseq_size; i++)\n  query_sequence[i] = seq[rand() % 4];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ga-omp/main/2"}
{"code": "for (j = 0; j <= column_num; j++)\n{\n  standard_simplex_tableau[min.index][j] = standard_simplex_tableau[min.index][j] / simplex_pivot1;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arkaprabha10/Simplex-Algorithm/Algorithm/openmp_final/2"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp8cgjts3t.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp8cgjts3t.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/18"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  a[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task11/0"}
{"code": "for (int i = 0; i < MATRIX_SIZE; ++i)\n  for (int j = 0; j < MATRIX_SIZE; ++j)\n  if (absIEEE754(A[i][j] - B[i][j]) > epsilon)\n{\n  cnt++;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taeguk/dist-prog-assignment/assignment-4/p1/main/2"}
{"code": "for (k = 0; k <= (grid_points[2] - 2); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    add = rhs[m][i][j][k];\n    rms[m] = rms[m] + (add * add);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(rms ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/9"}
{"code": "for (ii = 0; ii < 1000; ii += 32)\n{\n  for (kk = 0; kk < 1000; kk += 32)\n  {\n    for (jj = 0; jj < 1000; jj += 32)\n    {\n      for (i = ii; i < (((ii + 32) < 1000) ? (ii + 32) : (1000)); i++)\n      {\n        for (k = kk; k < (((kk + 32) < 1000) ? (kk + 32) : (1000)); k++)\n        {\n          for (j = jj; j < (((jj + 32) < 1000) ? (jj + 32) : (1000)); j++)\n          {\n            C[i][j] += A[i][k] * B[k][j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/Tiled/optimized_tiled/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  U[i] = (int *) calloc(N, sizeof(int));\n  for (int j = 0; j < N; j++)\n  {\n    U[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NJU-TJL/OpenMP-MPI_Labs/Lab02/OpenMP/LU_OpenMP/3"}
{"code": "for (int i = 0; i < centersize; i++)\n{\n  centers.p[i].coord = &centerBlock[i * dim];\n  centers.p[i].weight = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/33"}
{"code": "for (i = 0; i < m->nrows; ++i)\n{\n  indices[i] = (int *) malloc(max_entries_per_row * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/blocked/7"}
{"code": "for (int i = lowerLimit; i < upperLimit; i++)\n{\n  double sumX = 0;\n  double sumY = 0;\n  for (int j = 0; j < N; j++)\n  {\n    if (i != j)\n    {\n      x_diff = p[i * 5] - p[j * 5];\n      y_diff = p[(i * 5) + 1] - p[(j * 5) + 1];\n      r = sqrt((x_diff * x_diff) + (y_diff * y_diff));\n      mass = p[(j * 5) + 2];\n      mass /= ((r + 1e-3) * (r + 1e-3)) * (r + 1e-3);\n      x_diff *= mass;\n      y_diff *= mass;\n      sumX += x_diff;\n      sumY += y_diff;\n    }\n\n  }\n\n  a_x = (-G) * sumX;\n  a_y = (-G) * sumY;\n  u_x = p[(i * 5) + 3] + (delta_t * a_x);\n  u_y = p[(i * 5) + 4] + (delta_t * a_y);\n  p_buffer[(i * 5) + 3] = u_x;\n  p_buffer[(i * 5) + 4] = u_y;\n  p_buffer[i * 5] = p[i * 5] + (delta_t * u_x);\n  p_buffer[(i * 5) + 1] = p[(i * 5) + 1] + (delta_t * u_y);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DHjerpe/hybrid-Nbody/NBody/main/0"}
{"code": "for (i = 0; i < ((l.N - 5) + 1); ++i)\n{\n  out[i] = l.b;\n  for (j = 0; j < 5; ++j)\n  {\n    out[i] += l.x[i + j] * l.W[(i * 5) + j];\n  }\n\n  activation(&out[i]);\n}\n\n", "pragma": "omp parallel for private(i,j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michimichiamo/neuralnet/nn_omp/0"}
{"code": "for (int i = 0; i < nLinks; i++)\n  omp_destroy_lock(&Locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elena1905/ParallelIsingModel/src/worm/two_threads/Worm/2"}
{"code": "for (unsigned int g = 0; g < ng; ++g)\n{\n  for (unsigned int k = 0; k < nz; k++)\n  {\n    for (unsigned int j = 0; j < ny; j++)\n    {\n      for (unsigned int i = 0; i < nx; i++)\n      {\n        for (unsigned int l = 0; l < nmom; l++)\n        {\n          scat_cs(l, i, j, k, g) = gg_cs(mat(i, j, k) - 1, l, g, g);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/2"}
{"code": "for (int i = 1; i < x_size; i++)\n{\n  for (int j = 1; j < y_size; j++)\n  {\n    if (x_chars[i] == y_chars[j])\n    {\n      grid[i][j] = grid[i - 1][j - 1] + MATCH;\n    }\n    else\n    {\n      grid[i][j] = grid[i - 1][j - 1] + MISMATCH;\n    }\n\n    grid[i][j] = max(grid[i][j], max(grid[i - 1][j] + INDEL, grid[i][j - 1] + INDEL));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bergerom/nw_parallel/nw-openmp/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < N; j++)\n  {\n    sum = sum + (x[j] * a[i][j]);\n    if (abs(b[i] - sum) > 0.00001)\n    {\n      printf(\"%f != %f\\n\", sum, b[i]);\n      printf(\"Validation Failed...\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ChristosDeretzis/High-Performance-Computing/OpenMP/Backsub/backsub_par/1"}
{"code": "for (y = 0; y < (*ctx->countOnes_ptr); y++)\n{\n  indX = roundDouble((*ctx->arrayX_ptr)[x]) + (*ctx->objxy_ptr)[(y * 2) + 1];\n  indY = roundDouble((*ctx->arrayY_ptr)[x]) + (*ctx->objxy_ptr)[y * 2];\n  (*ctx->ind_ptr)[(x * (*ctx->countOnes_ptr)) + y] = fabs((double) ((((indX * (*ctx->IszY_ptr)) * (*ctx->Nfr_ptr)) + (indY * (*ctx->Nfr_ptr))) + (*ctx->k_ptr)));\n  if ((*ctx->ind_ptr)[(x * (*ctx->countOnes_ptr)) + y] >= (*ctx->max_size_ptr))\n    (*ctx->ind_ptr)[(x * (*ctx->countOnes_ptr)) + y] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq/1"}
{"code": "for (i = 0; i < ind[par].size(); i++)\n{\n  if (frontier.find(ind[par][i]) == frontier.end())\n  {\n    frontier[ind[par][i]] = 1;\n    q.push(ind[par][i]);\n    if (NSw.find(ind[par][i]) == NSw.end())\n    {\n      nearneigh[ind[par][i]] = nearneigh[par];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saiharshavellanki/K-BFS/rv/1"}
{"code": "for (i = 0; i < ARCHelems; i++)\n{\n  for (j = 0; j < 4; j++)\n    cor[j] = ARCHvertex[i][j];\n\n  if ((((cor[0] == Src.sourcenode) || (cor[1] == Src.sourcenode)) || (cor[2] == Src.sourcenode)) || (cor[3] == Src.sourcenode))\n  {\n    for (j = 0; j < 4; j++)\n      for (k = 0; k < 3; k++)\n      vertices[j][k] = ARCHcoord[cor[j]][k];\n\n\n    centroid(vertices, xc);\n    source_elms[i] = 2;\n    if (point2fault(xc) >= 0)\n      source_elms[i] = 3;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,vertices,xc,cor) firstprivate(ARCHelems)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/1"}
{"code": "for (int w = M; w >= 0; w--)\n{\n  dptable[w] = dptable_after[w];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10094/main/1"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  a[i] = rand() % 100;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/liba_bundled/main/0"}
{"code": "for (size_t index = 0; index < SIZE; index++)\n{\n  long long sum = 0;\n  for (size_t i = 0; i < index; i++)\n    sum += i;\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dogganidhal/Parallel-processing/OpenMP/helloworld/1"}
{"code": "for (j = 0; j <= 99; j += 1)\n{\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB060-matrixmultiply-orig-no/3"}
{"code": "for (int k = 0; k < MIN_SIZE; k++)\n{\n  vector[k] = MIN_SIZE + (rand() % ((MAX_SIZE - MIN_SIZE) + 1));\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, PORTIONS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roomanidzee/cpp_projects/SomeOpenMPSecond/matrix_and_vector/0"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n{\n  temp = 0.0;\n  for (k = 0; k < 2048; k++)\n    temp += a[i][k] * b[j][k];\n\n  d[i][j] = temp;\n}\n\n\n", "pragma": "omp parallel for private(i,j,k,temp) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/TAffinity/multf/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  M[i] = (double *) malloc(n * (sizeof(double)));\n  if (!M[i])\n  {\n    for (j = i - 1; j >= 0; j--)\n      free(M[j]);\n\n    free(M);\n    M = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidabrahim/Parallel-computing-labs/TP1/matrices_calculator/3"}
{"code": "for (int x = 0; x < nx; x++)\n  for (int y = 0; y < ny; y++)\n  for (int z = 0; z < nz; z++)\n  for (int t = 0; t < nt; t++)\n{\n  size_t i = node_index(x, y, z, t);\n  fwdsrc[0][i] = src + node_index(x + 1, y, z, t);\n  bcksrc[0][i] = src + node_index(x - 1, y, z, t);\n  fwdsrc[1][i] = src + node_index(x, y + 1, z, t);\n  bcksrc[1][i] = src + node_index(x, y - 1, z, t);\n  fwdsrc[2][i] = src + node_index(x, y, z + 1, t);\n  bcksrc[2][i] = src + node_index(x, y, z - 1, t);\n  fwdsrc[3][i] = src + node_index(x, y, z, t + 1);\n  bcksrc[3][i] = src + node_index(x, y, z, t - 1);\n  fwd3src[0][i] = src + node_index(x + 3, y, z, t);\n  bck3src[0][i] = src + node_index(x - 3, y, z, t);\n  fwd3src[1][i] = src + node_index(x, y + 3, z, t);\n  bck3src[1][i] = src + node_index(x, y - 3, z, t);\n  fwd3src[2][i] = src + node_index(x, y, z + 3, t);\n  bck3src[2][i] = src + node_index(x, y, z - 3, t);\n  fwd3src[3][i] = src + node_index(x, y, z, t + 3);\n  bck3src[3][i] = src + node_index(x, y, z, t - 3);\n}\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/dslash-omp/dslash/1"}
{"code": "for (c2 = 0; c2 <= (n + (-1)); c2++)\n{\n  A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n  B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB055-jacobi2d-parallel-no/1"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  int sum = 0;\n  for (int k = 0; k < 500; k++)\n  {\n    sum = sum + (errl2[k] * node2weights[k][i]);\n  }\n\n  errl1[i] = (forpassl1[i] * (1 - forpassl1[i])) * sum;\n}\n\n", "pragma": "omp for schedule(dynamic,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/7"}
{"code": "for (i = 0; i < 10; i++)\n{\n  x = i;\n  y = 0;\n  for (j = 0; j < 10; j++)\n  {\n    y = j;\n    sum += y;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum) firstprivate(x) lastprivate(x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49897-2/0"}
{"code": "for (int i = 0; i < 32; i++)\n{\n  split(arr, n, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/14"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA512)\n{\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_SHA512_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-sha512_fmt_plug/1"}
{"code": "for (int i = 0; i < 992; i++)\n{\n  if (A[i] != (1 * 2))\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, ((double) 1) * 2, A[i]);\n    fail = 1;\n  }\n\n  if (B[i] != (1 * 3))\n  {\n    printf(\"Error at B[%d], h = %lf, d = %lf\\n\", i, ((double) 1) * 3, B[i]);\n    fail = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/3"}
{"code": "for (int i = 0; i < N; i++)\n  res += f(a + (i * h)) * h;\n\n", "pragma": "\t#pragma omp parallel for reduction(+:res) if(Parallel)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/integral/0"}
{"code": "for (i = 1; i < state->nMoves; ++i)\n  if (values[i] < toRet)\n{\n  toRet = values[i];\n  idToRet = i;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luigifusco/CChess/minimax/2"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    energy0[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = state_energy[FTNREF1D(1, 1)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/generate_chunk_kernel_c/0"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  tmp[i + (SIZE / 2)] = 0;\n  y[i + (SIZE / 2)] = 0;\n  for (int j = 0; j < SIZE; j++)\n  {\n    tmp[i + (SIZE / 2)] = (A3[(i * SIZE) + j] * x[j]) + tmp[i + (SIZE / 2)];\n    y[i + (SIZE / 2)] = (B3[(i * SIZE) + j] * x[j]) + y[i + (SIZE / 2)];\n  }\n\n  y[i + (SIZE / 2)] = (43532.0f * tmp[i + (SIZE / 2)]) + (12313.0f * y[i + (SIZE / 2)]);\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS) depend(in: b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/GESUMMV_M/gesummvPL/2"}
{"code": "for (idx_t n = 0; n < nnz; ++n)\n{\n  assert(inds[n] >= minidx);\n  const idx_t idx = inds[n] - minidx;\n  if (slice_mkrs[idx] == 0)\n  {\n    slice_mkrs[idx] = 1;\n    ++found;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/4"}
{"code": "for (int n = 0; n < N; n++)\n{\n  z[n] = distribution(gen);\n  x[i][n] = m[t & 1][n] + (sigma * ((sqrt(1 - ccov) * z[n]) + ((sqrt(ccov) * r) * p[t & 1][n])));\n}\n\n", "pragma": "            #pragma omp prallel for shared(x,m,sigma,ccov,p,r,z)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/R1ES_omp_alt/6"}
{"code": "for (i = 0; i < nelem; i++)\n{\n  dmin = DBL_MAX;\n  for (j = 0; j < NGRUPOS; j++)\n  {\n    adis = gendist(elem[i], cent[j]);\n    if (adis < dmin)\n    {\n      dmin = adis;\n      ngrupo = j;\n    }\n\n  }\n\n  popul[i] = ngrupo;\n}\n\n", "pragma": "omp parallel for private(i, j, adis, dmin, ngrupo) schedule(dynamic,2) num_threads(32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/fun_p/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < n; i++)\n  {\n    a[i + (j * n)] = ((double) lrand48()) / MAXRAND;\n    if (i == j)\n    {\n      a[i + (j * n)] *= 10;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/6"}
{"code": "for (i2 = 0; i2 < n2; i2++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    u[n3 - 1][i2][i1] = u[1][i2][i1];\n    u[0][i2][i1] = u[n3 - 2][i2][i1];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/9"}
{"code": "for (int i = 0; i < size; i++)\n{\n  omp_destroy_lock(&lock_matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/7"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 10; j++)\n{\n  A[i][j] = 4;\n  b[i] = 4;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/OpenMP/matrixvectormultiplication/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (!input.eof())\n  {\n    input >> ar[i];\n  }\n  else\n  {\n    (cout << \"YOU LIE!!! There are not enough numbers in file!!\") << endl;\n    exit(EXIT_FAILURE);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_1/parallel_1/1"}
{"code": "for (i = 0; i < dim; i++)\n{\n  g[i] = (((2 * sqrt(quartic(x, dim))) * 2) * (i + 1)) * x[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mazury/Parallel-Programming-C-Project/conjugate-gradient-openmp/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    C[(i * 2048) + j] *= 4546;\n    for (k = 0; k < 2048; k++)\n    {\n      C[(i * 2048) + j] += ((12435 * A[(i * 2048) + k]) * B[(j * 2048) + k]) + ((12435 * B[(i * 2048) + k]) * A[(j * 2048) + k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/SYR2K/src/syr2k/3"}
{"code": "for (int i = 0; i < INT_ARRAY_SIZE; ++i)\n{\n  array[i] = rand() % 50;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/0scari/Parralel-programmin-pratice/remote/p12/main/1"}
{"code": "for (int i = 0; i < n_bodies_to_compute; i++)\n{\n  my_new_bodies[i] = update_body(last_step.bodies()[i + idx_from], *complete_quadtree, dt, G, theta);\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(n_bodies_to_compute, my_new_bodies, last_step, idx_from, complete_quadtree, dt, G, theta)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andreastedile/barnes-hut/simulators/mpi-barnes-hut-simulator/src/mpi_barnes_hut_simulator/0"}
{"code": "for (int i = 0; i < 5; ++i)\n  span = max(span, elap[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/refinement/5"}
{"code": "for (int i = 0; i < (repetitionNumber + 1); i++)\n{\n  free(x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/12"}
{"code": "for (h = 0; h < 1024; ++h)\n  A[h] = malloc(1024 * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/3"}
{"code": "for (j3 = 1; j3 < (m3j - 1); j3++)\n{\n  for (j2 = 1; j2 < (m2j - 1); j2++)\n  {\n    for (j1 = 1; j1 < m1j; j1++)\n    {\n      i3 = (2 * j3) - d3;\n      i2 = (2 * j2) - d2;\n      i1 = (2 * j1) - d1;\n      x1[(((i3 * m2k) * m1k) + (i2 * m1k)) + i1] = ((or[((((i3 + 1) * m2k) * m1k) + (i2 * m1k)) + i1] + or[((((i3 + 1) * m2k) * m1k) + ((i2 + 2) * m1k)) + i1]) + or[(((i3 * m2k) * m1k) + ((i2 + 1) * m1k)) + i1]) + or[((((i3 + 2) * m2k) * m1k) + ((i2 + 1) * m1k)) + i1];\n      y1[(((i3 * m2k) * m1k) + (i2 * m1k)) + i1] = ((or[(((i3 * m2k) * m1k) + (i2 * m1k)) + i1] + or[((((i3 + 2) * m2k) * m1k) + (i2 * m1k)) + i1]) + or[(((i3 * m2k) * m1k) + ((i2 + 2) * m1k)) + i1]) + or[((((i3 + 2) * m2k) * m1k) + ((i2 + 2) * m1k)) + i1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp teams distribute parallel for default(shared) private( i1,i2,i3) collapse(3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/4"}
{"code": "for (int row = 0; row < MatrixOrder; row++)\n{\n  for (int col = 0; col < MatrixOrder; col++)\n  {\n    srand(row + col);\n    firstParaMatrix[row][col] = (rand() % 10) * FactorIntToDouble;\n    secondParaMatrix[row][col] = (rand() % 10) * FactorIntToDouble;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/poodarchu/parallel-computing/OpenMP/mat_vec_mult/1"}
{"code": "for (i = 0; i < 10; i++)\n  printint(i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joanrieu/parac/sample/0"}
{"code": "for (int iter = 0; iter < iters; iter++)\n{\n  #pragma acc parallel loop gang vector collapse(2)\n  for (int i = 0; i < len; i++)\n  {\n    for (int j = 0; j < len; j++)\n    {\n      float t = 0;\n      for (int k = 0; k < len; k++)\n        t += a[k + (j * len)] * b[i + (k * len)];\n\n      x[i + (j * len)] = t;\n    }\n\n  }\n\n  #pragma acc parallel loop gang vector\n  for (int i = 0; i < (len * len); i++)\n  {\n    a[i] = x[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/matmul/4"}
{"code": "for (j = 0; j < i; j++)\n{\n  tempV += (d * M[i][j]) * R[j];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:tempV)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/1"}
{"code": "for (int i = 0; i < numNeurons; i++)\n{\n  int neuron_index = i % neurons_per_item;\n  int item_index = (int) (i / neurons_per_item);\n  float voltage = voltage_array[i];\n  float ref_time = reftime_array[i];\n  float current = bias[neuron_index] + (gain[neuron_index] * encode_result[item_index]);\n  float dV;\n  float spike;\n  float mult;\n  dV = (-expm1f((-dt) / tau_rc)) * (current - voltage);\n  voltage = fmaxf(voltage + dV, 0.f);\n  ref_time -= dt;\n  mult = ref_time;\n  mult *= (-1.f) / dt;\n  mult += 1.f;\n  mult = (mult > 1.f) ? (1.f) : (mult);\n  mult = (mult < 0.f) ? (0.f) : (mult);\n  voltage *= mult;\n  if (voltage > 1.f)\n  {\n    spike = 1.f / dt;\n    ref_time = tau_ref + (dt * (1.f - ((voltage - 1.f) / dV)));\n    voltage = 0.f;\n  }\n  else\n  {\n    spike = 0.f;\n  }\n\n  reftime_array[i] = ref_time;\n  voltage_array[i] = voltage;\n  spikes[i] = spike;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lif-omp/main/0"}
{"code": "for (int k = 0; k < N; k++)\n{\n  alpha = alpha + (U[k][i] * U[k][i]);\n  beta = beta + (U[k][j] * U[k][j]);\n  gamma = gamma + (U[k][i] * U[k][j]);\n}\n\n", "pragma": "          #pragma omp parallel for num_threads(num) reduction(+:alpha) reduction(+:beta) reduction(+:gamma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kratikakothari/IPSC_PROJECT_SVD_OPENMP/SVD_parallel/2"}
{"code": "for (int i = 0; i < omp_get_num_threads(); i++)\n{\n  vec_results_final.insert(vec_results_final.end(), vec_results.begin(), vec_results.end());\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JaredP94/Distributed-Equi-Join/Hybrid Solution/main/0"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  r = dot0(a, b);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/13"}
{"code": "for (i = 0; i < size; i++)\n{\n  (((out << i) << \"\\t\") << newPageRank[i]) << endl;\n  min = (count[i] < min) ? (count[i]) : (min);\n  minj = (count[i] == min) ? (i) : (minj);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srinivasbalaji-1/openmpProject/facebookEgo/7"}
{"code": "for (i = 0; i < n; ++i)\n{\n  PRNG(threadNo);\n  double x = nSeed[threadNo * 512];\n  PRNG(threadNo);\n  double y = nSeed[threadNo * 512];\n  x /= 32767;\n  y /= 32767;\n  if ((((x - 0.5) * (x - 0.5)) + ((y - 0.5) * (y - 0.5))) <= (r * r))\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "omp for reduction (+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/parallel_monte_carlo/0"}
{"code": "for (i = 0; i < (height * width); i++)\n{\n  Gradient[i] = atan2(Horizontal[i], Vertical[i]);\n  Magnitude[i] = sqrt((Vertical[i] * Vertical[i]) + (Horizontal[i] * Horizontal[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Robert-M-Hughes/High-Preformance-Computing/Project02/Project02Serial/main/1"}
{"code": "for (i = 0; i < (rowsNumber / sqrt_comm_sz); i++)\n{\n  for (int c = 0; c <= 2; c++)\n  {\n    leftCol[(3 * i) + c] = myArray[i][0 + c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/8"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  tmp[i] = rocalution_double(this->vec_[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/12"}
{"code": "for (I = 0; I < N; I++)\n{\n  s4 = xend[I][0];\n  s4 = s4 + func2[I][0];\n  xend[I][0] = s4;\n}\n\n", "pragma": "omp parallel for reduction(+:s4)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jainpranav/OpenMP_Fun/Project2/matrix/8"}
{"code": "for (j = 0; j < num_snakes; j++)\n{\n  world[tail[j].line][tail[j].col] = 0;\n  switch (snakes[j].direction)\n  {\n    case 'N':\n      if ((snakes[j].head.line != 0) && (world[snakes[j].head.line - 1][snakes[j].head.col] == 0))\n    {\n      world[snakes[j].head.line - 1][snakes[j].head.col] = snakes[j].encoding;\n      snakes[j].head.line -= 1;\n    }\n    else\n      if ((snakes[j].head.line != 0) && (world[snakes[j].head.line - 1][snakes[j].head.col] != 0))\n    {\n      collision = 1;\n      snakes[j].head.line -= 1;\n    }\n    else\n      if ((snakes[j].head.line == 0) && (world[num_lines - 1][snakes[j].head.col] == 0))\n    {\n      world[num_lines - 1][snakes[j].head.col] = snakes[j].encoding;\n      snakes[j].head.line = num_lines - 1;\n    }\n    else\n      if ((snakes[j].head.line == 0) && (world[num_lines - 1][snakes[j].head.col] != 0))\n    {\n      collision = 1;\n      snakes[j].head.line = num_lines - 1;\n    }\n\n\n\n\n      break;\n\n    case 'S':\n      if ((snakes[j].head.line != (num_lines - 1)) && (world[snakes[j].head.line + 1][snakes[j].head.col] == 0))\n    {\n      world[snakes[j].head.line + 1][snakes[j].head.col] = snakes[j].encoding;\n      snakes[j].head.line += 1;\n    }\n    else\n      if ((snakes[j].head.line != (num_lines - 1)) && (world[snakes[j].head.line + 1][snakes[j].head.col] != 0))\n    {\n      collision = 1;\n      snakes[j].head.line += 1;\n    }\n    else\n      if ((snakes[j].head.line == (num_lines - 1)) && (world[0][snakes[j].head.col] == 0))\n    {\n      world[0][snakes[j].head.col] = snakes[j].encoding;\n      snakes[j].head.line = 0;\n    }\n    else\n      if ((snakes[j].head.line == (num_lines - 1)) && (world[0][snakes[j].head.col] != 0))\n    {\n      collision = 1;\n      snakes[j].head.line = 0;\n    }\n\n\n\n\n      break;\n\n    case 'E':\n      if ((snakes[j].head.col != (num_cols - 1)) && (world[snakes[j].head.line][snakes[j].head.col + 1] == 0))\n    {\n      world[snakes[j].head.line][snakes[j].head.col + 1] = snakes[j].encoding;\n      snakes[j].head.col += 1;\n    }\n    else\n      if ((snakes[j].head.col != (num_cols - 1)) && (world[snakes[j].head.line][snakes[j].head.col + 1] != 0))\n    {\n      collision = 1;\n      snakes[j].head.col += 1;\n    }\n    else\n      if ((snakes[j].head.col == (num_cols - 1)) && (world[snakes[j].head.line][0] == 0))\n    {\n      world[snakes[j].head.line][0] = snakes[j].encoding;\n      snakes[j].head.col = 0;\n    }\n    else\n      if ((snakes[j].head.col == (num_cols - 1)) && (world[snakes[j].head.line][0] != 0))\n    {\n      collision = 1;\n      snakes[j].head.col = 0;\n    }\n\n\n\n\n      break;\n\n    case 'V':\n      if ((snakes[j].head.col != 0) && (world[snakes[j].head.line][snakes[j].head.col - 1] == 0))\n    {\n      world[snakes[j].head.line][snakes[j].head.col - 1] = snakes[j].encoding;\n      snakes[j].head.col -= 1;\n    }\n    else\n      if ((snakes[j].head.col != 0) && (world[snakes[j].head.line][snakes[j].head.col - 1] != 0))\n    {\n      collision = 1;\n      snakes[j].head.col -= 1;\n    }\n    else\n      if ((snakes[j].head.col == 0) && (world[snakes[j].head.line][num_cols - 1] == 0))\n    {\n      world[snakes[j].head.line][num_cols - 1] = snakes[j].encoding;\n      snakes[j].head.col = num_cols - 1;\n    }\n    else\n      if ((snakes[j].head.col == 0) && (world[snakes[j].head.line][num_cols - 1] != 0))\n    {\n      collision = 1;\n      snakes[j].head.col = num_cols - 1;\n    }\n\n\n\n\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yanxiaojing16/Parallel-Snake---OpenMP/parallel_snake/0"}
{"code": "for (i = 0; i < rows; ++i)\n{\n  H[i][0] = 0.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/8"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n  _output[i] = localBins[0][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double old_x = particles[i].x;\n  double old_y = particles[i].y;\n  move(particles[i]);\n  move_to_another_block(i, old_x, old_y, particles);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xingyousong/Parallelized-Particle-Simulation-CS267-HW2/serial/3"}
{"code": "for (j = 0; j < 10; j++)\n{\n  sum = 0;\n  for (k = 0; k < 10; k++)\n  {\n    sum += A[i][k] * B[k][j];\n  }\n\n  C[i][j] = sum;\n}\n\n", "pragma": "omp parallel for private(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment1/Asgn11/1"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = SMVP(u);\n    w[index] = smvp;\n    r[index] = u[index] - w[index];\n    p[index] = r[index];\n    rroTemp += r[index] * p[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:rroTemp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_cg_kernel/3"}
{"code": "for (int i = rank * chunk; i < ((rank + 1) * chunk); i++)\n  local_sum += f(((double) i) / 1000000);\n\n", "pragma": "omp for schedule(dynamic) reduction(+:local_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture15/hybrid_pi/0"}
{"code": "for (uint i = 0; i < length; i++)\n{\n  filterCoeffs[i] = SAMPLETYPE(coeffs[i] * scale);\n  filterCoeffsStereo[2 * i] = SAMPLETYPE(coeffs[i] * scale);\n  filterCoeffsStereo[(2 * i) + 1] = SAMPLETYPE(coeffs[i] * scale);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/FIRFilter/0"}
{"code": "for (j = 0; j <= (NC + 1); j++)\n  t[1][0][j] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/8"}
{"code": "for (int i = 0; i < points; i++)\n  output[i] = Fresnel_Sine_Integral(x[i]);\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fresnel-omp/main/2"}
{"code": "for (ei_new = 0; ei_new < public.in2_pad_cols; ei_new++)\n{\n  pos_ori = ei_new * public.in2_pad_rows;\n  sum = 0;\n  #pragma loop name kernel#7#0\n  for (position = pos_ori; position < (pos_ori + public.in2_pad_rows); position = position + 1)\n  {\n    private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n    sum = private.d_in2_pad[position];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/8"}
{"code": "for (; i < halfsize; i++)\n{\n  tmp[i] = hist[i];\n  hist[i] = hist[i + halfsize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/9"}
{"code": "for (int i = 0; i < V; i++)\n{\n  change[i] = localchange[i];\n  localchange[i] = false;\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspDataDriven/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  ref[i] = n * i;\n  a[i] = -2005.0;\n  for (j = 0; j < n; j++)\n    b[(i * n) + j] = i;\n\n}\n\n", "pragma": "omp parallel for if (m > threshold_row) default (none) private (i,j) shared(a, b, n, m, ref)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/Laborator/lab02/ex_lab/3 - mxv/init_data_omp/0"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d: c[%d]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mohan08p/ComputerEngineeringLabs/Academics/B.E./SEM II/PDS Labs/OpenMP/openmp_add/0"}
{"code": "for (i = 0; i <= (public.allPoints - 1); i += 1)\n{\n  private[i].d_in2_sub2_sqr = (float *) malloc(public.in2_sub2_sqr_mem);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/9"}
{"code": "for (i = 0; i < natr; i++)\n{\n  if (!(catr[i].valsrids = (VR *) calloc(nrec, sizeof(VR))))\n  {\n    printf(\"Memory Crunch @ catr[%d].valsrids\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidomenico/OpenMP_transaction/NU-MineBench-2.0/src/ScalParC_transaction/drive/2"}
{"code": "for (int i = 0; i < w; i++)\n  for (int j = 0; j < h; j++)\n  f[i + (j * w)] = 1 / (1 + (((1.0 * r) * r) / (((i - (w / 2)) * (i - (w / 2))) + ((j - (h / 2)) * (j - (h / 2))))));\n\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/6"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  struct tablo *SubMatrixAByRows = allocateTablo(getSizeSubmatrixDividedByRows(matrixA, numprocs));\n  getSubmatrixDividedByRows(matrixA, SubMatrixAByRows, i, numprocs);\n  send_slice(SubMatrixAByRows->tab, SubMatrixAByRows->size, i);\n  free(SubMatrixAByRows);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/13"}
{"code": "for (i = 0; i < 9999999; i++)\n{\n  stuff[i % 1000] = sin(i * i);\n}\n\n", "pragma": "omp parallel for private(i) shared(stuff)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiskattema/openmptest/main/0"}
{"code": "for (t = 0; t < k; t++)\n  free(Q[t]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/43"}
{"code": "for (i = 0; i < L; i++)\n{\n  for (j = 0; j < L; j++)\n  {\n    u = ((j + 1) == L) ? (0) : (j + 1);\n    d = ((j - 1) == (-1)) ? (L - 1) : (j - 1);\n    r = ((i + 1) == L) ? (0) : (i + 1);\n    l = ((i - 1) == (-1)) ? (L - 1) : (i - 1);\n    neighs[i + (j * L)][UP] = i + (u * L);\n    neighs[i + (j * L)][DOWN] = i + (d * L);\n    neighs[i + (j * L)][RIGHT] = r + (j * L);\n    neighs[i + (j * L)][LEFT] = l + (j * L);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/4"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  printf(\"thread = %d, i = %2d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ssssmiyassss/openmp_test/test02/0"}
{"code": "for (size_t i = 0; i < Nelt; i++)\n{\n  lengthlength(i, i) = 0;\n  lengthlength(i, g.next(i)) = 0;\n  lengthlength(i, g.prev(i)) = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/3"}
{"code": "for (c = L; c <= H; c++)\n{\n  if (list2[c - L] == 0)\n  {\n    printf(\"%d \", c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/sieve/sieve.hybrid/3"}
{"code": "for (i = 0; i < MP1; i++)\n  for (j = 0; j < NP1; j++)\n{\n  PSI[i][j] = (A * sin((i + .5) * DI)) * sin((j + .5) * DJ);\n  P[i][j] = (PCF * (cos((2.0 * i) * DI) + cos((2.0 * j) * DJ))) + 50000.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/11"}
{"code": "for (int i = 1; i < (ELEMENT_COUNT - 2); i++)\n{\n  b[i] = ((a[i - 1] + a[i]) + a[i + 1]) / DIVIDER;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,PORTIONS_1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roomanidzee/cpp_projects/SomeOpenMPSecond/time_metrics/1"}
{"code": "for (i = 0; i < thread_count; i++)\n{\n  x = ((2 * random()) / ((double) 32767)) - 1.0;\n  y = ((2 * random()) / ((double) 32767)) - 1.0;\n  distance_squared = (x * x) + (y * y);\n  if (distance_squared <= 1.0)\n  {\n    number_in_circle++;\n  }\n\n}\n\n", "pragma": "omp for firstprivate(randSeed) private(x,y) reduction(+: number_in_circle)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BitJetKit/Monte_Carlo_OpenMP/Pi/0"}
{"code": "for (i = 0; i < bands; i++)\n{\n  sum[i] = 0.0;\n  for (j = 0; j < bands; j++)\n  {\n    sumv[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"Thread num = %d, i = %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/for_schedule/0"}
{"code": "for (int i = 0; i < n_omp; i++)\n{\n  {\n    puts(thrd_str);\n  }\n}\n\n", "pragma": "omp for ordered schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/roryck/Donde/donde/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < l; i++)\n  {\n    a[i + (j * l)] = 0.0;\n    for (k = 0; k < m; k++)\n    {\n      a[i + (j * l)] = a[i + (j * l)] + (b[i + (k * l)] * c[k + (j * m)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_host/mxm/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][2];\n      u31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = rsd[i][j][k][1] * u31;\n      flux[i][j][k][2] = (rsd[i][j][k][2] * u31) + (C2 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][3] = rsd[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/8"}
{"code": "for (int y = 1; y < (rows - 1); y++)\n{\n  for (int x = 1; x < (columns - 1); x++)\n  {\n    fprintf(fp, \"%c\", *((grid + (y * columns)) + x));\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp_alt_1dArr/0"}
{"code": "for (i = 0; i < 600; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sendevour/openmp-samples/task_parallel/0"}
{"code": "for (long i = 0; i < size; i++)\n{\n  matrix[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Vector_Multiplication_Serial_Parallel/1"}
{"code": "for (i = 0; i < m; i++)\n  c[i] = (int *) malloc(p * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/mul_omp_q6/3"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 1; j <= (m - 1); j += 1)\n  {\n    b[i][j] = b[i][j - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j) firstprivate (n,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_outer_only/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a[j] += b[j];\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for reduction(+:a[0:N]) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_array/reduction_array/2"}
{"code": "for (i = 0; i < (128 + 1); i++)\n{\n  for (j = 0; j < (128 + 1); j++)\n  {\n    uold[i][j] = u[i][j] + (alpha * ((unew[i][j] - (2. * u[i][j])) + uold[i][j]));\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/11"}
{"code": "for (int i = 0; i < size; i++)\n{\n  m[i] = (double *) malloc(size * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YShoun/matrix-mul/main/0"}
{"code": "for (int i = 0; i < nodeCount; i++)\n  nodes.push_back(nodeIds[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/CSharpWrapperApplication/custom_sources/model_part_wrapper/2"}
{"code": "for (i = 0; i < width; ++i)\n{\n  send_bottom[i] = p(height, i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/8"}
{"code": "for (int m = 0; m < node->n_children; m++)\n{\n  double v = (node->children[m].q * ((node->state.next_player == player_col) ? (1) : (-1))) + (((C_PUCT * node->children[m].p) * sqrt_N) / (node->children[m].N_effective + 1));\n  if (v > best)\n  {\n    best = v;\n    index = m;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlSaeed/15618-Final-Project/mcts_player/1"}
{"code": "for (it = 0; it < num_its; it++)\n{\n  int ix;\n  int iy;\n  int ir;\n  for (ix = 0; ix < n; ix++)\n  {\n    for (iy = 0; iy < m; iy++)\n    {\n      REAL *temp_u = &u[(((ix + radius) * u_dimY) + radius) + iy];\n      REAL *temp_uold = &uold[(((ix + radius) * u_dimY) + radius) + iy];\n      REAL result = temp_uold[0] * coeff[0];\n      for (ir = 1; ir <= radius; ir++)\n      {\n        result += coeff[ir] * temp_uold[ir];\n        result += coeff[-ir] * temp_uold[-ir];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n      }\n\n      *temp_u = result / count;\n    }\n\n  }\n\n  REAL *tmp = uold;\n  uold = u;\n  u = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/benchmarks/stencil2d/stencil2d/2"}
{"code": "for (i = 1; i <= 3; i++)\n{\n  its3 = omp_get_thread_num();\n  printf(\"Print #3, its3 = %d\\n\", its3);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_6/c_print/1"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  count += count_bits_in_word(v[i]);\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/0"}
{"code": "for (frame_num = 1; frame_num <= Nf; frame_num++)\n{\n  printf(\"\\rProcessing frame %d / %d\", frame_num, Nf);\n  fflush(stdout);\n  MAT *I = get_frame(video, frame_num, 0, 1);\n  int Ih = I->m;\n  int Iw = I->n;\n  for (i = 0; i < Nc; i++)\n  {\n    xc[i][frame_num] = xc[i][frame_num - 1];\n    yc[i][frame_num] = yc[i][frame_num - 1];\n    for (j = 0; j < Np; j++)\n    {\n      r[i][j][frame_num] = r[i][j][frame_num - 1];\n    }\n\n  }\n\n  for (cell_num = 0; cell_num < Nc; cell_num++)\n  {\n    double xci = xc[cell_num][frame_num];\n    double yci = yc[cell_num][frame_num];\n    double *ri = (double *) malloc((sizeof(double)) * Np);\n    for (j = 0; j < Np; j++)\n    {\n      ri[j] = r[cell_num][j][frame_num];\n    }\n\n    double ycavg = 0.0;\n    for (i = (frame_num > 10) ? (frame_num - 10) : (0); i < frame_num; i++)\n    {\n      ycavg += yc[cell_num][i];\n    }\n\n    ycavg = ycavg / ((double) ((frame_num > 10) ? (10) : (frame_num)));\n    int u1 = max((xci - (4.0 * R)) + 0.5, 0);\n    int u2 = min((xci + (4.0 * R)) + 0.5, Iw - 1);\n    int v1 = max((yci - (2.0 * R)) + 1.5, 0);\n    int v2 = min((yci + (2.0 * R)) + 1.5, Ih - 1);\n    MAT *Isub = m_get((v2 - v1) + 1, (u2 - u1) + 1);\n    for (i = v1; i <= v2; i++)\n    {\n      for (j = u1; j <= u2; j++)\n      {\n        m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n      }\n\n    }\n\n    MAT *Ix = gradient_x(Isub);\n    MAT *Iy = gradient_y(Isub);\n    MAT *IE = m_get(Isub->m, Isub->n);\n    for (i = 0; i < Isub->m; i++)\n    {\n      for (j = 0; j < Isub->n; j++)\n      {\n        double temp_x = m_get_val(Ix, i, j);\n        double temp_y = m_get_val(Iy, i, j);\n        m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n      }\n\n    }\n\n    long long MGVF_start_time = get_time();\n    MAT *IMGVF = MGVF(IE, 1, 1);\n    MGVF_time += get_time() - MGVF_start_time;\n    xci = xci - ((double) u1);\n    yci = yci - ((double) (v1 - 1));\n    ycavg = ycavg - ((double) (v1 - 1));\n    long long snake_start_time = get_time();\n    ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n    snake_time += get_time() - snake_start_time;\n    xci = xci + u1;\n    yci = yci + (v1 - 1);\n    xc[cell_num][frame_num] = xci;\n    yc[cell_num][frame_num] = yci;\n    for (j = 0; j < Np; j++)\n    {\n      r[cell_num][j][frame_num] = ri[j];\n      x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n      y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n    }\n\n    m_free(IMGVF);\n    free(ri);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/26"}
{"code": "for (i = 0; i < N; i++)\n{\n  if ((adjacency[head][i] == 1) && (flag[i] == 0))\n  {\n    flag[i] = 1;\n    nodeQueue.push(i);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nersle/parallelProgramingProject/bfs/bfsMPI/3"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      tmp1 = dt * tz1;\n      tmp2 = dt * tz2;\n      lhs[i][j][k][AA][0][0] = (((-tmp2) * fjac[i][j][k - 1][0][0]) - (tmp1 * njac[i][j][k - 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][AA][0][1] = ((-tmp2) * fjac[i][j][k - 1][0][1]) - (tmp1 * njac[i][j][k - 1][0][1]);\n      lhs[i][j][k][AA][0][2] = ((-tmp2) * fjac[i][j][k - 1][0][2]) - (tmp1 * njac[i][j][k - 1][0][2]);\n      lhs[i][j][k][AA][0][3] = ((-tmp2) * fjac[i][j][k - 1][0][3]) - (tmp1 * njac[i][j][k - 1][0][3]);\n      lhs[i][j][k][AA][0][4] = ((-tmp2) * fjac[i][j][k - 1][0][4]) - (tmp1 * njac[i][j][k - 1][0][4]);\n      lhs[i][j][k][AA][1][0] = ((-tmp2) * fjac[i][j][k - 1][1][0]) - (tmp1 * njac[i][j][k - 1][1][0]);\n      lhs[i][j][k][AA][1][1] = (((-tmp2) * fjac[i][j][k - 1][1][1]) - (tmp1 * njac[i][j][k - 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][AA][1][2] = ((-tmp2) * fjac[i][j][k - 1][1][2]) - (tmp1 * njac[i][j][k - 1][1][2]);\n      lhs[i][j][k][AA][1][3] = ((-tmp2) * fjac[i][j][k - 1][1][3]) - (tmp1 * njac[i][j][k - 1][1][3]);\n      lhs[i][j][k][AA][1][4] = ((-tmp2) * fjac[i][j][k - 1][1][4]) - (tmp1 * njac[i][j][k - 1][1][4]);\n      lhs[i][j][k][AA][2][0] = ((-tmp2) * fjac[i][j][k - 1][2][0]) - (tmp1 * njac[i][j][k - 1][2][0]);\n      lhs[i][j][k][AA][2][1] = ((-tmp2) * fjac[i][j][k - 1][2][1]) - (tmp1 * njac[i][j][k - 1][2][1]);\n      lhs[i][j][k][AA][2][2] = (((-tmp2) * fjac[i][j][k - 1][2][2]) - (tmp1 * njac[i][j][k - 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][AA][2][3] = ((-tmp2) * fjac[i][j][k - 1][2][3]) - (tmp1 * njac[i][j][k - 1][2][3]);\n      lhs[i][j][k][AA][2][4] = ((-tmp2) * fjac[i][j][k - 1][2][4]) - (tmp1 * njac[i][j][k - 1][2][4]);\n      lhs[i][j][k][AA][3][0] = ((-tmp2) * fjac[i][j][k - 1][3][0]) - (tmp1 * njac[i][j][k - 1][3][0]);\n      lhs[i][j][k][AA][3][1] = ((-tmp2) * fjac[i][j][k - 1][3][1]) - (tmp1 * njac[i][j][k - 1][3][1]);\n      lhs[i][j][k][AA][3][2] = ((-tmp2) * fjac[i][j][k - 1][3][2]) - (tmp1 * njac[i][j][k - 1][3][2]);\n      lhs[i][j][k][AA][3][3] = (((-tmp2) * fjac[i][j][k - 1][3][3]) - (tmp1 * njac[i][j][k - 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][AA][3][4] = ((-tmp2) * fjac[i][j][k - 1][3][4]) - (tmp1 * njac[i][j][k - 1][3][4]);\n      lhs[i][j][k][AA][4][0] = ((-tmp2) * fjac[i][j][k - 1][4][0]) - (tmp1 * njac[i][j][k - 1][4][0]);\n      lhs[i][j][k][AA][4][1] = ((-tmp2) * fjac[i][j][k - 1][4][1]) - (tmp1 * njac[i][j][k - 1][4][1]);\n      lhs[i][j][k][AA][4][2] = ((-tmp2) * fjac[i][j][k - 1][4][2]) - (tmp1 * njac[i][j][k - 1][4][2]);\n      lhs[i][j][k][AA][4][3] = ((-tmp2) * fjac[i][j][k - 1][4][3]) - (tmp1 * njac[i][j][k - 1][4][3]);\n      lhs[i][j][k][AA][4][4] = (((-tmp2) * fjac[i][j][k - 1][4][4]) - (tmp1 * njac[i][j][k - 1][4][4])) - (tmp1 * dz5);\n      lhs[i][j][k][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dz1);\n      lhs[i][j][k][BB][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n      lhs[i][j][k][BB][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n      lhs[i][j][k][BB][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n      lhs[i][j][k][BB][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n      lhs[i][j][k][BB][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n      lhs[i][j][k][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dz2);\n      lhs[i][j][k][BB][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n      lhs[i][j][k][BB][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n      lhs[i][j][k][BB][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n      lhs[i][j][k][BB][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n      lhs[i][j][k][BB][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n      lhs[i][j][k][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dz3);\n      lhs[i][j][k][BB][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n      lhs[i][j][k][BB][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n      lhs[i][j][k][BB][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n      lhs[i][j][k][BB][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n      lhs[i][j][k][BB][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n      lhs[i][j][k][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dz4);\n      lhs[i][j][k][BB][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n      lhs[i][j][k][BB][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n      lhs[i][j][k][BB][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n      lhs[i][j][k][BB][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n      lhs[i][j][k][BB][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n      lhs[i][j][k][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dz5);\n      lhs[i][j][k][CC][0][0] = ((tmp2 * fjac[i][j][k + 1][0][0]) - (tmp1 * njac[i][j][k + 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][CC][0][1] = (tmp2 * fjac[i][j][k + 1][0][1]) - (tmp1 * njac[i][j][k + 1][0][1]);\n      lhs[i][j][k][CC][0][2] = (tmp2 * fjac[i][j][k + 1][0][2]) - (tmp1 * njac[i][j][k + 1][0][2]);\n      lhs[i][j][k][CC][0][3] = (tmp2 * fjac[i][j][k + 1][0][3]) - (tmp1 * njac[i][j][k + 1][0][3]);\n      lhs[i][j][k][CC][0][4] = (tmp2 * fjac[i][j][k + 1][0][4]) - (tmp1 * njac[i][j][k + 1][0][4]);\n      lhs[i][j][k][CC][1][0] = (tmp2 * fjac[i][j][k + 1][1][0]) - (tmp1 * njac[i][j][k + 1][1][0]);\n      lhs[i][j][k][CC][1][1] = ((tmp2 * fjac[i][j][k + 1][1][1]) - (tmp1 * njac[i][j][k + 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][CC][1][2] = (tmp2 * fjac[i][j][k + 1][1][2]) - (tmp1 * njac[i][j][k + 1][1][2]);\n      lhs[i][j][k][CC][1][3] = (tmp2 * fjac[i][j][k + 1][1][3]) - (tmp1 * njac[i][j][k + 1][1][3]);\n      lhs[i][j][k][CC][1][4] = (tmp2 * fjac[i][j][k + 1][1][4]) - (tmp1 * njac[i][j][k + 1][1][4]);\n      lhs[i][j][k][CC][2][0] = (tmp2 * fjac[i][j][k + 1][2][0]) - (tmp1 * njac[i][j][k + 1][2][0]);\n      lhs[i][j][k][CC][2][1] = (tmp2 * fjac[i][j][k + 1][2][1]) - (tmp1 * njac[i][j][k + 1][2][1]);\n      lhs[i][j][k][CC][2][2] = ((tmp2 * fjac[i][j][k + 1][2][2]) - (tmp1 * njac[i][j][k + 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][CC][2][3] = (tmp2 * fjac[i][j][k + 1][2][3]) - (tmp1 * njac[i][j][k + 1][2][3]);\n      lhs[i][j][k][CC][2][4] = (tmp2 * fjac[i][j][k + 1][2][4]) - (tmp1 * njac[i][j][k + 1][2][4]);\n      lhs[i][j][k][CC][3][0] = (tmp2 * fjac[i][j][k + 1][3][0]) - (tmp1 * njac[i][j][k + 1][3][0]);\n      lhs[i][j][k][CC][3][1] = (tmp2 * fjac[i][j][k + 1][3][1]) - (tmp1 * njac[i][j][k + 1][3][1]);\n      lhs[i][j][k][CC][3][2] = (tmp2 * fjac[i][j][k + 1][3][2]) - (tmp1 * njac[i][j][k + 1][3][2]);\n      lhs[i][j][k][CC][3][3] = ((tmp2 * fjac[i][j][k + 1][3][3]) - (tmp1 * njac[i][j][k + 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][CC][3][4] = (tmp2 * fjac[i][j][k + 1][3][4]) - (tmp1 * njac[i][j][k + 1][3][4]);\n      lhs[i][j][k][CC][4][0] = (tmp2 * fjac[i][j][k + 1][4][0]) - (tmp1 * njac[i][j][k + 1][4][0]);\n      lhs[i][j][k][CC][4][1] = (tmp2 * fjac[i][j][k + 1][4][1]) - (tmp1 * njac[i][j][k + 1][4][1]);\n      lhs[i][j][k][CC][4][2] = (tmp2 * fjac[i][j][k + 1][4][2]) - (tmp1 * njac[i][j][k + 1][4][2]);\n      lhs[i][j][k][CC][4][3] = (tmp2 * fjac[i][j][k + 1][4][3]) - (tmp1 * njac[i][j][k + 1][4][3]);\n      lhs[i][j][k][CC][4][4] = ((tmp2 * fjac[i][j][k + 1][4][4]) - (tmp1 * njac[i][j][k + 1][4][4])) - (tmp1 * dz5);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp1, tmp2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/25"}
{"code": "for (i = 0; i < V; i++)\n{\n  if ((visited[i] == 0) && (key[i] < min_local))\n  {\n    min_local = key[i];\n    index_local = i;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parthvshah/parallel-prims/src/bench/0"}
{"code": "for (int col = 0; col < width; col++)\n{\n  for (int row = 0; row < height; row++)\n  {\n    int pixel_index = col + (row * width);\n    if (suppressed_image[pixel_index] > high_threshold)\n      output_image[pixel_index] = 255;\n    else\n      if (suppressed_image[pixel_index] > low_threshold)\n      output_image[pixel_index] = 100;\n    else\n      output_image[pixel_index] = 0;\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashsm79/parallel-canny-edge-detector/src/canny/3"}
{"code": "for (int i = 0; i < localDataset.size(); i++)\n  for (int j = 0; j < total_values; j++)\n  localSum[memberships[i]].values[j] += localDataset[i].values[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/14"}
{"code": "for (int n = 0; n < N; n++)\n{\n  xbest[n] = x[i][n];\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/R1ES_omp_alt/7"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  a[i] = (i + 1) * 2.0;\n  b[i] = (i + 1) * 3.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafalcode/openmping/bowd0/1"}
{"code": "for (i = 0; i < agentSize; i++)\n{\n  a1Move(agents[i]);\n}\n\n", "pragma": "#pragma omp parallel for shared(agents) num_threads(threadNum) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hd-zhao-uu/PedestrianSimulation/libpedsim/ped_model/3"}
{"code": "for (int i = 0; i < rank; i++)\n  printf(\"%.2f \", b_hat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/8"}
{"code": "for (i = 0; i < xx; i += 2)\n  temp[i >> 1] = input[i] + input[i + 1];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/Old/2"}
{"code": "for (i = 0; i < m; i++)\n  a[i] = b[i * n] * c[0];\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/Laborator/lab02/ex_lab/3 - mxv/mxv_col_omp/0"}
{"code": "for (int k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    xvel0[FTNREF2D((x_max + 1) + j, k, x_max + 5, x_min - 2, y_min - 2)] = -xvel0[FTNREF2D((x_max + 1) - j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/31"}
{"code": "for (i = 0; i < nj; i++)\n  for (j = 0; j < nl; j++)\n  C[i][j] = ((double) (((i * (j + 3)) + 1) % nl)) / nl;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Werozel/OpenMP/2mm/5"}
{"code": "for (int i = 0; i < 10000000; i++)\n  res = res * pow(x, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vladislav-koval/openmp-lab/1-3/0"}
{"code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n  strcat(fsname[n], \"_\");\n  strcat(fsname[n], DEIDname);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/62"}
{"code": "for (i = 0; i < n; i++)\n{\n  TID = omp_get_thread_num();\n  if ((pglobal = (int *) malloc(length[i] * (sizeof(int)))) != 0)\n  {\n    for (j = 0; j < length[i]; j++)\n      pglobal[j] = j + 1;\n\n    sum = calculate_sum(length[i]);\n    printf(\"TID %d : value of sum for i = %d is %d\\n\", TID, i, sum);\n    free(pglobal);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(n,length) private(TID, i, j, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/021_threadprivate_example/0"}
{"code": "for (int i = id; i < num_steps; i += nthrds)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/onofrefelix/openMP/pi_paralle_V1/PI_parallelV2/Pi_parallelV2/Pi_parallelV2/2"}
{"code": "for (int i = 0; i < row; ++i)\n  for (int j = 0; j < col; ++j)\n  t[(row * j) + i] = d[(col * i) + j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/4"}
{"code": "for (i = 1; (i < n) && sort; i++)\n  if (data[i] < data[i - 1])\n  sort = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Count-Sort/count/3"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    matvec_sub(lhs[isize][j][k][0], rhs[isize - 1][j][k], rhs[isize][j][k]);\n    matmul_sub(lhs[isize][j][k][0], lhs[isize - 1][j][k][2], lhs[isize][j][k][1]);\n    binvrhs(lhs[i][j][k][1], rhs[i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/9"}
{"code": "for (int j = i; j < (SIZE - 1); j += 2)\n{\n  if (array[j] > array[j + 1])\n  {\n    swap(array[j], array[j + 1]);\n    sorted = false;\n  }\n\n  i = (i == 0) ? (1) : (0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohorka/HPCS/openMP/Sort(ex.5)/1"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  for (int j = 1; j < (m - 1); j++)\n  {\n    const int pos = (i * m) + j;\n    const float temp = (*mat)[pos];\n    (*mat)[pos] = 0.2f * (((((*mat)[pos] + (*mat)[pos - 1]) + (*mat)[pos - n]) + (*mat)[pos + 1]) + (*mat)[pos + n]);\n    diff += abs((*mat)[pos] - temp);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(num_ths) schedule(static, max_cells_per_th) collapse(2) reduction(+:diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EALH/Prog_Paralela/OpenMp/gauss/1"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  for (int j = 0; j < ((n - i) - 1); j++)\n  {\n    if (arr[j] > arr[j + 1])\n    {\n      swap(arr[j], arr[j + 1]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/odd_even/1"}
{"code": "for (int i = 0; i < (cyl_geom->n_grid_r - 1); i++)\n  for (int k = 0; k < cyl_geom->n_grid_z; k++)\n  e1[i][k] = (fi[i][k] - fi[i + 1][k]) / cyl_geom->dr;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/poissonDirichlet/4"}
{"code": "for (int i = 0; i < buckets; i++)\n{\n  result_table.insert(result_table.end(), all_buckets[0][i].begin(), (all_buckets[0][i].begin() + indexes[i]) - 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort1/2"}
{"code": "for (ix = 0; ix < ix_max; ix++)\n{\n  x = x_min + (ix * pix_w);\n  Zx = 0.0;\n  Zy = 0.0;\n  Zx2 = Zx * Zx;\n  Zy2 = Zy * Zy;\n  for (t = 1; (t < t_max) && ((Zx2 + Zy2) < (esc_rad * esc_rad)); t++)\n  {\n    Zy = ((2 * Zx) * Zy) + y;\n    Zx = (Zx2 - Zy2) + x;\n    Zx2 = Zx * Zx;\n    Zy2 = Zy * Zy;\n  }\n\n  if (t == t_max)\n  {\n    color[0] = 0;\n    color[1] = 0;\n    color[2] = 0;\n  }\n  else\n  {\n    color[0] = 255;\n    color[1] = 255;\n    color[2] = 255;\n  }\n\n  ;\n  fseek(fp, (((iy * 800) + ix) * 3) + 22, 0);\n  fwrite(color, 1, 3, fp);\n}\n\n", "pragma": "omp parallel for private(x,Zx,Zy,Zx2,Zy2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ram-Aditya/Parallel-Computing/MandelBrot`s Set/Mandelbrot_Parallel/1"}
{"code": "for (i = 0; i <= n; i++)\n{\n  multout *= f[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(n) reduction(*:multout)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/019_reduction_example/1"}
{"code": "for (int i = 0; i < numBuckets; i++)\n{\n  buckets[i] = bubbleSort(buckets[i]);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jalexisrdv/aceleracion-bubble-sort-openmp/main/3"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    fuzzyPadded[i + d][j + d] = fuzzy[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/z4/dosharpen/4"}
{"code": "for (int i = 0; i < arr.size(); ++i)\n  arr[i] = sin(i) * sin(i);\n\n", "pragma": "#pragma omp parallel for num_threads(num)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HPC-lab-ITIS/OpenMP-and-MPI/materials/lec_2/code/test_4/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  cu[1 + (4 * kj)] = zero;\n  cu[4 * k1] = zero;\n  cu[1 + (4 * k1)] = zero;\n  cu[2 + (4 * k1)] = zero;\n  cu[4 * (kj + l1)] = zero;\n  cu[1 + (4 * (kj + l1))] = zero;\n  cu[2 + (4 * (kj + l1))] = zero;\n  cu[4 * (k1 + l1)] = zero;\n  cu[1 + (4 * (k1 + l1))] = zero;\n  cu[2 + (4 * (k1 + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/45"}
{"code": "for (int i = 0; i < N; i++)\n{\n  c[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruparelmetarya/OpenMP-vs-TBB-A-survey-on-Parallel-Programming-Models/Source-codes/overhead-openmp/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  dtemp[m] = ((ce[0][m] + (xi * (ce[1][m] + (xi * (ce[4][m] + (xi * (ce[7][m] + (xi * ce[10][m])))))))) + (eta * (ce[2][m] + (eta * (ce[5][m] + (eta * (ce[8][m] + (eta * ce[11][m])))))))) + (zeta * (ce[3][m] + (zeta * (ce[6][m] + (zeta * (ce[9][m] + (zeta * ce[12][m])))))));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (xi,eta,zeta)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/35"}
{"code": "for (i = n_element - 1; i >= 0; i--)\n{\n  sorted[count[(unsorted[i] / exp) % counter_size] - 1] = unsorted[i];\n  count[(unsorted[i] / exp) % counter_size]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jessinra/IF3230-Radix-Sort-OpenMP/src/radix_sort/3"}
{"code": "for (j = 0; j <= (672 + 1); j++)\n{\n  Temperature_last[0][j] = 0.0;\n  Temperature_last[672 + 1][j] = (100.0 / 672) * j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  count = 0;\n  for (j = 0; j < n; j++)\n  {\n    if (data[j] < data[i])\n      count++;\n    else\n      if ((data[j] == data[i]) && (j < i))\n      count++;\n\n\n  }\n\n  temp[count] = data[i];\n}\n\n", "pragma": "omp parallel for private(i,j,count) shared(data,temp,n,thread_count)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Count-Sort/count/0"}
{"code": "for (int k = 0; k < n; k += 2 * level)\n{\n  int initial = k;\n  int center = k + (level - 1);\n  int rear = k + ((2 * level) - 1);\n  if (center >= n)\n  {\n    center = ((k + n) - 1) / 2;\n    rear = n - 1;\n  }\n  else\n    if (rear >= n)\n  {\n    rear = n - 1;\n  }\n\n\n  merge(arr, initial, center, rear);\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/mergesort/mergesort/2"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    if (obstacles[ii + (jj * params.nx)])\n    {\n      u_x = (u_y = (u = 0.f));\n      pressure = params.density * c_sq;\n    }\n    else\n    {\n      local_density = 0.f;\n      for (int kk = 0; kk < 9; kk++)\n      {\n        local_density += cells->speeds[kk][ii + (jj * params.nx)];\n      }\n\n      u_x = (((cells->speeds[1][ii + (jj * params.nx)] + cells->speeds[5][ii + (jj * params.nx)]) + cells->speeds[8][ii + (jj * params.nx)]) - ((cells->speeds[3][ii + (jj * params.nx)] + cells->speeds[6][ii + (jj * params.nx)]) + cells->speeds[7][ii + (jj * params.nx)])) / local_density;\n      u_y = (((cells->speeds[2][ii + (jj * params.nx)] + cells->speeds[5][ii + (jj * params.nx)]) + cells->speeds[6][ii + (jj * params.nx)]) - ((cells->speeds[4][ii + (jj * params.nx)] + cells->speeds[7][ii + (jj * params.nx)]) + cells->speeds[8][ii + (jj * params.nx)])) / local_density;\n      u = sqrtf((u_x * u_x) + (u_y * u_y));\n      pressure = local_density * c_sq;\n    }\n\n    fprintf(fp, \"%d %d %.12E %.12E %.12E %.12E %d\\n\", ii, jj, u_x, u_y, u, pressure, obstacles[(ii * params.nx) + jj]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abcdrm/LBM-OpenMP/d2q9-bgk/6"}
{"code": "for (int i = 0; i < 100; i++)\n  if (a[i] != (((-1) + i) + (2 * i)))\n{\n  printf(\"Error at %d: device = %d, host = %d\\n\", i, a[i], ((-1) + i) + (2 * i));\n  fail = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/4"}
{"code": "for (size_t dim = 0; dim < _dimensionality; dim++)\n  _internalVector[dim] = vec[dim];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariodematties/MPI_Tests/Sum/1"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    A[i][j] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/2"}
{"code": "for (int i = 0; i < 10; ++i)\n  a += 18 + x;\n\n", "pragma": "    #pragma omp target parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen_registration/8"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  if ((N[i] % local_work_size[i]) != 0)\n  {\n    group_number[i] = (N[i] / local_work_size[i]) + 1;\n  }\n  else\n    group_number[i] = N[i] / local_work_size[i];\n\n  global_work_size[i] = group_number[i] * local_work_size[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/0"}
{"code": "for (int i = 0; i < length; i++)\n{\n  char count;\n  unsigned long x = data[i];\n  for (count = 0; x; count++)\n    x &= x - 1;\n\n  result[i] = count;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/5"}
{"code": "for (int j = 0; j < dimension; j++)\n  sum += pow(points[(j * n) + p] - centroids[(j * k) + c], 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucabindini/KMeansClustering_OpenMP/KMeans/1"}
{"code": "for (uint32_t v = 0; v != vertex_num; ++v)\n{\n  if (m_vCompId[v] == max())\n  {\n    depth_first_search(v, comp_id, order_id);\n    comp_id += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/23"}
{"code": "for (i = 0; i < testIter; ++i)\n  hypre_SeqVectorAxpy(alpha, x, y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/main/4"}
{"code": "for (int i = 0; i < SDMGeom->HALO_Node(); ++i)\n{\n  sxx[i] = f;\n  syy[i] = f;\n  szz[i] = f;\n  sxy[i] = f;\n  sxz[i] = f;\n  syz[i] = f;\n  vx[i] = f;\n  vy[i] = f;\n  vz[i] = f;\n  ux[i] = f;\n  uy[i] = f;\n  uz[i] = f;\n  dsxx_dx[i] = f;\n  dsxy_dy[i] = f;\n  dsxz_dz[i] = f;\n  dsxy_dx[i] = f;\n  dsyy_dy[i] = f;\n  dsyz_dz[i] = f;\n  dsxz_dx[i] = f;\n  dsyz_dy[i] = f;\n  dszz_dz[i] = f;\n  dvx_dx[i] = f;\n  dvy_dy[i] = f;\n  dvz_dz[i] = f;\n  dvx_dy[i] = f;\n  dvy_dx[i] = f;\n  dvx_dz[i] = f;\n  dvz_dx[i] = f;\n  dvy_dz[i] = f;\n  dvz_dy[i] = f;\n  df_dI[i] = f;\n  df_dJ[i] = f;\n  df_dK[i] = f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/3"}
{"code": "for (i = offset_start; i < offset_end; i++)\n{\n  key = edgeList->edges_array_dest[i];\n  pos = vertex_count[(t_id * num_vertices) + key];\n  sorted_edges_array->edges_array_dest[pos] = edgeList->edges_array_dest[i];\n  sorted_edges_array->edges_array_src[pos] = edgeList->edges_array_src[i];\n  vertex_count[(t_id * num_vertices) + key]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/countsort/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  array3[i] = sin(array1[i] + array2[i]);\n  printf(\"Thread id: %d working on index %d\\n\", threadid, i);\n  sleep(1);\n}\n\n", "pragma": "omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tr0j4n034/HPC-2019/Examples/MPI/checkpoint_openmp/0"}
{"code": "for (i = 0; i < ch_im_out; i++)\n{\n  for (j = 0; j < dim_im_out; j++)\n  {\n    for (k = 0; k < dim_im_out; k++)\n    {\n      conv_out = (bias[i] << bias_shift) + NN_ROUND(out_shift);\n      for (m = 0; m < dim_kernel; m++)\n      {\n        for (n = 0; n < dim_kernel; n++)\n        {\n          in_row = ((stride * j) + m) - padding;\n          in_col = ((stride * k) + n) - padding;\n          if ((((in_row >= 0) && (in_col >= 0)) && (in_row < dim_im_in)) && (in_col < dim_im_in))\n          {\n            for (l = 0; l < ch_im_in; l++)\n            {\n              conv_out += Im_in[(((in_row * dim_im_in) + in_col) * ch_im_in) + l] * wt[((((i * ch_im_in) * dim_kernel) * dim_kernel) + (((m * dim_kernel) + n) * ch_im_in)) + l];\n            }\n\n          }\n\n        }\n\n      }\n\n      Im_out[i + (((j * dim_im_out) + k) * ch_im_out)] = (q7_t) __SSAT(conv_out >> out_shift, 8);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/cifar_original/CMSIS_5/CMSIS/NN/Source/ConvolutionFunctions/arm_convolve_HWC_q7_RGB/0"}
{"code": "for (i = 0; i < 48; i++)\n  cs.ct[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/o5logon_fmt_plug/0"}
{"code": "for (int x = start_x; x < end_x; x++)\n{\n  for (int y = start_y; y < end_y; y++)\n  {\n    if (((x != i) || (y != j)) && (cur_img(x, y) != 0))\n    {\n      alive += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pravez/VitaeLabilis/src/compute/3"}
{"code": "for (int i = 0; i < number_of_blocks; i++)\n{\n  BlockSort(input, length_of_blocks[i], start_position);\n  start_position += length_of_blocks[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/antonKorobenko/parallel-binsort/binsort_openMp/4"}
{"code": "for (i = 0; i < (nca / 2); i++)\n{\n  for (j = 0; j < (nca / 2); j++)\n    for (k = 0; k < (nca / 2); k++)\n    m[inm + (((i * nca) / 2) + j)] += resA[in1 + ((i * (nca / 2)) + k)] * resB[in2 + ((k * (nca / 2)) + j)];\n\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/7"}
{"code": "for (i = 1; i < (Nx - 1); i++)\n{\n  u[i][j + 1] = (u[i][j] - ((c / 2.) * (u[i + 1][j] - u[i - 1][j]))) + ((pow(c, 2.) / 2.) * ((u[i + 1][j] - (2. * u[i][j])) + u[i - 1][j]));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svretina/OpenMP-projects/wave/2"}
{"code": "for (int u = 0; u < n; u++)\n{\n  if (parent[u] == (-1))\n  {\n    for (int v = 0; v < n; v++)\n    {\n      if ((graph[u][v] == 1) && (isVInQueue(frontier, v) == 1))\n      {\n        if (next == 0)\n        {\n          next = createQueue();\n        }\n\n        enqueue(next, u);\n        parent[u] = v;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/4"}
{"code": "for (i = 0; i < (256 / 32); i++)\n  for (j = 0; j < 8; j++)\n  for (k = 0; k < 8; k++)\n  if (c[i][j][k] != (3 * (((i >= 2) && (j >= 2)) && ((k & 1) == 0))))\n  abort();\n\n\n\n\n", "pragma": "omp for collapse(3) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/5"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%f\\t\", a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/addi/1"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + .5) * step;\n  suml += 4.0 / (1. + (x * x));\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritaly/OWS/pi_na2_podzialy/0"}
{"code": "for (int i = 0; i < src_size; i++)\n  h_src[i] = rand() % 256;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/surfel-omp/main/0"}
{"code": "for (int i = 0; i < size; i++)\n  ds[i]->tryToMove(stepSize, trials);\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/zad6/DSEnsemble/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int i = 0; i < 64; i++)\n  {\n    var[i]++;\n  }\n\n}\n\n", "pragma": "omp teams distribute parallel for reduction(+:var)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB163-simdmissinglock1-orig-gpu-no/0"}
{"code": "for (i = 1; i <= leftRow; i++)\n{\n  for (k = 1; k <= rightCol; k++)\n  {\n    for (j = 1; j <= col; j++)\n    {\n      sumPerLine += leftMatrix->getMatrixElement(i, j) * rightMatrix->getMatrixElement(j, k);\n    }\n\n    tmpMatrix->setMatrixElement(i, k, sumPerLine);\n    sumPerLine = 0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, k) firstprivate(sumPerLine)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nablax/OpenMP-CUDA-Matrix-Multiplication/QtMatrixOpenMP/MatrixCalculation/3"}
{"code": "for (long j = 0; j < numtasks; ++j)\n{\n  compute(omp_get_thread_num(), nticks);\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime) num_threads(nworkers)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/perf_parfor/1"}
{"code": "for (i = 0; i < n_line; i++)\n{\n  points_array[i].cluster_id = assign_cluster(points_array[i], actual_centroids_array, n_clusters);\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  double _imopVarPre154;\n  double _imopVarPre155;\n  _imopVarPre154 = sum[m] / (((nx0 - 2) * (ny0 - 2)) * (nz0 - 2));\n  _imopVarPre155 = sqrt(_imopVarPre154);\n  sum[m] = _imopVarPre155;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/26"}
{"code": "for (i = 0; i < E; ++i)\n{\n  int qqq = scanf(\"%d %d %d\", &x, &y, &w);\n  if ((*((matrix + ((x - 1) * V)) + (y - 1))) > w)\n    *((matrix + ((x - 1) * V)) + (y - 1)) = w;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayushsharma-crypto/Floyd-Warshal-Optimization/code/2"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  show(u, w, h);\n  evolve(u, w, h);\n  usleep(200000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uros99/OpenMP-MPI-CUDA/OpenMP/gameoflife/14"}
{"code": "for (j = 0; j < n; j++)\n{\n  a[j] = ((float) rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/maximum/1"}
{"code": "for (int i = 0; i < 3731; ++i)\n{\n  for (int j = 0; j < 5716; ++j)\n  {\n    fputc(ans[i][j], fpout);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main1/4"}
{"code": "for (int i = 0; i < world_size; i++)\n  chunk_sizes[i] = (rows / world_size) * columns;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SilverSoldier/game-of-life/gol/7"}
{"code": "for (i = 0; i < (k - 1); i++)\n{\n  w[i] = w[i] + ((alpha * ((double) sign)) * point.values[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/PerceptronAlgorithm/2"}
{"code": "for (body1 = 0; body1 < 1000; body1++)\n{\n  if (body1 != body0)\n  {\n    distance = sqrt((pow(position[body1].x - position[body0].x, 2) + pow(position[body1].y - position[body0].y, 2)) + pow(position[body1].z - position[body0].z, 2));\n    cos_theta_x = (position[body1].x - position[body0].x) / distance;\n    cos_theta_y = (position[body1].y - position[body0].y) / distance;\n    cos_theta_z = (position[body1].z - position[body0].z) / distance;\n    force = ((G * 1) * 1) / pow(distance, 2);\n    new_x_ac += force * cos_theta_x;\n    new_y_ac += force * cos_theta_y;\n    new_z_ac += force * cos_theta_z;\n  }\n\n}\n\n", "pragma": "omp parallel for private(body1,cos_theta_x,cos_theta_y,cos_theta_z,distance,force) reduction(+:new_x_ac,new_y_ac,new_z_ac)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/roy-1996/Many-Body-Problem/many_body_problem/1"}
{"code": "for (uint i = 0; i < mols.kindsCount; ++i)\n{\n  for (uint j = 0; j < mols.kindsCount; ++j)\n  {\n    tailCorrection += ((mols.pairEnCorrections[(i * mols.kindsCount) + j] * kCount[i]) * kCount[j]) * currentAxes.volInv[box];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/22"}
{"code": "for (j = 0; j < nrows; j++)\n{\n  for (i = 0; i < nrows; i++)\n    temp[i] = v[j][index[i]];\n\n  for (i = 0; i < nrows; i++)\n    v[j][i] = temp[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/30"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int b = (rand() % 10) + 1;\n  v2.push_back(b);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_2/2/1"}
{"code": "for (i = nbeg + 1; i < nfin; i++)\n{\n  if (fmod(i, 2) == 0)\n    toggl = 1;\n  else\n    toggl = 2;\n\n  for (j = mbeg + toggl; j < mfin; j += 2)\n  {\n    u[i][j] = tmp2 * (((((tmp1 * rhs[i][j]) + u[i - 1][j]) + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared( u, rhs ) private( i, j, toggl ) num_threads(numprocs)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jovubeliveus/PRelax/src_datapar/work/0"}
{"code": "for (size_t i = 0; i < act_val.size(); i++)\n  cost_ += (_output[i] * log(act_val[i])) + ((1 - _output[i]) * log(1 - act_val[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatheusNBDG/Neural-Network/neuron/2"}
{"code": "for (int j = 0; j < NUMIN; j++)\n  for (int i = 0; i < NUMHID; i++)\n{\n  WeightIH[i][j] = (2.0 * (rando() + 0.5)) * smallwt;\n  DeltaWeightIH[i][j] = 0.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/12"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  for (int j = 0; j <= i; j++)\n  {\n    Distances[i][j] = nodeDistance(Cities[i], Cities[j]);\n    T[i][j] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/TSP/ants_parallel/4"}
{"code": "for (x = 0; x < diameter; x++)\n{\n  for (y = 0; y < diameter; y++)\n  {\n    float distance = sqrt(pow((float) ((x - radius) + 1), 2) + pow((float) ((y - radius) + 1), 2));\n    if (distance < radius)\n      disk[(x * diameter) + y] = 1;\n    else\n      disk[(x * diameter) + y] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/2"}
{"code": "for (i = 0; i < 100000; i++)\n  fscanf(fptr, \"%d\", &ex[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/4"}
{"code": "for (j = 0; j < 16384; j++)\n{\n  s[j] = s[j] + (r[i] * A[(i * 16384) + j]);\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/BICG/bicg/0"}
{"code": "for (i = 0; i < OUTPUTS; i++)\n{\n  for (j = 0; j < SAMPLES; j++)\n  {\n    (((cout << setprecision(2)) << fixed) << ATV2[i][j]) << \"\\t\";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Functional/parallel/parallel_feed/0"}
{"code": "for (int i = 1; i <= Q; i++)\n  arr[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tratitude/eight-queen-problem/eight_queen/2"}
{"code": "for (i = 0; i < threads; i++)\n{\n  tarr[i] = (i * size) / threads;\n  tarr[threads] = size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/7"}
{"code": "for (long i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  double subsum = 4.0 / (1.0 + (x * x));\n  sum += subsum;\n}\n\n", "pragma": "\t#pragma omp target teams distribute parallel for simd reduction (+:sum) map(tofrom:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex4_1B_pi_parallel-for-reduction__GPU/0"}
{"code": "for (int f = 0; f < feat4; f++)\n{\n  for (int i = 0; i < feat3; i++)\n  {\n    for (int j = 0; j < 3; j++)\n    {\n      for (int k = 0; k < 3; k++)\n      {\n        kernel41[f][i][j][k] = distr(gen);\n        kernel42[f][i][j][k] = distr(gen);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/7"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  switch (i)\n  {\n    case 0:\n      printf(\"|%10s|\", \"\u041f\u0443\u0437\u044b\u0440\u0451\u043a\");\n      break;\n\n    case 1:\n      printf(\"|%10s|\", \"\u0412\u044b\u0431\u043e\u0440\u043e\u043c\");\n      break;\n\n    case 2:\n      printf(\"|%10s|\", \"\u0412\u0441\u0442\u0430\u0432\u043a\u0430\u043c\u0438\");\n      break;\n\n    default:\n      break;\n\n  }\n\n  for (int j = i; j < 9; j += 3)\n    printf(\"%10.3f|\", TimeAllPos[j]);\n\n  for (int j = i; j < 27; j += 3)\n    printf(\"%10.3f|\", TimeAllPar[j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rezondor/Lab1_OpenMP/Lab1/Lab1/6"}
{"code": "for (size_t i = 0; i < loop; ++i)\n{\n  loadData(ptr, rData, rArrayLen);\n  simdOddEvenSort(rData);\n  (bitonicSort428 < 4) > ((rData, true));\n  storeData(ptr, rData, rArrayLen);\n  ptr += blockUnitLen;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/24"}
{"code": "for (x = 0; x < width; ++x)\n{\n  ray = camera->ComputeRay(x, y);\n  finalColor = traceRay(ray, 0).ToRange();\n  pImageBuffer->SetPixel(x, y, finalColor);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for private(x, ray, finalColor) schedule(dynamic, chunkSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnoazx005/RTRender/RTRender/source/impls/RTOMPRayTracer/0"}
{"code": "for (int i = 0; i < MATRIX_SIZE; i++)\n{\n  for (int j = 0; j < MATRIX_SIZE; j++)\n  {\n    for (int k = 0; k < MATRIX_SIZE; k++)\n    {\n      A->data[i][j][k] = rand() % 10;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW3/matmul3d/1"}
{"code": "for (size = 0; size < matSize; size += stride)\n{\n  sequentialVersion(oldA, newA, size);\n  start = rdtsc();\n  for (j = 0; j < repets; j++)\n  {\n    sequentialVersion(oldA, newA, size);\n  }\n\n  res = rdtsc() - start;\n  fprintf(fd, \"%u %lu\\n\", size, res / repets);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/Stencil/Lines/CDParallelism/utils/1"}
{"code": "for (long i = 0; i < (NUMNODES * NUMNODES); i++)\n{\n  long iu = i % NUMNODES;\n  long iv = i / NUMNODES;\n  double partialVolume = 0;\n  if (((iu == 0) || (iu == (NUMNODES - 1))) && ((iv == 0) || (iv == (NUMNODES - 1))))\n    partialVolume = (fullTileArea * Height(iu, iv)) / 4;\n  else\n    if ((((iu == 0) || (iu == (NUMNODES - 1))) || (iv == 0)) || (iv == (NUMNODES - 1)))\n    partialVolume = (fullTileArea * Height(iu, iv)) / 2;\n  else\n    partialVolume = fullTileArea * Height(iu, iv);\n\n\n  volume = volume + partialVolume;\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+:volume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tanyakhemani/parallel-programming/project1/project1/0"}
{"code": "for (unsigned long long tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (unsigned long long i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      unsigned long long id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_gpu/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  x[i] = 0.0;\n  b[i] = (double) (n + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/1"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    a[i][j] = a[i][j] + 1;\n    if (a[i][j] == 100)\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_break2/0"}
{"code": "for (int i = 0; i < (nb.elems * 3); ++i)\n  --topo.elems[i];\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/io/0"}
{"code": "for (size_t j = 0; j < gridDimY; ++j)\n{\n  for (size_t k = 0; k < gridDimX; ++k)\n  {\n    if (gridXY(k, j) > 0)\n      continue;\n\n    ++numEmpty;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/9"}
{"code": "for (i = 2 * curr; i < N; i += curr)\n{\n  arr[i] = 0;\n}\n\n", "pragma": "omp parallel for num_threads(t) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nesmabelkhodja/Parallel-Computing/Lab 2/genprimes/1"}
{"code": "for (i = 2; i <= (6 * ((((256 * 256) / 4) + ((256 * 256) / 4)) + ((128 * 128) / 4))); i++)\n{\n  ex[i] = ex[i - 1] * ex[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/28"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < colums; j++)\n  {\n    printf(\"%lf\\t\", M[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markopand/Code/LU algorithm OpenMP/7"}
{"code": "for (int j = 0; j < 4; ++j)\n{\n  int64_t k = j * s4;\n  for (int64_t i = k + 1; i < (k + s4); ++i)\n  {\n    x2[i] = (a[i] * x2[i - 1]) + b[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/romansamgin/OpenMP-test/main/3"}
{"code": "for (int i = 0; i < 1; ++i)\n{\n  ((cout << \"lastprivate: chances are this number is 13: \") << var) << endl;\n}\n\n", "pragma": "    #pragma omp parallel for lastprivate(var) num_threads(1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daleksla/learning/tools/openmp/arguments/0"}
{"code": "for (long long int toss = 0; toss < number_of_tosses; toss++)\n{\n  double x = getRand(&seed);\n  double y = getRand(&seed);\n  double length = (x * x) + (y * y);\n  if (length <= 1)\n    no_in_circle++;\n\n}\n\n", "pragma": "omp for reduction(+: no_in_circle)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vrajpatell/Monte-Carlo-Implementation-Using-OpenMP-in-Parallel-Programming/monte_carlo_lab1/0"}
{"code": "for (r = 0; r < nranks; ++r)\n{\n  size_t size = (whole_size / weighted_nranks) * weights[r];\n  MPI_Status status;\n  if (r == 0)\n  {\n    size += radius * nx_ny_pad;\n    memcpy(data_ptr, my_data, size * (sizeof(float)));\n  }\n  else\n    if (r < (nranks - 1))\n  {\n    MPI_Recv(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1, &status);\n  }\n  else\n  {\n    size += radius * nx_ny_pad;\n    MPI_Recv(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1, &status);\n  }\n\n\n  data_ptr += size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erwold/3d-Finite-difference/iso-3dfd_main/2"}
{"code": "for (i = 0; i < m; i++)\n  omp_init_lock(&L2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HardiChandra/Parallel-Programming-Projects/Project4 Bucket Sort/Project4-BucketSort/Project4-BucketSortCombine/Project4-BucketSortCombine/2"}
{"code": "for (int i = 0; i < numbers.size(); i++)\n  sum += numbers.at(i);\n\n", "pragma": "#pragma omp parallel for reduction( +: sum ) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dleliuhin/OpenMP-Labs/lab_7_2/main/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  histogram[i] = local_histogram[i] + rec_buff[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kerenrachev/CUDA_MPI_OpenMP_Histogram/histogram/8"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  czekaj(1);\n  for (int j = 0; j < SIZE; j++)\n  {\n    A[i][j] = ((long double) i) / ((i + j) + 20.0);\n    B[i][j] = ((long double) j) / ((i + j) + 30.0);\n    C[i][j] = ((long double) ((i + j) + 5)) / ((i + j) + 40.0);\n    D[i][j] = ((long double) (i + j)) / ((i + j) + 50.0);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WikGru/ParallelOpenMP/zad1+/zad1+/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  ytemp = y[i];\n  ztemp = z[i];\n  y[i] = (ytemp * cos(angle)) + (ztemp * sin(angle));\n  z[i] = ((-ytemp) * sin(angle)) + (ztemp * cos(angle));\n}\n\n", "pragma": "omp parallel for firstprivate(n,ytemp,ztemp,angle)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/0"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  result += 1 / array[i];\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/takashift/experimentB_OpenMP/function/0"}
{"code": "for (int i = chunk_size; i < n; i++)\n{\n  if (((i % chunk_size) == 0) && (curr_owner < (num_procs - 1)))\n    curr_owner++;\n\n  owner[i] = curr_owner;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/8"}
{"code": "for (ix = 0; ix < size; ix++)\n{\n  for (iy = 0; iy < size; iy++)\n  {\n    u[ix][iy] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taggelos/GameOfLife/Paradoteo/mpi_openmp/functions/4"}
{"code": "for (int row = 0; row < image_height; row++)\n{\n  for (int col = 0; col < image_width; col++)\n  {\n    int sad_result = 0;\n    const int overlap_width = min(image_width - col, kernel_width);\n    const int overlap_height = min(image_height - row, kernel_height);\n    #pragma unroll 4\n    for (int kr = 0; kr < overlap_height; kr++)\n    {\n      #pragma unroll 4\n      for (int kc = 0; kc < overlap_width; kc++)\n      {\n        const int image_addr = (((row + kr) * image_width) + (col + kc)) * 3;\n        const int kernel_addr = ((kr * kernel_width) + kc) * 3;\n        const int m_r = (int) image[image_addr + 0];\n        const int m_g = (int) image[image_addr + 1];\n        const int m_b = (int) image[image_addr + 2];\n        const int t_r = (int) kernel[kernel_addr + 0];\n        const int t_g = (int) kernel[kernel_addr + 1];\n        const int t_b = (int) kernel[kernel_addr + 2];\n        const int error = (abs(m_r - t_r) + abs(m_g - t_g)) + abs(m_b - t_b);\n        sad_result += error;\n      }\n\n    }\n\n    int norm_sad = (int) (sad_result / ((float) kernel_size));\n    int my_index_in_sad_array = (row * image_width) + col;\n    if (my_index_in_sad_array < sad_array_size)\n    {\n      sad_array[my_index_in_sad_array] = norm_sad;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sad-omp/main/0"}
{"code": "for (i = 0; i < NUM_BOXES; i++)\n{\n  if (box_arr[i].num_top != 0)\n  {\n    int j;\n    for (j = 0; j < box_arr[i].num_top; j++)\n    {\n      int cur_topid = box_arr[i].top_ids[j];\n      int len2;\n      int len1;\n      if (box_arr[i].up_left_x >= box_arr[cur_topid].up_left_x)\n        len1 = box_arr[i].up_left_x;\n      else\n        len1 = box_arr[cur_topid].up_left_x;\n\n      if ((box_arr[i].up_left_x + box_arr[i].width) <= (box_arr[cur_topid].up_left_x + box_arr[cur_topid].width))\n        len2 = box_arr[i].up_left_x + box_arr[i].width;\n      else\n        len2 = box_arr[cur_topid].up_left_x + box_arr[cur_topid].width;\n\n      box_arr[i].top_ov[j] = abs(len2 - len1);\n    }\n\n  }\n\n  if (box_arr[i].num_bottom != 0)\n  {\n    int j;\n    for (j = 0; j < box_arr[i].num_bottom; j++)\n    {\n      int cur_bottomid = box_arr[i].bottom_ids[j];\n      int len2;\n      int len1;\n      if (box_arr[i].up_left_x >= box_arr[cur_bottomid].up_left_x)\n        len1 = box_arr[i].up_left_x;\n      else\n        len1 = box_arr[cur_bottomid].up_left_x;\n\n      if ((box_arr[i].up_left_x + box_arr[i].width) <= (box_arr[cur_bottomid].up_left_x + box_arr[cur_bottomid].width))\n        len2 = box_arr[i].up_left_x + box_arr[i].width;\n      else\n        len2 = box_arr[cur_bottomid].up_left_x + box_arr[cur_bottomid].width;\n\n      box_arr[i].bottom_ov[j] = abs(len2 - len1);\n    }\n\n  }\n\n  if (box_arr[i].num_left != 0)\n  {\n    int j;\n    for (j = 0; j < box_arr[i].num_left; j++)\n    {\n      int cur_leftid = box_arr[i].left_ids[j];\n      int len2;\n      int len1;\n      if (box_arr[i].up_left_y >= box_arr[cur_leftid].up_left_y)\n        len1 = box_arr[i].up_left_y;\n      else\n        len1 = box_arr[cur_leftid].up_left_y;\n\n      if ((box_arr[i].up_left_y + box_arr[i].height) <= (box_arr[cur_leftid].up_left_y + box_arr[cur_leftid].height))\n        len2 = box_arr[i].up_left_y + box_arr[i].height;\n      else\n        len2 = box_arr[cur_leftid].up_left_y + box_arr[cur_leftid].height;\n\n      box_arr[i].left_ov[j] = abs(len2 - len1);\n    }\n\n  }\n\n  if (box_arr[i].num_right != 0)\n  {\n    int j;\n    for (j = 0; j < box_arr[i].num_right; j++)\n    {\n      int cur_rightid = box_arr[i].right_ids[j];\n      int len2;\n      int len1;\n      if (box_arr[i].up_left_y >= box_arr[cur_rightid].up_left_y)\n        len1 = box_arr[i].up_left_y;\n      else\n        len1 = box_arr[cur_rightid].up_left_y;\n\n      if ((box_arr[i].up_left_y + box_arr[i].height) <= (box_arr[cur_rightid].up_left_y + box_arr[cur_rightid].height))\n        len2 = box_arr[i].up_left_y + box_arr[i].height;\n      else\n        len2 = box_arr[cur_rightid].up_left_y + box_arr[cur_rightid].height;\n\n      box_arr[i].right_ov[j] = abs(len2 - len1);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nithintsk/adaptive-mesh-refinement/MPI/disposable/3"}
{"code": "for (size_t ui = 0; ui < 4; ++ui)\n{\n  temp[ui] = (double *) calloc(N, sizeof(double));\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yattroman/nsu-opp-mpi-openmp-labs/laboratory-2/version-2/main/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  mat1[i] = (float *) malloc(1000 * (sizeof(float)));\n  mat2[i] = (float *) malloc(1000 * (sizeof(float)));\n  res[i] = (float *) malloc(1000 * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ath-90/hpc-openmp-assignment/matrixMul/1"}
{"code": "for (idx_t i = 0; i < nslices; ++i)\n{\n  p_tt_quicksort3(tt, cmplt + 1, histogram_array[i], histogram_array[i + 1]);\n  for (idx_t j = histogram_array[i]; j < histogram_array[i + 1]; ++j)\n  {\n    tt->ind[m][j] = i;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/1"}
{"code": "for (i = 0; i < m_size; i++)\n{\n  aArray[i] = (double *) malloc((sizeof(double)) * m_size);\n  uArray[i] = (double *) malloc((sizeof(double)) * m_size);\n  lArray[i] = (double *) malloc((sizeof(double)) * m_size);\n}\n\n", "pragma": "  #pragma omp prallel for private(i) shared(aArray, uArray, lArray)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n    printf(\"%f \", matrix[(i * size) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/6"}
{"code": "for (int i = 1; i <= NPTS; i++)\n  yVals.push_back(0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reizero01/OpenMP/Non_MP/3"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  final_filter += filter[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ApChris/Image-Convolution/convolution/2"}
{"code": "for (i = 0; i < size; i++)\n  array[i] = i + 1;\n\n", "pragma": "omp parallel for schedule(static, 1) firstprivate(tmp_sum) shared(array, size) reduction(+:sum) default(none)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Yulypso/Richarallele/OpenMp/Ex2/parallel_for_3_for/0"}
{"code": "for (unsigned int j = 1; j <= n; j++)\n{\n  for (unsigned int i = 1; i <= n; i++)\n  {\n    x = i - (dt0 * u[i + ((n + 2) * j)]);\n    y = j - (dt0 * v[i + ((n + 2) * j)]);\n    if (x < 0.5f)\n    {\n      x = 0.5f;\n    }\n    else\n      if (x > (n + 0.5f))\n    {\n      x = n + 0.5f;\n    }\n\n\n    i0 = (int) x;\n    i1 = i0 + 1;\n    if (y < 0.5f)\n    {\n      y = 0.5f;\n    }\n    else\n      if (y > (n + 0.5f))\n    {\n      y = n + 0.5f;\n    }\n\n\n    j0 = (int) y;\n    j1 = j0 + 1;\n    s1 = x - i0;\n    s0 = 1 - s1;\n    t1 = y - j0;\n    t0 = 1 - t1;\n    d[i + ((n + 2) * j)] = (s0 * ((t0 * d0[i0 + ((n + 2) * j0)]) + (t1 * d0[i0 + ((n + 2) * j1)]))) + (s1 * ((t0 * d0[i1 + ((n + 2) * j0)]) + (t1 * d0[i1 + ((n + 2) * j1)])));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo1a/solver/4"}
{"code": "for (int tid = 0; tid < npoints; tid++)\n{\n  for (int i = 0; i < nfeatures; i++)\n    feature_swap[(i * npoints) + tid] = feature[(tid * nfeatures) + i];\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(BLOCK_SIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/kmeans-omp/cluster/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  scanf(\"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment1/lab1_10/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i + 1][j][k] = lhs[0][i + 1][j][k] + comz1;\n    lhs[1][i + 1][j][k] = lhs[1][i + 1][j][k] - comz4;\n    lhs[2][i + 1][j][k] = lhs[2][i + 1][j][k] + comz5;\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/56"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    a[i][j] = (rand() % 50) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_decomposition/Q1/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    pBuf[(i * cols) + j] = output_raster[i][j];\n    if (output_raster[i][j] <= 0)\n      pBuf[(i * cols) + j] = -9999;\n\n    if (output_raster[i][j] > maxVal)\n      maxVal = output_raster[i][j];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/raster/2"}
{"code": "for (j = 0; j <= (len - 1); j += 1)\n{\n  a[i][j] = ((double) i) / 2.0;\n  b[i][j] = ((double) i) / 3.0;\n  c[i][j] = ((double) i) / 7.0;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB098-simd2-orig-no/1"}
{"code": "for (t = 0; t < K; t++)\n{\n  disturb0 = _mm512_set1_ps(disturb[t]);\n  result[t] = logDataVSPrior(val, begin, end, res, disturb0, thread_num);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/PAC2020/main/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"TID %d,i=%d\\n\", id, i);\n  b[i] = a;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/for_section/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  uint32_t *q = x.u32;\n  p = x.c;\n  for (j = 48; j > 0; j--)\n  {\n    uint32_t u = *(q++);\n    t = (*(p++) = u ^ lotus_magic_table[(j--) + t]);\n    t = (*(p++) = (u >> 8) ^ lotus_magic_table[(j--) + t]);\n    u >>= 16;\n    t = (*(p++) = u ^ lotus_magic_table[(j--) + t]);\n    t = (*(p++) = (u >> 8) ^ lotus_magic_table[j + t]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/15"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n    if (i == j)\n  {\n    fprintf(fp, \"%d \", 1);\n  }\n  else\n  {\n    fprintf(fp, \"%d \", 0);\n  }\n\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/PKU-HPC/Testing on Intel Xeon E5 CPUs/ProblemScale/1024*1024/fox_floats_timer_caching_omp_fileIO_benchmark/0"}
{"code": "for (i = myid + 1; i <= n; i += numprocs)\n{\n  x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kc9qey/mpi_openmp/cpi/0"}
{"code": "for (int64_t i = 0; i < n; ++i)\n  order[start[lev[i]]++] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/5"}
{"code": "for (int i = 'a'; i < ('z' + 1); ++i)\n{\n  do\n  {\n    num = (rand() % 38) + 129;\n    exist = find(numbers.begin(), numbers.end(), num) != numbers.end();\n  }\n  while ((((num == ((int) ' ')) || exist) || (num == 152)) || (num == 150));\n  numbers.push_back(num);\n  letterSymbol[(char) i] = num;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eoshtanko/OpenMP/main/0"}
{"code": "for (layer7_index = 0; layer7_index < Layer_CH_Num; layer7_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (layer6_index = 0; layer6_index < Layer_CH_Num; layer6_index++)\n  {\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n      }\n\n    }\n\n    for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n    {\n      for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n      {\n        for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n        {\n          for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n          {\n            temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv6_data[(((layer6_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv7[(((((layer7_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer6_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv7[layer7_index];\n      if (conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n        conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/33"}
{"code": "for (i = 0; i < data_size; i++)\n  *((char *) (new_node->data + i)) = *((char *) (new_data + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/OpenMP&Mthread-dotproduct/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  val = rand() % 100;\n  (*vect)[i] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/7"}
{"code": "for (j = 0; j < width; j++)\n{\n  double radius = 0.27 * sqrt(((i - cx) * (i - cx)) + ((j - cy) * (j - cy)));\n  double angle_in_degree = radius;\n  double conversion = 3.14159265 / 180.0;\n  double cosine_value = cos(angle_in_degree * conversion);\n  double sine_value = sin(angle_in_degree * conversion);\n  int changed_i = (((i - cx) * cosine_value) + ((j - cy) * sine_value)) + cx;\n  int changed_j = (((-(i - cx)) * sine_value) + ((j - cy) * cosine_value)) + cy;\n  if ((changed_i < 0) || (changed_i > height))\n    continue;\n\n  if ((changed_j < 0) || (changed_j > width))\n    continue;\n\n  ((output_data + (i * width)) + j)->red = ((matrix + (changed_i * width)) + changed_j)->red;\n  ((output_data + (i * width)) + j)->green = ((matrix + (changed_i * width)) + changed_j)->green;\n  ((output_data + (i * width)) + j)->blue = ((matrix + (changed_i * width)) + changed_j)->blue;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nishi1612/High-Performance-Computing/Lab4/201601408-201601059-image_processing-warping/parallel_measurement/0"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  p_new[i][0] = 0;\n  p_new[i][x_points - 1] = y[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Laplace Equation/2-D_Laplace_Equation/main/4"}
{"code": "for (int row = 0; row < nel; row++)\n{\n  for (int col = 0; col < nel; col++)\n  {\n    if (row >= col)\n    {\n      cout << \" -\";\n      continue;\n    }\n\n    int map_row;\n    int map_col;\n    int rank;\n    matrix_to_map_index(row, col, nel, &map_row, &map_col, np);\n    rank = get_map(map, np, map_row, map_col);\n    if (rank == 0)\n    {\n      int local_col;\n      if (r == 0)\n      {\n        local_col = col - (q * map_col);\n        if (map_col == 0)\n        {\n          printf(\" %d\", get((*matrix_parts)[map_col], q, row, local_col));\n        }\n        else\n        {\n          printf(\" %d\", (*matrix_parts)[map_col][(row * q) + local_col]);\n        }\n\n      }\n      else\n      {\n        local_col = col - (((q + 1) * map_col) - MIN(map_col, np - r));\n        if (map_col == 0)\n        {\n          printf(\" %d\", get((*matrix_parts)[map_col], (map_col < (np - r)) ? (q) : (q + 1), row, local_col));\n        }\n        else\n        {\n          printf(\" %d\", (*matrix_parts)[map_col][(row * ((map_col < (np - r)) ? (q) : (q + 1))) + local_col]);\n        }\n\n      }\n\n    }\n    else\n    {\n      sim_metric element;\n      MPI_Status state;\n      MPI_Recv(&element, sizeof(sim_metric), MPI_BYTE, rank, TAG_PRINT, MPI_COMM_WORLD, &state);\n      printf(\" %d\", element);\n    }\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/21"}
{"code": "for (c = 0; c < nChunks; c++)\n{\n  doCrypt(c, plain, crypt, key);\n}\n\n", "pragma": "omp parallel for firstprivate(nChunks) private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/frobino/openmp_introduction/Examples/crypt/crypt_omp_cu/0"}
{"code": "for (int rw = 0; rw < m_nCells; rw++)\n{\n  m_packT[rw] = (m_packT[rw] * (1 - m_lagSnow)) + (m_meanTemp[rw] * m_lagSnow);\n  m_SA[rw] += m_snowAccum[rw] - m_SE[rw];\n  if (m_meanTemp[rw] < m_snowTemp)\n  {\n    m_SA[rw] += m_kblow * m_netPcp[rw];\n    m_netPcp[rw] *= 1.f - m_kblow;\n  }\n\n  if (m_SA[rw] < 0.01)\n  {\n    m_snowMelt[rw] = 0.f;\n  }\n  else\n  {\n    float dt = m_maxTemp[rw] - m_t0;\n    if (dt < 0)\n    {\n      m_snowMelt[rw] = 0.f;\n    }\n    else\n    {\n      m_snowMelt[rw] = cmelt * (((m_packT[rw] + m_maxTemp[rw]) * 0.5f) - m_t0);\n      float snowCoverFrac = 0.f;\n      if (m_SA[rw] < m_snowCoverMax)\n      {\n        float xx = m_SA[rw] / m_snowCoverMax;\n        snowCoverFrac = xx / (xx + exp(m_snowCoverCoef1 = m_snowCoverCoef2 * xx));\n      }\n      else\n      {\n        snowCoverFrac = 1.f;\n      }\n\n      m_snowMelt[rw] *= snowCoverFrac;\n      if (m_snowMelt[rw] < 0.f)\n        m_snowMelt[rw] = 0.f;\n\n      if (m_snowMelt[rw] > m_SA[rw])\n        m_snowMelt[rw] = m_SA[rw];\n\n      m_SA[rw] -= m_snowMelt[rw];\n      m_netPcp[rw] += m_snowMelt[rw];\n      if (m_netPcp[rw] < 0.f)\n        m_netPcp[rw] = 0.f;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SNO_SP/SNO_SP/0"}
{"code": "for (i = 0; i < hist_num; ++i)\n{\n  omp_destroy_lock(&hist_locks[i]);\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lumeng16/OpenMPstudy/Basic/lock/2"}
{"code": "for (int i = 0; i < (npack1 * ne); ++i)\n{\n  psi1[i] = (2.0 * rand()) - 1.0;\n  psi2[i] = (2.0 * rand()) - 1.0;\n  psi3[i] = (2.0 * rand()) - 1.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebylaska/NESAP-Kernels/LagrangeMultiplier1/micro_benchmark/dgemm_simple/1"}
{"code": "for (int i = 0; i < 6; i++)\n  printf(\"Th %i: iteration %i\\n\", omp_get_thread_num(), i);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/epoell/openMP_examples_and_Matrix-Matrix-Multiplication/min_examples/0"}
{"code": "for (i = 0; i < 8; i++)\n  printf(\"eu %d, fiz %d\\n\", omp_get_thread_num(), i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q3e/0"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (i = ist; i <= iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n      }\n\n    }\n\n    for (i = ist; i <= L2; i++)\n    {\n      tmp = 1.0 / rsd[i][j][k][0];\n      u21i = tmp * rsd[i][j][k][1];\n      u31i = tmp * rsd[i][j][k][2];\n      u41i = tmp * rsd[i][j][k][3];\n      u51i = tmp * rsd[i][j][k][4];\n      tmp = 1.0 / rsd[i - 1][j][k][0];\n      u21im1 = tmp * rsd[i - 1][j][k][1];\n      u31im1 = tmp * rsd[i - 1][j][k][2];\n      u41im1 = tmp * rsd[i - 1][j][k][3];\n      u51im1 = tmp * rsd[i - 1][j][k][4];\n      flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][j][k][2] = tx3 * (u31i - u31im1);\n      flux[i][j][k][3] = tx3 * (u41i - u41im1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i <= iend; i++)\n    {\n      frct[i][j][k][0] = frct[i][j][k][0] + ((dx1 * tx1) * ((rsd[i - 1][j][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i + 1][j][k][0]));\n      frct[i][j][k][1] = (frct[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((rsd[i - 1][j][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i + 1][j][k][1]));\n      frct[i][j][k][2] = (frct[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((rsd[i - 1][j][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i + 1][j][k][2]));\n      frct[i][j][k][3] = (frct[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((rsd[i - 1][j][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i + 1][j][k][3]));\n      frct[i][j][k][4] = (frct[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((rsd[i - 1][j][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i + 1][j][k][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[1][j][k][m] = frct[1][j][k][m] - (dsspm * ((((+5.0) * rsd[1][j][k][m]) - (4.0 * rsd[2][j][k][m])) + rsd[3][j][k][m]));\n      frct[2][j][k][m] = frct[2][j][k][m] - (dsspm * (((((-4.0) * rsd[1][j][k][m]) + (6.0 * rsd[2][j][k][m])) - (4.0 * rsd[3][j][k][m])) + rsd[4][j][k][m]));\n    }\n\n    ist1 = 3;\n    iend1 = nx - 4;\n    for (i = ist1; i <= iend1; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (dsspm * ((((rsd[i - 2][j][k][m] - (4.0 * rsd[i - 1][j][k][m])) + (6.0 * rsd[i][j][k][m])) - (4.0 * rsd[i + 1][j][k][m])) + rsd[i + 2][j][k][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[nx - 3][j][k][m] = frct[nx - 3][j][k][m] - (dsspm * (((rsd[nx - 5][j][k][m] - (4.0 * rsd[nx - 4][j][k][m])) + (6.0 * rsd[nx - 3][j][k][m])) - (4.0 * rsd[nx - 2][j][k][m])));\n      frct[nx - 2][j][k][m] = frct[nx - 2][j][k][m] - (dsspm * ((rsd[nx - 4][j][k][m] - (4.0 * rsd[nx - 3][j][k][m])) + (5.0 * rsd[nx - 2][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/7"}
{"code": "for (i = sharedFrontierQueue->head; i < sharedFrontierQueue->tail; i++)\n{\n  v = sharedFrontierQueue->queue[i];\n  outNodes = graph->vertices[v].outNodes;\n  out_degree = graph->vertices[v].out_degree;\n  for (j = 0; j < out_degree; j++)\n  {\n    u = outNodes->dest;\n    outNodes = outNodes->next;\n    int u_parent = stats->parents[u];\n    if (u_parent < 0)\n    {\n      if (__sync_bool_compare_and_swap(&stats->parents[u], u_parent, v))\n      {\n        enArrayQueue(localFrontierQueue, u);\n        stats->distances[u] = stats->distances[v] + 1;\n        mf += -u_parent;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:mf) schedule(auto)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/16"}
{"code": "for (int i = 0; i < spmatrix_hsize; i++)\n{\n  for (int j = 0; j < spmatrix->hsize; j++)\n  {\n    hrow[j] = '.';\n  }\n\n  for (int j = 0; j < spmatrix->iia[i]; j++)\n  {\n    if (ABS(spmatrix->val[i][j]) > hthresh)\n    {\n      hrow[spmatrix->jja[i][j]] = '*';\n    }\n\n  }\n\n  for (int j = 0; j < spmatrix->hsize; j++)\n  {\n    fprintf(sFile, \"%c\", hrow[j]);\n  }\n\n  fprintf(sFile, \"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/matrixio/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (flow_in_num_[i] == 0)\n  {\n    last_layer[num_last_layer++] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/7"}
{"code": "for (i = 0; i < chunk_size; i++)\n{\n  struct kd_node_t *arr_element = (struct kd_node_t *) malloc(sizeof(struct kd_node_t));\n  arr_element = chunk_send + i;\n  printf(\"What is being sent to rank 0 as a chunk/array %f\\n\", arr_element->x[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ImolaFodor/kdtree-parallel-construct/kdtree_build_2_tasks_openmp/4"}
{"code": "for (unsigned int i = 0; i < list.size(); i++)\n{\n  if (list[i] == edge)\n    ret = true;\n\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex-87/HyperGraphLib/src/algorithm/Connected/1"}
{"code": "for (int i = 0; i < data_size; i++)\n{\n  int x_datasize = dg.x - 2;\n  int y_datasize = dg.y - 2;\n  float xx_temp = (i % x_datasize) + 1.f;\n  float yy_temp = (((int) floorf(((float) i) / x_datasize)) % y_datasize) + 1.f;\n  float zz_temp = (floorf(((float) i) / x_datasize) / y_datasize) + 1.f;\n  float rx = xx_temp + ran[i % 97];\n  float ry = yy_temp + ran[i % 97];\n  float rz = zz_temp + ran[i % 97];\n  float xp = (((M[0] * rx) + (M[4] * ry)) + (M[8] * rz)) + M[12];\n  float yp = (((M[1] * rx) + (M[5] * ry)) + (M[9] * rz)) + M[13];\n  float zp = (((M[2] * rx) + (M[6] * ry)) + (M[10] * rz)) + M[14];\n  if ((((((zp >= 1.f) && (zp < df.z)) && (yp >= 1.f)) && (yp < df.y)) && (xp >= 1.f)) && (xp < df.x))\n  {\n    ivf_d[i] = floorf(interp(df, f_d, xp, yp, zp) + 0.5f);\n    ivg_d[i] = floorf(interp(dg, g_d, rx, ry, rz) + 0.5f);\n    data_threshold_d[i] = true;\n  }\n  else\n  {\n    ivf_d[i] = 0;\n    ivg_d[i] = 0;\n    data_threshold_d[i] = false;\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/spm-omp/main/0"}
{"code": "for (uint i = 1; i < numBlocks; ++i)\n{\n  for (uint j = 0; j < numBuckets; ++j)\n  {\n    uint delta = blockHistograms[((i - 1) * numBuckets) + j] + offsets[j];\n    blockExScan[(i * numBuckets) + j] += delta;\n    offsets[j] += blockHistograms[((i - 1) * numBuckets) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Vector %d [\", i);\n  for (j = 0; j < 100000; j++)\n  {\n    printf(\"%d \", bag_of_tasks[i][j]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_omp/2"}
{"code": "for (i = 0; i < N; ++i)\n{\n  Y[i] += a * X[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/omptrace/examples/axpy/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  c[i] = a[i] + b[i];\n  printf(\"num_threads = %d; id = %d; c[%d] = %d \\n\", omp_get_num_threads(), omp_get_thread_num(), i, c[i]);\n}\n\n", "pragma": "#pragma omp parallel for  schedule(dynamic, 3) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LiyaSharipova/OpenMP-Tasks/task7/1"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  for (wJ = 0; wJ < BIGN_MATR; wJ += 2)\n  {\n    wV1 = _mm_load_ps(&aMatr1[wI][wJ]);\n    wV2 = _mm_load_ps(&aMatr2[wI][wJ]);\n    wV3 = _mm_add_ps(wV1, wV2);\n    _mm_store_ps(&aMatr3[wI][wJ], wV3);\n  }\n\n}\n\n", "pragma": "omp parallel for private(wI, wJ, wV1, wV2, wV3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/2"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    index = (ii * params.nx) + jj;\n    for (int kk = 0; kk < 9; kk++)\n    {\n      total += cells[index].speeds[kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(3) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk.pomp/4"}
{"code": "for (int i = 0; i < num_nodes; i++)\n{\n  if (vertical)\n    playerShips[shipNodes[i]][active_col] = counter;\n  else\n    playerShips[active_row][shipNodes[i]] = counter;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      B[(i * N) + j] = 0;\n    }\n    else\n    {\n      B[(i * N) + j] = (((float) i) * (j + 1)) / N;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/14"}
{"code": "for (int i = 0; i < (20 + 2); i++)\n{\n  for (int j = 0; j <= (20 + 2); j++)\n  {\n    result[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gokaytitrek/openmp-gameoflife/main/2"}
{"code": "for (i = 20; i < limit; i++)\n{\n  if (divide(i))\n  {\n    printf(\"the number  is equal to = %d \\n\", i);\n    control = 1;\n  }\n\n  if ((i % 100000000) == 0)\n  {\n    printf(\"***thread id : %d, limit = %d \\n\", omp_get_thread_num(), limit);\n  }\n\n}\n\n", "pragma": "omp for schedule(static,200)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex5projecteuler/0"}
{"code": "for (int i = ida; i < idb; i++)\n{\n  sum += x_p[i] * y_p[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnaparker/pybind_examples/hpc_example/src/dot_product/1"}
{"code": "for (t = 0; t < n_2; t++)\n{\n  for (long p = 0; p < n_2; p++)\n  {\n    res_m[t][p] = C_M11[t][p];\n    res_m[t][p + m_2] = C_M12[t][p];\n    res_m[t + n_2][p] = C_M21[t][p];\n    res_m[t + n_2][p + m_2] = C_M22[t][p];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/strassen_mul_2d_omp/3"}
{"code": "for (i = 0; i < population; i++)\n{\n  patient = (struct Patient *) malloc(sizeof(struct Patient));\n  patient->id = sim_pid++;\n  patient->seed = (*capital)->seed;\n  my_rand(&(*capital)->seed);\n  patient->hosps_visited = 0;\n  patient->time = 0;\n  patient->time_left = 0;\n  patient->home_village = *capital;\n  addList(&(*capital)->population, patient);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/health/src/health_ompi/0"}
{"code": "for (k = lt - 1; k >= 1; k--)\n{\n  nx[k] = nx[k + 1] / 2;\n  ny[k] = ny[k + 1] / 2;\n  nz[k] = nz[k + 1] / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/6"}
{"code": "for (int i = 0; i < MAX_N; i++)\n{\n  a[i] = (a_h[i] = i);\n  b[i] = i * 2;\n  c[i] = i - 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-parallel-for-back2back/test/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/11"}
{"code": "for (int index = 0; index < num_elements; ++index)\n{\n  for (int jndex = 0; jndex < num_elements; ++jndex)\n  {\n    a[index][jndex] = index;\n    b[index][jndex] = jndex;\n    result[index][jndex] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akhtyamovpavel/ParallelComputationExamples/OpenMP/05-matrix-multiplication/main/0"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 1; j < 20; j++)\n  A[i][j] = A[i - 1][j];\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/1.race11/0"}
{"code": "for (int y = 0; y < height; y++)\n{\n  double imaginaryValue = upperLeftY - (y * incrementY);\n  double realValue = upperLeftX;\n  for (unsigned int x = 0; x < width; x++)\n  {\n    escapeCounts[(y * width) + x] = isMandelbrotNumber(realValue, imaginaryValue, numberOfIterations);\n    realValue += incrementX;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Balta-Stefan/Mandelbrot-viewer/src/MandelbrotCalculatorOLD/3"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    averageR = 0;\n    averageG = 0;\n    averageB = 0;\n    for (int itImageX = i - (maskDimensions / 2), itMaskX = 0; (itImageX <= (i + (maskDimensions / 2))) && (itMaskX < maskDimensions); itImageX++, itMaskX++)\n    {\n      if (itImageX != (-1))\n      {\n        int row = row_pointers[itImageX];\n        for (int itImageY = j - (maskDimensions / 2), itMaskY = 0; (itImageY <= (j + (maskDimensions / 2))) && (itMaskY < maskDimensions); itImageY++, itMaskY++)\n        {\n          int px = &row[itImageY * 4];\n          if ((((itImageX >= 0) && (itImageX < height)) && (itImageY >= 0)) && (itImageY < width))\n          {\n            averageR += px[0] * maskMatrix[itMaskX][itMaskY];\n            averageG += px[1] * maskMatrix[itMaskX][itMaskY];\n            averageB += px[2] * maskMatrix[itMaskX][itMaskY];\n          }\n\n        }\n\n      }\n\n    }\n\n    if (averageR < 0)\n      averageR = 0;\n    else\n      if (averageR > 255)\n      averageR = 255;\n\n\n    maskedImageR[(i * width) + j] += averageR / 9;\n    if (averageG < 0)\n      averageG = 0;\n    else\n      if (averageG > 255)\n      averageG = 255;\n\n\n    maskedImageG[(i * width) + j] += averageG / 9;\n    if (averageB < 0)\n      averageB = 0;\n    else\n      if (averageB > 255)\n      averageB = 255;\n\n\n    maskedImageB[(i * width) + j] += averageB / 9;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/LoGParallel/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  matrix.rows[i] = matrix.data + (i * cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuguangMeng/MPI-and-OpenMP-Codes/openmpge/1"}
{"code": "for (i = 0; i < l; i++)\n  index[i] = perm[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/66"}
{"code": "for (int i = 0; i < size; i++)\n{\n  input[i] = blocks[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/antonKorobenko/parallel-binsort/binsort_openMp/2"}
{"code": "for (k = 0; k < nz; k++)\n{\n  z = zlo + (k * dx);\n  for (j = 0; j < ny; j++)\n  {\n    y = ylo + (j * dy);\n    u[(i + (j * nx)) + ((k * nx) * ny)] = u_exact(x, y, z);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilmerhenao/Poisson-OpenMP/serial_hw2/10"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  printf(\"%d(%d), \", i, omp_get_num_threads());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/base_parallel_for/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  xe += arrayX[x] * weights[x];\n  ye += arrayY[x] * weights[x];\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:xe, ye)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/7"}
{"code": "for (int i = 0; i < mn; i++)\n{\n  b[i] = a[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/23"}
{"code": "for (i = 0; i < measurement_num; i++)\n{\n  if (meas->next == 0)\n  {\n    printf(\"ERROR\\tStill not exist Measurement #%d\\n\", meas->date);\n    exit(0);\n  }\n\n  meas = meas->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/23"}
{"code": "for (i = 0; i < 20; i++)\n{\n  printf(\"i=%d, soy el hilo %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanchuletas/Concurrent_Programming/ciclo_for_OMP/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    if (isCorner(i, size - 1) || isCorner(j, size - 1))\n    {\n      array2[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/almazhankapan/game-of-life/game_of_life/5"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int label = labels[(i * width) + j];\n    seg_data[(((i * width) + j) * 3) + 0] = (char) red[label];\n    seg_data[(((i * width) + j) * 3) + 1] = (char) blue[label];\n    seg_data[(((i * width) + j) * 3) + 2] = (char) green[label];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(numThreads) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mebegu/Parallel-Image-Segmentation/imseg_serial/8"}
{"code": "for (i = 0; i < STEPS; i++)\n{\n  vector_generate();\n  if (odd)\n  {\n    odd--;\n    even++;\n  }\n  else\n  {\n    odd++;\n    even--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skku-multicore-hw/Project1_gol_openmp/process/2"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    C[(i * ldc) + j] *= beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = w * (i - 0.5);\n  sum = sum + f(x);\n}\n\n", "pragma": "  #pragma omp parallel for private(x) shared(w) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyRybalkin/openmpi_samples/compute_pi_openmp/0"}
{"code": "for (i = 0; i < n; i++)\n  chunk->checksum += checksums[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP2/inf8601-lab2-2.1.3/encode/algo/4"}
{"code": "for (int i = 0; i < (width * height); i++)\n{\n  if ((((i < width) || ((i % width) == 0)) || (((i + 1) % width) == 0)) || (((height - 1) * width) <= i))\n  {\n    colorImage->pixels[i] = greyImage->pixels[i];\n  }\n  else\n  {\n    colorImage->pixels[i] = greyPixelToColor(greyImage->pixels, i, width, height);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omar-E-R/tp-programmation-parallel-openMP/TP3/ELRIFAI_Omar_tp34/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  out[i] = in1[i] + in2[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/add_contiguous/0"}
{"code": "for (y = 2; y < inner_j; y++)\n{\n  sum = 0;\n  for (fx = -1; fx <= 1; fx++)\n    for (fy = -1; fy <= 1; fy++)\n    sum += local_array_in[((x - fx) * (inner_j + 2)) + (y - fy)] * filter.array[fx + 1][fy + 1];\n\n\n  local_array_out[(x * (inner_j + 2)) + y] = ((int) sum) / filter.sum;\n}\n\n", "pragma": "omp for private(fx,fy,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/main_OMP/2"}
{"code": "for (iter = 0; (iter <= file_info->LIMIT) && (total_has_changed > 0); iter++)\n{\n  has_changed = 0;\n  group_points_with_cuda(&has_changed, set_of_points, k_clusters, set_of_points_size, file_info->K);\n  update_clusters(k_clusters, file_info->K, set_of_points, set_of_points_size);\n  recalculate_centroids(k_clusters, file_info->K);\n  update_has_changed(&has_changed, &total_has_changed);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/4"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  int m1count = matrix.ia[i + 1] - matrix.ia[i];\n  for (int j = 0; j < matrix2.cols; j++)\n  {\n    double dp = 0;\n    int m1pos = matrix.ia[i];\n    int m1seen = 0;\n    int m2count = matrix2.ia[j + 1] - matrix2.ia[j];\n    int m2pos = matrix2.ia[j];\n    int m2seen = 0;\n    while ((m1seen != m1count) && (m2seen != m2count))\n    {\n      if (matrix.ja[m1pos] == matrix2.ja[m2pos])\n      {\n        dp += matrix.nnz.f[m1pos++] * matrix2.nnz.f[m2pos++];\n        m1seen++;\n        m2seen++;\n      }\n      else\n        if (matrix.ja[m1pos] < matrix2.ja[m2pos])\n      {\n        m1seen++;\n        m1pos++;\n      }\n      else\n      {\n        m2seen++;\n        m2pos++;\n      }\n\n\n    }\n\n    if (dp != 0)\n    {\n      result_local[i].elements[result_local[i].count].value.f = dp;\n      result_local[i].elements[result_local[i].count].x = i;\n      result_local[i].elements[result_local[i].count++].y = j;\n    }\n\n  }\n\n  totalcount += result_local[i].count;\n}\n\n", "pragma": "omp parallel for reduction(+:totalcount) shared(matrix,matrix2) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/9"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  tmprlt->paras[i] = randu(topoinfo->prsrandrange[0][i], topoinfo->prsrandrange[1][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/66"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  mat_free(aTa[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/cpd/12"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < 14; j++)\n    printf(\"Implied vol. for time %.2f is %.2f%% \\n\", op[i].T, op[i].implied_vol[j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DomenicoNatella/implied_volatility/implied_volatility_newton/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n    printf(\"%d \", array[(i * cols) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jenniferleeny/openMP/code/wireroute/0"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || (mat2[rowcol] <= 0.001))\n  {\n    matOut3[rowcol] = 0.0;\n    matdtdry[rowcol] = -28768;\n  }\n  else\n  {\n    if (((mat1[rowcol] * 0.0001) > ndvi_max) && ((mat1[rowcol] * 0.0001) < 0.98))\n      ndvi_max = mat1[rowcol] * 0.0001;\n\n    if (((mat2[rowcol] * 0.001) > albedo_max) && ((mat2[rowcol] * 0.001) < 0.9))\n      albedo_max = mat2[rowcol] * 0.001;\n\n    if (((mat2[rowcol] * 0.001) < albedo_min) && ((mat2[rowcol] * 0.001) > 0.001))\n      albedo_min = mat2[rowcol] * 0.001;\n\n    tempk = mat8[rowcol] * 0.02;\n    dem = mat14[rowcol];\n    t0dem = tempk + (0.00627 * dem);\n    if ((t0dem > t0dem_max) && (t0dem > 274))\n      t0dem_max = t0dem;\n\n    if ((t0dem < t0dem_min) && (t0dem > 274))\n      t0dem_min = t0dem;\n\n    etpotd = et_pot_day(mat15[rowcol], tempk, roh_w);\n    matOut3[rowcol] = etpotd;\n    Rn = mat16[rowcol];\n    g0 = mat17[rowcol];\n    matdtdry[rowcol] = (0.2 * (Rn - g0)) / u2m;\n    if (matdtdry[rowcol] > 100)\n      matdtdry[rowcol] = 0;\n\n    if (matdtdry[rowcol] > dtdry_max)\n      dtdry_max = matdtdry[rowcol];\n\n    if (matdtdry[rowcol] < dtdry_min)\n      dtdry_min = matdtdry[rowcol];\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, tempk, etpotd, Rn, g0, dem, t0dem,) shared(N, nX, nY, roh_w, tsw, doy, u2m, t0dem_min,t0dem_max,dtdry_min,dtdry_max, ndvi_max,albedo_min,albedo_max, mat1,mat2,mat8,mat14, mat15,mat16, mat17, matdtdry, matOut3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/0"}
{"code": "for (int p = 0; p < NUMPAT; p++)\n{\n  printf(\"\\n%d\\t\", p);\n  for (int k = 0; k < NUMOUT; k++)\n  {\n    printf(\"%f\\t%f\\t\", Target[p][k], Output[p][k]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/15"}
{"code": "for (i = 0; i < 40; i++)\n  pi += sum[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/pi_omp/1"}
{"code": "for (i = 0; i < (2 * n); i++)\n  if (vla[i] != ' ')\n  __builtin_abort();\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.c/pr45784/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i - 1][j][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/100"}
{"code": "for (unsigned i = 0, e = Node->getNumLabels(); i != e; ++i)\n{\n  if (i != 0)\n    OS << \", \";\n\n  OS << Node->getLabelName(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/lib/AST/StmtPrinter/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp parallel for num_threads(2) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ehsan1222/parallel-processing-cheats/open-mp-examples/example10/0"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  if (((((b[j] / bj) - 1.0) >= 0) ? ((b[j] / bj) - 1.0) : (-((b[j] / bj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/24"}
{"code": "for (int i = 0; i < (rows + 1); i++)\n{\n  ptr[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMP/0"}
{"code": "for (long i = 0; i < 10; i++)\n{\n  {\n    result++;\n  }\n  caca++;\n  caca++;\n  caca++;\n  caca++;\n}\n\n", "pragma": "omp for schedule(dynamic,3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_task_name/0"}
{"code": "for (i = 0; i < 600; i++)\n  a[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Task/checking_scope_of_variables_inside_task/0"}
{"code": "for (uint8_t i = 0; i < 4; ++i)\n{\n  r[Xp(i, 0) >= center_x][Yp(i, 0) >= center_y] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinnik-dmitry07/image-homography/ImageHomographyOMP/0"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  copyFirstPixelOnRow_OpenMP(src.data(), width, dst.data(), width, width, height, true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/2"}
{"code": "for (i = 0; i < number_bodies; i++)\n{\n  (file << R[i][0]) << \" \";\n  (file << R[i][1]) << \" \";\n  (file << R[i][2]) << \" \";\n  file << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/6"}
{"code": "for (octave = (k = 0); octave < params->nOctaves; octave++)\n{\n  for (sc = -1; sc <= params->nOctaveLayers; sc++, k++)\n  {\n    if (sc < 0)\n      sizeCache[k] = (size = 7 << octave);\n    else\n      sizeCache[k] = (size = ((sc * 6) + 9) << octave);\n\n    scaleCache[k] = (scale = MAX(size, SIZE0));\n    hessian_rows = (sum->rows * SIZE0) / scale;\n    hessian_cols = (sum->cols * SIZE0) / scale;\n    hessians[k] = cvCreateMat(hessian_rows, hessian_cols, CV_32FC1);\n    traces[k] = cvCreateMat(hessian_rows, hessian_cols, CV_32FC1);\n    icvResizeHaarPattern(dx_s, Dx, NX, SIZE0, size, sum->cols);\n    icvResizeHaarPattern(dy_s, Dy, NY, SIZE0, size, sum->cols);\n    icvResizeHaarPattern(dxy_s, Dxy, NXY, SIZE0, size, sum->cols);\n    for (i = 0; i < NXY; i++)\n      Dxy[i].w *= 0.9f;\n\n    float *hessian = hessians[k]->data.fl;\n    float *trace = traces[k]->data.fl;\n    for (i = 0; i < (hessian_cols * (SIZE0 / 2)); i++)\n      hessian[i] = (hessian[((hessian_cols * hessian_rows) - 1) - i] = (trace[i] = (trace[((hessian_cols * hessian_rows) - 1) - i] = 0.f)));\n\n    hessian += (SIZE0 / 2) * (hessian_cols + 1);\n    trace += (SIZE0 / 2) * (hessian_cols + 1);\n    for (j = 0; j <= (hessian_cols - SIZE0); j++)\n      xofs[j] = (j * scale) / SIZE0;\n\n    for (i = 0; i < (hessian_rows - SIZE0); i++, trace += hessian_cols, hessian += hessian_cols)\n    {\n      const int *sum_ptr = sum->data.i + (sum->cols * ((i * scale) / SIZE0));\n      for (j = 0; j < (SIZE0 / 2); j++)\n        hessian[(-j) - 1] = (hessian[(hessian_cols - SIZE0) + j] = (trace[(-j) - 1] = (trace[(hessian_cols - SIZE0) + j] = 0.f)));\n\n      for (j = 0; j <= (hessian_cols - SIZE0); j++)\n      {\n        const int *s = sum_ptr + xofs[j];\n        dx = (((((s[Dx[0].p0] + s[Dx[0].p3]) - s[Dx[0].p1]) - s[Dx[0].p2]) * Dx[0].w) + ((((s[Dx[1].p0] + s[Dx[1].p3]) - s[Dx[1].p1]) - s[Dx[1].p2]) * Dx[1].w)) + ((((s[Dx[2].p0] + s[Dx[2].p3]) - s[Dx[2].p1]) - s[Dx[2].p2]) * Dx[2].w);\n        dy = (((((s[Dy[0].p0] + s[Dy[0].p3]) - s[Dy[0].p1]) - s[Dy[0].p2]) * Dy[0].w) + ((((s[Dy[1].p0] + s[Dy[1].p3]) - s[Dy[1].p1]) - s[Dy[1].p2]) * Dy[1].w)) + ((((s[Dy[2].p0] + s[Dy[2].p3]) - s[Dy[2].p1]) - s[Dy[2].p2]) * Dy[2].w);\n        dxy = ((((((s[Dxy[0].p0] + s[Dxy[0].p3]) - s[Dxy[0].p1]) - s[Dxy[0].p2]) * Dxy[0].w) + ((((s[Dxy[1].p0] + s[Dxy[1].p3]) - s[Dxy[1].p1]) - s[Dxy[1].p2]) * Dxy[1].w)) + ((((s[Dxy[2].p0] + s[Dxy[2].p3]) - s[Dxy[2].p1]) - s[Dxy[2].p2]) * Dxy[2].w)) + ((((s[Dxy[3].p0] + s[Dxy[3].p3]) - s[Dxy[3].p1]) - s[Dxy[3].p2]) * Dxy[3].w);\n        hessian[j] = (float) ((dx * dy) - (dxy * dxy));\n        trace[j] = (float) (dx + dy);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvsurf/2"}
{"code": "for (j = num_elements; j < ((cols_per_block - 1) * num_elements); j++)\n{\n  for (i = 1; i < (rows_per_block - 1); i++)\n  {\n    if ((!convolution(Table, Final, i, j, h, num_elements)) && (!lchanges))\n    {\n      lchanges++;\n      changes += lchanges;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,lchanges) reduction(+:changes)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisKarampas/Image_Convolution/src/main/0"}
{"code": "for (p = 0; p < M; p++)\n{\n  for (j = 0; j < N; j++)\n  {\n    float sum = 0.0;\n    for (q = 0; q < K; q++)\n    {\n      sum += weights[(p * K) + q] * conv_tensor[(((gid * K) * N) + (q * N)) + j];\n    }\n\n    output[(((i * M) * N) + (p * N)) + j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-gpu/1"}
{"code": "for (i = 1; i < (Nx - 1); ++i)\n  for (j = 1; j < (Ny - 1); ++j)\n  un[i][j] = (((u[i][j] + ((((dt * x[i]) * (Lx - x[i])) * y[j]) * (Ly - y[j]))) + ((0.5 * cx2) * ((u[i - 1][j] - (2 * u[i][j])) + u[i + 1][j]))) + ((0.5 * cy2) * ((u[i][j - 1] - (2 * u[i][j])) + u[i][j + 1]))) + ((((((0.5 * dt2) * 2) * c) * c) * (1 + (t / 2))) * ((y[j] * (Ly - y[j])) + (x[i] * (Lx - x[i]))));\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/set/2020/exercise2/5"}
{"code": "for (int i = 0; i < shuffleTime; i++)\n{\n  from = rand() % len;\n  to = rand() % len;\n  temp = idx[from];\n  idx[from] = idx[to];\n  idx[to] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n    printf(\"\\t%d \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/3/strassen/9"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  free(pointer[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshuawallace/hw4_scientific_computing/heat_omp/2"}
{"code": "for (int i = 0; i < size_target; i++)\n{\n  tar_c[i] = vec3(pos[i + size_scene]) - mu_tar;\n  cor_c[i] = vec3(pos[pair[i]]) - mu_cor;\n}\n\n", "pragma": "    #pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinayakvivek/Iterative-Closest-Point/src/icp/5"}
{"code": "for (int i = 0; i < image_height; i++)\n{\n  for (int j = 0; j < image_width; j++)\n  {\n    outputImage[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/usaruner/OpenMP/ImplementationA-tester/0"}
{"code": "for (int i = 0; i < num; ++i)\n{\n  x_new[i] = b[i];\n  for (int j = 0; j < i; ++j)\n  {\n    x_new[i] -= a[i][j] * x_old[j];\n  }\n\n  for (int j = i + 1; j < num; ++j)\n  {\n    x_new[i] -= a[i][j] * x_old[j];\n  }\n\n  x_new[i] /= a[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arnav-kansal/parallel_linsolver/source/gs/4"}
{"code": "for (int i = 2; i < ((int) sqrt((double) size)); i++)\n{\n  if (!primes[i])\n    continue;\n\n  for (int j = i * 2; j < size; j += i)\n    primes[j] = false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fizyk93/OpenMP/main/8"}
{"code": "for (int i = 0; i < numberOfPointsForHost; i++)\n{\n  int tid = omp_get_thread_num();\n  if ((tid == MASTER_THREAD) && cudaActivate)\n  {\n    cudaInitPoints(mPointsInDevice, aNumberOfPointsForCuda, mNumberOfPointsInDevice, mCosAngleInDevice, mSinAngleInDevice);\n    cudaActivate = false;\n  }\n\n  aPoints[i].mX = aPoints[i].mA + (aPoints[i].mR * cosAngle);\n  aPoints[i].mY = aPoints[i].mB + (aPoints[i].mR * singAngle);\n  aPoints[i].mDistnceToCenter = DEFAULT_MAX_POINT_VALUE;\n  aPoints[i].mCentroidId = 0;\n  if (i < (*aNumberOfCentroids))\n  {\n    aCentroids[i].mId = i;\n    aCentroids[i].mX = aPoints[i].mX;\n    aCentroids[i].mY = aPoints[i].mY;\n    aCentroids[i].mNumberOfPoints = 0;\n    aCentroids[i].mXcount = 0;\n    aCentroids[i].mYCount = 0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/1"}
{"code": "for (int i = 0; i < L; ++i)\n{\n  end[i + 1][0] = begin[i][C - 1];\n  end[i + 1][C + 1] = begin[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cristof17/Game-of-Life-OpenMP/g_omp/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    n = ((m - 3) + 1) * 5;\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/182"}
{"code": "for (i = 0; i < width; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    printf(\"%.2lf \", arr[(i * width) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/7"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  answer.set(i, nablaA_myuAB[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/34"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    if ((i > 0) && (i < (rows - 1)))\n    {\n      if ((j > 0) && (j < (cols - 1)))\n      {\n        storAvg[(i * cols) + j] = ((((data[i - 1][j - 1] + data[i - 1][j]) + data[i - 1][j + 1]) + ((data[i][j - 1] + data[i][j]) + data[i][j + 1])) + ((data[i + 1][j - 1] + data[i + 1][j]) + data[i + 1][j + 1])) / 9.0;\n      }\n      else\n        if (j == 0)\n      {\n        storAvg[(i * cols) + j] = (((data[i - 1][j] + data[i - 1][j + 1]) + (data[i][j] + data[i][j + 1])) + (data[i + 1][j] + data[i + 1][j + 1])) / 6.0;\n      }\n      else\n      {\n        storAvg[(i * cols) + j] = (((data[i - 1][j - 1] + data[i - 1][j]) + (data[i][j - 1] + data[i][j])) + (data[i + 1][j - 1] + data[i + 1][j])) / 6.0;\n      }\n\n\n    }\n    else\n      if (i == 0)\n    {\n      if ((j > 0) && (j < (cols - 1)))\n      {\n        storAvg[(i * cols) + j] = (((data[i][j - 1] + data[i][j]) + data[i][j + 1]) + ((data[i + 1][j - 1] + data[i + 1][j]) + data[i + 1][j + 1])) / 6.0;\n      }\n      else\n        if (j == 0)\n      {\n        storAvg[(i * cols) + j] = ((data[i][j] + data[i][j + 1]) + (data[i + 1][j] + data[i + 1][j + 1])) / 4.0;\n      }\n      else\n      {\n        storAvg[(i * cols) + j] = ((data[i][j - 1] + data[i][j]) + (data[i + 1][j - 1] + data[i + 1][j])) / 4.0;\n      }\n\n\n    }\n    else\n    {\n      if ((j > 0) && (j < (cols - 1)))\n      {\n        storAvg[(i * cols) + j] = (((data[i - 1][j - 1] + data[i - 1][j]) + data[i - 1][j + 1]) + ((data[i][j - 1] + data[i][j]) + data[i][j + 1])) / 6.0;\n      }\n      else\n        if (j == 0)\n      {\n        storAvg[(i * cols) + j] = ((data[i - 1][j] + data[i - 1][j + 1]) + (data[i][j] + data[i][j + 1])) / 4.0;\n      }\n      else\n      {\n        storAvg[(i * cols) + j] = ((data[i - 1][j - 1] + data[i - 1][j]) + (data[i][j - 1] + data[i][j])) / 4.0;\n      }\n\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bshapir/OpenMP-312/matAverager/0"}
{"code": "for (i = 0; i < L1; i++)\n  for (j = 0; j < L2; j++)\n  for (k = 0; k < L3; k++)\n  A[(j * N) + k] += (-C[(j * N) + i]) * R[(i * N) + k];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/9"}
{"code": "for (long long i = 0; i < 10; ++i)\n{\n  ;\n}\n\n", "pragma": "#pragma omp distribute parallel for reduction(task, +: argc, argv[0:10][0:argc])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/distribute_parallel_for_reduction_task_codegen/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  (cout << \"\\t\") << val[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/matxvec_sparse/matxvec_sparse/6"}
{"code": "for (i = 0; i < 768; i++)\n  for (j = 0; j < 768; j++)\n{\n  int end = 0;\n  while (!end)\n  {\n    V[i][j] += 0.00001 + ((((0.0002 * ((double) i)) / 768) * ((double) j)) / 768);\n    if (V[i][j] > 1.0)\n      end = 1;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for shared(V) private(i,j) schedule(dynamic, 16)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab4_OpenMP/Test1_Schedules/ejemplo2/0"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NL; j++)\n  {\n    if (percentDiff(G[(i * NL) + j], G_outputFromGpu[(i * NL) + j]) > PERCENT_DIFF_ERROR_THRESHOLD)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm_omp_out/4"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/56"}
{"code": "for (int c = c1; c < c2; c++)\n{\n  int r = (int) ((k * (c - c1)) + r1);\n  data[((r * w) * 3) + (3 * c)] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 1] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 2] = 255;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/image_utility/9"}
{"code": "for (int m = 0; m < count; ++m)\n  omp_target_free(pointcloud2[m].data, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/points2image/kernel/4"}
{"code": "for (int i = 0; i < numSamples; ++i)\n{\n  free(input[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/16"}
{"code": "for (int n = 0; n < N; n++)\n{\n  if (root->children[n].move_id == move_id)\n  {\n    new_root = root->children[n].node;\n    new_root->parent = NULL;\n  }\n  else\n    free_node(root->children[n].node);\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlSaeed/15618-Final-Project/mcts_player/5"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    sum = 0;\n    for (k = 0; k < 10; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment1/Asgn11/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/21"}
{"code": "for (int i = 0; i < v.rows(); i++)\n{\n  sum += v(i) * v(i);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/16"}
{"code": "for (row = 0; row < SIZE; row++)\n{\n  for (col = 0; col < SIZE; col++)\n  {\n    if (!curr->assigned[row][col])\n    {\n      if (curr->possiblevalues[row][col] == 0)\n        return -1;\n      else\n      {\n        if ((curr->possiblevalues[row][col] & (curr->possiblevalues[row][col] - 1)) == 0)\n        {\n          int k = 0;\n          do\n          {\n            k++;\n            curr->possiblevalues[row][col] >>= 1;\n          }\n          while (curr->possiblevalues[row][col]);\n          assign_possiblevalues(k, curr, row, col);\n          col = SIZE;\n          row = -1;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/26"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  arr[i] = arr[i] * 2;\n}\n\n", "pragma": "omp target parallel for map(tofrom: arr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/assume/test_assume_absent/0"}
{"code": "for (unsigned int j = 1; j <= n; j++)\n{\n  for (unsigned int i = 1; i <= n; i++)\n  {\n    u[i + ((n + 2) * j)] -= (0.5f * n) * (p[(i + 1) + ((n + 2) * j)] - p[(i - 1) + ((n + 2) * j)]);\n    v[i + ((n + 2) * j)] -= (0.5f * n) * (p[i + ((n + 2) * (j + 1))] - p[i + ((n + 2) * (j - 1))]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo1a/solver/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  suma[i] = vect1[i] + vect2[i];\n  printf(\"[Proceso %d] (Suma) He calculado %f (indice=%d)\\n\", id, suma[i], i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/5"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    result(i, j) = this->operator()(i, j) - rhs(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/5"}
{"code": "for (i = 0; i < nrow; i++)\n{\n  for (j = 0; j < ncol; j++)\n  {\n    printf(\"%8.2e \", *((ary + (size * i)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/12"}
{"code": "for (int ElN = 0; ElN < Len; ElN++)\n{\n  SOut.PutStrLn((((SpMat.Val1[ElN].GetStr() + \" \") + SpMat.Val2[ElN].GetStr()) + \" \") + SpMat.Val3[ElN].GetStr());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/16"}
{"code": "for (i = 0; i < n2; i++)\n{\n  R[i] = fit[(mid + 1) + i];\n  copy(G2[i], genes[(mid + 1) + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/9"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c8 = 0; c8 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c8++)\n  {\n    for (c9 = (1 > (16 * c8)) ? (1) : (16 * c8); c9 <= ((((16 * c8) + 15) < (n + (-1))) ? ((16 * c8) + 15) : (n + (-1))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        B[c9][c15] = B[c9][c15] - ((A[c9][c15] * A[c9][c15]) / B[c9 - 1][c15]);\n      }\n\n    }\n\n  }\n\n  for (c8 = 0; c8 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c8++)\n  {\n    for (c9 = (1 > (16 * c8)) ? (1) : (16 * c8); c9 <= ((((16 * c8) + 15) < (n + (-1))) ? ((16 * c8) + 15) : (n + (-1))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        X[c9][c15] = X[c9][c15] - ((X[c9 - 1][c15] * A[c9][c15]) / B[c9 - 1][c15]);\n      }\n\n    }\n\n  }\n\n  for (c8 = 0; c8 <= ((((n + (-3)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-3))) + 16) + 1) / 16)) : (-((((-(n + (-3))) + 16) - 1) / 16))) : ((n + (-3)) / 16)); c8++)\n  {\n    for (c9 = 16 * c8; c9 <= ((((16 * c8) + 15) < (n + (-3))) ? ((16 * c8) + 15) : (n + (-3))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        X[(n - 2) - c9][c15] = (X[(n - 2) - c9][c15] - (X[(n - c9) - 3][c15] * A[(n - 3) - c9][c15])) / B[(n - 2) - c9][c15];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2 ,c15 ,c9 ,c8 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/7"}
{"code": "for (i = 0; i < 3; i++)\n{\n  int _imopVarPre250;\n  int _imopVarPre251;\n  _imopVarPre250 = d_imopVarPre77[i];\n  _imopVarPre251 = ilog2(_imopVarPre250);\n  logd_imopVarPre80[i] = _imopVarPre251;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/14"}
{"code": "for (int x = 1; x <= (columns - 2); x++)\n{\n  calculateNextState(columns, rows, u1, u2, x, rows - 2);\n}\n\n", "pragma": "omp for reduction(+ : alive, changed)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kommz13/parallelprogramming/main_omp/2"}
{"code": "for (int i = 1; i < n; ++i)\n  ;\n\n", "pragma": "omp parallel for default(shared) schedule(dynamic, 1) reduction(+ : time)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang7/tools/flang-driver/test/CoverageMapping/openmp/0"}
{"code": "for (int j = 0; j < ArrayColumn; j++)\n{\n  E[i][j] = E[i][j] ^ R[First[i]][j];\n}\n\n", "pragma": "                #pragma omp parallel for num_threads(NUM_THREADS),shared(ArrayColumn)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tttran67/Parallel-Programming-Lab5_OpenMP/special/newomp/main/3"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  Matrix[i] = (float *) malloc((sizeof(float)) * 10);\n  Matrix2[i] = (float *) malloc((sizeof(float)) * 10);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/omp_parallel_for/stencil/0"}
{"code": "for (size_t i = 0; i < (row - 1); i++)\n{\n  for (size_t j = 0; j < (row - 1); j++)\n  {\n    if (atof(content[(j * column) + 3].c_str()) < atof(content[((j + 1) * column) + 3].c_str()))\n    {\n      temp[0] = content[j * column];\n      temp[1] = content[(j * column) + 1];\n      temp[2] = content[(j * column) + 2];\n      temp[3] = content[(j * column) + 3];\n      content[j * column] = content[(j + 1) * column];\n      content[(j * column) + 1] = content[((j + 1) * column) + 1];\n      content[(j * column) + 2] = content[((j + 1) * column) + 2];\n      content[(j * column) + 3] = content[((j + 1) * column) + 3];\n      content[(j + 1) * column] = temp[0];\n      content[((j + 1) * column) + 1] = temp[1];\n      content[((j + 1) * column) + 2] = temp[2];\n      content[((j + 1) * column) + 3] = temp[3];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 784; j++)\n  {\n    WL1[i][j] -= (((double) 0.05) * in[j]) * delta1[i];\n  }\n\n  WL1[i][784] -= ((double) 0.05) * delta1[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/5"}
{"code": "for (int i = 0; i < (0x01 << 9); i++)\n{\n  uint8_t r = ((int) ((127.0 * cos(((2.0 * M_PI) * i) / (0x01 << 9))) + 0.5)) + 128;\n  uint8_t g = ((int) ((127.0 * sin(((2.0 * M_PI) * i) / (0x01 << 9))) + 0.5)) + 128;\n  uint8_t b = ((int) ((127.0 * sin(((2.0 * M_PI) * i) / ((0x01 << 9) >> 1))) + 0.5)) + 128;\n  colormap[(3 * i) + 0] = r;\n  colormap[(3 * i) + 1] = g;\n  colormap[(3 * i) + 2] = b;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/misc/mandelbrot/2"}
{"code": "for (i = 0; i < bots_arg_size_1; i++)\n{\n  for (j = 0; j < bots_arg_size_1; j++)\n  {\n    r_err = M[(i * bots_arg_size_1) + j] - N[(i * bots_arg_size_1) + j];\n    if (r_err == 0.0)\n      continue;\n\n    if (r_err < 0.0)\n      r_err = -r_err;\n\n    if (M[(i * bots_arg_size_1) + j] == 0)\n    {\n      bots_message(\"Checking failure: A[%d][%d]=%f  B[%d][%d]=%f; \\n\", i, j, M[(i * bots_arg_size_1) + j], i, j, N[(i * bots_arg_size_1) + j]);\n      return FALSE;\n    }\n\n    r_err = r_err / M[(i * bots_arg_size_1) + j];\n    if (r_err > EPSILON)\n    {\n      bots_message(\"Checking failure: A[%d][%d]=%f  B[%d][%d]=%f; Relative Error=%f\\n\", i, j, M[(i * bots_arg_size_1) + j], i, j, N[(i * bots_arg_size_1) + j], r_err);\n      return FALSE;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/sparselu/sparselu_for/sparselu/3"}
{"code": "for (int i = 0; i < (h + 2); i++)\n{\n  for (int j = 0; j < (w + 2); j++)\n  {\n    if ((((i == 0) || (j == 0)) || (i == (h + 1))) || (j == (w + 1)))\n    {\n      arr1[i][j] = 0;\n      arr2[i][j] = 0;\n    }\n    else\n    {\n      arr1[i][j] = rand() % 2;\n      arr2[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/malfusion/hpc-game-of-life/gameoflife-opengl/0"}
{"code": "for (i = 0; i < num_b; i++)\n{\n  *(((unsigned long *) dst) + i) = *(((unsigned long *) src) + i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  for (j = 0; j < num_thread; j++)\n  {\n    histo[i] += histo_thread[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_creative/1"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  timer[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/15"}
{"code": "for (i = 0; i < nb_patterns; i++)\n{\n  printf(\"Number of matches for pattern <%s>: %d\\n\", pattern[i], n_matches[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmOMP/3"}
{"code": "for (n = 1; n < (N + 1); n++)\n{\n  sum = 0;\n  sumbis = 0;\n  for (k = 0; k < (nsctrellis.stateNb / 2); k++)\n  {\n    sum += exp(A[(k + (nsctrellis.stateNb / 2)) + (n * nsctrellis.stateNb)] + B[(k + (nsctrellis.stateNb / 2)) + (n * nsctrellis.stateNb)]);\n    sumbis += exp(A[k + (n * nsctrellis.stateNb)] + B[k + (n * nsctrellis.stateNb)]);\n  }\n\n  extrinsic_data[n - 1] = log(sum / sumbis) - apriori_data[n - 1];\n}\n\n", "pragma": "#pragma omp parallel for private(n,k,sum,sumbis)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_nsc/2"}
{"code": "for (r = 0; r < 1000; r++)\n{\n  xLocal[firstRow - 1][r] = 100;\n  xLocal[lastRow - 1][r] = 100;\n  xNew[firstRow - 1][r] = 100;\n  xNew[lastRow - 1][r] = 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/se-mendheim/Jacobi-Iterations/JacobiIteration/5"}
{"code": "for (const_iterator I = DKinds.begin(), E = DKinds.end(); I != E; ++I)\n{\n  if (isAllowedClauseForDirective(*I, CKind))\n    return true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/CodeGen/CGStmtOpenMP/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[i] = (double *) malloc(1000 * (sizeof(double)));\n  b[i] = (double *) malloc(1000 * (sizeof(double)));\n  c[i] = (double *) malloc(1000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/valeroclemente/AdvanceComputerArchitecture/OpenMP_linux_codes/MulMatOpenmp_linux/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < M; j++)\n    (cout << mat[i][j]) << \" \\n\"[j == (N - 1)];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Minyoung-Kim1110/OpenMP/HW1/jacobi/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    mat[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/priyanka2802/ParallelLUFactorization/RBParLU/4"}
{"code": "for (uint k = 0; k < repeat; k++)\n{\n  bs(aSize, zSize, a, z, r, N);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bsearch-omp/main/6"}
{"code": "for (i = 0; i < n; i++)\n  result = result + (a[i] * b[i]);\n\n", "pragma": "#pragma omp parallel for private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/function-attr/0"}
{"code": "for (unsigned int i = 0; i < K; i++)\n{\n  temp_combos[i] = combination[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RobertWSmith/RcppRegression/src/ls/1"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  x_n[i] = x_n1[i];\n}\n\n", "pragma": "#pragma omp parallel for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/9"}
{"code": "for (u = 6; u == 0; u--)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-2/5"}
{"code": "for (int i = 0; i < objs; i++)\n{\n  move(i);\n  checkBounds(i);\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/SoaSimulator/8"}
{"code": "for (int ii = 0; ii < test.size(); ii++)\n{\n  test[ii].draw();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NathanJewell/MouseParticle_OPENMP/src/ofApp/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += randArray[i];\n  diff += randArray[i] * randArray[i];\n}\n\n", "pragma": "#pragma omp for reduction(+:sum) reduction(+:diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmarzzz/OpenMPTests/djm6267_hw3/part1_omp/hw3_part1_omp_djm6267/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  xb1 = a + (i * l);\n  xb2 = a + ((i + 1) * l);\n  mj = carre(xb1);\n  MJ = carre(xb2);\n  Ii += (xb2 - xb1) * mj;\n  Is += (xb2 - xb1) * MJ;\n  printf(\"end of loop %d \\n\", comptor++);\n}\n\n", "pragma": "omp parallel for reduction(+:Ii) reduction(+:Is)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/exercices/integral_parallel/0"}
{"code": "for (int i = 1; i < 100; i++)\n{\n  {\n    var[i] = var[i - 1] + 1;\n  }\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB155-missingordered-orig-gpu-no/0"}
{"code": "for (int jj = 1; jj < (params.nx - 1); ++jj)\n{\n  sendbuf[((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)] = cells[(line * params.nx) + jj].speeds[7];\n  sendbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 1] = cells[(line * params.nx) + jj].speeds[4];\n  sendbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 2] = cells[(line * params.nx) + jj].speeds[8];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/15"}
{"code": "for (i = 0; i < 1000000000; i++)\n  sum += a[i];\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/sum_and_dot_product/sum_multi_thread_reduction_sum/0"}
{"code": "for (i = 1; i < slices; i++)\n{\n  for (int j = 1; j < (tasksize + 1); j++)\n  {\n    tempCrow[(i * tasksize) + j] += temp_row_sum;\n  }\n\n  temp_row_sum = tempCrow[(i + 1) * tasksize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/old/SpGEMM_mpi_omp/8"}
{"code": "for (int i = 0; i < nSegments; i++)\n{\n  ((((cout << \"segments[\") << i) << \"] = \\\"\") << segments[i]) << \"\\\"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/Bucket/3"}
{"code": "for (unsigned int i = 0; i < number_of_actuators; i++)\n{\n  mDeltaDisplacement(i, mActuatorCounter) = delta_displacement[i];\n  mDeltaReactionStress(i, mActuatorCounter) = delta_reaction_stress[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/multiaxial_control_module_generalized_2d_utilities/6"}
{"code": "for (int i = 0; i < ArraySize; ++i)\n{\n  if (max < min[i])\n    max = min[i];\n\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Smirnov-Mikhail/OpenMP/Task4/Task4/Task4/3"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[2 * (i + (mxv * j))] = fxy[2 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (2 * (i + (mxv * j)))] = fxy[1 + (2 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nn = 2 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dx = amy * ((dxp * sfxy[nn + 2]) + dx);\n    dy = amy * ((dxp * sfxy[nn + 3]) + dy);\n    nn += 2 * mxv;\n    vx = amx * sfxy[nn];\n    vy = amx * sfxy[nn + 1];\n    dx += dyp * ((dxp * sfxy[nn + 2]) + vx);\n    dy += dyp * ((dxp * sfxy[nn + 3]) + vy);\n    dxp = ppart[(j + (2 * nppmx)) + npoff];\n    dyp = ppart[(j + (3 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    dxp += vx;\n    dyp += vy;\n    sum1 += (dxp * dxp) + (dyp * dyp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,x,y,dxp,dyp,amx,amy,dx,dy,vx, vy,sum1,sfxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/0"}
{"code": "for (j = 0; j < 25; j++)\n{\n  for (i = 0; i < 5; i++)\n  {\n    tag_new[(j * 5) + i].newtempx1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempx1_2D_25_5) + (tag_h[5 + i].hprimewgll_xxT * utemp[(j * 5) + 1].tempx1_2D_25_5)) + (tag_h[10 + i].hprimewgll_xxT * utemp[(j * 5) + 2].tempx1_2D_25_5)) + (tag_h[15 + i].hprimewgll_xxT * utemp[(j * 5) + 3].tempx1_2D_25_5)) + (tag_h[20 + i].hprimewgll_xxT * utemp[(j * 5) + 4].tempx1_2D_25_5);\n    tag_new[(j * 5) + i].newtempy1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempy1_2D_25_5) + (tag_h[i + 5].hprimewgll_xxT * utemp[(j * 5) + 1].tempy1_2D_25_5)) + (tag_h[i + 10].hprimewgll_xxT * utemp[(j * 5) + 2].tempy1_2D_25_5)) + (tag_h[i + 15].hprimewgll_xxT * utemp[(j * 5) + 3].tempy1_2D_25_5)) + (tag_h[i + 20].hprimewgll_xxT * utemp[(j * 5) + 4].tempy1_2D_25_5);\n    tag_new[(j * 5) + i].newtempz1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempz1_2D_25_5) + (tag_h[i + 5].hprimewgll_xxT * utemp[(j * 5) + 1].tempz1_2D_25_5)) + (tag_h[i + 10].hprimewgll_xxT * utemp[(j * 5) + 2].tempz1_2D_25_5)) + (tag_h[i + 15].hprimewgll_xxT * utemp[(j * 5) + 3].tempz1_2D_25_5)) + (tag_h[i + 20].hprimewgll_xxT * utemp[(j * 5) + 4].tempz1_2D_25_5);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/specfem3d/aos-omp-for/specfem3D-omp-for/7"}
{"code": "for (j = 1; j < (o.n - 1); ++j)\n{\n  eqn = ((u[j - 1] - (2 * u[j])) + u[j + 1]) + ((o.dx * o.dx) * rho[j]);\n  res += sqrt(eqn * eqn);\n}\n\n", "pragma": "omp parallel for default(none) shared(u,rho,o) private(j,eqn) reduction(+:res)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex8-poisson-openmp/3"}
{"code": "for (int r = 0; r < N; r++)\n{\n  for (int c = 0; c < N; c++)\n  {\n    if (grid1[r][c] > 0)\n    {\n      if (grid[r][c] <= 0)\n      {\n        destroyed_CTs++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:destroyed_CTs)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CI4822-EneMar2020/BombingField/src/3"}
{"code": "for (i = 0; i < t; i++)\n  if (i < pos[i])\n  swap(x[i], x[pos[i]]);\n\n\n", "pragma": "    #pragma omp parallel for shared(x,pos)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  a = i + 1;\n  n = n - 1;\n  printf(\"n= %d\\n\", n);\n  printf(\"Thread number %d\\t has  value of a =%d\\t for i=%d\\n\", omp_get_thread_num(), a, i);\n}\n\n", "pragma": "omp parallel for private(i) firstprivate(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/private/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  if (i == 0)\n  {\n    fprintf(logFile, \"Thread nr %d entering for loop and going to sleep.\\n\", rank);\n    my_sleep(0.01);\n    count = 1;\n    fprintf(logFile, \"Thread nr %d woke up and set count = 1.\\n\", rank);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_nowait/0"}
{"code": "for (j = 0; j < 4; j++)\n{\n  avgtime[j] = avgtime[j] / ((double) (NTIMES - 1));\n  printf(\"%s%12.1f  %11.6f  %11.6f  %11.6f\\n\", label[j], (1.0E-06 * bytes[j]) / mintime[j], avgtime[j], mintime[j], maxtime[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/14"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i += 1)\n{\n  for (j = 0; j <= (grid_points[1] - 1); j += 1)\n  {\n    for (k = 0; k <= (grid_points[2] - 1); k += 1)\n    {\n      rho_inv = 1.0 / u[i][j][k][0];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[i][j][k][1] * rho_inv;\n      vs[i][j][k] = u[i][j][k][2] * rho_inv;\n      ws[i][j][k] = u[i][j][k][3] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (rho_inv,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/68"}
{"code": "for (i = 0; i < max_threads; i++)\n{\n  CvMemStorage * temp_storage_thread;\n  CV_CALL(temp_storage_thread = cvCreateMemStorage(0));\n  CV_CALL(seq_thread[i] = cvCreateSeq(0, sizeof(CvSeq), sizeof(CvRect), temp_storage_thread));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvhaar/4"}
{"code": "for (int i = 0; i < VERTEX_COUNT; i++)\n{\n  vertices[i] = (i) ? (-1) : (0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  _temp = i;\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for reduction (+:sum) private(_temp)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arghasarkar/high-performance-computing/deqn/src/Test/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/132"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    averageColor = computeAverage(i, j);\n    if (isMatchFound(i, j + (smallImageWidth - 1)) || isMatchFound(i, j))\n    {\n      continue;\n    }\n\n    if (maskImageFound(i, j, averageColor))\n    {\n      matcher.push_back(i);\n      matcher.push_back(j);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aksha/Breast-Tumor-Detection/ravicha_ImageSearch/5"}
{"code": "for (int i = 0; i < char_offset; i++)\n  printf(\"%c\", chrs[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/10"}
{"code": "for (int i = 0; i < nel; i++)\n{\n  file >> h_areas[i];\n  for (int j = 0; j < NNB; j++)\n  {\n    file >> h_elements_surrounding_elements[i + (j * nelr)];\n    if (h_elements_surrounding_elements[i + (j * nelr)] < 0)\n      h_elements_surrounding_elements[i + (j * nelr)] = -1;\n\n    h_elements_surrounding_elements[i + (j * nelr)]--;\n    for (int k = 0; k < NDIM; k++)\n    {\n      file >> h_normals[i + ((j + (k * NNB)) * nelr)];\n      h_normals[i + ((j + (k * NNB)) * nelr)] = -h_normals[i + ((j + (k * NNB)) * nelr)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cfd-omp/euler3d/6"}
{"code": "for (i = k; i < len2; i++)\n  score = score + scoringMatrix[i][(i + n) + 1];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/calculations/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"thread = %d, i = %2d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajingu/OpenMPTutorial/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = 0.0;\n  mc = m - (m % 4);\n  if (m >= 4)\n  {\n    for (j = 0; j < mc; j += 4)\n    {\n      c[i] += ((alpha * A[i + (j * n)]) * b[j]) + (beta * c[i]);\n      c[i] += ((alpha * A[i + ((j + 1) * n)]) * b[j + 1]) + (beta * c[i]);\n      c[i] += ((alpha * A[i + ((j + 2) * n)]) * b[j + 2]) + (beta * c[i]);\n      c[i] += ((alpha * A[i + ((j + 3) * n)]) * b[j + 3]) + (beta * c[i]);\n    }\n\n    if (mc != m)\n    {\n      for (i = mc; i < m; i++)\n      {\n        c[i] += ((alpha * A[i + (j * n)]) * b[j]) + (beta * c[i]);\n      }\n\n    }\n\n  }\n  else\n  {\n    for (j = 0; j < m; j++)\n    {\n      c[i] += ((alpha * A[i + (j * n)]) * b[j]) + (beta * c[i]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i, j) shared(c, A, b, n, m, mc, alpha, beta)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/1"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  double r = x[i];\n  s1_np1_res[i] = 0;\n  s2_np1_res[i] = 0;\n  V_np1_res[i] = ((((V_np1[i + 1] - V_np1[i - 1]) / (r * dr)) + (((V_np1[i + 1] - (2 * V_np1[i])) + V_np1[i - 1]) / (dr * dr))) - (s1_np1[i] * s1_np1[i])) - (s2_np1[i] * s2_np1[i]);\n  s1_n_res[i] = 0;\n  s2_n_res[i] = 0;\n  V_n_res[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/18"}
{"code": "for (i = 0; i < 9; i++)\n  if (tabla[x][i] == z)\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AleixMT/Massive-Parallel-Computing/OpenMP/P1.2/P1.2_CPM_MarineRuiz/1"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    printf(\"%d %d\\n\", a[i][j], b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB113-default-orig-no/4"}
{"code": "for (t = 0; t < NT; t++)\n{\n  U = totalPotentialEnergy();\n  K = totalKineticEnergy();\n  if ((t % NPRINT) == 0)\n  {\n    ((cout << \"===================================================\") << endl) << endl;\n    (((cout << \" \tCELL overdamped dynamics with RK4, t = \") << t) << endl) << endl;\n    (cout << \"===================================================\") << endl;\n    if (packingPrintObject.is_open())\n    {\n      (cout << \"\t* Printing vetex positions to file\") << endl;\n      printSystemPositions();\n    }\n\n    if (energyPrintObject.is_open())\n    {\n      (cout << \"\t* Printing cell energy to file\") << endl;\n      printSystemEnergy();\n    }\n\n    (cout << \"\t* Run data:\") << endl;\n    ((cout << \"\t* U \t\t= \") << U) << endl;\n    ((cout << \"\t* K \t\t= \") << K) << endl;\n    ((cout << \"\t* E \t\t= \") << (U + K)) << endl;\n    ((cout << \"\t* Nvv \t\t= \") << Nvv) << endl;\n    ((cout << \"\t* Ncc \t\t= \") << Ncc) << endl;\n    (cout << endl) << endl;\n  }\n\n  for (ci = 0; ci < NCELLS; ci++)\n  {\n    for (vi = 0; vi < cell(ci).getNV(); vi++)\n    {\n      for (d = 0; d < NDIM; d++)\n      {\n        cell(ci).setVForce(vi, d, 0.0);\n        cell(ci).setUInt(vi, 0.0);\n      }\n\n    }\n\n  }\n\n  resetContacts();\n  cellRK4();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/51"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  (((cout << \"rho species \") << i) << \" = \") << rhoINIT[i];\n  if (DriftSpecies[i])\n    (cout << \" DRIFTING \") << endl;\n  else\n    (cout << \" BACKGROUND \") << endl;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/59"}
{"code": "for (int i = 0; i < nBins; i++)\n  f[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/5"}
{"code": "for (unsigned int i = 0; i < kClusters.size(); i++)\n{\n  (((((myfile << kClusters.at(i).getX()) << \"\\t\") << kClusters.at(i).getY()) << \"\\t\") << (-1)) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicholasfresneda/kmeans/openmp_impl/Cluster/1"}
{"code": "for (i = 0; i <= (length - 1); i += 1)\n{\n  index = zoneset[i];\n  if (eps[zoneset[i]] > eps_failure_model)\n  {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n    newSzz[i] = 0.0;\n    newTxy[i] = 0.0;\n    newTxz[i] = 0.0;\n    newTyz[i] = 0.0;\n    eps[zoneset[i]] = eps_failure_model * 1.01;\n  }\n\n}\n\n", "pragma": "omp parallel for private (index,i) firstprivate (eps_failure_model,length)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_Stress-1/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      eta = ((double) j) * dnym1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[j][m] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[j][m] = dtpp * dtemp[m];\n      }\n\n      cuf[j] = buf[j][2] * buf[j][2];\n      buf[j][0] = (cuf[j] + (buf[j][1] * buf[j][1])) + (buf[j][3] * buf[j][3]);\n      q[j] = 0.5 * (((buf[j][1] * ue[j][1]) + (buf[j][2] * ue[j][2])) + (buf[j][3] * ue[j][3]));\n    }\n\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      jm1 = j - 1;\n      jp1 = j + 1;\n      forcing[k][j][i][0] = (forcing[k][j][i][0] - (ty2 * (ue[jp1][2] - ue[jm1][2]))) + (dy1ty1 * ((ue[jp1][0] - (2.0 * ue[j][0])) + ue[jm1][0]));\n      forcing[k][j][i][1] = ((forcing[k][j][i][1] - (ty2 * ((ue[jp1][1] * buf[jp1][2]) - (ue[jm1][1] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][1] - (2.0 * buf[j][1])) + buf[jm1][1]))) + (dy2ty1 * ((ue[jp1][1] - (2.0 * ue[j][1])) + ue[jm1][1]));\n      forcing[k][j][i][2] = ((forcing[k][j][i][2] - (ty2 * (((ue[jp1][2] * buf[jp1][2]) + (c2 * (ue[jp1][4] - q[jp1]))) - ((ue[jm1][2] * buf[jm1][2]) + (c2 * (ue[jm1][4] - q[jm1])))))) + (yycon1 * ((buf[jp1][2] - (2.0 * buf[j][2])) + buf[jm1][2]))) + (dy3ty1 * ((ue[jp1][2] - (2.0 * ue[j][2])) + ue[jm1][2]));\n      forcing[k][j][i][3] = ((forcing[k][j][i][3] - (ty2 * ((ue[jp1][3] * buf[jp1][2]) - (ue[jm1][3] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][3] - (2.0 * buf[j][3])) + buf[jm1][3]))) + (dy4ty1 * ((ue[jp1][3] - (2.0 * ue[j][3])) + ue[jm1][3]));\n      forcing[k][j][i][4] = ((((forcing[k][j][i][4] - (ty2 * ((buf[jp1][2] * ((c1 * ue[jp1][4]) - (c2 * q[jp1]))) - (buf[jm1][2] * ((c1 * ue[jm1][4]) - (c2 * q[jm1])))))) + ((0.5 * yycon3) * ((buf[jp1][0] - (2.0 * buf[j][0])) + buf[jm1][0]))) + (yycon4 * ((cuf[jp1] - (2.0 * cuf[j])) + cuf[jm1]))) + (yycon5 * ((buf[jp1][4] - (2.0 * buf[j][4])) + buf[jm1][4]))) + (dy5ty1 * ((ue[jp1][4] - (2.0 * ue[j][4])) + ue[jm1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = 1;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((5.0 * ue[j][m]) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n      j = 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((((-4.0) * ue[j - 1][m]) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n    }\n\n    for (j = 3; j <= (grid_points[1] - 4); j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = grid_points[1] - 3;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])));\n      j = grid_points[1] - 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (5.0 * ue[j][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/exact_rhs/2"}
{"code": "for (int i = 0; i < uvSize; i++)\n{\n  int v = unvisited[i];\n  if (distance[v] < 0)\n  {\n    for (int j = row_inv[v]; j < row_inv[v + 1]; j++)\n    {\n      int u = col_inv[j];\n      if (distance[u] == level)\n      {\n        distance[v] = level + 1;\n        nf++;\n        improvement = true;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:nf) reduction(||:improvement) schedule(guided, 32)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/hybrid/2"}
{"code": "for (unsigned int i = 0; i < dim; i++)\n{\n  if (info[2] == 0)\n  {\n    buf[i] = get(matrix_parts[0], dim, i, info[1]);\n  }\n  else\n    if (info[3] == 0)\n  {\n    buf[i] = matrix_parts[info[2]][(info[1] * col) + i];\n  }\n  else\n    if (info[3] == 1)\n  {\n    buf[i] = matrix_parts[info[2]][(col * i) + info[1]];\n  }\n  else\n  {\n    ((cerr << \"Errore: codice info[3] = \") << info[3]) << endl;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/6"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  for (iside = 0; iside < NSIDES; iside++)\n  {\n    if (cbc[iel][iside] == 3)\n    {\n      sizei = size_e[iel];\n      imor = idmo[iel][iside][0][0][0][0];\n      if (!ifpcmor[imor])\n      {\n        pc_corner(imor);\n        ifpcmor[imor] = 1;\n      }\n\n      imor = idmo[iel][iside][1][0][0][LX1 - 1];\n      if (!ifpcmor[imor])\n      {\n        pc_corner(imor);\n        ifpcmor[imor] = 1;\n      }\n\n      imor = idmo[iel][iside][0][1][LX1 - 1][0];\n      if (!ifpcmor[imor])\n      {\n        pc_corner(imor);\n        ifpcmor[imor] = 1;\n      }\n\n      imor = idmo[iel][iside][1][1][LX1 - 1][LX1 - 1];\n      if (!ifpcmor[imor])\n      {\n        pc_corner(imor);\n        ifpcmor[imor] = 1;\n      }\n\n      for (_enum = 0; _enum < 4; _enum++)\n      {\n        if (!edgevis[iel][iside][_enum])\n        {\n          edgevis[iel][iside][_enum] = 1;\n          face2 = f_e_ef[iside][_enum];\n          if (cbc[iel][face2] == 2)\n          {\n            nb1 = sje[iel][face2][0][0];\n            if (cbc[nb1][iside] == 2)\n            {\n              com_dpc(iside, iel, _enum, 1, sizei);\n              nb2 = sje[nb1][iside][0][0];\n              edgevis[nb2][jjface[face2]][op[e_face2[iside][_enum]]] = 1;\n            }\n            else\n              if (cbc[nb1][iside] == 3)\n            {\n              com_dpc(iside, iel, _enum, 2, sizei);\n              edgevis[nb1][iside][op[_enum]] = 1;\n            }\n\n\n          }\n          else\n            if (cbc[iel][face2] == 3)\n          {\n            edgevis[iel][face2][e_face2[iside][_enum]] = 1;\n            nb1 = sje[iel][face2][1][0];\n            if (cbc[nb1][iside] == 1)\n            {\n              com_dpc(iside, iel, _enum, 3, sizei);\n              nb2 = sje[nb1][iside][0][0];\n              edgevis[nb2][jjface[iside]][op[_enum]] = 1;\n              edgevis[nb2][jjface[face2]][op[e_face2[iside][_enum]]] = 1;\n            }\n            else\n              if (cbc[nb1][iside] == 2)\n            {\n              com_dpc(iside, iel, _enum, 4, sizei);\n            }\n\n\n          }\n          else\n            if (cbc[iel][face2] == 0)\n          {\n            com_dpc(iside, iel, _enum, 0, sizei);\n          }\n\n\n\n        }\n\n      }\n\n      for (nn1 = 0; nn1 < 2; nn1++)\n      {\n        for (nn2 = 0; nn2 < 2; nn2++)\n        {\n          for (j = 1; j < (LX1 - 1); j++)\n          {\n            for (i = 1; i < (LX1 - 1); i++)\n            {\n              imor = idmo[iel][iside][nn2][nn1][j][i];\n              dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][nn2][nn1][j][i] + pcmor_c[sizei + 1][j][i]);\n            }\n\n          }\n\n        }\n\n      }\n\n      i = LX1 - 1;\n      for (j = 1; j < (LX1 - 1); j++)\n      {\n        imor = idmo[iel][iside][0][0][j][i];\n        dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][0][0][j][i] + (pcmor_c[sizei + 1][j][i] * 2.0));\n        imor = idmo[iel][iside][0][1][j][i];\n        dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][0][1][j][i] + (pcmor_c[sizei + 1][j][i] * 2.0));\n      }\n\n      j = LX1 - 1;\n      imor = idmo[iel][iside][0][0][j][i];\n      dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][0][0][j][i] + (pcmor_c[sizei + 1][j][i] * 4.0));\n      for (i = 1; i < (LX1 - 1); i++)\n      {\n        imor = idmo[iel][iside][0][0][j][i];\n        dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][0][0][j][i] + (pcmor_c[sizei + 1][j][i] * 2.0));\n        imor = idmo[iel][iside][1][0][j][i];\n        dpcmor[imor] = 1.0 / (pcmor_nc1[sizei][1][0][j][i] + (pcmor_c[sizei + 1][j][i] * 2.0));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(iel,iside,sizei, imor,_enum,face2,nb1,nb2,i,j,nn1,nn2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/precond/5"}
{"code": "for (i = 0; i < NX; i++)\n{\n  for (j = 0; j < NY; j++)\n  {\n    ex[(i * NY) + j] = ((((DATA_TYPE) i) * (j + 1)) + 1) / NX;\n    ey[(i * NY) + j] = ((((DATA_TYPE) (i - 1)) * (j + 2)) + 2) / NX;\n    hz[(i * NY) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / NX;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/5"}
{"code": "for (int k = 1; k < dims[2]; k++)\n{\n  randlc(&start, an);\n  starts[k] = start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/6"}
{"code": "for (int ii = 2; ii < params.ly; ++ii)\n{\n  for (int jj = 1; jj < (params.lx + 1); jj += params.lx - 1)\n  {\n    if (!obstacles[((ii - 1) * params.lx) + (jj - 1)])\n    {\n      float tmp_speeds[9];\n      tmp_speeds[0] = cells[(ii * params.nx) + jj].speeds[0];\n      tmp_speeds[1] = cells[(ii * params.nx) + jj].speeds[3];\n      tmp_speeds[2] = cells[(ii * params.nx) + jj].speeds[4];\n      tmp_speeds[3] = cells[(ii * params.nx) + jj].speeds[1];\n      tmp_speeds[4] = cells[(ii * params.nx) + jj].speeds[2];\n      tmp_speeds[5] = cells[(ii * params.nx) + jj].speeds[7];\n      tmp_speeds[6] = cells[(ii * params.nx) + jj].speeds[8];\n      tmp_speeds[7] = cells[(ii * params.nx) + jj].speeds[5];\n      tmp_speeds[8] = cells[(ii * params.nx) + jj].speeds[6];\n      float local_density = 0.0f;\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        local_density += tmp_speeds[kk];\n      }\n\n      float u_x = ((((((+tmp_speeds[1]) + tmp_speeds[5]) + tmp_speeds[8]) - tmp_speeds[3]) - tmp_speeds[6]) - tmp_speeds[7]) / local_density;\n      float u_y = ((((((+tmp_speeds[2]) + tmp_speeds[5]) + tmp_speeds[6]) - tmp_speeds[4]) - tmp_speeds[7]) - tmp_speeds[8]) / local_density;\n      float u_sq = (u_x * u_x) + (u_y * u_y);\n      float d_equ[9];\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        float u_kk = (u[kk][0] * u_x) + (u[kk][1] * u_y);\n        d_equ[kk] = ((w[kk] * params.omega) * local_density) * (((1.0f + (3.0f * u_kk)) + ((4.5f * u_kk) * u_kk)) - (1.5f * u_sq));\n      }\n\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        cells[(ii * params.nx) + jj].speeds[kk] = ((1.0f - params.omega) * tmp_speeds[kk]) + d_equ[kk];\n      }\n\n      tot_u += sqrtf((u_x * u_x) + (u_y * u_y));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/33"}
{"code": "for (int i = 0; i < n; i++)\n{\n  while (thread != omp_get_thread_num())\n  {\n  }\n\n  printf(\"%d, \", omp_get_thread_num());\n  thread--;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task13/0"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  inText[i] = subByte(inText[i]);\n}\n\n", "pragma": "\t#pragma omp for ordered schedule(static,1)\t\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/6"}
{"code": "for (step = 1; step <= n_steps; step++)\n{\n  t = step * delta_t;\n  for (part = 0; part < n; part++)\n    Compute_force(part, forces, curr, n);\n\n  for (part = 0; part < n; part++)\n    Update_part(part, forces, curr, n, delta_t);\n\n  if ((step % output_freq) == 0)\n    Output_state(t, curr, n);\n\n}\n\n", "pragma": "omp parallel num_threads(thread_count) default(none) shared(curr, forces, thread_count, delta_t, n, n_steps, output_freq) private(step, part, t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/0"}
{"code": "for (i = 0; i < targetArrayCount; ++i)\n  for (int j = 0; j < NUM_THREADS; ++j)\n  isPrimeNumber[i] = isPrimeNumber[i] && privPrimes[j][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/6"}
{"code": "for (int i = startingIndex; i < endingIndex; ++i)\n{\n  for (int j = 0; j < (matrisColumnLength + 1); ++j)\n  {\n    if (M[startingIndex][j] > tempBiggest)\n    {\n      tempBiggest = M[startingIndex][j];\n      tempBiggests[threadId] = tempBiggest;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fatihazir/OpenMP-Maximum-Value-Of-2d-Matris/MaxValueOfMatris/0"}
{"code": "for (i = 0; i < prim2.dim; ++i)\n  for (j = 0; j < prim2.dim; j++)\n{\n  prim2.edge[i][j] = (rand() % ((0, 100))) + 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GennadySX/vvrs/lab_3/main/2"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets1252Ptr = _checkInCodelets1252(1, 1, this, codeletCounter);\n  (*checkInCodelets1252Ptr).decDep();\n  checkInCodelets1252Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/51"}
{"code": "for (i = 0; i < ((int) n_b); i++)\n{\n  result[i] = (*a) / b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/26"}
{"code": "for (int i = 0; i < N; i++)\n{\n  processor *p = processors + i;\n  if (p->good)\n    good++;\n\n  if (p->decided && p->good)\n  {\n    if (p->d == 0)\n      no++;\n    else\n      yes++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/byzantine/4"}
{"code": "for (int i = 0; i < size_mat; i++)\n{\n  for (int j = 0; j < size_mat; j++)\n  {\n    _MAT[i][j] = val;\n    val++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SboneloMdluli/ELEN4020-Lab2/OpenMP/block_MP/0"}
{"code": "for (i = 0, pi = 0.0; i < NUM_THREADS; i++)\n  pi += sum[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daramgineer/OpenMP_study/Source/for_loop_compare/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n}\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/cancel-1/6"}
{"code": "for (i = 0; i < 40000000; i++)\n{\n  if ((((data_point[i].x - 0.5) * (data_point[i].x - 0.5)) + ((data_point[i].y - 0.5) * (data_point[i].y - 0.5))) <= 0.25)\n  {\n    num_of_points_in_circle++;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:num_of_points_in_circle)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlie-bennett/pthreads_vs_openmp/p1_omp/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  int u = randperm[i];\n  int v = randperm[i + 1];\n  if (u < v)\n  {\n    adj_matrix[u][v] = 1;\n  }\n  else\n  {\n    adj_matrix[v][u] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/8"}
{"code": "for (int i = 0; i < EXP_NUM; i++)\n{\n  double start = omp_get_wtime();\n  matmul3d_col_p(&A, &B, &C);\n  double end = omp_get_wtime() - start;\n  printf(\"elapsed time : %f exp : %d\\n\", end, i + 1);\n  exp_times_sum += end;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW3/matmul3d/0"}
{"code": "for (int i = 0; i < (n * n); i++)\n{\n  printf(\"%f \", matrix[i]);\n  if (((i + 1) % n) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/15"}
{"code": "for (size_t k = 0; k < n; k++)\n{\n  double sumreal = 0;\n  double sumimag = 0;\n  for (size_t t = 0; t < n; t++)\n  {\n    double angle = (((2 * M_PI) * t) * k) / n;\n    if (inverse)\n      angle = -angle;\n\n    sumreal += (inreal[t] * cos(angle)) + (inimag[t] * sin(angle));\n    sumimag += ((-inreal[t]) * sin(angle)) + (inimag[t] * cos(angle));\n  }\n\n  if (inverse)\n  {\n    outreal[k] = sumreal / n;\n    outimag[k] = sumimag / n;\n  }\n  else\n  {\n    outreal[k] = sumreal;\n    outimag[k] = sumimag;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for  simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_dft/c3_1/dft/0"}
{"code": "for (i = 0; i < 20480; i++)\n{\n  x[i] = i * M_PI;\n  for (j = 0; j < 20480; j++)\n  {\n    A[(i * 20480) + j] = (((DATA_TYPE) i) * j) / 20480;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (a[i] * b[i]);\n  printf(\"iteration number %d\\n\", i);\n  printf(\"result = %f\\t tid=%d\\t\", result, omp_get_thread_num());\n  printf(\" a[i] = %f\\t\", a[i]);\n  printf(\"b[i]= %f\\n\\n\", b[i]);\n}\n\n", "pragma": "omp parallel for default(shared) schedule(static,chunk) reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/shared/0"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (i = 0; i <= (grid_points[0] - 1); i++)\n  {\n    xi = ((double) i) * dnxm1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][j][i][m] = temp[m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/initialize/3"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = ls_image; j < dim_image; j++)\n  {\n    int ii;\n    int jj;\n    int acumulador = 0;\n    int num = 0;\n    for (int m = 0; m < 5; m++)\n    {\n      int *krow = kernel[m];\n      ii = i + (m - 2);\n      int *irow = image[ii];\n      for (int n = 0; n < 5; n++)\n      {\n        jj = j + (n - 2);\n        if ((ii >= 0) && (jj < dim_image))\n        {\n          acumulador += krow[n] * irow[jj];\n          num++;\n        }\n\n      }\n\n    }\n\n    result[i][j] = acumulador / num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/ConvolutionOpenMP/convolucion/8"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  v1 = _mm_load_ps(&x[i]);\n  res = _mm_dp_ps(v1, v1, 0xFF);\n  _mm_store_ps(tmp, res);\n  nrm += tmp[0];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:nrm) reduction(+:tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/nrm2/2"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    printf(\"%d \", matriz_A[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/matriz_openmp/1"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  valeurs[16 * i] = alpha;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_v2/5"}
{"code": "for (i = 0; i < cs.ctlen; i++)\n  cs.ciphertext[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/andotp_fmt_plug/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"%d, \", A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/grandma-tutorial/OpenMP-tutorial/Worksharing/example_worksharing_1/1"}
{"code": "for (int p = 0; p < itt; p++)\n  Avg += AvgM();\n\n", "pragma": "\t#pragma omp parallel for reduction(+:Avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/k21226/omptst/main/1"}
{"code": "for (int i = binf; i < bsup; i++)\n{\n  b[i] = PRF(i, seed);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP/cg/5"}
{"code": "for (i = 0; i < 5; i++)\n  substr[i] = *((record.recString + i) + 28);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/nn/nn_omp/3"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n    matC[i][j] += matA[i][j] * matB[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/6"}
{"code": "for (i = 0; i < arrayLength; i++)\n{\n  array[i] = (rand() % arrayLength) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/axell-brendow/seminars-ii/Trabalho Paralelismo/Quicksort/6"}
{"code": "for (int j = 0; j <= n; j++)\n  C[indexOf(0, j)] = 0;\n\n", "pragma": "  #pragma omp for schedule(runtime) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shiva49814/OpenMPTasks/LCS/3"}
{"code": "for (int i = 0; i < row_size; i++)\n{\n  for (int j = 0; j < col_size; j++)\n  {\n    char status = (game_board[i][j]) ? ('1') : ('0');\n    printf(\"%c \", status);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment3/game-of-life/openmp/GameOfLife/5"}
{"code": "for (j = 0; j < VERYBIG; j++)\n{\n  sum += 1;\n  sumx = 0.0;\n  for (k = 0; k < j; k++)\n    sumx = sumx + ((double) k);\n\n  sumy = 0.0;\n  for (k = j; k > 0; k--)\n    sumy = sumy + ((double) k);\n\n  if (sumx > 0.0)\n  {\n    total = total + (1.0 / sqrt(sumx));\n  }\n\n  if (sumy > 0.0)\n  {\n    total = total + (1.0 / sqrt(sumy));\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/Lab1/Lab-1-1/0"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd4 * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxhs; i += 2)\n      {\n        v_t1 = _mm512_load_ps((float *) (&f[(4 * i) + i1]));\n        v_t2 = _mm512_load_ps((float *) (&f[(4 * i) + i0]));\n        _mm512_store_ps((float *) (&f[(4 * i) + i1]), v_t2);\n        _mm512_store_ps((float *) (&f[(4 * i) + i0]), v_t1);\n      }\n\n      for (i = nxhs; i < nxh; i++)\n      {\n        t1 = f[(4 * i) + i1];\n        t2 = f[(1 + (4 * i)) + i1];\n        t3 = f[(2 + (4 * i)) + i1];\n        f[(4 * i) + i1] = f[(4 * i) + i0];\n        f[(1 + (4 * i)) + i1] = f[(1 + (4 * i)) + i0];\n        f[(2 + (4 * i)) + i1] = f[(2 + (4 * i)) + i0];\n        f[(4 * i) + i0] = t1;\n        f[(1 + (4 * i)) + i0] = t2;\n        f[(2 + (4 * i)) + i0] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = conjf(sct[kmr * j]);\n        v_t1 = _mm512_set4_ps(cimagf(t1), crealf(t1), cimagf(t1), crealf(t1));\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxhs; i += 2)\n        {\n          v_t2 = _mm512_load_ps((float *) (&f[(4 * i) + i1]));\n          v_t3 = (int) _mm512_shuffle_epi32((int) v_t1, 160);\n          v_t3 = _mm512_mul_ps(v_t2, v_t3);\n          v_t2 = (int) _mm512_shuffle_epi32((int) v_t2, 177);\n          v_t4 = (int) _mm512_shuffle_epi32((int) v_t1, 245);\n          v_t4 = _mm512_mul_ps(v_t2, v_t4);\n          v_t4 = _mm512_mask_sub_ps(v_t4, _mm512_int2mask(21845), v_zero, v_t4);\n          v_t2 = _mm512_add_ps(v_t3, v_t4);\n          v_t3 = _mm512_load_ps((float *) (&f[(4 * i) + i0]));\n          v_t4 = _mm512_sub_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[(4 * i) + i1]), v_t4);\n          v_t4 = _mm512_add_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[(4 * i) + i0]), v_t4);\n        }\n\n        for (i = nxhs; i < nxh; i++)\n        {\n          t2 = t1 * f[(4 * i) + i1];\n          t3 = t1 * f[(1 + (4 * i)) + i1];\n          t4 = t1 * f[(2 + (4 * i)) + i1];\n          f[(4 * i) + i1] = f[(4 * i) + i0] - t2;\n          f[(1 + (4 * i)) + i1] = f[(1 + (4 * i)) + i0] - t3;\n          f[(2 + (4 * i)) + i1] = f[(2 + (4 * i)) + i0] - t4;\n          f[(4 * i) + i0] += t2;\n          f[(1 + (4 * i)) + i0] += t3;\n          f[(2 + (4 * i)) + i0] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2,t3, t4,v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/34"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d \", a2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/22"}
{"code": "for (f = 0; f < N; f++)\n{\n  suma = 0;\n  for (c = 0; c < N; c++)\n    suma += M[f][c] * v1[c];\n\n  v2[f] = suma;\n}\n\n", "pragma": "omp parallel for private(suma)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica2/src/pmv-OpenMP-a/2"}
{"code": "for (int k = 0; k < 100; k++)\n{\n  n = k;\n  a[k] = n;\n}\n\n", "pragma": "omp target parallel for simd private(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-parallel-for-simd-clauses/test/4"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  C[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/runDirectedMultiPhaseBasic/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = 0;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], hydro_data->r2[i]);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, position_phi);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/18"}
{"code": "for (i_imopVarPre79 = ist; i_imopVarPre79 <= iend; i_imopVarPre79++)\n{\n  for (j_imopVarPre80 = jst; j_imopVarPre80 <= jend; j_imopVarPre80++)\n  {\n    for (k_imopVarPre81 = 0; k_imopVarPre81 <= (nz - 1); k_imopVarPre81++)\n    {\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3];\n      u41 = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      q = (0.50 * (((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1]) + (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2])) + (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3]))) / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] * u41;\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] * u41;\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] * u41) + (0.40e+00 * (u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] - q));\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = ((1.40e+00 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4]) - (0.40e+00 * q)) * u41;\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 2); k_imopVarPre81++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (tz2 * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][m_imopVarPre82] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][m_imopVarPre82]));\n      }\n\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 1); k_imopVarPre81++)\n    {\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0];\n      u21k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1];\n      u31k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2];\n      u41k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3];\n      u51k = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4];\n      tmp_imopVarPre83 = 1.0 / u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][0];\n      u21km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][1];\n      u31km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][2];\n      u41km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][3];\n      u51km1 = tmp_imopVarPre83 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][4];\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = tz3 * (u21k - u21km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = tz3 * (u31k - u31km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((1.40e+00 * 1.40e+00) * tz3) * (u51k - u51km1));\n    }\n\n    for (k_imopVarPre81 = 1; k_imopVarPre81 <= (nz - 2); k_imopVarPre81++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0] + ((dz1 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][0] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][0])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][0]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][1] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1]))) + ((dz2 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][1] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][1])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][1]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][2] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2]))) + ((dz3 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][2] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][2])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][2]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][3] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3]))) + ((dz4 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][3] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][3])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][3]));\n      rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] = (rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][4] - flux[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4]))) + ((dz5 * tz1) * ((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][4] - (2.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][4])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][4]));\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82] - (dssp * ((((+5.0) * u[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82]) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][3][m_imopVarPre82]));\n      rsd[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82] - (dssp * (((((-4.0) * u[i_imopVarPre79][j_imopVarPre80][1][m_imopVarPre82]) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][2][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][3][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][4][m_imopVarPre82]));\n    }\n\n    for (k_imopVarPre81 = 3; k_imopVarPre81 <= (nz - 4); k_imopVarPre81++)\n    {\n      for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n      {\n        rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82] - (dssp * ((((u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 2][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 - 1][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 1][m_imopVarPre82])) + u[i_imopVarPre79][j_imopVarPre80][k_imopVarPre81 + 2][m_imopVarPre82]));\n      }\n\n    }\n\n    for (m_imopVarPre82 = 0; m_imopVarPre82 < 5; m_imopVarPre82++)\n    {\n      rsd[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82] - (dssp * (((u[i_imopVarPre79][j_imopVarPre80][nz - 5][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 4][m_imopVarPre82])) + (6.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82])) - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82])));\n      rsd[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82] = rsd[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82] - (dssp * ((u[i_imopVarPre79][j_imopVarPre80][nz - 4][m_imopVarPre82] - (4.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 3][m_imopVarPre82])) + (5.0 * u[i_imopVarPre79][j_imopVarPre80][nz - 2][m_imopVarPre82])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/19"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  if (weight > delta)\n  {\n    edgesPlusCounter++;\n  }\n  else\n    if (weight <= delta)\n  {\n    edgesMinusCounter++;\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(graph,delta) reduction(+:edgesPlusCounter,edgesMinusCounter)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/31"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    if (count[i])\n    {\n      centroid_p[i].x[j] /= count[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MahmoudAshraf97/OpenMP-KMeans-Clustering/Q1/8"}
{"code": "for (i = 0; i < mDIM; ++i)\n  for (j = 0; j < lDIM; ++j)\n  for (k = 0; k < BSIZE; ++k)\n{\n  currentValue = j * BSIZE;\n  for (y = 0; y < BSIZE; ++y)\n  {\n    if (((i == (mDIM - 1)) && (mDIM > perfectM)) && (k >= leftOutM))\n      tileA[(i * lDIM) + j][(k * BSIZE) + y] = 0.0;\n    else\n      if (((j == (lDIM - 1)) && (lDIM > perfectL)) && (y >= leftOutL))\n      tileA[(i * lDIM) + j][(k * BSIZE) + y] = 0.0;\n    else\n      tileA[(i * lDIM) + j][(k * BSIZE) + y] = ++currentValue;\n\n\n  }\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/3"}
{"code": "for (i = 0; i <= 2; i += 1)\n{\n  xstart[i] = 1;\n  xend[i] = 256;\n  ystart[i] = 1;\n  yend[i] = 256;\n  zstart[i] = 1;\n  zend[i] = 128;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (A[i][i] != 1)\n  {\n    return 0;\n  }\n\n  for (j = 0; j < n; j++)\n  {\n    if ((i != j) && (A[i][j] != 2))\n    {\n      return 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/puneetar/Parallel-LU-Factorization-with-OpenMP-MPI/OpenMP/OpenMP/2"}
{"code": "for (int i = 0; i < N; ++i)\n  sum += arr[i];\n\n", "pragma": "        \t#pragma omp parallel for shared(arr) schedule(static) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pchenik/OpenMP_Tasks/Task6/main/0"}
{"code": "for (int i = 1; i < N; i++)\n  F[i] = nu * (((C[i + 1] / (dL[i] * dL[i])) - (((1.0 / (dL[i] * dL[i])) + (1.0 / (dL[i] * dL[i - 1]))) * C[i])) + (C[i - 1] / (dL[i] * dL[i - 1])));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/93"}
{"code": "for (i = 0; i < (mDIM * nDIM); i++)\n  posix_memalign((float **) (&c[i]), getpagesize(), (BSIZE * BSIZE) * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/9"}
{"code": "for (ii = 0; ii < nzv; ii++)\n{\n  if (iv[ii] == i)\n  {\n    was_gen = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/27"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  if (arr[i] > max)\n  {\n    max = arr[i];\n    maxIndex = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arianhaddadi/Parallel-Programming/OpenMP/main/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp7shp34lq.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sx-aurora-dev/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (int i = 0; i < tempSize; i++)\n{\n  for (int j = 0; j < (tempSize - 1); j++)\n  {\n    if (arr[j] > arr[j + 1])\n    {\n      int temp = arr[j + 1];\n      arr[j + 1] = arr[j];\n      arr[j] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daniMusli/paralelImageFilter/paralel3/3"}
{"code": "for (i = 0; i < idx; i++)\n{\n  x_out_c[i] = xlocal[klocal[i]];\n  y_out_c[i] = ylocal[klocal[i]];\n  h_out_c[i] = hlocal[klocal[i]];\n  k_out_c[i] = klocal[i];\n}\n\n", "pragma": "omp parallel for firstprivate(n,idx)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/5"}
{"code": "for (int l = num_layers - 2; l > 0; l--)\n  layer_gconv[l].backward(layer_gconv[l + 1].get_feat_in(), layer_gconv[l - 1].get_grad_in());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/13"}
{"code": "for (i = 0; i < numDivs; i++)\n{\n  *(reglin + i) = B0 + (B1 * (*(vLL + i)));\n  ajus = *(reglin + i);\n  if (Sel == 0)\n    ei = ajus - (*(vNNMM + i));\n  else\n    ei = ajus - (*((vNNMM + i) + numDivs));\n\n  ei = pow(ei, 2);\n  *(Ei + i) = ei;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/9"}
{"code": "for (i = 0; i < 32; ++i)\n{\n  for (j = 0; j < 32; ++j)\n  {\n    for (k = 0; k < 32; ++k)\n    {\n      A[((i * (32 * 32)) + (j * 32)) + k] = ((i % 12) + (2 * (j % 7))) + (3 * (k % 13));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3DCONV/3DConvolution/15"}
{"code": "for (i = 1; i <= (NA + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/1"}
{"code": "for (i = 0; i < a_fila; i++)\n{\n  for (j = 0; j < a_col; j++)\n  {\n    A[i][j] = i + j;\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule (static, pedazos)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Diegox777/openmp-tests/mat_mult_omp/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  parallel_qsort_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/qsort/2"}
{"code": "for (i = 0; i < nsteps; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apallath/parallel_algos/src/demo_usage/omp_pi/0"}
{"code": "for (int d = 0; d < ndim; d++)\n{\n  ((((((cout << \"axis\") << d) << '\\t') << dims[d]) << '\\t') << nodes[d]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vbugaevskii/msu.supercomputers.course/parallel-hw2-03/parallel-mpi-omp/main/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  j = omp_get_thread_num();\n  printf(\"Iteration %d, by thread %d\\n\", i, j);\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/ompfor-default/0"}
{"code": "for (i = 0; i < ((int) n_rows_a); i++)\n{\n  for (j = 0; j < ((int) n_cols_a); j++)\n  {\n    a[(i * n_cols_a) + j] = rand() / ((data_t) 32767);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i, j) shared(a, n_rows_a, n_cols_a) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/2"}
{"code": "for (int b = 0; b < nbuckets; ++b)\n{\n  int64_t *buffer = &frontier[bucket_sizes[b]];\n  int64_t edge_ptr = 0;\n  ssize_t e_id = sbuckets[b].list_head[support];\n  while (e_id != (-1))\n  {\n    buffer[edge_ptr++] = e_id;\n    e_id = sbuckets[b].slist[e_id].next_eid;\n  }\n\n  sbuckets[b].list_head[support] = -1;\n  sbuckets[b].slist[-1].prev_eid = -1;\n  sbuckets[b].slist[-1].next_eid = -1;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt_sbucket/1"}
{"code": "for (unsigned i = 0; i < n; ++i)\n{\n  max = fmaxf(max, a[i]);\n}\n\n", "pragma": "omp parallel for reduction(max : max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/2"}
{"code": "for (int j = pow(2, l); j < max; j++)\n{\n  climbing->current[j] = climbing->current[2 * j] + climbing->current[(2 * j) + 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/0"}
{"code": "for (int i = 0; i < num_vertices; i++)\n{\n  temp = dijkstra(graph, num_vertices, i);\n  end_time = get_micros();\n  for (int j = 0; j < num_vertices; j++)\n  {\n    result[i][j] = temp[j];\n  }\n\n  total_time += end_time - start_time;\n}\n\n", "pragma": "omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nnadnad/openmp/src/paralel_openmp/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"\\n\\t x(%d) = %.1f \", i + 1, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CaillaRose/OpenMP/threadGauss/4"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++r;\n}\n\n", "pragma": "#pragma omp for reduction(+ : r)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/task_messages/1"}
{"code": "for (iter = 0; iter < max_iter; iter++)\n{\n  MatrixMultVect_SEQ(A, P, multAP);\n  MatrixMultVect_SEQ(At, biP, multAtbiP);\n  numerator = ScalarProduct_SEQ(biR, R, n);\n  denominator = ScalarProduct_SEQ(biP, multAP, n);\n  alpha = numerator / denominator;\n  for (i = 0; i < n; i++)\n  {\n    nR[i] = R[i] - (alpha * multAP[i]);\n  }\n\n  for (i = 0; i < n; i++)\n  {\n    nbiR[i] = biR[i] - (alpha * multAtbiP[i]);\n  }\n\n  denominator = numerator;\n  numerator = ScalarProduct_SEQ(nbiR, nR, n);\n  betta = numerator / denominator;\n  for (i = 0; i < n; i++)\n  {\n    nP[i] = nR[i] + (betta * P[i]);\n  }\n\n  for (i = 0; i < n; i++)\n  {\n    nbiP[i] = nbiR[i] + (betta * biP[i]);\n  }\n\n  check = sqrt(ScalarProduct_SEQ(R, R, n)) / norm;\n  if (check < eps)\n  {\n    break;\n  }\n\n  for (i = 0; i < n; i++)\n  {\n    x[i] += alpha * P[i];\n  }\n\n  tmpPtr = R;\n  R = nR;\n  nR = tmpPtr;\n  tmpPtr = P;\n  P = nP;\n  nP = tmpPtr;\n  tmpPtr = biR;\n  biR = nbiR;\n  nbiR = tmpPtr;\n  tmpPtr = biP;\n  biP = nbiP;\n  nbiP = tmpPtr;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/14"}
{"code": "for (i = 0; i <= m; i++)\n{\n  dp[i][0] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/4"}
{"code": "for (i = 0; i < spreps; i++)\n{\n  D.zeros();\n  assignew = Assign(data_proc, D, P, n, cov_num, strt_num, level_num, omeganew, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  sp(i) = ((-sum(data_proc.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data_proc.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/21"}
{"code": "for (int i = 0; i < 10; ++i)\n  foo();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_parallel_for_ast_print/4"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  nppp = kpic[k];\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = (ky - 1) * mx1;\n  kr = (ky + 1) * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = kxr + kk;\n  ks[1] = kxl + kk;\n  ks[2] = kx + kr;\n  ks[3] = kxr + kr;\n  ks[4] = kxl + kr;\n  ks[5] = kx + kl;\n  ks[6] = kxr + kl;\n  ks[7] = kxl + kl;\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  noff = 0;\n  moff = 0;\n  if (ky == 0)\n  {\n    if (kx > 0)\n      noff = mcll[2 + (3 * (kx - 1))];\n\n  }\n\n  if (ky == (myp1 - 1))\n  {\n    if (kx > 0)\n      moff = mclr[2 + (3 * (kx - 1))];\n\n  }\n\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 8; ii++)\n  {\n    if (ks[ii] < 0)\n    {\n      if (ii > 5)\n        noff = mcll[(ii - 6) + (3 * (ks[ii] + mx1))];\n\n      ip = mcll[(ii - 5) + (3 * (ks[ii] + mx1))] - noff;\n    }\n    else\n      if (ks[ii] >= mxyp1)\n    {\n      if (ii > 2)\n        moff = mclr[(ii - 3) + (3 * (ks[ii] - mxyp1))];\n\n      ip = mclr[(ii - 2) + (3 * (ks[ii] - mxyp1))] - moff;\n    }\n    else\n    {\n      if (ii > 0)\n        ncoff = ncl[(ii - 1) + (8 * ks[ii])];\n\n      ip = ncl[ii + (8 * ks[ii])] - ncoff;\n    }\n\n\n    for (j = 0; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        j1 = nppp;\n        nppp += 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        if (ks[ii] < 0)\n        {\n          for (i = 0; i < idimp; i++)\n          {\n            ppart[i + (idimp * (j1 + (nppmx * k)))] = rbufl[i + (idimp * (j + noff))];\n          }\n\n        }\n        else\n          if (ks[ii] >= mxyp1)\n        {\n          for (i = 0; i < idimp; i++)\n          {\n            ppart[i + (idimp * (j1 + (nppmx * k)))] = rbufr[i + (idimp * (j + moff))];\n          }\n\n        }\n        else\n        {\n          for (i = 0; i < idimp; i++)\n          {\n            ppart[i + (idimp * (j1 + (nppmx * k)))] = ppbuff[i + (idimp * ((j + ncoff) + (npbmx * ks[ii])))];\n          }\n\n        }\n\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    for (j = 0; j < ip; j++)\n    {\n      j1 = (nppp - j) - 1;\n      j2 = ihole[2 * ((nh - j) + ((ntmax + 1) * k))] - 1;\n      if (j1 > j2)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[i + (idimp * (j2 + (nppmx * k)))] = ppart[i + (idimp * (j1 + (nppmx * k)))];\n        }\n\n      }\n\n    }\n\n    nppp -= ip;\n  }\n\n  kpic[k] = nppp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,ii,kk,nppp,kx,ky,kl,kr,kxl,kxr,ih,nh,ncoff,noff,moff, ist,j1,j2,ip,ks)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/10"}
{"code": "for (i = 0; i < total_tosses; i++)\n{\n  drand48_r(&drand_buf, &x);\n  drand48_r(&drand_buf, &y);\n  if (((x * x) + (y * y)) <= 1)\n    total_in_circle++;\n\n}\n\n", "pragma": "omp for reduction(+: total_in_circle)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Monte-Carlo/montecarlo/0"}
{"code": "for (i = 0; i < ((end - start) + 1); i++)\n  for (j = 0; j < input.width; j++)\n{\n  aux[i][j].white_black = buffer[(i * width) + j];\n  aux_copy[i][j].white_black = buffer[(i * width) + j];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/21"}
{"code": "for (ix = 0; ix < Xdots; ix++)\n{\n  for (iy = 0; iy < Ydots; iy++)\n  {\n    pgrid->Values[ix + (iy * Xdots)] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/6"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_nCellsSubbasin[(int) m_subbasin[i]] += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/GW_RSVR/GWaterReservoir/0"}
{"code": "for (i = 0; i < NCA; i++)\n  for (j = 0; j < NCB; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/MatrixMultiply/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  this->vec_[i + dst_offset] = (alpha * this->vec_[i + dst_offset]) + (beta * cast_x->vec_[i + src_offset]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/16"}
{"code": "for (k = ceil(pow(2, d + 1) - 1); k < n; k += (int) ceil(pow(2, d + 1)))\n{\n  x[k] = x[k - ((int) ceil(pow(2, d)))] + x[k];\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TELESIO/OpenMP4.5/example/Prefix Sum/gpu/ps/2"}
{"code": "for (i = 0; i < k; i++)\n{\n  clusters_arr[i].num_of_points = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stefani237/K-MEANS/Initial/func/4"}
{"code": "for (double t = 0; t <= 1; t += dt)\n{\n  tforces -= wtime();\n  calculate_forces(p, f, m, n);\n  tforces += wtime();\n  tmove -= wtime();\n  move_particles(p, f, v, m, n, dt);\n  tmove += wtime();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NievinEvgeny/N-body/parallel-v1/main/2"}
{"code": "for (int i = 10; i > 1; i--)\n{\n  a[k]++;\n  k = k + 3;\n}\n\n", "pragma": "  #pragma omp for simd linear(k : 3) schedule(simd, nonmonotonic: dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/1"}
{"code": "for (int j = 0; j < grid; j++)\n  for (int k = 0; k < grid; k++)\n{\n  int blk = ((i + j) + k) % grid;\n  long ai = (i * sBLK) * BLK;\n  long aj = (blk * sBLK) * BLK;\n  long bi = (blk * sBLK) * BLK;\n  long bj = (j * sBLK) * BLK;\n  mymult(&A[INDEX(ai, aj, n)], &B[INDEX(bi, bj, n)], &C[INDEX(ai, bj, n)], s, s, s, n);\n}\n\n\n", "pragma": "omp parallel for private(id,nthreads) num_threads(20)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcheng761/Parallel-Block-Multiplier/mymult/1"}
{"code": "for (i = 0; i < ((int) nParticles); i++)\n  if (pBestFitness[i] < gBestFitness)\n{\n  gBestFitness = pBestFitness[i];\n}\n\n\n", "pragma": "omp for reduction(min:gBestFitness)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/omp_parallel/0"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  mor_s_v[0][i - 1] = idmo[ntemp1][jjface[face]][0][0][i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/16"}
{"code": "for (int i = 0; i < src_seq_length_max; i++)\n{\n  for (int j = 0; j < batch; j++)\n  {\n    for (int k = 0; k < feature_size; k++)\n    {\n      size_t tnc_offset = (((i * batch) * feature_size) + (j * feature_size)) + k;\n      alignment_model_ptr[tnc_offset] = tanhf((((float) (weighted_src_layer.data()[(j * feature_size) + k] - (dec_src_layer_shift * compensation[k]))) / (dec_src_layer_scale * weights_src_layer_scale)) + weighted_annotations[tnc_offset]);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rgr19/MKL-DNN_Eigen_Boost_OpenMPI_GoogleTests_Examples/src/bin/mkl-dnn/simple_rnn_int8/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"Mostramos resultados intermedios:\\n\");\n  for (j = 0; j < N; j++)\n    printf(\"/matriz[%d][%d]*matriz2[%d][%d](%d*%d=%d)/\\n\", i, j, i, j, matriz[i][j], matriz2[i][j], matriz[i][j] * matriz2[i][j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio9/7"}
{"code": "for (int i = low; i < up; ++i)\n{\n  f[i] = 0.0;\n  f[i] = 1.0;\n}\n\n", "pragma": "#pragma omp for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_codegen/3"}
{"code": "for (; it != moves_list.end(); ++it)\n  mvec.push_back(*it);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sphurti/Laserchess/trees/AlphaBetaParallel/0"}
{"code": "for (int i = 0; i < popl_size; i++)\n  for (int j = i + 1; j < popl_size; j++)\n  if (population[i].fitness < population[j].fitness)\n  swap_chromosomes(population, i, j);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/12"}
{"code": "for (j = 1; j <= seq2len; j++)\n  M[0][j] = M[0][j - 1] + gap;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alperencubuk/Sequence-Alignment-with-NW-Algorithm/SequenceAlignment/3"}
{"code": "for (int i = 0; i < m; i++)\n  if (Y[i] != Y_golden[i])\n  errorcount_parallel_avx2++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiaosongAI/Parallel-SpMV/spmv_avx2/5"}
{"code": "for (int x = 0; x < (m * n); x++)\n{\n  C[x] = X * C[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/machadoprx/CoolConvNN/gemm/2"}
{"code": "for (unsigned int i = 1; i <= (M.mesh.x_coordinates.size() - 1); i++)\n{\n  axpy(&M.thomas_denomx[i], M.thomas_constant1, M.thomas_cx[i - 1]);\n  M.thomas_cx[i] /= M.thomas_denomx[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_solvers/0"}
{"code": "for (i = 0; i < (1 << 16); i++)\n{\n  x1 = (2.0 * xx[k - 1][2 * i]) - 1.0;\n  x2 = (2.0 * xx[k - 1][(2 * i) + 1]) - 1.0;\n  t1 = pow2(x1) + pow2(x2);\n  if (t1 <= 1.0)\n  {\n    t2 = sqrt(((-2.0) * log(t1)) / t1);\n    t3 = x1 * t2;\n    t4 = x2 * t2;\n    l = max(fabs(t3), fabs(t4));\n    qq[k - 1][l] += 1.0;\n    psx = psx + t3;\n    psy = psy + t4;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:psx,psy)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/EP/ep/2"}
{"code": "for (int i = 0; i < pcinfo.x_cells_num; i++)\n{\n  double value = phi(x_(pcinfo.x_cell_pos + i), y_(pcinfo.y_cell_pos + (pcinfo.y_cells_num - 1)));\n  f[((pcinfo.y_cells_num - 1) * pcinfo.x_cells_num) + i] = value;\n}\n\n", "pragma": "            #pragma omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/19"}
{"code": "for (int i = 1; i < N; i++)\n{\n  int j = 1;\n  a[i][j] = 2 * b[i][j];\n  d[i][j] = a[i][j] * c[i][j];\n  c[i][j - 1] = a[i][j - 1] - (2 * b[i][j + 1]);\n  for (j = 2; j < (N - 1); j++)\n  {\n    a[i][j] = 2 * b[i][j];\n    d[i][j] = a[i][j] * c[i][j];\n    c[i][j - 1] = (2 * b[i][j - 1]) - (2 * b[i][j + 1]);\n  }\n\n  j = N - 1;\n  a[i][j] = 2 * b[i][j];\n  d[i][j] = a[i][j] * c[i][j];\n  c[i][j - 1] = (2 * b[i][j - 1]) - a[i][j + 1];\n}\n\n", "pragma": "omp parallel for num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arslansadiq/Parallel-Programming-TUM/Assignment8_Loop_Fusion/student/loop_fusion_par/0"}
{"code": "for (int i = 0; i < n; i += WINDOW_X)\n{\n  for (int j = 0; j < m; j += WINDOW_Y)\n  {\n    discreteCosTransform(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IGMercier/15418-S20-Parallel-Compression-/src/parallel_omp/src/compression/0"}
{"code": "for (int i = 0; i < (ifog_t.size() / 4); ++i)\n{\n  for (int j = 0; j < ifog_t[0].size(); ++j)\n  {\n    o_t[i][j] = ifog_t[i + (2 * (ifog_t.size() / 4))][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_3/6"}
{"code": "for (i = end16; i < end; i += 4)\n{\n  for (k = 0; k < total; k += m)\n  {\n    a = _mm_loadu_ps((A + i) + k);\n    for (j = 0; j < m; j += 1)\n    {\n      b = _mm_load1_ps((A + k) + j);\n      c = _mm_loadu_ps((C + i) + (j * m));\n      c = _mm_add_ps(c, _mm_mul_ps(a, b));\n      _mm_storeu_ps((C + i) + (j * m), c);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utkarshdalal/MatrixMultiply/sgemm-small (alternate)/1"}
{"code": "for (j = 0; j < len; j++)\n  c[i][j] = a[i][j] * b[i][j];\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB098-simd2-orig-no/2"}
{"code": "for (int i = 0; i < imagen.altura; i++)\n{\n  int pixelOffset = ((imagen.altura - i) - 1) * unpaddedRowSize;\n  if (fwrite(&imagen.imagen[pixelOffset], 1, paddedRowSize, escribirDF) == 0)\n  {\n    perror(\"Error de escritura al escribir los pixeles\");\n    return -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarZeta-hub/pr-ctica-OpenMP/image-par/image-par/1"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  a[i] = 3 * a[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-01-SimpleOmpParallelFor/0"}
{"code": "for (int r = 0, rn = mask.rows; r < rn; r++)\n{\n  for (int c = 0, cn = mask.cols; c < cn; c++)\n  {\n    intensity_bgr = (mask.at < Vec3b) > ((r, c));\n    number_channels_above = 0;\n    for (int i = 0; i < 3; i++)\n    {\n      if (intensity_bgr[i] > 200)\n      {\n        number_channels_above++;\n      }\n\n    }\n\n    if (number_channels_above == 1)\n    {\n      (r < max_row) ? (max_row = r) : (0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/0"}
{"code": "for (int p = 0; p < numDivs; p++)\n{\n  for (int t = 0; t < NumQs; t++)\n    fprintf(pFile, \"%.3lf,\", *((miqxdvsn_nn + t) + (p * NumQs)));\n\n  fprintf(pFile, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/16"}
{"code": "for (int i = 1; i < populationSize; i++)\n{\n  if (genePool.at(i).fitness < a.fitness)\n    z = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shay9000/Genetic-Algorithm-Sudoku-Solver/src/genetic/5"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j += 1)\n{\n  x[j] = norm_temp12 * z[j];\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (norm_temp12)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  table[i] = (rand() % 100) + 1;\n  printf(\"Thread number %d \\n\", omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5/0"}
{"code": "for (int i = 0; i < nonZeroCount; i++)\n{\n  x[0][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/4"}
{"code": "for (int i = 0; i < totalPoints; i++)\n{\n  counter = i * k;\n  for (int j = 0; j < totalPoints; j++)\n  {\n    if (i != (j + offset2))\n    {\n      temp = calculateDistance(i, j, array1, array2, numOfCoordinates);\n      if (temp <= nearestDistances[(counter + k) - 1])\n      {\n        for (int z = 0; z <= (k - 1); z++)\n        {\n          if (temp == nearestDistances[counter + z])\n          {\n            save = z;\n            break;\n          }\n\n        }\n\n        while ((labelPointer[counter + save] > 0) && (save <= (k - 2)))\n          save++;\n\n        labelPointer[counter + save] = j + offset;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(save,counter)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/billmats96/Parallel-and-Distributed-Systems/Project 2/src/mpi_threaded_blocking/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%f\\t\", X[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/6"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < width; k++)\n    {\n      double x = a[(i * width) + k];\n      double y = b[(k * width) + j];\n      sum += x * y;\n    }\n\n    c[(i * width) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa04/mm/0"}
{"code": "for (int i = 0; i < nx; i++)\n  for (int j = 0; j < ny; j++)\n{\n  int ipp = ((i + 1) < nx) ? (i + 1) : (0);\n  int inn = ((i - 1) >= 0) ? (i - 1) : (nx - 1);\n  int jpp = ((j + 1) < ny) ? (j + 1) : (0);\n  int jnn = ((j - 1) >= 0) ? (j - 1) : (ny - 1);\n  int joff;\n  if (is_black)\n  {\n    joff = (i % 2) ? (jpp) : (jnn);\n  }\n  else\n  {\n    joff = (i % 2) ? (jnn) : (jpp);\n  }\n\n  signed char nn_sum = ((op_lattice[(inn * ny) + j] + op_lattice[(i * ny) + j]) + op_lattice[(ipp * ny) + j]) + op_lattice[(i * ny) + joff];\n  signed char lij = lattice[(i * ny) + j];\n  float acceptance_ratio = exp((double) ((((-2.0f) * inv_temp) * nn_sum) * lij));\n  if (randvals[(i * ny) + j] < acceptance_ratio)\n  {\n    lattice[(i * ny) + j] = -lij;\n  }\n\n}\n\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ising-omp/main/1"}
{"code": "for (i = 0; i < nparts; i++)\n{\n  w[i] = particles[i].w;\n  wsum += w[i];\n  wsumsq += w[i] * w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/fast-slam/simulator/5"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/66"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    matvec_sub(lhs[i][j][ksize][0], rhs[i][j][ksize - 1], rhs[i][j][ksize]);\n    matmul_sub(lhs[i][j][ksize][0], lhs[i][j][ksize - 1][2], lhs[i][j][ksize][1]);\n    binvrhs(lhs[i][j][ksize][1], rhs[i][j][ksize]);\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/17"}
{"code": "for (j = 3; j <= (grid_points[1] - 4); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/29"}
{"code": "for (int counter = 0; counter < 1200000; counter++)\n{\n  int A = (rand() % (((10000 - 1) - 1) + 1)) + 1;\n  int B = (rand() % (((10000 - 1) - 1) + 1)) + 1;\n  while (A == B)\n    B = (rand() % (((10000 - 1) - 1) + 1)) + 1;\n\n  if (A > B)\n  {\n    int temp = A;\n    A = B;\n    B = temp;\n  }\n\n  int flag = (B - A) - 1;\n  double dist1_old;\n  double dist2_old;\n  double dist3_old;\n  double dist4_old;\n  double dist1_new = 1;\n  double dist2_new;\n  double dist3_new;\n  double dist4_new;\n  dist1_old = Distance(Path[A - 1], Path[A]);\n  dist2_old = (!flag) ? (0) : (Distance(Path[A], Path[A + 1]));\n  dist3_old = (!flag) ? (0) : (Distance(Path[B - 1], Path[B]));\n  dist4_old = Distance(Path[B], Path[B + 1]);\n  dist1_new = Distance(Path[A - 1], Path[B]);\n  dist2_new = (!flag) ? (0) : (Distance(Path[B], Path[A + 1]));\n  dist3_new = (!flag) ? (0) : (Distance(Path[B - 1], Path[A]));\n  dist4_new = Distance(Path[A], Path[B + 1]);\n  double distChange = (((((((-dist1_old) - dist2_old) - dist3_old) - dist4_old) + dist1_new) + dist2_new) + dist3_new) + dist4_new;\n  if (distChange < 0)\n  {\n    omp_set_lock(&Locks[A]);\n    omp_set_lock(&Locks[B]);\n    int temp = Path[A];\n    Path[A] = Path[B];\n    Path[B] = temp;\n    omp_unset_lock(&Locks[A]);\n    omp_unset_lock(&Locks[B]);\n  }\n  else\n    distChange = 0;\n\n  totDistChange += distChange;\n}\n\n", "pragma": "omp parallel for reduction(+:totDistChange) schedule(static, BATCH_SIZE_PER_RESCHEDULING)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_rnd04/0"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  for (int ColIdx = 0; ColIdx < Cols; ColIdx++)\n  {\n    Res.Mat->PutXY(RowIdx, ColIdx, Mat[RowIdx][ColIdx]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/105"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->distances[v] = 4294967295U / 2;\n  stats->parents[v] = 4294967295U;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpev08axvk.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project12/openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    register float temp = C[(i * ldc) + j];\n    for (k = 0; k < K; ++k)\n    {\n      temp += (alpha * A[(i * lda) + k]) * B[(k * ldb) + j];\n    }\n\n    C[(i * ldc) + j] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/1"}
{"code": "for (int n = 0; n < nNonZero; n++)\n{\n  int i = A[n][0];\n  int j = A[n][1];\n  double sum = 0;\n  for (int k = 0; k < nFeatures; k++)\n  {\n    sum += L[i][k] * RT[j][k];\n  }\n\n  B[i][j] = sum;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/0"}
{"code": "for (j = 1; j < columns; j++)\n  if (mat[(i * columns) + j] > mat[maxIdx[i]])\n  maxIdx[i] = (i * columns) + j;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AdoniasAlcantara/project4-omp/src/parallel/5"}
{"code": "for (i = 0; i < 9; i++)\n{\n  temp = window[i];\n  for (j = i - 1; (j >= 0) && (temp < window[j]); j--)\n  {\n    window[j + 1] = window[j];\n  }\n\n  window[j + 1] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhilashjain755/ParallelProg_NoiseFilter/Mediun Filter/Median_filter/0"}
{"code": "for (int l = 0; l < 6; ++l)\n{\n  for (int t = 0; t < 6; ++t)\n    (cout << OuputImage[l][t]) << \" \";\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nawalmunif/Kernel-Image-Processing-using-OpenMP/ConsoleApplication2/1"}
{"code": "for (i = 0; i < list->size(); ++i)\n{\n  tid = omp_get_thread_num();\n  if (list->at(i) <= list->at(pivot))\n  {\n    privateLeftList->push_back(list->at(i));\n  }\n  else\n    if (list->at(i) > list->at(pivot))\n  {\n    privateRightList->push_back(list->at(i));\n  }\n\n\n}\n\n", "pragma": "        #pragma omp for nowait ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AltBrian379/CPSC-479-Project2/parallelsort/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    for (int j = 0; j < cols; j++)\n    {\n      k = (i * cols) + j;\n      Jc = J[k];\n      dN[k] = J[(iN[i] * cols) + j] - Jc;\n      dS[k] = J[(iS[i] * cols) + j] - Jc;\n      dW[k] = J[(i * cols) + jW[j]] - Jc;\n      dE[k] = J[(i * cols) + jE[j]] - Jc;\n      G2 = ((((dN[k] * dN[k]) + (dS[k] * dS[k])) + (dW[k] * dW[k])) + (dE[k] * dE[k])) / (Jc * Jc);\n      L = (((dN[k] + dS[k]) + dW[k]) + dE[k]) / Jc;\n      num = (0.5 * G2) - ((1.0 / 16.0) * (L * L));\n      den = 1 + (.25 * L);\n      qsqr = num / (den * den);\n      den = (qsqr - q0sqr) / (q0sqr * (1 + q0sqr));\n      c[k] = 1.0 / (1.0 + den);\n      if (c[k] < 0)\n      {\n        c[k] = 0;\n      }\n      else\n        if (c[k] > 1)\n      {\n        c[k] = 1;\n      }\n\n\n    }\n\n  }\n  ;\n}\n\n", "pragma": "#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/srad/srad.balance/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sendcounts[i] = n_samples_all / size;\n  if (rem > 0)\n  {\n    sendcounts[i]++;\n    rem--;\n  }\n\n  sendcounts[i] = sendcounts[i] * n_features;\n  displs[i] = offset;\n  offset += sendcounts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/4"}
{"code": "for (int i = 0; i < (TIME_ORDER + 1); i++)\n{\n  for (int j = 0; j < size_u[0]; j++)\n  {\n    for (int k = 0; k < size_u[1]; k++)\n    {\n      printf(\"%.2f \", u[i][j][k]);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/time_marching/2"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  kz = l / mxy1;\n  k = l - (mxy1 * kz);\n  lk = kz * mxy1;\n  ll = kz - 1;\n  if (ll < 0)\n    ll += mz1;\n\n  ll = ll * mxy1;\n  lr = kz + 1;\n  if (lr >= mz1)\n    lr -= mz1;\n\n  lr = lr * mxy1;\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = ky - 1;\n  if (kl < 0)\n    kl += my1;\n\n  kl = kl * mx1;\n  kr = ky + 1;\n  if (kr >= my1)\n    kr -= my1;\n\n  kr = kr * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = (kxr + kk) + lk;\n  ks[1] = (kxl + kk) + lk;\n  ks[2] = (kx + kr) + lk;\n  ks[3] = (kxr + kr) + lk;\n  ks[4] = (kxl + kr) + lk;\n  ks[5] = (kx + kl) + lk;\n  ks[6] = (kxr + kl) + lk;\n  ks[7] = (kxl + kl) + lk;\n  ks[8] = (kx + kk) + lr;\n  ks[9] = (kxr + kk) + lr;\n  ks[10] = (kxl + kk) + lr;\n  ks[11] = (kx + kr) + lr;\n  ks[12] = (kxr + kr) + lr;\n  ks[13] = (kxl + kr) + lr;\n  ks[14] = (kx + kl) + lr;\n  ks[15] = (kxr + kl) + lr;\n  ks[16] = (kxl + kl) + lr;\n  ks[17] = (kx + kk) + ll;\n  ks[18] = (kxr + kk) + ll;\n  ks[19] = (kxl + kk) + ll;\n  ks[20] = (kx + kr) + ll;\n  ks[21] = (kxr + kr) + ll;\n  ks[22] = (kxl + kr) + ll;\n  ks[23] = (kx + kl) + ll;\n  ks[24] = (kxr + kl) + ll;\n  ks[25] = (kxl + kl) + ll;\n  nh = ihole[(2 * (ntmax + 1)) * l];\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 26; ii++)\n  {\n    nboff = (idimp * npbmx) * ks[ii];\n    if (ii > 0)\n      ncoff = ncl[(ii - 1) + (26 * ks[ii])];\n\n    ip = ncl[ii + (26 * ks[ii])] - ncoff;\n    ipp = ip / 16;\n    for (m = 0; m < ipp; m++)\n    {\n      joff = 16 * m;\n      for (j = 0; j < 16; j++)\n      {\n        if ((j + ih) < nh)\n        {\n          j1 = ihole[2 * (((j + ih) + 1) + ((ntmax + 1) * l))] - 1;\n        }\n        else\n        {\n          j1 = ((npp + j) + ih) - nh;\n        }\n\n        n[j] = j1;\n      }\n\n      for (i = 0; i < idimp; i++)\n      {\n        for (j = 0; j < 16; j++)\n        {\n          j1 = n[j];\n          if (j1 < nppmx)\n          {\n            ppart[(j1 + (nppmx * i)) + npoff] = ppbuff[(((j + joff) + ncoff) + (npbmx * i)) + nboff];\n          }\n          else\n          {\n            ist = 1;\n          }\n\n        }\n\n      }\n\n      ih += 16;\n    }\n\n    nps = 16 * ipp;\n    for (j = nps; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * l))] - 1;\n      }\n      else\n      {\n        j1 = ((npp + ih) - nh) - 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j1 + (nppmx * i)) + npoff] = ppbuff[((j + ncoff) + (npbmx * i)) + nboff];\n        }\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ih > nh)\n    npp = (npp + ih) - nh;\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    ii = nh;\n    ipp = ip / 16;\n    for (m = 0; m < ipp; m++)\n    {\n      joff = 16 * m;\n      for (j = 0; j < 16; j++)\n      {\n        n[j + 16] = ihole[2 * (((ih + j) + 1) + ((ntmax + 1) * l))] - 1;\n        n[j + (2 * 16)] = ihole[2 * ((ii - j) + ((ntmax + 1) * l))] - 1;\n      }\n\n      in = 0;\n      mm = 0;\n      nn = n[in + (2 * 16)];\n      for (j = 0; j < 16; j++)\n      {\n        j1 = ((npp - j) - joff) - 1;\n        n[j] = n[mm + 16];\n        if (j1 == nn)\n        {\n          in += 1;\n          nn = n[in + (2 * 16)];\n          n[j] = -1;\n        }\n        else\n        {\n          mm += 1;\n        }\n\n      }\n\n      for (i = 0; i < idimp; i++)\n      {\n        #pragma ivdep\n        for (j = 0; j < 16; j++)\n        {\n          j1 = ((npp - j) - joff) - 1;\n          j2 = n[j];\n          if (j2 >= 0)\n          {\n            ppart[(j2 + (nppmx * i)) + npoff] = ppart[(j1 + (nppmx * i)) + npoff];\n          }\n\n        }\n\n      }\n\n      ii -= in;\n      ih += mm;\n    }\n\n    nps = 16 * ipp;\n    nn = ihole[2 * (ii + ((ntmax + 1) * l))] - 1;\n    ih += 1;\n    j2 = ihole[2 * (ih + ((ntmax + 1) * l))] - 1;\n    for (j = nps; j < ip; j++)\n    {\n      j1 = (npp - j) - 1;\n      if (j1 == nn)\n      {\n        ii -= 1;\n        nn = ihole[2 * (ii + ((ntmax + 1) * l))] - 1;\n      }\n      else\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j2 + (nppmx * i)) + npoff] = ppart[(j1 + (nppmx * i)) + npoff];\n        }\n\n        ih += 1;\n        j2 = ihole[2 * (ih + ((ntmax + 1) * l))] - 1;\n      }\n\n    }\n\n    npp -= ip;\n  }\n\n  kpic[l] = npp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,ii,kk,in,npp,npoff,nboff,ipp,joff,nps,kx,ky,kz,kl,kr, kxl,kxr,lk,ll,lr,ih,nh,nn,mm,ncoff,ist,j1,j2,ip,ks,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/19"}
{"code": "for (i = 1; i <= 23; i += 1)\n{\n  R23 = 0.50 * R23;\n  T23 = 2.0 * T23;\n}\n\n", "pragma": "omp parallel for private (i) reduction (*:R23,T23)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/0"}
{"code": "for (j = 1; j < (4096 + 1); j++)\n{\n  mean[j] = 0.0;\n  for (i = 1; i < (4096 + 1); i++)\n  {\n    mean[j] += data[(i * (4096 + 1)) + j];\n  }\n\n  mean[j] /= (DATA_TYPE) 3214212.01f;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = 0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_dist_schedule_codegen/2"}
{"code": "for (int ix = 1; ix < (nx - 1); ix++)\n{\n  vector[ix][0][nz - 1] = vector[ix][ny - 2][nz - 1];\n  vector[ix][ny - 1][nz - 1] = vector[ix][1][nz - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/10"}
{"code": "for (i = 1; i < (n - 1); ++i)\n{\n  out[i] = ((0.25 * in[i - 1]) + (0.5 * in[i])) + (0.25 * in[i + 1]);\n}\n\n", "pragma": "omp parallel for schedule(guided,11)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Archangel2153/HeatDiffusion-OpenMP-MPI/Task 2/openmp/0"}
{"code": "for (int j = 0; j < numboundpix; j++)\n{\n  int ii = (contoury[j] * width) + contourx[j];\n  img[ii] = 0xffffff;\n  for (int n = 0; n < 8; n++)\n  {\n    int x = contourx[j] + dx[n];\n    int y = contoury[j] + dy[n];\n    if (((x >= 0) && (x < width)) && ((y >= 0) && (y < height)))\n    {\n      int ind = (y * width) + x;\n      if (!istaken[ind])\n        img[ind] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/2"}
{"code": "for (i = 0; i <= 7; i++)\n{\n  if (fscanf(fp, \"%d\", &debug_vec[i]) != 1)\n  {\n    printf(\" Error in reading elements\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/0"}
{"code": "for (c1 = (ni > nk) ? (ni) : (nk); c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nl + (-1)) < (nm + (-1))) ? (nl + (-1)) : (nm + (-1))); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/24"}
{"code": "for (T i = clen + 2; i < 20; ++i)\n{\n  v[i] = v[v - clen] + 1;\n}\n\n", "pragma": "    #pragma omp for simd safelen(clen-1) simdlen(clen-1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_ast_print/2"}
{"code": "for (i = 0; i < (totalSize - 1); i++)\n{\n  V[i] = f(V[i], V[i - 1]);\n}\n\n", "pragma": "omp parallel for default(none) shared(V,totalSize) private(i) schedule(static) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor8/0"}
{"code": "for (int i = 1; i < process_count; i++)\n{\n  int assigned_move = process_assigned_move[i];\n  if (assigned_move == (-1))\n    continue;\n\n  bool finished = receive_one_finished_result(edges, i, results_buffer + (2 * i), &results[i], &send_reqs[i], &recv_reqs[i], &process_assigned_move[i]);\n  if (finished)\n  {\n    finished_cnt++;\n    if (results[i].move_id)\n    {\n      compute_interrupted = true;\n    }\n    else\n    {\n      if (results[i].value > mpi_ab.alpha)\n      {\n        mpi_ab.alpha = results[i].value;\n        update_alpha(mpi_ab.alpha, process_count);\n      }\n\n      if (maxing)\n      {\n        if (results[i].value > rst.value)\n        {\n          rst.value = results[i].value;\n          rst.move_id = assigned_move;\n        }\n\n      }\n      else\n      {\n        if (results[i].value < rst.value)\n        {\n          rst.value = results[i].value;\n          rst.move_id = assigned_move;\n        }\n\n      }\n\n      determined_move = rst.move_id;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlSaeed/15618-Final-Project/heuristic_minimax_player/7"}
{"code": "for (y = 0; y < size; y++)\n  data[y] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ppuingppuing/ComputerTopics2/recognition_seq/2"}
{"code": "for (; i < ie; i++)\n{\n  Add(data()[i], vec1.hi[i], vec1.lo[i], vec2.hi[i], vec2.lo[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_add_d/0"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"c[%d]  = %d, a[%d] = %d, b[%d] = %d, thread = %d \\n\", i, c[i], i, a[i], i, b[i], omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 3) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvgeniiSamarin/OPenMP/openMP/main/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  bodies[i].r.x += dt * bodies[i].v.x;\n  bodies[i].r.y += dt * bodies[i].v.y;\n  bodies[i].r.z += dt * bodies[i].v.z;\n}\n\n", "pragma": "        #pragma omp parallel for default(none) private(i) shared(bodies, dt, n) schedule(guided) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/N-Body-Simulation/milestone-1/nbody/1"}
{"code": "for (int32_t i = 0, ie = m_db->color_num(); i != ie; ++i)\n  mplPrint(kINFO, \"Color %d density = %u\\n\", i, m_vColorDensity[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/20"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((i % 2) == 0)\n    pi += ((double) 1) / ((2 * i) + 1);\n  else\n    pi += (-((double) 1)) / ((2 * i) + 1);\n\n}\n\n", "pragma": "omp parallel for reduction(+:pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/pi_formula/0"}
{"code": "for (uint64_t i = 1; i <= N; i++)\n{\n  sum += i;\n}\n\n", "pragma": "        #pragma omp for reduction(+:sum) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexander-mipt/OpenMP/for-schedule/for-schedule/1"}
{"code": "for (i = 0; i < NGROUPS; i++)\n  iingrs[i].size = 0;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/3"}
{"code": "for (int thr = 0; thr < nthr; thr++)\n{\n  double norm_time = (double) (((norm_end[thr] - norm_start[thr]) + rand_start) - rand_end);\n  double multi_time = (double) (((multi_end[thr] - multi_start[thr]) + rand_start) - rand_end);\n  norm_avg += norm_time;\n  multi_avg += multi_time;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_omp/8"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  uint32_t j;\n  for (j = 0; j < totalPartitions; ++j)\n  {\n    uint32_t k;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      uint32_t src = partition->edgeList->edges_array_src[k];\n      uint32_t dest = partition->edgeList->edges_array_dest[k];\n      uint32_t comp_src = stats->components[src];\n      uint32_t comp_dest = stats->components[dest];\n      if (comp_src != comp_dest)\n      {\n        uint32_t comp_high = (comp_src > comp_dest) ? (comp_src) : (comp_dest);\n        uint32_t comp_low = comp_src + (comp_dest - comp_high);\n        if (comp_high == stats->components[comp_high])\n        {\n          change = 1;\n          stats->components[comp_high] = comp_low;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/6"}
{"code": "for (int i = 0; i < NUM_POINTS_0; i++)\n{\n  Results_Phi_z[IndexT][i] = (*phi_z)[i];\n  Results_Phi_x[IndexT][i] = (*phi_x)[i];\n  Results_Eta_x[IndexT][i] = (*eta_x)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/10"}
{"code": "for (i = 0; i <= (nx - 1); i++)\n{\n  for (j = 0; j <= (ny - 1); j++)\n  {\n    for (k = 0; k <= (nz - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = -frct[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/61"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x = my_random();\n  y = my_random();\n  if (((x * x) + (y * y)) <= (r * r))\n  {\n    cir[id][0] += 1;\n  }\n\n}\n\n", "pragma": "#pragma omp  for private(x,y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/pi/pi_randomMethod/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_3/transpose/parallel/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = temp[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/auyu0408/OpenMPpractice/h5_problem1/0"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpkwngid5o.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpkwngid5o.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/40"}
{"code": "for (int i = 0; i < system_size; i++)\n{\n  variable_value_prev_t[i] = variable_value_t[i];\n}\n\n", "pragma": "\t#pragma omp parallel for default(shared) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.1/system_solver/2"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    down_v2_kernel_post(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[1 * n], &((double *) arg2.data)[5 * n], &((double *) arg3.data)[5 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[21].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/down_v2_kernel_post_kernel/0"}
{"code": "for (int ii = HALO_PAD; ii < (HALO_PAD + depth); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX)) + (((ii - HALO_PAD) * _chunk.innerX) * _chunk.innerY);\n      buffer[bufIndex] = field[(((ii * y) * x) + (jj * x)) + kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/5"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    for (i = 0; i < 3; i++)\n    {\n      fxyz[i + (3 * (j + kj))] += exyz[i + (3 * (j + kj))] * at1;\n      fxyz[i + (3 * (j + k1))] += exyz[i + (3 * (j + k1))] * at1;\n      fxyz[i + (3 * ((j + kj) + l1))] += exyz[i + (3 * ((j + kj) + l1))] * at1;\n      fxyz[i + (3 * ((j + k1) + l1))] += exyz[i + (3 * ((j + k1) + l1))] * at1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,k1,kk,kj,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/22"}
{"code": "for (int n = 0; n < m; n++)\n  scores[n] = scores[n] / biggest_score;\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bc/omp_target/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n    printf(\"\\t%d \", a[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/3/strassen/7"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  if (i > 0)\n  {\n    a[i] += 1;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jablub/chpc_omp/samples/src/goodloop/0"}
{"code": "for (unsigned i = 0; i < num_h_neurons; ++i)\n{\n  for (unsigned j = 0; j < num_v_neurons; ++j)\n  {\n    f += ((((((-m.Vp[j]) * m.W[i][j]) * m.Hp[i]) - (m.Vp[j] * m.biasV[j])) - (m.Hp[i] * m.biasH[i])) - (m.Hp[i] * log(m.Hp[i]))) + ((1 - m.Hp[i]) * log(1 - m.Hp[i]));\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:f)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/20"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"x%d\\t%lf\\n\", i + 1, matrix[(i * (n + 1)) + n]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/8"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  int threadid = omp_get_thread_num();\n  if (x[i] > maxval[threadid * padding])\n  {\n    maxval[threadid * padding] = x[i];\n    maxloc[threadid * padding] = i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_non_critical/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  m[i] = (float *) aligned_alloc((32 * n) * (sizeof(float *)), 32);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/22"}
{"code": "for (i = 0; i < vec->N; i++)\n{\n  vec->elt[i] = drand(sd);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD1_OMP/omp_prod_mat_vec/correction/prod_mat_vec_omp/2"}
{"code": "for (int j = 0; j < n; ++j)\n{\n  (((cout << s) << \" \") << particles[j]->getFullRepresentation()) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afterdusk/cs3210-parallel-particle-simulator/omp-simulator/1"}
{"code": "for (i = 0; i < T_last; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/15"}
{"code": "for (k = 0; k < 10; k++)\n{\n  printf(\".\");\n  fflush(stdout);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-CSC/exercises-gpu/stream-gpu/task1-basics/stream/0"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        fac1 = 1. / lhs[n + 2][i][j][k];\n        lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n        lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n        rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n        lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n        lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n        lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n        lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n      fac2 = 1. / lhs[n + 2][i][j1][k];\n      rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(n, j1, j2, fac1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/104"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  selectionSort3(ilgi, size(ilgi), bas);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OsamaTab/openMp/OpenMp/Source/6"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, sizeof(float), (cols * (nendmembers - 1)) * 4, fpca4);\n  fread(buffer2, sizeof(float), cols * bands, fin);\n  for (j = 0; j < (nendmembers - 1); j++)\n  {\n    for (k = 0; k < cols; k++)\n    {\n      if (buffer2[((j * cols) * 4) + k] != nvalue)\n      {\n        if (buffer[((j * cols) * 4) + k] < hmin[j])\n        {\n          hmin[j] = buffer[((j * cols) * 4) + k];\n          coordsr[j] = i;\n          coordsc[j] = k;\n        }\n\n        if (buffer[((j * cols) * 4) + k] > hmax[j])\n        {\n          hmax[j] = buffer[((j * cols) * 4) + k];\n          coordsr[(nendmembers - 1) + j] = i;\n          coordsc[(nendmembers - 1) + j] = k;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/8"}
{"code": "for (int image_frame = 0; image_frame < 4; image_frame++)\n{\n  for (int idx = 0; idx < image_size; idx++)\n  {\n    int idx_on_big_image = (image_frame * image_size) + idx;\n    big_image[idx_on_big_image] = rgb[idx];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/castelojb/MPI-OpenMP-QuickStart/big_example/filters/1"}
{"code": "for (i = 0; i < (N - 1); i++)\n  printf(\"%3.3f \", Puu[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mcc_traco/9"}
{"code": "for (int i = 0; i < _N; i++)\n{\n  a[i] = rand();\n  b[i] = rand();\n  c[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhston02/PthreadComparisonToOpenMP/main/4"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,iend1 ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/20"}
{"code": "for (int pl = xsize; pl < fullsize; pl++)\n{\n  i = pl / (xsize - 1);\n  j = pl % (xsize - 1);\n  if (j != 0)\n  {\n    int offset = (i * xsize) + j;\n    sum1 = ((((pic[((xsize * (i - 1)) + j) + 1] - pic[((xsize * (i - 1)) + j) - 1]) + (2 * pic[((xsize * i) + j) + 1])) - (2 * pic[((xsize * i) + j) - 1])) + pic[((xsize * (i + 1)) + j) + 1]) - pic[((xsize * (i + 1)) + j) - 1];\n    sum2 = ((((pic[((xsize * (i - 1)) + j) - 1] + (2 * pic[(xsize * (i - 1)) + j])) + pic[((xsize * (i - 1)) + j) + 1]) - pic[((xsize * (i + 1)) + j) - 1]) - (2 * pic[(xsize * (i + 1)) + j])) - pic[((xsize * (i + 1)) + j) + 1];\n    magnitude = (sum1 * sum1) + (sum2 * sum2);\n    if (magnitude > thresh)\n      result[offset] = 255;\n    else\n      result[offset] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kevin1989c/sobel_openmp/Project1/Project1/Source/3"}
{"code": "for (mat_row = 0; mat_row < n; mat_row++)\n{\n  grid_row = mat_row / local_B->n_bar;\n  coords[0] = grid_row;\n  for (grid_col = 0; grid_col < grid->q; grid_col++)\n  {\n    coords[1] = grid_col;\n    MPI_Cart_rank(grid->comm, coords, &source);\n    if (source == 0)\n    {\n      for (mat_col = 0; mat_col < local_B->n_bar; mat_col++)\n        printf(\"%20.15E \", *((local_B->entries + (local_B->n_bar * mat_col)) + mat_row));\n\n    }\n    else\n    {\n      MPI_Recv(temp, local_B->n_bar, (MPI_Datatype) 0x4c00080b, source, 0, grid->comm, &status);\n      for (mat_col = 0; mat_col < local_B->n_bar; mat_col++)\n        printf(\"%20.15E \", temp[mat_col]);\n\n    }\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/10"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n  {\n    X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c15)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-tile-no/2"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  printf(\"N%d\", i);\n  for (j = 0; j < 1000; ++j)\n    printf(\"%5d\", dist[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gnalexandridis/Floyd-Warshall_HUA-PCA-2017-2018/openMP/4"}
{"code": "for (int i = 0; i < vertexCount; ++i)\n{\n  int maxDistance = 0;\n  for (int j = 0; j < localVertexCount; ++j)\n  {\n    if (((*(distancesTable[i] + j)) > maxDistance) && ((*(distancesTable[i] + j)) != 2147483647))\n      maxDistance = *(distancesTable[i] + j);\n\n  }\n\n  if (maxDistance > diameter)\n  {\n    diameter = maxDistance;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pancak3/Diameter-OpenMP/onePunch/1"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  free(spmatrix->val[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/5"}
{"code": "for (int i = 0; i < len; i++)\n{\n  acc += input[i];\n}\n\n", "pragma": "    #pragma omp for schedule(dynamic,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/1"}
{"code": "for (unsigned int tid = 0; tid < num_elements; tid++)\n{\n  for (unsigned int i = 0; i < iter; i++)\n  {\n    h_dst->s0[tid] += h_src->s0[tid];\n    h_dst->s1[tid] += h_src->s1[tid];\n    h_dst->s2[tid] += h_src->s2[tid];\n    h_dst->s3[tid] += h_src->s3[tid];\n    h_dst->s4[tid] += h_src->s4[tid];\n    h_dst->s5[tid] += h_src->s5[tid];\n    h_dst->s6[tid] += h_src->s6[tid];\n    h_dst->s7[tid] += h_src->s7[tid];\n    h_dst->s8[tid] += h_src->s8[tid];\n    h_dst->s9[tid] += h_src->s9[tid];\n    h_dst->sa[tid] += h_src->sa[tid];\n    h_dst->sb[tid] += h_src->sb[tid];\n    h_dst->sc[tid] += h_src->sc[tid];\n    h_dst->sd[tid] += h_src->sd[tid];\n    h_dst->se[tid] += h_src->se[tid];\n    h_dst->sf[tid] += h_src->sf[tid];\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/interleave-omp/main/1"}
{"code": "for (i = 0; i < n; i++)\n  ((((((cout << \"x[\") << (i + 1)) << \"]= \") << setw(7)) << setprecision(6)) << x[i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/4"}
{"code": "for (i = 0; i < nclusters; i++)\n{\n  for (j = 0; j < nfeatures; j++)\n  {\n    if (new_centers_len[i] > 0)\n      clusters[(i * nfeatures) + j] = new_centers[i][j] / new_centers_len[i];\n\n    new_centers[i][j] = 0.0;\n  }\n\n  new_centers_len[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/kmeans/kmeans_clustering.ref/4"}
{"code": "for (iterator Iter = Stack.back().first.rbegin(); Iter != ParentIterTarget; advance(Iter, 1))\n{\n  if (isOpenMPLocal(VD, Iter))\n  {\n    DVar.RefExpr = buildDeclRefExpr(SemaRef, VD, D->getType().getNonReferenceType(), D->getLocation());\n    DVar.CKind = OMPC_threadprivate;\n    return DVar;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/0"}
{"code": "for (size_t i = 0; i < vec.extent(0); ++i)\n{\n  (((((cout << vec.name()) << \"[\") << i) << \"]: \") << vec[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gadube/simple_openmp_examples/cg-solve/cgsolve_omp/0"}
{"code": "for (int i = 0; i < 350; i++)\n{\n  reference(h_tisspoints, h_gtt, h_gbartt, h_ct_gold, h_ctprev, h_qt, nnt, nntDev, step, 1);\n  reference(h_tisspoints, h_gtt, h_gbartt, h_ct_gold, h_ctprev, h_qt, nnt, nntDev, step, 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/tissue-omp/main/6"}
{"code": "for (ti = 0; ti < 12; ti++)\n{\n  int prim = nnode + (11 / 12);\n  int StartPre = prim * ti;\n  int EndPre = (ti == 11) ? (nnode) : (prim * (ti + 1));\n  for (ri = 0; ri < bcount; ri++)\n  {\n    int nnid = buffer[ri];\n    if ((StartPre <= nnid) && (nnid < EndPre))\n    {\n      s->rat_count[nnid] -= 1;\n    }\n\n    int npid = s->rat_position[ri + bstart];\n    if ((StartPre <= npid) && (npid < EndPre))\n    {\n      s->rat_count[npid] += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ri)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WeijiaGao49/Shared-Memory-Parallelism-with-OpenMP/code/sim/5"}
{"code": "for (i = 0; i < bands; i++)\n{\n  fprintf(report, \"Band %d : %10.5lf\\n\", i + 1, dvar2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/ODM/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  matrix[i] = malloc(n * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/caiobrreis/openMP-matrix-multiplication/omp/3"}
{"code": "for (int k = nbthreads * granularity; k < n; k++)\n{\n  pr[k + 1] = pr[k] + arr[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayuri34/parallel-computing/assignment-openmp-loop/prefixsum/prefixsum/1"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 10000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      D[(i * 10000) + j] = 0;\n    }\n    else\n    {\n      D[(i * 10000) + j] = (((float) i) * (j + 2)) / 10000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanafacion/Paralelas/Exercicio12/code-t12/4"}
{"code": "for (i = 0; i < Size; i++)\n{\n  pResult[i] = 0;\n  for (j = 0; j < Size; j++)\n    pResult[i] += pMatrix[i][j] * pVector[j];\n\n}\n\n", "pragma": "#pragma omp parallel for private (j) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PAAnisimofff/SLAU_OpenMP/SLAU_OpenMP/SLAU_OpenMP/6"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (k = 3; k <= (grid_points[2] - 4); k++)\n  {\n    forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][k - 2] - (4.0 * ue[m][k - 1])) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/9"}
{"code": "for (int i = 0; i < Reps; i++)\n{\n  D.zeros();\n  shuffle = uvec > ((n, distr_param(0, B.n_cols - 1)));\n  BG = B.cols(shuffle);\n  strp.zeros();\n  for (int j = 0; j < n; j++)\n  {\n    Res = StrROne(D, P, data.col(j).head(cov_num), cov_num, level_num, bsize, B, BG, strp);\n    strp = Res(0, 0);\n    BG = Res(1, 0);\n    assignew(j) = Res(2, 0)(0, 0);\n    D = Res(3, 0);\n  }\n\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  diff(i) = ((-sum(data.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/48"}
{"code": "for (j = ((int) pow(2, i)) - 1; j <= (((int) pow(2, i + 1)) - 1); j++)\n{\n  a[j] = a[j / 2];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/0"}
{"code": "for (int j = jb; j < je; j++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    Dzu[IDX(i, j, 3)] = ((((-3.0) * u[IDX(i, j, 3)]) + (4.0 * u[IDX(i, j, 4)])) - u[IDX(i, j, 5)]) * idz_by_2;\n    if (betaz[IDX(i, j, 4)] > 0.0)\n    {\n      Dzu[IDX(i, j, 4)] = ((((-3.0) * u[IDX(i, j, 4)]) + (4.0 * u[IDX(i, j, 5)])) - u[IDX(i, j, 6)]) * idz_by_2;\n    }\n    else\n    {\n      Dzu[IDX(i, j, 4)] = ((-u[IDX(i, j, 3)]) + u[IDX(i, j, 5)]) * idz_by_2;\n    }\n\n    if (betaz[IDX(i, j, 5)] > 0.0)\n    {\n      Dzu[IDX(i, j, 5)] = ((((((-3.0) * u[IDX(i, j, 4)]) - (10.0 * u[IDX(i, j, 5)])) + (18.0 * u[IDX(i, j, 6)])) - (6.0 * u[IDX(i, j, 7)])) + u[IDX(i, j, 8)]) * idz_by_12;\n    }\n    else\n    {\n      Dzu[IDX(i, j, 5)] = ((u[IDX(i, j, 3)] - (4.0 * u[IDX(i, j, 4)])) + (3.0 * u[IDX(i, j, 5)])) * idz_by_2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/34"}
{"code": "for (int u = 0; u < (W - 1); u++)\n{\n  ch_image[0 + u] = BLACKPIXEL;\n  ch_image[((H - 1) * W) + u] = BLACKPIXEL;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filipe3x/esqueletizacao_openmp/skeletonize/5"}
{"code": "for (long long j = 0; j < sizeList; j++)\n{\n  counter += checkStr(decipherText, plaintextList[j], tempStr);\n  if ((counter == 3) && (keyFound == 0))\n  {\n    printf(\"Key found is: %s\\n\", pKey);\n    printf(\"Decipher text:\\n%s\\n\", decipherText);\n    keyFound = 1;\n    j = sizeList;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NaorFahima/Parallel-And-Distributed-Computing/Project/func/0"}
{"code": "for (currentRow = 2; currentRow < workingRows; ++currentRow)\n  for (currentColumn = 2; currentColumn < workingColumns; ++currentColumn)\n{\n  *((nextGrid + (currentRow * totalColumns)) + currentColumn) = ((*((oldGrid + (currentRow * totalColumns)) + currentColumn)) + (parms.cx * (((*((oldGrid + ((currentRow + 1) * totalColumns)) + currentColumn)) + (*((oldGrid + ((currentRow - 1) * totalColumns)) + currentColumn))) - (2.0 * (*((oldGrid + (currentRow * totalColumns)) + currentColumn)))))) + (parms.cy * (((*(((oldGrid + (currentRow * totalColumns)) + currentColumn) + 1)) + (*(((oldGrid + (currentRow * totalColumns)) + currentColumn) - 1))) - (2.0 * (*((oldGrid + (currentRow * totalColumns)) + currentColumn)))));\n}\n\n\n", "pragma": "omp for schedule(static) collapse(DIMENSIONALITY)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/1"}
{"code": "for (z = 1; z < OMP_zMax; z++)\n{\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 16)\n    {\n      int xyzInd = OMP_Index(x, y, z);\n      u[xyzInd] = u[xyzInd - xyMax] * nu;\n      u[xyzInd + 1] = u[(xyzInd + 1) - xyMax] * nu;\n      u[xyzInd + 2] = u[(xyzInd + 2) - xyMax] * nu;\n      u[xyzInd + 3] = u[(xyzInd + 3) - xyMax] * nu;\n      u[xyzInd + 4] = u[(xyzInd + 4) - xyMax] * nu;\n      u[xyzInd + 5] = u[(xyzInd + 5) - xyMax] * nu;\n      u[xyzInd + 6] = u[(xyzInd + 6) - xyMax] * nu;\n      u[xyzInd + 7] = u[(xyzInd + 7) - xyMax] * nu;\n      u[xyzInd + 8] = u[(xyzInd + 8) - xyMax] * nu;\n      u[xyzInd + 9] = u[(xyzInd + 9) - xyMax] * nu;\n      u[xyzInd + 10] = u[(xyzInd + 10) - xyMax] * nu;\n      u[xyzInd + 11] = u[(xyzInd + 11) - xyMax] * nu;\n      u[xyzInd + 12] = u[(xyzInd + 12) - xyMax] * nu;\n      u[xyzInd + 13] = u[(xyzInd + 13) - xyMax] * nu;\n      u[xyzInd + 14] = u[(xyzInd + 14) - xyMax] * nu;\n      u[xyzInd + 15] = u[(xyzInd + 15) - xyMax] * nu;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x, y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.8/HoldompDeblur/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (fabs(R[i] - v[i][0]) > (5 * e))\n  {\n    flag = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/14"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], 0, hydro_data->r0[i], hydro_data->r1[i], position_phi);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, position_phi);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/16"}
{"code": "for (int i = 0; i < max_threads; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    for (int m = 0; m < temp_clusters[i][j].size(); m++)\n    {\n      clusters[j].push_back(temp_clusters[i][j][m]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/k-means/k-means-2/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/169"}
{"code": "for (k = 0; k < 3000; k++)\n{\n  lines[k] = (char *) malloc(256 * (sizeof(char)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/word_count/2"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = (4 * nxvh) * k;\n  k1 = ((4 * nxvh) * ny) - kj;\n  #pragma ivdep\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    fxy[(4 * j) + kj] = exy[(4 * j) + kj] * at1;\n    fxy[(1 + (4 * j)) + kj] = exy[(1 + (4 * j)) + kj] * at1;\n    fxy[(2 + (4 * j)) + kj] = exy[(2 + (4 * j)) + kj] * at1;\n    fxy[(4 * j) + k1] = exy[(4 * j) + k1] * at1;\n    fxy[(1 + (4 * j)) + k1] = exy[(1 + (4 * j)) + k1] * at1;\n    fxy[(2 + (4 * j)) + k1] = exy[(2 + (4 * j)) + k1] * at1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/20"}
{"code": "for (int ii = 2; ii < params.ly; ++ii)\n{\n  for (int jj = 2; jj < params.lx; ++jj)\n  {\n    if (!obstacles[((ii - 1) * params.lx) + (jj - 1)])\n    {\n      int y_n = ii + 1;\n      int y_s = ii - 1;\n      int x_e = jj + 1;\n      int x_w = jj - 1;\n      float tmp_speeds[9];\n      tmp_speeds[0] = cells[(ii * params.nx) + jj].speeds[0];\n      tmp_speeds[1] = cells[(ii * params.nx) + x_w].speeds[1];\n      tmp_speeds[2] = cells[(y_s * params.nx) + jj].speeds[2];\n      tmp_speeds[3] = cells[(ii * params.nx) + x_e].speeds[3];\n      tmp_speeds[4] = cells[(y_n * params.nx) + jj].speeds[4];\n      tmp_speeds[5] = cells[(y_s * params.nx) + x_w].speeds[5];\n      tmp_speeds[6] = cells[(y_s * params.nx) + x_e].speeds[6];\n      tmp_speeds[7] = cells[(y_n * params.nx) + x_e].speeds[7];\n      tmp_speeds[8] = cells[(y_n * params.nx) + x_w].speeds[8];\n      float local_density = 0.0f;\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        local_density += tmp_speeds[kk];\n      }\n\n      float u_x = ((((((+tmp_speeds[1]) + tmp_speeds[5]) + tmp_speeds[8]) - tmp_speeds[3]) - tmp_speeds[6]) - tmp_speeds[7]) / local_density;\n      float u_y = ((((((+tmp_speeds[2]) + tmp_speeds[5]) + tmp_speeds[6]) - tmp_speeds[4]) - tmp_speeds[7]) - tmp_speeds[8]) / local_density;\n      float u_sq = (u_x * u_x) + (u_y * u_y);\n      float omega_d_equ[9];\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        float u_kk = (u[kk][0] * u_x) + (u[kk][1] * u_y);\n        omega_d_equ[kk] = ((w[kk] * params.omega) * local_density) * (((1.0f + (3.0f * u_kk)) + ((4.5f * u_kk) * u_kk)) - (1.5f * u_sq));\n      }\n\n      for (int kk = 0; kk < 9; ++kk)\n      {\n        tmp_speeds[kk] *= 1.0f - params.omega;\n        tmp_speeds[kk] += omega_d_equ[kk];\n      }\n\n      cells[(ii * params.nx) + jj].speeds[0] = tmp_speeds[0];\n      cells[(ii * params.nx) + x_w].speeds[1] = tmp_speeds[3];\n      cells[(y_s * params.nx) + jj].speeds[2] = tmp_speeds[4];\n      cells[(ii * params.nx) + x_e].speeds[3] = tmp_speeds[1];\n      cells[(y_n * params.nx) + jj].speeds[4] = tmp_speeds[2];\n      cells[(y_s * params.nx) + x_w].speeds[5] = tmp_speeds[7];\n      cells[(y_s * params.nx) + x_e].speeds[6] = tmp_speeds[8];\n      cells[(y_n * params.nx) + x_e].speeds[7] = tmp_speeds[5];\n      cells[(y_n * params.nx) + x_w].speeds[8] = tmp_speeds[6];\n      tot_u += sqrtf((u_x * u_x) + (u_y * u_y));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/16"}
{"code": "for (i = 0; i < 20480; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/3"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n{\n  c[(i * N) + j] = a[i] * b[j];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/omp5/loop/loop/0"}
{"code": "for (i = 1; i <= (k - 1); i++)\n{\n  s[i] = (left + (interval * i)) - 1;\n  tid = omp_get_thread_num();\n  printf(\"Thread number %d allocated s[%d]=%d\\n\", tid, i, s[i]);\n}\n\n", "pragma": "omp parallel for num_threads(k-1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/search/2"}
{"code": "for (long i = 0; i < j; i++)\n{\n  ssyrk_tile(A[j][i], A[j][j], BlockSize, j);\n}\n\n", "pragma": "\t\t#pragma omp parallel for firstprivate(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/cholesky/cholesky_omp/0"}
{"code": "for (int i = 0; i < r; ++i)\n  if (board[i] == board[r])\n  return false;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nqueen-omp/main/1"}
{"code": "for (size_t k = 1; k < size; k++)\n{\n  MPI_Recv(env.grid + beginning[k - 1], num_organisms[k - 1], final_org, k, 0, 1, (MPI_Status *) 1);\n  MPI_Recv(tasks_completed, NUM_TASKS, (MPI_Datatype) 0x4c000102, k, 0, 1, (MPI_Status *) 1);\n  for (size_t m = 0; m < NUM_TASKS; m++)\n  {\n    env.tasks_completed[m] += tasks_completed[m];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/14"}
{"code": "for (int i = 0; i < (POP_SIZE / 2); i++)\n{\n  int flip = rand() % 2;\n  if (flip == 0)\n    offspring[i] = crossoverInj(p.pop[i + 1], p.pop[i]);\n  else\n    offspring[i] = crossoverPm(p.pop[i], p.pop[i + 1]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/16"}
{"code": "for (int j = 0; j < size; j++)\n{\n  outputSignal[2 * (offset + (j * step))] /= _size;\n  outputSignal[(2 * (offset + (j * step))) + 1] /= _size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/11. filter (parallel)/fft/7"}
{"code": "for (i = 0; i <= N; i++)\n  printf(\"%d \", final_path[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhishekgupta-1/Parallel-Computing-Assignment/submission/tsp_openmp/tsp_openmp/7"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int temp = lineDist(l, r, P[i]);\n  int k = findSide(l, r, P[i]);\n  if ((k == side) && (temp > max_dist))\n  {\n    ind = i;\n    max_dist = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aman33459/ParallelConvexHull/quickHull/quickhullpara/4"}
{"code": "for (y = 0; y < h; y++)\n{\n  for (x = 0; x < w; x++)\n  {\n    fprintf(stderr, \"%s\", codes[univ[y][x]]);\n  }\n\n  fprintf(stderr, \"\\033[E\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/1"}
{"code": "for (i = 0; i < Nx; ++i)\n{\n  u[i][0] = 0;\n  u[i][Ny - 1] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/set/2020/exercise2/2"}
{"code": "for (int i = 0; i < nb.cores; ++i)\n  sync.off[i] = 0;\n\n", "pragma": "#pragma omp for schedule(static, 1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/mesh/0"}
{"code": "for (j = 0; j < N; j++)\n{\n  int tid = omp_get_thread_num();\n  if (randArray[j] > upper_threshold)\n  {\n    main_vector[tid].push_back(make_pair(j, randArray[j]));\n  }\n  else\n    if (randArray[j] < lower_threshold)\n  {\n    main_vector[tid].push_back(make_pair(j, randArray[j]));\n  }\n\n\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmarzzz/OpenMPTests/djm6267_hw3/part2/hw3_part2_omp_djm6267/0"}
{"code": "for (int i = 0; i < s; i++)\n{\n  int subsum = 0;\n  char *tptr;\n  char *pptr;\n  char *text = ttab[i];\n  while ((*text) != NULL)\n  {\n    if ((*text) == (*pattern))\n    {\n      tptr = text + 1;\n      pptr = pattern + 1;\n      while (true)\n      {\n        if ((*pptr) == NULL)\n        {\n          subsum++;\n          break;\n        }\n\n        if ((*tptr) != (*pptr))\n        {\n          break;\n        }\n\n        tptr++;\n        pptr++;\n      }\n\n    }\n\n    text++;\n  }\n\n  n += subsum;\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) schedule(static, 1) shared(pattern)  reduction(+:n)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/micmax93/ParallelPatternMatching/source/main/3"}
{"code": "for_handler_pre(directive)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/base/tl-omp-base/0"}
{"code": "for (i = 0; i < n1; i++)\n{\n  for (j = 0; j < n2; j++)\n  {\n    A[i][j] = ((float) rand()) / RAND_MAX;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/scott50301/Dense-matrix-multiplication-OpenMP-/pr1/0"}
{"code": "for (n = 0;; n++)\n{\n  sprintf(name, \"%s%s%d/AdaBoostCARTHaarClassifier.txt\", directory, slash, n);\n  FILE *f = fopen(name, \"rb\");\n  if (!f)\n    break;\n\n  fseek(f, 0, SEEK_END);\n  size += ftell(f) + 1;\n  fclose(f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvhaar/7"}
{"code": "for (j = 0; j < ((size_t) nt); ++j)\n  sum += sums[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex3-dot-product-openmp-sta/1"}
{"code": "for (int i = 0; i < 256; i++)\n  omp_destroy_lock(&lock[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_locks/1"}
{"code": "for (cntr = cntr_min; cntr <= cntr_max; cntr++)\n{\n  imgnext[stdpart_l + (cntr * cntr_mult)] = imgnext[stdpart_r + (cntr * cntr_mult)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/odygsim/parallelImageConvolution/op_mpi_image_conv/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    val = 0.0;\n    sum = 0.0;\n    for (k = 0; k < length; k++)\n    {\n      if (observations[k] == \"Heads\")\n        t = 0;\n      else\n        t = 1;\n\n      if (t == j)\n      {\n        val = val + gamma[k][i];\n      }\n\n      sum = sum + gamma[k][i];\n    }\n\n    b[i][j] = val / sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/10"}
{"code": "for (i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) / num_steps;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/keerti2001/High-Performance-Computing/OpenMp/Q6/q6/0"}
{"code": "for (i = 0; i < 15; i++)\n{\n  temp = malloc(sizeof(struct node));\n  p->next = temp;\n  p = temp;\n  p->data = (30 + i) + 1;\n  p->fibdata = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Solutions/linked_notasks/0"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter9/forsimd/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  shortestDist[i] = 9999;\n  included[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/8"}
{"code": "for (int i = 0; i < (WIDTH + 2); i++)\n{\n  Mesh[0][i].setEmpty(true);\n  Mesh[HEIGHT + 1][i].setEmpty(true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yang0228/zombieApocalypse-MPI-OPENMP/stage2/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    printf(\"%d, \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannesrabo/concurrent-programming/hw2/matrixSum-openmp-new/2"}
{"code": "for (i = 0; i < nf; i++)\n{\n  features[i] = atof(array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/0"}
{"code": "for (int i = 0; i < clusters.size(); i++)\n{\n  conv = clusters[i].update_coords();\n  clusters[i].free_point();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SestoAle/Parallel-K-Means/main_parallel/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  b[i] = ((double) rand()) / 32767;\n  c[i] = 0.0;\n  for (j = 0; j < size; ++j)\n  {\n    a[i][j] = ((double) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/matvec/2"}
{"code": "for (int i = 1; i < np; i++)\n  dd1[i] = (cumP[i] - cumP[i - 1]) / (xp_m[i] - xp_m[i - 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/68"}
{"code": "for (size_t index = startIndex; index < endIndex; index++)\n  m_fMaxFluidVelocity = max(m_fMaxFluidVelocity, (vU[index] * vU[index]) + (vV[index] * vV[index]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/19"}
{"code": "for (int i = 0; i < command_line_args.clust_num; i++)\n{\n  ((((((((cout << \"Cluster:\") << (i + 1)) << '(') << clusters_arr[i].x) << ',') << clusters_arr[i].y) << \") size: \") << belong_list[i].size()) << endl;\n  for (int j = 0; j < belong_list[i].size(); j++)\n  {\n    (((cout << points_arr[belong_list[i][j]].x) << \":\") << points_arr[belong_list[i][j]].y) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ/main/4"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < columns; j++)\n  {\n    if ((cost[i][j] < min) && is_valid_edge(i, j, vertices_in_mst))\n    {\n      min = cost[i][j];\n      a = i;\n      b = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lffloyd/prog-paralela-trabalho/src/omp_prim/omp_prim/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  imgFloatPtr[i] = ((float) ((unsigned char) imgCharPtr[i])) / 255.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/freesdyla/Math-424-Semester-Project/stereo/5"}
{"code": "for (j = 0; j < nx; j++)\n{\n  bxy[(3 * j) + ((3 * nxe) * ny)] = bxy[3 * j];\n  bxy[(1 + (3 * j)) + ((3 * nxe) * ny)] = bxy[1 + (3 * j)];\n  bxy[(2 + (3 * j)) + ((3 * nxe) * ny)] = bxy[2 + (3 * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/31"}
{"code": "for (i = 0; i < x; i++)\n  input1[i] = input[i][0];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/inplace_no_rec/4"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  ft->dims[m] = tt->dims[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/ftensor/9"}
{"code": "for (i1 = 0; i1 < n1; i1++)\n{\n  u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n  u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n}\n\n", "pragma": "omp parallel for firstprivate(n1 ,u ,i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/4"}
{"code": "for (int i = 1; i <= 10000000; i++)\n{\n  sum += 1.0 / i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/ece563/hw2/C/reduction/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n    fprintf(fp, \"%d \", (i * 2048) + j);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Trace Analyzer Test/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (int i = 0; i < edge_list_size; i++)\n{\n  fscanf(fp, \"%d\", &id);\n  fscanf(fp, \"%d\", &cost);\n  h_graph_edges[i] = id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_bfs/bfs/1"}
{"code": "for (size_t i = 0; i < h_prevelentColocationCount2; i++)\n{\n  for (size_t j = 0; j < degree; j++)\n  {\n    if (inner[j] != h_prevalantColocations2[(i * degree) + j])\n    {\n      flag = false;\n      break;\n    }\n\n    flag = true;\n  }\n\n  if (flag)\n  {\n    return i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/13"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  if (matrix[(i * (n + 1)) + i] == 0)\n  {\n    for (j = i + i; j < n; j++)\n    {\n      if (matrix[(j * (n + 1)) + i] != 0)\n      {\n        swap_rows(i, j, matrix, n);\n        break;\n      }\n\n    }\n\n  }\n\n  if (matrix[(i * (n + 1)) + i] == 0)\n  {\n    printf(\"Unique solution does not exist\\n\");\n    exit(1);\n  }\n\n  for (j = i + 1; j < n; j++)\n  {\n    mult = matrix[(j * (n + 1)) + i];\n    if (mult != 0)\n    {\n      mult /= matrix[(i * (n + 1)) + i];\n      for (k = i; k < (n + 1); k++)\n      {\n        matrix[(j * (n + 1)) + k] -= mult * matrix[(i * (n + 1)) + k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/5"}
{"code": "for (int i = 0; i < dimSize; ++i)\n{\n  arrayInitializer->append_expression(buildIntVal(0));\n  v_offset.push_back(buildIntVal(0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/passlab/rexompiler/src/midend/programTransformation/ompLowering/omp_lowering/3"}
{"code": "for (unsigned int i = 0; i < N; ++i)\n{\n  sum += array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bbercovici/openMP_demo/source/main/2"}
{"code": "for (int i = 0; i < h; i++)\n{\n  unsigned int PRNG_state = time(0);\n  for (unsigned short j = 0; j < w; j++)\n  {\n    double pixel_radiance[3] = {0, 0, 0};\n    for (int sub_i = 0; sub_i < 2; sub_i++)\n    {\n      for (int sub_j = 0; sub_j < 2; sub_j++)\n      {\n        double subpixel_radiance[3] = {0, 0, 0};\n        for (int s = 0; s < samples; s++)\n        {\n          double r1 = (2 * ((double) rand_r(&PRNG_state))) / 32767;\n          double dx = (r1 < 1) ? (sqrt(r1) - 1) : (1 - sqrt(2 - r1));\n          double r2 = (2 * ((double) rand_r(&PRNG_state))) / 32767;\n          double dy = (r2 < 1) ? (sqrt(r2) - 1) : (1 - sqrt(2 - r2));\n          double ray_direction[3];\n          copy(camera_direction, ray_direction);\n          axpy((((((sub_i + .5) + dy) / 2) + i) / h) - .5, cy, ray_direction);\n          axpy((((((sub_j + .5) + dx) / 2) + j) / w) - .5, cx, ray_direction);\n          normalize(ray_direction);\n          double ray_origin[3];\n          copy(camera_position, ray_origin);\n          axpy(140, ray_direction, ray_origin);\n          double sample_radiance[3];\n          radiance(ray_origin, ray_direction, 0, &PRNG_state, sample_radiance);\n          axpy(1. / samples, sample_radiance, subpixel_radiance);\n        }\n\n        clamp(subpixel_radiance);\n        axpy(0.25, subpixel_radiance, pixel_radiance);\n      }\n\n    }\n\n    copy(pixel_radiance, image + (3 * ((((h - 1) - i) * w) + j)));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_omp/pathtracer_omp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\" thread %d suma a[%d]=%d suma=%d \\n\", 0, i, a[i], suma);\n  num_threads = omp_get_num_threads();\n  num_proc = omp_get_num_procs();\n  in_parallel = omp_in_parallel();\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma,num_threads,num_proc,in_parallel)schedule(dynamic,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica3/src/scheduled-clauseModificado4/1"}
{"code": "for (int i = 1; i <= m; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    if (text1[i - 1] == text2[j - 1])\n    {\n      dp[i][j] = 1 + dp[i - 1][j - 1];\n    }\n    else\n      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaiKarthik2000/OpenMP-Parallelization-of-Dynamic-Programming-and-Greedy-Algorithms/LCS/lcs/0"}
{"code": "for (int i = 0; i < nodes2cal; ++i)\n{\n  infile2.getline(buffer, 128);\n  instream.clear();\n  instream.str(buffer);\n  instream >> cur_node_array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/operedo/gslib-lva/Boost_dijkstra/Boost_dijkstra/1"}
{"code": "for (j = 0; j < n; j++)\n{\n  fprintf(tm, \"%.3f\\n\", t[j]);\n  fprintf(pf, \"%f\\n\", x[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rcv911/Henon-map/test_sin_omp/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  old2NewMap[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReorderingND/0"}
{"code": "for (int k = 0; k < blocks; k++)\n{\n  luDecomposition(dataset, k, k);\n  float **U_inv;\n  float **L_inv;\n  U_inv = upperInverse(dataset, k, k);\n  L_inv = lowerInverse(dataset, k, k);\n  for (int i = k + 1; i < blocks; i++)\n  {\n    multiplicationFU(dataset, i, k, U_inv);\n    multiplicationLF(L_inv, dataset, k, i);\n  }\n\n  float **LU_mul;\n  for (int i = k + 1; i < blocks; i++)\n  {\n    for (int j = k + 1; j < blocks; j++)\n    {\n      LU_mul = multiplicationLU(dataset, i, k, k, j);\n      subtract(dataset, LU_mul, i, j);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q3/15"}
{"code": "for (int ck = 1; ck <= k; ++ck)\n{\n  cC[ck] = pC[ck - 1] + pC[ck];\n  cC[ck] %= modref;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/nCk/nCk2_par1/1"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  r = dot2(a, b);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/15"}
{"code": "for (int32_t i = 0; i < 10; i++)\n{\n  sum[i].x = 0;\n  sum[i].y = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_10/1"}
{"code": "for (i = i1, j = 0; i <= j2; i++, j++)\n{\n  a[i][2 - comparator] = temp[j][2 - comparator];\n  a[i][comparator] = temp[j][comparator];\n  a[i][1] = temp[j][1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srahul00/Connected-Components-OpenMP/OSAssignmentOpenMP/2"}
{"code": "for (j = 0; j < i; j++)\n  x[j] = x[j] - (U[j][i] * x[i]);\n\n", "pragma": "omp parallel for num_threads(thread) private(j) shared(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thesaurabhkumar/ParallelDenseMatrixOpenMP/Submission/matrix_par/3"}
{"code": "for (int j = 0; j < m; j++)\n{\n  double prediction = predict_one(x[j], theta);\n  double diff = prediction - y[j];\n  errors_x1_sum += diff;\n  errors_x2_sum += diff * x[j];\n}\n\n", "pragma": "omp parallel for simd reduction(+:errors_x1_sum, errors_x2_sum) firstprivate(theta, m, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IlyaCES/openmp_openmpi_labs/kursach/c/linear_regression/0"}
{"code": "for (int ty = 0; ty < 6; ty++)\n{\n  MPI_Type_free(&datatype_faces[ty]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/multigrid/0"}
{"code": "for (uint i = 0; i < input_vec.size(); ++i)\n{\n  score[i] = (sin((1 / per1) * (i + 1)) * uni1) + (sin((1 / per2) * (i + 1)) * uni2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/1"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/4"}
{"code": "for (i = 1; i < data.size(); i++)\n{\n  if (fileContent[data[i]][numOfAttrib - 1] != fileContent[data[i - 1]][numOfAttrib - 1])\n  {\n    flag = 0;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(flag) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hafeezali/Parallel-Decision-Tree-Classifier/dtc_openmp/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[(i * n) + j] = (double) drand48();\n  }\n\n}\n\n", "pragma": "omp for private (i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/1"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (argv[i][0] == '-')\n  {\n    flag = argv[i][1];\n    switch (flag)\n    {\n      case 'r':\n        i++;\n        *r = atoi(argv[i]);\n        break;\n\n      case 'l':\n        if (argv[i][2] == 'a')\n      {\n        *lat = atof(argv[i + 1]);\n      }\n      else\n      {\n        *lng = atof(argv[i + 1]);\n      }\n\n        i++;\n        break;\n\n      case 'h':\n        return 1;\n        break;\n\n      case 'q':\n        *q = 1;\n        break;\n\n      case 't':\n        *t = 1;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nn-omp/nearestNeighbor/0"}
{"code": "for (int i = (N / 4) * 3; i < N; i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/10"}
{"code": "for (i = 0; i <= n1; i++)\n{\n  free((char *) net->input_weights[i]);\n  free((char *) net->input_prev_weights[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_backprop/backprop/6"}
{"code": "for (int i = 0; i < (geom1->n_grid_r - 1); i++)\n{\n  field_r[i][0] = 0;\n  field_r[i][geom1->n_grid_z - 1] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/1"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_SHA512_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-sha512_fmt_plug/0"}
{"code": "for (i = 1; i <= 16; i++)\n{\n  subKeys[i] = permuta(chaveCD56[i], pc2, 48, 56);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/DES/DES/4"}
{"code": "for (;;)\n{\n  for (;;)\n  {\n  }\n\n}\n\n", "pragma": "    #pragma omp cancellation point for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/cancellation_point_messages/0"}
{"code": "for (int i = 0; i < c_nth; i++)\n{\n  for (; j < m[i].nrow(); j++)\n  {\n    for (int k = 0; k < m[0].ncol(); k++)\n    {\n      output(j, k) = m[i](j, k);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/hw2/p2/4"}
{"code": "for (size_t i = 1; i < size; i++)\n{\n  size_t row_start = (size_t) (i * rows_per_worker);\n  size_t amt_of_rows = (size_t) (((i + 1) * rows_per_worker) - row_start);\n  num_organisms[i - 1] = (process_info[0] = amt_of_rows * world_size);\n  beginning[i - 1] = (process_info[1] = row_start * world_size);\n  MPI_Send(process_info, 2, (MPI_Datatype) 0x4c000408, i, 0, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/7"}
{"code": "for (int ii = 0; ii < nn; ii++)\n{\n  vol = m_chSto[i] + wtrin;\n  volrt = vol / (86400.f / nn);\n  max_rate = manningQ(cross_area, radius, m_chMan[i], m_chSlope[i]);\n  sdti = 0.f;\n  m_chWtrDepth[i] = 0.f;\n  if (volrt > max_rate)\n  {\n    m_chWtrDepth[i] = m_chDepth[i];\n    sdti = max_rate;\n    while (sdti < volrt)\n    {\n      m_chWtrDepth[i] += 0.01f;\n      rcharea = ChannelCrossSectionalArea(m_chBtmWth[i], m_chDepth[i], m_chWtrDepth[i], m_chSideSlope[i], m_chWth[i], 4.f);\n      rchp = ChannelWettingPerimeter(m_chBtmWth[i], m_chDepth[i], m_chWtrDepth[i], m_chSideSlope[i], m_chWth[i], 4.f);\n      radius = rcharea / rchp;\n      sdti = manningQ(rcharea, radius, m_chMan[i], m_chSlope[i]);\n    }\n\n    sdti = volrt;\n  }\n  else\n  {\n    while (sdti < volrt)\n    {\n      m_chWtrDepth[i] += 0.01f;\n      rcharea = ChannelCrossSectionalArea(m_chBtmWth[i], m_chWtrDepth[i], m_chSideSlope[i]);\n      rchp = ChannelWettingPerimeter(m_chBtmWth[i], m_chWtrDepth[i], m_chSideSlope[i]);\n      rchradius = rcharea / rchp;\n      sdti = manningQ(rcharea, rchradius, m_chMan[i], m_chSlope[i]);\n    }\n\n    sdti = volrt;\n  }\n\n  if (m_chWtrDepth[i] <= m_chDepth[i])\n  {\n    m_chWtrWth[i] = m_chBtmWth[i] + ((2.f * m_chWtrDepth[i]) * m_chSideSlope[i]);\n  }\n  else\n  {\n    m_chWtrWth[i] = (5.f * m_chWth[i]) + ((2.f * (m_chWtrDepth[i] - m_chDepth[i])) * 4.f);\n  }\n\n  if (sdti > 0.f)\n  {\n    vc = sdti / rcharea;\n    float rttime = m_chLen[i] / (3600.f * vc);\n    rtwtr = ((c1 * wtrin) + (c2 * m_flowIn[i])) + (c3 * m_flowOut[i]);\n    if (rtwtr < 0.f)\n      rtwtr = 0.f;\n\n    rtwtr = Min(rtwtr, wtrin + m_chSto[i]);\n    m_chSto[i] += wtrin - rtwtr;\n    if (m_chSto[i] < 0.f)\n      m_chSto[i] = 0.f;\n\n    if (rtwtr > 0.f)\n    {\n      rttlc = (((det * m_Kchb[i]) * 0.001f) * m_chLen[i]) * rchp;\n      float rttlc2 = (rttlc * m_chSto[i]) / (rtwtr + m_chSto[i]);\n      float rttlc1 = 0.f;\n      if (m_chSto[i] <= rttlc2)\n      {\n        rttlc2 = Min(rttlc2, m_chSto[i]);\n      }\n\n      m_chSto[i] -= rttlc2;\n      rttlc1 = rttlc - rttlc2;\n      if (rtwtr <= rttlc1)\n      {\n        rttlc1 = Min(rttlc1, rtwtr);\n      }\n\n      rtwtr -= rttlc1;\n      rttlc = rttlc1 + rttlc2;\n    }\n\n    float rtevp = 0.f;\n    float rtevp1 = 0.f;\n    float rtevp2 = 0.f;\n    if (rtwtr > 0.f)\n    {\n      float aaa = ((m_Epch * m_petSubbsn[i]) * 0.001f) / nn;\n      if (m_chWtrDepth[i] <= m_chDepth[i])\n      {\n        rtevp = (aaa * m_chLen[i]) * m_chWtrWth[i];\n      }\n      else\n      {\n        if (aaa <= (m_chWtrDepth[i] - m_chDepth[i]))\n        {\n          rtevp = (aaa * m_chLen[i]) * m_chWtrWth[i];\n        }\n        else\n        {\n          rtevp = aaa;\n          m_chWtrWth[i] = m_chBtmWth[i] + ((2.f * m_chDepth[i]) * m_chSideSlope[i]);\n          rtevp *= m_chLen[i] * m_chWtrWth[i];\n        }\n\n      }\n\n      rtevp2 = (rtevp * m_chSto[i]) / (rtwtr + m_chSto[i]);\n      if (m_chSto[i] <= rtevp2)\n      {\n        rtevp2 = Min(rtevp2, m_chSto[i]);\n      }\n\n      m_chSto[i] -= rtevp2;\n      rtevp1 = rtevp - rtevp2;\n      if (rtwtr <= rtevp1)\n      {\n        rtevp1 = Min(rtevp1, rtwtr);\n      }\n\n      rtwtr -= rtevp1;\n      rtevp = rtevp1 + rtevp2;\n    }\n\n    m_flowIn[i] = wtrin;\n    m_flowOut[i] = rtwtr;\n    qinday += wtrin;\n    qoutday += rtwtr;\n    rtwtr = qoutday;\n  }\n  else\n  {\n    rtwtr = 0.f;\n    sdti = 0.f;\n    m_chSto[i] = 0.f;\n    m_flowIn[i] = 0.f;\n    m_flowOut[i] = 0.f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/MUSK_CH/MUSK_CH/2"}
{"code": "for (int j = 0; j < 8; j++)\n{\n  for (int i = 1; i < 3; i++)\n  {\n    A[0][j] += A[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanwbrei/openmp_tutorial/src/lcd/0"}
{"code": "for (d = 0; d <= 2; d++)\n{\n  rms[m] = rms[m] / ((double) (grid_points[d] - 2));\n}\n\n", "pragma": "omp parallel for firstprivate(m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    (cout << matr[(i * n) + j]) << \"\\t\";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvaKolosova/GPU-Lab3/functions/0"}
{"code": "for (int i = 0; i < 54; i++)\n{\n  xx[i] = fgetc(image);\n  fputc(xx[i], outputImage);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/7"}
{"code": "for (i = start_n; i < (start_n + length_n); i++)\n{\n  sum += y[i] * x[i];\n}\n\n", "pragma": "omp parallel for simd shared(y, x, start_n, length_n) private(i) num_threads(num_omp_threads) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/sum/sum_cpu_omp_kernel/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  grid[0][i] = d;\n  grid[m - 1][i] = u;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/97amarnathk/steadyStateHeat/src/steadyStateHeat/4"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    float sum = 0.0;\n    for (int k = 0; k < N; ++k)\n    {\n      sum = sum + (a[(i * N) + k] * b[(k * N) + j]);\n    }\n\n    c[(i * N) + j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/test/offloading/bug49334/1"}
{"code": "for (i = 0; i < cache->sets; i++)\n{\n  for (j = 0; j < cache->assoc; j++)\n  {\n    if (isValid(&cache->cacheLines[i][j]))\n    {\n      freq = getFreq(&cache->cacheLines[i][j]);\n      if (freq > 0)\n        freq--;\n\n      setFreq(&cache->cacheLines[i][j], freq);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/10"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  if (i == j)\n    S[i][j] = 1.0 - S[i][j];\n  else\n    S[i][j] = 0.0 - S[i][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/6"}
{"code": "for (int i = 0; i < a.nrow(); ++i)\n{\n  for (int j = 0; j < b.ncol(); ++j)\n  {\n    for (int ii = 0; ii < a.ncol(); ++ii)\n      ans.add(i, j, at(ii, i) * b(ii, j));\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/USCbiostats/r-parallel-benchmark/matrix/2"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  test();\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest02/simple_test_02/1"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n{\n  wPerNode[ip + 1] = wPerNode[ip] + wClones[ip]->getActiveWalkers();\n  (app_log() << wClones[ip]->getActiveWalkers()) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/7"}
{"code": "for (int ix = 0; ix < A_height; ++ix)\n{\n  for (int iy = 0; iy < B_height; ++iy)\n  {\n    for (int i = 0; i < A_width; ++i)\n    {\n      C[ix][iy] += A[ix][i] * B[iy][i];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(THREADS) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/I-Iaroslav/MIPT_Programs/Parallel_2/Matrix_multiply/0"}
{"code": "for (int i = 0; i < m_nCells; ++i)\n{\n  float hWater = m_sr[i];\n  if (hWater <= m_depCap[i])\n  {\n    m_sd[i] = hWater;\n    m_sr[i] = 0.f;\n  }\n  else\n  {\n    m_sd[i] = m_depCap[i];\n    m_sr[i] = hWater - m_depCap[i];\n  }\n\n  m_storageCapSurplus[i] = m_depCap[i] - m_sd[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/DEP_FS/DepressionFS/1"}
{"code": "for (int i = 1; i <= max; i++)\n{\n  for (int j = 1; j <= max; j++)\n    printf(\"%d -> (%d, %d)\\n\", omp_get_thread_num(), i, j);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/irajeshegde/OMP-Programs/4.nestedparallelfor/0"}
{"code": "for (i = 0; i < FSMSIZE; i++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    trans[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fsm-omp/main/4"}
{"code": "for (int j = 0; j < n; j++)\n{\n  result2[i][j] = 0;\n  for (int k = 0; k < m; k++)\n  {\n    result2[i][j] += matrix1[i][k] * matrix2[k][j];\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_4/4/2"}
{"code": "for (int _i0 = 1; _i0 <= R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 1; _i1 <= C; _i1 = _i1 + 1)\n  {\n    Ixy[(_i0 * (2 + C)) + _i1] = Ix[(_i0 * (2 + C)) + _i1] * Iy[(_i0 * (2 + C)) + _i1];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  v1[i] = 3;\n  v2[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp2/ejer9/pmv-OPM-a/1"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  free(mat[i]);\n  free(ps[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/max/7"}
{"code": "for (int i = 0; i < e; i++)\n  if (cross_edges[i])\n  hook(visited, 0, edge_list[i].u, edge_list[i].v, NULL);\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/5"}
{"code": "for (i = 0; i < 6; i++)\n  for (j = 0; j < 6; j++)\n  board[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/6"}
{"code": "for (i1 = 0; i1 < (mm1 - 1); i1++)\n{\n  u[2 * i3][(2 * i2) + 1][2 * i1] = u[2 * i3][(2 * i2) + 1][2 * i1] + (0.5 * z1[i1]);\n  u[2 * i3][(2 * i2) + 1][(2 * i1) + 1] = u[2 * i3][(2 * i2) + 1][(2 * i1) + 1] + (0.25 * (z1[i1] + z1[i1 + 1]));\n}\n\n", "pragma": "omp parallel for firstprivate(mm1 ,u ,i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/9"}
{"code": "for (int i = 0; i < table->n; i++)\n{\n  real_t r = table->x0 + (i * dR);\n  fprintf(potData, \"%d %e %e\\n\", i, r, table->values[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/2"}
{"code": "for (int i = 0; i < (SIZE / 10); i++)\n{\n  int idx = rand() % SIZE;\n  while (data[idx] >= 0)\n    idx = (idx + 1) % SIZE;\n\n  if (i > 0)\n  {\n    data[idx] = 1;\n    prev[idx] = tmp;\n    next[tmp] = idx;\n  }\n  else\n  {\n    data[idx] = 0;\n  }\n\n  test[idx] = i;\n  tmp = idx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/scan/lab_scan_link/scan_link/3"}
{"code": "for (diag_idx = 0; diag_idx < len; ++diag_idx)\n{\n  int diag_row_offset = len * diag_idx;\n  int curr_row_len = len - diag_idx;\n  double *non_zero_diag_row = (matrix_copy + diag_row_offset) + diag_idx;\n  double diag_elem = *non_zero_diag_row;\n  mult_row(non_zero_diag_row, 1.0 / diag_elem, curr_row_len);\n  det *= diag_elem;\n  int col_idx = diag_idx;\n  for (row_idx = diag_idx + 1; row_idx < len; ++row_idx)\n  {\n    int row_offset = row_idx * len;\n    double *non_zero_row = (matrix_copy + row_offset) + col_idx;\n    double elem = *non_zero_row;\n    mult_row(non_zero_row, (-1.0) / elem, curr_row_len);\n    det *= (-1.0) * elem;\n    add_row(non_zero_row, non_zero_diag_row, curr_row_len);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ViktorooReps/skpod/openmp/src/tria_det/5"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      do\n      {\n        rand_val = ((double) rand()) / 32767;\n      }\n      while (rand_val == 0);\n      A[(i * n) + j] = rand_val;\n    }\n    else\n    {\n      A[(i * n) + j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrovalerolara/SparseLU/test/sparselu_vs_superlu/matrix_methods/2"}
{"code": "for (i = 0; i < ni; i++)\n{\n  for (j = 0; j < nj; j++)\n  {\n    if (percentDiff(C[i][j], C_output[i][j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/polybench-acc/OpenMP/linear-algebra/kernels/gemm/gemm/0"}
{"code": "for (i__ = 1; i__ <= i__1; ++i__)\n{\n  y[i__] = (*beta) * y[i__];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/35"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (genome[(a + i) % n] != genome[(b + i) % n])\n  {\n    return genome[(a + i) % n] < genome[(b + i) % n];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bwt-omp/bwt/1"}
{"code": "for (i = 0; i < N; i++)\n  free(array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1a/code/Game_Of_Life/3"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    dampen_ewt(&((double *) arg0.data)[3 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[4].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/dampen_ewt_kernel/0"}
{"code": "for (int i = 0; i < m_nCells; ++i)\n{\n  m_accumuDepth[i] = 0.0f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/SUR_EXCESS/ExcessRunoff/1"}
{"code": "for (int j = 0; j < 50; j++)\n{\n  printf(\"%u \", A[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MiloVahos/PruebasOMP/parallelfor/3"}
{"code": "for (j = 0; j < ((1 * 1024) / 256); j++)\n  for (k = 0; k < ((1 * 1024) / 256); k++)\n{\n  if (j <= k)\n  {\n    if (k < ((1 * 1024) / 256))\n      B[(j * ((1 * 1024) / 256)) + k] = 1.0;\n    else\n      B[(j * ((1 * 1024) / 256)) + k] = B[((j * ((1 * 1024) / 256)) + k) - 1] + 1.0;\n\n  }\n  else\n  {\n    B[(j * ((1 * 1024) / 256)) + k] = 0.0;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Matrix_Multiplication_Parallel_Processing_OpenMP_OpenACC/Exploring_OpenMP/matmul/2"}
{"code": "for (int i = 1; i < width; i++)\n  dp[i] = dp[i - 1] + height;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  bodies[i].ax = (bodies[i].ay = (bodies[i].az = 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cmaureir/nbody-paper-code/src/nbody_leap_openmp/0"}
{"code": "for (k = 0; k < myid; k++)\n{\n  bucket_ptrs[0] += bucket_size[k][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/8"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n{\n  a1 = angle[previous[i]][j];\n  a2 = angle[next[i]][j];\n  a3 = angle[i][previous[j]];\n  a4 = angle[i][next[j]];\n  double resultRand;\n  drand48_r(&randBuffer, &resultRand);\n  aNew = angle[i][j] + (resultRand - 0.5);\n  if (useNew(ph->getProbability(a1, a2, a3, a4, angle[i][j], aNew), resultRand))\n  {\n    angleNew[i][j] = aNew;\n  }\n  else\n  {\n    angleNew[i][j] = angle[i][j];\n  }\n\n}\n\n\n", "pragma": "\t\t\t#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/Simulation/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 0;\n  for (int j = 0; j < N; j++)\n  {\n    a[i] += j;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/check_time/0"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  int start = g_graph_nodes[vid].starting;\n  int no_of_edges = g_graph_nodes[vid].no_of_edges;\n  int end = start + no_of_edges;\n  int new_cost = 0;\n  for (int i = start; i < end; i++)\n  {\n    int id = g_graph_edges[i];\n    if (vid > id)\n    {\n      int neighbor_cost;\n      if (stale_mode == 0)\n      {\n        neighbor_cost = g_cost[id];\n      }\n      else\n      {\n        neighbor_cost = g_cost_ind[i];\n      }\n\n      new_cost = new_cost + neighbor_cost;\n    }\n\n  }\n\n  int my_cost = g_cost[vid];\n  if (my_cost < new_cost)\n  {\n    g_cost[vid] = new_cost;\n    *g_over = true;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/NP/kernel/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n  cnt = DES_IP[i ^ 0x20];\n  j = (uchar) ((binary_salt[cnt >> 3] >> (7 - (cnt & 7))) & 1);\n  temp[i / 8] |= j << (7 - (i % 8));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETNTLM_bs_fmt_plug/4"}
{"code": "for (int i = 0; i < 800; i++)\n{\n  for (int j = 0; j < 800; j++)\n  {\n    A[i][j] = 2.0f;\n    B[i][j] = i * j;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/keigo194547/OpenMPandMPI/ompMatrixCalc/0"}
{"code": "for (int64_t i = 0; i < num_trials; ++i)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:sum) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/relentless7/parallel-pi/pi/1"}
{"code": "for (long seed = 1; seed <= MAX_SEED; seed++)\n{\n  long element = seed;\n  for (long i = 1; i <= MAX_STEPS; i++)\n  {\n    element = collatz(element);\n    if (element > high)\n      high = element;\n\n    if (element == 1)\n      break;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(auto), reduction(max:high)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mithradatha/collatz-conjecture/auto/1"}
{"code": "for (index = 0; index < stateVecSize; index++)\n{\n  targetBit = extractBit_copy(targetQubit, index + (chunkId * chunkSize));\n  if (targetBit)\n  {\n    stateRealLo = stateVecReal[index];\n    stateImagLo = stateVecImag[index];\n    stateVecReal[index] = (cosAngle * stateRealLo) - (sinAngle * stateImagLo);\n    stateVecImag[index] = (sinAngle * stateRealLo) + (cosAngle * stateImagLo);\n  }\n\n}\n\n", "pragma": "omp parallel for default (none) shared (stateVecSize, stateVecReal,stateVecImag ) private (index,targetBit,stateRealLo,stateImagLo) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josthoma/Distributed-Quantum-Computing/QuEST/testCode/eceBenchmark_0812/1"}
{"code": "for (k = 0; k < (nz + 1); k++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    for (ll = 0; ll < NUM_VARS; ll++)\n    {\n      for (s = 0; s < sten_size; s++)\n      {\n        inds = ((((ll * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + s) * (nx + (2 * hs)))) + i) + hs;\n        stencil[s] = state[inds];\n      }\n\n      vals[ll] = ((((-stencil[0]) / 12) + ((7 * stencil[1]) / 12)) + ((7 * stencil[2]) / 12)) - (stencil[3] / 12);\n      d3_vals[ll] = (((-stencil[0]) + (3 * stencil[1])) - (3 * stencil[2])) + stencil[3];\n    }\n\n    r = vals[ID_DENS] + hy_dens_int[k];\n    u = vals[ID_UMOM] / r;\n    w = vals[ID_WMOM] / r;\n    t = (vals[ID_RHOT] + hy_dens_theta_int[k]) / r;\n    p = (C0 * pow(r * t, gamm)) - hy_pressure_int[k];\n    if ((k == 0) || (k == nz))\n    {\n      w = 0;\n      d3_vals[ID_DENS] = 0;\n    }\n\n    flux[(((ID_DENS * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i] = (r * w) - (hv_coef * d3_vals[ID_DENS]);\n    flux[(((ID_UMOM * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i] = ((r * w) * u) - (hv_coef * d3_vals[ID_UMOM]);\n    flux[(((ID_WMOM * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i] = (((r * w) * w) + p) - (hv_coef * d3_vals[ID_WMOM]);\n    flux[(((ID_RHOT * (nz + 1)) * (nx + 1)) + (k * (nx + 1))) + i] = ((r * w) * t) - (hv_coef * d3_vals[ID_RHOT]);\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(2) private(ll,s,inds,stencil,vals,d3_vals,r,u,w,t,p)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-omp/main/3"}
{"code": "for (i = RowCount - 1; i >= 0; i--)\n{\n  free(NewCellArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-omp-examples/heat1/7"}
{"code": "for (iterator cond_it = mrDestinationModelPart.ConditionsBegin(); cond_it != mrDestinationModelPart.ConditionsEnd(); cond_it++)\n{\n  for (unsigned int i = 0; i < 3; i++)\n  {\n    double dist = 0.0;\n    int Status = 0;\n    mGaussPointList[GPiter + i]->GetProjStatus(Status);\n    if (Status != 0)\n    {\n      mGaussPointList[GPiter + i]->GetDist(dist);\n      if (Status == 2)\n      {\n        dist = -sqrt(dist);\n      }\n\n    }\n    else\n    {\n      dist = -10000;\n    }\n\n    cond_it->GetGeometry()[i].FastGetSolutionStepValue(FICTITIOUS_FLUID_DENSITY) = dist;\n  }\n\n  GPiter += 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/FSIApplication/custom_utilities/AdvancedNMPointsMapper/3"}
{"code": "for (i = 0; i < (argc - 2); i++)\n  free(storms[i].posval);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bayons/OpenMP/Practica/energy_v2/8"}
{"code": "for (i = 100; i > i_peak3; i--)\n{\n  if (histogram[i] < bottom3b)\n  {\n    bottom3b = histogram[i];\n    i_bottom3b = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ALB/alb/9"}
{"code": "for (int i = 0; i < height; i++)\n{\n  floatpng[i] = (float *) malloc((sizeof(float *)) * width);\n  for (int j = 0; j < width; j++)\n    floatpng[i][j] = bytepng[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmaeilkeshavarz/Edge-detection-with-C-using-OpenMp/phase2/2"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < columns; ++j)\n  {\n    m[(i * columns) + j] = min + (rand() % ((max + 1) - min));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/contrerasmiguel/matrix-multiplication/openmp/main/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  a[j] = b[j];\n}\n\n", "pragma": "omp target teams distribute parallel for num_teams(N/256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/teams512-info/teams512-info/0"}
{"code": "for (unsigned int i = 0; i < dimFactorVector.size(); ++i)\n{\n  shrinkDimensionality(iter_no);\n  dimFactorVector[i] = dimFactors;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/0"}
{"code": "for (int i = 0; i < (Size - 1); i++)\n  for (int j = 1; j < (Size - i); j++)\n  if (pData[j - 1] > pData[j])\n  swap(pData[j - 1], pData[j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/sort/2"}
{"code": "for (i = 0; i < M; i++)\n{\n  if (i < (R % M))\n  {\n    sizedim[i] = (R / M) + 1;\n    start[i] = ((R / M) + 1) * i;\n  }\n  else\n  {\n    sizedim[i] = R / M;\n    start[i] = (((R / M) + 1) * (R % M)) + ((R / M) * (i - (R % M)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/2"}
{"code": "for (j = 0; j <= i; j++)\n{\n  k = i - j;\n  x = i % 3;\n  if ((k == 0) && (j == 0))\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = 0;\n\n  }\n  else\n    if (k == 0)\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = a[(i - 1) % 3][j - 1];\n\n  }\n  else\n    if (j == 0)\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = a[(i - 1) % 3][j];\n\n  }\n  else\n  {\n    if (X[k] == Y[j])\n      a[x][j] = a[(i - 2) % 3][j - 1] + 1;\n    else\n      a[x][j] = (a[(i - 1) % 3][j] >= a[(i - 1) % 3][j - 1]) ? (a[(i - 1) % 3][j]) : (a[(i - 1) % 3][j - 1]);\n\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for private(j,k,x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_cache_improved/0"}
{"code": "for (j = 7; j < URL.length(); j++)\n{\n  if ((URL[j] == '/') && (URL[j - 1] != '/'))\n    val = j;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Po-Y-H/Parallel-Web-Crawler-by-OpenMP/03_ps/Crawler/3"}
{"code": "for (iter = 0; iter < my_args.iterations; iter++)\n{\n  r_index = iter % 2;\n  flag_corner_ul = 0;\n  flag_corner_ur = 0;\n  flag_corner_ll = 0;\n  flag_corner_lr = 0;\n  MPI_Startall(NUM_NEIGHBOURS, send_requests[r_index]);\n  for (i = 2; i < my_height; i++)\n  {\n    for (j = 2 * mult; j < my_width; j++)\n    {\n      (*im_after)[i][j] = (int) ((((((((((*im_before)[i][j] * my_args.filter[1][1]) + ((*im_before)[i - 1][j] * my_args.filter[0][1])) + ((*im_before)[i - 1][j + mult] * my_args.filter[0][2])) + ((*im_before)[i][j + mult] * my_args.filter[1][2])) + ((*im_before)[i + 1][j + mult] * my_args.filter[2][2])) + ((*im_before)[i + 1][j] * my_args.filter[2][1])) + ((*im_before)[i + 1][j - mult] * my_args.filter[2][0])) + ((*im_before)[i][j - mult] * my_args.filter[1][0])) + ((*im_before)[i - 1][j - mult] * my_args.filter[0][0]));\n      if ((*im_after)[i][j] < 0)\n        (*im_after)[i][j] = 0;\n      else\n        if ((*im_after)[i][j] > 255)\n        (*im_after)[i][j] = 255;\n\n\n    }\n\n  }\n\n  MPI_Startall(NUM_NEIGHBOURS, recv_requests[r_index]);\n  for (k = 0; k < NUM_NEIGHBOURS; k++)\n  {\n    MPI_Waitany(NUM_NEIGHBOURS, recv_requests[r_index], &index, &recv_stat);\n    if (index == N)\n    {\n      flag_corner_ul++;\n      flag_corner_ur++;\n      for (j = 2 * mult; j < my_width; j++)\n      {\n        (*im_after)[1][j] = (int) ((((((((((*im_before)[1][j] * my_args.filter[1][1]) + ((*im_before)[0][j] * my_args.filter[0][1])) + ((*im_before)[0][j + mult] * my_args.filter[0][2])) + ((*im_before)[1][j + mult] * my_args.filter[1][2])) + ((*im_before)[2][j + mult] * my_args.filter[2][2])) + ((*im_before)[2][j] * my_args.filter[2][1])) + ((*im_before)[2][j - mult] * my_args.filter[2][0])) + ((*im_before)[1][j - mult] * my_args.filter[1][0])) + ((*im_before)[0][j - mult] * my_args.filter[0][0]));\n        if ((*im_after)[1][j] < 0)\n          (*im_after)[1][j] = 0;\n        else\n          if ((*im_after)[1][j] > 255)\n          (*im_after)[1][j] = 255;\n\n\n      }\n\n    }\n    else\n      if (index == NE)\n    {\n      flag_corner_ur++;\n    }\n    else\n      if (index == E)\n    {\n      flag_corner_ur++;\n      flag_corner_lr++;\n      for (i = 2; i < my_height; i++)\n      {\n        for (j = 0; j < mult; j++)\n        {\n          (*im_after)[i][my_width + j] = (int) ((((((((((*im_before)[i][my_width + j] * my_args.filter[1][1]) + ((*im_before)[i - 1][my_width + j] * my_args.filter[0][1])) + ((*im_before)[i - 1][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[i][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[i + 1][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[i + 1][my_width + j] * my_args.filter[2][1])) + ((*im_before)[i + 1][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[i][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[i - 1][my_width_decr_1 + j] * my_args.filter[0][0]));\n          if ((*im_after)[i][my_width + j] < 0)\n            (*im_after)[i][my_width + j] = 0;\n          else\n            if ((*im_after)[i][my_width + j] > 255)\n            (*im_after)[i][my_width + j] = 255;\n\n\n        }\n\n      }\n\n    }\n    else\n      if (index == SE)\n    {\n      flag_corner_lr++;\n    }\n    else\n      if (index == S)\n    {\n      flag_corner_ll++;\n      flag_corner_lr++;\n      for (j = 2 * mult; j < my_width; j++)\n      {\n        (*im_after)[my_height][j] = (int) ((((((((((*im_before)[my_height][j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][j + mult] * my_args.filter[0][2])) + ((*im_before)[my_height][j + mult] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][j + mult] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][j - mult] * my_args.filter[2][0])) + ((*im_before)[my_height][j - mult] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][j - mult] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][j] < 0)\n          (*im_after)[my_height][j] = 0;\n        else\n          if ((*im_after)[my_height][j] > 255)\n          (*im_after)[my_height][j] = 255;\n\n\n      }\n\n    }\n    else\n      if (index == SW)\n    {\n      flag_corner_ll++;\n    }\n\n\n\n\n\n\n    if (index == W)\n    {\n      flag_corner_ul++;\n      flag_corner_ll++;\n      for (i = 2; i < my_height; i++)\n      {\n        for (j = 0; j < mult; j++)\n        {\n          (*im_after)[i][mult + j] = (int) ((((((((((*im_before)[i][mult + j] * my_args.filter[1][1]) + ((*im_before)[i - 1][mult + j] * my_args.filter[0][1])) + ((*im_before)[i - 1][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[i][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[i + 1][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[i + 1][mult + j] * my_args.filter[2][1])) + ((*im_before)[i + 1][j] * my_args.filter[2][0])) + ((*im_before)[i][j] * my_args.filter[1][0])) + ((*im_before)[i - 1][j] * my_args.filter[0][0]));\n          if ((*im_after)[i][mult + j] < 0)\n            (*im_after)[i][mult + j] = 0;\n          else\n            if ((*im_after)[i][mult + j] > 255)\n            (*im_after)[i][mult + j] = 255;\n\n\n        }\n\n      }\n\n    }\n\n    if (index == NW)\n    {\n      flag_corner_ul++;\n    }\n\n    if (flag_corner_ul == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[1][mult + j] = (int) ((((((((((*im_before)[1][mult + j] * my_args.filter[1][1]) + ((*im_before)[0][mult + j] * my_args.filter[0][1])) + ((*im_before)[0][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[1][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[2][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[2][mult + j] * my_args.filter[2][1])) + ((*im_before)[2][j] * my_args.filter[2][0])) + ((*im_before)[1][j] * my_args.filter[1][0])) + ((*im_before)[0][j] * my_args.filter[0][0]));\n        if ((*im_after)[1][mult + j] < 0)\n          (*im_after)[1][mult + j] = 0;\n        else\n          if ((*im_after)[1][mult + j] > 255)\n          (*im_after)[1][mult + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_ur == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[1][my_width + j] = (int) ((((((((((*im_before)[1][my_width + j] * my_args.filter[1][1]) + ((*im_before)[0][my_width + j] * my_args.filter[0][1])) + ((*im_before)[0][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[1][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[2][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[2][my_width + j] * my_args.filter[2][1])) + ((*im_before)[2][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[1][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[0][my_width_decr_1 + j] * my_args.filter[0][0]));\n        if ((*im_after)[1][my_width + j] < 0)\n          (*im_after)[1][my_width + j] = 0;\n        else\n          if ((*im_after)[1][my_width + j] > 255)\n          (*im_after)[1][my_width + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_lr == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[my_height][my_width + j] = (int) ((((((((((*im_before)[my_height][my_width + j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][my_width + j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[my_height][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][my_width + j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[my_height][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][my_width_decr_1 + j] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][my_width + j] < 0)\n          (*im_after)[my_height][my_width + j] = 0;\n        else\n          if ((*im_after)[my_height][my_width + j] > 255)\n          (*im_after)[my_height][my_width + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_ll == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[my_height][mult + j] = (int) ((((((((((*im_before)[my_height][mult + j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][mult + j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[my_height][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][mult + j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][j] * my_args.filter[2][0])) + ((*im_before)[my_height][j] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][j] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][mult + j] < 0)\n          (*im_after)[my_height][mult + j] = 0;\n        else\n          if ((*im_after)[my_height][mult + j] > 255)\n          (*im_after)[my_height][mult + j] = 255;\n\n\n      }\n\n    }\n\n  }\n\n  MPI_Waitall(NUM_NEIGHBOURS, send_requests[r_index], (MPI_Status *) 1);\n  equality_flag = 0;\n  for (i = 1; (i < my_height_incr_1) && (equality_flag == 0); i++)\n  {\n    for (j = mult; j < my_width_incr_1; j++)\n    {\n      if ((*im_after)[i][j] != (*im_before)[i][j])\n      {\n        equality_flag = 1;\n        break;\n      }\n\n    }\n\n  }\n\n  MPI_Allreduce(&equality_flag, &all_finished, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000007, my_cartesian_comm);\n  if (((my_rank == 0) && (print_message == 0)) && (all_finished == 0))\n  {\n    printf(\"Image convergence at %d iteration\\n\", iter);\n    print_message = 1;\n  }\n\n  tmp = im_before;\n  im_before = im_after;\n  im_after = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/10"}
{"code": "for (k = i + 1; k < m; k++)\n{\n  term = a[k][i] / a[i][i];\n  for (j = 0; j < m; j++)\n  {\n    a[k][j] = a[k][j] - (term * a[i][j]);\n  }\n\n  b[k] = b[k] - (term * b[i]);\n}\n\n", "pragma": "omp parallel for private(term,k,j) schedule(static,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaeldcampbell/GaussianEliminationParallel/src/openMPGaussianElimination/1"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  counter++;\n  printf(\"Thread id: %d, i: %d, counter: %d\\n\", omp_get_thread_num(), i, counter);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest06/simple_test_06/0"}
{"code": "for (i = starti; i < rows; i++)\n{\n  for (j = 0; j < NY; j++)\n  {\n    x = xmin + (i * dx);\n    y = ymin + (j * dy);\n    if (world_rank == 0)\n    {\n      iters_s[(((WIDTH / world_size) - (rows - i)) * WIDTH) + j] = Mandelbrot_Member(x, y);\n    }\n    else\n    {\n      iters[(((WIDTH / world_size) - (rows - i)) * WIDTH) + j] = Mandelbrot_Member(x, y);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(NUM_THREADS) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mareckste/mandelbrot_set/sources/mandelbrot_openmp_mpi_opengl/2"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  temp[i] = distances[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/vptree/src/vptree_openmp/3"}
{"code": "for (row = 0; row <= (my_num_rows + 1); row++)\n{\n  exit_if((current_grid[row] = (int *) malloc((NUM_COLS + 2) * (sizeof(int)))) == 0, \"malloc(current_grid[some_row])\", my_rank);\n  exit_if((next_grid[row] = (int *) malloc((NUM_COLS + 2) * (sizeof(int)))) == 0, \"malloc(next_grid[some_row])\", my_rank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/life/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (fabs(output[i] - expected_output[i]) > error_rate)\n  {\n    error_rate = fabs(output[i] - expected_output[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/geodesic-omp/main/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  str_arr[i] = (char *) malloc(256 * (sizeof(char)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/test/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  m = (k * ((double) i)) / 2.0;\n  a[i] = b[i] + m;\n}\n\n", "pragma": "  #pragma omp parallel for firstprivate(k) \\", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/firstprivate_lastprivate/0"}
{"code": "for (int thread = 0; thread < threads; thread++)\n{\n  int end;\n  if ((thread + 1) == threads)\n  {\n    end = width * height;\n  }\n  else\n  {\n    end = pixel_per_thread * (thread + 1);\n  }\n\n  for (int i = pixel_per_thread * thread; i < end; i++)\n  {\n    result[i] = ((0.2126 * img[i * channels]) + (0.7152 * img[(i * channels) + 1])) + (0.0722 * img[(i * channels) + 2]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiangRongLin/grayscale-conversion/cpu/algorithms/memory/0"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    y0 = (i * ((upper - lower) / height)) + lower;\n    x0 = (j * ((right - left) / width)) + left;\n    x = 0;\n    y = 0;\n    distance = 0;\n    intensity = 0;\n    while ((intensity < iterationMax) && (distance < 4.0))\n    {\n      tmp = ((x * x) - (y * y)) + x0;\n      y = ((2 * x) * y) + y0;\n      x = tmp;\n      distance = (x * x) + (y * y);\n      intensity++;\n    }\n\n    image[(i * width) + j] = intensity;\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zululin/PP_Hw2/ms_omp/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    sum = 0;\n    for (k = 0; k < 500; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanGit/Threads-OpenMP/Threads-OpenMP/OpenMP/task2_4/2"}
{"code": "for (n = 0; n < (N + L); n++)\n  Covr(n, n) = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_mud/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/69"}
{"code": "for (i = 0; i < (this->ROWS - 3); i++)\n{\n  for (j = 0; j < (this->COLS - 3); j++)\n  {\n    window.push_back(board[i + 3][j]);\n    window.push_back(board[i + 2][j + 1]);\n    window.push_back(board[i + 1][j + 2]);\n    window.push_back(board[i][j + 3]);\n    score += evaluateWindow(window, player);\n    window.clear();\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(3) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/Board/5"}
{"code": "for (i = 1; i <= ((int) num_steps); i++)\n{\n  x = (i - 0.5) * step;\n  d = step * sqrt(1.0 - (x * x));\n  sum = sum + d;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum) private(i, x, d) shared(step), default(none)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thedomdom/openmp/pi/0"}
{"code": "for (q = 0; q < Nqd; q++)\n{\n  PolPol = (quads(q, 2) * Polt.block(q, 0, 1, k + 1).transpose()) * Poltau.block(q, 0, 1, k + 2);\n  Kdq.setZero();\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, g.next(i)) = Knext(q, i);\n  }\n\n  Kprime += kron(Kdq, PolPol);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/20"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  matrix[i][0] = 0;\n  matrix[i][1] = 0;\n  matrix[i][2] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/5"}
{"code": "for (int ig = 0; ig < ngpown; ++ig)\n  inv_igp_index[ig] = ((ig + 1) * ncouls) / ngpown;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gpp-omp/main/3"}
{"code": "for (i = 0; i < NCLUSTERS; i++)\n{\n  new_centers_len[i] = 0;\n  for (j = 0; j < NFEATURES; j++)\n  {\n    new_centers[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/Heterogeniuses/opencl/kmeans/kmeans_clustering/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (k = 0; k < 50; k++)\n  {\n    for (j = 0; j < 150; j++)\n    {\n      output_matrix[i][k] += input_matrix_a[i][j] * input_matrix_b[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/takashift/experimentB_OpenMP/matrix_product/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < m; i++)\n  {\n    if ((((i == 0) || (i == (m - 1))) || (j == 0)) || (j == (n - 1)))\n    {\n      error = u_old[i + (j * m)] - f[i + (j * m)];\n    }\n    else\n    {\n      error = ((((ax * (u_old[(i - 1) + (j * m)] + u_old[(i + 1) + (j * m)])) + (ay * (u_old[i + ((j - 1) * m)] + u_old[i + ((j + 1) * m)]))) + (b * u_old[i + (j * m)])) - f[i + (j * m)]) / b;\n    }\n\n    u[i + (j * m)] = u_old[i + (j * m)] - (omega * error);\n    error_norm = error_norm + (error * error);\n  }\n\n}\n\n", "pragma": "omp for reduction ( + : error_norm )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_host/helmholtz/4"}
{"code": "for (int i = 0; i < m_nCells; ++i)\n{\n  m_q[i] = 0.0f;\n  m_h[i] = 0.f;\n  m_hReturnFlow[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/IKW_IF/InterFlow_IKW/0"}
{"code": "for (i = 0; i < 5; i++)\n  suma = suma + 1;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Canario0/Openmp/Pruebas/Secciones/0"}
{"code": "for (thread = 0; thread < thread_count; thread++)\n{\n  pthread_join(thread_handles[thread], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/7"}
{"code": "for (int ii = 1; ii < (params.ny - 1); ++ii)\n{\n  sendbuf[(ii - 1) * 3] = cells[(ii * params.nx) + line].speeds[5];\n  sendbuf[((ii - 1) * 3) + 1] = cells[(ii * params.nx) + line].speeds[1];\n  sendbuf[((ii - 1) * 3) + 2] = cells[(ii * params.nx) + line].speeds[8];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/12"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < p; k++)\n    {\n      A[i][k] = rand();\n      B[k][j] = rand();\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code7777/MatrixMultiplierParallelProcessing/hw1/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[4 * (i + (lxv * j))] = fxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (4 * (i + (lxv * j)))] = fxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[2 + (4 * (i + (lxv * j)))] = fxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[4 * (i + (lxv * j))] = bxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[1 + (4 * (i + (lxv * j)))] = bxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[2 + (4 * (i + (lxv * j)))] = bxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      nn = x;\n      mm = y;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      n[j] = 4 * ((nn - noff) + (lxv * (mm - moff)));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      s1[j] = amx * amy;\n      s1[j + 32] = dxp * amy;\n      s1[j + (2 * 32)] = amx * dyp;\n      s1[j + (3 * 32)] = dxp * dyp;\n      t[j] = x;\n      t[j + 32] = y;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = nn + (4 * (lxv - 2));\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      #pragma ivdep\n      for (i = 0; i < 4; i++)\n      {\n        if (i > 1)\n          nn = mm;\n\n        dx += sfxy[(4 * i) + nn] * s1[j + (32 * i)];\n        dy += sfxy[(1 + (4 * i)) + nn] * s1[j + (32 * i)];\n        dz += sfxy[(2 + (4 * i)) + nn] * s1[j + (32 * i)];\n        ox += sbxy[(4 * i) + nn] * s1[j + (32 * i)];\n        oy += sbxy[(1 + (4 * i)) + nn] * s1[j + (32 * i)];\n        oz += sbxy[(2 + (4 * i)) + nn] * s1[j + (32 * i)];\n      }\n\n      s1[j] = dx;\n      s1[j + 32] = dy;\n      s1[j + (2 * 32)] = dz;\n      s2[j] = ox;\n      s2[j + 32] = oy;\n      s2[j + (2 * 32)] = oz;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      dx = qtmh * s1[j];\n      dy = qtmh * s1[j + 32];\n      dz = qtmh * s1[j + (2 * 32)];\n      acx = ppart[((j + joff) + (2 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (3 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (4 * nppmx)) + npoff] + dz;\n      p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n      gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n      qtmg = qtmh * gami;\n      sum1 += (gami * p2) / (1.0f + gami);\n      omxt = qtmg * s2[j];\n      omyt = qtmg * s2[j + 32];\n      omzt = qtmg * s2[j + (2 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n      dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n      s1[j] = x + (vx * dtg);\n      s1[j + 32] = y + (vy * dtg);\n      s2[j] = vx;\n      s2[j + 32] = vy;\n      s2[j + (2 * 32)] = vz;\n    }\n\n    #pragma novector\n    for (j = 0; j < 32; j++)\n    {\n      dx = s1[j];\n      dy = s1[j + 32];\n      vx = s2[j];\n      vy = s2[j + 32];\n      vz = s2[j + (2 * 32)];\n      if (ipbc == 2)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n      }\n      else\n        if (ipbc == 3)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = vx;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = vy;\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = vz;\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (lxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * lxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * lxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,noff,moff,npp,npoff,ipp,joff,nps,nn,mm,nm,x,y,vx,vy,vz, dxp,dyp,amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm, rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,p2,gami,qtmg,dtg,sum1, sfxy,sbxy,n,s1,s2,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/8"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  Phi *= GT;\n  oMinusPhi *= 1 - GT;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Fibonacci/Parallelization/main/0"}
{"code": "for (i = 1; i < my_height_incr_2; i++)\n  my_image_after[i] = &my_image_after[0][i * my_width_incr_2];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/5"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((((x[i] < axx.amin) || (x[i] >= axx.amax)) || (y[i] < axy.amin)) || (y[i] >= axy.amax))\n    continue;\n\n  by = calc_bin(y[i], axy.amin, normy);\n  bx = calc_bin(x[i], axx.amin, normx);\n  bin = by + (nby * bx);\n  values_px[bin] += w[i];\n  variances_px[bin] += w[i] * w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/43"}
{"code": "for (size_t i = 0; i < (n - 1); i++)\n{\n  paths[i] = path_create(n + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcullo/travelling-salesman-problem/c/src/solvers/solver_openmp/1"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min; j <= (x_max + 1); j++)\n  {\n    node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = 0.25 * (((mass_flux_y[FTNREF2D(j - 1, k, x_max + 4, x_min - 2, y_min - 2)] + mass_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) + mass_flux_y[FTNREF2D(j - 1, k + 1, x_max + 4, x_min - 2, y_min - 2)]) + mass_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/8"}
{"code": "for (unsigned i = 1; i <= n; ++i)\n  sum += i;\n\n", "pragma": "  #pragma omp parallel for reduction(+:sum) schedule(auto)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/archie230/parprog_2021/task2/main/0"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int x = 0; x < GRAIN; x++)\n  {\n    for (int y = 0; y < GRAIN; y++)\n    {\n      if (current_array[(x * GRAIN) + y] == 1)\n      {\n        current_array[(x * GRAIN) + y] = 0;\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            compute_new_state(i, j);\n            if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n            {\n              next_array[(x * GRAIN) + y] = 1;\n              if (((i % TILEX) == 0) && (x > 0))\n              {\n                next_array[((x - 1) * GRAIN) + y] = 1;\n                if (((j % TILEY) == 0) && (y > 0))\n                {\n                  next_array[((x - 1) * GRAIN) + (y - 1)] = 1;\n                }\n\n                if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n                {\n                  next_array[((x - 1) * GRAIN) + (y + 1)] = 1;\n                }\n\n              }\n\n              if (((i % TILEX) == (TILEX - 1)) && (x < (GRAIN - 1)))\n              {\n                next_array[((x + 1) * GRAIN) + y] = 1;\n                if (((j % TILEY) == 0) && (y > 0))\n                {\n                  next_array[((x + 1) * GRAIN) + (y - 1)] = 1;\n                }\n\n                if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n                {\n                  next_array[((x + 1) * GRAIN) + (y + 1)] = 1;\n                }\n\n              }\n\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[(x * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[(x * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n      else\n      {\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            if (next_img(i, j) != 0xFFFF00FF)\n            {\n              next_img(i, j) = 0;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  swap_images();\n  int *tmp = current_array;\n  current_array = next_array;\n  next_array = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/21"}
{"code": "for (int i = 0; i < VECTOR_SIZE; i++)\n{\n  product += vectorA[i] * vectorB[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/J3FALL/HPC-OpenMP/main/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  grid[i] = (Grid *) malloc((sizeof(Grid)) * size);\n  for (j = 0; j < size; j++)\n  {\n    grid[i][j].center.x = 0;\n    grid[i][j].center.y = 0;\n    grid[i][j].M = 0;\n    grid[i][j].Mnext = 0;\n    grid[i][j].par_list = initLinkedList();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelV/grid/4"}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%f \", vec[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/12_omp_mat_vec_mul/4"}
{"code": "for (j1 = 1; j1 < (4096 + 1); j1++)\n{\n  for (j2 = j1; j2 < (4096 + 1); j2++)\n  {\n    symmat[(j1 * (4096 + 1)) + j2] = 0.0;\n    for (int i = 1; i < (4096 + 1); i++)\n    {\n      symmat[(j1 * (4096 + 1)) + j2] += data[(i * (4096 + 1)) + j1] * data[(i * (4096 + 1)) + j2];\n    }\n\n    symmat[(j2 * (4096 + 1)) + j1] = symmat[(j1 * (4096 + 1)) + j2];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/COVAR/covariance_cpu/8"}
{"code": "for (n = 0; n < (k + 1); n++)\n{\n  m = k - n;\n  for (x = 0; x < chunk_size; x++)\n    for (y = 0; y < chunk_size; y++)\n  {\n    i = (x + 1) + (n * chunk_size);\n    j = (y + 1) + (m * chunk_size);\n    e = A[i][j];\n    A[i][j] = (((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.;\n    E[n][m] = (E[n][m] > fabs(e - A[i][j])) ? (E[n][m]) : (fabs(e - A[i][j]));\n  }\n\n\n}\n\n", "pragma": "omp parallel for shared(A, E, k) private(n, m, x, y, i, j, e)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artem-bondar/parallel-programming/sor_2d_omp/0"}
{"code": "for (r = 0; r < 6; r++)\n{\n  for (m = 0; m < (358 * 638); m++)\n  {\n    y[((r * 358) * 638) + m] = bias[r];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-tavana/CNN_OPENMP/conv_layer4/0"}
{"code": "for (int filter_len = 8; filter_len <= 256; filter_len *= 2)\n{\n  printf(\"Collecting timing data for filter of length %d\\n\", filter_len);\n  serialDataFirst((512 * 512) * 128, input_array, serial_array, filter_len, filter_list);\n  memset(output_array, 0, (512 * 512) * 128);\n  serialFilterFirst((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelDataFirst((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelFilterFirst((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelDataFirstUnrolledFilter((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelFilterFirstUnrolledFilter((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelDataFirstUnrolledData((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n  parallelFilterFirstUnrolledData((512 * 512) * 128, input_array, output_array, filter_len, filter_list);\n  checkData(serial_array, output_array);\n  memset(output_array, 0, (512 * 512) * 128);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hsouri/OpenMP-Filter/filter/5"}
{"code": "for (int i = 1; i <= 8; ++i)\n{\n  label.read(&number, sizeof(char));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/22"}
{"code": "for (int frame = 0; frame < frames; frame++)\n{\n  my_delta = Delta * pow(0.99, frame + 1);\n  const double xMin = xMid - my_delta;\n  const double yMin = yMid - my_delta;\n  const double dw = (2.0 * my_delta) / width;\n  for (int row = 0; row < width; row++)\n  {\n    const double cy = (-yMin) - (row * dw);\n    for (int col = 0; col < width; col++)\n    {\n      const double cx = (-xMin) - (col * dw);\n      double x = cx;\n      double y = cy;\n      int depth = 256;\n      double x2;\n      double y2;\n      do\n      {\n        x2 = x * x;\n        y2 = y * y;\n        y = ((2 * x) * y) + cy;\n        x = (x2 - y2) + cx;\n        depth--;\n      }\n      while ((depth > 0) && ((x2 + y2) < 5.0));\n      pic[(((frame * width) * width) + (row * width)) + col] = (unsigned char) depth;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xyzst/OMP-and-Mandelbrot/fractal_omp/0"}
{"code": "for (iter = 0; iter < max_iter; iter++)\n{\n  h11 = sigma;\n  h22 = sigma;\n  h21 = 0.0;\n  g1 = 0.0;\n  g2 = 0.0;\n  for (i = 0; i < l; i++)\n  {\n    fApB = (dec_values[i] * A) + B;\n    if (fApB >= 0)\n    {\n      p = exp(-fApB) / (1.0 + exp(-fApB));\n      q = 1.0 / (1.0 + exp(-fApB));\n    }\n    else\n    {\n      p = 1.0 / (1.0 + exp(fApB));\n      q = exp(fApB) / (1.0 + exp(fApB));\n    }\n\n    d2 = p * q;\n    h11 += (dec_values[i] * dec_values[i]) * d2;\n    h22 += d2;\n    h21 += dec_values[i] * d2;\n    d1 = t[i] - p;\n    g1 += dec_values[i] * d1;\n    g2 += d1;\n  }\n\n  if ((fabs(g1) < eps) && (fabs(g2) < eps))\n    break;\n\n  det = (h11 * h22) - (h21 * h21);\n  dA = (-((h22 * g1) - (h21 * g2))) / det;\n  dB = (-(((-h21) * g1) + (h11 * g2))) / det;\n  gd = (g1 * dA) + (g2 * dB);\n  stepsize = 1;\n  while (stepsize >= min_step)\n  {\n    newA = A + (stepsize * dA);\n    newB = B + (stepsize * dB);\n    newf = 0.0;\n    for (i = 0; i < l; i++)\n    {\n      fApB = (dec_values[i] * newA) + newB;\n      if (fApB >= 0)\n        newf += (t[i] * fApB) + log(1 + exp(-fApB));\n      else\n        newf += ((t[i] - 1) * fApB) + log(1 + exp(fApB));\n\n    }\n\n    if (newf < (fval + ((0.0001 * stepsize) * gd)))\n    {\n      A = newA;\n      B = newB;\n      fval = newf;\n      break;\n    }\n    else\n      stepsize = stepsize / 2.0;\n\n  }\n\n  if (stepsize < min_step)\n  {\n    info(\"Line search fails in two-class probability estimates\\n\");\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/41"}
{"code": "for (int i = 0; i < sizeOfMatrix; i++)\n{\n  for (int j = 0; j < sizeOfMatrix; j++)\n  {\n    (cout << matrixToDisplay[i][j]) << \" \";\n  }\n\n  (cout << \" \\n\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sajidamro/eclipse-workspace/Lab_1/matrix_Multi/2"}
{"code": "for (int j = 0; j < 1000000; j++)\n  sum += arr[j];\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Supercool1604/OpenMP-Codes/sum/0"}
{"code": "for (int j = 0; j < asteps; j++)\n  WA[j] = ww(j / ((T) (asteps - 1))) * (1.0 / ((T) (asteps - 1)));\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/5"}
{"code": "for (int i = 0; i < this->input_neurons; i++)\n{\n  for (int j = 0; j < this->output_neurons; j++)\n  {\n    *((w_t + (j * input_neurons)) + i) = *((this->weights + (i * this->output_neurons)) + j);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/Linear Layer - ANN/Linear/4"}
{"code": "for (i = 1; i < n; i += 2)\n{\n  if (a[i - 1] > a[i])\n  {\n    temp = a[i - 1];\n    a[i - 1] = a[i];\n    a[i] = temp;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mishal23/parallel-programming-openmp/brick-sort/brick-sort/0"}
{"code": "for (int i = max_cols - 4; i >= 0; i--)\n{\n  for (idx = 0; idx <= i; idx++)\n  {\n    index = ((((((max_cols - idx) - 2) * max_cols) + idx) + max_cols) - i) - 2;\n    input_itemsets[index] = maximum(input_itemsets[(index - 1) - max_cols] + referrence[index], input_itemsets[index - 1] - penalty, input_itemsets[index - max_cols] - penalty);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nw/needle/8"}
{"code": "for (i = 0; i < pcinfo.x_cells_num; i++)\n{\n  send_message_td[i] = f[((pcinfo.y_cells_num - 1) * pcinfo.x_cells_num) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/4"}
{"code": "for (int i = 0; i < rowCount; i++)\n{\n  for (int j = 0; j < colCount; j++)\n  {\n    if (tempMatrix[i][j] != 0)\n    {\n      nonZeroCount++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/2"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j <= i; ++j)\n  {\n    A[i][j] = p_low[i][j];\n  }\n\n  for (j = i + 1; j < n; ++j)\n  {\n    A[i][j] = p_up[i][j];\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhinav-vaishya/Parallel-Computing---MPI-OpenMP-CUDA/codes/Q4/8"}
{"code": "for (i = 0; i < nendmembers; i++)\n{\n  if ((ata[i] = calloc(nendmembers, sizeof(double))) == 0)\n  {\n    puts(\"Error in (buffer) Memory Allocation.\");\n    exit(-1);\n  }\n\n  if ((ata_inv[i] = calloc(nendmembers, sizeof(double))) == 0)\n  {\n    puts(\"Error in (buffer) Memory Allocation.\");\n    exit(-1);\n  }\n\n  if ((N[i] = calloc(bands, sizeof(double))) == 0)\n  {\n    puts(\"Error in (buffer) Memory Allocation.\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/Unmixing/0"}
{"code": "for (i = 0; i < m1->numFilas; i++)\n{\n  for (j = 0; j < m2->numColumnas; j++)\n  {\n    temporal = 0.0;\n    for (k = 0; k < m1->numColumnas; k++)\n    {\n      temporal += m1->datos[i][j] * m2->datos[k][j];\n    }\n\n    m3->datos[i][j] = temporal;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaelmanzanorivera/matrix-dot-prod-optimization-OpenMP/matricesOmp/5"}
{"code": "for (int i = start; i < end; i++)\n{\n  max = (data[i].data[dim] > max) ? (data[i].data[dim]) : (max);\n  min = (data[i].data[dim] < min) ? (data[i].data[dim]) : (min);\n}\n\n", "pragma": "omp for reduction(max:max) reduction(min:min)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erikalena/hpc_assignment2/src/sorting_data/0"}
{"code": "for (i = 0; i < A->nzmax; i++)\n{\n  A->values[i] = rand() / 32768.0;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/cg/6"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  resetVec(&centres[i][0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project2/K-Means-OpenMP/8"}
{"code": "for (int j = 0; j < (700 - 1); j++)\n{\n  for (int i = 1; i < (1000 - 1); i++)\n  {\n    y[j + 1][i] = y[j][i] - (alpha * (y[j][i] - y[j][i - 1]));\n  }\n\n}\n\n", "pragma": "omp parallel for shared(y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juandapradam12/JuanPrada_Ejercicio30/advectionOPENMP/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  sum += max_;\n}\n\n", "pragma": "#pragma omp for private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/4/lab4/Source/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    (*res)[i][j] = (P[i][j] + P[j][i]) * 0.5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/12"}
{"code": "for (i = 0; i < 5000; i++)\n{\n  j = (i * i) % 5000;\n  lock_index = j % 100;\n  a[j] = a[j] - 5;\n}\n\n", "pragma": "omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lockarray/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n  A[i][j] = (((DATA_TYPE) i) * j) / ni;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/syrk/syrk/1"}
{"code": "for (m = 1; m <= 4; m += 1)\n{\n  buf[m][k] = dtpp * dtemp[m];\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dtpp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/25"}
{"code": "for (miel = 0; miel < nelt; miel++)\n{\n  iel = mt_to_id_old[miel];\n  if (!skip[iel])\n  {\n    if (ifcoa[miel])\n    {\n      action[front[miel] - 1] = miel;\n      mielnew = miel - ((front[miel] - 1) * 7);\n    }\n    else\n    {\n      mielnew = miel - (front[miel] * 7);\n    }\n\n    mt_to_id[mielnew] = iel;\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(miel,iel,mielnew)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/5"}
{"code": "for (i = i_photon; i >= 0; i--)\n{\n  PhotonStruct photon;\n  LaunchPhoton(out_parm.Rsp, In_Ptr->layerspecs, &photon);\n  do\n    HopDropSpin(In_Ptr, &photon, &out_parm);\n  while (!photon.dead);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pccr10001/mcml-openmp/mcmlmain/0"}
{"code": "for (i = 0; i < 30; i++)\n{\n  for (j = 0; j < 30; j++)\n  {\n    D[(i * 30) + j] *= 4546;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYRK/syrk/28"}
{"code": "for (unsigned int i = 0; i < kClusters.size(); i++)\n{\n  if ((copyCluster.at(i).getX() != kClusters.at(i).getX()) && (copyCluster.at(i).getY() != kClusters.at(i).getY()))\n  {\n    converged = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicholasfresneda/kmeans/openmp_impl/Cluster/2"}
{"code": "for (int x = 0; x < ScreenWidth(); x++)\n{\n  for (int y = 0; y < ScreenHeight(); y++)\n  {\n    int n = pFractalIterations[(x * ScreenHeight()) + y];\n    double t = ((double) n) / ((double) nMaxIteration);\n    int rr = (int) (((((9 * (1 - t)) * t) * t) * t) * 255);\n    int rg = (int) (((((15 * (1 - t)) * (1 - t)) * t) * t) * 255);\n    int rb = (int) (((((8.5 * (1 - t)) * (1 - t)) * (1 - t)) * t) * 255);\n    Draw(x, y, Pixel(rr, rg, rb, 255));\n  }\n\n}\n\n", "pragma": "                    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucaszm7/Mandel2Us/Application/3"}
{"code": "for (int j = 0; j < N; j++)\n  c[j] = b[j];\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/workgroup_size_option1/workgroup_size_option1/0"}
{"code": "for (i = 0; i < (N * N); i++)\n{\n  if (matriz[i] > max)\n  {\n    max = matriz[i];\n  }\n\n  if (matriz[i] < min)\n  {\n    min = matriz[i];\n  }\n\n  total += matriz[i];\n}\n\n", "pragma": "omp parallel for shared (matriz,N,max,min) reduction(+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/0"}
{"code": "for (int i = 0; i < tamlinha; i++)\n{\n  for (int j = 0; j < tamcoluna; j++)\n  {\n    cin >> matriz[i][j];\n    if (j != (tamcoluna - 1))\n      cin >> discart;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Landecrispim/Metodo-de-Gauss-cpp-OpenMP/guss/0"}
{"code": "for (int i = 0; i < 4000; ++i)\n{\n  buffer[i] = i * rank;\n}\n\n", "pragma": "omp parallel for firstprivate(buffer) schedule(static,1000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tudasc/CommPart/demo-codes/full_buffer/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  t4 = omp_get_wtime();\n  T1D[i] = ((double) rand()) / 3.33;\n  printf(\"Thread number %d fill this portion [%d] of table \\n\", omp_get_thread_num(), i);\n  t5 = omp_get_wtime() - t4;\n  printf(\"La charge du thread [%d] = %f \\n\", omp_get_thread_num(), t5 / nb_threads);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.1/0"}
{"code": "for (int i = 0; i < n_balls; i++)\n{\n  B[i].calc_force(B);\n  B[i].update_vel_half();\n  B[i].update_pos();\n  B[i].update_vel_full();\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(threads) shared(B)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_3/many-body-sim-program/5"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  fprintf(fp, \"%u %u\\n\", edgeList->edges_array_src[i], edgeList->edges_array_dest[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/7"}
{"code": "for (int i = 0; i < cluster_amount; i++)\n{\n  cluster_points_amount_arr[0][i] = clusters[i].size;\n}\n\n", "pragma": "#pragma omp parallel for shared(clusters,cluster_points_amount_arr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/18"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  dot_real += (this->vec_[i].real() * cast_x->vec_[i].real()) - (this->vec_[i].imag() * cast_x->vec_[i].imag());\n  dot_imag += (this->vec_[i].real() * cast_x->vec_[i].imag()) + (this->vec_[i].imag() * cast_x->vec_[i].real());\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : dot_real, dot_imag)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/21"}
{"code": "for (int i = 0; i < ((int) nsubranks_1d); ++i)\n{\n  out_queue_size += popcount_range(g.out_queue[i].bm.get_data(0, g.out_queue[i].bm.get_nwords()), g.out_queue[i].bm.get_length());\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:out_queue_size)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/21"}
{"code": "for (int i = 1; i < (nrow + 1); ++i)\n{\n  row_offset[i] = cast_prolong->mat_.row_offset[i] + row_offset[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/92"}
{"code": "for (i = 0; i < n; i++)\n  sumb += b[i];\n\n", "pragma": "omp parallel for default(shared)private(i)schedule(static,chunk)reduction(+:sumb)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Liangyuefeng/Multi_core-computing/OpenMP/OpenMp_codes/0"}
{"code": "for (size_t i = 0; (i = text.find(substring, i)) != npos; num++, i++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Storn5/genetic-parallelization/GeneticAlgorithms/ParallelOpenMP/ParallelOpenMP/1"}
{"code": "for (iterator ES = SrcRanges.end(); IS != ES; ++IS, ++IB, ++IE)\n{\n  Data.push_back(SimdVariant(*IS, *IB, *IE));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/1"}
{"code": "for (i = 0; i < NUM_OF_NODES; i++)\n{\n  D[i] = (double *) malloc(NUM_OF_NODES * (sizeof(double)));\n  P[i] = (double *) malloc(NUM_OF_NODES * (sizeof(double)));\n  for (j = 0; j < NUM_OF_NODES; j++)\n  {\n    D[i][j] = d[i] * options.v[j];\n    P[i][j] = E[i][j] + D[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anapt/PageRank/src/parallel/7"}
{"code": "for (int k = 0; k < nk; k++)\n  for (int j = 0; j < nj; j++)\n  inBT[(j * nk) + k] = inB[(k * nj) + j];\n\n\n", "pragma": "    #pragma omp for schedule(dynamic, ratio)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/holoubekm/BI-EIA/task_1/version_2/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char key[32];\n  unsigned char i;\n  AES_KEY aeskey;\n  int key_size;\n  if ((cur_salt->etype == 18) || (cur_salt->etype == 17))\n  {\n    if (cur_salt->etype == 18)\n    {\n      key_size = 32;\n    }\n    else\n    {\n      key_size = 16;\n    }\n\n    pbkdf2_sha1((const unsigned char *) saved_key[index], strlen(saved_key[index]), (const unsigned char *) cur_salt->saved_salt, strlen(cur_salt->saved_salt), 4096, key, key_size, 0);\n    i = 0;\n    AES_set_encrypt_key(key, key_size * 8, &aeskey);\n    AES_encrypt((unsigned char *) \"kerberos{\\x9b[+\\x93\\x13+\\x93\", (unsigned char *) crypt_out[index + i], &aeskey);\n    AES_encrypt((unsigned char *) crypt_out[index + i], (unsigned char *) (&crypt_out[index + i][4]), &aeskey);\n  }\n  else\n    if (cur_salt->etype == 3)\n  {\n    for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n    {\n      des_string_to_key_shishi(saved_key[index + i], strlen(saved_key[index + i]), cur_salt->saved_salt, strlen(cur_salt->saved_salt), (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/krb5_db_fmt_plug/2"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  vec[i] = rand();\n  copy[i] = vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/florin-alistar/AlistarSerbanFlorin_Tema1_OpenMP/radix/3"}
{"code": "for (int i = l + 1; i < vet.size(); i++)\n{\n  tab[0] = vet[i][0];\n  tab[1] = vet[i][1];\n  MPI_Send(&tab, 2, MPI_DOUBLE, rank + 3, rank + 3, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/B23579/Kd-tree-implementation/MPI_with_n_process/2"}
{"code": "for (int i = 0; i < 200; i++)\n{\n  for (int j = 0; j < 200; j++)\n  {\n    sum += B[i][j] * C[j];\n  }\n\n  A[i] = sum;\n  sum = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/8.norace3/0"}
{"code": "for (i = 0; i < x; i++)\n  input[i][0] = input1[i];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/inplace_no_rec/3"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    if (percentDiff(C[(i * 2048) + j], D[(i * 2048) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk_cpu/3"}
{"code": "for (size_t i = 0; i < v.size(); i++)\n  v[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SuperStrongDinosaur/OpenMPTest/OpenMPTest/wrong/0"}
{"code": "for (long i = 0; i < num_steps; ++i)\n{\n  x = (double) ((rand() % radius) - 1);\n  y = (double) ((rand() % radius) - 1);\n  diameter = sqrt(((x - center_x) * (x - center_x)) + ((y - center_y) * (y - center_y)));\n  if (diameter <= radius)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, y, diameter) reduction(+:count) num_threads(nthreads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q7/q7/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    a[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atanu151/Matrix-Multiplication/main/4"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  n = seqlen_array[si + 1];\n  for (i = 1, len1 = 0; i <= n; i++)\n  {\n    char c = seq_array[si + 1][i];\n    if ((c != gap_pos1) && (c != gap_pos2))\n      len1++;\n\n  }\n\n  for (sj = si + 1; sj < nseqs; sj++)\n  {\n    m = seqlen_array[sj + 1];\n    if ((n == 0) || (m == 0))\n    {\n      bench_output[(si * nseqs) + sj] = (int) 1.0;\n    }\n    else\n    {\n      _taskFunc0_((void *) 0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/alignment/src/alignment_ompi_trim/0"}
{"code": "for (j1 = 1; j1 < (8192 + 1); j1++)\n{\n  for (j2 = j1; j2 < (8192 + 1); j2++)\n  {\n    symmat[(j1 * (8192 + 1)) + j2] = 0.0;\n    for (int i = 1; i < (8192 + 1); i++)\n    {\n      symmat[(j1 * (8192 + 1)) + j2] += data[(i * (8192 + 1)) + j1] * data[(i * (8192 + 1)) + j2];\n    }\n\n    symmat[(j2 * (8192 + 1)) + j1] = symmat[(j1 * (8192 + 1)) + j2];\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for private(j1, j2, i) if(!RST_AI1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/COVAR/covariance_dawncc_kernel/2"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/20"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if (arr[i] < MinValue)\n  {\n    MinValue = arr[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ishanjogalekar/Parallel-distributed-computing-programs/Programs/reduction_arr1/0"}
{"code": "for (unsigned int elem_index = 0; elem_index < obj_const_elem.vector_dimension; elem_index++)\n{\n  obj_const_elem.values[elem_index] = constant_value;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shreyas-Gururaj/HPC_PNLA_Library_OpenMP/src/vector_omp/0"}
{"code": "for (int i = 1; i < size; i++)\n{\n  if (arr[i] > b)\n  {\n    max_loc = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Insertion-Sort-Using-OpenMP/insertion_sort_parallel/3"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  *(matrizA + i) = (int *) malloc(1000 * (sizeof(int)));\n  *(matrizB + i) = (int *) malloc(1000 * (sizeof(int)));\n  *(matrizC + i) = (int *) malloc(1000 * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Felcks/matriz_openmp/MainP/3"}
{"code": "for (j = 3; j < (grid_points[1] - 3); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/103"}
{"code": "for (i = 4; i < width; i++)\n{\n  for (j = 4; j < depth; j++)\n  {\n    results[offset(i, j, 1)] = pow(1, 10);\n    for (k = 2; k < (height + 1); k++)\n    {\n      results[offset(i, j, k)] = pow(0.9 * results[offset(i, j, k - 1)], 10);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petrosgk/Atmospheric-Model-Simulation/AtmModelMPI/6"}
{"code": "for (i = 0; i < NoofCols; i = i + 1)\n{\n  for (j = 0; j < NoofRows; j = j + 1)\n    printf(\"%f \\t\", Trans[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/6"}
{"code": "for (int i = ibegin[tid]; i < (ibegin[tid] + localn[tid]); i++)\n{\n  for (int j = 0; j < jmax; j++)\n  {\n    new_grid[i][j] = grid[i][j];\n    int num_n = num_neighbours(i, j);\n    if (grid[i][j])\n    {\n      if ((num_n != 2) && (num_n != 3))\n        new_grid[i][j] = false;\n\n    }\n    else\n      if (num_n == 3)\n      new_grid[i][j] = true;\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/acse-hz6818/OpenMP_ConwaysGame/ConwaysGame_OpenMP/1"}
{"code": "for (j_imopVar118 = 1; j_imopVar118 < (grid_points[1] - 1); j_imopVar118++)\n{\n  for (k_imopVar119 = 1; k_imopVar119 < (grid_points[2] - 1); k_imopVar119++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      for (n = 0; n < 5; n++)\n      {\n        rhs[i_imopVar117][j_imopVar118][k_imopVar119][m] = rhs[i_imopVar117][j_imopVar118][k_imopVar119][m] - (lhs[i_imopVar117][j_imopVar118][k_imopVar119][2][m][n] * rhs[i_imopVar117 + 1][j_imopVar118][k_imopVar119][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/76"}
{"code": "for (int kk = kk_min; kk < kk_max; kk++)\n{\n  for (int jj = jj_min; jj < jj_max; jj++)\n  {\n    for (int ii = ii_min; ii < ii_max; ii++)\n    {\n      ngh = evaluate_array3d_bndy(array3d, N, ii - 1, jj, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii + 1, jj, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj - 1, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj + 1, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj, kk - 1, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj, kk + 1, recvarray);\n      value = ((6. * evaluate_array3d(array3d, N, ii, jj, kk)) - ngh) / (h * h);\n      fill_array3d(vector_out, N, ii, jj, kk, value);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(ngh, value)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/matvecAv/0"}
{"code": "for (i = 0; i < array_size; i++)\n{\n  a[i] = b[i] + (scalar * c[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DaisukeMiyamoto/android-neuron-simulator/app/src/main/cpp/benchmark_daxpy/0"}
{"code": "for (uint32_t samp_i = 0; samp_i < samp_num; samp_i++)\n{\n  cent_of_samp[samp_i] = rand() % _cent_num;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoSz/parallel-kmeans/parallel_kmeans/1"}
{"code": "for (unsigned ck = 0; ck < Nkeys; ck++)\n{\n  if (makeindex)\n  {\n    SortStepIndex(ck, PrevData64, Data64, PrevIndex, Index);\n    swap(PrevIndex, Index);\n  }\n  else\n    SortStep(ck, PrevData64, Data64);\n\n  swap(PrevData64, Data64);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/13"}
{"code": "for (int c = 0; c < 7; c++)\n{\n  for (int n = 0; n < cells[c]->mesh->common_triangles_count; n++)\n  {\n    this_tri = cells[c]->mesh->common_triangles(n, 0);\n    other_cell = cells[c]->mesh->common_triangles(n, 1);\n    other_tri = cells[c]->mesh->common_triangles(n, 2);\n    v1 = cells[c]->mesh->vertices.block < 1, 3 > ((cells[c]->mesh->surface_triangles(this_tri, 0), 0));\n    v2 = cells[c]->mesh->vertices.block < 1, 3 > ((cells[c]->mesh->surface_triangles(this_tri, 1), 0));\n    v3 = cells[c]->mesh->vertices.block < 1, 3 > ((cells[c]->mesh->surface_triangles(this_tri, 2), 0));\n    c1 = ((v1 + v2) + v3) / 3.0;\n    v1 = cells[other_cell]->mesh->vertices.block < 1, 3 > ((cells[other_cell]->mesh->surface_triangles(other_tri, 0), 0));\n    v2 = cells[other_cell]->mesh->vertices.block < 1, 3 > ((cells[other_cell]->mesh->surface_triangles(other_tri, 1), 0));\n    v3 = cells[other_cell]->mesh->vertices.block < 1, 3 > ((cells[other_cell]->mesh->surface_triangles(other_tri, 2), 0));\n    c2 = ((v1 + v2) + v3) / 3.0;\n    d = (c1 - c2).norm();\n    if (d > 0.001)\n      (out << d) << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrugis/parotid_sim/src/cAcinus/0"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (ai == this->mat_.col[aj])\n    {\n      ++size;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/35"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (k = 0; k < nz; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/8"}
{"code": "for (i = 1; i < n; i += 2)\n{\n  if (a2[i - 1] > a2[i])\n  {\n    temp = a2[i - 1];\n    a2[i - 1] = a2[i];\n    a2[i] = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/16"}
{"code": "for (int i = 0; i < (textoSaida.size() - 1); i++)\n{\n  if ((textoSaida[i] == '%') && (textoSaida[i + 1] == '%'))\n  {\n    textoSaida.replace(i, 2, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/main/3"}
{"code": "for (y = 0; y < YSIZE; y++)\n{\n  for (x = 0; x < XSIZE; x++)\n  {\n    const double cx = XMIN + (((XMAX - XMIN) * ((float) x)) / (XSIZE - 1));\n    const double cy = YMAX - (((YMAX - YMIN) * ((float) y)) / (YSIZE - 1));\n    const int v = iterate(cx, cy);\n    {\n      char c = ' ';\n      if (v < MAXIT)\n      {\n        c = charset[v % ((sizeof(charset)) - 1)];\n      }\n\n      putchar(c);\n      if ((x + 1) == XSIZE)\n        puts(\"|\");\n\n    }\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) collapse(2) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/omp-mandelbrot-ordered/0"}
{"code": "for (i = 1; i < (MAX_PRINT_SIZE / 2); ++i)\n{\n  (cout << \", \") << arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CSalih/Parallel-Programming/Assignment4/Task3/Mergesort/4"}
{"code": "for (i = 0; i < N; i++)\n  if (x[i] > maxval)\n  break;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q10/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  a[i] = rand();\n  b[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvgeniiSamarin/OPenMP/openMP/main/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  sumA += a[i];\n  sumB += b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block2/task6/2"}
{"code": "for (i = ibeg; i <= ifin; i++)\n{\n  iglob = i;\n  for (j = jbeg; j <= jfin; j++)\n  {\n    jglob = j;\n    k = ki1;\n    phi1[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n    k = ki2;\n    phi2[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/14"}
{"code": "for (p = 0; p < NP; p++)\n{\n  pos[p][0] = (p % PA) / (PA + 1.0);\n  pos[p][1] = (p % PB) / (PB + 1.0);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iroghair/verletIntegrationSpeedtest/verletTestArray/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  a[i] = 1;\n  b[i] = 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/matrix_operations/dot_product/1"}
{"code": "for (j = 1; j <= ny2; j++)\n{\n  for (i = 1; i <= nx2; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((u[k - 2][j][i][m] - (4.0 * u[k - 1][j][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k + 1][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/8"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  matrix_1D[(i * n) + j] = matrix_2D[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geilerh/matrix-vector_product-MPI-and-OpenMP/main/1"}
{"code": "for (j = 0; j <= (m - 1); j += 1)\n{\n  uold[i][j] = u[i][j];\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_jacobi_seq/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += arr[i];\n  if (((count % ngCount) == 0) || ((i + 1) == n))\n  {\n    int threadsIndex = omp_get_thread_num();\n    if (vectors[threadsIndex].size() < (vectors[threadsIndex].max_size() - 50))\n    {\n      vectors[threadsIndex].push_back(sum / count);\n      count = 0;\n      sum = 0;\n    }\n\n  }\n\n  count++;\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static, ngCount) private(count, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siedex/OpenMP/Lab 1/Assignment/MatrixMultiplication/AvgNeighbours/0"}
{"code": "for (int i = 0; i < maxNumOfNodes; ++i)\n{\n  nodes[i].seen = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/5"}
{"code": "for (i = 0; i < (numTeams * NN); i++)\n{\n  if (Res[i] != i)\n  {\n    printf(\"Failed %d %d\\n\", i, Res[i]);\n    printf(\"Failed %d %d\\n\", i + 1, Res[i + 1]);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/Threads1xxx/Threads1xxx/4"}
{"code": "for (i = 1; i <= array_size; i++)\n{\n  Array[i] = i * 1;\n  Check[i] = Array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/riaarun25/OpenMP_Programs/sum_of_numbers/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  if (oldroad[i] == 1)\n  {\n    if (oldroad[i + 1] == 1)\n    {\n      newroad[i] = 1;\n    }\n    else\n    {\n      newroad[i] = 0;\n      nmove++;\n    }\n\n  }\n  else\n  {\n    if (oldroad[i - 1] == 1)\n    {\n      newroad[i] = 1;\n    }\n    else\n    {\n      newroad[i] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), schedule(static), shared(oldroad, newroad, n), private(i), reduction(+:nmove)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bbw7561135/OpenMP-Workshop/traffic/trafficlib/0"}
{"code": "for (i = 0; i < (10000 - 1); i++)\n{\n  tempDistance = 0;\n  for (j = 0; j < 2; j++)\n  {\n    tempDistance += (Cities[Route[i]][j] - Cities[Route[i + 1]][j]) * (Cities[Route[i]][j] - Cities[Route[i + 1]][j]);\n  }\n\n  distance += sqrt(tempDistance);\n}\n\n", "pragma": "omp parallel for private(j,tempDistance) reduction(+:distance)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex2/tsp2/0"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  for (int j = 729 - 1; j > i; j--)\n  {\n    a[i][j] += cos(b[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), schedule(runtime), shared(a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/0"}
{"code": "for (int i = 0; i < imageSzVal; i++)\n{\n  energyRecip += ((sumRnew[box][i] * sumRnew[box][i]) + (sumInew[box][i] * sumInew[box][i])) * prefactPtr[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(box, imageSzVal, prefactPtr) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/6"}
{"code": "for (i = 0; i < 4096; i = i + 1)\n{\n  r = 0.0;\n  for (j = 0; j < 4096; j = j + 1)\n  {\n    r += M[i][j] * b[j];\n  }\n\n  c[i] = r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/triangular_matrix/triangular_matrix/5"}
{"code": "for (j = 0; j < k; j += B)\n  FW(A, k, k, j, B);\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/2"}
{"code": "for (int i = 0; i < 123; i++)\n  if (A[i] != 1)\n{\n  printf(\"Error at %d, h = %lf, d = %lf\\n\", i, (double) 1, A[i]);\n  fail = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/2"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < NODESY; j++)\n  {\n    TOPO[i + 1][j + 1] = count;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/69"}
{"code": "for (ie = 0; ie < nmor; ie++)\n{\n  tmor[ie] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/2"}
{"code": "for (int j = 0; j < MAX_LENGTH; j++)\n{\n  tempA += (a[j] - meanA) * (a[j] - meanA);\n  tempB += (b[j] - meanB) * (b[j] - meanB);\n  tempSum += (a[j] - meanA) * (b[j] - meanB);\n}\n\n", "pragma": "omp parallel for reduction(+:tempA) reduction(+:tempB) reduction(+:tempSum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/meismyles/pearson-cc/openmp/PearsonCC/1"}
{"code": "for (i = ((-0x7fffffff) - 1) + 6; i != ((-0x7fffffff) - 1); i--)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-2/0"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = -frct[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/84"}
{"code": "for (unsigned int i = 0; i < dimFactorVector.size(); ++i)\n{\n  if (dimFactorVector[i].size() != df_size)\n  {\n    Rprintf(\"Incorrect DimFactorVector specified iteration %d has %d dimensions\\n\", i, dimFactorVector[i].size());\n    Rprintf(\"Using default dimension strategy\\n\");\n    return reduce_dimensions(dimFactorVector.size(), 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/1"}
{"code": "for (i = 0; i < (H + 2); i++)\n{\n  harta[i][0] = 0;\n  harta_aux[i][0] = 0;\n  harta[i][H + 1] = 0;\n  harta[i][H + 1] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anaMirela/Tema1-APD/tema1/5"}
{"code": "for (i = 0; i < ntrain_samples; i++)\n{\n  float *data_row = (float *) (data->data.ptr + (data->step * i));\n  for (j = 0; j < class_count; j++)\n  {\n    float *new_data_row = (float *) (new_data->data.ptr + (new_data->step * ((i * class_count) + j)));\n    for (k = 0; k < var_count; k++)\n      new_data_row[k] = data_row[k];\n\n    new_data_row[var_count] = (float) j;\n    new_responses->data.i[(i * class_count) + j] = responses->data.fl[i] == (j + 'A');\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/25"}
{"code": "for (int i = 0; i < L2_NEURONS; i++)\n{\n  for (int j = 0; j < L2_DIM; j++)\n  {\n    temp[j][i] = WL2[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/6"}
{"code": "for (t = 0; t < 8; t++)\n{\n  int i0 = t * (1024 / 8);\n  int i1 = (t + 1) * (1024 / 8);\n  {\n    for (int i = i0; i < i1; i++)\n      A[i] = (C[i] + D[i]) + 1;\n\n  }\n}\n\n", "pragma": "omp parallel for num_threads(T) schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-concurrent-target/test/0"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n    }\n\n  }\n\n  for (i = ist; i <= L2; i++)\n  {\n    tmp = 1.0 / rsd[i][j][k][0];\n    u21i = tmp * rsd[i][j][k][1];\n    u31i = tmp * rsd[i][j][k][2];\n    u41i = tmp * rsd[i][j][k][3];\n    u51i = tmp * rsd[i][j][k][4];\n    tmp = 1.0 / rsd[i - 1][j][k][0];\n    u21im1 = tmp * rsd[i - 1][j][k][1];\n    u31im1 = tmp * rsd[i - 1][j][k][2];\n    u41im1 = tmp * rsd[i - 1][j][k][3];\n    u51im1 = tmp * rsd[i - 1][j][k][4];\n    flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n    flux[i][j][k][2] = tx3 * (u31i - u31im1);\n    flux[i][j][k][3] = tx3 * (u41i - u41im1);\n    flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n  }\n\n  for (i = ist; i <= iend; i++)\n  {\n    frct[i][j][k][0] = frct[i][j][k][0] + ((dx1 * tx1) * ((rsd[i - 1][j][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i + 1][j][k][0]));\n    frct[i][j][k][1] = (frct[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((rsd[i - 1][j][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i + 1][j][k][1]));\n    frct[i][j][k][2] = (frct[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((rsd[i - 1][j][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i + 1][j][k][2]));\n    frct[i][j][k][3] = (frct[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((rsd[i - 1][j][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i + 1][j][k][3]));\n    frct[i][j][k][4] = (frct[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((rsd[i - 1][j][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i + 1][j][k][4]));\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    frct[1][j][k][m] = frct[1][j][k][m] - (dsspm * ((((+5.0) * rsd[1][j][k][m]) - (4.0 * rsd[2][j][k][m])) + rsd[3][j][k][m]));\n    frct[2][j][k][m] = frct[2][j][k][m] - (dsspm * (((((-4.0) * rsd[1][j][k][m]) + (6.0 * rsd[2][j][k][m])) - (4.0 * rsd[3][j][k][m])) + rsd[4][j][k][m]));\n  }\n\n  ist1 = 3;\n  iend1 = nx - 4;\n  for (i = ist1; i <= iend1; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][k][m] = frct[i][j][k][m] - (dsspm * ((((rsd[i - 2][j][k][m] - (4.0 * rsd[i - 1][j][k][m])) + (6.0 * rsd[i][j][k][m])) - (4.0 * rsd[i + 1][j][k][m])) + rsd[i + 2][j][k][m]));\n    }\n\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    frct[nx - 3][j][k][m] = frct[nx - 3][j][k][m] - (dsspm * (((rsd[nx - 5][j][k][m] - (4.0 * rsd[nx - 4][j][k][m])) + (6.0 * rsd[nx - 3][j][k][m])) - (4.0 * rsd[nx - 2][j][k][m])));\n    frct[nx - 2][j][k][m] = frct[nx - 2][j][k][m] - (dsspm * ((rsd[nx - 4][j][k][m] - (4.0 * rsd[nx - 3][j][k][m])) + (5.0 * rsd[nx - 2][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,iend1 ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/19"}
{"code": "for (int i = 0; i < ((int) height); i++)\n{\n  for (int j = 0; j < ((int) width); j++)\n  {\n    if ((((i <= 2) || (i >= (((int) height) + 3))) || (j <= 2)) || (j >= (((int) width) + 3)))\n    {\n      rgb_image[i][j][0] = 0;\n      rgb_image[i][j][1] = 0;\n      rgb_image[i][j][2] = 0;\n    }\n    else\n    {\n      rgb_image[i][j][0] = in_image[(((i * width) * 4) + (j * 4)) + 0];\n      rgb_image[i][j][1] = in_image[(((i * width) * 4) + (j * 4)) + 1];\n      rgb_image[i][j][2] = in_image[(((i * width) * 4) + (j * 4)) + 2];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/boxFilterOpenMP/1"}
{"code": "for (i = 0; i < 8; i++)\n{\n  loop_0[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/parallel-region-with-multiple-loops/parallel-region-with-multiple-loops/0"}
{"code": "for (col = 0; col <= (public.in2_pad_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_pad_rows - 1); row += 1)\n  {\n    if ((((row > (public.in2_pad_add_rows - 1)) && (row < (public.in2_pad_add_rows + public.in2_rows))) && (col > (public.in2_pad_add_cols - 1))) && (col < (public.in2_pad_add_cols + public.in2_cols)))\n    {\n      ori_row = row - public.in2_pad_add_rows;\n      ori_col = col - public.in2_pad_add_cols;\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = private.d_in2[(ori_col * public.in2_rows) + ori_row];\n    }\n    else\n    {\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/14"}
{"code": "for (i = 0; i < l->filas(); i++)\n{\n  for (j = 0; j < l->columnas(); j++)\n  {\n    nMatris->num(l->num(i, j), i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kunkkaharden/Proyecto-de-tesis/source/utiles/matrix/7"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  (out << i) << \",\";\n  for (int j = 0; j < 100; ++j)\n  {\n    for (int k = 0; k < 8; ++k)\n    {\n      if (Agents[i].connections[k] == j)\n        out << j;\n\n    }\n\n    out << \",\";\n    if (j == 99)\n      out << \"\\n\";\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c8/4"}
{"code": "for (int i = 0; i < 123; i++)\n{\n  A[i] += C[i];\n}\n\n", "pragma": "omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-dpfs-dist-clauses/test/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  set_array();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/avr-aics-riken/PMlib/example/test1/main_pmlib/1"}
{"code": "for (int i = 0; i < numNodes; ++i)\n{\n  solution[i] = equal_prob;\n  if (outgoing_size(g, i) == 0)\n  {\n    sum += solution[i];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ace821017/OpenMP-Programming/part2/page_rank/page_rank/0"}
{"code": "for (int i = 0; i < p[0]; i++)\n{\n  for (int j = 0; j < p[n - 1]; j++)\n    fprintf(out, \"%f \", a[(i * p[n - 1]) + j]);\n\n  fprintf(out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/4"}
{"code": "for (int j1 = 0; j1 < tam; j1++)\n{\n  fprintf(fp, \"%s \", names[j1].c_str());\n  for (int j2 = 0; j2 < tam; j2++)\n  {\n    if (j2 < (j1 + 1))\n    {\n      fprintf(fp, \"- \");\n      continue;\n    }\n\n    fprintf(fp, \"%f \", jaccards[j1][(j2 - j1) - 1]);\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/4"}
{"code": "for (int i = 0; i < NBOUND; i++)\n  result[i] += fib(40);\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPToolsInterface/ompt-test-suite/examples/looptest/1"}
{"code": "for (i = 0; i <= (li - 1); i++)\n{\n  i11 = i * lk;\n  i12 = i11 + n1;\n  i21 = i * lj;\n  i22 = i21 + lk;\n  if (is >= 1)\n  {\n    u1 = u[ku + i];\n  }\n  else\n  {\n    u1 = dconjg(u[ku + i]);\n  }\n\n  for (k = 0; k <= (lk - 1); k++)\n  {\n    for (j = 0; j < ny; j++)\n    {\n      x11 = x[i11 + k][j];\n      x21 = x[i12 + k][j];\n      y[i21 + k][j] = dcomplex_add(x11, x21);\n      y[i22 + k][j] = dcomplex_mul(u1, dcomplex_sub(x11, x21));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/10"}
{"code": "for (j = 0; j < numberOfDataPoint; j++)\n{\n  if (pointsToClusters[j] == i)\n  {\n    printf(\"( %f ,%f)\", ArrayOfPoints[j].x, ArrayOfPoints[j].y);\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarwanaMostafa/Parallel-Processing_K-means-Clustering_OpenMp/K-means Clustering/2"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    image[i][j].rgbRed = temp[i][j].rgbRed;\n    image[i][j].rgbGreen = temp[i][j].rgbGreen;\n    image[i][j].rgbBlue = temp[i][j].rgbBlue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/3"}
{"code": "for (i = 0; i < 8; i++)\n{\n  if (a[i] < resa_seq)\n    resa_seq = a[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/reduce-omp-test/reduce-omp/2"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/12"}
{"code": "for (c2 = nm; c2 <= (nk + (-1)); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/56"}
{"code": "for (i = 0; i < nu; i++)\n{\n  printf(\"  %8d  %14f  %14f  %14f  %14f\\n\", i + 1, aleft[i], adiag[i], arite[i], f[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/20"}
{"code": "for (i = 0; i < city_num; i++)\n{\n  if (ant->visited[i] != '\\0')\n    continue;\n\n  sum += probability[offset + i];\n  avail_city[index] = i;\n  city_prob[index] = probability[offset + i] + previous;\n  previous = city_prob[index];\n  index++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/12"}
{"code": "for (int k = 0; k < N; k += 2)\n{\n  sum += factor / ((2 * k) + 1);\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilev4ik/openmp/main/1"}
{"code": "for (int i = 0; i < 2; ++i)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  foo();\n\n\n\n\n\n", "pragma": "#pragma omp target parallel for simd private(argc, b), firstprivate(c, d), lastprivate(d, f) collapse(N) schedule(static, N) ordered(N) if (parallel :argc) num_threads(N) default(shared) shared(e) reduction(+ : h)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/target_parallel_for_simd_ast_print/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  omp_set_lock(&lock);\n  sum = sum + max_;\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/6/6/Source/0"}
{"code": "for (int i = 0; i < n; i++)\n  res += a[i][i] * a[i][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shemetovElisey/OpenMP_PZ3/MPAA_PZ3/MPAA_PZ3/8"}
{"code": "for (int k = kk_min; k < kk_max; k += 2)\n{\n  for (int j = jj_min; j < jj_max; j += 2)\n  {\n    for (int i = ii_min; i < ii_max; i += 2)\n    {\n      temp = 0.5 * evaluate_array3d_bndy(array3d, N, i, j, k, recvarray);\n      temp += (1.0 / 12.0) * (((((evaluate_array3d_bndy(array3d, N, i + 1, j, k, recvarray) + evaluate_array3d_bndy(array3d, N, i - 1, j, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j + 1, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j - 1, k, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j, k + 1, recvarray)) + evaluate_array3d_bndy(array3d, N, i, j, k - 1, recvarray));\n      fill_array3d(new_X, new_N, i / 2, j / 2, k / 2, temp);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  rank_start[i] = i * (NumInputs / size);\n  rank_end[i] = (i + 1) * (NumInputs / size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trannguyendev/transportation-problem/ss/10"}
{"code": "for (int i = 1; i < end; i++)\n{\n  double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n  if (d > dmax)\n  {\n    index = i;\n    dmax = d;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkavvadias/Parallel-Processing-Project/Dynamic/0"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0438\u0442\u0435\u0439: %d, \u043d\u043e\u043c\u0435\u0440 \u043d\u0438\u0442\u0438: %d, c[i] = %d\\n\", omp_get_max_threads(), omp_get_thread_num(), c[i]);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, ITERATIONS_COUNT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roomanidzee/cpp_projects/SomeOpenMPSecond/two_parallel/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/scan_messages/1"}
{"code": "for (int i = 0; i < D; ++i)\n{\n  dist += (key->dim[i] - curr[i]) * (key->dim[i] - curr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/3"}
{"code": "for (size_t i = 0; i < KERNEL_WIDTH; i++)\n{\n  kernel_row[i] = gaussian(i, KERNEL_RADIUS, sigma);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/blurrifier-openmp/main/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (a[i] != b[i])\n  {\n    rc++;\n    printf(\"Wrong varlue: a[%d]=%d\\n\", i, a[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/teams512-info/teams512-info/2"}
{"code": "for (long i = 0; i < NV_out; i++)\n{\n  vtxPtrOut[i + 1] += vtxPtrOut[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/3"}
{"code": "for (i = 0; i < n; i++)\n  fprintf(vtk, \"%e %e %e\\n\", p[i].pos[X], p[i].pos[Y], p[i].pos[Z]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Two-n-Body/Parallel-Basic/src/twoBody/5"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    x2[i] = x2[i] + (a[(j * 128) + i] * y2[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/MVT/mvt/28"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    U_t[i][j] = A[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saiharshavellanki/Parallel-SVD/parallel_svd/1"}
{"code": "for (int var = 0; var < 2; var++)\n{\n  for (int var2 = 0; var2 < chrmsm[var].size(); var2++)\n  {\n    Lastst = Lastet + 1;\n    taskList[tc].setStarttime(Lastst);\n    Lastet = Lastst + ((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    taskList[tc].setEndtime(Lastet);\n    taskList[tc].setExectime((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    LastTaskID = taskList[tc].getTId();\n    taskListNoDup.push_back(taskList[tc]);\n    tc++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/14"}
{"code": "for (c1 = 0; c1 <= 127; c1++)\n{\n  for (c2 = 0; c2 <= 127; c2++)\n  {\n    for (c5 = 0; c5 <= 127; c5++)\n    {\n      F[c1][c2] += C[c1][c5] * D[c5][c2];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c5, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/34"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < rows; j++)\n  {\n    if (lengths[i] == 0)\n      mu[i][j] = 0.0;\n    else\n      mu[i][j] /= lengths[i] * 1.0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/9"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    if (percentDiff(B[(i * 128) + j].value, B_GPU[(i * 128) + j].value) > 0.05)\n    {\n      fail++;\n    }\n\n    if (percentDiff(B[(i * 128) + j].position, B_GPU[(i * 128) + j].position) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/k-nearest/src/k-nearest_gpu/5"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  this->mat_.row[i] = row[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/0"}
{"code": "for (unsigned int i = 0; i < number; i++)\n{\n  if (is_alive[i])\n  {\n    dump_position_to_old_single(i);\n    half_step_pos_single(t, i);\n    back_position_to_rz_single(i);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(e_fld, h_fld, t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/10"}
{"code": "for (i = 0; i < DIM; i++)\n  for (j = 0; j < DIM; j++)\n  if (c[i][j] != ck[i][j])\n{\n  printf(\"err: %d %d %d %d\\n\", i, j, c[i][j], ck[i][j]);\n  exit(0);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/counting/counting/7"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n  for (j = 1; j < (_PB_N - 1); j++)\n  B[i][j] = SCALAR_VAL(0.2) * ((((A[i][j] + A[i][j - 1]) + A[i][1 + j]) + A[1 + i][j]) + A[i - 1][j]);\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/jacobi-2d/jacobi-2d/0"}
{"code": "for (int y_start = yy_start; y_start < height; y_start += y_interval)\n{\n  for (int x_start = xx_start; x_start < width; x_start += x_interval)\n  {\n    int y_end = min(y_start + CHUNKSIZE1, height);\n    int x_end = min(x_start + CHUNKSIZE2, width);\n    for (int fy = y_start; fy < y_end; fy++)\n    {\n      for (int fx = x_start; fx < x_end; fx++)\n      {\n        nn_search_helper(first, second, curMap, height, width, half_patch, fy, fx);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/patchmatch/omp/patchmatch/2"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  T1D[i] = (((double) rand()) / 32767) * 2.0;\n  somme += T1D[i];\n}\n\n", "pragma": "omp for schedule(dynamic) reduction(+:somme) private(i) nowait", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice6/0"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n    for (k = 0; k < 1500; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Assignments/3/matmulpar/3"}
{"code": "for (int i = 0; i < p; i++)\n{\n  local_start[i] = ave * i;\n  local_end[i] = ave * (i + 1);\n  if (i == (p - 1))\n  {\n    local_end[i] = n;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sunnlo/BellmanFord/openmp_bellman_ford/2"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = 0; kk < depth; ++kk)\n    {\n      int base = ((ii * _chunk.x) * _chunk.y) + (jj * _chunk.x);\n      buffer[base + ((_chunk.x - HALO_PAD) + kk)] = buffer[base + (((_chunk.x - HALO_PAD) - 1) - kk)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_update_halo/1"}
{"code": "for (int i = 0; i < N; i++)\n  outer[i].foo();\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(tofrom: outer[:N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/mymapper/main/7"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm512_set1_epi32(noff);\n  v_moff = _mm512_set1_epi32(moff);\n  v_loff = _mm512_set1_epi32(loff);\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  nps = 4 * (nn / 4);\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &fxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &fxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sfxyz[m], v_at);\n        _mm512_packstorehi_ps(&sfxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  nps = 16 * (npp / 16);\n  sum1 = 0.0;\n  v_sum1 = _mm512_set1_pd(0.0);\n  for (j = 0; j < nps; j += 16)\n  {\n    v_x = _mm512_load_ps(&ppart[j + npoff]);\n    v_y = _mm512_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_z = _mm512_load_ps(&ppart[(j + (2 * nppmx)) + npoff]);\n    v_nn = _mm512_cvtfxpnt_round_adjustps_epi32(v_x, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_mm = _mm512_cvtfxpnt_round_adjustps_epi32(v_y, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_ll = _mm512_cvtfxpnt_round_adjustps_epi32(v_z, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_nn, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_sub_ps(v_x, v_dxp);\n    v_dyp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_mm, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dyp = _mm512_sub_ps(v_y, v_dyp);\n    v_dzp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_ll, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dzp = _mm512_sub_ps(v_z, v_dzp);\n    v_nn = _mm512_sub_epi32(v_nn, v_noff);\n    v_mm = _mm512_sub_epi32(v_mm, v_moff);\n    v_ll = _mm512_sub_epi32(v_ll, v_loff);\n    v_it = _mm512_mullo_epi32(v_mxyv4, v_ll);\n    v_it = _mm512_add_epi32(v_it, _mm512_mullo_epi32(v_mxv4, v_mm));\n    v_nn = _mm512_add_epi32(_mm512_slli_epi32(v_nn, 2), v_it);\n    v_amx = _mm512_sub_ps(v_one, v_dxp);\n    v_amy = _mm512_sub_ps(v_one, v_dyp);\n    v_amz = _mm512_sub_ps(v_one, v_dzp);\n    v_dx1 = _mm512_mul_ps(v_dxp, v_dyp);\n    v_dyp = _mm512_mul_ps(v_amx, v_dyp);\n    v_amx = _mm512_mul_ps(v_amx, v_amy);\n    v_amy = _mm512_mul_ps(v_dxp, v_amy);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_mul_ps(v_amx, a);\n    v_dx = _mm512_fmadd_ps(v_amy, p, v_dx);\n    v_dy = _mm512_mul_ps(v_amx, b);\n    v_dy = _mm512_fmadd_ps(v_amy, q, v_dy);\n    v_dz = _mm512_mul_ps(v_amx, c);\n    v_dz = _mm512_fmadd_ps(v_amy, r, v_dz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_fmadd_ps(v_dyp, a, v_dx);\n    v_dx = _mm512_fmadd_ps(v_dx1, p, v_dx);\n    v_dx = _mm512_mul_ps(v_amz, v_dx);\n    v_dy = _mm512_fmadd_ps(v_dyp, b, v_dy);\n    v_dy = _mm512_fmadd_ps(v_dx1, q, v_dy);\n    v_dy = _mm512_mul_ps(v_amz, v_dy);\n    v_dz = _mm512_fmadd_ps(v_dyp, c, v_dz);\n    v_dz = _mm512_fmadd_ps(v_dx1, r, v_dz);\n    v_dz = _mm512_mul_ps(v_amz, v_dz);\n    v_nn = _mm512_add_epi32(v_nn, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_dx = _mm512_fmadd_ps(v_dzp, v_vx, v_dx);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_dy = _mm512_fmadd_ps(v_dzp, v_vy, v_dy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_dz = _mm512_fmadd_ps(v_dzp, v_vz, v_dz);\n    v_dxp = _mm512_load_ps(&ppart[(j + (3 * nppmx)) + npoff]);\n    v_dyp = _mm512_load_ps(&ppart[(j + (4 * nppmx)) + npoff]);\n    v_dzp = _mm512_load_ps(&ppart[(j + (5 * nppmx)) + npoff]);\n    v_vx = _mm512_fmadd_ps(v_qtm, v_dx, v_dxp);\n    v_vy = _mm512_fmadd_ps(v_qtm, v_dy, v_dyp);\n    v_vz = _mm512_fmadd_ps(v_qtm, v_dz, v_dzp);\n    v_dxp = _mm512_add_ps(v_dxp, v_vx);\n    v_dyp = _mm512_add_ps(v_dyp, v_vy);\n    v_dzp = _mm512_add_ps(v_dzp, v_vz);\n    v_at = _mm512_mul_ps(v_dxp, v_dxp);\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dyp, v_dyp));\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dzp, v_dzp));\n    v_sum1 = _mm512_add_pd(v_sum1, _mm512_cvtpslo_pd(v_at));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_at, 78));\n    v_sum1 = _mm512_add_pd(v_sum1, v_d);\n    v_dx = _mm512_fmadd_ps(v_vx, v_dt, v_x);\n    v_dy = _mm512_fmadd_ps(v_vy, v_dt, v_y);\n    v_dz = _mm512_fmadd_ps(v_vz, v_dt, v_z);\n    if (ipbc == 2)\n    {\n      msk = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n      msk = _mm512_kor(msk, _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE));\n      v_dx = _mm512_mask_blend_ps(msk, v_dx, v_x);\n      v_vx = _mm512_mask_sub_ps(v_vx, msk, v_zero, v_vx);\n      msk = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n      msk = _mm512_kor(msk, _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE));\n      v_dy = _mm512_mask_blend_ps(msk, v_dy, v_y);\n      v_vy = _mm512_mask_sub_ps(v_vy, msk, v_zero, v_vy);\n      msk = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n      msk = _mm512_kor(msk, _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE));\n      v_dz = _mm512_mask_blend_ps(msk, v_dz, v_z);\n      v_vz = _mm512_mask_sub_ps(v_vz, msk, v_zero, v_vz);\n    }\n    else\n      if (ipbc == 3)\n    {\n      msk = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n      msk = _mm512_kor(msk, _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE));\n      v_dx = _mm512_mask_blend_ps(msk, v_dx, v_x);\n      v_vx = _mm512_mask_sub_ps(v_vx, msk, v_zero, v_vx);\n      msk = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n      msk = _mm512_kor(msk, _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE));\n      v_dy = _mm512_mask_blend_ps(msk, v_dy, v_y);\n      v_vy = _mm512_mask_sub_ps(v_vy, msk, v_zero, v_vy);\n      msk = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n      v_dz = _mm512_mask_add_ps(v_dz, msk, v_dz, v_edgerz);\n      msk = _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE);\n      v_dz = _mm512_mask_sub_ps(v_dz, msk, v_dz, v_edgerz);\n    }\n\n\n    _mm512_store_ps(&ppart[j + npoff], v_dx);\n    _mm512_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm512_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_dz);\n    _mm512_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vx);\n    _mm512_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vy);\n    _mm512_store_ps(&ppart[(j + (5 * nppmx)) + npoff], v_vz);\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nn = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    dx = amz * ((dx + (dyp * sfxyz[nn + (4 * mxv)])) + (dx1 * sfxyz[(nn + (4 * mxv)) + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[(nn + (4 * mxv)) + 1])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[(nn + (4 * mxv)) + 2])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 2) + 4]));\n    mm = nn + (4 * mxyv);\n    vx = (amx * sfxyz[mm]) + (amy * sfxyz[mm + 4]);\n    vy = (amx * sfxyz[mm + 1]) + (amy * sfxyz[(mm + 1) + 4]);\n    vz = (amx * sfxyz[mm + 2]) + (amy * sfxyz[(mm + 2) + 4]);\n    dx = dx + (dzp * ((vx + (dyp * sfxyz[mm + (4 * mxv)])) + (dx1 * sfxyz[(mm + (4 * mxv)) + 4])));\n    dy = dy + (dzp * ((vy + (dyp * sfxyz[(mm + (4 * mxv)) + 1])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 1) + 4])));\n    dz = dz + (dzp * ((vz + (dyp * sfxyz[(mm + (4 * mxv)) + 2])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 2) + 4])));\n    dxp = ppart[(j + (3 * nppmx)) + npoff];\n    dyp = ppart[(j + (4 * nppmx)) + npoff];\n    dzp = ppart[(j + (5 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    vz = dzp + (qtm * dz);\n    dxp += vx;\n    dyp += vy;\n    dzp += vz;\n    sum1 += ((dxp * dxp) + (dyp * dyp)) + (dzp * dzp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    dz = z + (vz * dt);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        vz = -vz;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n  }\n\n  _mm512_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,nps,nn,mm,ll,x,y,z,dxp,dyp, dzp,amx,amy,amz,dx1,dx,dy,dz,vx,vy,vz,sum1,v_noff,v_moff,v_loff,v_nn, v_mm,v_ll,v_it,v_x,v_y,v_z,v_dxp,v_dyp,v_dzp,v_amx,v_amy,v_amz,v_dx1, v_dx,v_dy,v_dz,v_vx,v_vy,v_vz,v_at,v_d,v_sum1,a,b,c,d,e,f,g,p,q,r,s, msk,kk,dd,sfxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic3/kncmpush3/0"}
{"code": "for (i = j; i < n; ++i)\n{\n  a[i] = a[i] + temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alty-ir/openmp/openmp/Lab_4_parallel1/3"}
{"code": "for (j = 0; j < height; j++)\n{\n  ret[i] += vec[j] * mat[i][j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:ret[i]) shared(i, vec, mat, height) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pyhro36/TD-1-OpenMP/matrice-vecteur/main_mat_vect/5"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  free(Matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/jacobi/5"}
{"code": "for (uint i = 0; i < nBonds; ++i)\n{\n  angleInRing[i][i] = true;\n  for (uint j = i + 1; j < nBonds; ++j)\n  {\n    angleInRing[i][j] = true;\n    angleInRing[j][i] = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedronCycle/2"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpu_ikicq1.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/27"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  temp = 2.0 * a[i];\n  a[i] = temp;\n  b[i] = c[i] / temp;\n}\n\n", "pragma": "#pragma omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kka-na/parallel_image_processing/ex3/ex3/1"}
{"code": "for (i = 0; i < simu_opts->numKD; i++)\n{\n  if (simu_opts->KDID[i] <= topoinfo->numG)\n  {\n    tmprlt->paras[simu_opts->KDID[i] - 1] = 0.0;\n  }\n  else\n  {\n    tmprlt->paras[topoinfo->ParasPos[(simu_opts->KDID[i] - topoinfo->numG) - 1] + 2] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/79"}
{"code": "for (base = 0; base < top; base += step)\n{\n  uint32_t start = base << (5 + shift);\n  uint32_t next = (base + step) << (5 + shift);\n  clock_t running_time = times(&tms) - start_time;\n  fprintf(stderr, \"\\rFound %llu, trying 0x%08x - 0x%08x, speed %.1f Mseeds/s \", (unsigned long long) found, start, next - 1, (((double) start) * clk_tck) / ((running_time) ? (running_time * 1e6) : (1e6)));\n  recent = crack_range(base, base + step, match, flavor);\n  found += recent;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/php_mt_seed/php_mt_seed/1"}
{"code": "for (int level = L - 1; level >= 0; level--)\n{\n  top_k = SearchLayer(k, q, top_k, indptr, index, level_offset, level, visited, vect);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/1"}
{"code": "for (i = 0; i < 16; i++)\n{\n  for (j = i; j < 16; j++)\n  {\n    for (k = 0; k < i; k++)\n    {\n      a[(((offset * size) + (i * size)) + j) + offset] = a[(((offset * size) + (i * size)) + j) + offset] - (a[(((offset * size) + (i * size)) + k) + offset] * a[(((offset * size) + (k * size)) + j) + offset]);\n    }\n\n  }\n\n  float temp = 1.f / a[(((offset * size) + (i * size)) + i) + offset];\n  for (j = i + 1; j < 16; j++)\n  {\n    for (k = 0; k < i; k++)\n    {\n      a[(((offset * size) + (j * size)) + i) + offset] = a[(((offset * size) + (j * size)) + i) + offset] - (a[(((offset * size) + (j * size)) + k) + offset] * a[(((offset * size) + (k * size)) + i) + offset]);\n    }\n\n    a[(((offset * size) + (j * size)) + i) + offset] = a[(((offset * size) + (j * size)) + i) + offset] * temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/lud/omp/lud_omp/2"}
{"code": "for (i = 0; i < 100; i++)\n  for (int j = 0; j < 200; j++)\n  a += h + x[j];\n\n\n", "pragma": "#pragma omp distribute parallel for simd aligned(x:8) linear(i:2) safelen(8) simdlen(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/distribute_parallel_for_simd_ast_print/1"}
{"code": "for (i = 0; i < 8; ++i)\n  neighbor[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/3"}
{"code": "for (unsigned int idx = 0; idx < parameter.size(); idx++)\n  if (a == parameter[idx].a)\n{\n  par = &parameter[idx];\n  return par;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/32"}
{"code": "for (int i = 0; i < NFEAT; i++)\n  distance += pow(elem1[i] - elem2[i], 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/fungg_p/3"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i += 1)\n  {\n    for (j = 3 * 1; j <= ((grid_points[1] - 3) - 1); j += 1)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k += 1)\n      {\n        rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/122"}
{"code": "for (i = 0; i < 1000000; ++i)\n{\n  l_Count += (isPrime(i)) ? (1) : (0);\n}\n\n", "pragma": "omp for schedule(guided) reduction(+:l_Count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/creativeyann17/Prime_C_JAVA/OpenMP/Prime/2"}
{"code": "for (i = 0; i < col; i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    fscanf(fp, \"%lf\", &A[i][j]);\n    fscanf(fp, \"%c\", &junk);\n    fscanf(fp, \"%c\", &junk);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  *(unew + i) = (double *) malloc((sizeof(double)) * N);\n  *(uold + i) = (double *) malloc((sizeof(double)) * N);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jzuhusky/HPC_Homework2/gs2D-omp/3"}
{"code": "for (ii = 10 + 25; ii < 1000; ii += 1)\n  for (iii = (ii * 10) + 25; iii < ((ii / ii) - 23); iii += 1)\n  for (kk = (ii * 10) + 25; kk < (iii - 23); kk += 1)\n  ;\n\n\n\n", "pragma": "#pragma omp for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/test/OpenMP/for_loop_messages/6"}
{"code": "for (i = 1; i < numOfProcs; i++)\n{\n  MPI_Recv(q, 1, MPI_DOUBLE, i, Q_TAG, MPI_COMM_WORLD, &status);\n  MPI_Recv(alpha, 1, MPI_DOUBLE, i, ALPHA_TAG, MPI_COMM_WORLD, &status);\n  MPI_Recv(tempW, numOfW, MPI_DOUBLE, i, W_TAG, MPI_COMM_WORLD, &status);\n  if (((*alpha) < smallestAlpha) && ((*q) < qc))\n  {\n    smallestAlpha = *alpha;\n    tempQ = *q;\n    copyArr(&w, tempW, numOfW);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danrol/Parallel_Perceptron_MPI_CUDA_openMP/CudaMPIOpenMP_onVDI/MPIAndOpenMPMethods/6"}
{"code": "for (k = 0; k < nz; k++)\n{\n  zeta = ((double) k) / (nz - 1);\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(nx ,m ,k ,j ,xi ,eta ,zeta ,nx0 ,ny0 ,nz ,ny ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/14"}
{"code": "for (u = 0; u < graph->num_vertices; u++)\n{\n  uint32_t j;\n  uint32_t v;\n  struct AdjLinkedListNode *Nodes = graph->vertices[u].outNodes;\n  uint32_t degree_out = graph->vertices[u].out_degree;\n  for (j = 0 + r; j < degree_out; j++)\n  {\n    v = Nodes->dest;\n    Nodes = Nodes->next;\n    linkNodes(u, v, stats->components);\n    break;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2048)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/17"}
{"code": "for (int col = row; col < mat_size; col++)\n{\n  sum = sum + (A_aug[row][col] * x[col]);\n}\n\n", "pragma": "omp parallel for shared(A_aug, x, mat_size) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/6/Gauss_Elimination/main/2"}
{"code": "for (int n = 0; n < N; n++)\n{\n  double mnew = 0;\n  for (int i = 0; i < mu; i++)\n  {\n    mnew += w[i] * x[i][n];\n  }\n\n  m[(t + 1) & 1][n] = mnew;\n  p[(t + 1) & 1][n] = ((1 - cc) * p[t & 1][n]) + ((sqrt((cc * (2 - cc)) * mueff) * (m[(t + 1) & 1][n] - m[t & 1][n])) / sigma);\n}\n\n", "pragma": "        #pragma omp parallel for shared(mu,sigma,cc,m,p,mueff)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/R1ES_omp_alt/9"}
{"code": "for (; n >= 0; n--)\n{\n  thread_dimension[div_ctr] *= 2;\n  div_ctr = (div_ctr + 1) % 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/1"}
{"code": "for (int i = 0; i < 1024; i++)\n  thread_id[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/threads/threads/1"}
{"code": "for (int i = 0; i < sim->LANES; i++)\n{\n  for (int j = 0; j < length; j++)\n  {\n    if (grid[(sim->L * i) + j] != (-1))\n    {\n      printf(\"\\033[1;32m%d\\033[0m\", cars[grid[(sim->L * i) + j]].lane_change_now);\n    }\n    else\n    {\n      printf(\"\\033[2;35m\\u2588\\033[0m\");\n    }\n\n  }\n\n  printf(\"\\n\\033[K\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/13"}
{"code": "for (i = 0; i < n; i++)\n  x[i] = (rand() % ((upper - lower) + 1)) + lower;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ChristosDeretzis/High-Performance-Computing/OpenMP/Matrix_Multiplication/mat_vect_mult_par/1"}
{"code": "for (int i = 0; i < 7; i++)\n{\n  ((cout << \"\\n\\nThreads: \") << threadcount[i]) << \"\\nSize:\\tTime AVG:\\n\";\n  ((outfile << \"\\n\\nThreads: \") << threadcount[i]) << \"\\nSize:\\tTime AVG:\\n\";\n  for (int j = 0; j < 6; j++)\n  {\n    avgtime = 0;\n    (cout << dimension[j]) << \"\\t\";\n    (outfile << dimension[j]) << \"\\t\";\n    avgtime = execution(dimension[j], threadcount[i]);\n    (cout << avgtime) << \"\\n\";\n    (outfile << avgtime) << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/inverse/9"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + (((vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)] - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]);\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - (vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)] - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_cell_kernel_c/4"}
{"code": "for (i = 0; i < digits.size(); i++)\n{\n  digit++;\n  counter = counter + pow(*it, digit);\n  it++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/itwitch13/parallel-solutions/DisariumNumber/openMPDisarium/0"}
{"code": "for (k = n - 1; 1 <= k; k--)\n{\n  b[k - 1] = b[k - 1] + sdot(n - k, (a + k) + ((k - 1) * lda), 1, b + k, 1);\n  l = ipvt[k - 1];\n  if (l != k)\n  {\n    t = b[l - 1];\n    b[l - 1] = b[k - 1];\n    b[k - 1] = t;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/25"}
{"code": "for (int i = 0; i < E; i++)\n{\n  int u = g[i].src;\n  int v = g[i].dest;\n  offset[u + 1] += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspDataDriven/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  d[i] = 0.0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n    if (i == Aj[u])\n    d[i] += Ax[u];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/OMP/cg/7"}
{"code": "for (int i = 1; i < Nthr; i++)\n  suma.col(i) += suma.col(i - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/reverseCummulativeSum/2"}
{"code": "for (i = 0; i < num_rownnz; i++)\n{\n  m = A_rownnz[i];\n  tempx = y_data[m];\n  for (jj = A_i[m]; jj < A_i[m + 1]; jj++)\n    tempx += A_data[jj] * x_data[A_j[jj]];\n\n  y_data[m] = tempx;\n}\n\n", "pragma": "omp parallel for private(tempx, m, jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/amgmk/csr_matvec/0"}
{"code": "for (int j = 0; j < dijkstra_params->num_tries; j++)\n{\n  num_thr = 0;\n  for (int k = 0; k < range_threads; k++)\n  {\n    if (num_thr <= dijkstra_params->num_thr_end)\n    {\n      num_thr++;\n    }\n    else\n    {\n      break;\n    }\n\n    records[k].num_threads = num_thr;\n    records[k].processes = sysconf(_SC_NPROCESSORS_ONLN);\n    get_runtime_stats(&records[k]);\n    double start_time = omp_get_wtime();\n    run_dijkstra(num_thr);\n    double time = omp_get_wtime() - start_time;\n    results[k] = time;\n  }\n\n  int min_index = find_min(results, range_threads);\n  pthread_mutex_lock(&lock);\n  write_in_dataset(\"\", &records[min_index]);\n  pthread_mutex_unlock(&lock);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/33"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    E[(i * N) + j] = 0.0;\n    for (int k = 0; k < N; ++k)\n    {\n      E[(i * N) + j] += C[(i * N) + k] * D[(k * N) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse (1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/12"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n{\n  c = A[(i * an) + j] - B[(i * bn) + j];\n  if (c < 0.0)\n    c = -c;\n\n  c = c / A[(i * an) + j];\n  if (c > 1.0E-6)\n  {\n    {\n      if (bots_verbose_mode >= BOTS_VERBOSE_DEFAULT)\n      {\n        fprintf(stdout, \"Strassen: Wrong answer!\\n\");\n      }\n\n    }\n    ;\n    return 2;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/strassen/src/strassen_ompi/6"}
{"code": "for (int i = 0; i < ROWA; i++)\n  for (int j = 0; j < COLB; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_mm/2"}
{"code": "for (int i = 0; i < nUser; i++)\n{\n  for (int j = 0; j < nItem; j++)\n  {\n    B[i][j] = 0;\n    for (int k = 0; k < nFeat; k++)\n      B[i][j] += L[i][k] * R[k][j];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/2"}
{"code": "for (i = 0; i < V; i++)\n{\n  graphAdjLinkedList->vertices[i].outNodes = 0;\n  graphAdjLinkedList->vertices[i].out_degree = 0;\n  graphAdjLinkedList->vertices[i].visited = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjLinkedList/0"}
{"code": "for (i = 0; i < m; i++)\n  F[i] = malloc(n * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/laplace2d_omp_acc/2"}
{"code": "for (int i = 0; i < file_size; i++)\n{\n  freq[buffer[i] - 0]++;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: freq) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NickDeca/OpenMp/char_freq_paral/0"}
{"code": "for (unsigned long long i = 0; i < edge_list_size; i++)\n{\n  h_graph_edges[i] = rand() % no_of_nodes;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_gpu/1"}
{"code": "for (long i = 0; i < n_unionized_grid_points; i++)\n  energy_grid[i].xs_ptrs = n_isotopes * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/xsbench-mp4/src/GridInit/5"}
{"code": "for (unsigned i = 0; i < input.size(); i++)\n{\n  input[i] = i * mul;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/1"}
{"code": "for (i = 0; i < omp_num_devices; i++)\n{\n  omp_device_t *dev = &omp_devices[i];\n  int rt = pthread_join(dev->helperth, 0);\n  omp_device_type_t devtype = dev->type;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/runtime/homp_dev/5"}
{"code": "for (int i = 1; i <= 100000; i++)\n{\n  xData[i] = i * 5;\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reizero01/OpenMP/MP_linear_interpolation/0"}
{"code": "for (j = 0; j < nx1; j++)\n{\n  for (n = 0; n < ndim; n++)\n  {\n    f[n + (ndim * j)] += scr[n + (ndim * j)];\n    f[n + (ndim * (j + (nxv * nyp)))] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpplib2/11"}
{"code": "for (int i = 0; i < FRAMES_PER_BUFFER; i++)\n{\n  if (fabs(apOut[i]) > max)\n  {\n    max = fabs(apOut[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SurturTawers/OpenMP-ReverbDSP/reverbParalelo/4"}
{"code": "for (i = 1; i < 10; i++)\n{\n  id = omp_get_thread_num();\n  a[i] = a[i - 1] + 1;\n  printf(\"a[%d] is %d from thread: %d\\n\", i, a[i], id);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/dependentfor/0"}
{"code": "for (j = 2; j < xcell; j++)\n{\n  u[1 - iz][j][1] = (u[iz][j][1] + (0.1 * ((u[iz][j + 1][1] + u[iz][j - 1][1]) - (2.0 * u[iz][j][1])))) + (0.1 * ((u[iz][j][2] + u[iz][j][0]) - (2.0 * u[iz][j][1])));\n  u[1 - iz][j][ycell] = (u[iz][j][ycell] + (0.1 * ((u[iz][j + 1][ycell] + u[iz][j - 1][ycell]) - (2.0 * u[iz][j][ycell])))) + (0.1 * ((u[iz][j][ycell + 1] + u[iz][j][ycell - 1]) - (2.0 * u[iz][j][ycell])));\n}\n\n", "pragma": "omp parallel for schedule(static,1) default(none) private(j) shared (u, iz, xcell, ycell)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/9"}
{"code": "for (y = 0; y < GLOBAL_GRID_W; ++y)\n  send_buf_y[y] = buf_grid_values[get_index_row(proc_x_indices.second - 1, y)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/20"}
{"code": "for (i = 0; i < nxgrid; i++)\n{\n  celldata[i] = malloc((nygrid * ndata) * (sizeof(double *)));\n  for (j = 0; j < nygrid; j++)\n    celldata[i][j] = malloc(ndata * (sizeof(double)));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/107"}
{"code": "for (int i = 0; i < Time_cell; ++i)\n{\n  hhsa_map[i] = (float **) malloc(Freq_cell * (sizeof(float *)));\n  for (int j = 0; j < Freq_cell; ++j)\n  {\n    hhsa_map[i][j] = (float *) malloc(Holo_Freq_cell * (sizeof(float)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/40"}
{"code": "for (int i = 0; i < nbp; i++)\n{\n  scounts[i] = ((n / nbp) + 1) + ((n % nbp) * (i == (nbp - 1)));\n  displs[i] = i * (n / nbp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP/cg/7"}
{"code": "for (i = 0; i < testIter; ++i)\n  hypre_CSRMatrixMatvec(1, A, x, 0, y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/main/0"}
{"code": "for (j = 0; j < num_loops; j++)\n{\n  for (i = -200; i < 200; i += 7)\n    a_known_value++;\n\n  for (i = 200; i >= (-200); i -= 7)\n    b_known_value++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/worksharing/for/kmp_set_dispatch_buf/0"}
{"code": "for (long i = 0; i < 10; i++)\n{\n  for (int u = 0; u < 100000000; u++)\n  {\n    result++;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_loopx2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  s += 1.0 / (((4.0 * i) + 1.0) * ((4.0 * i) + 3.0));\n}\n\n", "pragma": "omp parallel for private(i) shared(n) reduction(+:s)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/pi_c_omp/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  imgR[i] = ((0.299 * imgR[i]) + (0.587 * imgG[i])) + (0.114 * imgB[i]);\n  imgG[i] = ((0.299 * imgR[i]) + (0.587 * imgG[i])) + (0.114 * imgB[i]);\n  imgB[i] = ((0.299 * imgR[i]) + (0.587 * imgG[i])) + (0.114 * imgB[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ikhor/RPDIP/RPDIPDLL/RPDIPDLL/rpdip/2"}
{"code": "for (i = 0; i < 10; ++i)\n  continue;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/block-2/4"}
{"code": "for (int i = 2500001; i <= 5000000; i++)\n  funcsum[1] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/1"}
{"code": "for (i = 0; i < ((*tamanho) - 1); i++)\n  for (j = 0; j < (((*tamanho) - i) - 1); j++)\n  if (vetor[j] > vetor[j + 1])\n  swap(&vetor[j], &vetor[j + 1]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sort/2"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  if ((x[i] < xmin) || (x[i] >= xmax))\n    continue;\n\n  bin = calc_bin(x[i], edges);\n  weight = w[i];\n  values_ot[bin] += weight;\n  variances_ot[bin] += weight * weight;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/29"}
{"code": "for (int p = ini; p < fin; p++)\n  if (Deltac[p] != FLT_MAX)\n  Arc[p] += Deltac[p];\n\n\n", "pragma": "      #pragma omp parallel for schedule (static) if(npf>OMP_LIMIT_COMPUTELIGHT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphCpuSingle/1"}
{"code": "for (int i = 0; i < R; i++)\n{\n  printf(\"|\");\n  for (int j = 0; j < C; j++)\n  {\n    printf(\"%c\", getMinName(getType(oldWorld[i][j].type)));\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arcmarqs/EcosystemSim/src/util/6"}
{"code": "for (i = 0; i <= T; i += 1)\n{\n  nrA[i] = 0;\n  nrB[i] = 0;\n  maxPriceA[i] = 0;\n  maxPriceB[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elf11/Parallel-Processing/OpenMP/paralel/5"}
{"code": "for (int icell = 1; icell <= ncells; icell++)\n{\n  int i = CVT_INT(m_rteLyrs[ilyr][icell]);\n  if (m_rchID[i] > 0)\n    continue;\n\n  NitrateLoss(i);\n  PhosphorusLoss(i);\n  SubbasinWaterQuality(i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrMV/NutrientMovementViaWater/6"}
{"code": "for (int r = 0; r < 2; r++)\n{\n  rowIndex = 0;\n  for (int count = 0; count < Ntotal; count++)\n  {\n    spPosVerlet();\n    resetContacts();\n    sp_Forces(lenscales);\n    sp_VelVerlet();\n    if (((count % print_frequency) == 0) && (rowIndex < frames))\n    {\n      for (int ci = 0; ci < NCELLS; ci++)\n      {\n        v_x = cell(ci).cal_mean_v(0);\n        v_y = cell(ci).cal_mean_v(1);\n        cur_speed += sqrt((v_x * v_x) + (v_y * v_y));\n      }\n\n      cur_speed /= NCELLS;\n      speed[rowIndex] = cur_speed;\n      for (int i = 0; i < NCELLS; i++)\n      {\n        x_com[rowIndex][i] = cell(i).cpos(0);\n        y_com[rowIndex][i] = cell(i).cpos(1);\n      }\n\n      rowIndex++;\n    }\n\n  }\n\n  taos[r] = calTao(q, rowIndex, x_com, y_com);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/111"}
{"code": "for (int i = 0; i < size; i++)\n{\n  v3[i] = v1[i] + v2[i];\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/realsanya/parallel-programming/sem-2/ConsoleApplication1/1"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  tmp1 = 1.0 / u[i][j][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  fjac[i][j][k][0][0] = 0.0;\n  fjac[i][j][k][0][1] = 0.0;\n  fjac[i][j][k][0][2] = 1.0;\n  fjac[i][j][k][0][3] = 0.0;\n  fjac[i][j][k][0][4] = 0.0;\n  fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][2])) * tmp2;\n  fjac[i][j][k][1][1] = u[i][j][k][2] * tmp1;\n  fjac[i][j][k][1][2] = u[i][j][k][1] * tmp1;\n  fjac[i][j][k][1][3] = 0.0;\n  fjac[i][j][k][1][4] = 0.0;\n  fjac[i][j][k][2][0] = (-((u[i][j][k][2] * u[i][j][k][2]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][2][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n  fjac[i][j][k][2][2] = ((2.0 - c2) * u[i][j][k][2]) * tmp1;\n  fjac[i][j][k][2][3] = ((-c2) * u[i][j][k][3]) * tmp1;\n  fjac[i][j][k][2][4] = c2;\n  fjac[i][j][k][3][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][3][1] = 0.0;\n  fjac[i][j][k][3][2] = u[i][j][k][3] * tmp1;\n  fjac[i][j][k][3][3] = u[i][j][k][2] * tmp1;\n  fjac[i][j][k][3][4] = 0.0;\n  fjac[i][j][k][4][0] = ((((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - ((c1 * u[i][j][k][4]) * tmp1)) * u[i][j][k][2]) * tmp1;\n  fjac[i][j][k][4][1] = (((-c2) * u[i][j][k][1]) * u[i][j][k][2]) * tmp2;\n  fjac[i][j][k][4][2] = ((c1 * u[i][j][k][4]) * tmp1) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + ((3.0 * u[i][j][k][2]) * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][4][3] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][4][4] = (c1 * u[i][j][k][2]) * tmp1;\n  njac[i][j][k][0][0] = 0.0;\n  njac[i][j][k][0][1] = 0.0;\n  njac[i][j][k][0][2] = 0.0;\n  njac[i][j][k][0][3] = 0.0;\n  njac[i][j][k][0][4] = 0.0;\n  njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][1][1] = c3c4 * tmp1;\n  njac[i][j][k][1][2] = 0.0;\n  njac[i][j][k][1][3] = 0.0;\n  njac[i][j][k][1][4] = 0.0;\n  njac[i][j][k][2][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][2][1] = 0.0;\n  njac[i][j][k][2][2] = (con43 * c3c4) * tmp1;\n  njac[i][j][k][2][3] = 0.0;\n  njac[i][j][k][2][4] = 0.0;\n  njac[i][j][k][3][0] = ((-c3c4) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][3][1] = 0.0;\n  njac[i][j][k][3][2] = 0.0;\n  njac[i][j][k][3][3] = c3c4 * tmp1;\n  njac[i][j][k][3][4] = 0.0;\n  njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - ((((con43 * c3c4) - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c3c4 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n  njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][4][2] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][4][3] = ((c3c4 - c1345) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][4][4] = c1345 * tmp1;\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,k) firstprivate (c3c4,c1345,c1,c2,con43)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/58"}
{"code": "for (__i__ = 0; __i__ < __num_target_devices__; __i__++)\n{\n  args[i].a = a;\n  args[i].n = n;\n  __offloading_info__.offloadings[i].args = &args[i];\n  __offloading_info__.offloadings[i].kernel_launcher = OUT__3__5904__launcher;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/axpy/axpy_ompacc/0"}
{"code": "for (int j = left; j < right; j += 2 * i)\n{\n  int start = j;\n  int mid = (j + i) - 1;\n  int end = min((start + (2 * i)) - 1, right);\n  mergesort(merge_array, B, start, mid, end, n);\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarshiniKoduru/OpenMp/mergesort/mergesort/1"}
{"code": "for (j = 0; j < n; j++)\n{\n  int active_cluster;\n  active_cluster = PointAssignCluster[j];\n  omp_set_lock(&lock);\n  cluster_member_count[active_cluster]++;\n  clustersCenters[active_cluster].x += points[j].x;\n  clustersCenters[active_cluster].y += points[j].y;\n  clustersCenters[active_cluster].z += points[j].z;\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YanivBir/K-Means/kmeans/2"}
{"code": "for (int i = 0; i < (n / 2); ++i)\n{\n  p_0[i] = p[2 * i];\n  p_1[i] = p[(2 * i) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mlchkhn/parallel_algorithms/multiplication/3"}
{"code": "for (j = i + 1; j < 5000; j++)\n{\n  temp = A[i][j];\n  A[i][j] = A[j][i];\n  A[j][i] = temp;\n}\n\n", "pragma": "omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/transpose/0"}
{"code": "for (int j = 0; j < x_points; j++)\n{\n  p_new[0][j] = p_new[1][j];\n  p_new[y_points - 1][j] = p_new[y_points - 2][j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Channel Flow/2-D_Channel_Flow/main/4"}
{"code": "for (int i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ensemblearner/openmp/pi/0"}
{"code": "for (int k = 0; k < num_vertices; k++)\n{\n  if (cheap[k] != (-1))\n  {\n    if (!same(ufind_sets, edges[k].source, edges[k].dest))\n    {\n      int source = find(ufind_sets, edges[cheap[k]].source);\n      int dest = find(ufind_sets, edges[cheap[k]].dest);\n      printf(\"Edge %d->%d included in MST\\n\", edges[cheap[k]].source, edges[cheap[k]].dest, edges[cheap[k]].weight);\n      union_sets(ufind_sets, source, dest);\n      sum[k] = edges[cheap[k]].weight;\n      comp[k] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic,1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_init/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  pthread_join(thread_id[i], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/6"}
{"code": "for (long long i = -10; i < 10; i += 3)\n{\n  R *= i;\n}\n\n", "pragma": "  #pragma omp for simd reduction(*:R)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/4"}
{"code": "for (int i = 0; i < board.getCols(); i++)\n{\n  if (board.isColumnEmpty(i))\n  {\n    board.makeMove(i, player);\n    int score = alphabetapruning(depth + 1, maxDepth, alpha, beta, false, nextPlayer);\n    bestScore = max(bestScore, score);\n    alpha = max(alpha, score);\n    board.undoMove();\n    if (beta <= alpha)\n      break;\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) if(isMaximizingPlayer)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/GameAlphaBeta/1"}
{"code": "for (m = 0; m < 5; m++)\n{\n  i = grid_points[0] - 3;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[i - 2][m] - (4.0 * ue[i - 1][m])) + (6.0 * ue[i][m])) - (4.0 * ue[i + 1][m])));\n  i = grid_points[0] - 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[i - 2][m] - (4.0 * ue[i - 1][m])) + (5.0 * ue[i][m])));\n}\n\n", "pragma": "omp parallel for private(m, i) firstprivate(dssp ,k ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/19"}
{"code": "for (x = 0; x < Lc; x++)\n  for (y = 0; y < Lc; y++)\n  phi_c[x + (y * L)] = 0.0;\n\n\n", "pragma": "omp parallel for private(x, y) shared(p, L, Lc)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/5"}
{"code": "for (long int idxLoop = 0; idxLoop < NbLoops; ++idxLoop)\n{\n  parallelSum += dotOmp(vec0.data(), vec1.data(), TestSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/dot/3"}
{"code": "for (i = 1; i < (n - 1); i += 2)\n{\n  if (a2[i] > a2[i + 1])\n  {\n    temp = a2[i + 1];\n    a2[i + 1] = a2[i];\n    a2[i] = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/17"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    printf(\"%s[%d][%d]:%f\\n\", name, i, j, A[(i * m) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/bm2d/bm2d/0"}
{"code": "for (i = 0; i < tam; i++)\n{\n  printf(\"%d\\t\", vetor[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tiaagosr/parallel-sorting-algorithms/bubble/2"}
{"code": "for (i = 0; i < nT; i++)\n{\n  int bj = nT / Q;\n  int rj = nT % Q;\n  int cj = 0;\n  int nj = 0;\n  for (j = 0; j < nT; j++)\n  {\n    if (j > i)\n      owner[i][j] = -1;\n    else\n    {\n      if (randDist)\n        owner[i][j] = rand() % nthreads;\n      else\n        if (blockDist)\n        owner[i][j] = (ni * Q) + nj;\n      else\n        owner[i][j] = ((i % P) * Q) + (j % Q);\n\n\n      assert((0 <= owner[i][j]) && (owner[i][j] < nthreads));\n    }\n\n    cj++;\n    if (cj == (bj + (rj > 0)))\n      nj++, cj = 0, rj--;\n\n  }\n\n  ci++;\n  if (ci == (bi + (ri > 0)))\n    ni++, ci = 0, ri--;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhyuchao123/OpenMP-and-CUDA-for-matrix-decomposition/openmp/parCholesky/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (mat[i][j] != 0)\n    {\n      value[(i * N) + j] = mat[i][j];\n      column[(i * N) + j] = j;\n      scan_a++;\n    }\n    else\n    {\n      value[(i * N) + j] = -1;\n      column[(i * N) + j] = -1;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CanBoran/Fractal-OpenMP/parallel_sparse/1"}
{"code": "for (int i = 0; i <= m_nSubbasins; i++)\n{\n  m_surfqToCh[i] = 0.f;\n  m_sedToCh[i] = 0.f;\n  m_surNO3ToCh[i] = 0.f;\n  m_surNH4ToCh[i] = 0.f;\n  m_surSolPToCh[i] = 0.f;\n  m_surCodToCh[i] = 0.f;\n  m_sedOrgNToCh[i] = 0.f;\n  m_sedOrgPToCh[i] = 0.f;\n  m_sedMinPAToCh[i] = 0.f;\n  m_sedMinPSToCh[i] = 0.f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IMP_SWAT/pothole_SWAT/1"}
{"code": "for (i = 0; i < splitPoint; i++)\n{\n  child.person[i].x_pos = parentOne.person[i].x_pos;\n  child.person[i].y_pos = parentOne.person[i].y_pos;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/4"}
{"code": "for (unsigned int k = 0; k < nIterations; k += 1)\n{\n  for (unsigned int i = 1; i < (nRows - HALF_LENGTH); i += 1)\n  {\n    for (unsigned int j = 1; j < (nCols - HALF_LENGTH); j += 1)\n    {\n      int gid = j + (i * nCols);\n      float value = 0.f;\n      value += (prev[gid + 1] - (2.f * prev[gid])) + prev[gid - 1];\n      value += (prev[gid + nCols] - (2.f * prev[gid])) + prev[gid - nCols];\n      value *= dtDIVdxy * vel[gid];\n      next[gid] = ((2.f * prev[gid]) - next[gid]) + value;\n    }\n\n  }\n\n  float *swap = next;\n  next = prev;\n  prev = swap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/iso2dfd-omp/iso2dfd/3"}
{"code": "for (unsigned i = 0; i < stoi(ImGrey.height); i++)\n  ImGrey.pixels[i].resize(stoi(ImGrey.width));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ozielalves/prog-paralela/Filters/paralelo/omp_filters/2"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 3 * 1; k <= ((grid_points[2] - (3 * 1)) - 1); k++)\n      {\n        rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/140"}
{"code": "for (int i = 1; i <= numCities; i++)\n{\n  baseStr += i + '0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/15"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  if ((n = seqlen_array[si + 1]) != 0)\n  {\n    for (i = 1, len1 = 0; i <= n; i++)\n    {\n      char c = seq_array[si + 1][i];\n      if ((c != gap_pos1) && (c != gap_pos2))\n        len1++;\n\n    }\n\n    for (sj = si + 1; sj < nseqs; sj++)\n    {\n      if ((m = seqlen_array[sj + 1]) != 0)\n      {\n        int se1;\n        int se2;\n        int sb1;\n        int sb2;\n        int maxscore;\n        int seq1;\n        int seq2;\n        int g;\n        int gh;\n        int displ[(2 * 5000) + 1];\n        int print_ptr;\n        int last_print;\n        for (i = 1, len2 = 0; i <= m; i++)\n        {\n          char c = seq_array[sj + 1][i];\n          if ((c != gap_pos1) && (c != gap_pos2))\n            len2++;\n\n        }\n\n        gh = 10 * pw_ge_penalty;\n        gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n        g = (mat_avscore <= 0) ? (20 * gg) : ((2 * mat_avscore) * gg);\n        seq1 = si + 1;\n        seq2 = sj + 1;\n        forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n        reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n        print_ptr = 1;\n        last_print = 0;\n        diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n        mm_score = tracepath(sb1, sb2, &print_ptr, &last_print, displ, seq1, seq2);\n        if ((len1 == 0) || (len2 == 0))\n          mm_score = 0.0;\n        else\n          mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n\n        seq_output[(si * nseqs) + sj] = mm_score;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_performance/task_performance/bots/omp-tasks/alignment/alignment_for/alignment/1"}
{"code": "for (int h = 0; h < 4; h++)\n  for (int w = 0; w < 4; w++)\n  input_file.read((char *) (&initGuess->data[h][w]), sizeof(float));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_odd_even_transposition_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/odd-even-transposition/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = a[i] - b[i];\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/VecVecRed/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  arrayX[x] = xe;\n  arrayY[x] = ye;\n}\n\n", "pragma": "omp parallel for shared(arrayX, arrayY, xe, ye) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/1"}
{"code": "for (int x = 0; x < 256; x++)\n{\n  for (int y = 0; y < N; ++y)\n    histo[x] += arr[x][y];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative2/2"}
{"code": "for (i = 1; i <= 10; i++)\n{\n  div /= i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_atomic/3"}
{"code": "for (c1 = (c0 + 1) / 2; c1 <= ((((c0 < ((c0 + ((-l) + (1 / 16))) + 1)) ? (c0) : ((c0 + ((-l) + (1 / 16))) + 1)) < ((N - 3) / 16)) ? ((c0 < ((c0 + ((-l) + (1 / 16))) + 1)) ? (c0) : ((c0 + ((-l) + (1 / 16))) + 1)) : ((N - 3) / 16)); c1 += 1)\n  for (c3 = (l > (((16 * c0) - (16 * c1)) + 2)) ? (l) : (((16 * c0) - (16 * c1)) + 2); c3 <= (((N - 1) < (((16 * c0) - (16 * c1)) + 17)) ? (N - 1) : (((16 * c0) - (16 * c1)) + 17)); c3 += 1)\n  for (c4 = (0 > (((-c1) + ((N - 1) / 16)) - 1)) ? (0) : (((-c1) + ((N - 1) / 16)) - 1); c4 <= (((((-l) + N) / 16) < ((-c1) + (((((-l) + N) + c3) - 2) / 16))) ? (((-l) + N) / 16) : ((-c1) + (((((-l) + N) + c3) - 2) / 16))); c4 += 1)\n  for (c6 = ((((((-N) + (16 * c1)) + 2) > ((-N) + c3)) ? (((-N) + (16 * c1)) + 2) : ((-N) + c3)) > (((-16) * c4) - 15)) ? (((((-N) + (16 * c1)) + 2) > ((-N) + c3)) ? (((-N) + (16 * c1)) + 2) : ((-N) + c3)) : (((-16) * c4) - 15); c6 <= (((((-1) < (((-N) + (16 * c1)) + 17)) ? (-1) : (((-N) + (16 * c1)) + 17)) < (((-l) + c3) - (16 * c4))) ? (((-1) < (((-N) + (16 * c1)) + 17)) ? (-1) : (((-N) + (16 * c1)) + 17)) : (((-l) + c3) - (16 * c4))); c6 += 1)\n  for (c10 = ((16 * c4) > (-c6)) ? (16 * c4) : (-c6); c10 <= ((((16 * c4) + 15) < (((-l) + c3) - c6)) ? ((16 * c4) + 15) : (((-l) + c3) - c6)); c10 += 1)\n  c[-c6][c3 - c6] += (c[-c6][(c3 - c6) - 1] + paired(c10, c3 - c6)) ? (c[-c6][c10 - 1] + c[c10 + 1][(c3 - c6) - 1]) : (0);\n\n\n\n\n\n", "pragma": "omp parallel for shared(c0) private(c1, c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/counting/counting/2"}
{"code": "for (int mp = 0; mp < MPIsize; mp++)\n{\n  if (MPIoffset == mp)\n    hdf_float_data.openFile(fname.str());\n\n  myComm->barrier();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FWSingleMPI/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int sum = 0;\n  for (int j = 0; j < n; j++)\n    sum += matrix[i][j] * vector[j];\n\n  result[i] = sum;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task3/0"}
{"code": "for (j = 0; j < numSelect; j++)\n{\n  done = false;\n  while (!done)\n  {\n    select = rand() % initSize;\n    newProb = populationFitness[select] / maxFitness;\n    rndNumber = rand() / ((double) RAND_MAX);\n    if (rndNumber <= newProb)\n    {\n      strcopy(parents[j], population[select], dim);\n      done = true;\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(NUM_THREADS) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/19"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  phi = pseudo_K0RS[(nuc * input.numL) + i] * sqrt(E);\n  if (i == 1)\n    phi -= -atan(phi);\n  else\n    if (i == 2)\n    phi -= atan((3.0 * phi) / (3.0 - (phi * phi)));\n  else\n    if (i == 3)\n    phi -= atan((phi * (15.0 - (phi * phi))) / (15.0 - ((6.0 * phi) * phi)));\n\n\n\n  phi *= 2.0;\n  sigTfactors[i].r = cos(phi);\n  sigTfactors[i].i = -sin(phi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/rsbench-omp/simulation/6"}
{"code": "for (j = 0; j < verybig; j++)\n{\n  int id = omp_get_thread_num();\n  long k;\n  sum[id] += 1;\n  sumx[id] = 0.0;\n  for (k = 0; k < j; k++)\n    sumx[id] = sumx[id] + ((double) k);\n\n  sumy[id] = 0.0;\n  for (k = j; k > 0; k--)\n    sumy[id] = sumy[id] + ((double) k);\n\n  if (sumx[id] > 0.0)\n    total[id] = total[id] + (1.0 / sqrt(sumx[id]));\n\n  if (sumy[id] > 0.0)\n    total[id] = total[id] + (1.0 / sqrt(sumy[id]));\n\n}\n\n", "pragma": "#pragma omp parallel for private(sumx, sumy, k) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /parallel_for_loop/0"}
{"code": "for (i = 0; i < (size * size); i++)\n{\n  if ((i % size) == 0)\n    printf(\"\\n\");\n\n  printf(\"%c\", (f[i]) ? ('X') : ('.'));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeBrizola/game-of-life-openMp/gameoflife/game_mp/2"}
{"code": "for (long p = 2; p <= M; p++)\n{\n  if (prime[p] == true)\n  {\n    count++;\n    striker[n_factor] = mark_multiples(prime, p * 2, p, M);\n    factor[n_factor++] = p;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/4_parallel_sieve/parallel_sieve/2"}
{"code": "for (k = 1; k < dims[2]; k++)\n{\n  dummy = randlc(&start, an);\n  starts[k] = start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/10"}
{"code": "for (int i = 0; i < (size + 1); i++)\n{\n  if (i >= size)\n  {\n    palette[i] = (Color){.r = 0, .g = 0, .b = 0};\n    continue;\n  }\n\n  double j;\n  if (i == 0)\n  {\n    j = 3.0;\n  }\n  else\n  {\n    j = 3.0 * (log(i) / log(size - 1.0));\n  }\n\n  if (j < 1)\n  {\n    palette[i] = (Color){.r = 255 * j, .g = 0, .b = 255 * j};\n  }\n  else\n    if (j < 2)\n  {\n    palette[i] = (Color){.r = 255, .g = 255 * (j - 1), .b = 255};\n  }\n  else\n  {\n    palette[i] = (Color){.r = 255 * (j - 2), .g = 255, .b = 255 * (j - 2)};\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abagali1/mandelbrot/parallel/mandelbrot_openmp/2"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < BLOCK_SIZE; m++)\n  {\n    for (n = 0; n < BLOCK_SIZE; n++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][CC][m][n] * rhs[i + 1][j][k][n]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/75"}
{"code": "for (i = 0; i < n; i++)\n  A[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW1/stockwell_hw1_prefix_sums/2"}
{"code": "for (int i = 1; i <= m; i++)\n{\n  int tmp = lcost[i] + rcost[i];\n  if (tmp < min_local)\n  {\n    min_local = tmp;\n    index_local = i;\n  }\n\n}\n\n", "pragma": "omp for simd nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/1"}
{"code": "for (__i = 0; __i < omp_get_max_threads(); __i++)\n{\n  fprintf(stderr, \"Thread %d: %d\\n\", __i, ____num_tasks[__i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/10"}
{"code": "for (i = 0; i < n; ++i)\n  err += (prd[i][0] - b[i][0]) * (prd[i][0] - b[i][0]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/16"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < cols; ++j)\n  {\n    int out_offset = i + (j * rows);\n    double prewitt_x = 0;\n    double prewitt_y = 0;\n    for (int x = i - 1; x <= (i + 1); x++)\n    {\n      for (int y = j - 1; y <= (j + 1); y++)\n      {\n        if ((((x >= 0) && (x < rows)) && (y >= 0)) && (y < cols))\n        {\n          int kxx = x - (i - 1);\n          int kyy = y - (j - 1);\n          const int in_offset = x + (y * rows);\n          const int k_offset = kxx + (kyy * 3);\n          prewitt_x += prewittX[k_offset] * intensity[in_offset];\n          prewitt_y += prewittY[k_offset] * intensity[in_offset];\n        }\n\n      }\n\n    }\n\n    out[out_offset].red = (out[out_offset].green = (out[out_offset].blue = sqrt((prewitt_x * prewitt_x) + (prewitt_y * prewitt_y))));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishig25/2017Block2/patterns/stencil/openmp/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  {\n    if (is_prime(i) == 1)\n      numprimes++;\n\n  }\n}\n\n", "pragma": "omp for reduction(+:numprimes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KevinDHuynh/Julia-Research/C/prime-OpenMP/0"}
{"code": "for (int i = 1; i <= V; i++)\n  dist[i] = INT_MAX;\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspTopologyDriven/2"}
{"code": "for (int i = 0; i < nAntenas; i++)\n{\n  antenas[i].x = atoi(vargs[5 + (i * 2)]);\n  antenas[i].y = atoi(vargs[6 + (i * 2)]);\n  if ((((antenas[i].y < 0) || (antenas[i].y >= rows)) || (antenas[i].x < 0)) || (antenas[i].x >= cols))\n  {\n    fprintf(stderr, \"Antena #%d est\u00e1 fuera del mapa\\n\", i);\n    return -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cramer-0xbit/antenas-openmp/antenas/5"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (((data[i] >= 0) && (prev[i] >= 0)) && (next[i] >= 0))\n  {\n    flag[i] = rnd(seed[omp_get_thread_num()][0]) % 2;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/independentSet/ind_set/2"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n  vector[i][ny - 2][nz - 2] += vector[i][ny - 1][nz - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/30"}
{"code": "for (int i = 0; i < numMutar; i++)\n{\n  int index = aleatorio(num_pixels - 1);\n  actual->imagen[index].r = aleatorio(max);\n  actual->imagen[index].g = aleatorio(max);\n  actual->imagen[index].b = aleatorio(max);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/7"}
{"code": "for (int i = 0; i < pattlength; i++)\n{\n  p = ((d * p) + pattern[i]) % prime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RadhikaBailurkar/OpenMP/PatternSearch/1"}
{"code": "for (int i = 0; i < clusters_size; i++)\n{\n  free(clusters[i].points);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/Parallel_implementation_K_Means_15_sequentional/Parallel_implementation_K_Means_15/Main/3"}
{"code": "for (i = 0; i < x; i++)\n{\n  int lefter;\n  nmin = 0;\n  nmax = 0;\n  lefter = 0;\n  for (j = 0; j < y; j++)\n  {\n    n = (j + 6) - nmin;\n    xa[n] = zya[j];\n    dx[n] = zdy[j];\n    xa0[n] = zya[j];\n    dx0[n] = zdy[j];\n    if (dom[i][j][k] == 0)\n    {\n      state = DOM_FLUID;\n      rho_1D[n] = rho[i][j][k];\n      pre_1D[n] = pre[i][j][k];\n      vx_1D[n] = vy[i][j][k];\n      vy_1D[n] = vz[i][j][k];\n      vz_1D[n] = vx[i][j][k];\n      if (advection == 1)\n        marker_1D[n] = marker[i][j][k];\n\n      if (with_obstacles == 1)\n        pressure_solid_1D[n] = pressure_on_solid[i][j][k];\n\n      pre_1D[n] = max_sweep_y(smallp, pre_1D[n]);\n      eng_1D[n] = (pre_1D[n] / (rho_1D[n] * Gamma)) + (0.5 * ((pow(vx_1D[n], 2) + pow(vy_1D[n], 2)) + pow(vz_1D[n], 2)));\n      if (viscosity_on_off == 1)\n      {\n        if (dimension > 1)\n        {\n          if (((i > 0) && (dom[i - 1][j][k] == 0)) && (i < (x - 1)))\n          {\n            rhodown[n] = rho[i - 1][j][k];\n            vxdown[n] = vy[i - 1][j][k];\n            vydown[n] = vz[i - 1][j][k];\n            vzdown[n] = vx[i - 1][j][k];\n          }\n\n          if (((i > 0) && (dom[i - 1][j][k] != 0)) && (i < (x - 1)))\n          {\n            rhodown[n] = 0.0;\n            vxdown[n] = 0.0;\n            vydown[n] = 0.0;\n            vzdown[n] = 0.0;\n          }\n\n          if (i == 0)\n          {\n            if (bound.left == 0)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.left == 1)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.left == 2)\n              rhodown[n] = small;\n\n            if (bound.left == 3)\n              rhodown[n] = rho_visc[i][j][k];\n\n            if (bound.left == 4)\n              rhodown[n] = inflow_density;\n\n            if (bound.left == 5)\n              rhodown[n] = rho_visc[x - 1][j][k];\n\n            if (bound.left == 0)\n              vxdown[n] = vy_visc[i][j][k];\n\n            if (bound.left == 1)\n              vxdown[n] = -vy_visc[i][j][k];\n\n            if (bound.left == 2)\n              vxdown[n] = small;\n\n            if (bound.left == 3)\n              vxdown[n] = vy_visc[i][j][k];\n\n            if (bound.left == 4)\n              vxdown[n] = 0.0;\n\n            if (bound.left == 5)\n              vxdown[n] = vy_visc[x - 1][j][k];\n\n            if (bound.left == 0)\n              vydown[n] = vz_visc[i][j][k];\n\n            if (bound.left == 1)\n              vydown[n] = -vz_visc[i][j][k];\n\n            if (bound.left == 2)\n              vydown[n] = small;\n\n            if (bound.left == 3)\n            {\n              if (vy_visc[i][j][k] > 0.0)\n                vydown[n] = small;\n\n              if (vy_visc[i][j][k] <= 0.0)\n                vydown[n] = vz_visc[i][j][k];\n\n            }\n\n            if (bound.left == 4)\n              vydown[n] = 0.0;\n\n            if (bound.left == 5)\n              vydown[n] = vz_visc[x - 1][j][k];\n\n            if (bound.left == 0)\n              vzdown[n] = vx_visc[i][j][k];\n\n            if (bound.left == 1)\n              vzdown[n] = -vx_visc[i][j][k];\n\n            if (bound.left == 2)\n              vzdown[n] = small;\n\n            if (bound.left == 3)\n              vzdown[n] = vx_visc[i][j][k];\n\n            if (bound.left == 4)\n              vzdown[n] = inflow_velocity;\n\n            if (bound.left == 5)\n              vzdown[n] = vz_visc[x - 1][j][k];\n\n            rhoup[n] = rho_visc[i + 1][j][k];\n            vxup[n] = vx_visc[i + 1][j][k];\n            vyup[n] = vy_visc[i + 1][j][k];\n            vzup[n] = vz_visc[i + 1][j][k];\n          }\n\n          if (((i < (x - 1)) && (dom[i + 1][j][k] == 0)) && (i > 0))\n          {\n            rhoup[n] = rho_visc[i + 1][j][k];\n            vxup[n] = vy_visc[i + 1][j][k];\n            vyup[n] = vz_visc[i + 1][j][k];\n            vzup[n] = vx_visc[i + 1][j][k];\n          }\n\n          if (((i < (x - 1)) && (dom[i + 1][j][k] != 0)) && (i > 0))\n          {\n            rhoup[n] = 0.0;\n            vxup[n] = 0.0;\n            vyup[n] = 0.0;\n            vzup[n] = 0.0;\n          }\n\n          if (i == (x - 1))\n          {\n            if (bound.right == 0)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.right == 1)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.right == 2)\n              rhoup[n] = small;\n\n            if (bound.right == 3)\n              rhoup[n] = rho_visc[i][j][k];\n\n            if (bound.right == 4)\n              rhoup[n] = inflow_density;\n\n            if (bound.right == 5)\n              rhoup[n] = rho_visc[0][j][k];\n\n            if (bound.right == 0)\n              vxup[n] = vy_visc[i][j][k];\n\n            if (bound.right == 1)\n              vxup[n] = -vy_visc[i][j][k];\n\n            if (bound.right == 2)\n              vxup[n] = small;\n\n            if (bound.right == 3)\n              vxup[n] = vy_visc[i][j][k];\n\n            if (bound.right == 4)\n              vxup[n] = 0.0;\n\n            if (bound.right == 5)\n              vxup[n] = vx_visc[0][j][k];\n\n            if (bound.right == 0)\n              vyup[n] = vz_visc[i][j][k];\n\n            if (bound.right == 1)\n              vyup[n] = -vz_visc[i][j][k];\n\n            if (bound.right == 2)\n              vyup[n] = small;\n\n            if (bound.right == 3)\n            {\n              if (vy_visc[i][j][k] < 0.0)\n                vyup[n] = small;\n\n              if (vy_visc[i][j][k] >= 0.0)\n                vyup[n] = vz_visc[i][j][k];\n\n            }\n\n            if (bound.right == 4)\n              vyup[n] = 0.0;\n\n            if (bound.right == 5)\n              vyup[n] = vz_visc[0][j][k];\n\n            if (bound.right == 0)\n              vzup[n] = vx_visc[i][j][k];\n\n            if (bound.right == 1)\n              vzup[n] = -vx_visc[i][j][k];\n\n            if (bound.right == 2)\n              vzup[n] = small;\n\n            if (bound.right == 3)\n              vzup[n] = vx_visc[i][j][k];\n\n            if (bound.right == 4)\n              vzup[n] = inflow_velocity;\n\n            if (bound.right == 5)\n              vzup[n] = vx_visc[0][j][k];\n\n            rhodown[n] = rho_visc[i - 1][j][k];\n            vxdown[n] = vx_visc[i - 1][j][k];\n            vydown[n] = vy_visc[i - 1][j][k];\n            vzdown[n] = vz_visc[i - 1][j][k];\n          }\n\n        }\n\n        if (dimension > 2)\n        {\n          if (((k > 0) && (dom[i][j][k - 1] == 0)) && (k < (z - 1)))\n          {\n            rhofront[n] = rho_visc[i][j][k - 1];\n            vxfront[n] = vy_visc[i][j][k - 1];\n            vyfront[n] = vz_visc[i][j][k - 1];\n            vzfront[n] = vx_visc[i][j][k - 1];\n          }\n\n          if (((k > 0) && (dom[i][j][k - 1] != 0)) && (k < (z - 1)))\n          {\n            rhofront[n] = 0.0;\n            vxfront[n] = 0.0;\n            vyfront[n] = 0.0;\n            vzfront[n] = 0.0;\n          }\n\n          if (k == 0)\n          {\n            if (bound.front == 0)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 1)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 2)\n              rhofront[n] = small;\n\n            if (bound.front == 3)\n              rhofront[n] = rho_visc[i][j][k];\n\n            if (bound.front == 4)\n              rhofront[n] = inflow_density;\n\n            if (bound.front == 5)\n              rhofront[n] = rho_visc[i][j][z - 1];\n\n            if (bound.front == 0)\n              vxfront[n] = vy_visc[i][j][k];\n\n            if (bound.front == 1)\n              vxfront[n] = -vy_visc[i][j][k];\n\n            if (bound.front == 2)\n              vxfront[n] = small;\n\n            if (bound.front == 3)\n              vxfront[n] = vy_visc[i][j][k];\n\n            if (bound.front == 4)\n              vxfront[n] = 0.0;\n\n            if (bound.front == 5)\n              vxfront[n] = vy_visc[i][j][z - 1];\n\n            if (bound.front == 0)\n              vyfront[n] = vz_visc[i][j][k];\n\n            if (bound.front == 1)\n              vyfront[n] = -vz_visc[i][j][k];\n\n            if (bound.front == 2)\n              vyfront[n] = small;\n\n            if (bound.front == 3)\n              vyfront[n] = vz_visc[i][j][k];\n\n            if (bound.front == 4)\n              vyfront[n] = 0.0;\n\n            if (bound.front == 5)\n              vyfront[n] = vz_visc[i][j][z - 1];\n\n            if (bound.front == 0)\n              vzfront[n] = vx_visc[i][j][k];\n\n            if (bound.front == 1)\n              vzfront[n] = -vx_visc[i][j][k];\n\n            if (bound.front == 2)\n              vzfront[n] = small;\n\n            if (bound.front == 3)\n            {\n              if (vz_visc[i][j][k] > 0.0)\n                vzfront[n] = small;\n\n              if (vz_visc[i][j][k] <= 0.0)\n                vzfront[n] = vx_visc[i][j][k];\n\n            }\n\n            if (bound.front == 4)\n              vzfront[n] = inflow_velocity;\n\n            if (bound.front == 5)\n              vzfront[n] = vx_visc[i][j][z - 1];\n\n            rhoback[n] = rho_visc[i][j][k + 1];\n            vxback[n] = vx_visc[i][j][k + 1];\n            vyback[n] = vy_visc[i][j][k + 1];\n            vzback[n] = vz_visc[i][j][k + 1];\n          }\n\n          if (((k < (z - 1)) && (dom[i][j][k + 1] == 0)) && (k > 0))\n          {\n            rhoback[n] = rho_visc[i][j][k + 1];\n            vxback[n] = vy_visc[i][j][k + 1];\n            vyback[n] = vz_visc[i][j][k + 1];\n            vzback[n] = vx_visc[i][j][k + 1];\n          }\n\n          if (((k < (z - 1)) && (dom[i][j][k + 1] != 0)) && (k > 0))\n          {\n            rhoback[n] = 0.0;\n            vxback[n] = 0.0;\n            vyback[n] = 0.0;\n            vzback[n] = 0.0;\n          }\n\n          if (k == (z - 1))\n          {\n            if (bound.back == 0)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 1)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 2)\n              rhoback[n] = small;\n\n            if (bound.back == 3)\n              rhoback[n] = rho_visc[i][j][k];\n\n            if (bound.back == 4)\n              rhoback[n] = inflow_density;\n\n            if (bound.back == 5)\n              rhoback[n] = rho_visc[i][j][0];\n\n            if (bound.back == 0)\n              vxback[n] = vy_visc[i][j][k];\n\n            if (bound.back == 1)\n              vxback[n] = -vy_visc[i][j][k];\n\n            if (bound.back == 2)\n              vxback[n] = small;\n\n            if (bound.back == 3)\n              vxback[n] = vy_visc[i][j][k];\n\n            if (bound.back == 4)\n              vxback[n] = 0.0;\n\n            if (bound.back == 5)\n              vxback[n] = vy_visc[i][j][0];\n\n            if (bound.back == 0)\n              vyback[n] = vz_visc[i][j][k];\n\n            if (bound.back == 1)\n              vyback[n] = -vz_visc[i][j][k];\n\n            if (bound.back == 2)\n              vyback[n] = small;\n\n            if (bound.back == 3)\n              vyback[n] = vz_visc[i][j][k];\n\n            if (bound.back == 4)\n              vyback[n] = 0.0;\n\n            if (bound.back == 5)\n              vyback[n] = vz_visc[i][j][0];\n\n            if (bound.back == 0)\n              vzback[n] = vx_visc[i][j][k];\n\n            if (bound.back == 1)\n              vzback[n] = -vx_visc[i][j][k];\n\n            if (bound.back == 2)\n              vzback[n] = small;\n\n            if (bound.back == 3)\n            {\n              if (vz_visc[i][j][k] < 0.0)\n                vzback[n] = small;\n\n              if (vz_visc[i][j][k] >= 0.0)\n                vzback[n] = vx_visc[i][j][k];\n\n            }\n\n            if (bound.back == 4)\n              vzback[n] = inflow_velocity;\n\n            if (bound.back == 5)\n              vzback[n] = vx_visc[i][j][0];\n\n            rhofront[n] = rho_visc[i][j][k - 1];\n            vxfront[n] = vx_visc[i][j][k - 1];\n            vyfront[n] = vy_visc[i][j][k - 1];\n            vzfront[n] = vz_visc[i][j][k - 1];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (dom[i][j][k] == 1)\n    {\n      state = DOM_SOLID;\n      rho_1D[n] = obstacle_density;\n      pre_1D[n] = obstacle_temperature;\n      vx_1D[n] = 0.0;\n      vy_1D[n] = 0.0;\n      vz_1D[n] = 0.0;\n      if (advection == 1)\n        marker_1D[n] = 0.0;\n\n      if (with_obstacles == 1)\n        pressure_solid_1D[n] = 0.0;\n\n      pre_1D[n] = 0.0;\n      eng_1D[n] = 0.0;\n    }\n\n\n    if (j < (y - 1))\n    {\n      state_next = (dom[i][j + 1][k] == 0) ? (DOM_FLUID) : (DOM_SOLID);\n    }\n    else\n    {\n      state_next = (state == DOM_FLUID) ? (DOM_SOLID) : (DOM_FLUID);\n    }\n\n    if (state != state_next)\n    {\n      if (state == DOM_FLUID)\n      {\n        int bound_checker;\n        int jj;\n        int nminy2 = 6;\n        int nmaxy2 = (nmax - nmin) + 6;\n        if ((nmin == 0) || (nmax == (y - 1)))\n        {\n          bound_checker = 0;\n        }\n\n        if ((nmax - nmin) != (y - 1))\n        {\n          bound_checker = 1;\n          if (nmin == 0)\n            lefter = 1;\n\n          if (nmax == (y - 1))\n            lefter = 2;\n\n          if ((nmin != 0) && (nmax != (y - 1)))\n            lefter = 3;\n\n        }\n\n        ppm_step(i, j, k, direction, flag, nminy2, nmaxy2, a_coef, ai_coef, b_coef, bi_coef, c_coef, ci_coef, d_x, diffa, da, ar, pl, p6, rl, r6, u6, ul, vl, v6, wl, w6, el, e6, ql, q6, dp, du, dr, dv, dw, dq, de, scratch1, scratch2, scratch3, plft, prgh, ulft, urgh, rlft, rrgh, Cdtdx, fCdtdx, steep, flat, para, clft, crgh, plfti, prghi, pmid, pmold, wlft, wrgh, zlft, zrgh, umidl, umidr, umid, dm, dtbdm, upmid, xa1, xa2, xa3, vx_1D_old, dvol, dvol0, dvol1, delta, fluxr, fluxu, fluxv, fluxw, fluxe, fluxq, dm0, e_int_1D, rho_1D, pre_1D, eng_1D, vx_1D, vy_1D, vz_1D, marker_1D, pressure_solid_1D, dx0, xa0, xa, dx, bound_checker, lefter, rhodown, rhoup, rhofront, rhoback, vxdown, vxup, vxfront, vxback, vydown, vyup, vyfront, vyback, vzdown, vzup, vzfront, vzback, viscosity_on_off, dimension);\n        for (jj = nmin; jj <= nmax; jj++)\n        {\n          n = (jj + 6) - nmin;\n          rho[i][jj][k] = rho_1D[n];\n          pre[i][jj][k] = pre_1D[n];\n          vy[i][jj][k] = vx_1D[n];\n          vz[i][jj][k] = vy_1D[n];\n          vx[i][jj][k] = vz_1D[n];\n          if (advection == 1)\n            marker[i][jj][k] = marker_1D[n];\n\n          if (with_obstacles == 1)\n            pressure_on_solid[i][jj][k] = pressure_solid_1D[n];\n\n        }\n\n      }\n      else\n        if (state == DOM_SOLID)\n      {\n        nmin = nmax + 1;\n      }\n\n\n    }\n\n    nmax++;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/sweep_y/0"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  vcomplexe cc = v[i];\n  printf(\"(%f, %f) \", cc.REEL, cc.IMAG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/axpy/3"}
{"code": "for (i = 0; i < 20480; i++)\n{\n  x[i] = i * 3.14159;\n  for (j = 0; j < 20480; j++)\n  {\n    A[(i * 20480) + j] = (((DATA_TYPE) i) * j) / 20480;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/2"}
{"code": "for (int j = 0; j < n; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    if (i == j)\n      L[j][i] = 1;\n    else\n      L[j][i] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Riceboy112/LU-Decomposition-Program-Performances/LU_OMP/LU-openMP/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  int j = bitRev(i, log_n);\n  a[i] = in[j];\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Fast Fourier Transform/fft_parallel/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  a[i] = malloc(n * (sizeof(float)));\n  for (int j = 0; j < n; j++)\n    scanf(\"%f\", a[i] + j);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oCarye/openMP_practice/task3/0"}
{"code": "for (;;)\n{\n  read_fd = master;\n  fflush(stdout);\n  scaduto = select(maxfd + 1, &read_fd, 0, 0, 0);\n  if (scaduto == (-1))\n  {\n    printf(\"errrore select\\n\");\n    exit(1);\n  }\n\n  printf(\"evento\");\n  for (i = 0; i <= maxfd; i++)\n  {\n    if (FD_ISSET(i, &read_fd))\n    {\n      if (i == 0)\n      {\n        tastiera();\n      }\n      else\n        if (i == sk)\n        mexserver();\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/clientcrush/5"}
{"code": "for (trial = my_first; trial < my_last; trial++)\n{\n  for (i = 0; i < nvars; i++)\n  {\n    startpt[i] = (4.0 * drand48()) - 4.0;\n  }\n\n  jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);\n  fx = f(endpt, nvars);\n  if (fx < best_fx)\n  {\n    best_trial = trial;\n    best_jj = jj;\n    best_fx = fx;\n    for (i = 0; i < nvars; i++)\n      best_pt[i] = endpt[i];\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/katderv/Parallel-Programming/MPI_openMP/0"}
{"code": "for (int i = 0; i < width_; i++)\n{\n  for (int j = 0; j < height_; j++)\n  {\n    grid_cell_[(i * width_) + j]->diffuse_protein();\n    grid_cell_[(i * width_) + j]->degrade_protein();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nathan-K-/PC-optimisation/src/World/5"}
{"code": "for (i = 0; i < numPartitions; i++)\n{\n  a = (i + .5) * interval;\n  for (j = 0; j < numPartitions; j++)\n  {\n    b = (j + .5) * interval;\n    if (((a * a) + (b * b)) <= 1)\n      circleCount++;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/munawira/Using-OpenMP-to-Estimate-Pi/Parallel_3/0"}
{"code": "for (i = 0; i < population_size; i++)\n  free(population[i].person);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/15"}
{"code": "for (i = 0; i < N; i++)\n{\n  last_v[i][0] = v[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/10"}
{"code": "for_handler_pre(construct)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/core/tl-omp-core/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  pops[i] = rand() % 256;\n  totalPop += pops[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/5"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = 1;\n  b[i] = 2;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/omp_data_scope_test2/0"}
{"code": "for (col = 0; col <= (public.in2_sub_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_sub_rows - 1); row += 1)\n  {\n    ori_row = (row + public.in2_pad_cumv_sel_rowlow) - 1;\n    ori_col = (col + public.in2_pad_cumv_sel_collow) - 1;\n    temp = private.d_in2_pad[(ori_col * public.in2_pad_rows) + ori_row];\n    ori_row = (row + public.in2_pad_cumv_sel2_rowlow) - 1;\n    ori_col = (col + public.in2_pad_cumv_sel2_collow) - 1;\n    temp2 = private.d_in2_pad[(ori_col * public.in2_pad_rows) + ori_row];\n    private.d_in2_sub[(col * public.in2_sub_rows) + row] = temp - temp2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/15"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = 1; j < i; j++)\n  {\n    tmpsum += (j + sin(x + j)) / (((2 * i) * j) - 1);\n  }\n\n  if (tmpsum != 0)\n  {\n    sum += 1 / tmpsum;\n  }\n\n  tmpsum = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    if (percentDiff(C[(i * M) + j], D[(i * M) + j]) > ERROR_THRESHOLD)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk/1"}
{"code": "for (int i = 0; i < BS; i++)\n  A[(ll * BS) + i] = _coefs[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/41"}
{"code": "for (i = 0; i < N; i++)\n{\n  loop_1[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/parallel-region-with-multiple-loops/parallel-region-with-multiple-loops/4"}
{"code": "for (int i = 0; i < 8192; i++)\n  m += x1[i], n += x2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/7"}
{"code": "for (unsigned c = 0; c < inoutcount; c++)\n{\n  const unsigned p = inoutpart[c];\n  if (CODE_IsFluidInout(code[p]))\n  {\n    unsigned izone = CODE_GetIzoneFluidInout(code[p]);\n    if (izone >= ListSize)\n      Run_Exceptioon(PrintStr(\"%d> [%s] Value izone %d is invalid of cp=%d idp[%d]=%d.\", nstep, key.c_str(), izone, c, p, idp[p]));\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    y[i] += A[i][j] * x[j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads (t) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurbaaz27/CS433A-Design-Exercises/assignment3/Q2_openmp/2"}
{"code": "for (x = 0; x < dimensions; x++)\n{\n  for (y = 0; y < dimensions; y++)\n  {\n    updated[x][y] = check_adjacents(dimensions, matrix, x, y);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sarabonardi/OpenMPCellGame/ompgame/0"}
{"code": "for (long i = 0; i < I->segments; i++)\n{\n  int QSR_id = rand_r(&seed) % I->source_3D_regions;\n  QSR_id_arr[i] = QSR_id;\n  int FAI_id = rand_r(&seed) % I->fine_axial_intervals;\n  FAI_id_arr[i] = FAI_id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/16"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnrn/Introduction-to-Algorithms/MultiThreaded/MatVec/omp/matvec/0"}
{"code": "for (i = 1; i < nv; i++)\n  printf(\"%u\\n\", mind[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/4"}
{"code": "for (int row = 0; row < rowStride; row++)\n{\n  for (int col = 0; col < colStride; col++)\n  {\n    resultMat[(row * n) + col] = res[(row * colStride) + col];\n  }\n\n}\n\n", "pragma": "              #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/mpi/matrixMulti/gemm/5"}
{"code": "for (int i = 0; i < B->col; i += TILESIZE)\n{\n  for (int k = 0; k < col; k += TILESIZE)\n  {\n    for (int j = 0; j < row; j++)\n    {\n      for (int kk = k; kk < (k + TILESIZE); kk++)\n      {\n        for (int ii = i; ii < (i + TILESIZE); ii++)\n        {\n          calculated->mem[(j * B->col) + ii] += mem[(j * col) + kk] * B->mem[(kk * B->col) + ii];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akgunduz/benchpar/src/app/matrix/matrixfuncs/3"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-i\") == 0)\n  {\n    maxiter = atoi(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-w\") == 0)\n  {\n    width = atoi(argv[++i]);\n    height = width;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    size = atof(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    x0 = atof(argv[++i]);\n    y0 = atof(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-i maxiter -w windowsize -c x0 y0 -s size]\\n\", argv[0]);\n    fprintf(stderr, \"\t   -i to specify maximum number of iterations at each point (default 1000)\\n\");\n    fprintf(stderr, \"\t   -w to specify the size of the image to compute (default 800x800 elements)\\n\");\n    fprintf(stderr, \"\t   -c to specify the center x0+iy0 of the square to compute (default origin)\\n\");\n    fprintf(stderr, \"\t   -s to specify the size of the square to compute (default 2, i.e. size 4 by 4)\\n\");\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab3/par2312-lab3/code/mandel-omp-taskloop-point/3"}
{"code": "for (int i = y; i < (y + height); i += height - 1)\n  for (int j = x; j < (x + width); j++)\n  change += compute_new_state_stable(i, j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/22"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (v[i] > max_val)\n    max_val = v[i];\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(numThreads) reduction(max:max_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment1/1"}
{"code": "formula.append((\"+ \" + number(g)) + \"*F( T + 273.15) \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/31"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int k = 0; k < 3; ++k)\n  {\n    if (r[i][k] > 0)\n    {\n      rn[i][k] = fmod(r[i][k] + L2[k], L[k]) - L2[k];\n    }\n    else\n    {\n      rn[i][k] = fmod(r[i][k] - L2[k], L[k]) + L2[k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/1"}
{"code": "for (int i = 0; i <= game.dimension; ++i)\n{\n  int idx = i + (game.dimension * line_num);\n  if (line[i] == '1')\n  {\n    pieces++;\n    game.grid[idx] = 1;\n  }\n\n  if (line[i] == '3')\n  {\n    game.start_coord = idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marianhlavac/mi-pdp-jes/src/main/0"}
{"code": "for (i = 0; i < _PB_NI; i++)\n{\n  for (j = 0; j < _PB_NI; j++)\n  {\n    C[i][j] *= beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/polybench-acc/OpenMP/linear-algebra/kernels/syr2k/syr2k/1"}
{"code": "for (j = 1; j < numOfProcs; j++)\n{\n  MPI_Send(allClusters, numOfClusters, ClusterMPIType, j, MASTER, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/2"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    u[i][j] = 1.0;\n    u_new[i][j] = 1.0;\n    if ((((x[i] > 0.5) && (x[i] < 1.0)) && (y[i] > 0.5)) && (y[i] < 1.0))\n    {\n      u[i][j] = 2.0;\n      u_new[i][j] = 2.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Linear Convection/2-D_Linear_Convection/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    trans[(i * npadded) + j] = b[(j * npadded) + i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MATMUL/mxm_openmp/2"}
{"code": "for (trial = 0; trial < ntrials; trial++)\n{\n  for (i = 0; i < nvars; i++)\n  {\n    startpt[i] = (4.0 * drand48()) - 4.0;\n  }\n\n  jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);\n  fx = f(endpt, nvars);\n  printf(\"f(x) = %15.7le\\n\", fx);\n  if (fx < best_fx)\n  {\n    best_trial = trial;\n    best_jj = jj;\n    best_fx = fx;\n    for (i = 0; i < nvars; i++)\n      best_pt[i] = endpt[i];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/its-lito/Parallel-Programming/Code/OpenMP-Tasks/4"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  for (i = 0; i < 1000; i++)\n  {\n    if (fabs(C[j][i] - ((double) 1000)) > 1.0e-18)\n    {\n      printf(\" Error! in ( %d , %d ) th argument. \\n\", j, i);\n      iflag = 1;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Mat-Mat/C/mat-mat/3"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"ADD %d\\n\", a + i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/no_wait/0"}
{"code": "for (int fromVertex = 0; fromVertex < vertexCount; ++fromVertex)\n{\n  distancesTable[fromVertex] = Dijkstra(fromVertex, localVertexCount, givenDistance);\n}\n\n", "pragma": "omp parallel for copyin(localVertexCount)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pancak3/Diameter-OpenMP/onePunch/0"}
{"code": "for (i = 0; i < num_elemnts; i++)\n  list_items[i]->data *= 2;\n\n", "pragma": "\t#pragma omp parallel for num_threads (NO_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PSS1998/OpenMP-parallelism/exer02/main/1"}
{"code": "for (j = 0; j < (argc - 1); j++)\n{\n  for (i = 0; i < 1000; i++)\n  {\n    fprintf(fp, \"%s \\n\", words[j][i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/fileread_parallel/1"}
{"code": "for (int i = 1; i < image_height; i++)\n{\n  if (curr_t != message[i])\n  {\n    curr_t = message[i];\n    printf(\"Thread %d \u00ad-> Processing Chunk starting at Row %d\\n\", curr_t, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kujoukaren/CPP-Sobel-Algorithm-OpenMP/Implementation/1"}
{"code": "for (i = 0; i < K_global; i++)\n{\n  temp_delta += (((iterative_centroids_global[(((iter_counter + 1) * K_global) + i) * 3] - iterative_centroids_global[((iter_counter * K_global) + i) * 3]) * (iterative_centroids_global[(((iter_counter + 1) * K_global) + i) * 3] - iterative_centroids_global[((iter_counter * K_global) + i) * 3])) + ((iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 1] - iterative_centroids_global[(((iter_counter * K_global) + i) * 3) + 1]) * (iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 1] - iterative_centroids_global[(((iter_counter * K_global) + i) * 3) + 1]))) + ((iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 2] - iterative_centroids_global[(((iter_counter * K_global) + i) * 3) + 2]) * (iterative_centroids_global[((((iter_counter + 1) * K_global) + i) * 3) + 2] - iterative_centroids_global[(((iter_counter * K_global) + i) * 3) + 2]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/5"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = i * h;\n  sum += x;\n}\n\n", "pragma": "        #pragma omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/skynet118/openmp/rectangle_method/1"}
{"code": "for (int i = 0; i < (threadnum - distance); i += 2 * distance)\n{\n  if (do_first_query)\n    mergeWeekLethalArray(&week_lethal_vector[i][0], week_lethal_vector[i + distance]);\n\n  if (do_second_query)\n    mergeFactor(factor_map_vector[i + distance], factor_map_vector[i]);\n\n  if (do_third_query)\n    mergeBorough(borough_map_vector[i + distance], borough_map_vector[i]);\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/main/2"}
{"code": "for (int i = 0; i < size; i++)\n  L[(i * size) + i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/lu-utils/7"}
{"code": "for (int i = 0; i < N; i += 2)\n{\n  _mm_storeu_pd(&alphaZ[i], _mm_loadu_pd(&z[i]) * _mm_set1_pd(alpha));\n  _mm_storeu_pd(&solution[i], _mm_loadu_pd(&prevSolution[i]) + _mm_loadu_pd(&alphaZ[i]));\n}\n\n", "pragma": "#pragma omp for schedule(TYPE, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_2_SSE/3"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    if (percentDiff(G[(i * 512) + j], G_outputFromGpu[(i * 512) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3MM/src/3mm/4"}
{"code": "for (i = 0; i < 24576; i++)\n{\n  if (percentDiff(x1[i], x1_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n  if (percentDiff(x2[i], x2_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/MVT/mvt_cpu/11"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  model->jump[i] = (rand() % (2 * model->updateFactor)) + 1;\n  model->neighbor[i] = ((rand() % 3) - 1) + (((rand() % 3) - 1) * width);\n  model->position[i] = rand() % model->numberOfSamples;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/3"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    Cities[i][j] = rand() % 1000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex2/tsp2/1"}
{"code": "for (int i = 0; i < nx; i++)\n  for (int j = 0; j < ny; j++)\n  u[(i * nx) + j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/jacobi_omp/10"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int in = i * n;\n  for (j = 0; j < n; j++)\n  {\n    at[j + in] = a[i + (j * m)];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/26"}
{"code": "for (i = 0; i < NX; i++)\n{\n  r[i] = i * M_PI;\n  for (j = 0; j < NY; j++)\n  {\n    A[(i * NY) + j] = (((DATA_TYPE) i) * j) / NX;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/8"}
{"code": "for (int i = 0; i < C->rows; i++)\n{\n  for (int j = 0; j < C->cols; j++)\n  {\n    for (int k = 0; k < A->cols; k++)\n    {\n      C->matrix[i][j] += A->matrix[i][k] * B->matrix[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RaphaelRGusmao/Matrix-Multiplication/matrix/1"}
{"code": "for (i = 1; i < (size - 1); i += 2)\n  if (vector[i] > vector[i + 1])\n{\n  temp = vector[i];\n  vector[i] = vector[i + 1];\n  vector[i + 1] = temp;\n}\n\n\n", "pragma": "omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Josue-Zenteno/OpenMP-Project/src/OrdenaVectorOMP/3"}
{"code": "for (i = 1; i < (400 - 1); ++i)\n{\n  for (j = 1; j < (400 - 1); ++j)\n  {\n    B[(i * 400) + j] = ((((((((c11 * A[((i - 1) * 400) + (j - 1)]) + (c12 * A[((i + 0) * 400) + (j - 1)])) + (c13 * A[((i + 1) * 400) + (j - 1)])) + (c21 * A[((i - 1) * 400) + (j + 0)])) + (c22 * A[((i + 0) * 400) + (j + 0)])) + (c23 * A[((i + 1) * 400) + (j + 0)])) + (c31 * A[((i - 1) * 400) + (j + 1)])) + (c32 * A[((i + 0) * 400) + (j + 1)])) + (c33 * A[((i + 1) * 400) + (j + 1)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/15"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/1"}
{"code": "for (size_t i = 0; i < bodies.size(); ++i)\n{\n  cnu(bodies[i], radius, gravity, snapshot);\n  bodies[i].update_for_tick(elapse, position_range, radius);\n}\n\n", "pragma": "    #pragma omp parallel for shared(bodies,radius,gravity,snapshot,elapse, position_range) default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/philipzhux/parallel-n-body/src/body_pool/3"}
{"code": "for (int i = 0; i < len; i++)\n{\n  if (!arr[i])\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lewis98/OpenMP_Tasks/parallelism/main/0"}
{"code": "for (int k = 0; k < K; ++k)\n{\n  int ijk = (((i * N) * K) + (j * K)) + k;\n  w_ptr[ijk] = 0.1f + v_ptr[ijk];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/tests/target_task/omp-task-bug/0"}
{"code": "for (int i = 0; i < msz; i++)\n  for (int j = 0; j < msz; j++)\n  A[IDX(i, j)] -= LU[IDX(i, j)];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zooltd/LU-decomposition/lu/12"}
{"code": "for (int i = 0; i < _sze; i++)\n  (*_m)[i] = (double *) malloc((sizeof(double)) * _sze);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/4"}
{"code": "for (row = 0; row < NRowsPlusBounds; row++)\n{\n  Trees[(row * NColsPlusBounds) + 0] = NMaxBurnSteps;\n  if (((MyRank == 0) && (row == 0)) || ((MyRank == (Procs - 1)) && (row == (NRows + 1))))\n  {\n    for (col = 1; col < (NCols + 1); col++)\n    {\n      Trees[(row * NColsPlusBounds) + col] = NMaxBurnSteps;\n    }\n\n  }\n\n  Trees[(row * NColsPlusBounds) + (NCols + 1)] = NMaxBurnSteps;\n}\n\n", "pragma": "omp parallel for private(col)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/fire/1"}
{"code": "for (i = 0; i < N; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < N; ++k)\n    {\n      result[i][j] = result[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/4/4/3"}
{"code": "for (i = 0; i < num_vertices; ++i)\n{\n  edgeList->label_array[i] = edgeListmem->label_array[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/4"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  row_cnt[i] = m / nprocs;\n  row_disp[i] = (i * m) / nprocs;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgolubev/Conjugate_Gradient_with_MPI_and_OpenMP/src/conjugate_grad_dense/conj_grad_solve/3"}
{"code": "for (long long i = 0; i < size; i++)\n{\n  colors[i] = BGRColor(bgrColors[3 * i], bgrColors[(3 * i) + 1], bgrColors[(3 * i) + 2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stevenalbert/parallel-histogram/openmp/main/0"}
{"code": "for (i = 0; i < DIM; i++)\n{\n  a[i] = a[i] * a[i];\n  totalp = totalp + a[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahmedmokeddem/OpenMP/activite1/1"}
{"code": "for (int i = 0; i < this->numloci; i++)\n{\n  next_trait.push_back(this->inittraits + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmadsen/neutral-model-cpp/src/population/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmplzq1z3zo.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/openmp/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  if (dirty)\n    vtp_secret_derive(saved_key[index], saved_len[index], secret[index]);\n\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, secret[index], 16);\n  MD5_Update(&ctx, &cur_salt->vsp, sizeof(vtp_summary_packet));\n  if (cur_salt->version != 1)\n    MD5_Update(&ctx, cur_salt->trailer_data, cur_salt->trailer_length);\n\n  MD5_Update(&ctx, cur_salt->vlans_data, cur_salt->vlans_data_length);\n  MD5_Update(&ctx, secret[index], 16);\n  MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vtp_fmt_plug/0"}
{"code": "for (i = 0; i < 302; i++)\n  for (j = 0; j < 302; j++)\n  solution[0][i][j] = (solution[1][i][j] = 0.0);\n\n\n", "pragma": "omp parallel for shared(solution) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moreandres/hotspot/tests/examples/heat2d/heat2d/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  perm[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%.3f \", R[(j * n) + i]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geziogas/ParallelProgramming-Project/qr_par2/7"}
{"code": "for (int i = start_index; i < max_index; i++)\n{\n  const int key = my_bucket_keys[i];\n  if ((key < my_min_key) || (key > my_max_key))\n  {\n    printf(\"Rank %d Failed Verification!\\n\", shmem_my_pe());\n    printf(\"Key: %d is outside of bounds [%d, %d]\\n\", key, my_min_key, my_max_key);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/15"}
{"code": "for (i = 0; i < SIZE; i++)\n  sum += arr[i];\n\n", "pragma": "omp parallel for default(shared) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubhams167/intro-to-OpenMP/OMP - ArraySum/0"}
{"code": "for (int i = m; i < n; i++)\n{\n  C[i - m] = L[(2 * (i - m)) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoEREW/5"}
{"code": "for (i = 1; i < n_subprobs; i++)\n{\n  res_offset = ((((int) (i / ((int) sqrt(n_subprobs)))) * subprob_size) * subprob_size) * ((int) sqrt(n_subprobs));\n  res_offset += (i % ((int) sqrt(n_subprobs))) * subprob_size;\n  MPI_Recv(res[0] + res_offset, 1, double_strided_vect, i, generic_tag, 1, (MPI_Status *) 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/14"}
{"code": "for (int64_t r = lev_beg; r < lev_end; ++r)\n{\n  int64_t i = order[r];\n  int64_t h = ptr[r];\n  for (int64_t j = _ptr[i]; j < _ptr[i + 1]; ++j)\n  {\n    col[h] = _col[j];\n    val[h] = _val[j];\n    ++h;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/7"}
{"code": "for (int i = 0; i < n; i++)\n  y[i] = (s * x[i]) + y[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/openmp/declare_variant_if/declare_variant_if/0"}
{"code": "for (int i = 1; i < tranche; i++)\n{\n  for (int j = 1; j < tranche; j++)\n  {\n    tile_handler_optim_task(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pravez/VitaeLabilis/src/compute/9"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n  for (int k = 0; k < N; ++k)\n{\n  printf(\"outer[%d].arr[%d].arr[%d].data1 = %d.\\n\", i, j, k, outer[i].arr[j].arr[k].data1);\n  printf(\"outer[%d].arr[%d].arr[%d].data2 = %d.\\n\", i, j, k, outer[i].arr[j].arr[k].data2);\n  assert((outer[i].arr[j].arr[k].data1 == 11) && (outer[i].arr[j].arr[k].data2 == 22));\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/test/mapping/declare_mapper_nested_default_mappers_complex_structure/0"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = (float) strtod(head, &tail);\n    if (tail == head)\n    {\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n    }\n\n    if (mat->rsizes[i] < 0)\n    {\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = strtof(head, &tail);\n      if (tail == head)\n      {\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n      }\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n      {\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n      }\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/62"}
{"code": "for (int i = 1; i <= rows_per_proc; i++)\n{\n  MPI_File_seek(fh, ((bytes * ((start_row + i) - 1)) * width) + (bytes * start_col), MPI_SEEK_SET);\n  MPI_File_read(fh, &t0[((bytes * (cols_per_proc + 2)) * i) + bytes], bytes * cols_per_proc, (MPI_Datatype) 0x4c00010d, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NickLekkas01/img-convolution/src/imgconv/1"}
{"code": "for (i = ist; i <= L2; i++)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21i = tmp * rsd[i][j][k][1];\n  u31i = tmp * rsd[i][j][k][2];\n  u41i = tmp * rsd[i][j][k][3];\n  u51i = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i - 1][j][k][0];\n  u21im1 = tmp * rsd[i - 1][j][k][1];\n  u31im1 = tmp * rsd[i - 1][j][k][2];\n  u41im1 = tmp * rsd[i - 1][j][k][3];\n  u51im1 = tmp * rsd[i - 1][j][k][4];\n  flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n  flux[i][j][k][2] = tx3 * (u31i - u31im1);\n  flux[i][j][k][3] = tx3 * (u41i - u41im1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,iend1 ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/22"}
{"code": "for (size_t i = 0; i < n1; i++)\n{\n  for (size_t k = 0; k < m1; k++)\n  {\n    const float *bl = mb[k];\n    const float v = ma[i][k];\n    float *rl = resultMatrix[i];\n    for (size_t j = 0; j < m2; j++)\n    {\n      rl[j] += v * bl[j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/4"}
{"code": "for (int i = 1; i < worldSize; i++)\n{\n  areaa[0] = ((x / worldSize) * i) + offset;\n  areaa[1] = (((x / worldSize) * (i + 1)) - 1) + offset;\n  MPI_Send((void *) areaa, 2, (MPI_Datatype) 0x4c000405, i, 0, 1);\n  printf(\"Host 0 - Enviado dimens\u00f5es para Host %d\\n\", i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gustavohubner/ippd-mandelbrot/mandel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (j = 0; j < n; j++)\n  {\n    b[i][j] = a[i];\n    printf(\"b[%d][%d] = %d, threads: %d\\n\", i, j, b[i][j], omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/012_nested_parallelism/0"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  if (i == 1)\n    Second_Word_Count(content_odd);\n  else\n    Second_Word_Count(content_even);\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jayrobo/OpenMP/Lab 4/Word_Count/6"}
{"code": "for (int i = 0; i < dup_vector.size(); i++)\n{\n  reduced_vector.push_back(reduceFunc(dup_vector[i]));\n}\n\n", "pragma": "    #pragma omp parallel for reduction (merge: reduced_vector)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akermanmc/ENSC351_L4/word_countMR_OMP/4"}
{"code": "for (int i = 0; i < nthreads; i++)\n  do_something(my_thread_id);\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_regions/05c_order_of_threads/0"}
{"code": "for (int i = 0; i < p_len; i++)\n{\n  center.pos[0] += p_list[i].pos[0];\n  center.pos[1] += p_list[i].pos[1];\n  center.pos[2] += p_list[i].pos[2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lewis98/OpenMP_Tasks/parallelism/main/3"}
{"code": "for (i = 1; i < numClusters; i++)\n  newClusters[i] = newClusters[i - 1] + numFea;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/10"}
{"code": "for (long int i = 0; i < N; ++i)\n{\n  for (long int j = 0; j < N; ++j)\n  {\n    CheckEqual(C[(i * N) + j], COptim[(i * N) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP9/tests/matrix/2"}
{"code": "for (i = 1; i < num_steps; i++)\n{\n  x = (i - 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daramgineer/OpenMP_study/Source/for_loop_compare/0"}
{"code": "for (y = 0; y < 100; y++)\n{\n  toprint[y][100] = 0;\n  printf(\"%s\\n\", toprint[y]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP5/Fichiers/tsp-main/6"}
{"code": "for (int proj = 0; proj < vagas.size(); proj++)\n{\n  while (vagas[proj] > 0)\n  {\n    aluno_projeto.push_back(proj);\n    vagas[proj] -= 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Veguinho/Projeto1_Supercomp/busca_local_par/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(packfile, \"%lf\", &v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/23"}
{"code": "for (npy_intp i = 0; i < xsize; ++i)\n{\n  xdata[i] = op->apply(xdata[i], ydata[i]);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gregvw/mpops/operations/1"}
{"code": "for (int i = 0; i < ((3 * w) * h); i++)\n{\n  if (abs(rgb_sequential[i] - rgb_parallel[i]) > 0.01)\n  {\n    failed = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/z2/dz1_z2/2"}
{"code": "for (m = 0; m < 4; m++)\n{\n  for (i = 0; i < 3; ++i)\n  {\n    ++row;\n    column = -1;\n    for (n = 0; n <= m; n++)\n    {\n      for (j = 0; j < 3; j++)\n      {\n        ++column;\n        ts = ds[i][m] * ds[j][n];\n        if (i == j)\n        {\n          ts = ts * c1;\n          tt = (((ds[0][m] * ds[0][n]) + (ds[1][m] * ds[1][n])) + (ds[2][m] * ds[2][n])) * c3;\n        }\n        else\n        {\n          if (m == n)\n          {\n            ts = ts * c1;\n            tt = 0;\n          }\n          else\n          {\n            ts = ts * c2;\n            tt = (ds[j][m] * ds[i][n]) * c3;\n          }\n\n        }\n\n        Ke[row][column] = (Ke[row][column] + ts) + tt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/14"}
{"code": "for (int i = 0; i < 992; i++)\n  pA[i] = (pC[i] + ((i - 1) * omp_is_initial_device())) + 1;\n\n", "pragma": "      #pragma omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-target-map-ptr/test/4"}
{"code": "for (int i = 1; i < size; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/13"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    if (dom[i][j][k] == 0)\n    {\n      tmpdy = zdy[j];\n      tmpdz = zdz[k];\n      min_tmp1 = min_dt_first(tmpdy, tmpdz);\n      tmp = min_dt_first(zdx[i], min_tmp1);\n      svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / zdx[i];\n      xvel = fabs(vx[i][j][k]) / zdx[i];\n      yvel = fabs(vy[i][j][k]) / tmpdy;\n      zvel = fabs(vz[i][j][k]) / tmpdz;\n      max_tmp1 = max_dt_first(xvel, yvel);\n      max_tmp2 = max_dt_first(zvel, svel);\n      max_tmp3 = max_dt_first(max_tmp1, max_tmp2);\n      rdt1 = max_dt_first(max_tmp3, rdt1);\n      if (viscosity_on_off == 1)\n      {\n        temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n        kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n        s_visc = kin_viscosity / (tmp * tmp);\n        rdt1 = max_dt_first(s_visc, rdt1);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc_first/1"}
{"code": "for (int i = 1; i < MAX_ROWS; ++i)\n{\n  if (iArray[i] > max)\n  {\n    max = iArray[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/9"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    xvel0[FTNREF2D(j, 1 - k, x_max + 5, x_min - 2, y_min - 2)] = xvel0[FTNREF2D(j, 1 + k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/28"}
{"code": "for (int i = 0; i < amount; i++)\n{\n  int cluster_index = cluster_of_points[i];\n  cluster_parallel[cluster_index].size++;\n  cluster_parallel[cluster_index].cluster_points[cluster_parallel[cluster_index].size - 1] = points[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/9"}
{"code": "for (i = 0; i < N; i++)\n  k = fscanf(file, \"%lf\", &testVec[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/savvpais/omp-pagerank/pageRankGSOMP/8"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == fluid)\n  {\n    double sum1 = 0.0;\n    double sum2 = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double dstij2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            if (dstij2 < reS2)\n            {\n              if ((j != i) && (particleType[j] == fluid))\n              {\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                sum1 += wS;\n                if (PTYPE[j] >= 2)\n                  sum2 += wS;\n\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    if (sum1 < 1.0e-8)\n      Cv[i] = 0.0;\n    else\n      Cv[i] = sum2 / sum1;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/64"}
{"code": "for (int i = 0; i < ans.size(); i++)\n{\n  ans[i] = vec1[i] / vec2[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector/div/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    x = ((((double) (j - 1)) * x_max) + (((double) (m - j)) * x_min)) / ((double) (m - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (n - i)) * y_min)) / ((double) (n - 1));\n    cant[i][j] = 0;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= cant_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        cant[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if ((cant[i][j] % 2) == 1)\n    {\n      r[i][j] = 255;\n      g[i][j] = 255;\n      b[i][j] = 255;\n    }\n    else\n    {\n      c = (int) (255.0 * sqrt(sqrt(sqrt(((double) cant[i][j]) / ((double) cant_max)))));\n      r[i][j] = (3 * c) / 5;\n      g[i][j] = (3 * c) / 5;\n      b[i][j] = c;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/Fractal-Mandelbrot/main/0"}
{"code": "for (int i = 0; i <= m_nReaches; i++)\n{\n  m_ptNO3ToCh[i] = 0.f;\n  m_ptNH4ToCh[i] = 0.f;\n  m_ptOrgNToCh[i] = 0.f;\n  m_ptTNToCh[i] = 0.f;\n  m_ptSolPToCh[i] = 0.f;\n  m_ptOrgPToCh[i] = 0.f;\n  m_ptTPToCh[i] = 0.f;\n  m_ptCODToCh[i] = 0.f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrCH_QUAL2E/NutrCH_QUAL2E/4"}
{"code": "for (i = 0; i < v_ind; i++)\n{\n  pieceWiseMul[i] = value[i] * multVector[column[i]];\n}\n\n", "pragma": "omp parallel for shared(v_ind, pieceWiseMul,value,multVector) private(i) schedule(dynamic, chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/sparceMatrix/sparceMatrix_parallel/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (5.0 * u[m][i][j][k])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,i ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/109"}
{"code": "for (i = 0; i <= 10; i++)\n{\n  x = i;\n  printf(\"N\u00famero da thread: %d    x: %d\\n\", omp_get_thread_num(), x);\n}\n\n", "pragma": "omp parallel for lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_lastprivate/0"}
{"code": "for (int i = 0; i < rowCount; i++)\n{\n  tempMatrix[i] = (double *) calloc(colCount, sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erdemegemarasli/Parallel-Computing-CS426-P3/main/1"}
{"code": "for (i = 0; i < (input->d - 1); i++)\n  printf(\"%f,\", input->xh[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/14"}
{"code": "for (int i = 0; i < classcount; i++)\n{\n  if (arr[i] > max)\n  {\n    max = arr[i];\n    maxind = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhantkulkarni/parallelmachinelearning/Code/Naive Bayesian/parallelnaive/7"}
{"code": "for (i = 0; i < r; i++)\n  a1[i] = (int *) malloc(c * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog2_MatrixMul_opemmp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  phi[i] = tmp + (i * m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiackAloZ/OPoly/benchmarks/src/omp-gauss-seidel-2d/1"}
{"code": "for (int iz = (half_length + bound_length) - 1; iz >= half_length; iz--)\n{\n  #pragma ivdep\n  for (int ix = half_length + bound_length; ix <= ((lwnx - half_length) - bound_length); ix++)\n  {\n    next[(iz * wnx) + ix] *= sponge_coefficients[iz - half_length];\n    next[((((iz + wnz) - (2 * iz)) - 1) * wnx) + ix] *= sponge_coefficients[iz - half_length];\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(static, 1) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp/boundary-managers/SpongeBoundaryManager/0"}
{"code": "for (int i = 0; i < totalNodes; i++)\n{\n  distance[i] = reversedistance[(totalNodes - i) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac3/EulerTour_EREW_OpenMP/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum += a[i];\n  printf(\"\\n Sum:%d i:%d id:%d\", sum, i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/sum_array_red/0"}
{"code": "for (j = 1; j < (128 - 1); ++j)\n{\n  for (i = 1; i < (128 - 1); ++i)\n  {\n    int k;\n    for (k = 1; k < (128 - 1); ++k)\n    {\n      B[((i * (128 * 128)) + (j * 128)) + k] = ((((((((((((((c11 * A[(((i - 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)]) + (c13 * A[(((i + 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)])) + (c21 * A[(((i - 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)])) + (c23 * A[(((i + 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)])) + (c31 * A[(((i - 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)])) + (c33 * A[(((i + 1) * (128 * 128)) + ((j - 1) * 128)) + (k - 1)])) + (c12 * A[(((i + 0) * (128 * 128)) + ((j - 1) * 128)) + (k + 0)])) + (c22 * A[(((i + 0) * (128 * 128)) + ((j + 0) * 128)) + (k + 0)])) + (c32 * A[(((i + 0) * (128 * 128)) + ((j + 1) * 128)) + (k + 0)])) + (c11 * A[(((i - 1) * (128 * 128)) + ((j - 1) * 128)) + (k + 1)])) + (c13 * A[(((i + 1) * (128 * 128)) + ((j - 1) * 128)) + (k + 1)])) + (c21 * A[(((i - 1) * (128 * 128)) + ((j + 0) * 128)) + (k + 1)])) + (c23 * A[(((i + 1) * (128 * 128)) + ((j + 0) * 128)) + (k + 1)])) + (c31 * A[(((i - 1) * (128 * 128)) + ((j + 1) * 128)) + (k + 1)])) + (c33 * A[(((i + 1) * (128 * 128)) + ((j + 1) * 128)) + (k + 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3DCONV/3DConvolution/5"}
{"code": "for (long i = 0; i < m; i++)\n  (cout << V[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task8/3"}
{"code": "for (i = 2; i <= n; i++)\n{\n  prime = 1;\n  for (j = 2; j < ((i / 2) + 1); j++)\n  {\n    if ((i % j) == 0)\n    {\n      prime = 0;\n      break;\n    }\n\n  }\n\n  total = total + prime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illia20/OpenMPPrime/OpenMPPrime/OpenMPPrime/1"}
{"code": "for (i = 0; i < 5; i++)\n  teste2(i);\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_ordered/1"}
{"code": "for (int i = 0; i < (N - 1); ++i)\n  if (array[i] > array[i + 1])\n{\n  (cout << i) << \" not sorted!!!\\n\";\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kvitnat/Parallel-programming-lab/OpenMP/omp/1"}
{"code": "for (int x = 0; x < GRAIN; x++)\n{\n  for (int y = 0; y < GRAIN; y++)\n  {\n    for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n    {\n      for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n      {\n        compute_new_state(i, j);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/1"}
{"code": "for (int w = 0; w < divider; w++)\n  for (int m = 0; m < divider; m++)\n{\n  if (m == dx)\n    break;\n\n  sum += *((matrixdata + ((x * divider) + m)) + (((y * divider) + w) * DtCol));\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/32"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (jlo = 0; jlo < n; jlo = jlo + 4)\n  {\n    jhi = i4_min(jlo + 4, n);\n    for (j = jlo; j < jhi; j++)\n    {\n      fprintf(output_unit, \"  %d  %d  %d\", r[i][j], g[i][j], b[i][j]);\n    }\n\n    fprintf(output_unit, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/mandelbrot_openmp/1"}
{"code": "for (int i = 0; i < size; i++)\n  sum += arr[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bolek117/CP-OpenMP/cp_omp/main/2"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      flux[i][0] = rsd[k][j][i][1];\n      u21 = rsd[k][j][i][1] / rsd[k][j][i][0];\n      q = (0.50 * (((rsd[k][j][i][1] * rsd[k][j][i][1]) + (rsd[k][j][i][2] * rsd[k][j][i][2])) + (rsd[k][j][i][3] * rsd[k][j][i][3]))) / rsd[k][j][i][0];\n      flux[i][1] = (rsd[k][j][i][1] * u21) + (C2 * (rsd[k][j][i][4] - q));\n      flux[i][2] = rsd[k][j][i][2] * u21;\n      flux[i][3] = rsd[k][j][i][3] * u21;\n      flux[i][4] = ((C1 * rsd[k][j][i][4]) - (C2 * q)) * u21;\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (tx2 * (flux[i + 1][m] - flux[i - 1][m]));\n      }\n\n    }\n\n    for (i = ist; i < nx; i++)\n    {\n      tmp = 1.0 / rsd[k][j][i][0];\n      u21i = tmp * rsd[k][j][i][1];\n      u31i = tmp * rsd[k][j][i][2];\n      u41i = tmp * rsd[k][j][i][3];\n      u51i = tmp * rsd[k][j][i][4];\n      tmp = 1.0 / rsd[k][j][i - 1][0];\n      u21im1 = tmp * rsd[k][j][i - 1][1];\n      u31im1 = tmp * rsd[k][j][i - 1][2];\n      u41im1 = tmp * rsd[k][j][i - 1][3];\n      u51im1 = tmp * rsd[k][j][i - 1][4];\n      flux[i][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][2] = tx3 * (u31i - u31im1);\n      flux[i][3] = tx3 * (u41i - u41im1);\n      flux[i][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      frct[k][j][i][0] = frct[k][j][i][0] + ((dx1 * tx1) * ((rsd[k][j][i - 1][0] - (2.0 * rsd[k][j][i][0])) + rsd[k][j][i + 1][0]));\n      frct[k][j][i][1] = (frct[k][j][i][1] + (((tx3 * C3) * C4) * (flux[i + 1][1] - flux[i][1]))) + ((dx2 * tx1) * ((rsd[k][j][i - 1][1] - (2.0 * rsd[k][j][i][1])) + rsd[k][j][i + 1][1]));\n      frct[k][j][i][2] = (frct[k][j][i][2] + (((tx3 * C3) * C4) * (flux[i + 1][2] - flux[i][2]))) + ((dx3 * tx1) * ((rsd[k][j][i - 1][2] - (2.0 * rsd[k][j][i][2])) + rsd[k][j][i + 1][2]));\n      frct[k][j][i][3] = (frct[k][j][i][3] + (((tx3 * C3) * C4) * (flux[i + 1][3] - flux[i][3]))) + ((dx4 * tx1) * ((rsd[k][j][i - 1][3] - (2.0 * rsd[k][j][i][3])) + rsd[k][j][i + 1][3]));\n      frct[k][j][i][4] = (frct[k][j][i][4] + (((tx3 * C3) * C4) * (flux[i + 1][4] - flux[i][4]))) + ((dx5 * tx1) * ((rsd[k][j][i - 1][4] - (2.0 * rsd[k][j][i][4])) + rsd[k][j][i + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][j][1][m] = frct[k][j][1][m] - (dssp * ((((+5.0) * rsd[k][j][1][m]) - (4.0 * rsd[k][j][2][m])) + rsd[k][j][3][m]));\n      frct[k][j][2][m] = frct[k][j][2][m] - (dssp * (((((-4.0) * rsd[k][j][1][m]) + (6.0 * rsd[k][j][2][m])) - (4.0 * rsd[k][j][3][m])) + rsd[k][j][4][m]));\n    }\n\n    for (i = 3; i < (nx - 3); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (dssp * ((((rsd[k][j][i - 2][m] - (4.0 * rsd[k][j][i - 1][m])) + (6.0 * rsd[k][j][i][m])) - (4.0 * rsd[k][j][i + 1][m])) + rsd[k][j][i + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][j][nx - 3][m] = frct[k][j][nx - 3][m] - (dssp * (((rsd[k][j][nx - 5][m] - (4.0 * rsd[k][j][nx - 4][m])) + (6.0 * rsd[k][j][nx - 3][m])) - (4.0 * rsd[k][j][nx - 2][m])));\n      frct[k][j][nx - 2][m] = frct[k][j][nx - 2][m] - (dssp * ((rsd[k][j][nx - 4][m] - (4.0 * rsd[k][j][nx - 3][m])) + (5.0 * rsd[k][j][nx - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/erhs/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  flag[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/13"}
{"code": "for (int i = treadsCount - 1; i >= 0; --i)\n{\n  printf(\"-- Hello world. Thread #%d, treads count %d --\\n\", omp_get_thread_num(), omp_get_num_threads());\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 1) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/21"}
{"code": "for (int ii = 0; ii < nb; ++ii)\n{\n  x[ii] = X_VAL;\n  y[ii] = Y_VAL;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-critical/test/0"}
{"code": "for (j = 0; j < npxy; j++)\n{\n  part[2 + (idimp * j)] = vtx * ranorm();\n  part[3 + (idimp * j)] = vty * ranorm();\n  part[4 + (idimp * j)] = vtz * ranorm();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/23"}
{"code": "for (w = 0; w <= W; w++)\n{\n  if ((i == 0) || (w == 0))\n    K[i][w] = 0;\n  else\n    if (wt[i - 1] <= w)\n    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);\n  else\n    K[i][w] = K[i - 1][w];\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mgarralda/hpc/hybrid/knapsack_dyn_hybrid/0"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.m; j++)\n  {\n    dataSet.C[(i * dataSet.m) + j] = dataSet.A[(i * dataSet.m) + j] + dataSet.B[(i * dataSet.m) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /matrix_add/2"}
{"code": "for (int ipatch = 0; ipatch < npatches; ipatch++)\n{\n  nrowL = Lindex_Patch[ipatch];\n  nrowR = Rindex_Patch[ipatch];\n  vsize[ipatch] = nrowL * nrowR;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arghyac007/DMRG-openMP/openmpPrototypeTests/2Level_Indi_aHT/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  array[i] = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/omp_parallel_for/loop_array_test/0"}
{"code": "for (int i = 0; i < nErosions; i++)\n{\n  erosion(multipleProcessedImg, m, n, SE, seRows, seCols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/delchiaro/parallel-project/src/mainSimpleStructured/1"}
{"code": "for (v = 0; v < num_vertices; v++)\n{\n  pageRanksFP[v] = FloatToFixed32SORT(pageRanks[v]);\n  pageRanksFPTemp[v] = 0;\n  labelsTemp[v] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/0"}
{"code": "for (i = 0; i < numClusters; i++)\n{\n  for (j = 0; j < numCoords; j++)\n  {\n    if (newClusterSize[i] > 0)\n      clusters[i][j] = newClusters[i][j] / newClusterSize[i];\n\n    newClusters[i][j] = 0.0;\n  }\n\n  newClusterSize[i] = 0;\n}\n\n", "pragma": "omp for private(j) schedule(dynamic, 10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdigenis/High_Performance_Computing/k-means_northwestern_Optimized/seq_kmeans/0"}
{"code": "for (int i = 1; i < nthreads; i++)\n{\n  add[i] *= add[i - 1];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iPogot/Parallel-Programming/term_2/exp/prog/1"}
{"code": "for (int k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (int j = x_min; j <= (x_max + 1); j++)\n  {\n    xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = xvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_reset_field/2"}
{"code": "for (int s = k - 1; s < n; s++)\n{\n  double newElement = fabs(augmentedMatrix[s][k - 1]);\n  if (newElement > maxElement)\n  {\n    maxElement = newElement;\n    maxRow = s;\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for shared(maxElement, maxRow, k, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/gaussianElimination/gaussianEliminationPartialPivot/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  tid = omp_get_thread_num();\n  ((((cout << \"Default: Thread \") << tid) << \" executing iteration \") << i) << endl;\n}\n\n", "pragma": "#pragma omp parallel for private(tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/main/1"}
{"code": "for (int j = 0; j < 4; j++)\n{\n  timediff.startTime();\n  int threadsNumber = 2 << j;\n  ParallelPrefixSum(X, Sparallel, N, threadsNumber);\n  timediff.endTime();\n  obj.SetDataFromSource(S, j + 3, ileOstatnichWyswietlic, N);\n  obj.setTime(1, j + 3, to_string(timediff.measure()));\n  timediff.reset();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/inirion/MpiIndexowanie/Source/11"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    if (percentDiff(A[(i * 512) + j], A_outputFromGpu[(i * 512) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/GRAMSCHM/src/gramschmidt/4"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    C[(i * 1024) + j] = 0.0;\n    for (k = 0; k < 1024; ++k)\n    {\n      C[(i * 1024) + j] += A[(i * 1024) + k] * B[(k * 1024) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/2MM/src/2mm/5"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  (cout << (*(table_even + i))) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Tri_Pair_Impair/TriPI_openmp_pair_impair/3"}
{"code": "for (it = 0; it < SIZE_OF_CNT; it++)\n{\n  beg_pos[it] = cnt[it];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/9"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x[i], nbins, xmin, xmax, edges);\n  values[bin]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/5"}
{"code": "for (int k = 1; k < N; k += 2)\n{\n  for (int j = 1; j < N; j += 2)\n  {\n    for (int i = 1; i < N; i += 2)\n    {\n      temp = 0.5 * evaluate_array3d(X, N, i, j, k);\n      temp += (1.0 / 24.0) * (((((evaluate_array3d(X, N, i + 1, j, k) + evaluate_array3d(X, N, i - 1, j, k)) + evaluate_array3d(X, N, i, j + 1, k)) + evaluate_array3d(X, N, i, j - 1, k)) + evaluate_array3d(X, N, i, j, k + 1)) + evaluate_array3d(X, N, i, j, k - 1));\n      temp += (1.0 / 48.0) * (((((((((((evaluate_array3d(X, N, i + 1, j + 1, k) + evaluate_array3d(X, N, i - 1, j + 1, k)) + evaluate_array3d(X, N, i + 1, j - 1, k)) + evaluate_array3d(X, N, i - 1, j - 1, k)) + evaluate_array3d(X, N, i + 1, j, k + 1)) + evaluate_array3d(X, N, i - 1, j, k + 1)) + evaluate_array3d(X, N, i, j + 1, k + 1)) + evaluate_array3d(X, N, i, j - 1, k + 1)) + evaluate_array3d(X, N, i + 1, j, k - 1)) + evaluate_array3d(X, N, i - 1, j, k - 1)) + evaluate_array3d(X, N, i, j + 1, k - 1)) + evaluate_array3d(X, N, i, j - 1, k - 1));\n      fill_array3d(new_X, N / 2, i / 2, j / 2, k / 2, temp);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/restriction3d/0"}
{"code": "for (i = 0; i < 32768; i++)\n{\n  tmp[i] = 0;\n  for (j = 0; j < 32768; j++)\n  {\n    tmp[i] = tmp[i] + (A[(i * 32768) + j] * x[j]);\n  }\n\n  for (j = 0; j < 32768; j++)\n  {\n    y[j] = y[j] + (A[(i * 32768) + j] * tmp[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/12"}
{"code": "for (int sys = 0; sys < nb_sys; sys++)\n  if (array_sys[sys].i)\n  printf(\"System %d => i = %d\\n\", sys + 1, array_sys[sys].i);\nelse\n  printf(\"We didn't found i for system %d\\n\", sys + 1);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RadhJL/Parallel-password-cracking/src/main/6"}
{"code": "for (b = 0; b < batch; b++)\n{\n  for (c = 0; c < channels_col; c++)\n  {\n    w_offset = c % ksize;\n    h_offset = (c / ksize) % ksize;\n    c_im = (c / ksize) / ksize;\n    for (h = 0; h < height_col; h++)\n    {\n      for (w = 0; w < width_col; w++)\n      {\n        row = h_offset + (h * stride);\n        col = w_offset + (w * stride);\n        out_index = (((((b * height) * width) * channels) + ((c_im * height) * width)) + (row * width)) + col;\n        col_index = (((c * height_col) * width_col) + (h * width_col)) + w;\n        row -= pad;\n        col -= pad;\n        if ((((row < 0) || (col < 0)) || (row >= height)) || (col >= width))\n        {\n          conv_t1[col_index] = 0.0;\n        }\n        else\n        {\n          conv_t1[col_index] = input[out_index];\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < M; i++)\n  {\n    for (j = 0; j < N; j++)\n    {\n      sum = 0;\n      for (k = 0; k < K; k++)\n      {\n        sum += delta_in[(((b * N) * K) + (j * K)) + k] * conv_t1[(i * K) + k];\n      }\n\n      weight_updates[(i * N) + j] += sum;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-cpu/11"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  M(A, i, j, n) = ((n * i) + j) + 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amerinor01/Practica4-HPC/src/esqueleto/1"}
{"code": "for (int i = 0; i < length; ++i)\n{\n  if ((data[i] > 1000000000000.0) || (data[i] < (-1000000000000.0)))\n    continue;\n\n  sum += data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/4"}
{"code": "for (k = n - 1; k > 0; k--)\n{\n  int j = rand() % (k + 1);\n  int temp = a[j];\n  a[j] = a[k];\n  a[k] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1B/mandelbrot/4"}
{"code": "for (int i1 = 0; i1 < N1; i1++)\n{\n  for (int i2 = 0; i2 < N2; i2++)\n  {\n    for (int i3 = 0; i3 < N3; i3++)\n    {\n      for (int i4 = 0; i4 < N4; i4++)\n      {\n        RES[4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)] = A1[i1];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 1] = A2[i2];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 2] = A3[i3];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 3] = A4[i4];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AleiynikovPavel/OpenMPLab7/main/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < 6; j++)\n  {\n    printf(\"*\");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp for schedule(static, size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPPattern/0"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      printf(\"hello\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(3)  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-nest-nothing/clang-nothing/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  aRef[i] = 0.0;\n  for (j = 0; j < n; j++)\n    aRef[i] += b[(i * n) + j] * c[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultVector/1"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(logFile, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(logFile, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(logFile, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(logFile, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_static/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  wt[i] = 1 + (MaxIntWeight * sprng(stream));\n  if ((i % size) == rank)\n    rank_m[rank] = (i / size) + 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rinriko/OpenMPI_SSCA2.2/gen2DTorus/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  z.arr[i] = arr[i] * k.arr[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector0/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] += i;\n}\n\n", "pragma": "omp parallel for shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.31-shared-clause/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  arr[i] = i + 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_variant/test_declare_variant/2"}
{"code": "for (int i = 0; i < B; i++)\n{\n  shuffle = uvec > ((n, distr_param(0, n - 1)));\n  ynew = trans(y(shuffle));\n  D.zeros();\n  assignew = AssignB(data_proc, D, P, n, cov_num, strt_num, level_num, omeganew, shuffle, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  theta(i) = ((-sum(ynew % (assignew - 2))) / n1) - (sum(ynew % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/24"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j - 1][k][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/100"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  old2NewMap[commIndex[i]] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReordering/1"}
{"code": "for (int y = 0; y < height; y++)\n{\n  const uint16_t *pSrc = input + (width * y);\n  uint16_t *pDst = output_ + ((height - 1) - y);\n  for (int x = 0; x < width; x++)\n  {\n    *pDst = *pSrc;\n    pSrc++;\n    pDst += height;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Michaelangel007/buddhabrot/buddhabrot_omp1/6"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  printf(\"Outer dimension number %d\\n\", i);\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < (dim2 - 1); k++)\n    {\n      printf(\"%f, \", a[i][j][k]);\n    }\n\n    printf(\"%f\\n\", a[i][j][dim2 - 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cooneyro/concurrent-systems/Assignment1/1"}
{"code": "for (int i = 1; i < (*rowsNumber); i++)\n{\n  (*twoDMatrix)[i] = (*twoDMatrix)[i - 1] + (*columnsNumber);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/0"}
{"code": "for (int i = low; i < (low + k); i++)\n  comp_swap(a, i, i + k, asc);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ram-Aditya/Bitonic-Sort/Bitonic Sort/bitsort_parallel/0"}
{"code": "for (ii = 0; ii < i; ii++)\n{\n  for (jj = 0; jj < j; jj++)\n  {\n    REAL sum = 0.0;\n    for (kk = 0; kk < k; kk++)\n    {\n      sum += A[(ii * k) + kk] * B[(kk * j) + jj];\n    }\n\n    C[(ii * j) + jj] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A, B, C, i,j,k) private(ii, jj, kk) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_cpu_omp_kernel/0"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  for (int k = 0; k < CVT_INT(m_nSoilLyrs[i]); k++)\n  {\n    m_sol_WOC[i][k] = (m_soilMass[i][k] * m_soilCbn[i][k]) * 0.01f;\n    m_sol_WON[i][k] = m_soilActvOrgN[i][k] + m_soilStabOrgN[i][k];\n    if (FBM < 1.e-10f)\n      FBM = 0.04f;\n\n    if (FHP < 1.e-10f)\n      FHP = 0.6999999999996266f;\n\n    m_sol_BM[i][k] = FBM * m_sol_WOC[i][k];\n    m_sol_BMC[i][k] = m_sol_BM[i][k];\n    RTO = m_sol_WON[i][k] / m_sol_WOC[i][k];\n    m_sol_BMN[i][k] = RTO * m_sol_BMC[i][k];\n    m_sol_HP[i][k] = FHP * (m_sol_WOC[i][k] - m_sol_BM[i][k]);\n    m_sol_HS[i][k] = (m_sol_WOC[i][k] - m_sol_BM[i][k]) - m_sol_HP[i][k];\n    m_sol_HSC[i][k] = m_sol_HS[i][k];\n    m_sol_HSN[i][k] = RTO * m_sol_HSC[i][k];\n    m_sol_HPC[i][k] = m_sol_HP[i][k];\n    m_sol_HPN[i][k] = RTO * m_sol_HPC[i][k];\n    x1 = m_soilRsd[i][k] * 0.001f;\n    m_sol_LM[i][k] = 500.f * x1;\n    m_sol_LS[i][k] = m_sol_LM[i][k];\n    m_sol_LSL[i][k] = 0.8f * m_sol_LS[i][k];\n    m_sol_LMC[i][k] = 0.42f * m_sol_LM[i][k];\n    m_sol_LMN[i][k] = 0.1f * m_sol_LMC[i][k];\n    m_sol_LSC[i][k] = 0.42f * m_sol_LS[i][k];\n    m_sol_LSLC[i][k] = 0.8f * m_sol_LSC[i][k];\n    m_sol_LSLNC[i][k] = 0.2f * m_sol_LSC[i][k];\n    m_sol_LSN[i][k] = m_sol_LSC[i][k] * 0.006666666666666667f;\n    m_sol_WOC[i][k] += m_sol_LSC[i][k] + m_sol_LMC[i][k];\n    m_sol_WON[i][k] += m_sol_LSN[i][k] + m_sol_LMN[i][k];\n    m_soilStabOrgN[i][k] = m_sol_HPN[i][k];\n    m_soilActvOrgN[i][k] = m_sol_HSN[i][k];\n    m_soilFrshOrgN[i][k] = m_sol_LMN[i][k] + m_sol_LSN[i][k];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NUTR_TF/Nutrient_Transformation/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  pos[curr_step][i][0] = bodies[i].s[0];\n  pos[curr_step][i][1] = bodies[i].s[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/6"}
{"code": "for (int i = 0; i < ncells; i++)\n{\n  float r = (fx[i] * fy[i]) * fy[i];\n  drx[i] = (-r) + (d_c1 * (1.f - fx[i]));\n  dry[i] = r - ((d_c1 + d_c2) * fy[i]);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/reaction-omp/kernels/0"}
{"code": "for (elt = 0; elt < (matrixsize - 1); elt++)\n{\n  if (pid == (elt % p))\n  {\n    printf(\"%.2f, \", values[elt / p]);\n    fflush(0);\n  }\n\n  MPI_Barrier((MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/7"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 0; j < 20; j++)\n  A[i][j] = A[i][j - 1];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/5.race1/0"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  tmpPosition[i].x = satelites[i].position.x;\n  tmpPosition[i].y = satelites[i].position.y;\n  tmpVelocity[i].x = satelites[i].velocity.x;\n  tmpVelocity[i].y = satelites[i].velocity.y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/2"}
{"code": "for (ei_new = 0; ei_new < public.in2_pad_cols; ei_new++)\n{\n  pos_ori = ei_new * public.in2_pad_rows;\n  sum = 0;\n  #pragma loop name kernel#12#0\n  for (position = pos_ori; position < (pos_ori + public.in2_pad_rows); position = position + 1)\n  {\n    private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n    sum = private.d_in2_pad[position];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/13"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 3 * 1; k <= ((grid_points[2] - 3) - 1); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/142"}
{"code": "for (int i = 0; i < (height * width); i++)\n{\n  thread_freq[pic[i]]++;\n}\n\n", "pragma": "                #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GermanRandle/contrast-openmp/image-processor/main/1"}
{"code": "for (i = 0; i < partition->num_edges; ++i)\n{\n  src = partition->edgeList->edges_array_src[i];\n  dest = partition->edgeList->edges_array_dest[i];\n  int v_dest = stats->parents[dest];\n  if (isEnArrayQueued(sharedFrontierQueue, src) && (v_dest < 0))\n  {\n    stats->parents[dest] = src;\n    stats->distances[dest] = stats->distances[src] + 1;\n    enArrayQueue(localFrontierQueue, dest);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/18"}
{"code": "for (i = i_start; i < n; i++)\n{\n  float *tmp_uold = &uold[(((i + uold_0_offset) * uold_m) + uold_1_offset) + j_start];\n  float *tmp_f = &f[(i * m) + j_start];\n  float *tmp_u = &u[(i * m) + j_start];\n  for (j = j_start; j < m; j++)\n  {\n    float resid = ((((ax * (tmp_uold[uold_m] + tmp_uold[-uold_m])) + (ay * (tmp_uold[-1] * tmp_uold[1]))) + (b * tmp_uold[0])) - (*tmp_f)) / b;\n    *tmp_u = (*tmp_uold = omega * resid);\n    er = er + (resid * resid);\n    tmp_uold++;\n    tmp_f++;\n    tmp_u++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) reduction(+:er) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_cpu_omp_kernel/1"}
{"code": "for (i = 0; i < (n / 2); i++)\n  b[i] = a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/mergesort/2"}
{"code": "for (i = 0; i < num_pac; i++)\n  for (j = 0; j < num_snp; j++)\n  SNP_Data[(i * num_snp) + j] = rand() % 3;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/epistatis-omp/main/1"}
{"code": "for (int i = 0; i < m; i++)\n  Lawn2[i] = &array[i * m];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhsu32/OpenMP/anthill/2"}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  int *_imopVarPre193;\n  int *_imopVarPre194;\n  _imopVarPre193 = &colidx[n];\n  _imopVarPre194 = &colidx[0];\n  sprnvc(n, nzv, v, iv, _imopVarPre194, _imopVarPre193);\n  int *_imopVarPre196;\n  _imopVarPre196 = &nzv;\n  vecset(n, v, iv, _imopVarPre196, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    int _imopVarPre198;\n    _imopVarPre198 = jcol >= firstcol;\n    if (_imopVarPre198)\n    {\n      _imopVarPre198 = jcol <= lastcol;\n    }\n\n    if (_imopVarPre198)\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        int _imopVarPre200;\n        _imopVarPre200 = irow >= firstrow;\n        if (_imopVarPre200)\n        {\n          _imopVarPre200 = irow <= lastrow;\n        }\n\n        if (_imopVarPre200)\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/21"}
{"code": "for (int i = 0; i < 3; i++)\n  A_copy[i] = (double *) calloc(3, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/6"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (L * L))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((0.75 - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/70"}
{"code": "for (int i = 1; i < n; i++)\n{\n  previous *= squared_x / ((long double) (((4 * i) * i) + (2 * i)));\n  sum += previous;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ragen1337/taylor_series_openmp/task_taylor_series_pereslyckih/2"}
{"code": "for (j = 0; j < i; j++)\n{\n  y[i] -= L[i][j] * x[j];\n}\n\n", "pragma": "#pragma omp for reduction (-:y[i])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurbaaz27/CS433A-Design-Exercises/assignment1/Q2/2"}
{"code": "for (i = 0; i < 100000000; i++)\n{\n  x = Rand(-1, 1);\n  y = Rand(-1, 1);\n  if (((x * x) + (y * y)) <= 1)\n    count++;\n\n}\n\n", "pragma": "omp parallel for private(x,y) reduction(+:count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IvyHan2013/Monte-Carlo-in-OpenMp/mcopm/0"}
{"code": "for (i = 0; i < numOfPoints; i++)\n  clusters[points[i].belongTo].numOfPointsInProc++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/KmeansParallel/11"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = 0.25 * (((mass_flux_y[FTNREF2D(j - 1, k, x_max + 4, x_min - 2, y_min - 2)] + mass_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) + mass_flux_y[FTNREF2D(j - 1, k + 1, x_max + 4, x_min - 2, y_min - 2)]) + mass_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/9"}
{"code": "for (int i = 0, p; i < elemsNum; i++)\n{\n  for (int j = 0; j < Npt[i]; j++)\n  {\n    p = Np[i][j];\n    Elem_Conc[p][Nconc[p]] = i;\n    No_Corresp[p][Nconc[p]] = j;\n    Nconc[p]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tokarevart/parallel-ensembling/OpenMPParallelEnsembling/1"}
{"code": "for (i = 0; i < LINHAS; i++)\n{\n  for (j = 0; j < COLUNAS_B; j++)\n    printf(\"%6.2f   \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/6-Matriz/MultiMatriz/MultiMatriz/Origem/4"}
{"code": "for (l = 0; l <= (ub - 1); l += 1)\n{\n  int l8 = l * 8;\n  int l36 = l * 36;\n  real8 h12 = m[((l8 + 0) * 4) + 1];\n  real8 h13 = m[((l8 + 0) * 4) + 2];\n  real8 h14 = m[((l8 + 0) * 4) + 3];\n  real8 h22 = m[((l8 + 1) * 4) + 1];\n  real8 h23 = m[((l8 + 1) * 4) + 2];\n  real8 h24 = m[((l8 + 1) * 4) + 3];\n  real8 h32 = m[((l8 + 2) * 4) + 1];\n  real8 h33 = m[((l8 + 2) * 4) + 2];\n  real8 h34 = m[((l8 + 2) * 4) + 3];\n  real8 h42 = m[((l8 + 3) * 4) + 1];\n  real8 h43 = m[((l8 + 3) * 4) + 2];\n  real8 h44 = m[((l8 + 3) * 4) + 3];\n  real8 h52 = m[((l8 + 4) * 4) + 1];\n  real8 h53 = m[((l8 + 4) * 4) + 2];\n  real8 h54 = m[((l8 + 4) * 4) + 3];\n  real8 h62 = m[((l8 + 5) * 4) + 1];\n  real8 h63 = m[((l8 + 5) * 4) + 2];\n  real8 h64 = m[((l8 + 5) * 4) + 3];\n  real8 h72 = m[((l8 + 6) * 4) + 1];\n  real8 h73 = m[((l8 + 6) * 4) + 2];\n  real8 h74 = m[((l8 + 6) * 4) + 3];\n  real8 h82 = m[((l8 + 7) * 4) + 1];\n  real8 h83 = m[((l8 + 7) * 4) + 2];\n  real8 h84 = m[((l8 + 7) * 4) + 3];\n  real8 ddd = d__[l];\n  y[l36 + 0] += ddd * (((h12 * h12) + (h13 * h13)) + (h14 * h14));\n  y[l36 + 1] += ddd * (((h12 * h22) + (h13 * h23)) + (h14 * h24));\n  y[l36 + 2] += ddd * (((h22 * h22) + (h23 * h23)) + (h24 * h24));\n  y[l36 + 3] += ddd * (((h12 * h32) + (h13 * h33)) + (h14 * h34));\n  y[l36 + 4] += ddd * (((h22 * h32) + (h23 * h33)) + (h24 * h34));\n  y[l36 + 5] += ddd * (((h32 * h32) + (h33 * h33)) + (h34 * h34));\n  y[l36 + 6] += ddd * (((h12 * h42) + (h13 * h43)) + (h14 * h44));\n  y[l36 + 7] += ddd * (((h22 * h42) + (h23 * h43)) + (h24 * h44));\n  y[l36 + 8] += ddd * (((h32 * h42) + (h33 * h43)) + (h34 * h44));\n  y[l36 + 9] += ddd * (((h42 * h42) + (h43 * h43)) + (h44 * h44));\n  y[l36 + 10] += ddd * (((h12 * h52) + (h13 * h53)) + (h14 * h54));\n  y[l36 + 11] += ddd * (((h22 * h52) + (h23 * h53)) + (h24 * h54));\n  y[l36 + 12] += ddd * (((h32 * h52) + (h33 * h53)) + (h34 * h54));\n  y[l36 + 13] += ddd * (((h42 * h52) + (h43 * h53)) + (h44 * h54));\n  y[l36 + 14] += ddd * (((h52 * h52) + (h53 * h53)) + (h54 * h54));\n  y[l36 + 15] += ddd * (((h12 * h62) + (h13 * h63)) + (h14 * h64));\n  y[l36 + 16] += ddd * (((h22 * h62) + (h23 * h63)) + (h24 * h64));\n  y[l36 + 17] += ddd * (((h32 * h62) + (h33 * h63)) + (h34 * h64));\n  y[l36 + 18] += ddd * (((h42 * h62) + (h43 * h63)) + (h44 * h64));\n  y[l36 + 19] += ddd * (((h52 * h62) + (h53 * h63)) + (h54 * h64));\n  y[l36 + 20] += ddd * (((h62 * h62) + (h63 * h63)) + (h64 * h64));\n  y[l36 + 21] += ddd * (((h12 * h72) + (h13 * h73)) + (h14 * h74));\n  y[l36 + 22] += ddd * (((h22 * h72) + (h23 * h73)) + (h24 * h74));\n  y[l36 + 23] += ddd * (((h32 * h72) + (h33 * h73)) + (h34 * h74));\n  y[l36 + 24] += ddd * (((h42 * h72) + (h43 * h73)) + (h44 * h74));\n  y[l36 + 25] += ddd * (((h52 * h72) + (h53 * h73)) + (h54 * h74));\n  y[l36 + 26] += ddd * (((h62 * h72) + (h63 * h73)) + (h64 * h74));\n  y[l36 + 27] += ddd * (((h72 * h72) + (h73 * h73)) + (h74 * h74));\n  y[l36 + 28] += ddd * (((h12 * h82) + (h13 * h83)) + (h14 * h84));\n  y[l36 + 29] += ddd * (((h22 * h82) + (h23 * h83)) + (h24 * h84));\n  y[l36 + 30] += ddd * (((h32 * h82) + (h33 * h83)) + (h34 * h84));\n  y[l36 + 31] += ddd * (((h42 * h82) + (h43 * h83)) + (h44 * h84));\n  y[l36 + 32] += ddd * (((h52 * h82) + (h53 * h83)) + (h54 * h84));\n  y[l36 + 33] += ddd * (((h62 * h82) + (h63 * h83)) + (h64 * h84));\n  y[l36 + 34] += ddd * (((h72 * h82) + (h73 * h83)) + (h74 * h84));\n  y[l36 + 35] += ddd * (((h82 * h82) + (h83 * h83)) + (h84 * h84));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_livenessTest/2"}
{"code": "for (int igrid = 0; igrid < ngrid; igrid++)\n{\n  float sum = 0.0f;\n  for (int iatom = 0; iatom < natom; iatom++)\n  {\n    float dist = sqrtf((((gx[igrid] - ax[iatom]) * (gx[igrid] - ax[iatom])) + ((gy[igrid] - ay[iatom]) * (gy[igrid] - ay[iatom]))) + ((gz[igrid] - az[iatom]) * (gz[igrid] - az[iatom])));\n    sum += ((pre1 * (charge[iatom] / dist)) * expf((-xkappa) * (dist - size[iatom]))) / (1 + (xkappa * size[iatom]));\n  }\n\n  val[igrid] = sum;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mdh-omp/main/4"}
{"code": "for (base = start; base < end; base++)\n{\n  uint32_t seed = ((uint32_t) base) << 5;\n  typedef struct \n  {\n    vtype a;\n    vtype b;\n    vtype c;\n    vtype d;\n    vtype e;\n    vtype f;\n    vtype g;\n    vtype h;\n  } atype;\n  atype xM;\n  atype x = {};\n  atype x710 = {};\n  volatile atype x1;\n  const vtype cone = _mm_set1_epi32(1);\n  vtype vseed = _mm_set1_epi32(seed);\n  version_t version;\n  xM.a = _mm_add_epi32(vseed, _mm_set_epi32(0, 2, 4, 6));\n  xM.b = _mm_add_epi32(xM.a, _mm_set1_epi32(1));\n  xM.c = _mm_add_epi32(xM.a, _mm_set1_epi32(8));\n  xM.d = _mm_add_epi32(xM.a, _mm_set1_epi32(9));\n  xM.e = _mm_add_epi32(xM.a, _mm_set1_epi32(16));\n  xM.f = _mm_add_epi32(xM.a, _mm_set1_epi32(17));\n  xM.g = _mm_add_epi32(xM.a, _mm_set1_epi32(24));\n  xM.h = _mm_add_epi32(xM.a, _mm_set1_epi32(25));\n  if (flavor == PHP_LEGACY)\n  {\n    const vtype c69069 = _mm_set1_epi32(69069);\n    const vtype c69069to396 = _mm_set1_epi32(0x4396a0b1);\n    xM.a = _mm_add_epi32(_mm_add_epi32(xM.a, xM.a), cone);\n    x1.a = (xM.a = _mm_mullo_epi32(c69069, xM.a));\n    xM.a = _mm_mullo_epi32(c69069to396, xM.a);\n    xM.b = _mm_add_epi32(_mm_add_epi32(xM.b, xM.b), cone);\n    x1.b = (xM.b = _mm_mullo_epi32(c69069, xM.b));\n    xM.b = _mm_mullo_epi32(c69069to396, xM.b);\n    xM.c = _mm_add_epi32(_mm_add_epi32(xM.c, xM.c), cone);\n    x1.c = (xM.c = _mm_mullo_epi32(c69069, xM.c));\n    xM.c = _mm_mullo_epi32(c69069to396, xM.c);\n    xM.d = _mm_add_epi32(_mm_add_epi32(xM.d, xM.d), cone);\n    x1.d = (xM.d = _mm_mullo_epi32(c69069, xM.d));\n    xM.d = _mm_mullo_epi32(c69069to396, xM.d);\n    xM.e = _mm_add_epi32(_mm_add_epi32(xM.e, xM.e), cone);\n    x1.e = (xM.e = _mm_mullo_epi32(c69069, xM.e));\n    xM.e = _mm_mullo_epi32(c69069to396, xM.e);\n    xM.f = _mm_add_epi32(_mm_add_epi32(xM.f, xM.f), cone);\n    x1.f = (xM.f = _mm_mullo_epi32(c69069, xM.f));\n    xM.f = _mm_mullo_epi32(c69069to396, xM.f);\n    xM.g = _mm_add_epi32(_mm_add_epi32(xM.g, xM.g), cone);\n    x1.g = (xM.g = _mm_mullo_epi32(c69069, xM.g));\n    xM.g = _mm_mullo_epi32(c69069to396, xM.g);\n    xM.h = _mm_add_epi32(_mm_add_epi32(xM.h, xM.h), cone);\n    x1.h = (xM.h = _mm_mullo_epi32(c69069, xM.h));\n    xM.h = _mm_mullo_epi32(c69069to396, xM.h);\n  }\n  else\n  {\n    const vtype cmul = _mm_set1_epi32(1812433253U);\n    vtype vi = _mm_add_epi32(cone, cone);\n    unsigned int n = (397 - 1) / 22;\n    x1.a = (xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, seed_shr_30)), cone));\n    x1.b = (xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, seed_shr_30)), cone));\n    x1.c = (xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, seed_shr_30)), cone));\n    x1.d = (xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, seed_shr_30)), cone));\n    x1.e = (xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, seed_shr_30)), cone));\n    x1.f = (xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, seed_shr_30)), cone));\n    x1.g = (xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, seed_shr_30)), cone));\n    x1.h = (xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, seed_shr_30)), cone));\n    do\n    {\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n      xM.a = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.a, _mm_srli_epi32(xM.a, 30))), vi);\n      xM.b = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.b, _mm_srli_epi32(xM.b, 30))), vi);\n      xM.c = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.c, _mm_srli_epi32(xM.c, 30))), vi);\n      xM.d = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.d, _mm_srli_epi32(xM.d, 30))), vi);\n      xM.e = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.e, _mm_srli_epi32(xM.e, 30))), vi);\n      xM.f = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.f, _mm_srli_epi32(xM.f, 30))), vi);\n      xM.g = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.g, _mm_srli_epi32(xM.g, 30))), vi);\n      xM.h = _mm_add_epi32(_mm_mullo_epi32(cmul, _mm_xor_si128(xM.h, _mm_srli_epi32(xM.h, 30))), vi);\n      vi = _mm_add_epi32(vi, cone);\n    }\n    while (--n);\n  }\n\n  version = flavor;\n  if (!(match->flags & 4))\n  {\n    const vtype c0x7fffffff = _mm_set1_epi32(0x7fffffff);\n    const vtype c0x9908b0df = _mm_set1_epi32(0x9908b0df);\n    x.a = _mm_xor_si128(xM.a, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.a, c0x7fffffff)), 1));\n    x.b = _mm_xor_si128(xM.b, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.b, c0x7fffffff)), 1));\n    x.c = _mm_xor_si128(xM.c, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.c, c0x7fffffff)), 1));\n    x.d = _mm_xor_si128(xM.d, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.d, c0x7fffffff)), 1));\n    x.e = _mm_xor_si128(xM.e, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.e, c0x7fffffff)), 1));\n    x.f = _mm_xor_si128(xM.f, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.f, c0x7fffffff)), 1));\n    x.g = _mm_xor_si128(xM.g, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.g, c0x7fffffff)), 1));\n    x.h = _mm_xor_si128(xM.h, _mm_srli_epi32(_mm_or_si128(seed_and_0x80000000, _mm_and_si128(x1.h, c0x7fffffff)), 1));\n    x710.a = _mm_xor_si128(x.a, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.a, cone)));\n    x710.b = _mm_xor_si128(x.b, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.b, cone)));\n    x710.c = _mm_xor_si128(x.c, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.c, cone)));\n    x710.d = _mm_xor_si128(x.d, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.d, cone)));\n    x710.e = _mm_xor_si128(x.e, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.e, cone)));\n    x710.f = _mm_xor_si128(x.f, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.f, cone)));\n    x710.g = _mm_xor_si128(x.g, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.g, cone)));\n    x710.h = _mm_xor_si128(x.h, _mm_mullo_epi32(c0x9908b0df, _mm_and_si128(x1.h, cone)));\n    if (version == PHP_521)\n    {\n      x.b = _mm_xor_si128(x.b, c0x9908b0df);\n      x.d = _mm_xor_si128(x.d, c0x9908b0df);\n      x.f = _mm_xor_si128(x.f, c0x9908b0df);\n      x.h = _mm_xor_si128(x.h, c0x9908b0df);\n    }\n    else\n      x = x710;\n\n  }\n\n  do\n  {\n    uint32_t maybe = 1;\n    if (!(match->flags & 4))\n    {\n      const vtype c0x9d2c5680 = _mm_set1_epi32(0x9d2c5680);\n      const vtype c0xefc60000 = _mm_set1_epi32(0xefc60000);\n      x.a = _mm_xor_si128(x.a, _mm_srli_epi32(x.a, 11));\n      x.b = _mm_xor_si128(x.b, _mm_srli_epi32(x.b, 11));\n      x.c = _mm_xor_si128(x.c, _mm_srli_epi32(x.c, 11));\n      x.d = _mm_xor_si128(x.d, _mm_srli_epi32(x.d, 11));\n      x.e = _mm_xor_si128(x.e, _mm_srli_epi32(x.e, 11));\n      x.f = _mm_xor_si128(x.f, _mm_srli_epi32(x.f, 11));\n      x.g = _mm_xor_si128(x.g, _mm_srli_epi32(x.g, 11));\n      x.h = _mm_xor_si128(x.h, _mm_srli_epi32(x.h, 11));\n      x.a = _mm_xor_si128(x.a, _mm_and_si128(_mm_slli_epi32(x.a, 7), c0x9d2c5680));\n      x.a = _mm_xor_si128(x.a, _mm_and_si128(_mm_slli_epi32(x.a, 15), c0xefc60000));\n      x.b = _mm_xor_si128(x.b, _mm_and_si128(_mm_slli_epi32(x.b, 7), c0x9d2c5680));\n      x.b = _mm_xor_si128(x.b, _mm_and_si128(_mm_slli_epi32(x.b, 15), c0xefc60000));\n      x.c = _mm_xor_si128(x.c, _mm_and_si128(_mm_slli_epi32(x.c, 7), c0x9d2c5680));\n      x.c = _mm_xor_si128(x.c, _mm_and_si128(_mm_slli_epi32(x.c, 15), c0xefc60000));\n      x.d = _mm_xor_si128(x.d, _mm_and_si128(_mm_slli_epi32(x.d, 7), c0x9d2c5680));\n      x.d = _mm_xor_si128(x.d, _mm_and_si128(_mm_slli_epi32(x.d, 15), c0xefc60000));\n      x.e = _mm_xor_si128(x.e, _mm_and_si128(_mm_slli_epi32(x.e, 7), c0x9d2c5680));\n      x.e = _mm_xor_si128(x.e, _mm_and_si128(_mm_slli_epi32(x.e, 15), c0xefc60000));\n      x.f = _mm_xor_si128(x.f, _mm_and_si128(_mm_slli_epi32(x.f, 7), c0x9d2c5680));\n      x.f = _mm_xor_si128(x.f, _mm_and_si128(_mm_slli_epi32(x.f, 15), c0xefc60000));\n      x.g = _mm_xor_si128(x.g, _mm_and_si128(_mm_slli_epi32(x.g, 7), c0x9d2c5680));\n      x.g = _mm_xor_si128(x.g, _mm_and_si128(_mm_slli_epi32(x.g, 15), c0xefc60000));\n      x.h = _mm_xor_si128(x.h, _mm_and_si128(_mm_slli_epi32(x.h, 7), c0x9d2c5680));\n      x.h = _mm_xor_si128(x.h, _mm_and_si128(_mm_slli_epi32(x.h, 15), c0xefc60000));\n      x.a = _mm_xor_si128(x.a, _mm_srli_epi32(x.a, 18));\n      x.b = _mm_xor_si128(x.b, _mm_srli_epi32(x.b, 18));\n      x.c = _mm_xor_si128(x.c, _mm_srli_epi32(x.c, 18));\n      x.d = _mm_xor_si128(x.d, _mm_srli_epi32(x.d, 18));\n      x.e = _mm_xor_si128(x.e, _mm_srli_epi32(x.e, 18));\n      x.f = _mm_xor_si128(x.f, _mm_srli_epi32(x.f, 18));\n      x.g = _mm_xor_si128(x.g, _mm_srli_epi32(x.g, 18));\n      x.h = _mm_xor_si128(x.h, _mm_srli_epi32(x.h, 18));\n      if (match->flags & 2)\n      {\n        x.a = _mm_srli_epi32(x.a, 1);\n        x.b = _mm_srli_epi32(x.b, 1);\n        x.c = _mm_srli_epi32(x.c, 1);\n        x.d = _mm_srli_epi32(x.d, 1);\n        x.e = _mm_srli_epi32(x.e, 1);\n        x.f = _mm_srli_epi32(x.f, 1);\n        x.g = _mm_srli_epi32(x.g, 1);\n        x.h = _mm_srli_epi32(x.h, 1);\n      }\n\n    }\n\n    if (maybe)\n    {\n      unsigned int i;\n      uint32_t iseed;\n      typedef union \n      {\n        atype v;\n        uint32_t s[8][(sizeof(vtype)) / 4];\n      } utype;\n      utype u;\n      volatile utype uM;\n      u.v = x;\n      uM.v = xM;\n      for (i = 0, iseed = seed; i < 8; i++, iseed += 8)\n      {\n        if (!diff(u.s[i][0], uM.s[i][0], iseed + 6, match, version))\n          print_guess(iseed + 6, &found, version);\n\n        if (!diff(u.s[i][1], uM.s[i][1], iseed + 4, match, version))\n          print_guess(iseed + 4, &found, version);\n\n        if (!diff(u.s[i][2], uM.s[i][2], iseed + 2, match, version))\n          print_guess(iseed + 2, &found, version);\n\n        if (!diff(u.s[i][3], uM.s[i][3], iseed, match, version))\n          print_guess(iseed, &found, version);\n\n        i++;\n        if (!diff(u.s[i][0], uM.s[i][0], iseed + 7, match, version))\n          print_guess(iseed + 7, &found, version);\n\n        if (!diff(u.s[i][1], uM.s[i][1], iseed + 5, match, version))\n          print_guess(iseed + 5, &found, version);\n\n        if (!diff(u.s[i][2], uM.s[i][2], iseed + 3, match, version))\n          print_guess(iseed + 3, &found, version);\n\n        if (!diff(u.s[i][3], uM.s[i][3], iseed + 1, match, version))\n          print_guess(iseed + 1, &found, version);\n\n      }\n\n      xM = uM.v;\n    }\n\n    if (version != PHP_521)\n      break;\n\n    version = PHP_710;\n    x = x710;\n  }\n  while (1);\n}\n\n", "pragma": "omp parallel for default(none) private(base) shared(match, flavor, start, end, found, seed_and_0x80000000, seed_shr_30)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/php_mt_seed/php_mt_seed/2"}
{"code": "for (int j = 0; j < c2; ++j)\n{\n  for (int k = 0; k < c1; ++k)\n  {\n    result[i][j] += first[i][k] * second[k][j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eliah7/OpenMP-Intro/mat_mul_parallel/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((i % 2) == 0)\n  {\n    for (j = 0; j < size; j++)\n    {\n      buffer[omp_get_thread_num()][j] = vec[i] + (j * vec[i + 1]);\n    }\n\n  }\n  else\n  {\n    for (j = 0; j < size; j++)\n    {\n      sum += buffer[omp_get_thread_num()][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threadsCount) schedule(static, 2) private(i, j) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jonlenes/M_Parallel_OpenMP/2-Producer_Consumer/T2_parallel/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float prevPageRank = stats->pageRanks[v];\n  float nextPageRank = stats->base_pr + (stats->damp * Fixed16ToFloat(pageRanksNext[v]));\n  stats->pageRanks[v] = nextPageRank;\n  pageRanksNext[v] = 0;\n  double error = fabs(nextPageRank - prevPageRank);\n  error_total += error / graph->num_vertices;\n  if (error >= arguments->epsilon)\n  {\n    activeVertices++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) shared(arguments, pageRanksNext,stats) reduction(+ : error_total, activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/17"}
{"code": "for (i = 0; i < 2400; i++)\n{\n  for (j = 0; j < 2400; j++)\n  {\n    hz[(i * 2400) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / 2400;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/14"}
{"code": "for (int i = 0; i < NUM_CHARS; i++)\n{\n  c1 = FIRST_CHAR + i;\n  for (int j = 0; j <= i; j++)\n  {\n    c2 = FIRST_CHAR + j;\n    hashtable_cpu[i][j] = get_pair_sign(c1, c2);\n  }\n\n  hashtable_cpu[i][NUM_CHARS] = SPACE;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  *mean += keff[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wangsnowyin/monte-carlo/eigenvalue/4"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 6; j++)\n  rowSum[i] += A[i][j];\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture14/lastprivate/0"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  for (int i = 0; i < 1000000; i++)\n  {\n    randomnumber = rand() % 6;\n    dnabig[i] = dna[randomnumber];\n  }\n\n  replacecharacters(dnabig);\n  countA(dnabig);\n  end = clock();\n  total_time = ((double) (end - start)) / CLOCKS_PER_SEC;\n  nDynamicN[j] = total_time;\n}\n\n", "pragma": "omp for schedule(dynamic, DYNAMIC_CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  array[i] = rand() % 100;\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac2/testing/0"}
{"code": "for (int i = 0; i < freqs_shape; i++)\n  f[i] = 0.01f + ((i * (10.f - 0.01f)) / freqs_shape);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lombscargle-omp/main/3"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < (n + 1); j++)\n  a[i][j] = (b[i][j] = (rand() / ((((float) RAND_MAX) + 1) / Max_Element)) + 1);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/9"}
{"code": "for (i = 2; i <= N; ++i)\n{\n  if (nums[i] != 0)\n  {\n    curr_num = i;\n    fprintf(fp, \"%d, %d, %d\\n\", rank++, curr_num, curr_num - prev_num);\n    prev_num = curr_num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephbieselin/Primes-OpenMP/parallel/genprime/3"}
{"code": "for (int i = 8000 - 1; i >= 0; i--)\n{\n  sum = Z[i];\n  for (int j = 8000 - 1; j > i; j--)\n    sum -= X[j] * U[i][j];\n\n  X[i] = sum / U[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzunny97/LU-OpenMP/LU_decomposition/7"}
{"code": "for (j = RADIUS; j < (n - RADIUS); j++)\n  for (i = RADIUS; i < (n - RADIUS); i++)\n{\n  norm += (double) ABS(out[i + (j * n)]);\n}\n\n\n", "pragma": "omp for reduction(+:norm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Stencil/stencil/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    (cout << b[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/5"}
{"code": "for (char i = 0; i < 10; i += '\\1')\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/2"}
{"code": "for (i = 0; i < 180; i++)\n{\n  xnew_ptr[i] = xnew[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/2"}
{"code": "for (int d = 0; d < D; d++)\n{\n  dim[d] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/4"}
{"code": "for (j = 0; j < 100; j++)\n  b[i][j] = b[i][j] + 1;\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB113-default-orig-no/2"}
{"code": "for (i = 0; i < 10; i++)\n  printf(\"%f %f\\n\", qq[i], q[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB172-critical2-orig-no/3"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  b[i] += d;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/test/OpenMP/nvptx_parallel_for_codegen/0"}
{"code": "for (uint8_t *mask = segmentation_map; mask < (segmentation_map + (width * height)); ++mask)\n  if ((*mask) > 0)\n  *mask = COLOR_FOREGROUND;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/14"}
{"code": "for (int i = 0; i <= m_nSubbsns; i++)\n{\n  tmp_qsSub[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IUH_OL/IUH_OL/3"}
{"code": "for (i = 1; i < (n - 1); i += 2)\n  if (myList[i] > myList[i + 1])\n{\n  temp = myList[i];\n  myList[i] = myList[i + 1];\n  myList[i + 1] = temp;\n}\n\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmalAljabri/Parallel_Computing/odd-even_transposition_sort_invariant_of_bubble_sort/OpenMP/oddeven_sort/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum = (r[i] * r[i]) + sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/1"}
{"code": "for (int y = 0; y < height; y++)\n  for (int x = 0; x < width; x++)\n{\n  char count[16];\n  for (int i = 0; i < 16; i++)\n    count[i] = 0;\n\n  char total = 0;\n  for (int dy = -2; dy <= 2; dy++)\n  {\n    for (int dx = -2; dx <= 2; dx++)\n    {\n      int xx = x + dx;\n      int yy = y + dy;\n      if ((((xx >= 0) && (yy >= 0)) && (yy < height)) && (xx < width))\n      {\n        count[d_val[(yy * width) + xx]]++;\n        total++;\n      }\n\n    }\n\n  }\n\n  float entropy = 0;\n  if (total < 1)\n  {\n    total = 1;\n  }\n  else\n  {\n    for (int k = 0; k < 16; k++)\n    {\n      float p = ((float) count[k]) / ((float) total);\n      entropy -= p * log2f(p);\n    }\n\n  }\n\n  d_entropy[(y * width) + x] = entropy;\n}\n\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(256) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/entropy-omp/main/0"}
{"code": "for (size_t i = 0; i < numV; ++i)\n{\n  fromIndextoID[index[i]] = id[i];\n  fromIDtoIndex[id[i]] = index[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gbossi/Pagerank-DOBFS/utils/0"}
{"code": "for (int member = 1; member < (NODE_POPULATION_SIZE / CHILD_PER_GNOME); member++)\n{\n  struct individual p1 = population[member];\n  for (int child = 0; child < CHILD_PER_GNOME; child++)\n  {\n    int number_mutations = (((double) rand()) / ((double) RAND_MAX)) * (MAX_NUMBER_MUTATIONS + 1);\n    struct individual paux = p1;\n    for (int mut_i = 0; mut_i < number_mutations; mut_i++)\n    {\n      paux.gnome = mutate_gnome(paux.gnome, tsp.dimension, 0, 1);\n    }\n\n    paux.fitness = calculate_fitness(paux.gnome, tsp);\n    thread_population.push_back(paux);\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/javiervela/tsp-genalg-parallel/src/Genetic/genetic/4"}
{"code": "for (int node = 1; node < commSize; node++)\n{\n  MPI_Recv(&taskResultSize, 1, (MPI_Datatype) 0x4c000405, node, FROM_WORKER, (MPI_Comm) 0x44000000, &status);\n  taskResult = malloc(taskResultSize * (sizeof(*taskResult)));\n  MPI_Recv(taskResult, taskResultSize, MPI_MAT_ENTRY, node, FROM_WORKER, (MPI_Comm) 0x44000000, &status);\n  taskResultSizes[node - 1] = taskResultSize;\n  taskResults[node - 1] = taskResult;\n  reducedMax += taskResultSize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mvhv/mpi-openmp-matrix/mmMPI/4"}
{"code": "for (i = 0; i < nvars; i++)\n{\n  printf(\"x[%3d] = %15.7le \\n\", i, best_pt[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/its-lito/Parallel-Programming/Code/OpenMP-Tasks/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/0"}
{"code": "for (int i = 0; i < y.size(); ++i)\n{\n  mpop[y[i]] += sample_weight[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ctiely/gbdt/tree/ClassificationTree/0"}
{"code": "for (k = 0; k < 3; k++)\n  v[j][k] += (F[j][k] * delta_t) / 2;\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(v,j,delta_t) private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/N-Body-Simulator/manybody-sim-program/5"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  for (size_t j = 0; j < row; j++)\n  {\n    offspring[i].benefit += atof(content[(j * column) + 3].c_str()) * (offspring[i].binaryValue[j] - '0');\n    offspring[i].cost += (atof(content[(j * column) + 1].c_str()) * 586.0) * (offspring[i].binaryValue[j] - '0');\n  }\n\n  offspring[i].fitnessValue = offspring[i].benefit;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/11"}
{"code": "for (int i = 0; i < NBUCKETS; i++)\n{\n  omp_destroy_lock(&hist_locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olia92/OpenMP_Mattson/Hist/hist_omp/3"}
{"code": "for (int j = 0; j < num_edges; j++)\n{\n  int source = sets.find(edges[j].source);\n  int dest = sets.find(edges[j].dest);\n  if (source == dest)\n  {\n    continue;\n  }\n  else\n  {\n    if ((cheap[source] == (-1)) || (edges[cheap[source]].weight > edges[j].weight))\n    {\n      cheap[source] = j;\n    }\n\n    if ((cheap[dest] == (-1)) || (edges[cheap[dest]].weight > edges[j].weight))\n    {\n      cheap[dest] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/2"}
{"code": "for (int jj = 0; jj < (N + 2); jj++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    fill_array3d(vector_out, N, ii, jj, 0, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/matvecAv/6"}
{"code": "for (int i = 0; i < n_nodes; i++)\n{\n  for (int j = 0; j < n_nodes; j++)\n  {\n    (sol_file << solution[i][j]) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/11"}
{"code": "for (i = 0; i < numOfSeq2; i++)\n{\n  seq2Results[i] = calculateScoringMatrix(inputData->seq1, inputData->seq2Array[i], inputData->weightsArray);\n  if (seq2Results[i].n == ERROR)\n  {\n    printf(\"Error during dynamic allocating. Exiting!\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/ompFunctions/0"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  result[i] = a[i] / b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/24"}
{"code": "for (int i = 0; i < dataset.n; i++)\n{\n  free(dataset.A[i]);\n  free(dataset.L[i]);\n  free(dataset.U[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q3/3"}
{"code": "for (int ix = 0; ix < DATAXSIZE; ix++)\n{\n  for (int iy = 0; iy < DATAYSIZE; iy++)\n  {\n    for (int iz = 0; iz < DATAZSIZE; iz++)\n    {\n      if (ix == 0)\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n      else\n        if (ix == (DATAXSIZE - 1))\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n      else\n        if (iy == 0)\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n      else\n        if (iy == (DATAYSIZE - 1))\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n      else\n        if (iz == 0)\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n      else\n        if (iz == (DATAZSIZE - 1))\n      {\n        phinew[ix][iy][iz] = -1.0;\n      }\n\n\n\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-omp/main/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  cells[i] = malloc((sizeof(char)) * columns);\n  for (j = 0; j < columns; j++)\n  {\n    cells[i][j] = '-';\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Alakeil/gameoflife/gol/1"}
{"code": "for (j = 0; j < NY; j++)\n  for (i = 0; i < NX; i++)\n{\n  {\n    y[j] = y[j] + (A[(i * NY) + j] * tmp[i]);\n  }\n}\n\n\n", "pragma": "#pragma omp target teams distribute parallel for map(tofrom: j, i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_omp_out/5"}
{"code": "for (y = 1; y != IMG_H; y++)\n{\n  index = y * IMG_W;\n  for (x = 1; x != IMG_W; x++)\n  {\n    hist_R[IObj->sR[index]]++;\n    hist_G[IObj->sG[index]]++;\n    hist_B[IObj->sB[index]]++;\n    index++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/minyaho/Histogram-Equalization-by-OpenMP-and-OpenCL/code_files/code_file/4"}
{"code": "for (int k = 0; k < n; k++)\n{\n  for (int j = k + 1; j < n; j++)\n  {\n    A[k][j] = A[k][j] / A[k][k];\n  }\n\n  A[k][k] = 1;\n  if (k == 0)\n  {\n    for (int i = 0; i < thread_count; i++)\n    {\n      pthread_create(&threadID[i], NULL, dealwithbyrow, (void *) (&id[i]));\n    }\n\n  }\n  else\n    pthread_barrier_wait(&childbarrier_row);\n\n  for (int i = 0; i < thread_count; i++)\n  {\n    sem_wait(&sem_parent);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/3"}
{"code": "for (int i = 0; i < (LEN / world_size); ++i)\n{\n  for (int j = 0; j < number_of_neighbors; ++j)\n  {\n    cur_labels[j] = ((int) labels[(int) neighbors_index[i][j]]) - 1;\n  }\n\n  memset(&labels_freq, 0, number_of_neighbors * (sizeof(int)));\n  for (int j = 0; j < number_of_neighbors; ++j)\n  {\n    labels_freq[cur_labels[j] - 1]++;\n  }\n\n  cur_max = labels_freq[0];\n  label = 0;\n  for (int j = 0; j < number_of_neighbors; ++j)\n  {\n    if (labels_freq[j] > cur_max)\n    {\n      cur_max = labels_freq[j];\n      label = j + 1;\n    }\n\n  }\n\n  if (label == (((int) labels[((LEN / world_size) * world_rank) + i]) - 1))\n  {\n    ++res;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/npaschos/kNN-Search-MPI-OpenMP/main/6"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[2 * (i + (mxv * j))] = fxy[2 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (2 * (i + (mxv * j)))] = fxy[1 + (2 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nn = 2 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dx = amy * ((dxp * sfxy[nn + 2]) + dx);\n    dy = amy * ((dxp * sfxy[nn + 3]) + dy);\n    nn += 2 * mxv;\n    vx = amx * sfxy[nn];\n    vy = amx * sfxy[nn + 1];\n    dx += dyp * ((dxp * sfxy[nn + 2]) + vx);\n    dy += dyp * ((dxp * sfxy[nn + 3]) + vy);\n    dxp = ppart[(j + (2 * nppmx)) + npoff];\n    dyp = ppart[(j + (3 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    dxp += vx;\n    dyp += vy;\n    sum1 += (dxp * dxp) + (dyp * dyp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,ih,nh,x,y,dxp,dyp,amx,amy, dx,dy,vx,vy,edgelx,edgely,edgerx,edgery,sum1,sfxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/1"}
{"code": "for (i = 0; i < (*myPointsSize); i++)\n  (*myPoints)[i] = arrPoints[i];\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (i < j)\n    {\n      U[i][j] = DBL_MAX;\n      L[i][j] = 0;\n    }\n    else\n      if (i > j)\n    {\n      L[i][j] = DBL_MAX;\n      U[i][j] = 0;\n    }\n    else\n      if (i == j)\n    {\n      L[i][j] = 1;\n      U[i][j] = DBL_MAX;\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/doolittleMethod/0"}
{"code": "for (i = 0; i < 1048576; i++)\n{\n  fprintf(stdout, \"Thread [%02d]: h_c[%07d]: %f\\n\", omp_get_thread_num(), i, h_c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-omp-parallel-for-combined-schedule-dynamic-chunk-value/2"}
{"code": "for (int from = 0; from < vertices; from++)\n{\n  for (int to = 0; to < vertices; to++)\n  {\n    if (((from != to) && (from != via)) && (to != via))\n    {\n      dist[from][to] = min(dist[from][to], dist[from][via] + dist[via][to]);\n    }\n\n  }\n\n}\n\n", "pragma": "  \t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahzebp/floyd_warshall_parallel/openmp/iterative1/0"}
{"code": "for (int i = 0; i < bin_count; i++)\n{\n  int bin = 0;\n  for (int j = 0; j < num_count; j++)\n  {\n    int bin_index = (int) ((nums[j] * bin_count) / 100.0);\n    if (bin_index == i)\n    {\n      bin++;\n    }\n\n  }\n\n  bin_counter[i] = bin;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) shared(bin_counter)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dizys/nyu-multicore-lab-1/zz2960ver1/0"}
{"code": "for (int i = 0; i < size.h; ++i)\n{\n  field[idx_at(0, i)] = 0;\n  field[idx_at(size.w - 1, i)] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tsb99x/cello/src/grid/1"}
{"code": "for (k = 0; k < n_col; k++)\n{\n  int swap;\n  int cCol;\n  cCol = cur_pos;\n  swap = *((A + (k * n_row)) + col_pos);\n  *((A + (k * n_row)) + col_pos) = *((A + (k * n_row)) + cCol);\n  *((A + (k * n_row)) + cCol) = swap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ddsihongliang/ece_5720/hw2/hs983_hw2_openmp_sort_block/2"}
{"code": "for (c1 = 0; c1 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c1++)\n{\n  for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n  {\n    for (c3 = 16 * c1; c3 <= ((((16 * c1) + 15) < (n + (-1))) ? ((16 * c1) + 15) : (n + (-1))); c3++)\n    {\n      for (c4 = 16 * c2; c4 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c4++)\n      {\n        X[c3][c4] = ((((double) c3) * (c4 + 1)) + 1) / n;\n        A[c3][c4] = ((((double) c3) * (c4 + 2)) + 2) / n;\n        B[c3][c4] = ((((double) c3) * (c4 + 3)) + 3) / n;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c4, c2, c3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-tile-no/0"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  if (cast_cf->vec_[i] == 0)\n  {\n    undecided = true;\n    i = this->nrow_;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 1024)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/108"}
{"code": "for (y = 0; y < L; y++)\n{\n  for (x = 0; x < L; x++)\n  {\n    phi[x + (y * L)] = tmp[x + (y * L)];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/mg/1"}
{"code": "for (i = 0; i < 12; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"Loop 4: (%d) gets iteration %d\\n\", id, i);\n}\n\n", "pragma": "omp for schedule(guided,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/2.schedule/3"}
{"code": "for (int i = 0; i < nzv; i++)\n{\n  fscanf(f, \"%d %d\\n\", &J[i], &I[i]);\n  I[i]--;\n  J[i]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ypatiapd/Parallel-and-distributed-systems/project1/sparse_openMP/1"}
{"code": "for (int i = 1; i < n; ++i)\n{\n  (cout << arr[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Husain0007/Parallel-Programming-with-OpenMP/PrefixSum/psum/3"}
{"code": "for (i = 0; i < 10; i)\n  ;\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr59073/0"}
{"code": "for (c = 0; c < size; c++)\n{\n  for (d = 0; d < size; d++)\n  {\n    for (k = 0; k < size; k++)\n    {\n      sum = sum + ((*((first + (c * size)) + k)) * (*((second + (k * size)) + d)));\n    }\n\n    *((multiply + (size * c)) + d) = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MeghanaVankadari/Gemm_parallel/gemm_omp/1"}
{"code": "for (i = 0; i < nodes; i++)\n{\n  if (num_out_links[i] == 0)\n  {\n    dangling_idx[temp_counter] = i;\n    temp_counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/read_graph_from_file/2"}
{"code": "for (int g = 0; g < I->n_egroups; g++)\n{\n  float q = FSR->fine_source[fine_id][g] / sigT[g];\n  float delta_psi = (psi[g] - q) * expVal[g];\n  tally[g] = weight * delta_psi;\n  psi[g] -= delta_psi;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/21"}
{"code": "for (i = 0; i < z; i++)\n  W_sum += x_old[dangling_idx[i]];\n\n", "pragma": "omp for reduction(+:W_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/Ferdig/PE_functions_15243/2"}
{"code": "for (int i = 0; i < this->fields.size(); ++i)\n{\n  int x = i % this->width;\n  int y = floor(((double) i) / ((double) this->height));\n  int sum = 0;\n  for (int row = -horizon; row <= horizon; row++)\n    for (int col = -horizon; col <= horizon; col++)\n  {\n    if ((row == 0) && (col == 0))\n    {\n      continue;\n    }\n\n    int neiX = x + row;\n    int neiY = y + col;\n    if (neiX < 0)\n      neiX = width - 1;\n    else\n      if (neiX >= width)\n      neiX = 0;\n\n\n    if (neiY < 0)\n      neiY = height - 1;\n    else\n      if (neiY >= height)\n      neiY = 0;\n\n\n    if (fields[(neiX * width) + neiY].prev)\n      sum++;\n\n  }\n\n\n  if (!fields[i].actual)\n  {\n    omp_set_lock(&fields[i].lock);\n    Classic(i, sum);\n    omp_unset_lock(&fields[i].lock);\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/2/gameOfLife/GameOfLife/0"}
{"code": "for (unsigned int i = 0; i < m_particles.size(); i++)\n  if (bw < m_particles[i].weightSum)\n{\n  bw = m_particles[i].weightSum;\n  bi = i;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/gmapping/gridfastslam/gridslamprocessor/8"}
{"code": "for (int i = 0; i < length_A; i++)\n  distances[i] = one_to_many_distances(points_A[i], points_B, length_B, dims, dist_func);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/distance/6"}
{"code": "for (i = 0; i < 8; ++i)\n{\n  while (1)\n  {\n    j = rand() % 64;\n    if (checkFlag(flag, j))\n    {\n      mean[i] = point[j];\n      center[i] = j;\n      flag[i] = j;\n      break;\n    }\n\n  }\n\n  for (int e = 0; e < 4; ++e)\n  {\n    mean[i].elements[e] = point[j].elements[e];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/14"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    C[(i * 128) + j] = 0.0;\n    for (k = 0; k < 128; ++k)\n    {\n      C[(i * 128) + j] += A[(i * 128) + k] * B[(k * 128) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/24"}
{"code": "for (i = 0; i < NumPart; i++)\n  if (P[i].Ti_endstep == All.Ti_Current)\n{\n  ax = P[i].GravAccel[0];\n  ay = P[i].GravAccel[1];\n  az = P[i].GravAccel[2];\n  P[i].OldAcc = sqrt(((ax * ax) + (ay * ay)) + (az * az));\n  force_add_ryan(i);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/gravtree/6"}
{"code": "for (int i = 0; i < untill; i++)\n{\n  int work_for = (level * (i + 1)) - 1;\n  int get = work_for - (level / 2);\n  int temp = prefix[work_for][0];\n  prefix[work_for][0] += prefix[get][0];\n  prefix[get][0] = temp;\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/prefix_sum_2/2"}
{"code": "for (i = 0; i < strlen(to_remove); i++)\n{\n  if (full_string[i] == to_remove[i])\n  {\n  }\n  else\n  {\n    printf(\"Second string isn't a substring of the first one\\nTerminate execution\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/8"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n  topo.stenc[i].resize(64, -1);\n\n", "pragma": "#pragma omp for schedule(static,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/mesh/4"}
{"code": "for (int i = 0; i < K; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    C[i][j] = 0;\n    for (int k = 0; k < L; k++)\n    {\n      x = A[i][k] * B[k][j];\n      C[i][j] += x;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_num) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shikhashah2627/Python_Performance/OMP_Matrix_Multiplication/0"}
{"code": "for (i3 = 0; i3 < m3; i3++)\n{\n  for (i1 = 0; i1 < m1; i1++)\n  {\n    for (i2 = 0; i2 < m2; i2++)\n    {\n      printf(\"%6.3f\", oz[(((i3 * n2) * n1) + (i2 * n1)) + i2]);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"  - - - - - - - \\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/29"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  sum += ((int) ((stats->vector_output[v] * 100) + .5)) / 100.0;\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/3"}
{"code": "for (int tid = 0; tid < nthreads; tid++)\n{\n  for (int u = csrSplitter[tid]; u < csrSplitter[tid + 1]; u++)\n  {\n    float sum = 0;\n    int res = _mm512_setzero_ps();\n    int dif = RowPtr[u + 1] - RowPtr[u];\n    int nloop = dif / 16;\n    int remainder = dif % 16;\n    for (int li = 0; li < nloop; li++)\n    {\n      int j = RowPtr[u] + (li * 16);\n      int vecv = _mm512_loadu_ps(&Val[j]);\n      int veci = _mm512_loadu_si512(&ColIdx[j]);\n      int vecx = _mm512_i32gather_ps(veci, X, 4);\n      res = _mm512_fmadd_ps(vecv, vecx, res);\n    }\n\n    sum += _mm512_reduce_add_ps(res);\n    for (int j = RowPtr[u] + (nloop * 16); j < RowPtr[u + 1]; j++)\n    {\n      sum += Val[j] * X[ColIdx[j]];\n    }\n\n    Y[u] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiaosongAI/Parallel-SpMV/spmv_avx512/0"}
{"code": "for (i = 0; i < get_num_pixel(); i++)\n{\n  new_bmp_img[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/naveentrtumkur/Sobel-Operator-using-MPI-and-OpenMP/mpi_program5/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_for_nowait())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_nowait/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  d[i] = 1.0 / c[i];\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adityakaria/5-Sem/pc/lab2/q1/no-wait/1"}
{"code": "for (i = 0; i < SLICE_SIZE; i++)\n{\n  if (points[i + (nslice * SLICE_SIZE)].ID != dataSlice[i].ID)\n  {\n    *unConverged = 1;\n  }\n\n  points[i + (nslice * SLICE_SIZE)].ID = dataSlice[i].ID;\n  points[i + (nslice * SLICE_SIZE)].dist = dataSlice[i].dist;\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mkdan91/ParallelKmeans/Kmeans/Main/6"}
{"code": "for (i = 0; i < N; i += N / 8)\n{\n  for (j = 0; j < N; j += N / 8)\n  {\n    printf(\"%.2f \", h[0][i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/parallelx/5"}
{"code": "for (int kk = 0; (kk < FlowNode2D) < FP, NumEq; kk++)\n{\n  RMS[kk] = 0.;\n  iRMS[kk] = 0;\n  sumDiv[kk] = 0.;\n  DD_max[rank].DD[kk].RMS = 0.;\n  DD_max[rank].DD[kk].iRMS = 0;\n  DD_max[rank].DD[kk].sumDiv = 0;\n  DD_max[rank].DD[kk].DD = 0.;\n  DD_max[rank].DD[kk].i = 0;\n  DD_max[rank].DD[kk].j = 0;\n  DD_local[kk] = 0.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/2"}
{"code": "for (int i = 0; i < time_size; i++)\n{\n  (((output_pr << t_means[i]) << \"\\t\") << pr_means[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JacobHilbert/simple-gillespie/gillespie/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  invariant_amount_of_work(3);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_scheduling/1"}
{"code": "for (unsigned int r = 0; r < (geom->n_grid_r - 1); r++)\n  for (unsigned int z = 0; z < (geom->n_grid_z - 1); z++)\n{\n  double p_sum_2 = ((t_vec_r[r][z] * t_vec_r[r][z]) + (t_vec_phi[r][z] * t_vec_phi[r][z])) + (t_vec_z[r][z] * t_vec_z[r][z]);\n  if (p_sum_2 < (((REL_LIMIT * REL_LIMIT) * prtls->mass) * prtls->mass))\n    t_src[r][z] = ((t_sum[r][z] * t_sum[r][z]) - p_sum_2) / (((2 * prtls->mass) * count_sum[r][z]) * count_sum[r][z]);\n  else\n  {\n    double mc_2 = prtls->mass * LIGHT_SPEED_POW_2;\n    t_src[r][z] = sq_rt(((((t_sum[r][z] * t_sum[r][z]) - p_sum_2) * LIGHT_SPEED_POW_2) / (count_sum[r][z] * count_sum[r][z])) + (mc_2 * mc_2)) - mc_2;\n  }\n\n  t_src[r][z] /= abs(prtls->charge);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/temperature/2"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  sum += A[i] * B[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nghialuffy/OpenMP-Exercises/Bai6/Bai6/0"}
{"code": "for (j = 0; j < nca; j++)\n{\n  for (k = 0; k < ncb; k++)\n  {\n    b[j][k] = (double) (i * j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonyz0x0/parallel-computing/omp_saxp/2"}
{"code": "for (int i = 0; i < n; i++)\n  y[i] += a * x[i];\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(THREADS_PER_BLOCK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lanczos-omp/lanczos/1"}
{"code": "for (int j = 0; j < 3; ++j)\n{\n  sleep(1);\n  printf(\"wake %d, %d\\n\", j, 5 + omp_get_thread_num());\n}\n\n", "pragma": "         #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPToolsInterface/ompt-test-suite/examples/parallelsections/2"}
{"code": "for (; (i + 15) < n; i += 16)\n{\n  xv[0] = _mm256_load_ps(&x[i + 0]);\n  xv[1] = _mm256_load_ps(&x[i + 8]);\n  _mm256_store_ps(&y[i + 0], xv[0]);\n  _mm256_store_ps(&y[i + 8], xv[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/12"}
{"code": "for (int i = 0; i < num_hidden; i++)\n{\n  double sum = 0.0;\n  for (int j = 0; j < num_outputs; j++)\n  {\n    sum += output_weight_deltas[j] * output_weights[j][i];\n  }\n\n  hidden_weight_deltas[i] = (sum * hv[i]) * (1.0 - hv[i]);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ghulette/neural-net-openmp/neuralnet/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int ki = 0; ki < k; ki++)\n  {\n    if (ki == 0)\n      lowerDist = m;\n\n    getRow(centroids, ki, supCentroid, m);\n    getRow(dataset, i, supDataset, m);\n    dist = eucliDist(supCentroid, supDataset, m);\n    if (dist <= lowerDist)\n    {\n      lowerDist = dist;\n      salvaK = ki;\n    }\n\n    if (ki == (k - 1))\n      clusters[i][salvaK] = 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(lowerDist, dist, salvaK, supCentroid, supDataset)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/2"}
{"code": "for (int ii = 0; ii < N; ii++)\n{\n  suma += array[ii];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:suma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cdpadillae/OpenMP-Workshop/openmp_parallel_for/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    D_T[(j * N) + i] = D[(i * P) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) collapse(2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/3"}
{"code": "for (int j = 0; j < upper_bound; j++)\n{\n  *((scanned->tab + j) + 1) = (*(((A + padded_size) - 1) + j)) + (*(((B + padded_size) - 1) + j));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/2"}
{"code": "for (i = 0; i < 64; i++)\n{\n  {\n    ;\n  }\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/nesting-2/0"}
{"code": "for (i = 0; i < n_threads; i++)\n{\n  for (j = 0; j < n_clusters; j++)\n    local_newClusters[i][j] = (float *) calloc(n_coords, sizeof(float));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreP-git/Kmeans-OpenMP/kmeans/9"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  x[i] = x0 + (i * dx);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svretina/OpenMP-projects/wave/0"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  D.zeros();\n  assignew = Assign(data_proc, D, P, n, cov_num, strt_num, level_num, omega, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Up;\n  TU = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (Up - diff_data);\n  mupdate = ((Up - diff_data) > (2 * (Um - diff_data))) || ((Up - diff_data) < ((Um - diff_data) * 0.5));\n  Up = (TU > (diff_data - ((Up * n1c) / n))) ? (Up - ((c * alpha) / m)) : (Up + ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Um = (mupdate) ? (Up) : (Um);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/14"}
{"code": "for (i = 0; i < cutoutsize; i++)\n{\n  equal = 0;\n  for (j = 0; j < listsize; j++)\n  {\n    if (cutout[i] == filterlist[j])\n    {\n      equal = 1;\n      break;\n    }\n\n  }\n\n  if ((!equal) || (cutout[i] > filterlist[j]))\n    cutout[i] = 0;\n\n}\n\n", "pragma": "omp for private(i,j,equal) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/neurodata/ndlib/c_version/filterCutoutOMP/0"}
{"code": "for (int k = 0; k < col1; k++)\n{\n  temp += m1[i][k] * m2[k][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muyuuuu/High-performance-computing/\u7b2c\u4e09\u6b21\u4f5c\u4e1a(\u77e9\u9635\u5e76\u884c\u4e58\u6cd5)/matrix/1"}
{"code": "for (int imf = 0; imf < mode; ++imf)\n{\n  if (EMD_success[imf])\n  {\n    fprintf(fp, \"IMF%d,\", imf + 1);\n    fprintf(fp, \"Residual%d,\", imf + 1);\n    fprintf(fp, \"Up%d,\", imf + 1);\n    fprintf(fp, \"Low%d,\", imf + 1);\n    fprintf(fp, \"Mean%d,\", imf + 1);\n  }\n\n  if (NDQ_success[imf])\n  {\n    fprintf(fp, \"FM%d,\", imf + 1);\n    fprintf(fp, \"AM%d,\", imf + 1);\n    fprintf(fp, \"IP%d,\", imf + 1);\n    fprintf(fp, \"IF%d,\", imf + 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/44"}
{"code": "for (i = 0; i < 9; i++)\n{\n  if (arr[i] > max_)\n    max_ = arr[i];\n\n  if (arr[i] < min_)\n    min_ = arr[i];\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Arrays/array_min_max/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  if (percentDiff(A[i], A_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/vector-product/src/vector-product_gpu/2"}
{"code": "for (i = 0; i <= (_PB_LENGTH - 1); i++)\n  for (j = 0; j <= (_PB_LENGTH - 1); j++)\n  c[i][j] = 0;\n\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/solvers/dynprog/dynprog/0"}
{"code": "for (i = 0; i < prof; i++)\n{\n  double temp = x;\n  double x2 = x * x;\n  double y2 = y * y;\n  x = (x2 - y2) + a;\n  y = ((2 * temp) * y) + b;\n  if ((x2 + y2) > 4.0)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/mandel_openmp/1"}
{"code": "for (int i = 0; i < len; i++)\n{\n  for (int j = 0; j < len; j++)\n  {\n    float t = 0;\n    for (int k = 0; k < len; k++)\n      t += a[k + (j * len)] * b[i + (k * len)];\n\n    x[i + (j * len)] = t;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/matmul/2"}
{"code": "for (i = 0; i < k; i++)\n{\n  a[i] = ((float) rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/vector_add/1"}
{"code": "for (i = 0; i < block; i++)\n{\n  for (j = 0; j < N_prime; j++)\n  {\n    result[(i * N_prime) + j] = 0;\n    for (k = 0; k < L; k++)\n    {\n      result[(i * N_prime) + j] += BOLD[(L * i) + k] * BOLD_transpose[(k * N_prime) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/2"}
{"code": "for (uint b = 0; b < count; ++b)\n{\n  if (bondExist[b])\n  {\n    energy += forcefield.bonds.Calc(molKind.bondList.kinds[b], vecs.Get(b).Length());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/7"}
{"code": "for (j = 4; j <= 10000; j += 2)\n{\n  for (i = 3; i <= (j / 2); i++)\n  {\n    r1 = isprime(i);\n    r2 = isprime(j - i);\n    if ((r1 == 1) && (r2 == 1))\n    {\n      isgold[i][j / 2] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhiy91/Goldbach_conjecture/goldbach_omp/0"}
{"code": "for (cj = 0; cj < NCELLS; cj++)\n{\n  if (cj != ci)\n    nc += contacts(ci, cj);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/34"}
{"code": "for (i = 0; i < size; i++)\n{\n  printf(\"%lf\\n\", r[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/obernardocosta/High-Performance-Computing-HPC/OPEN_MP/2/linalg_par/3"}
{"code": "for (i = 0; i < townsNo; i++)\n{\n  if (child1->townsOrder[i] == (-1))\n  {\n    for (int j = 0; j < townsNo; j++)\n    {\n      if (!isInIntArray(child1->townsOrder, townsNo, parent->townsOrder[j]))\n      {\n        child1->townsOrder[i] = parent->townsOrder[j];\n        break;\n      }\n\n    }\n\n  }\n\n  if (child2->townsOrder[i] == (-1))\n  {\n    for (int j = 0; j < townsNo; j++)\n    {\n      if (!isInIntArray(child2->townsOrder, townsNo, townsOrder[j]))\n      {\n        child2->townsOrder[i] = townsOrder[j];\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/7"}
{"code": "for (int i = 0; i < VECTOR_SIZE; i++)\n  c_serial[i] = a[i] + b[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture5/VectorSum_Loop_construct/VectorSum_Loop_construct/1"}
{"code": "for (int y = 0; y < height; y++)\n{\n  int row = row_pointers[y];\n  for (int x = 0; x < width; x++)\n  {\n    int px = &row[x * 4];\n    px[0] = 255 - px[0];\n    px[1] = 255 - px[1];\n    px[2] = 255 - px[2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/negationImageParallel/1"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  int source = i;\n  MPI_Recv(&buffer[offset], chunksize * i_y_max, (MPI_Datatype) 0x4c000101, source, 1, 1, &status);\n  offset += chunksize * i_y_max;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP2/MPI+OMP/mandelbrot_openmpi+omp/2"}
{"code": "for (int node = 0; node < nnodes; node++)\n{\n  multi_spline[node] = create_multi_UBspline_3d_d(x_grid, y_grid, z_grid, xBC, yBC, zBC, num_splines);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_omp/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = 0;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], 0, hydro_data->r0[i], hydro_data->r1[i], position_phi);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      position3_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r2_size[i]) - (0.5 * hydro_data->r2_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, hydro_data->r2[i] + position3_rand);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/21"}
{"code": "for (c1 = (((ni > nj) ? (ni) : (nj)) > nm) ? ((ni > nj) ? (ni) : (nj)) : (nm); c1 <= (nk + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/82"}
{"code": "for (polynomialItertor = 0; polynomialItertor <= polynomialDegree; polynomialItertor++)\n{\n  tmpCalc = coefficients[polynomialItertor] * pow(x, polynomialItertor);\n  functionResult += tmpCalc;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zdzwie/PiASK_Project/integral_omp/1"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n  matrix[(i * size) + j] = (rand() % (10 - 1)) * 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muriloboratto/hands-on-supercomputing-with-parallel-computing/Hands-On-5-Basic-Hybrid-Application-MPI+OpenMP/material/mm-openmp/1"}
{"code": "for (i = 0; i < n2; i++)\n{\n  arg = aw * ((double) i);\n  w[(i * 2) + 0] = cos(arg);\n  w[(i * 2) + 1] = sin(arg);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/2"}
{"code": "for (i = 1; i < (my_grid->dimension - 1); i++)\n{\n  for (j = 1; j < (my_grid->dimension - 1); j++)\n  {\n    temp = my_grid->element[(i * my_grid->dimension) + j];\n    my_grid->element[(i * my_grid->dimension) + j] = 0.20 * ((((my_grid->element[(i * my_grid->dimension) + j] + my_grid->element[((i - 1) * my_grid->dimension) + j]) + my_grid->element[((i + 1) * my_grid->dimension) + j]) + my_grid->element[(i * my_grid->dimension) + (j + 1)]) + my_grid->element[(i * my_grid->dimension) + (j - 1)]);\n    diff = diff + fabs(my_grid->element[(i * my_grid->dimension) + j] - temp);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/solver/solver/0"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/8"}
{"code": "for (i = 1; i < NUM_KEYS; i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "omp parallel for reduction(+ : j)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/1"}
{"code": "for (unsigned int i = 0; i < numNodes; ++i)\n{\n  unsigned int iXWidth = i * numNodes;\n  pathDistanceMatrix[iXWidth + i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/floydwarshall-omp/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  mat[i] = (int *) malloc((sizeof(int)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q1/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"%d \\n\", i);\n  sleep(n);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/castelojb/MPI-OpenMP-QuickStart/class_one/main/2"}
{"code": "for (i = 0; i < 32; i++)\n{\n  v1 -= (((v0 << 4) + k2) ^ (v0 + sum)) ^ ((v0 >> 5) + k3);\n  v0 -= (((v1 << 4) + k0) ^ (v1 + sum)) ^ ((v1 >> 5) + k1);\n  sum -= delta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BriefsZero/Event-Detection-in-a-fully-distrubuted-wireless-sensor-network/encr_tea_omp/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i][j][k + 1] = lhs[0][i][j][k + 1] + comz1;\n    lhs[1][i][j][k + 1] = lhs[1][i][j][k + 1] - comz4;\n    lhs[2][i][j][k + 1] = lhs[2][i][j][k + 1] + comz5;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/19"}
{"code": "for (int i = 0; i < l; i++)\n  fprintf(stderr, \"%d \", tab[i]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_mpi-omp-simd/pathracer_mpi-omp-simd/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"[\");\n  for (j = 0; j < N; j++)\n  {\n    printf(\" %5.2f,\", A[i][j]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/GuassianElimination_Parallell/4"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    putc(rgb[i][j].rgbRed, oFile);\n    putc(rgb[i][j].rgbGreen, oFile);\n    putc(rgb[i][j].rgbBlue, oFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/2/2"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  const double *residual = &data0[5 * n_op];\n  double *rms = &arg1_l;\n  for (int i = 0; i < NVAR; i++)\n  {\n    *rms += residual[i] * residual[i];\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1) reduction(+:arg1_l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/calc_rms_kernel_omp4kernel_func/0"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets1581Ptr = _checkInCodelets1581(1, 1, this, codeletCounter);\n  (*checkInCodelets1581Ptr).decDep();\n  checkInCodelets1581Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/85"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  if (ich[iel] == 4)\n  {\n    for (i = 0; i < NSIDES; i++)\n    {\n      jface = jjface[i];\n      ntemp = sje[iel][i][0][0];\n      if (cbc[iel][i] == 1)\n      {\n        ich[iel] = 0;\n        if (ich[ntemp] != 4)\n        {\n          if (!(*ifrepeat))\n            *ifrepeat = 1;\n\n          ich[ntemp] = 4;\n        }\n\n        for (iface = 0; iface < NSIDES; iface++)\n        {\n          if ((iface != i) && (iface != jface))\n          {\n            if (cbc[ntemp][iface] == 2)\n            {\n              nntemp = sje[ntemp][iface][0][0];\n              if ((ich[nntemp] != 4) && ifcor(iel, nntemp, i, iface))\n              {\n                ich[nntemp] = 4;\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n      else\n        if (cbc[iel][i] == 2)\n      {\n        for (iface = 0; iface < NSIDES; iface++)\n        {\n          if ((iface != i) && (iface != jface))\n          {\n            if (cbc[ntemp][iface] == 1)\n            {\n              nntemp = sje[ntemp][iface][0][0];\n              ich[nntemp] = 4;\n              ich[iel] = 0;\n              if (!(*ifrepeat))\n                *ifrepeat = 1;\n\n            }\n\n          }\n\n        }\n\n      }\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(iel,i,jface,ntemp, iface,nntemp) shared(ifrepeat)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/13"}
{"code": "for (i = 0; i < (384 - 2); ++i)\n  for (j = 0; j < (512 - 2); ++j)\n  *((*(greenmeanfilteredmatrix + i)) + j) = ((((((((0.111111 * (*((*(greenmatrix + i)) + j))) + (0.111111 * (*(((*(greenmatrix + i)) + j) + 1)))) + (0.111111 * (*(((*(greenmatrix + i)) + j) + 2)))) + (0.111111 * (*((*((greenmatrix + i) + 1)) + j)))) + (0.111111 * (*(((*((greenmatrix + i) + 1)) + j) + 1)))) + (0.111111 * (*(((*((greenmatrix + i) + 1)) + j) + 2)))) + (0.111111 * (*((*((greenmatrix + i) + 2)) + j)))) + (0.111111 * (*(((*((greenmatrix + i) + 2)) + j) + 1)))) + (0.111111 * (*(((*((greenmatrix + i) + 2)) + j) + 2)));\n\n\n", "pragma": "omp parallel for default(none) shared(greenmeanfilteredmatrix, greenmatrix) private(i, j) num_threads(NUM_THREADS[num_threads_index]) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-3/codes/with-sections/meanfilter3x3/1"}
{"code": "for (int j = 0; j < 2048; ++j)\n{\n  for (int m = 256 - 4; m >= 0; m -= 4)\n  {\n    float32x4_t t1;\n    float32x4_t t2;\n    t1 = vld1q_f32(point[j].elements + m);\n    t2 = vld1q_f32(mean[center[j]].elements + m);\n    t2 = vsubq_f32(t1, t2);\n    res = vaddq_f32(res, vmulq_f32(t2, t2));\n  }\n\n  for (int m = (256 % 4) - 1; m >= 0; --m)\n  {\n    global_sum += (point[j].elements[m] - mean[center[j]].elements[m]) * (point[j].elements[m] - mean[center[j]].elements[m]);\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, 1),reduction(+:global_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+neon+kmeans/1"}
{"code": "for (int a = 0; a < n; a++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    int adder = 0;\n    for (int j = 0; j < n; j++)\n    {\n      adder += matrix_A[i][j] * matrix_B[j][a];\n    }\n\n    matrix_Out[i][a] = adder;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Documents/TrabajoDeCursada/Matrix Multiplication/mm/0"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n{\n  X[i][j] = rand();\n  Y[i][j] = rand();\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aniruddha-Kulkarni/OpenMP---Matrix-Multiplication/MatrixMultiplication/1"}
{"code": "for (int i = 0; i < images_nr; ++i)\n{\n  free(encoded_images[i]);\n  free((*images)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/10"}
{"code": "for (int hn = 0; hn < previousLayer->numberOfNodes; ++hn)\n{\n  Node *previousLayerNode = &previousLayer->nodes[hn];\n  node->weights[hn] += (LEARNING_RATE * previousLayerNode->output) * backPropValue;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/4"}
{"code": "for (t = 0; t < mxiter; t++)\n{\n  fprintf(stdout, \"Step %d of %d\\n\", t, mxiter);\n  for (i = 0; i < (2 * pp->np); i++)\n    forces[i] = 0.0;\n\n  time_t t_comuteForce_0;\n  time_t t_comuteForce_1;\n  time(&t_comuteForce_0);\n  for (i = 0; i < pp->np; i++)\n  {\n    newparticle(&p1, pp->weight[i], pp->x[i], pp->y[i], pp->vx[i], pp->vy[i]);\n    for (j = 0; j < pp->np; j++)\n    {\n      if (j != i)\n      {\n        newparticle(&p2, pp->weight[j], pp->x[j], pp->y[j], pp->vx[j], pp->vy[j]);\n        ForceCompt(f, p1, p2);\n        ftem0 += f[0];\n        ftem1 += f[1];\n      }\n\n    }\n\n    forces[0 + (i * 2)] = ftem0;\n    forces[1 + (i * 2)] = ftem1;\n  }\n\n  time(&t_comuteForce_1);\n  fprintf(stdout, \"time spent on ForceCompt(): %lf\\n seconds\", difftime(t_comuteForce_1, t_comuteForce_0));\n  ParticleScreen(pgrid, *pp, t);\n  DumpPopulation(*pp, t);\n  ParticleStats(*pp, t);\n  time_t t_ComptPopulation_0;\n  time_t t_ComptPopulation_1;\n  time(&t_ComptPopulation_0);\n  ComptPopulation(pp, forces);\n  time(&t_ComptPopulation_1);\n  fprintf(stdout, \"time spent on ComptPopulation(): %lf\\n seconds\", difftime(t_ComptPopulation_1, t_ComptPopulation_0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/singleProc-print-time-use-ftemp/0"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  double wtotal;\n  wtotal = respvar[i];\n  if (min > wtotal)\n    min = wtotal;\n\n  if (max < wtotal)\n    max = wtotal;\n\n  total += wtotal;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp-benchmarks/src/benchmark/benchmark/2"}
{"code": "for (i = 0; i < 32768; i++)\n{\n  x[i] = i * M_PI;\n  for (j = 0; j < 32768; j++)\n  {\n    A[(i * 32768) + j] = (((DATA_TYPE) i) * j) / 32768;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/13"}
{"code": "forbidden.resize((size_t) max.part, max())\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/partition/1"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    colidx[k] -= firstcol;\n  }\n\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nctu-homeworks/PP-hw2/cg/0"}
{"code": "for (i = 0; i < v.degree; i++)\n{\n  int nb_id = v.neighbor[i];\n  vertex_t nb_v = g->vertex[nb_id];\n  if (nb_v.is_colored)\n  {\n    nb_color_list[count] = nb_v.color;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michaelwjk/Parallel-graph-coloring/parallel/parallel/2"}
{"code": "for (i = first; i <= last; ++i)\n{\n  if (i % 2)\n  {\n    printf(\"test() iteration %d\\n\", i);\n  }\n\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/ordered/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoyMitra/android-parallel-benchmarks/openmp/max-array/app/src/main/cpp/findmax/1"}
{"code": "for (i = 1; i < (1024 + 1); i++)\n{\n  for (j = 1; j < (1024 + 1); j++)\n  {\n    data[(i * (1024 + 1)) + j] -= mean[j];\n    data[(i * (1024 + 1)) + j] /= sqrt(3214212.01f) * stddev[j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/CORR/src/correlation/3"}
{"code": "for (int i = 0; i < howmany; ++i)\n{\n  int ii_start = lowerb(i, howmany, sizex);\n  int ii_end = upperb(i, howmany, sizex);\n  for (int j = 0; j < nBlocs; j++)\n  {\n    int jj_start = lowerb(j, nBlocs, sizey);\n    int jj_end = upperb(j, nBlocs, sizey);\n    if (i > 0)\n    {\n      while (processedBlocks[i - 1] <= j)\n      {\n      }\n\n    }\n\n    for (int ii = max(1, ii_start); ii <= min(sizex - 2, ii_end); ii++)\n    {\n      for (int jj = max(1, jj_start); jj <= min(sizey - 2, jj_end); jj++)\n      {\n        unew = 0.25 * (((u[(ii * sizey) + (jj - 1)] + u[(ii * sizey) + (jj + 1)]) + u[((ii - 1) * sizey) + jj]) + u[((ii + 1) * sizey) + jj]);\n        diff = unew - u[(ii * sizey) + jj];\n        sum += diff * diff;\n        u[(ii * sizey) + jj] = unew;\n      }\n\n    }\n\n    ++processedBlocks[i];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(diff,unew) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab5/solver-omp-for_gauss/2"}
{"code": "for (i = 0; i < N; i++)\n  if (a[i] != b[i])\n{\n  rc++;\n  printf(\"Wrong varlue: a[%d]=%d\\n\", i, a[i]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/requires_directive/requires_directive/0"}
{"code": "for (int irch = 0; irch <= m_nReaches; irch++)\n{\n  m_chDaylen[irch] += tmp_chDaylen[irch];\n  m_chSr[irch] += tmp_chSr[irch];\n  m_chTemp[irch] += tmp_chTemp[irch];\n  m_chCellCount[irch] += tmp_chCellCount[irch];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrCH_QUAL2E/NutrCH_QUAL2E/1"}
{"code": "for (uint64_t i = 0; i < nsmall; i += 2)\n{\n  uint64_t h = smallsegs[i + 1];\n  uint64_t l = smallsegs[i + 0];\n  if (((h - l) + 1) <= insertionSize)\n    insertionSort(vec, l, h);\n  else\n    basicquicksort(vec, l, h);\n\n}\n\n", "pragma": "#pragma omp for schedule ( guided , 1 )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arnov-sinha/parallel-qsort/psort/4"}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = ((float) rand()) / ((float) RAND_MAX);\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nunosilva800/pGEMM_performanceEval/utils/ompMM_GOTO+CUBLAS/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    double *_imopVarPre442;\n    double *_imopVarPre443;\n    double (*_imopVarPre444)[5];\n    _imopVarPre442 = rhs[i][j][ksize];\n    _imopVarPre443 = rhs[i][j][ksize - 1];\n    _imopVarPre444 = lhs[i][j][ksize][0];\n    matvec_sub(_imopVarPre444, _imopVarPre443, _imopVarPre442);\n    double (*_imopVarPre448)[5];\n    double (*_imopVarPre449)[5];\n    double (*_imopVarPre450)[5];\n    _imopVarPre448 = lhs[i][j][ksize][1];\n    _imopVarPre449 = lhs[i][j][ksize - 1][2];\n    _imopVarPre450 = lhs[i][j][ksize][0];\n    matmul_sub(_imopVarPre450, _imopVarPre449, _imopVarPre448);\n    double *_imopVarPre453;\n    double (*_imopVarPre454)[5];\n    _imopVarPre453 = rhs[i][j][ksize];\n    _imopVarPre454 = lhs[i][j][ksize][1];\n    binvrhs(_imopVarPre454, _imopVarPre453);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/83"}
{"code": "for (i = 0; i < currentMatrixSize; i++)\n{\n  Bhead = &B_g[i * currentMatrixSize];\n  tmp = 0;\n  for (j = 0; j < currentMatrixSize; j++)\n  {\n    tmp += Bhead[j];\n  }\n\n  Bsum[i] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/subgraph_modularity_matrix/sgmm_benchmarking/4"}
{"code": "for (idx = 0; idx < 5; idx++)\n  if (arr[(2 * 5) + idx] != (idx < 1))\n  abort();\nelse\n  arr[(2 * 5) + idx] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-12/8"}
{"code": "for (i = T_INIT; i < T_LAST; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/0"}
{"code": "for (i = 1; i < n; i++)\n{\n  int k;\n  int rev = 0;\n  int inp = i;\n  for (k = 0; k < log2_of_n; k++)\n  {\n    rev = (rev << 1) | (inp & 1);\n    inp >>= 1;\n  }\n\n  if (rev <= i)\n    continue;\n\n  temp = xReal[i];\n  xReal[i] = xReal[rev];\n  xReal[rev] = temp;\n  temp = xImg[i];\n  xImg[i] = xImg[rev];\n  xImg[rev] = temp;\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i, temp) shared(n, xReal, xImg, log2_of_n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krishnakinnal/FFT-in-Parallel/fft/1"}
{"code": "for (int index = 0; index < readsCount; index++)\n{\n  if (cluster[index] == (-3))\n  {\n    int target = representative;\n    int query = index;\n    int minLength = ceilf(((float) lengths[index]) * threshold);\n    int targetLength = lengths[target] - gaps[target];\n    int queryLength = lengths[query] - gaps[query];\n    int target32Length = (targetLength / 16) + 1;\n    int query32Length = (queryLength / 16) + 1;\n    int targetOffset = offsets[target] / 16;\n    int queryOffset = offsets[query] / 16;\n    short rowNow[3000] = {0};\n    short rowPrevious[3000] = {0};\n    int columnPrevious[17] = {0};\n    int columnNow[17] = {0};\n    int shift = ceilf(((float) targetLength) - (((float) queryLength) * threshold));\n    int complete = 0;\n    shift = ceilf(((float) shift) / 16.f);\n    for (int i = 0; i < query32Length; i++)\n    {\n      for (int j = 0; j < 17; j++)\n      {\n        columnPrevious[j] = 0;\n        columnNow[j] = 0;\n      }\n\n      int targetIndex = 0;\n      unsigned int queryPack = compressed[queryOffset + i];\n      int jstart = i - shift;\n      jstart = max(jstart, 0);\n      int jend = i + shift;\n      jend = min(jend, target32Length);\n      for (int j = 0; j < target32Length; j++)\n      {\n        columnPrevious[0] = rowPrevious[targetIndex];\n        unsigned int targetPack = compressed[targetOffset + j];\n        for (int k = 30; k >= 0; k -= 2)\n        {\n          int targetBase = (targetPack >> k) & 3;\n          int m = 0;\n          columnNow[m] = rowPrevious[targetIndex + 1];\n          for (int l = 30; l >= 0; l -= 2)\n          {\n            m++;\n            int queryBase = (queryPack >> l) & 3;\n            int diffScore = queryBase == targetBase;\n            columnNow[m] = columnPrevious[m - 1] + diffScore;\n            columnNow[m] = max(columnNow[m], columnNow[m - 1]);\n            columnNow[m] = max(columnNow[m], columnPrevious[m]);\n          }\n\n          targetIndex++;\n          rowNow[targetIndex] = columnNow[16];\n          if (targetIndex == targetLength)\n          {\n            if (i == (query32Length - 1))\n            {\n              int score = columnNow[queryLength % 16];\n              if (score >= minLength)\n              {\n                cluster[index] = target;\n              }\n              else\n              {\n                cluster[index] = -1;\n              }\n\n              complete = 1;\n            }\n\n            break;\n          }\n\n          k -= 2;\n          targetBase = (targetPack >> k) & 3;\n          m = 0;\n          columnPrevious[m] = rowPrevious[targetIndex + 1];\n          for (int l = 30; l >= 0; l -= 2)\n          {\n            m++;\n            int queryBase = (queryPack >> l) & 3;\n            int diffScore = queryBase == targetBase;\n            columnPrevious[m] = columnNow[m - 1] + diffScore;\n            columnPrevious[m] = max(columnPrevious[m], columnPrevious[m - 1]);\n            columnPrevious[m] = max(columnPrevious[m], columnNow[m]);\n          }\n\n          targetIndex++;\n          rowNow[targetIndex] = columnPrevious[16];\n          if (targetIndex == targetLength)\n          {\n            if (i == (query32Length - 1))\n            {\n              int score = columnPrevious[queryLength % 16];\n              if (score >= minLength)\n              {\n                cluster[index] = target;\n              }\n              else\n              {\n                cluster[index] = -1;\n              }\n\n              complete = 1;\n            }\n\n            break;\n          }\n\n        }\n\n        if (complete)\n          break;\n\n      }\n\n      if (complete)\n        break;\n\n      i++;\n      for (int j = 0; j < 17; j++)\n      {\n        columnPrevious[j] = 0;\n        columnNow[j] = 0;\n      }\n\n      targetIndex = 0;\n      queryPack = compressed[queryOffset + i];\n      jstart = i - shift;\n      jstart = max(jstart, 0);\n      jend = i + shift;\n      jend = min(jend, target32Length);\n      for (int j = 0; j < target32Length; j++)\n      {\n        unsigned int targetPack = compressed[targetOffset + j];\n        for (int k = 30; k >= 0; k -= 2)\n        {\n          int targetBase = (targetPack >> k) & 3;\n          int m = 0;\n          columnNow[m] = rowNow[targetIndex + 1];\n          for (int l = 30; l >= 0; l -= 2)\n          {\n            m++;\n            int queryBase = (queryPack >> l) & 3;\n            int diffScore = queryBase == targetBase;\n            columnNow[m] = columnPrevious[m - 1] + diffScore;\n            columnNow[m] = max(columnNow[m], columnNow[m - 1]);\n            columnNow[m] = max(columnNow[m], columnPrevious[m]);\n          }\n\n          targetIndex++;\n          rowPrevious[targetIndex] = columnNow[16];\n          if (targetIndex == targetLength)\n          {\n            if (i == (query32Length - 1))\n            {\n              int score = columnNow[queryLength % 16];\n              if (score >= minLength)\n              {\n                cluster[index] = target;\n              }\n              else\n              {\n                cluster[index] = -1;\n              }\n\n              complete = 1;\n            }\n\n            break;\n          }\n\n          if (complete)\n            break;\n\n          k -= 2;\n          targetBase = (targetPack >> k) & 3;\n          m = 0;\n          columnPrevious[m] = rowNow[targetIndex + 1];\n          for (int l = 30; l >= 0; l -= 2)\n          {\n            m++;\n            int queryBase = (queryPack >> l) & 3;\n            int diffScore = queryBase == targetBase;\n            columnPrevious[m] = columnNow[m - 1] + diffScore;\n            columnPrevious[m] = max(columnPrevious[m], columnPrevious[m - 1]);\n            columnPrevious[m] = max(columnPrevious[m], columnNow[m]);\n          }\n\n          targetIndex++;\n          rowPrevious[targetIndex] = columnPrevious[16];\n          if (targetIndex == targetLength)\n          {\n            if (i == (query32Length - 1))\n            {\n              int score = columnPrevious[queryLength % 16];\n              if (score >= minLength)\n              {\n                cluster[index] = target;\n              }\n              else\n              {\n                cluster[index] = -1;\n              }\n\n              complete = 1;\n            }\n\n            break;\n          }\n\n          if (complete)\n            break;\n\n        }\n\n        if (complete)\n          break;\n\n      }\n\n      if (complete)\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_threads(128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/deredundancy-omp/kernels/14"}
{"code": "for (int i = 0; i < size; i++)\n{\n  total_cells += rank_load[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing8/test/0"}
{"code": "for (k = 1 * 3; k <= ((grid_points[2] - (3 * 1)) - 1); k++)\n{\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(k ,dssp ,m ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/34"}
{"code": "for (unsigned int i = 0; i < (2048 / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < 2048; j++)\n  {\n    spin_old = write[i][j];\n    spin_neigh_x = read[i][j];\n    spin_neigh_y = read[i][((j + 1) + 2048) % 2048];\n    spin_neigh_z = read[i][((j - 1) + 2048) % 2048];\n    spin_neigh_w = read[((i + ((2 * (color ^ (j % 2))) - 1)) + (2048 / 2)) % (2048 / 2)][j];\n    h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n    spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (Q - 1))))) % Q;\n    h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n    delta_E = h_after - h_before;\n    float p = rand_MWC_co(&x_l, &a_l);\n    if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n    {\n      write[i][j] = spin_new;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/49"}
{"code": "for (j = 0; j < dimension; j++)\n{\n  t = data_points[j] - c[j];\n  distance += t * t;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/1"}
{"code": "for (i = Low_h / 2; i < (Low_h - 2); i++)\n{\n  for (j = Low_w / 4; j < (Low_w / 2); j++)\n  {\n    bicubic_Y_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Y[(i * Low_w) + j])) + (bicubic2[1][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Y_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Y[(i * Low_w) + j])) + (bicubic2[0][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/6"}
{"code": "for (int ii = 0; ii < num_threads; ii++)\n  val += local_vals[ii];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/magland/openmp_performance_test/main/1"}
{"code": "for (int i = 0; i < nrow; ++i)\n{\n  if (i < idx)\n  {\n    for (int j = row_offset[i]; j < row_offset[i + 1]; ++j)\n    {\n      col[j] = this->mat_.col[j];\n      val[j] = this->mat_.val[j];\n    }\n\n  }\n  else\n    if (i == idx)\n  {\n    int k = row_offset[i];\n    for (int j = 0; j < ncol; ++j)\n    {\n      if (cast_vec->vec_[j] != ((static_cast < ValueType) > 0))\n      {\n        col[k] = j;\n        val[k] = cast_vec->vec_[j];\n        ++k;\n      }\n\n    }\n\n  }\n  else\n    if (i > idx)\n  {\n    int k = row_offset[i];\n    for (int j = this->mat_.row_offset[i]; j < this->mat_.row_offset[i + 1]; ++j)\n    {\n      col[k] = this->mat_.col[j];\n      val[k] = this->mat_.val[j];\n      ++k;\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/126"}
{"code": "for (int i = 0; i < entrycounters[attr]; i++)\n{\n  if (key == countlabels[i][attr])\n    return i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhantkulkarni/parallelmachinelearning/Code/Naive Bayesian/parallelnaive/2"}
{"code": "for (long pidx_darts_counter_temp1284 = *pidx; (pidx_darts_counter_temp1284 < endRange) && (pidx_darts_counter_temp1284 < this->inputsTPParent->lastIteration1284); pidx_darts_counter_temp1284++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1284], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/52"}
{"code": "for (int i = 2; i < (n - 1); i++)\n{\n  b = createMatrix(p[i], p[i + 1], i);\n  a = matrix_mult(a, b, p[0], p[i], p[i + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/3"}
{"code": "for (i = 0; i < 62; i++)\n{\n  for (j = 0; j < 7; j++)\n  {\n    printf(\"%6.2f   \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_mm/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  middle = a[i];\n  if (((i - 1) > 0) && ((i + 1) < size))\n  {\n    if (i != (offset - 1))\n      a[i] = ((left * a[i]) * a[i + 1]) / 3.0;\n    else\n      a[i] = ((left * a[i]) * buf) / 3.0;\n\n  }\n\n  left = middle;\n}\n\n", "pragma": "omp for schedule(static, block_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw3/swap/0"}
{"code": "for (int i = index; i < (index + granularity); ++i)\n{\n  if (a[i] < a[thread_minimum_index])\n  {\n    thread_minimum_index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP Tasks/q1_w/1"}
{"code": "for (int x = 0; x < BOID_SEGMENTS_PER_DIM; x++)\n{\n  for (int y = 0; y < BOID_SEGMENTS_PER_DIM; y++)\n  {\n    for (int z = 0; z < BOID_SEGMENTS_PER_DIM; z++)\n    {\n      ApplyBoidsSteering(ivec3(x, y, z));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(3) schedule(nonmonotonic:dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/5"}
{"code": "for (i = 0; i < n_rect; i++)\n{\n  sum += f(a + ((i + 0.5) * h)) * h;\n}\n\n", "pragma": "omp parallel for num_threads(threadct) shared (a, n_rect, h) private(i) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sethd1/gpu-offloading-research/Code/pi/0"}
{"code": "for (int j = 0; j < this->nnz_; ++j)\n{\n  this->mat_.row[j] = cast_mat->mat_.row[j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/6"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total += data[i * n];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/1"}
{"code": "for (int i = 0; i < nt; i++)\n{\n  data[i] = q.front();\n  q.pop();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rushabhk7/Branch_and_bound/OPENMP/bnb_openMP/0"}
{"code": "for (int i = 0; i < 16; i++)\n  sd_count[i][idx] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/entropy-omp/main/1"}
{"code": "for (c = 0; c < k; c++)\n{\n  int clusterSize = clusters[c].numDatapoints;\n  double *distances = malloc(clusterSize * (sizeof(double)));\n  for (i = 0; i < clusterSize; i++)\n  {\n    distances[i] = 0.0;\n    for (j = 0; j < clusterSize; j++)\n    {\n      distances[i] += distance(*clusters[c].datapoints[i], *clusters[c].datapoints[j]);\n    }\n\n  }\n\n  int medoidIndex = indexOfSmallestElement(distances, clusterSize);\n  clusters[c].medoid = clusters[c].datapoints[medoidIndex];\n  free(distances);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/11"}
{"code": "for (int i = 0; i < num; i++)\n{\n  v[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/1"}
{"code": "for (int j = 0; j < sizey; j++)\n{\n  for (int i = 0; i < sizex; i++)\n  {\n    for (int mat = 0; mat < Nmats; mat++)\n    {\n      if (Vf[((i + (sizex * j)) * Nmats) + mat] > 0.0)\n      {\n        double nm = n[mat];\n        p[((i + (sizex * j)) * Nmats) + mat] = ((nm * rho[((i + (sizex * j)) * Nmats) + mat]) * t[((i + (sizex * j)) * Nmats) + mat]) / Vf[((i + (sizex * j)) * Nmats) + mat];\n      }\n      else\n      {\n        p[((i + (sizex * j)) * Nmats) + mat] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/1"}
{"code": "for (int i = 0; i < (2 * nst); i++)\n  v2 = v2 + (((1.0 / 20.0) * st2) * ((((((11.0 * f1((i + (1.0 / 6.0)) * st2)) * f2((i + (1.0 / 6.0)) * st2, p1)) - ((14.0 * f1((i + (2.0 / 6.0)) * st2)) * f2((i + (2.0 / 6.0)) * st2, p1))) + ((26.0 * f1((i + (3.0 / 6.0)) * st2)) * f2((i + (3.0 / 6.0)) * st2, p1))) - ((14.0 * f1((i + (4.0 / 6.0)) * st2)) * f2((i + (4.0 / 6.0)) * st2, p1))) + ((11.0 * f1((i + (5.0 / 6.0)) * st2)) * f2((i + (5.0 / 6.0)) * st2, p1))));\n\n", "pragma": "#pragma omp parallel for reduction (+:v2)    ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/7"}
{"code": "for (int i = 0; i < n_local; i++)\n  z_local[i] = r_local[i] / d_local[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/5"}
{"code": "for (i = 10 - 1; i >= m0; i--)\n{\n  z[j3[i][0]][j2[i][0]][j1[i][0]] = -1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/25"}
{"code": "for (int j = 0; j < N; j++)\n{\n  (*m_)[i][j] = drand48();\n  (*mcopy)[i][j] = (*m_)[i][j];\n  if (i == j)\n  {\n    (*l_)[i][j] = 1;\n    (*u_)[i][j] = 1;\n  }\n  else\n    if (i > j)\n  {\n    (*l_)[i][j] = 1;\n  }\n  else\n  {\n    (*u_)[i][j] = 1;\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpz_yegu7e.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/llvm-openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (int i = 0; i < POPULATION_SIZE; i++)\n{\n  population.push_back(get_random(start, end, rand));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RenaLL-N/OpenMP/OpenMP/OpenMP/2"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  result[i] = a[i] / (*b);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/25"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 1; j < s[i]; ++j)\n  for (k = 1; k < j; ++k)\n  a[i] += (log(j + k) * pow(b[i], 4.0)) / (n * n);\n\n\n\n", "pragma": "omp parallel for schedule(runtime) default(none) shared(n,b,s,a) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex7-imbalance-openmp/0"}
{"code": "for (size_t i = 1; i < ((size_t) DARTS_CODELETS_MULT); i++)\n{\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)] = _checkInCodelets872(2, 1, this, localID + (this->baseNumThreads * i));\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)].setID(codeletID);\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)].decDep();\n  this->firstCodelet[localID + (this->baseNumThreads * i)].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/15"}
{"code": "for (i = 0; i < nx; i++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, y[i]);\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/atax/atax/4"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        lhs[i][j][k][1][m][m] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/52"}
{"code": "for (i = 0; i < ((1 * 1024) / 256); i++)\n  for (k = 0; k < ((1 * 1024) / 256); k++)\n{\n  C[(i * ((1 * 1024) / 256)) + k] = ((-((float) ((1 * 1024) / 256))) * ((1 * 1024) / 256)) * ((1 * 1024) / 256);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Matrix_Multiplication_Parallel_Processing_OpenMP_OpenACC/Exploring_OpenMP/matmul/3"}
{"code": "for (i = 0; i < (len * threads); i++)\n{\n  a[i] = 1.0;\n  b[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matiasmartineza/learning_omp/examples/omp_dotprod_openmp/1"}
{"code": "for (int x = 0; x < thread_dimension.x; x++)\n  for (int y = 0; y < thread_dimension.y; y++)\n  for (int z = 0; z < thread_dimension.z; z++)\n  thread_lattice_map.emplace(ivec3(x, y, z), thread_counter++);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/2"}
{"code": "for (i = 0; i < (1 << 23); i++)\n{\n  key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/5"}
{"code": "for (unsigned int i = 0; i < now->capacity; i++)\n{\n  cell_t c = now->table[i];\n  if (c == 0)\n  {\n    continue;\n  }\n\n  cell_t neighbors[6];\n  cell_get_neighbors(c, neighbors, size);\n  if (cell_next_state(c, neighbors, now))\n  {\n    HT_set_atomic(next, c);\n    ncells_next++;\n  }\n\n  for (size_t j = 0; j < 6; j++)\n  {\n    c = neighbors[j];\n    if ((!HT_contains(now, c)) && (!HT_contains(next, c)))\n    {\n      cell_t buf[6];\n      cell_get_neighbors(c, buf, size);\n      if (cell_next_state(c, buf, now))\n      {\n        HT_set_atomic(next, c);\n        ncells_next++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:ncells_next) shared(now, next)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogocp/life3d/life3d-mpi/0"}
{"code": "for (i = 0; i < NUMBALLS; i++)\n  bodies[i].resetforce();\n\n", "pragma": "  #pragma omp parallel for num_threads(numthreads) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sayanmandal/Many-Body-Simulation-OpenMP/simulation/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%d \", vector__2[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EALH/Prog_Paralela/OpenMp/matXmat/2"}
{"code": "for (npy_intp i = 0; i < xsize; ++i)\n{\n  xdata[i] = op->apply(xdata[i]);\n}\n\n", "pragma": "  #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gregvw/mpops/operations/0"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  x_vec.data[i] = 0.0001 * i;\n  y_vec.data[i] = 0.00003 * i;\n}\n\n", "pragma": "omp target teams distribute parallel for num_teams(120*4) thread_limit(512) schedule(static,chunk) map(to:x_vec,y_vec) if(target:use_device)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/targ-273742/targ-273742/0"}
{"code": "for (i = 0; i < m->nrows; ++i)\n{\n  free(m->mel[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/blocked/10"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  if (thread_num)\n  {\n    sum *= add[thread_num - 1];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iPogot/Parallel-Programming/term_2/exp/prog/2"}
{"code": "for (int i = 1; i < size; i++)\n{\n  if (visited[i] == 0)\n  {\n    int temp = curr_bound;\n    curr_weight += adj[curr_path[level - 1]][i];\n    curr_bound -= ((*((*second_mins) + curr_path[level - 1])) + (*((*first_mins) + i))) / 2;\n    if ((curr_bound + curr_weight) <= final_res)\n    {\n      curr_path[level] = i;\n      visited[i] = 1;\n      recursion(size, adj, curr_bound, curr_weight, level + 1, curr_path, visited, first_mins, second_mins);\n    }\n\n    curr_bound = temp;\n    curr_weight -= adj[curr_path[level - 1]][i];\n    visited[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris23bp/Parallel-Traveling-Salesman/openmp_schedule/1"}
{"code": "for (int i = 0; i < num_threads; ++i)\n{\n  int tmp[N];\n  for (int j = 0; j < N; ++j)\n  {\n    tmp[j] = i;\n  }\n\n  for (int j = 0; j < N; ++j)\n  {\n    tmp[j] += j;\n  }\n\n  for (int j = 0; j < N; ++j)\n  {\n    array[i] += tmp[j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/offloading/parallel_offloading_map/0"}
{"code": "for (i1 = 0; i1 < n1; i1++)\n  for (i2 = 0; i2 < n2; i2++)\n{\n  j1 = index1[i1];\n  j2 = index2[i2];\n  distance += metric(n, data, data, mask, mask, weight, j1, j2, transpose);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/133"}
{"code": "for (size_t index_vertex = 0; index_vertex < size_nodes_tags; ++index_vertex)\n{\n  m_list_vertices.push_back(Vertex(index_vertex, normalization_factor * nodeCoords[3 * index_vertex], normalization_factor * nodeCoords[(3 * index_vertex) + 1], normalization_factor * nodeCoords[(3 * index_vertex) + 2]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RemiHelleboid/BzMeshBandsDos/src/BZ_MESH/bz_mesh/0"}
{"code": "for (i = 0; i < 1000; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/architkarandikar/OpenMP-Tutorial/Intro/For/for_directive/0"}
{"code": "for (t = 0; t < 500; t++)\n{\n  {\n    for (j = 0; j < SIZE; j++)\n    {\n      ey[(0 * SIZE) + j] = _fict_[t];\n    }\n\n  }\n  {\n    for (i = 1; i < SIZE; i++)\n    {\n      for (j = 0; j < SIZE; j++)\n      {\n        ey[(i * SIZE) + j] = ey[(i * SIZE) + j] - (0.5 * (hz[(i * SIZE) + j] - hz[((i - 1) * SIZE) + j]));\n      }\n\n    }\n\n  }\n  {\n    for (i = 0; i < SIZE; i++)\n    {\n      for (j = 1; j < SIZE; j++)\n      {\n        ex[(i * (SIZE + 1)) + j] = ex[(i * (SIZE + 1)) + j] - (0.5 * (hz[(i * SIZE) + j] - hz[(i * SIZE) + (j - 1)]));\n      }\n\n    }\n\n  }\n  {\n    for (i = 0; i < SIZE; i++)\n    {\n      for (j = 0; j < SIZE; j++)\n      {\n        hz[(i * SIZE) + j] = hz[(i * SIZE) + j] - (0.7 * (((ex[(i * (SIZE + 1)) + (j + 1)] - ex[(i * (SIZE + 1)) + j]) + ey[((i + 1) * SIZE) + j]) - ey[(i * SIZE) + j]));\n      }\n\n    }\n\n  }\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(2) thread_limit(THREADS) num_teams(BLOCKS3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/FDTD2D/fdtd2dKE/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = i + 1; j < n; j++)\n  a[i][j] = a[j][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_4/c_neighbor/1"}
{"code": "for (i = 0; i < 100; ++i)\n  sum += a[i];\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1516E2/1-fixed/0"}
{"code": "for (i = 0; i < quantidadePiorCasoB; i++)\n{\n  printf(\"%d \", vetor_recB[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/6"}
{"code": "for (i = rb; i < re; i++)\n  ret[i] = ret[i] - (ro1 * p_u_precond[i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/19"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/173"}
{"code": "for (i = 0; i < s->N; i++)\n{\n  Point *xi = &s->positions[i];\n  Point *vi = &s->velocities[i];\n  Point *ai = &accelerations[i];\n  xi->x = (xi->x + (vi->x * s->dt)) + ((0.5 * ai->x) * pow(s->dt, 2));\n  xi->y = (xi->y + (vi->y * s->dt)) + ((0.5 * ai->y) * pow(s->dt, 2));\n  xi->z = (xi->z + (vi->z * s->dt)) + ((0.5 * ai->z) * pow(s->dt, 2));\n  vi->x = vi->x + ((0.5 * ai->x) * s->dt);\n  vi->y = vi->y + ((0.5 * ai->y) * s->dt);\n  vi->z = vi->z + ((0.5 * ai->z) * s->dt);\n}\n\n", "pragma": "omp for schedule(guided,2) private(i) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vahidkianfar/N-body_simulation-Parallel-Programming-/N-body simulation/1"}
{"code": "for (int i = (rang * n) / nbp; i < (((rang + 1) * n) / nbp); i++)\n{\n  d[i] = 0.0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n    if (i == Aj[u])\n    d[i] += Ax[u];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/15"}
{"code": "for (int i = 1; i < size; i++)\n{\n  if ((*max) < arr[i])\n  {\n    *max = arr[i];\n  }\n\n  if ((*min) > arr[i])\n  {\n    *min = arr[i];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alb3rtov/ARCO/lab3/results/task1/src/maxmin_parallel/1"}
{"code": "for (i = 0; i < 1048576; i++)\n{\n  fprintf(stdout, \"Thread [%02d]: h_c[%07d]: %f\\n\", 0, i, h_c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-omp-parallel-for-combined-schedule-dynamic-chunk-value/4"}
{"code": "for (i = 0; i < rows; i++)\n  vector[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Matrix_Vector_Multiplication_MPI_and_OpenMP/matrix_vector_rowwise/1"}
{"code": "for (int j = 0; j < M; j++)\n{\n  if (verbose)\n    printf(\"TID:subTID = %d:%d - in process_data: iteration j=%d\\n\", TID_LVL_1, 0, j);\n\n  do_compute(i, j);\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/17"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  BF_current[index].P[0] ^= u1;\n  BF_current[index].P[1] ^= u2;\n  BF_current[index].P[2] ^= u3;\n  BF_current[index].P[3] ^= u4;\n  BF_current[index].P[4] ^= u1;\n  BF_current[index].P[5] ^= u2;\n  BF_current[index].P[6] ^= u3;\n  BF_current[index].P[7] ^= u4;\n  BF_current[index].P[8] ^= u1;\n  BF_current[index].P[9] ^= u2;\n  BF_current[index].P[10] ^= u3;\n  BF_current[index].P[11] ^= u4;\n  BF_current[index].P[12] ^= u1;\n  BF_current[index].P[13] ^= u2;\n  BF_current[index].P[14] ^= u3;\n  BF_current[index].P[15] ^= u4;\n  BF_current[index].P[16] ^= u1;\n  BF_current[index].P[17] ^= u2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/26"}
{"code": "for (int i = 0; i < aSize; i++)\n{\n  mean += mean_array[i];\n}\n\n", "pragma": "omp for reduction(+:mean)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franBec/SDyP-OpenMP/media/0"}
{"code": "for (int j = jb; j < je; j++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    DzDzu[IDX(i, j, 3)] = ((((2.0 * u[IDX(i, j, 3)]) - (5.0 * u[IDX(i, j, 4)])) + (4.0 * u[IDX(i, j, 5)])) - u[IDX(i, j, 6)]) * idz_sqrd;\n    DzDzu[IDX(i, j, 4)] = ((u[IDX(i, j, 3)] - (2.0 * u[IDX(i, j, 4)])) + u[IDX(i, j, 5)]) * idz_sqrd;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/22"}
{"code": "for (k = ki1; k <= (ki2 - 1); k++)\n{\n  frc2 = frc2 + (((((((phi1[i][k] + phi1[i + 1][k]) + phi1[i][k + 1]) + phi1[i + 1][k + 1]) + phi2[i][k]) + phi2[i + 1][k]) + phi2[i][k + 1]) + phi2[i + 1][k + 1]);\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin1 ,k ,ki1 ,ki2 ,i ) reduction(+:frc2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/60"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  vijk = vs[i][j][k];\n  vp1 = vs[i][j + 1][k];\n  vm1 = vs[i][j - 1][k];\n  rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n  rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n  rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n  rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n  rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,vijk ,vp1 ,vm1 ,ty2 ,dy1ty1 ,yycon2 ,dy2ty1 ,c2 ,dy3ty1 ,con43 ,dy4ty1 ,c1 ,yycon5 ,yycon3 ,dy5ty1 ,yycon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/114"}
{"code": "for (long i = 0; i < n; i++)\n{\n  arr[i] = (int) rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/3"}
{"code": "for (j = active_size; j < l; j++)\n  G[j] = G_bar[j] + p[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/2"}
{"code": "for (i = 0; i < 3; i++)\n  soma += matriz[tid][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabriellramos/lista-openmp-concorrente/q5/1"}
{"code": "for (int i = 1; i < max_rows; i++)\n  input_itemsets[i * max_cols] = (-i) * penalty;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nw/needle/4"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    C[(i * 512) + j] = 0.0;\n    int k;\n    for (k = 0; k < 512; ++k)\n    {\n      C[(i * 512) + j] += A[(i * 512) + k] * B[(k * 512) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/12"}
{"code": "for (int i = 0; i < length; i++)\n{\n  printf(\"Chromosomes[%d]: \", i);\n  for (int j = 0; j < args; j++)\n    printf(\"%c\", ptr3[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/7"}
{"code": "for (i = 0; i < (tamanioMatriz * 2); i++)\n{\n  matrizCampo[i].fila = -5;\n  matrizAux[i].fila = -5;\n  matrizAux[i].color = 10;\n  matrizCampo[i].color = 10;\n}\n\n", "pragma": "omp parallel for private(i) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalOPM1500/1"}
{"code": "for (int channel = 0; channel < source_nchannel; channel++)\n{\n  for (int y = y_begin; (y < y_end) && (y < source_height); y++)\n  {\n    for (int x = x_begin; (x < x_end) && (x < source_width); x++)\n    {\n      int id = (x + (y * source_width)) + ((channel * source_width) * source_height);\n      if (((x == 0) && (y == 0)) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x == 0) && (y == (source_height - 1))) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x == (source_width - 1)) && (y == 0)) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x == (source_width - 1)) && (y == (source_height - 1))) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x == 0) && (y < (source_height - 1))) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x == (source_width - 1)) && (y < (source_height - 1))) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x < (source_width - 1)) && (y == 0)) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n        if (((x < (source_width - 1)) && (y == (source_height - 1))) && maskIn[id])\n      {\n        boundryPixelArray[id] = OUTSIDE;\n      }\n      else\n      {\n        int id_right = ((x + 1) + (y * source_width)) + ((channel * source_width) * source_height);\n        int id_left = ((x - 1) + (y * source_width)) + ((channel * source_width) * source_height);\n        int id_up = (x + ((y + 1) * source_width)) + ((channel * source_width) * source_height);\n        int id_down = (x + ((y - 1) * source_width)) + ((channel * source_width) * source_height);\n        if (((((maskIn[id] >= 0.5) && (maskIn[id_right] >= 0.5)) && (maskIn[id_left] >= 0.5)) && (maskIn[id_up] >= 0.5)) && (maskIn[id_down] >= 0.5))\n        {\n          boundryPixelArray[id] = INSIDE_MASK;\n        }\n        else\n          if (maskIn[id])\n        {\n          boundryPixelArray[id] = BOUNDRY;\n        }\n        else\n        {\n          boundryPixelArray[id] = OUTSIDE;\n        }\n\n\n      }\n\n\n\n\n\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/5"}
{"code": "for (j = 0; j < J; j++)\n{\n  fprintf(fid, \" %20.16e %20.16e\\n\", x[j], u[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcduta/programming/heat/1D/heat_omp/4"}
{"code": "for (k = 0; k < 10; k++)\n{\n  sum += A[i][k] * B[k][j];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment1/Asgn11/2"}
{"code": "for (c = 0; c < buffer; c++)\n{\n  if (x == img.largura)\n  {\n    y++;\n    x = 0;\n  }\n\n  matriz[x][y] = img.data[c];\n  x++;\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francisneibl/processamento_paralelo_imagens/fitroMedia/0"}
{"code": "for (unsigned int i = 0; i < path_array.size(); ++i)\n{\n  print_path_and_values(path_array.at(i), mapa);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/18"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  M(B, i, j, n) = (((n * n) + (i * n)) + j) + 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amerinor01/Practica4-HPC/src/esqueleto/2"}
{"code": "for (m = 0; m < 3; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k])) - (lhs[n + 4][i][j][k] * rhs[m][i2][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/100"}
{"code": "for (int i = 0; i < cluster_amount; i++)\n{\n  for (int j = 0; j < amount_each_proc; j++)\n  {\n    if ((max_qm_points_arr[j].cluster_id == i) && (max_qm_points_arr[j].max_diameter > max_cluster[i]))\n    {\n      max_cluster[i] = max_qm_points_arr[j].max_diameter;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(amount_each_proc,max_qm_points_arr,max_cluster)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/25"}
{"code": "for (iterator i_node = temp_nodes_container.begin(); i_node != temp_nodes_container.end(); ++i_node)\n{\n  if (i_node->IsNot(IdentifierFlag))\n    r_mesh.Nodes().push_back(move(*i_node.base()));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/sources/model_part/1"}
{"code": "for (i = 0; i < niter; ++i)\n{\n  x = ((double) rand()) / 32767;\n  y = ((double) rand()) / 32767;\n  z = (x * x) + (y * y);\n  if (z <= 1)\n    ++local_count;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/pi_montecarlo/pi_montecarlo_parallel_my_reduction/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  M[i] = (int *) malloc(rows * (sizeof(int)));\n  if (M[i] == 0)\n  {\n    printf(\"Out of Memory\\n\");\n    exit(-1);\n  }\n\n  for (j = 0; j < rows; j++)\n  {\n    M[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chander2207/Dijkstra-openmp/omp_dijkstra/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  A[i] = rand() % 9;\n  B[i] = rand() % 9;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Onyaxoxo/OpenMP-FEFU-/4/0"}
{"code": "for (unsigned int i = StartXLocal; i < MaxXLocal; i++)\n  for (unsigned int j = 0; j < F->GetY(); j++)\n{\n  F->GetValue(i, j).Q_conv = 0.;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/18"}
{"code": "for (int i = 0; i < xCoordinates.size(); i += 3)\n{\n  _xCoordinates.push_back(xCoordinates[i]);\n  _yCoordinates.push_back(yCoordinates[i]);\n  _zCoordinates.push_back(zCoordinates[i]);\n  _xCoordinates.push_back(xCoordinates[i + 1]);\n  _yCoordinates.push_back(yCoordinates[i + 1]);\n  _zCoordinates.push_back(zCoordinates[i + 1]);\n  _xCoordinates.push_back(xCoordinates[i + 2]);\n  _yCoordinates.push_back(yCoordinates[i + 2]);\n  _zCoordinates.push_back(zCoordinates[i + 2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/structure/Mesh/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  xtemp = x[i];\n  ytemp = y[i];\n  x[i] = (xtemp * cos(angle)) + (ytemp * sin(angle));\n  y[i] = ((-xtemp) * sin(angle)) + (ytemp * cos(angle));\n}\n\n", "pragma": "omp parallel for firstprivate(n,xtemp,ytemp,angle)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/2"}
{"code": "for (int i = 0; i < NVALS; i++)\n{\n  arr[i] = (rand() / ((float) RAND_MAX)) * 10.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olia92/OpenMP_Mattson/Hist/hist_omp/0"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  int sum = 0;\n  for (k = 0; k < 1000; k++)\n  {\n    sum += matrizA[i][k] * matrizB[k][j];\n  }\n\n  matrizC[i][j] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Felcks/matriz_openmp/MainP/1"}
{"code": "for (int i = 0; i < nSegments; i++)\n{\n  ((((cout << \"----------------------------\\nSegmento \") << i) << \":\\n\") << segments[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/Bucket/0"}
{"code": "for (j = jbeg; j <= jfin; j++)\n{\n  jglob = j;\n  for (k = ki1; k <= ki2; k++)\n  {\n    phi2[j][k] = C2 * (u[ifin][j][k][4] - ((0.50 * ((pow2(u[ifin][j][k][1]) + pow2(u[ifin][j][k][2])) + pow2(u[ifin][j][k][3]))) / u[ifin][j][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/42"}
{"code": "for (c2 = nk; c2 <= (nm + (-1)); c2++)\n{\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/53"}
{"code": "for (x = 0; x < m_rows; ++x)\n{\n  for (y = 0; y < m_cols; ++y)\n  {\n    int x_rows = (x == (m_rows - 1)) ? (rows - (x * c)) : (c);\n    int y_cols = (y == (m_cols - 1)) ? (cols - (y * c)) : (c);\n    int m_area = x_rows * y_cols;\n    block_sum_r = 0, block_sum_g = 0, block_sum_b = 0;\n    for (i = 0; i < x_rows; ++i)\n    {\n      for (j = 0; j < y_cols; ++j)\n      {\n        int offset = (((x * c) + i) * cols) + ((y * c) + j);\n        block_sum_r += pixels_i[offset].r;\n        block_sum_g += pixels_i[offset].g;\n        block_sum_b += pixels_i[offset].b;\n      }\n\n    }\n\n    for (i = 0; i < x_rows; ++i)\n    {\n      for (j = 0; j < y_cols; ++j)\n      {\n        int offset = (((x * c) + i) * cols) + ((y * c) + j);\n        pixels_o[offset].r = pixval(block_sum_r / m_area);\n        pixels_o[offset].g = pixval(block_sum_g / m_area);\n        pixels_o[offset].b = pixval(block_sum_b / m_area);\n      }\n\n    }\n\n    average_r += block_sum_r;\n    average_g += block_sum_g;\n    average_b += block_sum_b;\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, y, i, j, block_sum_r, block_sum_g, block_sum_b) reduction(+ : average_r, average_g, average_b)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yzheng51/image-processing/src/filter/0"}
{"code": "for (int i = 0; i < a.dimension; ++i)\n{\n  float tmp = a.coordinates[i] - b.coordinates[i];\n  dist += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kon-pap/Parallel_Programming_Project_OpenMP/kdtree_omp/0"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k <= (grid_points[2] - 1); k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      for (ix = 0; ix < 2; ix++)\n      {\n        exact_solution((double) ix, eta, zeta, &Pface[ix][0][0]);\n      }\n\n      for (iy = 0; iy < 2; iy++)\n      {\n        exact_solution(xi, (double) iy, zeta, &Pface[iy][1][0]);\n      }\n\n      for (iz = 0; iz < 2; iz++)\n      {\n        exact_solution(xi, eta, (double) iz, &Pface[iz][2][0]);\n      }\n\n      for (m = 0; m < 5; m++)\n      {\n        Pxi = (xi * Pface[1][0][m]) + ((1.0 - xi) * Pface[0][0][m]);\n        Peta = (eta * Pface[1][1][m]) + ((1.0 - eta) * Pface[0][1][m]);\n        Pzeta = (zeta * Pface[1][2][m]) + ((1.0 - zeta) * Pface[0][2][m]);\n        u[m][i][j][k] = (((((Pxi + Peta) + Pzeta) - (Pxi * Peta)) - (Pxi * Pzeta)) - (Peta * Pzeta)) + ((Pxi * Peta) * Pzeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/77"}
{"code": "for (int i = 0; i < count; i++)\n{\n  processwork(parr[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dragonfly9113/introduction_to_OpenMP/OpenMPApplication/OpenMPApplication/Linked/2"}
{"code": "for (int next = 0; next < 40000; next++)\n{\n  if ((graph[(cur_node * 40000) + next] != 0) && (visited_nodes_array[next] != 1))\n  {\n    long new_distance = node_distance_array[cur_node] + graph[(cur_node * 40000) + next];\n    if (new_distance < node_distance_array[next])\n    {\n      node_distance_array[next] = new_distance;\n      parent_nodes_array[next] = cur_node;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(graph, node_distance_array)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/1"}
{"code": "for (i = 0; i < negLength; i++)\n{\n  printf(\"%s\\n\", negative[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/6"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/73"}
{"code": "for (idx_t m = 0; m < mode; ++m)\n{\n  offset += csf->dims[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/3"}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  omp_set_lock(counter_lock[my_ID]);\n  (*pcounter1[my_ID])++;\n  (*pcounter2[my_ID])++;\n  omp_unset_lock(counter_lock[my_ID]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/RefCount_private/private/4"}
{"code": "for (j = 0; j < 32768; j++)\n  for (i = 0; i < 32768; i++)\n{\n  {\n    y[j] = y[j] + (A[(i * 32768) + j] * tmp[i]);\n  }\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/8"}
{"code": "for (i = 0; i < m; i++)\n  y[i] = sqrt(z[i]);\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.8.1/0"}
{"code": "for (int i = 0; i < p; i++)\n{\n  second[i] = malloc(q * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiSoJi/Arqui2_Taller02/op_par/2"}
{"code": "for (i = 0; i < size; ++i)\n  for (j = 0; j < size; ++j)\n  M[(i * size) + j] = (((float) ((i + j) + seed)) / ((i + j) + 1)) * ((i ^ seed) + 0.55);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pengkang12/openmpi-app/Matrix_multiplication_MPI_OMP/matrix_mult_omp/3"}
{"code": "for (int index = (width * height) - 1; index >= 0; --index)\n{\n  if (segmentation_map[index] > 0)\n  {\n    uint32_t indexHistoryBuffer = (3 * index) * numberOfTests;\n    for (int i = numberOfTests; i > 0; --i, indexHistoryBuffer += 3)\n    {\n      if (distance_is_close_8u_C3R(image_data[3 * index], image_data[(3 * index) + 1], image_data[(3 * index) + 2], historyBuffer[indexHistoryBuffer], historyBuffer[indexHistoryBuffer + 1], historyBuffer[indexHistoryBuffer + 2], matchingThreshold))\n      {\n        --segmentation_map[index];\n      }\n\n      uint8_t temp_r = swappingImageBuffer[3 * index];\n      uint8_t temp_g = swappingImageBuffer[(3 * index) + 1];\n      uint8_t temp_b = swappingImageBuffer[(3 * index) + 2];\n      swappingImageBuffer[3 * index] = historyBuffer[indexHistoryBuffer];\n      swappingImageBuffer[(3 * index) + 1] = historyBuffer[indexHistoryBuffer + 1];\n      swappingImageBuffer[(3 * index) + 2] = historyBuffer[indexHistoryBuffer + 2];\n      historyBuffer[indexHistoryBuffer] = temp_r;\n      historyBuffer[indexHistoryBuffer + 1] = temp_g;\n      historyBuffer[indexHistoryBuffer + 2] = temp_b;\n      if (segmentation_map[index] <= 0)\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/13"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  for (int j = 0; j < nx; j++)\n  {\n    double *adjacent = malloc(4 * (sizeof(double)));\n    if (adjacent == 0)\n    {\n      fprintf(stderr, \"Malloc did not work.  Now exiting...\\n\");\n      exit(1);\n    }\n\n    if (i == 0)\n    {\n      adjacent[0] = T_x_pi_boundaryconditions(j, nx);\n    }\n    else\n    {\n      adjacent[0] = T[i - 1][j];\n    }\n\n    if (j == (nx - 1))\n    {\n      adjacent[1] = T[i][0];\n    }\n    else\n    {\n      adjacent[1] = T[i][j + 1];\n    }\n\n    if (i == (nx - 1))\n    {\n      adjacent[2] = T_x_0_boundaryconditions(j, nx);\n    }\n    else\n    {\n      adjacent[2] = T[i + 1][j];\n    }\n\n    if (j == 0)\n    {\n      adjacent[3] = T[i][nx - 1];\n    }\n    else\n    {\n      adjacent[3] = T[i][j - 1];\n    }\n\n    T2[i][j] = T[i][j] + ((dt / (dx * dx)) * ((((adjacent[0] + adjacent[1]) + adjacent[2]) + adjacent[3]) - (4. * T[i][j])));\n    free(adjacent);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshuawallace/hw4_scientific_computing/heat_omp/0"}
{"code": "for (int x = 1; x <= iters; x++)\n  i.swirlTest(x);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/20"}
{"code": "for (i = 0; i < n; i++)\n{\n  t[i] = i * 0.01;\n  x[i] = sin((2 * M_PI) * t[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rcv911/Henon-map/test_sin_omp/0"}
{"code": "for (ptrdiff_t r = 0; r < size; r++)\n{\n  memcpy(count_space, dimensions, arg_len * (sizeof(size_t)));\n  count_space[0] = 1;\n  if (_DEBUG)\n  {\n    printf(\"THREAD %p:\", count_space);\n    printf(\"count_space: \");\n    for (size_t j = 0; j < arg_len; j++)\n      printf(\"%zd, \", count_space[j]);\n\n    printf(\"\\n\");\n  }\n\n  for (size_t j = 0; j < array_count; j++)\n  {\n    char *base = args[j];\n    size_t step = steps[j];\n    ptrdiff_t offset = step * r;\n    array_arg_space[j] = base + offset;\n    if (0 && _DEBUG)\n    {\n      printf(\"Index %zu\\n\", j);\n      printf(\"-->Got base %p\\n\", (void *) base);\n      printf(\"-->Got step %zu\\n\", step);\n      printf(\"-->Got offset %td\\n\", offset);\n      printf(\"-->Got addr %p\\n\", (void *) array_arg_space[j]);\n    }\n\n  }\n\n  if (_DEBUG)\n  {\n    printf(\"array_arg_space: \");\n    for (size_t j = 0; j < array_count; j++)\n      printf(\"%p, \", (void *) array_arg_space[j]);\n\n    printf(\"\\n\");\n  }\n\n  func(array_arg_space, count_space, steps, data);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Python-for-HPC/numbaWithOpenmp/numba/np/ufunc/omppool/3"}
{"code": "for (unsigned int i = 0; i < nlocal_slots; ++i)\n{\n  for (size_t j = slot_start[i]; j < slot_start[i + 1]; ++j)\n  {\n    assert((incoming_data[j] >> (2 * lg_nvertices_per_subpart_2d(lg_nvertices, lg_nvertices_local_1d_per_subowner))) == i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/10"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (5.0 * u[m][i][j][k])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/111"}
{"code": "for (int v = 0; v < numNodes; v++)\n{\n  if (!outgoing_size(g, v))\n  {\n    sum += (damping * solution[v]) / numNodes;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+:sum)\t", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tim00631/OpenMP-Programming/part2/page_rank/page_rank/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i;\n  b[i] = (N + 1) - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daseibert2/OpenMP_Exercises/simd_reduction1/2"}
{"code": "for (i = 0; i < (n * (n + 1)); i++)\n{\n  matrix[i] = 4 * (drand48() - 0.5);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/37"}
{"code": "for (int i = 0; i < ARRAYSIZE; i++)\n{\n  C[i] = A[i] * B[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RebeccaLyric/parallel/Project0/proj0/0"}
{"code": "for (i = 0; i < number_bodies; i++)\n{\n  x = (y = (z = 0.0));\n  for (j = 0; j < number_bodies; j++)\n  {\n    dis = euclidean(R[j][0], R[j][1], R[j][2], R[i][0], R[i][1], R[i][2]);\n    if (dis != 0)\n    {\n      x = x + ((R[j][0] - R[i][0]) / dis);\n      y = y + ((R[j][1] - R[i][1]) / dis);\n      z = z + ((R[j][2] - R[i][2]) / dis);\n    }\n\n  }\n\n  F[i][0] = (x * mass) * mass;\n  F[i][1] = (y * mass) * mass;\n  F[i][2] = (z * mass) * mass;\n}\n\n", "pragma": "     #pragma omp parallel for private(j,dis) schedule(guided) reduction(+:x,y,z) ", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/1"}
{"code": "for (idx_t j_off = 0; j_off < (jend - jbegin); ++j_off)\n{\n  const idx_t j = (jend - j_off) - 1;\n  idx_t idx = tt->ind[m][j];\n  --histogram[idx];\n  idx_t offset = histogram[idx];\n  new_vals[offset] = tt->vals[j];\n  for (idx_t mode = 0; mode < tt->nmodes; ++mode)\n  {\n    if (mode != m)\n    {\n      new_ind[mode][offset] = tt->ind[mode][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/16"}
{"code": "for (uint s = 0; s < lambdaSize; s++)\n{\n  coefDiff = lambda_Coul[s] - lambda_Coul[iState];\n  energyDiff[s].correction += coefDiff * correction;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/22"}
{"code": "for (i = 0; i < n; i++)\n{\n  numero = rand() % n;\n  fprintf(fp, \"%li\", numero);\n  if (i < (n - 1))\n  {\n    fprintf(fp, \" \");\n  }\n\n}\n\n", "pragma": "omp parallel for ordered schedule(static,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_10/Ejercicio_1/generateBitonicArray/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm_set1_epi32(noff);\n  v_moff = _mm_set1_epi32(moff);\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  v_edgelx = _mm_set1_ps(edgelx);\n  v_edgely = _mm_set1_ps(edgely);\n  v_edgerx = _mm_set1_ps(edgerx);\n  v_edgery = _mm_set1_ps(edgery);\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&fxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sfxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&bxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sbxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  memset((void *) (&ncl[8 * k]), 0, 8 * (sizeof(int)));\n  nps = 4 * (npp / 4);\n  sum1 = 0.0;\n  v_sum1 = _mm_set1_pd(0.0);\n  for (j = 0; j < nps; j += 4)\n  {\n    v_x = _mm_load_ps(&ppart[j + npoff]);\n    v_y = _mm_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_nn = _mm_cvttps_epi32(v_x);\n    v_mm = _mm_cvttps_epi32(v_y);\n    v_dxp = _mm_sub_ps(v_x, _mm_cvtepi32_ps(v_nn));\n    v_dyp = _mm_sub_ps(v_y, _mm_cvtepi32_ps(v_mm));\n    v_nn = _mm_sub_epi32(v_nn, v_noff);\n    v_mm = _mm_sub_epi32(v_mm, v_moff);\n    v_it = _mm_mul_epu32(v_mxv, _mm_srli_si128(v_mm, 4));\n    v_mm = _mm_mul_epu32(v_mm, v_mxv);\n    v_mm = _mm_add_epi32(v_mm, _mm_slli_si128(v_it, 4));\n    v_nn = _mm_slli_epi32(_mm_add_epi32(v_nn, v_mm), 2);\n    v_amx = _mm_sub_ps(v_one, v_dxp);\n    v_amy = _mm_sub_ps(v_one, v_dyp);\n    _mm_store_si128((int *) ll, v_nn);\n    nn = ll[0];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 0);\n    a = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    e = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 0);\n    nn += 4;\n    a = _mm_add_ps(a, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    e = _mm_add_ps(e, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 0);\n    a = _mm_mul_ps(a, v_at);\n    e = _mm_mul_ps(e, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 0);\n    a = _mm_add_ps(a, _mm_mul_ps(v_dx, v_at));\n    e = _mm_add_ps(e, _mm_mul_ps(v_dy, v_at));\n    nn = ll[1];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 85);\n    b = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    f = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 85);\n    nn += 4;\n    b = _mm_add_ps(b, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    f = _mm_add_ps(f, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 85);\n    b = _mm_mul_ps(b, v_at);\n    f = _mm_mul_ps(f, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 85);\n    b = _mm_add_ps(b, _mm_mul_ps(v_dx, v_at));\n    f = _mm_add_ps(f, _mm_mul_ps(v_dy, v_at));\n    nn = ll[2];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 170);\n    c = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    g = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 170);\n    nn += 4;\n    c = _mm_add_ps(c, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    g = _mm_add_ps(g, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 170);\n    c = _mm_mul_ps(c, v_at);\n    g = _mm_mul_ps(g, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 170);\n    c = _mm_add_ps(c, _mm_mul_ps(v_dx, v_at));\n    g = _mm_add_ps(g, _mm_mul_ps(v_dy, v_at));\n    nn = ll[3];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 255);\n    d = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    h = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 255);\n    nn += 4;\n    d = _mm_add_ps(d, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    h = _mm_add_ps(h, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 255);\n    d = _mm_mul_ps(d, v_at);\n    h = _mm_mul_ps(h, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 255);\n    d = _mm_add_ps(d, _mm_mul_ps(v_dx, v_at));\n    h = _mm_add_ps(h, _mm_mul_ps(v_dy, v_at));\n    _MM_TRANSPOSE4_PS(a, b, c, d);\n    _MM_TRANSPOSE4_PS(e, f, g, h);\n    v_dx = _mm_mul_ps(a, v_qtmh);\n    v_dy = _mm_mul_ps(b, v_qtmh);\n    v_dz = _mm_mul_ps(c, v_qtmh);\n    a = _mm_add_ps(v_dx, _mm_load_ps(&ppart[(j + (2 * nppmx)) + npoff]));\n    b = _mm_add_ps(v_dy, _mm_load_ps(&ppart[(j + (3 * nppmx)) + npoff]));\n    c = _mm_add_ps(v_dz, _mm_load_ps(&ppart[(j + (4 * nppmx)) + npoff]));\n    v_at = _mm_add_ps(_mm_mul_ps(a, a), _mm_mul_ps(b, b));\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(c, c));\n    v_gami = _mm_sqrt_ps(_mm_add_ps(v_one, _mm_mul_ps(v_at, v_ci2)));\n    v_gami = _mm_div_ps(v_one, v_gami);\n    v_at = _mm_mul_ps(v_gami, v_at);\n    v_at = _mm_div_ps(v_at, _mm_add_ps(v_one, v_gami));\n    v_d = _mm_cvtps_pd(v_at);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    v_it = _mm_srli_si128((int) v_at, 8);\n    v_d = _mm_cvtps_pd((int) v_it);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    v_at = _mm_mul_ps(v_qtmh, v_gami);\n    e = _mm_mul_ps(v_at, e);\n    f = _mm_mul_ps(v_at, f);\n    g = _mm_mul_ps(v_at, g);\n    v_vx = _mm_mul_ps(e, e);\n    v_vy = _mm_mul_ps(f, f);\n    v_vz = _mm_mul_ps(g, g);\n    v_at = _mm_add_ps(_mm_add_ps(v_vx, v_vy), v_vz);\n    d = _mm_div_ps(v_two, _mm_add_ps(v_one, v_at));\n    h = _mm_mul_ps(v_half, _mm_sub_ps(v_one, v_at));\n    v_vx = _mm_mul_ps(_mm_add_ps(h, v_vx), a);\n    v_vy = _mm_mul_ps(_mm_add_ps(h, v_vy), b);\n    v_vz = _mm_mul_ps(_mm_add_ps(h, v_vz), c);\n    h = _mm_mul_ps(e, f);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_add_ps(h, g), b));\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_sub_ps(h, g), a));\n    h = _mm_mul_ps(e, g);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_sub_ps(h, f), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_add_ps(h, f), a));\n    h = _mm_mul_ps(f, g);\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_add_ps(h, e), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_sub_ps(h, e), b));\n    v_vx = _mm_add_ps(v_dx, _mm_mul_ps(v_vx, d));\n    v_vy = _mm_add_ps(v_dy, _mm_mul_ps(v_vy, d));\n    v_vz = _mm_add_ps(v_dz, _mm_mul_ps(v_vz, d));\n    v_at = _mm_mul_ps(v_vx, v_vx);\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(v_vy, v_vy));\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(v_vz, v_vz));\n    v_at = _mm_sqrt_ps(_mm_add_ps(v_one, _mm_mul_ps(v_at, v_ci2)));\n    v_at = _mm_div_ps(v_dtc, v_at);\n    v_dx = _mm_add_ps(v_x, _mm_mul_ps(v_vx, v_at));\n    v_dy = _mm_add_ps(v_y, _mm_mul_ps(v_vy, v_at));\n    mm = 0;\n    v_st = v_zero;\n    v_x = _mm_cmpge_ps(v_dx, v_edgerx);\n    v_y = _mm_cmplt_ps(v_dx, v_edgelx);\n    v_at = _mm_or_ps(v_x, v_y);\n    v_it = _mm_srli_si128((int) v_at, 8);\n    v_it = _mm_add_epi64((int) v_at, v_it);\n    _mm_storel_epi64((int *) (&jj[0]), v_it);\n    if (jj[0] != 0)\n    {\n      v_st = _mm_and_ps(v_two, v_x);\n      v_x = _mm_and_ps(v_x, _mm_cmpge_ps(v_dx, v_anx));\n      v_dx = _mm_sub_ps(v_dx, _mm_and_ps(v_anx, v_x));\n      v_at = _mm_and_ps(v_one, v_y);\n      v_x = _mm_and_ps(v_y, _mm_cmplt_ps(v_dx, v_zero));\n      v_dx = _mm_add_ps(v_dx, _mm_and_ps(v_anx, v_x));\n      v_y = _mm_cmplt_ps(v_dx, v_anx);\n      v_dx = _mm_and_ps(v_dx, v_y);\n      v_st = _mm_add_ps(v_st, _mm_and_ps(v_at, v_y));\n    }\n\n    v_y = _mm_cmpge_ps(v_dy, v_edgery);\n    v_x = _mm_cmplt_ps(v_dy, v_edgely);\n    v_at = _mm_or_ps(v_x, v_y);\n    v_it = _mm_srli_si128((int) v_at, 8);\n    v_it = _mm_add_epi64((int) v_at, v_it);\n    _mm_storel_epi64((int *) (&jj[0]), v_it);\n    if (jj[0] != 0)\n    {\n      v_st = _mm_add_ps(v_st, _mm_and_ps(v_six, v_y));\n      v_y = _mm_and_ps(v_y, _mm_cmpge_ps(v_dy, v_any));\n      v_dy = _mm_sub_ps(v_dy, _mm_and_ps(v_any, v_y));\n      v_at = _mm_and_ps(v_three, v_x);\n      v_y = _mm_and_ps(v_x, _mm_cmplt_ps(v_dy, v_zero));\n      v_dy = _mm_add_ps(v_dy, _mm_and_ps(v_any, v_y));\n      v_x = _mm_cmplt_ps(v_dy, v_any);\n      v_dy = _mm_and_ps(v_dy, v_x);\n      v_st = _mm_add_ps(v_st, _mm_and_ps(v_at, v_x));\n    }\n\n    _mm_store_ps(&ppart[j + npoff], v_dx);\n    _mm_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_vx);\n    _mm_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vy);\n    _mm_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vz);\n    _mm_store_si128((int *) ll, _mm_cvttps_epi32(v_st));\n    kk = 0;\n    memset((void *) lm, 0, 8 * (sizeof(int)));\n    for (i = 0; i < 4; i++)\n    {\n      mm = ll[i];\n      if (mm > 0)\n      {\n        lm[2 * kk] = (j + i) + 1;\n        lm[1 + (2 * kk)] = mm;\n        ncl[(mm + (8 * k)) - 1] += 1;\n        kk += 1;\n      }\n\n    }\n\n    if (kk > 0)\n    {\n      if ((ih + kk) > ntmax)\n      {\n        nh = 1;\n      }\n      else\n      {\n        v_it = _mm_load_si128((int *) lm);\n        _mm_storeu_si128((int *) (&ihole[2 * ((ih + 1) + ((ntmax + 1) * k))]), v_it);\n        if (kk > 2)\n        {\n          v_it = _mm_load_si128((int *) (&lm[4]));\n          _mm_storeu_si128((int *) (&ihole[2 * ((ih + 3) + ((ntmax + 1) * k))]), v_it);\n        }\n\n      }\n\n      ih += kk;\n    }\n\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * mxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * mxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  _mm_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 2; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nps,nn,mm,nm,kk,ih,nh,x,y,vx,vy,vz, dxp,dyp,amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm, rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx, edgery,p2,gami,qtmg,dtg,sum1,v_noff,v_moff,v_nn,v_mm,v_it,v_x,v_y,v_vx, v_vy,v_vz,v_dxp,v_dyp,v_amx,v_amy,v_dx,v_dy,v_dz,v_gami,v_st,v_at, v_edgelx,v_edgely,v_edgerx,v_edgery,v_d,v_sum1,a,b,c,d,e,f,g,h,jj,ll, lm,dd,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/3"}
{"code": "for (it = 0; it < total_its; it++)\n{\n  omp_offloading_start(__off_info__);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/axpy/axpy_ompacc/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    result[i][j] = a[i][j] - b[i][j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pesfahanian/Parallel_Strassen/Strassan Matrix Multiplication Final/6"}
{"code": "for (unsigned int i = 0; i < nEdge; i++)\n  (of2 << _verWt[i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/mtxReader/5"}
{"code": "for (r = 0, pos = 0; r < rows; r++)\n{\n  for (c = 0; c < cols; c++, pos++)\n  {\n    if (nms[pos] == 128)\n      edge[pos] = 128;\n    else\n      edge[pos] = 255;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/10"}
{"code": "for (i = 0; i < end_count; i++)\n{\n  if (i < (*scatt_cyclosynch_num_ph))\n  {\n    idx = synch_comp_photon_idx[i];\n  }\n  else\n  {\n    idx = ((i - (*scatt_cyclosynch_num_ph)) + (*num_ph)) - ((total_bins - count_c_ph) + (*num_null_ph));\n  }\n\n  if (((*ph_orig)[idx].type == UNABSORBED_CS_PHOTON) || ((*ph_orig)[idx].type == COMPTONIZED_PHOTON))\n  {\n    if (count < total_bins)\n    {\n      (*ph_orig)[idx].p0 = (rebin_ph + count)->p0;\n      (*ph_orig)[idx].p1 = (rebin_ph + count)->p1;\n      (*ph_orig)[idx].p2 = (rebin_ph + count)->p2;\n      (*ph_orig)[idx].p3 = (rebin_ph + count)->p3;\n      (*ph_orig)[idx].comv_p0 = (rebin_ph + count)->comv_p0;\n      (*ph_orig)[idx].comv_p1 = (rebin_ph + count)->comv_p1;\n      (*ph_orig)[idx].comv_p2 = (rebin_ph + count)->comv_p2;\n      (*ph_orig)[idx].comv_p3 = (rebin_ph + count)->comv_p3;\n      (*ph_orig)[idx].r0 = (rebin_ph + count)->r0;\n      (*ph_orig)[idx].r1 = (rebin_ph + count)->r1;\n      (*ph_orig)[idx].r2 = (rebin_ph + count)->r2;\n      (*ph_orig)[idx].s0 = (rebin_ph + count)->s0;\n      (*ph_orig)[idx].s1 = (rebin_ph + count)->s1;\n      (*ph_orig)[idx].s2 = (rebin_ph + count)->s2;\n      (*ph_orig)[idx].s3 = (rebin_ph + count)->s3;\n      (*ph_orig)[idx].num_scatt = (rebin_ph + count)->num_scatt;\n      (*ph_orig)[idx].weight = (rebin_ph + count)->weight;\n      (*ph_orig)[idx].nearest_block_index = (rebin_ph + count)->nearest_block_index;\n      (*ph_orig)[idx].type = COMPTONIZED_PHOTON;\n      if ((rebin_ph + count)->weight == 0)\n      {\n        num_null_rebin_ph++;\n      }\n\n      count++;\n    }\n    else\n    {\n      if ((*ph_orig)[idx].type == UNABSORBED_CS_PHOTON)\n      {\n        (*ph_orig)[idx].p0 = -1;\n        (*ph_orig)[idx].nearest_block_index = -1;\n        (*ph_orig)[idx].weight = 0;\n      }\n      else\n      {\n        (*ph_orig)[idx].weight = 0;\n        (*ph_orig)[idx].nearest_block_index = -1;\n      }\n\n    }\n\n  }\n  else\n    if ((*ph_orig)[idx].type != CS_POOL_PHOTON)\n  {\n    (*ph_orig)[idx].type = COMPTONIZED_PHOTON;\n    (*ph_orig)[idx].weight = 0;\n    (*ph_orig)[idx].nearest_block_index = -1;\n  }\n\n\n  if ((*ph_orig)[idx].weight == 0)\n  {\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/12"}
{"code": "for (i = 1; i < (2400 - 1); ++i)\n{\n  for (j = 1; j < (2400 - 1); ++j)\n  {\n    B[(i * 2400) + j] = ((((((((c11 * A[((i - 1) * 2400) + (j - 1)]) + (c12 * A[((i + 0) * 2400) + (j - 1)])) + (c13 * A[((i + 1) * 2400) + (j - 1)])) + (c21 * A[((i - 1) * 2400) + (j + 0)])) + (c22 * A[((i + 0) * 2400) + (j + 0)])) + (c23 * A[((i + 1) * 2400) + (j + 0)])) + (c31 * A[((i - 1) * 2400) + (j + 1)])) + (c32 * A[((i + 0) * 2400) + (j + 1)])) + (c33 * A[((i + 1) * 2400) + (j + 1)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/9"}
{"code": "for (int i = 0; i < num_t_bins; ++i)\n{\n  for (int j = 0; j < num_f_bins; ++j)\n  {\n    if (Map.at(j).at(i) == 1)\n    {\n      f.push_back((char) (32 + j));\n    }\n    else\n    {\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/4"}
{"code": "for (i = 0; i < num_nodes; ++i)\n{\n  for (j = 0; j < num_nodes; ++j)\n  {\n    if (((dist[i][k] == INT_MAX) || (dist[k][j] == INT_MAX)) || (i == j))\n      continue;\n\n    int new_dist = dist[i][k] + dist[k][j];\n    if (dist[i][j] <= new_dist)\n      continue;\n\n    dist[i][j] = new_dist;\n    paths[i][j] = k;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/parallel-processing/OpenMP-NQMQ/FloydOMP/2"}
{"code": "for (i = 0; i < sz; i++)\n{\n  if (maxlab[klabels[i]] < distlab[i])\n    maxlab[klabels[i]] = distlab[i];\n\n  if (maxxy[klabels[i]] < distxy[i])\n    maxxy[klabels[i]] = distxy[i];\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/8"}
{"code": "for (i = 0; i <= (1000 + 1); i++)\n{\n  for (j = 0; j <= (1000 + 1); j++)\n  {\n    t[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kuanweih/XSEDE-HPC-Workshop/Exercises-my/OpenMP/Examples/laplace_parallel_region/3"}
{"code": "for (int i = 0; i < groundTruth.shape[0]; ++i)\n{\n  for (int j = 0; j < groundTruth.shape[1]; ++j)\n  {\n    for (int k = 0; k < groundTruth.shape[2]; ++k)\n    {\n      res = max(res, abs(groundTruth(i, j, k)));\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(max : res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/CpuSolver/7"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    for (int k = 0; k < SIZE; k++)\n    {\n      matrix_r[i][j] += matrix_a[i][k] * matrix_b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darek74123/PR-OpenMP-Project/Code/matrix/0"}
{"code": "for (int a = 0; a < N; ++a)\n{\n  p1 = (rand() * 1.0) / ((double) RAND_MAX);\n  p2 = (rand() * 1.0) / ((double) RAND_MAX);\n  p3 = (rand() * 1.0) / ((double) RAND_MAX);\n  position[a] = triplet(p1 * XMAX, p2 * YMAX, p3 * ZMAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task2/src/v0.0/pathGen/0"}
{"code": "for (i = 0; i < Np; i++)\n{\n  t[i] = increment * ((double) i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/1"}
{"code": "for (register int l = -lmax; l < 0; l++)\n{\n  a1[l + lmax] = ((factor / lambda) * pow(-1.0, -l)) * bessel_Jn_array[-l];\n  a1[l + lmax] *= (double) l;\n  a2[l + lmax] = (((factor * I) * 0.5) * pow(-1.0, -l)) * (bessel_Jn_array[(-l) - 1] - bessel_Jn_array[(-l) + 1]);\n  a3[l + lmax] = ((((kperp / omega) * ((vpar * df0_dvperp(vpar, vperp)) - (vperp * df0_dvpar(vpar, vperp)))) / lambda) * pow(-1.0, -l)) * bessel_Jn_array[-l];\n  a3[l + lmax] *= (double) l;\n  a3[l + lmax] += (df0_dvpar(vpar, vperp) * pow(-1.0, -l)) * bessel_Jn_array[-l];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/20"}
{"code": "for (int i = 1; i < (COLUMN - 1); i++)\n{\n  currentGeneration[i][0] = '.';\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rzaaeeff/GameofLife-OpenMP/GoLParallel/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  private_sum += z[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialBase/Mapexp/parallel/mapexpCritical/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (c[i] != 100)\n  {\n    printf(\"Data Race\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB149-missingdata1-orig-gpu-no/2"}
{"code": "for (i = 0; i < STATES; i++)\n  free(transitionMat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/19"}
{"code": "for (int j = 0; j < this->nnz_; ++j)\n{\n  this->mat_.val[j] = cast_mat->mat_.val[j];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/8"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = nppmx * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[3 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (j = 0; j < 26; j++)\n  {\n    ncl[j + (26 * l)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    z = ppart[2 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nn = 3 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 3]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 3]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 3]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 3]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 3]));\n    nn += 3 * mxyv;\n    vx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 3]);\n    vy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 3]);\n    vz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    dx = dx + (dzp * ((vx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 3])));\n    dy = dy + (dzp * ((vy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 3])));\n    dz = dz + (dzp * ((vz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 3])));\n    vx = ppart[3 + (idimp * (j + npoff))];\n    vy = ppart[4 + (idimp * (j + npoff))];\n    vz = ppart[5 + (idimp * (j + npoff))];\n    dx = vx + (qtm * dx);\n    dy = vy + (qtm * dy);\n    dz = vz + (qtm * dz);\n    vx += dx;\n    vy += dy;\n    vz += dz;\n    sum1 += ((vx * vx) + (vy * vy)) + (vz * vz);\n    ppart[3 + (idimp * (j + npoff))] = dx;\n    ppart[4 + (idimp * (j + npoff))] = dy;\n    ppart[5 + (idimp * (j + npoff))] = dz;\n    dx = x + (dx * dt);\n    dy = y + (dy * dt);\n    dz = z + (dz * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    ppart[2 + (idimp * (j + npoff))] = dz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,noff,moff,loff,npp,npoff,nn,mm,ll,ih,nh,x,y,z,dxp,dyp, dzp,amx,amy,amz,dx1,dx,dy,dz,vx,vy,vz,edgelx,edgely,edgelz,edgerx, edgery,edgerz,sum1,sfxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic3/mpush3/1"}
{"code": "for (size_t i = 0; i != dev.size(); ++i)\n{\n  m_buffers.emplace_back(dev[i].m_context, CL_MEM_READ_WRITE, alloc_size());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_opencl/1"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i += 1)\n{\n  for (j = 0; j <= (grid_points[1] - 1); j += 1)\n  {\n    for (k = 0; k <= (grid_points[2] - 1); k += 1)\n    {\n      rho_inv = 1.0 / u[0][i][j][k];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[1][i][j][k] * rho_inv;\n      vs[i][j][k] = u[2][i][j][k] * rho_inv;\n      ws[i][j][k] = u[3][i][j][k] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[1][i][j][k] * u[1][i][j][k]) + (u[2][i][j][k] * u[2][i][j][k])) + (u[3][i][j][k] * u[3][i][j][k]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n      aux = (c1c2 * rho_inv) * (u[4][i][j][k] - square[i][j][k]);\n      aux = sqrt(aux);\n      speed[i][j][k] = aux;\n      ainv[i][j][k] = 1.0 / aux;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/223"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n  a[i][j] = j;\n\n\n", "pragma": "omp for schedule (dynamic, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Matrix_mult/block_mult/0"}
{"code": "for (unsigned int i = 0; i < num_main_call; ++i)\n{\n  r_sum = 0;\n  g_sum = 0;\n  b_sum = 0;\n  for (unsigned int j = 0; j < cell_size; ++j)\n  {\n    index = (((((i / cell_num_weight) * cell_size) + j) * image->width) + ((i % cell_num_weight) * cell_size)) * 3;\n    for (unsigned int k = 0; k < cell_size; ++k)\n    {\n      r_sum += p_data[index + (k * 3)];\n      g_sum += p_data[(index + (k * 3)) + 1];\n      b_sum += p_data[(index + (k * 3)) + 2];\n    }\n\n  }\n\n  r = (unsigned char) (r_sum / num_in_cell);\n  g = (unsigned char) (g_sum / num_in_cell);\n  b = (unsigned char) (b_sum / num_in_cell);\n  r_average_sum += r;\n  g_average_sum += g;\n  b_average_sum += b;\n  for (unsigned int j = 0; j < cell_size; ++j)\n  {\n    index = (((((i / cell_num_weight) * cell_size) + j) * image->width) + ((i % cell_num_weight) * cell_size)) * 3;\n    for (unsigned int k = 0; k < cell_size; ++k)\n    {\n      p_data[index + (k * 3)] = r;\n      p_data[(index + (k * 3)) + 1] = g;\n      p_data[(index + (k * 3)) + 2] = b;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NYXFLOWER/Mosaics-CUDA-OpenMP/photo_mosaic/mosaic/0"}
{"code": "for (i = i_start; i < n; i++)\n{\n  REAL *tmp_uold = &uold[(((i + uold_0_offset) * uold_m) + uold_1_offset) + j_start];\n  REAL *tmp_f = &f[(i * m) + j_start];\n  REAL *tmp_u = &u[(i * m) + j_start];\n  for (j = j_start; j < m; j++)\n  {\n    REAL resid = ((((ax * (tmp_uold[uold_m] + tmp_uold[-uold_m])) + (ay * (tmp_uold[-1] * tmp_uold[1]))) + (b * tmp_uold[0])) - (*tmp_f)) / b;\n    *tmp_u = (*tmp_uold = omega * resid);\n    er = (*er) + (resid * resid);\n    tmp_uold++;\n    tmp_f++;\n    tmp_u++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) reduction(+:er)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_itlmic_kernel/1"}
{"code": "for (i = 0; i < bar_num; i++)\n{\n  if (points <= bar_maxes[i])\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bahaa29/OpenMP_with_mpi-compute-hisogram/A3/2"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = size; j < (size * 2); j++)\n{\n  if (j == (i + size))\n    _A[i][j] = 1;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW4/det/10"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i)\n{\n  if (pred[i] != (-1))\n  {\n    pred_win.add_request(i - i_start, pred_owner[i - i_start], pred_local[i - i_start], i - i_start);\n  }\n  else\n  {\n    pred_level[i - i_start] = UINT16_MAX;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/validate/2"}
{"code": "for (int i = myoffset; i < (myoffset + mylength); i++)\n{\n  update(&bodies[i], deltaT, accX[i], accY[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nelorth/nbody/src/nbody/parallel/6"}
{"code": "for (int i = 4; i < 5; ++i)\n{\n  ((cout << \"Thread number: \") << i) << endl;\n  als(ratings, maxUserId, maxUMovieId, 4, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muatik/openmp-examples/als-movie-recommender/main/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    B[(i * 500) + j] = (((DATA_TYPE) i) * (j + 1)) / 500;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm_cpu/4"}
{"code": "for (long i = 1; i < curr_step_number; i++)\n{\n  double x = a + (step * i);\n  result += f(x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KirovVerst/parallel_programming_course/lab3/implementations/0"}
{"code": "for (i = 0; i < 13; i += 3)\n{\n  printf(\"Second Hello %d\\n\", i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-nowait/2"}
{"code": "for (int i = 0; i < (n * n); i++)\n  b[i] = mat[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/opencl-char-pol/main/4"}
{"code": "for (int j = 1; j < (sizey - 1); j++)\n{\n  for (int i = 1; i < (sizex - 1); i++)\n  {\n    double xo = x[i + (sizex * j)];\n    double yo = y[i + (sizex * j)];\n    double dsqr[9];\n    for (int nj = -1; nj <= 1; nj++)\n    {\n      for (int ni = -1; ni <= 1; ni++)\n      {\n        dsqr[((nj + 1) * 3) + (ni + 1)] = 0.0;\n        double xi = x[(i + ni) + (sizex * (j + nj))];\n        double yi = y[(i + ni) + (sizex * (j + nj))];\n        dsqr[((nj + 1) * 3) + (ni + 1)] += (xo - xi) * (xo - xi);\n        dsqr[((nj + 1) * 3) + (ni + 1)] += (yo - yi) * (yo - yi);\n      }\n\n    }\n\n    for (int mat = 0; mat < Nmats; mat++)\n    {\n      if (Vf[((i + (sizex * j)) * Nmats) + mat] > 0.0)\n      {\n        double rho_sum = 0.0;\n        int Nn = 0;\n        for (int nj = -1; nj <= 1; nj++)\n        {\n          if (((j + nj) < 0) || ((j + nj) >= sizey))\n            continue;\n\n          for (int ni = -1; ni <= 1; ni++)\n          {\n            if (((i + ni) < 0) || ((i + ni) >= sizex))\n              continue;\n\n            if (Vf[(((i + ni) + (sizex * (j + nj))) * Nmats) + mat] > 0.0)\n            {\n              rho_sum += rho[(((i + ni) + (sizex * (j + nj))) * Nmats) + mat] / dsqr[((nj + 1) * 3) + (ni + 1)];\n              Nn += 1;\n            }\n\n          }\n\n        }\n\n        rho_mat_ave[((i + (sizex * j)) * Nmats) + mat] = rho_sum / Nn;\n      }\n      else\n      {\n        rho_mat_ave[((i + (sizex * j)) * Nmats) + mat] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/2"}
{"code": "for (int i = 1; i < size; i++)\n{\n  curr_bound += (*((*first_mins) + i)) + (*((*second_mins) + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris23bp/Parallel-Traveling-Salesman/openmp_for/2"}
{"code": "for (i = 0; i < 9; i++)\n{\n  Ma[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/20"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  sum += histo[i];\n  printf(\"histo[%d]=%d\\n\", i, histo[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Histogramme/Histo_atomic/1"}
{"code": "for (int i = 0; i < IT_END; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rutgers-apl/omp-racer/tests/microbenchmarks/contention_test/test_1/0"}
{"code": "for (unsigned int i = 0; i < daughter.size(); ++i)\n{\n  if (daughter.at(i) == \" \")\n    unused_mommy_genes.push_back(parents.at(0).at(i));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/10"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  suma += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ummyers/Concurrente2019-2/Practica2/RespaldoPractica2Concurrente/0"}
{"code": "for (int i = 1; i < m; ++i)\n{\n  rowptr[i + 1] += rowptr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/CSR/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  randperm.push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/7"}
{"code": "for (int pz = 0; pz < nSlices; pz++)\n{\n  for (int py = 0; py < nPixX; py++)\n  {\n    for (int px = 0; px < nPixY; px++)\n    {\n      const int pos = (((nPixX * nPixY) * pz) + (py * nPixY)) + px;\n      d_img[pos] /= (double) nProj;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  x = h * i;\n  sum_seq += f(x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/integral/1"}
{"code": "for (i = 0; i < (bands * cols); i++)\n{\n  noise1[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/19"}
{"code": "for (int j = i * i; j <= N; j += i)\n{\n  list[j] = -1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibrahim65432/GeneratingPrimeNumbers_using_OpenMP/genprimes/0"}
{"code": "for (int ctr = end; ctr < (imageHeight * imageWidth); ctr++)\n  depth[ctr] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eeshanagarwal/DepthMap/calcDepthOptimized_openMP/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  temp = temp + (x[i] * y[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/19"}
{"code": "for (int process_id = MASTER + 1; process_id < mpi_num_processes; process_id++)\n{\n  if (ended[process_id] == true)\n    continue;\n\n  if (MPI_Recv(&result_length, 1, MPI_INT, process_id, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)\n    ERR(\"MPI_Recv@get_results\");\n\n  if (MPI_Recv(result, result_length, MPI_CHAR, process_id, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)\n    ERR(\"MPI_Recv@get_results\");\n\n  if (strcmp(result, END) == 0)\n  {\n    num_processes_ended++;\n    ended[process_id] = true;\n  }\n  else\n  {\n    result_string = string(result);\n    escape_pos = result_string.find_last_of(ESCAPE_CHAR);\n    itemset = result_string.substr(0, escape_pos);\n    support = stoi(result_string.substr(escape_pos + 1));\n    if (results.find(itemset) == results.end())\n      results[itemset] = support;\n    else\n      results[itemset] += support;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paoloiannino/PFP-Growth/src/pfp_growth/1"}
{"code": "for (i = 0; i < num_sections; i++)\n{\n  sprintf(devname, \"%s\", iniparser_getsecname(ini, i));\n  sprintf(keyname, \"%s:%s\", devname, \"num\");\n  int num_devs = iniparser_getint(ini, keyname, 1);\n  if (num_devs <= 0)\n    continue;\n\n  omp_device_t *dev = &omp_devices[devid];\n  sprintf(devname, \"%s\", iniparser_getsecname(ini, i));\n  sprintf(keyname, \"%s:%s\", devname, \"sysid\");\n  int devsysid = iniparser_getint(ini, keyname, -1);\n  sprintf(dev->name, \"%s:%d\", devname, devsysid);\n  sprintf(keyname, \"%s:%s\", devname, \"ncores\");\n  int num_cores = iniparser_getint(ini, keyname, 1);\n  char *devtype;\n  sprintf(keyname, \"%s:%s\", devname, \"type\");\n  devtype = iniparser_getstring(ini, keyname, \"NULL\");\n  if ((strcasecmp(devtype, \"cpu\") == 0) || (strcasecmp(devtype, \"hostcpu\") == 0))\n  {\n    omp_init_hostcpu_device(dev, devid, devsysid, num_cores);\n    num_hostcpu_dev += num_devs;\n  }\n  else\n    if (strcasecmp(devtype, \"nvgpu\") == 0)\n  {\n    omp_init_nvgpu_device(dev, devid, devsysid);\n    num_nvgpu_dev += num_devs;\n  }\n  else\n    if (strcasecmp(devtype, \"thsim\") == 0)\n  {\n    omp_init_thsim_device(dev, devid, devsysid, num_cores);\n    num_thsim_dev += num_devs;\n  }\n  else\n    if (strcasecmp(devtype, \"itlgpu\") == 0)\n  {\n    omp_init_itlgpu_device(dev, devid, devsysid, num_cores);\n    num_itlgpu_dev += num_devs;\n  }\n  else\n    if (strcasecmp(devtype, \"itlmic\") == 0)\n  {\n    omp_init_itlmic_device(dev, devid, devsysid, num_cores);\n    num_itlmic_dev += num_devs;\n  }\n  else\n  {\n    printf(\"unknow device type error: %s \\n, default to be hostcpu\\n\", devtype);\n  }\n\n\n\n\n\n  sprintf(keyname, \"%s:%s\", devname, \"flopss\");\n  dev->total_real_flopss = iniparser_getdouble(ini, keyname, -1);\n  sprintf(keyname, \"%s:%s\", devname, \"Bandwidth\");\n  dev->bandwidth = iniparser_getdouble(ini, keyname, -1);\n  sprintf(keyname, \"%s:%s\", devname, \"Latency\");\n  dev->latency = iniparser_getdouble(ini, keyname, 0.00000000001);\n  sprintf(keyname, \"%s:%s\", devname, \"Memory\");\n  char *mem = iniparser_getstring(ini, keyname, \"default\");\n  if (strcasecmp(mem, \"shared\") == 0)\n  {\n    dev->mem_type = OMP_DEVICE_MEM_SHARED;\n  }\n  else\n    if (strcasecmp(mem, \"discrete\") == 0)\n  {\n    dev->mem_type = OMP_DEVICE_MEM_DISCRETE;\n  }\n  else\n  {\n  }\n\n\n  devid++;\n  int j;\n  for (j = 1; j < num_devs; j++)\n  {\n    omp_device_t *newd = &omp_devices[devid];\n    omp_util_copy_device_object(newd, dev, devid, devsysid + j);\n    sprintf(newd->name, \"%s:%d\", devname, devsysid + j);\n    devid++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/3"}
{"code": "for (i = 0; i < 3; ++i)\n{\n  for (j = 0; j < 3; ++j)\n  {\n    C[i][j] = 0;\n    for (k = 0; k < 3; ++k)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) shared(A,B,C)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/product of 2 matrix/0"}
{"code": "for (int i = 0; i < (n * n); ++i)\n  *(C + i) = (*(A + i)) + (*(B + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/3"}
{"code": "for (int i = 0; i < cloudSize; ++i)\n{\n  x.push_back(IntegerVector(clouds[i].dusts.begin(), clouds[i].dusts.end()));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/15"}
{"code": "for (i = k1; i < k2; i++)\n{\n  x = randlc(&s, an);\n  x += randlc(&s, an);\n  x += randlc(&s, an);\n  x += randlc(&s, an);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/IS/is/0"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, 0, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x += 8)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n        u[xyzInd + 1] += u[(xyzInd + 1) - OMP_xMax] * nu;\n        u[xyzInd + 2] += u[(xyzInd + 2) - OMP_xMax] * nu;\n        u[xyzInd + 3] += u[(xyzInd + 3) - OMP_xMax] * nu;\n        u[xyzInd + 4] += u[(xyzInd + 4) - OMP_xMax] * nu;\n        u[xyzInd + 5] += u[(xyzInd + 5) - OMP_xMax] * nu;\n        u[xyzInd + 6] += u[(xyzInd + 6) - OMP_xMax] * nu;\n        u[xyzInd + 7] += u[(xyzInd + 7) - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, yval, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, 0);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, zval);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/qompDeblur/0"}
{"code": "for (int i = start_index; i < end_index; i++)\n{\n  if (waat[i] > dsv[i])\n  {\n    dsv[i] = dsv[i] + (AFFECT_RATE * (waat[i] - dsv[i]));\n  }\n  else\n  {\n    dsv[i] = dsv[i] - (AFFECT_RATE * (dsv[i] - waat[i]));\n  }\n\n  if (dsv[i] < LOCAL_MIN_DSV)\n    LOCAL_MIN_DSV = dsv[i];\n\n  if (dsv[i] > LOCAL_MAX_DSV)\n    LOCAL_MAX_DSV = dsv[i];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nithintsk/adaptive-mesh-refinement/MPI/disposable/1"}
{"code": "for (int j = 0; j < i; j++)\n  sub += L[i][j] * v[j];\n\n", "pragma": "omp parallel for reduction(+:sub)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/6"}
{"code": "for (int t = tempmin; t <= tempmax; t += tempsteps)\n{\n  startt;\n  latticeinirand(lattice);\n  acc = runmcmc(lattice, equibsweep, 0.01 * ((double) t), 0);\n  endt;\n  printf(\"Equilibration:: t=%f__acc=%f__Time=%I64d__Thread=%d\\n\", 0.01 * ((double) t), acc, showt, omp_get_thread_num());\n  latticeexport(lattice, 0.01 * ((double) t));\n  startt;\n  acc = runmcmc(lattice, measurelen * measurenum, 0.01 * ((double) t), 2);\n  endt;\n  printf(\"Measurement:: t=%f__acc=%f__Time=%I64d__Thread=%d\\n\", 0.01 * ((double) t), acc, showt, omp_get_thread_num());\n}\n\n", "pragma": "\t\t#pragma omp for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keygenx/N-Vector-Model/Vector Model/19"}
{"code": "for (int j = 0; j < mode; ++j)\n{\n  if (NDQ_success[j])\n  {\n    for (int i = 0; i < length; ++i)\n    {\n      if (IF[j][i] > maxF)\n        maxF = IF[j][i];\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/27"}
{"code": "for (i = 0; i < l; ++i)\n  kvalue[i] = k_function(x, model->SV[i], model->param);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/billyeh/cs194project/libsvm-3.20/svm/1"}
{"code": "for (i = 0; i < 1000; i++)\n  a[(2 * i) + 1] = a[i] + 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/truedeplinear-orig-yes/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  current_y[i] = y_a[i];\n  current_k1[i] = 0.;\n  current_k2[i] = 0.;\n  current_k3[i] = 0.;\n  current_k4[i] = 0.;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example3/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[i][j] = AA[(i * 4) + j];\n    Ai[i][j] = A[i][j];\n  }\n\n  b[i] = bb[i];\n  bi[i] = b[i];\n  y[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/gauss/6"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    B[(i * 1024) + j] = (((DATA_TYPE) i) * (j + 1)) / 1024;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/2MM/src/2mm/1"}
{"code": "for (j = 1; j <= ndelta; j++)\n{\n  for (k = 0; k <= nly; k++)\n  {\n    new_dw = ((learning_rate * delta[j]) * ly[k]) + (momentum * oldw[k][j]);\n    w[k][j] += new_dw;\n    oldw[k][j] = new_dw;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PAC-P2P/BPNN-Face-Recognition-For-Parallel/src/backprop/1"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  uint32_t src;\n  uint32_t dest;\n  src = edgeList->edges_array_src[i];\n  dest = edgeList->edges_array_dest[i];\n  edgeList->edges_array_src[i] = src | mask_array[src];\n  edgeList->edges_array_dest[i] = dest | mask_array[dest];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/11"}
{"code": "for (i = 0; i < 10; i++)\n{\n  {\n    sum = intermediate + sum;\n  }\n}\n\n", "pragma": "omp parallel for ordered private(intermediate)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/directives/ordered/0"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  primes[i] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/prime/prime/0"}
{"code": "for (int i = 0; i < img_h; i++)\n{\n  for (int j = 0; j < img_w; j++)\n  {\n    float sum = 0;\n    for (int k = 0; k < ker_h; k++)\n    {\n      for (int m = 0; m < ker_w; m++)\n      {\n        int offseti = ((-1) * floor(ker_h / 2)) + k;\n        int offsetj = ((-1) * floor(ker_w / 2)) + m;\n        if (in_bounds(i + offseti, j + offsetj, img_w, img_h))\n          sum += image[((i + offseti) * img_w) + (j + offsetj)] * kernel[(k * ker_w) + m];\n\n      }\n\n    }\n\n    (*gradient)[(i * img_w) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GlennRC/HighPerformanceComputing/Program-3/main_omp/1"}
{"code": "for (size_t i = 0; i < val.size(); i++)\n{\n  val[i] = rand(mt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/utils/dense_constructor/0"}
{"code": "for (j = jbeg; j <= jfin; j++)\n{\n  jglob = j;\n  k = ki1;\n  phi1[i][j] = C2 * (u[i][j][k][4] - ((0.50 * ((pow2(u[i][j][k][1]) + pow2(u[i][j][k][2])) + pow2(u[i][j][k][3]))) / u[i][j][k][0]));\n  k = ki2;\n  phi2[i][j] = C2 * (u[i][j][k][4] - ((0.50 * ((pow2(u[i][j][k][1]) + pow2(u[i][j][k][2])) + pow2(u[i][j][k][3]))) / u[i][j][k][0]));\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin ,j ,jbeg ,ki1 ,ki2 ,jfin ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/52"}
{"code": "for (unsigned int i = 0; i < dim; i++)\n{\n  input_vector.push_back(rand() % lim);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmirsamanAhmadi/OpenMPSorting/Combined Project/Combined Project/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  res += str[arr[i] - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashishpoudel995/Parallelization-of-DES-Algorithm-Using-Open-MP/Codes/nestedParallelism/0"}
{"code": "for (iRow = 0; iRow < H; ++iRow)\n{\n  double temp_r = rand() / ((double) 32767);\n  long *data = PyArray_GETPTR2(array, iRow, 0);\n  long *node_type = PyArray_GETPTR2(node_types, iRow, 0);\n  long mod_iRowM1 = mod(iRow - 1, H);\n  long mod_iRowP1 = mod(iRow + 1, H);\n  uint32_t *cell_color = PyArray_GETPTR2(cell_colors, iRow, 0);\n  for (iCol = 0; iCol < W; ++iCol, ++data, ++cell_color, ++node_type)\n  {\n    if ((iCol == 0) || (iCol == (W - 1)))\n    {\n      if ((iRow % 2) == 0)\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, mod(iCol - 1, W));\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *e = PyArray_GETPTR2(array_temp, iRow, mod(iCol + 1, W));\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, mod(iCol - 1, W));\n        long *w = PyArray_GETPTR2(array_temp, iRow, mod(iCol - 1, W));\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n      else\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, mod(iCol + 1, W));\n        long *e = PyArray_GETPTR2(array_temp, iRow, mod(iCol + 1, W));\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, mod(iCol + 1, W));\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *w = PyArray_GETPTR2(array_temp, iRow, mod(iCol - 1, W));\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n\n    }\n    else\n    {\n      if ((iRow % 2) == 0)\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol - 1);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *e = PyArray_GETPTR2(array_temp, iRow, iCol + 1);\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol - 1);\n        long *w = PyArray_GETPTR2(array_temp, iRow, iCol - 1);\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n      else\n      {\n        long *nw = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol);\n        long *ne = PyArray_GETPTR2(array_temp, mod_iRowM1, iCol + 1);\n        long *e = PyArray_GETPTR2(array_temp, iRow, iCol + 1);\n        long *se = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol + 1);\n        long *sw = PyArray_GETPTR2(array_temp, mod_iRowP1, iCol);\n        long *w = PyArray_GETPTR2(array_temp, iRow, iCol - 1);\n        *data = move6(*nw, *ne, *e, *se, *sw, *w);\n      }\n\n    }\n\n    if ((*node_type) != (-1))\n    {\n      *cell_color = 255 - (nSetBits[*data] * 42);\n      if (((temperature != 0) && ((*cell_color) != (255 - (6 * 42)))) && ((*cell_color) != 255))\n      {\n        long this_temp_r = (((((iCol * iRow) * temp_r) * (*cell_color)) + iCol) + iRow) + temp_r;\n        if ((this_temp_r % 100000) < temperature)\n        {\n          switch (*cell_color)\n          {\n            case 255 - (1 * 42):\n              *data = 255 - random_table1[this_temp_r % size_random1];\n              break;\n\n            case 255 - (2 * 42):\n              *data = 255 - random_table2[this_temp_r % size_random2];\n              break;\n\n            case 255 - (3 * 42):\n              *data = 255 - random_table3[this_temp_r % size_random3];\n              break;\n\n            case 255 - (4 * 42):\n              *data = 255 - random_table4[this_temp_r % size_random4];\n              break;\n\n            case 255 - (5 * 42):\n              *data = 255 - random_table5[this_temp_r % size_random5];\n              break;\n\n            default:\n              fprintf(stderr, \"Bad magic %ui :(\\n\", *cell_color);\n              break;\n\n          }\n\n        }\n\n      }\n\n      *cell_color = ((((*cell_color) << 24) | ((*cell_color) << 16)) | ((*cell_color) << 8)) | ((*cell_color) << 0);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(array, array_temp, cell_colors, H, W, iRow) private (iCol)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kallus/Lattice-gas-automata/c_module/3"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n  C[i][j] = (((DATA_TYPE) i) * j) / ni;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gemm/gemm/1"}
{"code": "for (int i = 0; i < row1; i++)\n{\n  for (int j = 0; j < col2; j++)\n    (cout << c[i][j]) << \" \";\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/askarakhmetov/avks-openmp/second/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_kmp_set_disp_num_buffers())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/env/kmp_set_dispatch_buf/1"}
{"code": "for (i = k + 1; i < ROW; i++)\n{\n  revmat[i][k] = revmat[i][k] / revmat[k][k];\n  for (j = k + 1; j < ROW; j++)\n    revmat[i][j] = revmat[i][j] - (revmat[k][j] * revmat[i][k]);\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ching-Yee-Chan/openMP/arm/3"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    if (mapa[(i * cols) + j] > max)\n    {\n      max = mapa[(i * cols) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "parallel omp for reduction(max:max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cramer-0xbit/antenas-openmp/antenas/1"}
{"code": "for (int i = 0; i < d; i++)\n{\n  T->vp[i] = *(((X + n) - 1) + (i * n));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/vptree/src/vptree_openmp/2"}
{"code": "for (int i = 0; i < n; i++)\n  array[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kishkaru/OpenMP_Demos/OpenMP/dotp_critical/1"}
{"code": "for (iv = 1; iv <= alpha; iv += 64)\n{\n  beta = 64, gama = ((*n) - iv) + 1;\n  il = MIN(beta, gama);\n  if ((*idist) == 3)\n  {\n    il2 = il << 1;\n  }\n  else\n  {\n    il2 = il;\n  }\n\n  dlaruv_(&iseed[1], &il2, u);\n  if ((*idist) == 1)\n  {\n    beta = il;\n    for (val = 1; val <= beta; ++val)\n    {\n      x[(iv + val) - 1] = u[val - 1];\n    }\n\n  }\n  else\n    if ((*idist) == 2)\n  {\n    beta = il;\n    for (val = 1; val <= beta; ++val)\n    {\n      x[(iv + val) - 1] = (u[val - 1] * 2.) - 1.;\n    }\n\n  }\n  else\n    if ((*idist) == 3)\n  {\n    beta = il;\n    for (val = 1; val <= beta; ++val)\n    {\n      x[(iv + val) - 1] = sqrt(log(u[(val << 1) - 2]) * (-2.)) * cos(u[(val << 1) - 1] * 6.2831853071795864769252867663);\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/10"}
{"code": "for (ii = 0; ii < 5; ii++)\n{\n  for (jj = 0; jj < 5; jj++)\n  {\n    for (kk = 0; kk < 5; kk++)\n    {\n      tmp = (exp((float) kk) * exp((float) jj)) / exp((float) ii);\n      a[ii][jj][kk] = 9;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/OpenMP---Examples/openmp/example6/simple/0"}
{"code": "for (i = k + 1; i < m_size; i++)\n{\n  lArray[i][k] = aArray[i][k] / uArray[k][k];\n  uArray[k][i] = aArray[k][i];\n}\n\n", "pragma": "    #pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/8"}
{"code": "for (k = 0; k < 8; k++)\n  printf(\"%f \", r1[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB169-missingsyncwrite-orig-yes/2"}
{"code": "for (i = 0; i < niv; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    T[j].val = minmax_ab(T[j], -1, i, alpha, beta, nb_noeuds, nb_coupes);\n  }\n\n  trier_config_table(T, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/parallel_vs_parallel_iterative_deeepening/0"}
{"code": "for (i = 0; i < n_variable; i++)\n{\n  var[i] = (float *) malloc((n_variable + 1) * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/workout3/workout3/0"}
{"code": "for (int i = (N / 8) * 7; i < N; i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/18"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  free(str_arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/test/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  chromos[0][i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rachit95arora/travelling-salesman-openmp/src/main/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == dummyWall)\n  {\n    particleBC[i] = other;\n    continue;\n  }\n\n  if (pndSmall[i] < betaPnd)\n  {\n    particleBC[i] = surface;\n  }\n  else\n  {\n    particleBC[i] = inner;\n  }\n\n  if (freeSurfType == PND_NEIGH)\n  {\n    if ((pndSmall[i] < betaPnd) && (numNeigh[i] < betaNeigh))\n    {\n      particleBC[i] = surface;\n    }\n    else\n    {\n      particleBC[i] = inner;\n    }\n\n  }\n  else\n    if (freeSurfType == PND_NPCD)\n  {\n    if (particleBC[i] == surface)\n    {\n      if ((numNeigh[i] > 4) && (npcdDeviation2[i] < delta2))\n      {\n        particleBC[i] = inner;\n      }\n\n    }\n\n  }\n  else\n    if (freeSurfType == PND_ARC)\n  {\n    double normalXi = normal[i * 3];\n    double normalYi = normal[(i * 3) + 1];\n    double normalZi = normal[(i * 3) + 2];\n    double norm2 = ((normalXi * normalXi) + (normalYi * normalYi)) + (normalZi * normalZi);\n    if (((pndi[i] >= betaPnd) && (numNeigh[i] >= betaNeigh)) && (norm2 <= normThreshold2))\n    {\n      particleBC[i] = inner;\n    }\n    else\n    {\n      double posXi = pos[i * 3];\n      double posYi = pos[(i * 3) + 1];\n      double posZi = pos[(i * 3) + 2];\n      double posMirrorXi = mirrorParticlePos[i * 3];\n      double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n      double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n      if (norm2 > 1.0e-8)\n      {\n        double norm = sqrt(norm2);\n        normalXi /= norm;\n        normalYi /= norm;\n        normalZi /= norm;\n      }\n      else\n      {\n        normalXi = 0.0;\n        normalYi = 0.0;\n        normalZi = 0.0;\n      }\n\n      double Rref_i[9];\n      double normaliw[3];\n      double normalMod2;\n      normaliw[0] = 0.5 * (posXi - posMirrorXi);\n      normaliw[1] = 0.5 * (posYi - posMirrorYi);\n      normaliw[2] = 0.5 * (posZi - posMirrorZi);\n      normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n      if (normalMod2 > 1.0e-8)\n      {\n        double normalMod = sqrt(normalMod2);\n        normaliw[0] /= normalMod;\n        normaliw[1] /= normalMod;\n        normaliw[2] /= normalMod;\n      }\n      else\n      {\n        normaliw[0] = 0.0;\n        normaliw[1] = 0.0;\n        normaliw[2] = 0;\n      }\n\n      Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n      Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n      Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n      Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n      Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n      Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n      Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n      Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n      Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n      double normalMirrorXi = ((Rref_i[0] * normalXi) + (Rref_i[1] * normalYi)) + (Rref_i[2] * normalZi);\n      double normalMirrorYi = ((Rref_i[3] * normalXi) + (Rref_i[4] * normalYi)) + (Rref_i[5] * normalZi);\n      double normalMirrorZi = ((Rref_i[6] * normalXi) + (Rref_i[7] * normalYi)) + (Rref_i[8] * normalZi);\n      double normMirror2 = ((normalMirrorXi * normalMirrorXi) + (normalMirrorYi * normalMirrorYi)) + (normalMirrorZi * normalMirrorZi);\n      if (normMirror2 > 1.0e-8)\n      {\n        double normMirror = sqrt(normMirror2);\n        normalMirrorXi /= normMirror;\n        normalMirrorYi /= normMirror;\n        normalMirrorZi /= normMirror;\n      }\n      else\n      {\n        normalMirrorXi = 0.0;\n        normalMirrorYi = 0.0;\n        normalMirrorZi = 0.0;\n      }\n\n      int ix;\n      int iy;\n      int iz;\n      bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n      int minZ = (iz - 1) * ((int) (dim - 2.0));\n      int maxZ = (iz + 1) * ((int) (dim - 2.0));\n      for (int jz = minZ; jz <= maxZ; jz++)\n      {\n        for (int jy = iy - 1; jy <= (iy + 1); jy++)\n        {\n          for (int jx = ix - 1; jx <= (ix + 1); jx++)\n          {\n            int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n            int j = firstParticleInBucket[jb];\n            if (j == (-1))\n              continue;\n\n            double plx;\n            double ply;\n            double plz;\n            getPeriodicLengths(jb, plx, ply, plz);\n            while (true)\n            {\n              double v0ij;\n              double v1ij;\n              double v2ij;\n              double v0imj;\n              double v1imj;\n              double v2imj;\n              double dstij2;\n              double dstimj2;\n              sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n              sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n              if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n              {\n                if (j != i)\n                {\n                  double v0inj;\n                  double v1inj;\n                  double v2inj;\n                  double dstinj2;\n                  sqrDistBetweenParticles(j, posXi + (partDist * normalXi), posYi + (partDist * normalYi), posZi + (partDist * normalZi), v0inj, v1inj, v2inj, dstinj2, plx, ply, plz);\n                  double rijn = ((v0ij * normalXi) + (v1ij * normalYi)) + (v2ij * normalZi);\n                  double ang = acos(rijn / sqrt(dstij2));\n                  if ((dstij2 >= dstThreshold2) && (dstinj2 < hThreshold2))\n                  {\n                    particleBC[i] = inner;\n                    goto endloop;\n                  }\n                  else\n                    if ((dstij2 < dstThreshold2) && (ang < thetaArc))\n                  {\n                    particleBC[i] = inner;\n                    goto endloop;\n                  }\n                  else\n                  {\n                    particleBC[i] = surface;\n                  }\n\n\n                }\n\n              }\n\n              if (wallType == POLYGON)\n              {\n                if (((dstij2 < reS2) && (dstimj2 < reS2)) && (dstij2 < dstimj2))\n                {\n                  if (j != i)\n                  {\n                    double v0imnj;\n                    double v1imnj;\n                    double v2imnj;\n                    double dstimnj2;\n                    sqrDistBetweenParticles(j, posMirrorXi + (partDist * normalMirrorXi), posMirrorYi + (partDist * normalMirrorYi), posMirrorZi + (partDist * normalMirrorZi), v0imnj, v1imnj, v2imnj, dstimnj2, plx, ply, plz);\n                    double rimjn = ((v0imj * normalMirrorXi) + (v1imj * normalMirrorYi)) + (v2imj * normalMirrorZi);\n                    double angm = acos(rimjn / sqrt(dstimj2));\n                    if ((dstimj2 >= dstThreshold2) && (dstimnj2 < hThreshold2))\n                    {\n                      particleBC[i] = inner;\n                      goto endloop;\n                    }\n                    else\n                      if ((dstimj2 < dstThreshold2) && (angm < thetaArc))\n                    {\n                      particleBC[i] = inner;\n                      goto endloop;\n                    }\n                    else\n                    {\n                      particleBC[i] = surface;\n                    }\n\n\n                  }\n\n                }\n\n              }\n\n              j = nextParticleInSameBucket[j];\n              if (j == (-1))\n                break;\n\n            }\n\n          }\n\n        }\n\n      }\n\n      endloop:\n      ;\n\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/48"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < ((i + r) + 1); j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n  for (j = (n - r) + i; j < n; j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonisstou/Optimization-of-C-program-by-rearrange-computations-and-parallelization-with-openmp/i_lif1d_omp/2"}
{"code": "for (j = 1; j < (128 + 1); j++)\n{\n  mean[j] = 0.0;\n  for (i = 1; i < (128 + 1); i++)\n  {\n    mean[j] += data[(i * (128 + 1)) + j];\n  }\n\n  mean[j] /= (DATA_TYPE) 3214212.01f;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/25"}
{"code": "for (unsigned i = 0; i < width_local; i++)\n{\n  for (unsigned j = 0; j < height_local; j++)\n  {\n    uint32_t sum = 0;\n    for (unsigned k = 0; k < width_local; k++)\n      sum = sum + (a_local[(i * width_local) + k] * b_local[(k * width_local) + j]);\n\n    c_local[(i * width_local) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) firstprivate(a_local, b_local, c_local, width_local, height_local)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/mm-small/mm-small/3"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  int y = i + 1;\n  x = a[i] + g;\n}\n\n", "pragma": "omp parallel for private (x,i) firstprivate (g)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_private/0"}
{"code": "for (unsigned int i = 0; i < this->size; i++)\n{\n  getline(path_file_stream, line_in);\n  path = int_explode(\" \", line_in);\n  this->new_individuals.push_back(Individual(path));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/12"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    old_val = U_old[i][j];\n    U_old[i][j] = ((((U[i][j - 1] + U[i][j + 1]) + U[i - 1][j]) + U[i + 1][j]) + ((Delta * Delta) * F[i][j])) * one_fourth;\n    old_val -= U_old[i][j];\n    d += (old_val < 0) ? (-old_val) : (old_val);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/martinverup/OpenMP-Poisson-Problem/poisson/4"}
{"code": "for (i = 0; i < NumPart; i++)\n{\n  for (k = 0, r2 = 0; k < 3; k++)\n    r2 += P[i].Pos[k] * P[i].Pos[k];\n\n  P[i].Potential += fac * r2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/potential/5"}
{"code": "for (size_t i = 0; i < vertexNum; ++i)\n{\n  g[i].value = 0;\n  g[i].fixed_value = 0;\n  g[i].distance = -1;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gbossi/Pagerank-DOBFS/graph/0"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    {\n      printf(\"Computing loop 1 iteration %d %d\\n\", i, j);\n      a1[i][j] = 3.45;\n    }\n  }\n\n  for (int j = 2; j < 4; j++)\n  {\n    {\n      printf(\"Computing loop 2 iteration %d %d\\n\", i, j);\n      b1[i][j] = a1[i][j - 1] * 0.978;\n    }\n  }\n\n}\n\n", "pragma": "omp for ordered(1) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/7.doacross2/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  parallel_merge_sort1(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting(optimized) of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/4"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  for (k = 0; k < N; k++)\n    C[i][j] += A[i][k] * B[k][j];\n\n  if (C[i][j] != control[i][j])\n    flag++;\n\n}\n\n\n", "pragma": "omp for schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw4/matrix/0"}
{"code": "for (int l = 0; l < people_count; ++l)\n{\n  for (int i = 0; i < sample_count_per_person; ++i)\n  {\n    free(histogram_array[l][i]);\n    dealloc_2d_matrix(original_images[l][i], IMAGE_HEIGHT, IMAGE_WIDTH);\n  }\n\n  free(histogram_array[l]);\n  free(original_images[l]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/egebasturk/Parallel-Computing-Projects/Project3/cs426_project3_code/lbp_omp/5"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  errout[i] = (forpassout[i] * (1 - forpassout[i])) * (classes[training_sample][i] - forpassout[i]);\n}\n\n", "pragma": "omp for schedule(dynamic,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/4"}
{"code": "for (int l = 0; l < tmpfortxt.size(); l++)\n{\n  Usedimage[l] = tmpfortxt[l];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/84"}
{"code": "for (i = 0; i < rows; i++)\n{\n  free(A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zajaczek/Solving-linear-equations-using-the-Jacobi-method/parallel_linear_equation_solving/openmp/jacobi_openmp/3"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  douto[col] = outo[col] * (1 - outo[col]);\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/10"}
{"code": "for (col = 0; col < public.in2_sub_cols; col++)\n{\n  #pragma loop name kernel#8#0\n  for (row = 0; row < public.in2_sub_rows; row++)\n  {\n    ori_row = (row + public.in2_pad_cumv_sel_rowlow) - 1;\n    ori_col = (col + public.in2_pad_cumv_sel_collow) - 1;\n    temp = private.d_in2_pad[(ori_col * public.in2_pad_rows) + ori_row];\n    ori_row = (row + public.in2_pad_cumv_sel2_rowlow) - 1;\n    ori_col = (col + public.in2_pad_cumv_sel2_collow) - 1;\n    temp2 = private.d_in2_pad[(ori_col * public.in2_pad_rows) + ori_row];\n    private.d_in2_sub[(col * public.in2_sub_rows) + row] = temp - temp2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/9"}
{"code": "for (i = 0; i < m; i++)\n{\n  src[i] = permV[src[i]];\n  dest[i] = permV[dest[i]];\n  if ((i % size) == rank)\n    rank_m[rank] = (i / size) + 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rinriko/OpenMPI_SSCA2.2/genScalData/3"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  if (((visited[i] == NODE_UNVISITED) && (disFromStart[i] != UNKNOWN_DISTANCE)) && (disFromStart[i] < curClosestDistance))\n  {\n    curClosestNode = i;\n    curClosestDistance = disFromStart[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/0"}
{"code": "for (int i = 0; i < _vdwcalculations.size(); ++i)\n{\n  if (_cutoff)\n    if (!_vdwpairs.BitIsSet(i))\n    continue;\n\n\n  if (gradients)\n  {\n    AddGradient(_vdwcalculations[i].force_a, _vdwcalculations[i].idx_a);\n    AddGradient(_vdwcalculations[i].force_b, _vdwcalculations[i].idx_b);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/5"}
{"code": "for (int ci = 1; ci < NCELLS; ci++)\n{\n  for (int d = 0; d < NDIM; d++)\n  {\n    system_p[d] += cell(ci).momentum(d);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/93"}
{"code": "for (i = (12 * n) / 16; i < ((13 * n) / 16); i++)\n  U[i][i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/13"}
{"code": "for (i = 0; i < (no_filters - 1); i++)\n{\n  applyFilter(&input, &copy, argv[i + 3], 1, input.heigth - 1);\n  if (num_workers > 1)\n  {\n    if (rank == 1)\n    {\n      unsigned char *buff = preparePackage(&input, (end - start) - 1, end - start);\n      MPI_Ssend(buff, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, 1, 1);\n      free(buff);\n    }\n    else\n      if (rank < (nProcesses - 1))\n    {\n      unsigned char *buff = preparePackage(&input, 1, 2);\n      MPI_Ssend(buff, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, 0, 1);\n      free(buff);\n      buff = preparePackage(&input, (end - start) - 1, end - start);\n      MPI_Ssend(buff, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, 1, 1);\n      free(buff);\n    }\n    else\n      if (rank == (nProcesses - 1))\n    {\n      unsigned char *buff = preparePackage(&input, 1, 2);\n      MPI_Ssend(buff, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, 0, 1);\n      free(buff);\n    }\n\n\n\n    if (rank == 1)\n    {\n      MPI_Recv(buffer, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, -1, 1, (MPI_Status *) 1);\n      transfer_to_matrix(&input, buffer, end - start);\n    }\n    else\n      if (rank < (nProcesses - 1))\n    {\n      MPI_Status status;\n      for (int cnt = 0; cnt < 2; cnt++)\n      {\n        MPI_Recv(buffer, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, -1, 1, &status);\n        if (status.MPI_TAG == 0)\n          transfer_to_matrix(&input, buffer, 0);\n        else\n          transfer_to_matrix(&input, buffer, end - start);\n\n      }\n\n    }\n    else\n      if (rank == (nProcesses - 1))\n    {\n      MPI_Recv(buffer, dimensiune_line, (MPI_Datatype) 0x4c000102, 0, -1, 1, (MPI_Status *) 1);\n      transfer_to_matrix(&input, buffer, 0);\n    }\n\n\n\n    MPI_Barrier(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/23"}
{"code": "for (t = 0; t < _PB_TMAX; t++)\n{\n  kernelP_fdtd_2d0(tmax, nx, ny, t, ex, _fict_);\n  kernelP_fdtd_2d1(tmax, nx, ny, ex, ey, hz, _fict_);\n  kernelP_fdtd_2d2(tmax, nx, ny, ex, ey, hz, _fict_);\n  kernelP_fdtd_2d3(tmax, nx, ny, ex, ey, hz, _fict_);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/fdtd-2d/fdtd-2d/6"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  divideImageDataWithParam(src.data(), width, dst.data(), width, size, PARAM, true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/10"}
{"code": "for (i = 0; i < population_size; i++)\n  free(new_generation[i].person);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/11"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (a[i] != ah[i])\n  {\n    err = true;\n    printf(\"Error at %d, host = %lf, device = %lf\\n\", i, ah[i], a[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-target-nowait-dep-implicit/test/3"}
{"code": "for (int i = 0; i < arrayLength; ++i)\n{\n  printf(\"%d\\n\", pIntArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivaneduardomv/OpenMPTest/ompBubble1/2"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < this->numThreads; codeletCounter++)\n{\n  *checkInCodelets1336Ptr = _checkInCodelets1336(1, 1, this, codeletCounter);\n  checkInCodelets1336Ptr++;\n  *checkInCodelets1332Ptr = _checkInCodelets1332(1, 1, this, codeletCounter);\n  checkInCodelets1332Ptr++;\n  *checkInCodelets1331Ptr = _checkInCodelets1331(2, 1, this, codeletCounter);\n  (*checkInCodelets1331Ptr).decDep();\n  checkInCodelets1331Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/57"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  (((((((((cout << \"CELLP\\t\") << \": NV = \") << cell(ci).getNV()) << setw(6)) << \"; cx = \") << cell(ci).cpos(0)) << setw(6)) << \"; cy = \") << cell(ci).cpos(1)) << endl;\n  for (vi = 0; vi < cell(ci).getNV(); vi++)\n  {\n    cout << \"VERTP\\t\";\n    (cout << cell(ci).vpos(vi, 0)) << \"; \";\n    (cout << cell(ci).vpos(vi, 1)) << \"; \";\n    (cout << cell(ci).vvel(vi, 0)) << \"; \";\n    (cout << cell(ci).vvel(vi, 1)) << \"; \";\n    (cout << cell(ci).vforce(vi, 0)) << \"; \";\n    cout << cell(ci).vforce(vi, 1);\n    cout << endl;\n  }\n\n  ((cout << endl) << endl) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/7"}
{"code": "for (long i = 0; i < (n * n); i++)\n{\n  (*ResM)[i] = (*M1)[i] + (*M2)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/strassen_mul_1d_omp/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  if ((buffer[i] != ' ') && (buffer[i] != '\\n'))\n  {\n    c[k] = buffer[i];\n    k++;\n  }\n  else\n  {\n    x = atof(c);\n    if ((x >= 12) && (x <= 30))\n      count2++;\n\n    count1++;\n    k = 0;\n  }\n\n}\n\n", "pragma": "omp nowait parallel for firstprivate(size) reduction(+:count1) reduction(+:count2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anoulis/OpenMP-and-OpenMPI/examineOPENMP/0"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    smats[color[j]]->rowptr[i]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/24"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    X[i][j] = val;\n    X[j][i] = 0.0;\n  }\n\n  X[i][i] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/triangular_matrix/triangular_matrix/2"}
{"code": "for (int i = 0; i < RUNLENGTH; i += 2)\n{\n  double v1;\n  double v2;\n  double u1;\n  double u2;\n  double g1;\n  double g2;\n  double w;\n  do\n  {\n    drand48_r(&state, &u1);\n    drand48_r(&state, &u2);\n    v1 = (u1 * 2) - 1;\n    v2 = (u2 * 2) - 1;\n    w = (v1 * v1) + (v2 * v2);\n  }\n  while ((w >= 1.0) || (w == 0.0));\n  double sq = sqrt(((-2.0) * log(w)) / w);\n  g1 = v1 * sq;\n  g2 = v2 * sq;\n  numObs++;\n  sum += (g1 * sigma) + mu;\n  sumSquares += ((g1 * sigma) + mu) * ((g1 * sigma) + mu);\n  numObs++;\n  sum += (g2 * sigma) + mu;\n  sumSquares += ((g2 * sigma) + mu) * ((g2 * sigma) + mu);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: sum, sumSquares, numObs)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZacharyZampa/GaussianDistributionGenerator/marsaglia_omp/0"}
{"code": "for (int i = 0; i < A.Rows; i++)\n{\n  for (int j = 0; j < BT.Cols; j++)\n  {\n    float sum = 0.0f;\n    for (int k = 0; k < A.Cols; k++)\n    {\n      sum += arrayA[i][k] * arrayBT[j][k];\n    }\n\n    arrayC[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haniyeka/Parallel-Programming/Assignment3/Prob3/Prob3/Parallel/3"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  printf(\"\\tgreetings from thread num %d\\n\", my_thread_id);\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_regions/05b_order_of_threads/0"}
{"code": "for (int j = 0; j < 2; j++)\n{\n  diff[i][j] = a[i][j] - b[i][j];\n}\n\n", "pragma": "omp parallel for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Matrix_addition_and_subtraction/3"}
{"code": "for (int idx = 0; idx <= i; idx++)\n{\n  int index = ((((((max_cols - idx) - 2) * max_cols) + idx) + max_cols) - i) - 2;\n  input_itemsets[index] = maximum(input_itemsets[(index - 1) - max_cols] + referrence[index], input_itemsets[index - 1] - penalty, input_itemsets[index - max_cols] - penalty);\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/1"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    u[i3][n2 - 1][i1] = u[i3][1][i1];\n    u[i3][0][i1] = u[i3][n2 - 2][i1];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/8"}
{"code": "for (int i = 0; i < len; i++)\n{\n  vector[i] = (5.0 * rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/16"}
{"code": "for (i = 0; i < 64; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 7; j++)\n    for (k = 0; k < 15; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/omp_mm/2"}
{"code": "for (i = 0; i < strp_sent; i++)\n{\n  MPI_Recv(&cc1, strp_rows * ncols, (MPI_Datatype) 0x4c00080b, -2, -1, 1, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/3"}
{"code": "for (size_t i = 0; i < output_size; i++)\n  checksum += value[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/contract-omp/main/4"}
{"code": "for (int row = start; row < end; row++)\n{\n  for (int col = 0; col < columns; col++)\n  {\n    double value = dataset->at(row)->getFeatures()->at(col);\n    if (std->at(col) != 0)\n    {\n      value -= mean->at(col);\n      value /= std->at(col);\n    }\n\n    result[i + col] = value;\n  }\n\n  i += columns;\n  result[i] = dataset->at(row)->getLabel();\n  i++;\n}\n\n", "pragma": "    #pragma omp parallel for shared(mean, std, columns, dataset, result, i)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-Hybrid-OpenMP-MPI/MPI:OpenMP/StandardScaler/2"}
{"code": "for (unsigned int s = blockDim.x / 2; s > 0; s >>= 1)\n{\n  if (tid < s)\n  {\n    if (maxData[tid] < maxData[tid + s])\n      maxData[tid] = maxData[tid + s];\n\n  }\n\n  __syncthreads();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/amplifier XE&schedule/Lab-1-1/0"}
{"code": "for (j = 2; j < (n - 2); j += tile_size)\n{\n  for (i = 2; i < (n - 2); i += tile_size)\n  {\n    for (jt = j; jt < MIN(n - 2, j + tile_size); jt++)\n    {\n      for (it = i; it < MIN(n - 2, i + tile_size); it++)\n      {\n        for (jj = -2; jj <= 2; jj++)\n          out[it + (jt * n)] += weight[0 + 2][jj + 2] * in[it + ((jt + jj) * n)];\n\n        for (ii = -2; ii < 0; ii++)\n          out[it + (jt * n)] += weight[ii + 2][0 + 2] * in[(it + ii) + (jt * n)];\n\n        for (ii = 1; ii <= 2; ii++)\n          out[it + (jt * n)] += weight[ii + 2][0 + 2] * in[(it + ii) + (jt * n)];\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/Stencil/stencil/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  population[i].mutate(mutationRate);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krris/openmp-evolutionary-algorithm/src/Population/3"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  for (j = 0; j < 10; ++j)\n  {\n    for (k = 0; k < 10; ++k)\n      x[i][j][k] = k;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr56883/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = rand() / ((float) 32767);\n  y[i] = rand() / ((float) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PurplePachyderm/openmp-gputool/tests/0"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  for (int i = 0; i < 1000000; i++)\n  {\n    randomnumber = rand() % 6;\n    dnabig[i] = dna[randomnumber];\n  }\n\n  replacecharacters(dnabig);\n  countA(dnabig);\n  end = clock();\n  total_time = ((double) (end - start)) / CLOCKS_PER_SEC;\n  nDynamic1[j] = total_time;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/2"}
{"code": "for (i2 = 1; i2 <= (mm2 - 1); i2++)\n{\n  for (i1 = d1; i1 <= (mm1 - 1); i1++)\n  {\n    ou[((((((2 * i3) - t3) - 1) * n2) * n1) + ((((2 * i2) - t2) - 1) * n1)) + (((2 * i1) - d1) - 1)] = ou[((((((2 * i3) - t3) - 1) * n2) * n1) + ((((2 * i2) - t2) - 1) * n1)) + (((2 * i1) - d1) - 1)] + (0.25 * (((oz[(((i3 * mm2) * mm1) + (i2 * mm1)) + (i1 - 1)] + oz[(((i3 * mm2) * mm1) + ((i2 - 1) * mm1)) + (i1 - 1)]) + oz[((((i3 - 1) * mm2) * mm1) + (i2 * mm1)) + (i1 - 1)]) + oz[((((i3 - 1) * mm2) * mm1) + ((i2 - 1) * mm1)) + (i1 - 1)]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i2,i1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/15"}
{"code": "for (i = 1; i < (2048 + 1); i++)\n{\n  for (j = 1; j < (2048 + 1); j++)\n  {\n    if (percentDiff(symmat[(i * (2048 + 1)) + j], symmat_outputFromOmp[(i * (2048 + 1)) + j]) > 1.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/COVAR/covariance/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  int32_t current_node = Shortest_Distance_Node(Node_Shortest_Dist, Completed_Node);\n  Completed_Node[current_node] = 1;\n  for (j = 0; j < 1000; j++)\n  {\n    uint32_t new_distance = Node_Shortest_Dist[current_node] + Graph[(current_node * 1000) + j];\n    if (((Completed_Node[j] != 1) && (Graph[(current_node * 1000) + j] != ((float) 0))) && (new_distance < Node_Shortest_Dist[j]))\n    {\n      Node_Shortest_Dist[j] = new_distance;\n      Parent_Node[j] = current_node;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VishalVishnani/CUDA-pthread-openMP-implementation-of-Graph-Algorithms/Dijkstra/7"}
{"code": "for (i = 0; i < 16; ++i)\n  printf(\"all for - thread = %d, i = %d\\n\", tid, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/examples/src/openmp_tutorial/1"}
{"code": "for (float v = (n * a) * 2; v_element_count < 16; v_element_count++, v += 1)\n{\n  tmp_vec[0][v_element_count] = v;\n  tmp_vec[1][v_element_count] = 0.0;\n  tmp_vec[2][v_element_count] = 0.0;\n  tmp_vec[3][v_element_count] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/elect_energy_avx512/2"}
{"code": "for (uint32_t i = 0; i < rows; i++)\n{\n  for (uint32_t j = 0; j < rows; j++)\n  {\n    idStartCol = csrA.pointer[i];\n    idEndCol = csrA.pointer[i + 1];\n    if (idStartCol == idEndCol)\n    {\n      break;\n    }\n\n    idStartRow = cscB.pointer[j];\n    idEndRow = cscB.pointer[j + 1];\n    bool isCommon = hasCommon(csrA.indices.begin() + idStartCol, csrA.indices.begin() + idEndCol, cscB.indices.begin() + idStartRow, cscB.indices.begin() + idEndRow);\n    if (isCommon)\n    {\n      mulResult.indices.push_back(j);\n      nnz++;\n    }\n\n  }\n\n  mulResult.pointer[i + 1] = nnz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thodkatz/sparse-bmm/src/spgemm/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/64"}
{"code": "for (long K = coloradj1; K < coloradj2; K++)\n{\n  distExecuteLouvainIteration(colorIndex[K], dg, currComm, targetComm, vDegree, localCinfo, localCupdate, remoteComm, remoteCinfo, remoteCupdate, constantForSecondTerm, clusterWeight, me);\n}\n\n", "pragma": "#pragma omp parallel for shared(clusterWeight, localCupdate, currComm, targetComm, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/3"}
{"code": "for (i = 0; i <= (d[0] - 1); i += 1)\n{\n  y0[i][j].real = x[k][j + jj][i].real;\n  y0[i][j].imag = x[k][j + jj][i].imag;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpnxca05ew.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MJChku/openmp_source/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (phase = 0; phase < n; phase++)\n{\n  if ((phase % 2) == 0)\n  {\n    for (i = 1; i < n; i += 2)\n    {\n      if (a_valor[i - 1][i - 1] < a_valor[i][i])\n      {\n        temp = a_valor[i][i];\n        a_valor[i][i] = a_valor[i - 1][i - 1];\n        a_valor[i - 1][i - 1] = temp;\n        for (j = 0; j < n; j++)\n        {\n          temp2 = a_vetor[j][i];\n          a_vetor[j][i] = a_vetor[j][i - 1];\n          a_vetor[j][i - 1] = temp2;\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    for (i = 1; i < (n - 1); i += 2)\n    {\n      if (a_valor[i][i] < a_valor[i + 1][i + 1])\n      {\n        temp = a_valor[i][i];\n        a_valor[i][i] = a_valor[i + 1][i + 1];\n        a_valor[i + 1][i + 1] = temp;\n        for (j = 0; j < n; j++)\n        {\n          temp2 = a_vetor[j][i];\n          a_vetor[j][i] = a_vetor[j][i + 1];\n          a_vetor[j][i + 1] = temp2;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex7alves/PCA_OpenMP/pca/0"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  ibox.emplace_back(bm.getBounds()[i].first, bm.getBounds()[i].second);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AGorchakov/BNB_test_prelimited/bnb_test_prelim/1"}
{"code": "for (iterator it = children.begin(); it != children.end(); it++)\n{\n  walk(*it);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/core/tl-omp-core/2"}
{"code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  n = n / mx;\n  m = part[1 + (idimp * j)];\n  m = m / my;\n  l = part[2 + (idimp * j)];\n  l = l / mz;\n  m = (n + (mx1 * m)) + (mxy1 * l);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[ip + (nppmx * (i + (idimp * m)))] = part[i + (idimp * j)];\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/48"}
{"code": "for (i = 0; i < table_size; i++)\n{\n  v[i] = rand_r(&myseed) % maxValue;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Wicz3k/MPR_OpenMP/zad_1/main/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  sum_a += a[i];\n  sum_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum_a, sum_b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LiyaSharipova/OpenMP-Tasks/task6/0"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"a[%d] = %d\\n\", i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/1/shared-clause/2"}
{"code": "for (int i = 0; i < control; ++i)\n{\n  int *p = control_knn[i];\n  for (int j = 0; j < K; ++j)\n  {\n    p[j] = knns[i][j].key;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyandai/nndes/fvecsnndes/2"}
{"code": "for (wJ = wI; wJ < (wI + (SMALLN / 4)); wJ++)\n{\n  aVect2[wJ] = aVect1[wJ] * aScalaire;\n}\n\n", "pragma": "omp parallel for firstprivate(wI) private(wJ)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vects/3"}
{"code": "for (int iterations = 0; iterations < NUM_ITERATIONS; iterations++)\n{\n  alpha = 0.0;\n  for (int i = 0; i < NMAX; i++)\n  {\n    alpha += a[i] * b[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment3/dotProduct/dotProduct/1"}
{"code": "for (int xy = myrank; xy < (width * height); xy += nprocs)\n{\n  int x = xy % width;\n  int y = xy / width;\n  pixel_t pixel;\n  if (detect_edge(sketch, &pixel, x, y))\n  {\n    pixel_t average = pixel;\n    int m = 1;\n    int n = 0x01 << 4;\n    int sum_r = pixel_get_r(pixel);\n    int sum_g = pixel_get_g(pixel);\n    int sum_b = pixel_get_b(pixel);\n    do\n    {\n      pixel = average;\n      for (int k = m; k < n; k++)\n      {\n        double p_r = c_r + (d * ((x + dx[k]) - (width / 2)));\n        double p_i = c_i + (d * ((height / 2) - (y + dy[k])));\n        int iter = mandelbrot(iter_max, p_r, p_i);\n        sum_r += pixel_get_r(colormap[iter & iter_mask]);\n        sum_g += pixel_get_g(colormap[iter & iter_mask]);\n        sum_b += pixel_get_b(colormap[iter & iter_mask]);\n      }\n\n      average = pixel_set_rgb((int) round(((double) sum_r) / n), (int) round(((double) sum_g) / n), (int) round(((double) sum_b) / n));\n    }\n    while ((!equivalent_color(average, pixel)) && ((n = (m = n) << 0x01) <= (0x01 << 16)));\n    pixel = average;\n  }\n\n  pixmap_put_pixel(image, pixel, x, y);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/05.adaptive_antialiasing/02.cpu_vector/mandelbrot/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (frontier_level[i] == 0)\n  {\n    for (int j = index_into_adjacency_array[i]; j < index_into_adjacency_array[i + 1]; j++)\n    {\n      int parent = adjacency_array[j];\n      if (frontier_level[parent] == level)\n      {\n        node_parent[i] = parent;\n        frontier_level[i] = level + 1;\n        local_count++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : local_count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/15"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->fvsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->ivsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/32"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"%d  \", MeuArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/array_openmp/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == fluid)\n  {\n    gradConcentration[i * 3] = 0.0;\n    gradConcentration[(i * 3) + 1] = 0.0;\n    gradConcentration[(i * 3) + 2] = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double duXi = 0.0;\n    double duYi = 0.0;\n    double duZi = 0.0;\n    double conc_i = concentration[i];\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                gradConcentration[i * 3] += (((conc_i + concentration[j]) * v0ij) * wS) / dstij2;\n                gradConcentration[(i * 3) + 1] += (((conc_i + concentration[j]) * v1ij) * wS) / dstij2;\n                gradConcentration[(i * 3) + 2] += (((conc_i + concentration[j]) * v2ij) * wS) / dstij2;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    gradConcentration[3 * i] *= -coeffPressGrad;\n    gradConcentration[(3 * i) + 1] *= -coeffPressGrad;\n    gradConcentration[(3 * i) + 2] *= -coeffPressGrad;\n    if (particleBC[i] == inner)\n    {\n      pos[i * 3] -= coeffShifting2 * gradConcentration[3 * i];\n      pos[(i * 3) + 1] -= coeffShifting2 * gradConcentration[(3 * i) + 1];\n      pos[(i * 3) + 2] -= coeffShifting2 * gradConcentration[(3 * i) + 2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/90"}
{"code": "for (int i = 0; i < nrow; i++)\n{\n  if (y(i, 1) == 1.0)\n  {\n    sumTrt = sumTrt + (y(i, 0) / y(i, 2));\n    sumTrtWt = sumTrtWt + (1 / y(i, 2));\n  }\n  else\n  {\n    sumUntrt = sumUntrt + (y(i, 0) / (1 - y(i, 2)));\n    sumUntrtWt = sumUntrtWt + (1 / (1 - y(i, 2)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjnsteven/wb_openmp/splitc/8"}
{"code": "for (uint32_t i = 0; i < nPoints; i++)\n{\n  double xPart = pointX[i] - 0.5;\n  xPart = xPart * xPart;\n  double yPart = pointY[i] - 0.5;\n  yPart = yPart * yPart;\n  double xyDependentPart = xPart + yPart;\n  result[i] = 1 - xyDependentPart;\n  result[i] += get5HundredthsRandom();\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogether/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  index[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leaferm/OMP/main/6"}
{"code": "for (i = 0, j = 0; i < n; i = i + blockSize, j++)\n{\n  if (j == num)\n  {\n    for (l = 0; l < (n % blockSize); l++)\n    {\n      subarrays[j][l] = a[i + l];\n    }\n\n  }\n  else\n  {\n    for (l = 0; l < blockSize; l++)\n    {\n      subarrays[j][l] = a[i + l];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/med/1"}
{"code": "for (i = 0; i < id; i++)\n{\n  x += temp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/himanshudhawale/PrefixSum-OpenMP-Loop/prefixsum/0"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (argv[i][0] == '-')\n  {\n    flag = argv[i][1];\n    switch (flag)\n    {\n      case 'r':\n        i++;\n        *r = atoi(argv[i]);\n        break;\n\n      case 'l':\n        if (argv[i][2] == 'a')\n      {\n        *lat = atof(argv[i + 1]);\n      }\n      else\n      {\n        *lng = atof(argv[i + 1]);\n      }\n\n        i++;\n        break;\n\n      case 'h':\n        return 1;\n\n      case 'q':\n        *q = 1;\n        break;\n\n      case 't':\n        *t = 1;\n        break;\n\n      case 'p':\n        i++;\n        *p = atoi(argv[i]);\n        break;\n\n      case 'd':\n        i++;\n        *d = atoi(argv[i]);\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/nn/nn_omp/6"}
{"code": "for (col = 0; col < 1000; col++)\n{\n  *(current + col) = 100;\n  *(next + col) = 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShaunJorstad/Hybrid-parallelized-thermal-conduction/jacobiHybrid/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  i += mm;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/variables/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  result += vx_data[i] * vy_data[i];\n}\n\n", "pragma": "omp parallel for shared(N,vx_data,vy_data) private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uscheedella/Image-Interpolation/labs/lab07/code/vector/3"}
{"code": "for (unsigned int i = 0; i < size; i++)\n{\n  sum[id] += A[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NDaghboudj/Learn-OpenMP/01-Basics/omp_ex_23/0"}
{"code": "for (it = kpt_list.begin(); it != kpt_list.end(); it++)\n{\n  cR = (int) it->scale;\n  if (cR <= 1)\n  {\n    cR = 1;\n  }\n\n  r = (int) it->r;\n  c = (int) it->c;\n  rasterCircle(&imgPPM, r, c, cR);\n  rasterCircle(&imgPPM, r, c, cR + 1);\n  float ori = it->ori;\n  draw_red_orientation(&imgPPM, c, r, ori, cR);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/image_utility/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int j = lrand48() % (n - i);\n  int k = shuffle[j];\n  shuffle[j] = shuffle[(n - i) - 1];\n  p[i].x = (size * (1. + (k % sx))) / (1 + sx);\n  p[i].y = (size * (1. + (k / sx))) / (1 + sy);\n  p[i].vx = (drand48() * 2) - 1;\n  p[i].vy = (drand48() * 2) - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/urmilas239/Openmp/common/13"}
{"code": "for (ei = start_edge; ei < end_edge; ++ei)\n{\n  mrg_state new_state = state;\n  mrg_skip(&new_state, 0, ei, 0);\n  make_one_edge(nverts, 0, logN, &new_state, edges + (ei - start_edge), val0, val1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/generator/graph_generator/0"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  u_data->received_first_message = 0;\n  if (u_data->fragment_id != u->label)\n    continue;\n\n  message m = {-1};\n  enqueue(msgs, u->label, &m);\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (rand() < (.1 * RAND_MAX))\n      townSets[i][j] = true;\n    else\n      townSets[i][j] = false;\n\n  }\n\n  townSets[i][i] = true;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/4"}
{"code": "for (i = 0; i < 1200; i++)\n{\n  for (j = 0; j < 1200; j++)\n  {\n    int k;\n    for (k = 0; k < 1200; k++)\n    {\n      D[(i * 1200) + j] += (12435 * A[(i * 1200) + k]) * A[(j * 1200) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYRK/syrk/12"}
{"code": "for (int ii = HALO_PAD; ii < (z - HALO_PAD); ++ii)\n{\n  for (int jj = (y - HALO_PAD) - depth; jj < (y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - ((y - HALO_PAD) - depth)) * _chunk.innerX)) + (((ii - HALO_PAD) * depth) * _chunk.innerX);\n      buffer[bufIndex] = field[(((ii * y) * x) + (jj * x)) + kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/2"}
{"code": "for (i = i2; i < (((i2 + 256) < len) ? (i2 + 256) : (len)); i++)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp parallel for private(i) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB097-target-teams-distribute-orig-no/1"}
{"code": "for (int i = 0; i < r; i++)\n  sum += a[(row * r) + i] * b[(i * m) + col];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/0"}
{"code": "for (a = 0; a < ROWSIZE; a++)\n{\n  for (b = 0; b < COLSIZE; b++)\n  {\n    for (c = 0; c < ROWSIZE; c++)\n    {\n      pC(a, b) += pA(a, c) * pB(c, b);\n    }\n\n  }\n\n}\n\n", "pragma": "omp teams distribute parallel for collapse(2) private(a,b,c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/SREC_workshop/ex3_mpi_mm_gpu_omp/gpuoffload/3"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    if ((((i == 0) || (j == 0)) || (i == (nx - 1))) || (j == (ny - 1)))\n    {\n      unew[i][j] = f[i][j];\n    }\n    else\n    {\n      unew[i][j] = 0.25 * ((((u[i - 1][j] + u[i][j + 1]) + u[i][j - 1]) + u[i + 1][j]) + ((f[i][j] * dx) * dy));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/poisson/1"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = u[i][j][k][2];\n      u31 = u[i][j][k][2] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = u[i][j][k][1] * u31;\n      flux[i][j][k][2] = (u[i][j][k][2] * u31) + (C2 * (u[i][j][k][4] - q));\n      flux[i][j][k][3] = u[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/17"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + (((vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]);\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - (vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_cell/0"}
{"code": "for (i = 0; i < 1200; i++)\n{\n  for (j = 0; j < 1200; j++)\n  {\n    C[(i * 1200) + j] *= 4546;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/12"}
{"code": "for (int x = 0; x < W; ++x)\n  for (int y = 0; y < W; ++y)\n{\n  kernel[x][y] = exp((-0.5) * (pow((x - mean) / sigma, 2.0) + pow((y - mean) / sigma, 2.0))) / (((2 * M_PI) * sigma) * sigma);\n  sum += kernel[x][y];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/0"}
{"code": "for (int i = 0; i < dataset->n; i++)\n{\n  for (int j = 0; j < dataset->n; j++)\n  {\n    dataset->A[i][j] = (unsigned short *) malloc((sizeof(unsigned short)) * dataset->n);\n    dataset->B[i][j] = (unsigned short *) malloc((sizeof(unsigned short)) * dataset->n);\n    dataset->C[i][j] = (unsigned short *) malloc((sizeof(unsigned short)) * dataset->n);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW3/3DMatMul/2"}
{"code": "for (int i = 0; i < npoint; i++)\n{\n  states[i] = seed ^ i;\n  LCG_random_init(&states[i]);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(NTHR_PER_BLK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vmc-omp/vmc/0"}
{"code": "for (j = 0; j < innerreps; j++)\n{\n  delay(delaylength);\n  aaaa += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/benchs/EPCC/syncbench/3"}
{"code": "for (c2 = (nk > nl) ? (nk) : (nl); c2 <= (nm + (-1)); c2++)\n{\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/49"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  b[i] = i;\n  c[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vishal-subbu/OpenMP/mat_vec/1"}
{"code": "for (j = 0; j < 2048; j += BLOCK_SIZE[bb])\n{\n  for (i = 0; i < 2048; ++i)\n  {\n    for (jj = j; jj < min(j + BLOCK_SIZE[bb], 2048); ++jj)\n    {\n      for (kk = k; kk < min(k + BLOCK_SIZE[bb], 2048); ++kk)\n      {\n        C[i][jj] += A[i][kk] * B[kk][jj];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/magiciiboy/openmp-matmul/Block matrix multiplication/block_mm/1"}
{"code": "for (int i = 0; i < file1_numRows; i++)\n{\n  for (int j = 0; j < file2_numCols; j++)\n  {\n    {\n      {\n        int intVal_ij = 0;\n        long double floatVal_ij = 0.0;\n        for (int m = 0; m < file1_totalNonzeros; m++)\n        {\n          for (int n = 0; n < file2_totalNonzeros; n++)\n          {\n            {\n              if ((aRow[m] == i) && ((b + n)->colind == j))\n              {\n                if (aCol[m] == (b + n)->rowind)\n                {\n                  if (file_inttype)\n                    intVal_ij += aintVal[m] * (b + n)->intval;\n\n                  if (file_floattype)\n                    floatVal_ij += afloatVal[m] * (b + n)->floatval;\n\n                }\n\n              }\n\n            }\n          }\n\n        }\n\n        {\n          if (file_inttype)\n            fprintf(fp, \"%d \", intVal_ij);\n\n          if (file_inttype && (!required_logging))\n            printf(\"%d \", intVal_ij);\n\n          if (file_floattype)\n          {\n            if (floatVal_ij == 0.0)\n            {\n              fprintf(fp, \"%d. \", 0);\n              if (!required_logging)\n                printf(\"%d. \", 0);\n\n            }\n            else\n            {\n              truncateNrounding(floatVal_ij, fp);\n            }\n\n          }\n\n        }\n      }\n    }\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VumGualnam/2019S2_C_I_T_S_3_4_0_2__HPC_Project1/matrixMultiplier/0"}
{"code": "for (j = 0; j < miplaneta.size(); j++)\n{\n  distanciaPl = sqrt(pow(miasteroide[i].x - miplaneta[j].x, 2) + pow(miasteroide[i].y - miplaneta[j].y, 2));\n  pendientePl = (miasteroide[i].y - miplaneta[j].y) / (miasteroide[i].x - miplaneta[j].x);\n  if ((pendientePl >= 1) || (pendientePl <= (-1)))\n  {\n    pendientePl = pendientePl - trunc(pendientePl);\n  }\n\n  anguloPl = atan(pendientePl);\n  fuerza = ((gravity * miasteroide[i].masa) * miplaneta[j].masa) / pow(distanciaPl, 2);\n  if (fuerza > 200)\n  {\n    fuerza = 200;\n  }\n\n  fuerzaxp[i][j] = fuerza * cos(anguloPl);\n  fuerzayp[i][j] = fuerza * sin(anguloPl);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(i,miasteroide,miplaneta,fuerzaxp,fuerzayp) private(j,fuerza,distanciaPl,pendientePl,anguloPl)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JaimeGarcia17/Asteroides/par/nasteroids-par/4"}
{"code": "for (i = 0; i < 256; i++)\n{\n  if (percentDiff(y[i], y_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/14"}
{"code": "for (int ai = 0; ai < this->nnz_; ++ai)\n{\n  this->mat_.val[ai] *= alpha;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/56"}
{"code": "for (int i = 1; i < np; ++i)\n{\n  MPI_Send(&pixel_value_min, 1, MPI_DOUBLE, i, i + 200, MPI_COMM_WORLD);\n  MPI_Send(&pixel_value_max, 1, MPI_DOUBLE, i, i + 210, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jianxuecn/cccourse-examples/src/sobel_mpi_omp/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 3; k <= (grid_points[2] - 4); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/74"}
{"code": "for (int j = 0; j < (nprocs_mpi * Q); j++)\n{\n  TT[fila][col] = T[j];\n  if (col == (Q - 1))\n  {\n    fila += 1;\n    col = 0;\n  }\n  else\n  {\n    col += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/54"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (k = 0; k < nz; k++)\n    {\n      flux[k][0] = rsd[k][j][i][3];\n      u41 = rsd[k][j][i][3] / rsd[k][j][i][0];\n      q = (0.50 * (((rsd[k][j][i][1] * rsd[k][j][i][1]) + (rsd[k][j][i][2] * rsd[k][j][i][2])) + (rsd[k][j][i][3] * rsd[k][j][i][3]))) / rsd[k][j][i][0];\n      flux[k][1] = rsd[k][j][i][1] * u41;\n      flux[k][2] = rsd[k][j][i][2] * u41;\n      flux[k][3] = (rsd[k][j][i][3] * u41) + (C2 * (rsd[k][j][i][4] - q));\n      flux[k][4] = ((C1 * rsd[k][j][i][4]) - (C2 * q)) * u41;\n    }\n\n    for (k = 1; k < (nz - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (tz2 * (flux[k + 1][m] - flux[k - 1][m]));\n      }\n\n    }\n\n    for (k = 1; k < nz; k++)\n    {\n      tmp = 1.0 / rsd[k][j][i][0];\n      u21k = tmp * rsd[k][j][i][1];\n      u31k = tmp * rsd[k][j][i][2];\n      u41k = tmp * rsd[k][j][i][3];\n      u51k = tmp * rsd[k][j][i][4];\n      tmp = 1.0 / rsd[k - 1][j][i][0];\n      u21km1 = tmp * rsd[k - 1][j][i][1];\n      u31km1 = tmp * rsd[k - 1][j][i][2];\n      u41km1 = tmp * rsd[k - 1][j][i][3];\n      u51km1 = tmp * rsd[k - 1][j][i][4];\n      flux[k][1] = tz3 * (u21k - u21km1);\n      flux[k][2] = tz3 * (u31k - u31km1);\n      flux[k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n    }\n\n    for (k = 1; k < (nz - 1); k++)\n    {\n      frct[k][j][i][0] = frct[k][j][i][0] + ((dz1 * tz1) * ((rsd[k + 1][j][i][0] - (2.0 * rsd[k][j][i][0])) + rsd[k - 1][j][i][0]));\n      frct[k][j][i][1] = (frct[k][j][i][1] + (((tz3 * C3) * C4) * (flux[k + 1][1] - flux[k][1]))) + ((dz2 * tz1) * ((rsd[k + 1][j][i][1] - (2.0 * rsd[k][j][i][1])) + rsd[k - 1][j][i][1]));\n      frct[k][j][i][2] = (frct[k][j][i][2] + (((tz3 * C3) * C4) * (flux[k + 1][2] - flux[k][2]))) + ((dz3 * tz1) * ((rsd[k + 1][j][i][2] - (2.0 * rsd[k][j][i][2])) + rsd[k - 1][j][i][2]));\n      frct[k][j][i][3] = (frct[k][j][i][3] + (((tz3 * C3) * C4) * (flux[k + 1][3] - flux[k][3]))) + ((dz4 * tz1) * ((rsd[k + 1][j][i][3] - (2.0 * rsd[k][j][i][3])) + rsd[k - 1][j][i][3]));\n      frct[k][j][i][4] = (frct[k][j][i][4] + (((tz3 * C3) * C4) * (flux[k + 1][4] - flux[k][4]))) + ((dz5 * tz1) * ((rsd[k + 1][j][i][4] - (2.0 * rsd[k][j][i][4])) + rsd[k - 1][j][i][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[1][j][i][m] = frct[1][j][i][m] - (dssp * ((((+5.0) * rsd[1][j][i][m]) - (4.0 * rsd[2][j][i][m])) + rsd[3][j][i][m]));\n      frct[2][j][i][m] = frct[2][j][i][m] - (dssp * (((((-4.0) * rsd[1][j][i][m]) + (6.0 * rsd[2][j][i][m])) - (4.0 * rsd[3][j][i][m])) + rsd[4][j][i][m]));\n    }\n\n    for (k = 3; k < (nz - 3); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (dssp * ((((rsd[k - 2][j][i][m] - (4.0 * rsd[k - 1][j][i][m])) + (6.0 * rsd[k][j][i][m])) - (4.0 * rsd[k + 1][j][i][m])) + rsd[k + 2][j][i][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[nz - 3][j][i][m] = frct[nz - 3][j][i][m] - (dssp * (((rsd[nz - 5][j][i][m] - (4.0 * rsd[nz - 4][j][i][m])) + (6.0 * rsd[nz - 3][j][i][m])) - (4.0 * rsd[nz - 2][j][i][m])));\n      frct[nz - 2][j][i][m] = frct[nz - 2][j][i][m] - (dssp * ((rsd[nz - 4][j][i][m] - (4.0 * rsd[nz - 3][j][i][m])) + (5.0 * rsd[nz - 2][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/9"}
{"code": "for (int i = 0; i < N; i++)\n  B[i] = (int *) malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Coursal/OpenMP-Strictly-Diagonally-Dominant/sdd/4"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  init_array(X);\n  start = _rdtsc();\n  parallel_qsort_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X))\n  {\n    fprintf(stderr, \"ERROR: the array is not properly sorted\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/qsort/4"}
{"code": "for (int i = 2; i < 10; i++)\n{\n  fib[i] = fib[i - 2] + fib[i - 1];\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/demos/openmp/parallel-for/1"}
{"code": "for (int i = 0; i < job_n; ++i)\n  MPI_Recv(canvas[msg + i], y_point_n, MPI_INT, slave_rank, DATA_TAG, MPI_COMM_WORLD, &status);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kjs1095/PP/mandelbrot-set/MS_Hybrid_dynamic/0"}
{"code": "for (int i = 0; i < nr_centroids; i++)\n{\n  for (int j = 0; j < nr_dimensions; j++)\n  {\n    coordinates_accumulator_thread[(i * nr_dimensions) + j] = 0.0;\n  }\n\n  points_accumulator_thread[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/9"}
{"code": "for (intptr_t i = 0; i < size; i++)\n{\n  scalar_product += ((long long int) vector1[i]) * vector2[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:scalar_product) num_threads(t_value)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alamart1683/openmp-scalar-product/pp_lr2/pp_lr2/pp_lr2/3"}
{"code": "for (int i = 0; i < num_row_indices; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    sl(i, j) = array(row_indices[i], start_col + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_cuda/image_stitching/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  x[i] = 2.0f;\n  y[i] = 1.0f;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_parfor/0"}
{"code": "for (i = 0; i < ARCHelems; i++)\n{\n  fscanf(packfile, \"%d\", &ARCHglobalelem[i]);\n  for (j = 0; j < ARCHcorners; j++)\n  {\n    fscanf(packfile, \"%d\", &ARCHvertex[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/27"}
{"code": "for (i = 0; i < n_local_edges; i++)\n{\n  packed_edge *edge = local_edges + i;\n  int64_t v0 = get_v0_from_edge(edge);\n  int64_t v1 = get_v1_from_edge(edge);\n  assert((get_owner_pe(v0, nglobalverts) == pe) || (get_owner_pe(v1, nglobalverts) == pe));\n  if (get_owner_pe(v0, nglobalverts) == pe)\n  {\n    local_vertex_offsets[v0 - local_min_vertex]++;\n  }\n\n  if (get_owner_pe(v1, nglobalverts) == pe)\n  {\n    local_vertex_offsets[v1 - local_min_vertex]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/11"}
{"code": "for (i = 0; i < V; i++)\n{\n  graphAdjArrayList->vertices[i].outNodes = 0;\n  graphAdjArrayList->vertices[i].out_degree = 0;\n  graphAdjArrayList->vertices[i].inNodes = 0;\n  graphAdjArrayList->vertices[i].in_degree = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjArrayList/5"}
{"code": "for (int row = 0; row < realImg_.rows; ++row)\n{\n  for (int col = 0; col < realImg_.cols; ++col)\n  {\n    float sum;\n    sum = realImg_(row, col)[0] + plainElevationMapColored_(row, col)[0];\n    sum = (sum > 255) ? (255) : (sum);\n    realImg_(row, col)[0] = sum;\n    sum = realImg_(row, col)[1] + plainElevationMapColored_(row, col)[1];\n    sum = (sum > 255) ? (255) : (sum);\n    realImg_(row, col)[1] = sum;\n    sum = realImg_(row, col)[2] + plainElevationMapColored_(row, col)[2];\n    sum = (sum > 255) ? (255) : (sum);\n    realImg_(row, col)[2] = sum;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maltejoos/LongitudinalRoadProfileEstimation/src/src/ElevationMap/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double random_number = (rand() % 99) + 10;\n  random_array.push_back(random_number);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Presto412/Parallel-Matrix-Inversion-with-OpenMP/pdc-da2-inverse-gje/0"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  varianza += pow(arr[i] - media, 2.0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio8/ejercicio8Paralelo/4"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  for (j = 0; j < clusters[i]->numOfProducts; j++)\n  {\n    sum += clusters[i]->products[j]->distance;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roiedanino/K-Means-Parallel-Implementation/kMeansRoieDanino/Kmeans_Products_Serial/3"}
{"code": "for (k = k1; k <= kn; k++)\n{\n  for (j = j1; j <= jn; j++)\n  {\n    for (i = i1; i <= in; i++)\n    {\n      a[((k * mxy) + (j * mx)) + i] = anew[((k * mxy) + (j * mx)) + i];\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(1024) collapse(3) schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/c-heatx/c-heatx/1"}
{"code": "for (i = 0; i < L1; i++)\n  for (j = 0; j < L2; j++)\n  for (k = 0; k < L3; k++)\n  A[(j * N) + k] += (-C[(j * N) + i]) * R[(i * N) + k];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/hpx/bench/lu/hpx-lu/10"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i - 2][j][k][m] - (4. * u[i - 1][j][k][m])) + (5.0 * u[i][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/91"}
{"code": "for (x = 0; x < image.width(); x++)\n{\n  for (y = 0; y < image.height(); y++)\n  {\n    oimage(x, y) = px[x][y];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CatKinKitKat/TEI-ImageMP/sobelMulti/0"}
{"code": "for (; it < 100; it++)\n{\n  if (!working_iterations[it])\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GetsuDer/Sor3D/Source/openmp_code/2"}
{"code": "for (int i = 1; i < length; i++)\n{\n  if (array[i] > max)\n  {\n    max = array[i];\n    ind = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/hash_mpi/5"}
{"code": "for (int i = 0; i < ntrain_samples; i++)\n  train_resp->data.fl[i] = responses->data.fl[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/27"}
{"code": "for (i = 0; i != n; i++)\n{\n  x[i] = i;\n  y[i] = 2 * i;\n  z[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/saxpy/1"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  row_disp[i] = row_disp[i - 1] + row_sendcount[i - 1];\n  col_disp[i] = col_disp[i - 1] + col_sendcount[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/11"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < 16; j = j + baz(&i))\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/36"}
{"code": "for (int j = 0; j < this->out_channels; j++)\n{\n  this->Kernels.push_back((float *) malloc(((this->in_channels * kernel_size) * kernel_size) * (sizeof(float))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/CNN/Convolution_OpenMP/0"}
{"code": "for (int row = aStartZ + aBoundaryLength; row < (aEndZ - aBoundaryLength); row += aStrideZ)\n{\n  for (int column = 0; column < aBoundaryLength; column += aStrideX)\n  {\n    index = ((row * aNx) + column) + aStartX;\n    float r_val = GET_RANDOM_VALUE(aBoundaryLength, column) * aMaxVelocity;\n    apRandom[index] = abs(apRandom[((row * aNx) + aBoundaryLength) + aStartX] - r_val);\n    apSeeds[seed_index] = Point3D(column + aStartX, 1, row);\n    seed_index++;\n    index = (row * aNx) + ((aEndX - column) - 1);\n    r_val = GET_RANDOM_VALUE(aBoundaryLength, column) * aMaxVelocity;\n    apRandom[index] = abs(apRandom[(row * aNx) + ((aEndX - 1) - aBoundaryLength)] - r_val);\n    apSeeds[seed_index] = Point3D((aEndX - column) - 1, 1, row);\n    seed_index++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/RandomExtension/0"}
{"code": "for (k = a; k <= b; ++k)\n{\n  c = cos(twoPiOverN * k);\n  W[k].re = (W[n - k].re = c);\n  s = sin(twoPiOverN * k);\n  W[k].im = -s;\n  W[n - k].im = s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/0"}
{"code": "for (i = 0; i < ngrid; i++)\n{\n  accum += arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mdh-omp/main/2"}
{"code": "for (i = 0; i < grid_rows; i++)\n{\n  for (j = 0; j < grid_cols; j++)\n  {\n    sprintf(str, \"%g\\n\", vect[(i * grid_cols) + j]);\n    fputs(str, fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task5_hotspot/hotspot_omp_single_iteration/hotspot/2"}
{"code": "for (long long int i = 1; i < (1 << (N - 1)); i++)\n{\n  int y = (i >> 1) ^ i;\n  int yy = ((i - 1) >> 1) ^ (i - 1);\n  int z = __builtin_ctz(y ^ yy);\n  int s = (((y >> z) & 1) == 1) ? (1) : (-1);\n  int prodsign = ((i & 1) == 0) ? (1) : (-1);\n  double dd = 1.0;\n  for (int j = 0; j < N; j++)\n  {\n    x_specul[j] += (double) (s * MT[z][j]);\n    dd *= x_specul[j];\n  }\n\n  p += (double) (prodsign * dd);\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YigitAras/OpenMP_Matrix_Permanent_Parallel/permanent_hw1/1"}
{"code": "for (layer4_index = 0; layer4_index < Layer_CH_Num; layer4_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv4_data[(((layer4_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv5[(((((layer5_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer4_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/28"}
{"code": "for (i = 1; i < (my_grid->dimension - 1); i++)\n{\n  for (j = ((i + k) % 2) + 1; j < (my_grid->dimension - 1); j += 2)\n  {\n    temp = my_grid->element[(i * my_grid->dimension) + j];\n    my_grid->element[(i * my_grid->dimension) + j] = 0.20 * ((((my_grid->element[(i * my_grid->dimension) + j] + my_grid->element[((i - 1) * my_grid->dimension) + j]) + my_grid->element[((i + 1) * my_grid->dimension) + j]) + my_grid->element[(i * my_grid->dimension) + (j + 1)]) + my_grid->element[(i * my_grid->dimension) + (j - 1)]);\n    diff = diff + fabs(my_grid->element[(i * my_grid->dimension) + j] - temp);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) default(none) private(i, j, temp) shared(k, my_grid) reduction( + : diff)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mklobukov/Parallel-Programming/Cholesky/solver/solverr/0"}
{"code": "for (int j = 0; j < N; j += SMALL_N)\n{\n  int sub_N = (SMALL_N < (N - j)) ? (SMALL_N) : (N - j);\n  compute(A + ((i * lda) + (k * 8)), B + ((j * lda) + k), C + ((j * lda) + i), sub_M, sub_N, sub_K, lda);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/7"}
{"code": "for (int i = 0; i < N; ++i)\n  a[i] = cos((i * 1.0) / 200);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDX-Math-HSAP/openmp_intro/example codes/impls/7"}
{"code": "for (long i = 1; i <= n; i++)\n{\n  if (is_prime(i) == 1)\n    numprimes++;\n\n}\n\n", "pragma": "omp parallel forschedule(dynamic, 1) reduction(+:numprimes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/OpenMP/noOfPrimes/0"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  if (iterations[i] == which_thread)\n  {\n    stop_iter = i;\n  }\n  else\n  {\n    printf(\"%4d  \\t\\t%d -- %d\\n\", which_thread, start_iter, stop_iter);\n    which_thread = iterations[i];\n    start_iter = (stop_iter = i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/10_omp_sin_sum/2"}
{"code": "for (ii = id, sum[id] = 0; ii < numSteps; ii = ii + nThreadsSlave)\n{\n  x = (ii + 0.5) * step;\n  sum[id] = sum[id] + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Adaickalavan/OpenMP-Tim-Mattson/libs/computepi/computepi/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/parallel_reduction_openmp/aggregation_operations/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  hash_map[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atharva1707/K-mer-counting-using-Bloom-filter/main/0"}
{"code": "for (j = 0; j < size_new_seq; j++)\n{\n  addMutantsEachSeq(seq2, size_seq2, &new_seq2, &j, &scores);\n  scores->score = compareSameLenSequences(weights, seq1, new_seq2, size_seq2);\n  if (scores->score > maxScore)\n  {\n    maxScore = scores->score;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/6"}
{"code": "for (i = 1; i < k; i++)\n{\n  for (j = 0; j < i; j++)\n  {\n    if (((1 + currprob) % size) == 0)\n    {\n      my_max_i = (gene_lens[i] > my_max_i) ? (gene_lens[i]) : (my_max_i);\n      my_max_j = (gene_lens[j] > my_max_j) ? (gene_lens[j]) : (my_max_j);\n    }\n\n    recv_count[(1 + currprob) % size] += 1;\n    currprob += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/4"}
{"code": "for (z = 0; z < 316; ++z)\n  Kcell[z] = (double *) malloc(dof2n6 * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/1"}
{"code": "for (i = 0; i < (DIM * DIM); i++)\n{\n  A[i] = (float *) malloc((BSIZE * BSIZE) * (sizeof(float)));\n  B[i] = (float *) malloc((BSIZE * BSIZE) * (sizeof(float)));\n  C[i] = (float *) malloc((BSIZE * BSIZE) * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/matrix_multiplication/dense_algebra_omp/3"}
{"code": "for (int t = 0; t < 256; t++)\n{\n  omp_init_lock(&lck[t]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_locks/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    a[i][j] = (i * j) + 0.01;\n  }\n\n  v_out[i] = (i * j) + 0.01;\n  v[i] = (i * j) + 0.01;\n}\n\n", "pragma": "omp parallel for private(i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB061-matrixvector1-orig-no/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"Loop 2 - (%d) gets iteration %d\\n\", id, i);\n}\n\n", "pragma": "omp for schedule(dynamic) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/5.ordered/1"}
{"code": "for (i = 0; i < (N_COMM * 2); i += 2)\n{\n  double comienzo = minCommTimes[i];\n  double final = maxCommTimes[i + 1];\n  printf(\"Comunicaci\u00f3n %i: %f\\n\", i / 2, final - comienzo);\n  commTime += final - comienzo;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/25"}
{"code": "for (int ii = 0; ii < size; ii += block_size)\n{\n  for (int jj = 0; jj < size; jj += block_size)\n  {\n    for (int kk = 0; kk < size; kk += block_size)\n    {\n      for (int i = ii; i < (ii + block_size); i++)\n      {\n        for (int j = jj; j < (jj + block_size); j++)\n        {\n          T temp = 0;\n          for (int k = kk; k < (kk + block_size); k++)\n          {\n            temp += a2[(i * size) + k] * b3[(j * size) + k];\n          }\n\n          c[i][j] += temp;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(5) default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_block_transpose/2"}
{"code": "for (i = 7; i >= 0; i--)\n  printf(\"%lf \", x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/vec_nbody/1"}
{"code": "for (i__ = 1; (i__2 < 0) ? (i__ >= i__1) : (i__ <= i__1); i__ += i__2)\n{\n  sx[i__] = (*sa) * sx[i__];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/42"}
{"code": "for (size_t k = 0; k < (m_height * m_width); ++k)\n{\n  wvprod[k] = prod(vsp, vind, vsz, codebook + (k * m_dim));\n  const double dst = squared_sum[k] - (2 * (wvprod[k] * w_coeff[k]));\n  if (dst < dStar)\n  {\n    idx = k;\n    dStar = dst;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/som/3"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  int j;\n  for (j = 0; j < 4096; j++)\n  {\n    x2[i] = x2[i] + (a[(j * 4096) + i] * y2[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/MVT/src/mvt/4"}
{"code": "for (int neuron = 0; neuron < (layers[layer] - 1); neuron += 1)\n{\n  double REGISTER = 0.0;\n  for (int synapse = 0; synapse < layers[layer - 1]; synapse += 1)\n  {\n    REGISTER += weights[layer - 1][neuron][synapse] * a[layer - 1][synapse];\n  }\n\n  z[layer][neuron] = REGISTER;\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/neural-network/src/forward/0"}
{"code": "for (int i = 1; i <= omp_get_num_threads(); i++)\n{\n  int my_thread = omp_get_thread_num();\n  printf(\"Hello from thread %d\\n\", my_thread);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pyright/omp_hello/parallel_for_hello/0"}
{"code": "for (int i = 0; i < N; i++)\n  array[i] = rand();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/test/0"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  input[i] = rand() / ((double) RAND_MAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raaavioli/OpenMP-Assignments-DD2356/Exercise-3/sum/6"}
{"code": "for (y = 0; y < (ny + 1); ++y)\n{\n  grid_current[(0 * size_y) + y] = 0;\n  grid_current[(nx * size_y) + y] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bazk/rbgs/rbgs/20"}
{"code": "for (int i = 0; i < (3 * (ifog_t_linear.size() / 4)); ++i)\n{\n  for (int j = 0; j < ifog_t_linear[0].size(); ++j)\n  {\n    ifog_t[i][j] = 1 / (1 + exp(-ifog_t_linear[i][j]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_3/2"}
{"code": "for (int i = 0; i < nx; i++)\n  for (int j = 0; j < ny; j++)\n{\n  vectorX[i][j][0] = vectorX[i][j][4];\n  vectorY[i][j][0] = vectorY[i][j][4];\n  vectorZ[i][j][0] = vectorZ[i][j][4];\n  vectorX[i][j][1] = vectorX[i][j][4];\n  vectorY[i][j][1] = vectorY[i][j][4];\n  vectorZ[i][j][1] = vectorZ[i][j][4];\n  vectorX[i][j][2] = vectorX[i][j][4];\n  vectorY[i][j][2] = vectorY[i][j][4];\n  vectorZ[i][j][2] = vectorZ[i][j][4];\n  vectorX[i][j][3] = vectorX[i][j][4];\n  vectorY[i][j][3] = vectorY[i][j][4];\n  vectorZ[i][j][3] = vectorZ[i][j][4];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/110"}
{"code": "for (int i = 0; i < numprocs; ++i)\n{\n  int t1 = (i < remainder) ? (count + 1) : (count);\n  recvcounts[i] = t1 * N2;\n  sendcounts[i] = t1 * N1;\n  int t2 = prefixSum;\n  recvdispls[i] = t2 * N2;\n  senddispls[i] = t2 * N1;\n  prefixSum += t1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kcherenkov/Parallel-Programming-Labs/MatrixMatrixProduct/MatrixMatrixProduct/2"}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = VNI;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/7"}
{"code": "for (i = 0; i < n; i++)\n  for (k = 0; k < n; k++)\n{\n  float c = 0.0;\n  for (j = 0; j < n; j++)\n    c += A[(i * n) + j] * B[(j * n) + k];\n\n  C[(i * n) + k] = c;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/5"}
{"code": "for (i = 1; i <= 15; i++)\n{\n  intm_value = pow(rads, j) / fact(j);\n  sign = 1;\n  if ((i % 2) != 0)\n  {\n    sign = -1;\n  }\n\n  sum += sign * intm_value;\n  j = j + 2;\n}\n\n", "pragma": "omp parallel for shared(sum)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/cosine_x_estimation/0"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  flux[i][j][k][0] = u[i][j][k][2];\n  u31 = u[i][j][k][2] / u[i][j][k][0];\n  q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n  flux[i][j][k][1] = u[i][j][k][1] * u31;\n  flux[i][j][k][2] = (u[i][j][k][2] * u31) + (C2 * (u[i][j][k][4] - q));\n  flux[i][j][k][3] = u[i][j][k][3] * u31;\n  flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u31;\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,k ,ny ,u31 ,q ,nz ,L2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/76"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  cu[4 * j] = zero;\n  _mm_store_ps((float *) (&cu[(4 * j) + k1]), v_zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/31"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  xi = ((double) iglob) / (nx0 - 1);\n  for (j = 0; j < ny; j++)\n  {\n    jglob = j;\n    eta = ((double) jglob) / (ny0 - 1);\n    for (k = 0; k < nz; k++)\n    {\n      zeta = ((double) k) / (nz - 1);\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/5"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NJ; j++)\n  {\n    C[(i * NJ) + j] = 0.0;\n    for (k = 0; k < NK; ++k)\n    {\n      C[(i * NJ) + j] += A[(i * NK) + k] * B[(k * NJ) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/7"}
{"code": "for (y = 0; y < OMP_yMax; y++)\n{\n  for (x = 0; x < OMP_xMax; x += 8)\n  {\n    int ind = OMP_Index(x, y, 0);\n    u[ind] *= boundryScale;\n    u[ind + 1] *= boundryScale;\n    u[ind + 2] *= boundryScale;\n    u[ind + 3] *= boundryScale;\n    u[ind + 4] *= boundryScale;\n    u[ind + 5] *= boundryScale;\n    u[ind + 6] *= boundryScale;\n    u[ind + 7] *= boundryScale;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/loopunroll16/4ompDeblur/2"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    ASSERT(rowind[j] < ncols);\n    collen[rowind[j]]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/31"}
{"code": "for (int g = 0; g < I.n_egroups; g++)\n{\n  t3[g] = (q2[g] * mu2) * reuse[g];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/16"}
{"code": "for (i = 0; i < 3; i++)\n{\n  random_seq[i] = (unsigned short) atoi(argv[8 + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/7"}
{"code": "for (int i = 0; i < k; i++)\n{\n  w[i] = 0;\n  for (int j = 0; j < n; j++)\n  {\n    w[i] += (datapoint[j] - mu[i][j]) * (datapoint[j] - mu[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/4"}
{"code": "for (c = 0; c < 4; c++)\n{\n  int clusterSize = clusters[c].numDatapoints;\n  double *distances = malloc(clusterSize * (sizeof(double)));\n  for (i = 0; i < clusterSize; i++)\n  {\n    distances[i] = 0.0;\n    for (j = 0; j < clusterSize; j++)\n    {\n      distances[i] += distance(*clusters[c].datapoints[i], *clusters[c].datapoints[j]);\n    }\n\n  }\n\n  int medoidIndex = indexOfSmallestElement(distances, clusterSize);\n  clusters[c].medoid = clusters[c].datapoints[medoidIndex];\n  free(distances);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/28"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < num_of_threads; ++j)\n  result_vect[i] += partial_sums[j][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/3/3/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name foo#0#0\n  for (j = 0; j < (m - 1); j++)\n  {\n    b[i][j] = b[i][j + 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB063-outeronly1-orig-no/2"}
{"code": "for (int i = 0; i < coord.size(); ++i)\n  convert(coord[i], coord_s[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/SandBox/einspline_io/2"}
{"code": "for (i = 1; i <= 100; i++)\n{\n  app_id = get_app_id(i);\n  main_token = get_main_token(app_id);\n  sub_token = get_sub_token(main_token);\n  printf(\"\\nMain counter is currently processing Application ID:%d \\nMain Counter Token ID :%d \\nCounter ID assigned:%d\", app_id, main_token, sub_token);\n}\n\n", "pragma": "omp parallel for firstprivate(app_id,main_token,sub_token)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pushpinder107/parallel-programming-lab/firstprivate/fprivate1/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fseek(fsignal, ((i * cols) * bands) * (sizeof(float)), 0);\n  fread(buffer, sizeof(float), cols * (nendmembers - 1), fsignal);\n  fread(buffer2, sizeof(float), cols * bands, fin);\n  for (j = 0; j < (nendmembers - 1); j++)\n  {\n    for (k = 0; k < cols; k++)\n    {\n      if (buffer2[(j * cols) + k] != nvalue)\n      {\n        if (buffer[(j * cols) + k] < hmin[j])\n        {\n          hmin[j] = buffer[(j * cols) + k];\n          coordsr[j] = i;\n          coordsc[j] = k;\n        }\n\n        if (buffer[(j * cols) + k] > hmax[j])\n        {\n          hmax[j] = buffer[(j * cols) + k];\n          coordsr[(nendmembers - 1) + j] = i;\n          coordsc[(nendmembers - 1) + j] = k;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"thread %d: initial value = %d\\n\", omp_get_thread_num(), vtest);\n  vtest = i;\n}\n\n", "pragma": "omp parallel for private(i) firstprivate(vtest) lastprivate(vtest) shared(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaohao99/Introduction_to_OpenMP/source/firstlastprivate/solution/firstlastprivate/0"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((((mat1[rowcol] == (-28768)) || ((mat1[rowcol] * 0.02) <= 250.0)) || ((mat1[rowcol] * 0.02) > 365.0)) || (mat5[rowcol] >= 10000.0)) || (mat5[rowcol] <= 0.0))\n    matOut[rowcol] = -28768;\n  else\n  {\n    e0 = 0.5 * (((mat3[rowcol] * 0.002) + 0.49) + ((mat4[rowcol] * 0.002) + 0.49));\n    kin = k_in(mat2[rowcol], doy, mat7[rowcol] * 0.01);\n    kin24 = k_in24(latitude[rowcol], doy, mat2[rowcol]);\n    sebsevapfr = sebs_evapfr(z_pbl, t_s, p_s, u_s, hr_s, alt_ms, e_act, kin, mat6[rowcol] * 0.001, mat5[rowcol] * 0.0001, ndvi_min, ndvi_max, ndvimedian, e0, mat1[rowcol] * 0.02, mat2[rowcol]);\n    matOut0[rowcol] = sebsevapfr;\n    sebseta = sebs_eta(doy, mat5[rowcol] * 0.0001, ndvi_max, ndvi_min, ndvimedian, u_s, z_pbl, t_s, p_s, alt_ms, e_act, latitude[rowcol], kin24, mat6[rowcol] * 0.001, mat2[rowcol], mat1[rowcol] * 0.02, e0, sebsevapfr);\n    matOut[rowcol] = sebseta;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, sebseta, sebsevapfr, kin, kin24, e0) shared(N, e_act, doy, p_s, t_s, z_pbl, u_s, ndvimedian, ndvi_min, ndvi_max, alt_ms, hr_s, mat1, mat2, mat3, mat4, mat5, mat6, mat7, matOut0, matOut, latitude )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBS/gdal_sebs_eta/4"}
{"code": "for (i = 0; i < numbars; ++i)\n{\n  bars[i] = 0;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarimAboshamia/Frequency-Histogram/main/0"}
{"code": "for (i = 0; i < order; i++)\n{\n  if (i != (order - 1))\n    printf(\"%dx\", dimensionality[i]);\n  else\n    printf(\"%d\\t\", dimensionality[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/7"}
{"code": "for (int i = start; i <= end; i++)\n{\n  for (int j = start; j <= end; j++)\n  {\n    if (array[j] > array[i])\n    {\n      int k;\n      T temp = array[j];\n      array[j] = array[i];\n      for (k = i; k > j; k--)\n        array[k] = array[k - 1];\n\n      array[k + 1] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nikhilunni/ParallelQuicksort/psort/2"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  printf(\"[\");\n  for (j = 0; j < dimension; j++)\n    printf(\" %.3lf\", data_points[i][j]);\n\n  printf(\" ]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  f[i] = ((float) 0.01) * ((rand() % 11) - 5);\n  f[i] = (f[i] + 1.0) - (pow(A[i][0] - 0.5, 2.0) + pow(A[i][1] - 0.5, 2.0));\n  (cout << f[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sharatchandraj/Gaussian-Process-Regression-OpenMP/GPR/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 0;\n  validate[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/alignedattribute/alignedattribute/1"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  double *X = X0 + ((i % cX) * rX);\n  double *Y = Y0 + ((i / cX) * rY);\n  double cc = 0.0;\n  double nn = 0.0;\n  double rc = 0.0;\n  double rn = 0.0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double t;\n    double y;\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    y = (z * W[k]) - rc;\n    t = cc + y;\n    rc = (t - cc) - y;\n    cc = t;\n    y = (z * W[k]) - rn;\n    t = nn + y;\n    rn = (t - nn) - y;\n    nn = t;\n  }\n\n  CC[i] = cc;\n  if (NN != NULL)\n    NN[i] = nn;\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/5"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    (cout << matriz_C[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SidSan97/OMP---Algebra-Linear/OMP - Algebra Linear/main/4"}
{"code": "for (n = nzi - 1; n < nzt; n++)\n{\n  nn = nxhyd * n;\n  for (i = 0; i < ny; i++)\n  {\n    joff = (nnxhd * i) + nn;\n    for (j = 0; j < nxh; j++)\n    {\n      at1 = cimagf(f[(2 + (4 * j)) + joff]);\n      at2 = crealf(f[(2 + (4 * j)) + joff]);\n      f[(2 + (4 * j)) + joff] = crealf(f[(1 + (4 * j)) + joff]) + (crealf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n      f[(1 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (at1 * _Complex_I);\n      f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n    }\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (i = 0; i < ny; i++)\n      {\n        joff = (nnxhd * i) + nn;\n        t1 = f[(4 * j1) + joff];\n        t2 = f[(1 + (4 * j1)) + joff];\n        t3 = f[(2 + (4 * j1)) + joff];\n        f[(4 * j1) + joff] = f[(4 * j) + joff];\n        f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n        f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n        f[(4 * j) + joff] = t1;\n        f[(1 + (4 * j)) + joff] = t2;\n        f[(2 + (4 * j)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = sct[kmr * j];\n        for (i = 0; i < ny; i++)\n        {\n          joff = (nnxhd * i) + nn;\n          t2 = t1 * f[((4 * j) + k2) + joff];\n          t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n          t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n          f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n          f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n          f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n          f[((4 * j) + k1) + joff] += t2;\n          f[((1 + (4 * j)) + k1) + joff] += t3;\n          f[((2 + (4 * j)) + k1) + joff] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxyz / nx;\n  ani = 0.5 / ((((float) nx) * ((float) ny)) * ((float) nz));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < ny; k++)\n    {\n      joff = (nnxhd * k) + nn;\n      for (jj = 0; jj < 3; jj++)\n      {\n        t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n        t1 = f[(jj + (4 * j)) + joff] + t2;\n        t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n        f[(jj + (4 * j)) + joff] = ani * (t1 + t2);\n        f[(jj + (4 * (nxh - j))) + joff] = ani * conjf(t1 - t2);\n      }\n\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nnxhd * k) + nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      f[(jj + (4 * nxhh)) + joff] = ani * conjf(f[(jj + (4 * nxhh)) + joff]);\n      f[jj + joff] = ani * ((crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I));\n    }\n\n  }\n\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nnxhd * k) + nn;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (nnxhd * k1) + nn;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[(4 * i) + k1];\n        t2 = f[(1 + (4 * i)) + k1];\n        t3 = f[(2 + (4 * i)) + k1];\n        f[(4 * i) + k1] = f[(4 * i) + joff];\n        f[(1 + (4 * i)) + k1] = f[(1 + (4 * i)) + joff];\n        f[(2 + (4 * i)) + k1] = f[(2 + (4 * i)) + joff];\n        f[(4 * i) + joff] = t1;\n        f[(1 + (4 * i)) + joff] = t2;\n        f[(2 + (4 * i)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (nnxhd * (j + k1)) + nn;\n        j2 = (nnxhd * (j + k2)) + nn;\n        t1 = sct[kmr * j];\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[(4 * i) + j2];\n          t3 = t1 * f[(1 + (4 * i)) + j2];\n          t4 = t1 * f[(2 + (4 * i)) + j2];\n          f[(4 * i) + j2] = f[(4 * i) + j1] - t2;\n          f[(1 + (4 * i)) + j2] = f[(1 + (4 * i)) + j1] - t3;\n          f[(2 + (4 * i)) + j2] = f[(2 + (4 * i)) + j1] - t4;\n          f[(4 * i) + j1] += t2;\n          f[(1 + (4 * i)) + j1] += t3;\n          f[(2 + (4 * i)) + j1] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    joff = nnxhd * k;\n    k1 = ((nnxhd * ny) - joff) + nn;\n    joff += nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      t1 = f[jj + k1];\n      f[jj + k1] = 0.5 * (cimagf(f[jj + joff] + t1) + (crealf(f[jj + joff] - t1) * _Complex_I));\n      f[jj + joff] = 0.5 * (crealf(f[jj + joff] + t1) + (cimagf(f[jj + joff] - t1) * _Complex_I));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,jj,j1,j2,nn,joff,at1,at2,ani,t1, t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/40"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  if ((n = seqlen_array[si + 1]) != 0)\n  {\n    for (i = 1, len1 = 0; i <= n; i++)\n    {\n      char c = seq_array[si + 1][i];\n      if ((c != gap_pos1) && (c != gap_pos2))\n        len1++;\n\n    }\n\n    for (sj = si + 1; sj < nseqs; sj++)\n    {\n      if ((m = seqlen_array[sj + 1]) != 0)\n      {\n        {\n          int se1;\n          int se2;\n          int sb1;\n          int sb2;\n          int maxscore;\n          int seq1;\n          int seq2;\n          int g;\n          int gh;\n          int displ[(2 * 5000) + 1];\n          int print_ptr;\n          int last_print;\n          for (i = 1, len2 = 0; i <= m; i++)\n          {\n            char c = seq_array[sj + 1][i];\n            if ((c != gap_pos1) && (c != gap_pos2))\n              len2++;\n\n          }\n\n          gh = 10 * pw_ge_penalty;\n          gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n          g = (mat_avscore <= 0) ? (20 * gg) : ((2 * mat_avscore) * gg);\n          seq1 = si + 1;\n          seq2 = sj + 1;\n          forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n          reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n          print_ptr = 1;\n          last_print = 0;\n          diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n          mm_score = tracepath(sb1, sb2, &print_ptr, &last_print, displ, seq1, seq2);\n          if ((len1 == 0) || (len2 == 0))\n            mm_score = 0.0;\n          else\n            mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n\n          bench_output[(si * nseqs) + sj] = mm_score;\n        }\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) private(i,n,si,sj,len1,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_performance/task_performance/bots/omp-tasks/alignment/alignment_for/alignment/0"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  slope = atan(m_Slope[i]);\n  DX = m_CellWidth / cos(slope);\n  wh = m_WH[i] / 1000;\n  m_Vol[i] = (DX * m_CellWidth) * wh;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/KinWavSed_OL/KinWavSed_OL/2"}
{"code": "for (int i = 0; i < arraySize; i++)\n{\n  printf(\"\\t th_cnt: %d, th_id: %d, iter: %d\\n\", omp_get_num_threads(), omp_get_thread_num(), i);\n  a[i] = omp_get_thread_num();\n  b[i] = 4 - omp_get_thread_num();\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static, 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dimanaux/itis-omp/07/0"}
{"code": "for (j = 0; j < BLOCK_HEIGHT; j++)\n{\n  for (i = 0; i < BLOCK_WIDTH; i++)\n  {\n    pixels[i + (j * BLOCK_WIDTH)] = computePoint(i, j + (myJobStart / 1536));\n  }\n\n}\n\n", "pragma": "\t\t\t\t#pragma omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/mandelbrot-hybrid/1"}
{"code": "for (i = 1; i < (100 + 1); i++)\n{\n  U[i][0] = 100.0 - ((((double) i) / ((double) 100)) * 100.0);\n  U[i][100 + 1] = (((double) i) / ((double) 100)) * 100.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/5"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%f %f %f \", (float) npcdDeviation[i * 3], (float) npcdDeviation[(i * 3) + 1], (float) npcdDeviation[(i * 3) + 2]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/131"}
{"code": "for (i = 0; i < rows; i++)\n{\n  printf(\"|\");\n  for (j = 0; j < columns; j++)\n  {\n    char symbol;\n    if (heights[(((int) i) * columns) + ((int) j)] != (-2147483648))\n      printf(\" %6d\", heights[(((int) i) * columns) + ((int) j)]);\n    else\n      printf(\"       \");\n\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/12"}
{"code": "for (int j = 0; j < cnt; j++)\n{\n  data[j] = 0;\n  for (int i = 0; i < max_threads_nums; i++)\n  {\n    data[j] += res[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (mask1[index1][i] && mask2[index2][i])\n  {\n    for (j = 0; j < i; j++)\n    {\n      if (mask1[index1][j] && mask2[index2][j])\n      {\n        double x1 = data1[index1][i];\n        double x2 = data1[index1][j];\n        double y1 = data2[index2][i];\n        double y2 = data2[index2][j];\n        if ((x1 < x2) && (y1 < y2))\n          con++;\n\n        if ((x1 > x2) && (y1 > y2))\n          con++;\n\n        if ((x1 < x2) && (y1 > y2))\n          dis++;\n\n        if ((x1 > x2) && (y1 < y2))\n          dis++;\n\n        if ((x1 == x2) && (y1 != y2))\n          exx++;\n\n        if ((x1 != x2) && (y1 == y2))\n          exy++;\n\n        flag = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/44"}
{"code": "for (i = 0; i < N; i++)\n{\n  compute_acceleration(root, &particles[i], theta_max, G);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuanx749/n-body/barnes_hut/0"}
{"code": "for (k = 0; k < nn; k++)\n{\n  SparseMXNdsetup(El, E_N, N_E, count, tja, n0, k);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXsetup/0"}
{"code": "for (i = 0; i < (N - points); i++)\n{\n  float tmp = 0.0f;\n  for (j = 0; j < points; j++)\n  {\n    tmp += b[i + j];\n  }\n\n  c[i] = tmp / points;\n}\n\n", "pragma": "omp simd for aligned(b,c:64) suitable(N) nowait overlap(b:4,0,0)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_32_parallel_moving_average_overlap/0"}
{"code": "for (row = 0; row < n; row++)\n{\n  for (col = 0; col < n; col++)\n  {\n    A[row][n] += A[row][col] * x[col];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sfyzsr/Gaussian-Elimination-OpenMP-MPI/gauss_OpenMP/3"}
{"code": "for (int i = 0; i < set_2.size(); ++i)\n{\n  if (!contains(intersection, set_2[i]))\n  {\n    res.push_back(set_2[i]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kiiitG/homework4_openmp/main/2"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  printf(\"%lf\\n\", o1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB050-functionparameter-orig-no/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < 5; j++)\n  {\n    printf(\"%d\\t\", C[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/matrix_multiplication/4"}
{"code": "for (i = 0; i < nsize; i++)\n{\n  for (k = 0; k < nsize; k++)\n  {\n    matrix.a2[i][k] = 1.0;\n    matrix.b2[i][k] = 2.0;\n    matrix.c2[i][k] = 3.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avr-aics-riken/PMlib/doc/src_advanced/sub_dgemm/0"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  copyFirstPixelOnRowUsingTSize_OpenMP(src.data(), width, dst.data(), width, size, true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/5"}
{"code": "for (i = 0; i < 800; i++)\n{\n  for (j = 0; j < 800; j++)\n  {\n    MA[i][j] = (rand() / ((long double) 32767)) * 10.0;\n  }\n\n  MA[i][800] = i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-2/0"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int permIndex = perm_nnz[cast_perm->vec_[i]];\n  int prevIndex = this->mat_.row_offset[i];\n  for (int j = 0; j < row_nnz[i]; ++j)\n  {\n    col[permIndex + j] = this->mat_.col[prevIndex + j];\n    val[permIndex + j] = this->mat_.val[prevIndex + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/73"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    s_A[i][j] = rand() % G;\n    p_A[i][j] = s_A[i][j];\n    temp[i][j] = s_A[i][j];\n    s_b[i][j] = 0;\n    p_b[i][j] = 0;\n    s_x[i][j] = 0;\n    p_x[i][j] = 0;\n    s_y[i][j] = 0;\n    p_y[i][j] = 0;\n  }\n\n  s_b[i][0] = ((1ll * rand()) * rand()) % (G * G);\n  p_b[i][0] = s_b[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhinav-vaishya/Parallel-Computing---MPI-OpenMP-CUDA/codes/Q4/9"}
{"code": "for (int i = result.width - 1; i >= 0; i--)\n{\n  float tmpSum = 0;\n  for (int j = i; j < result.width; j++)\n  {\n    tmpSum += tmp.data[i][j] * result.data[0][j];\n  }\n\n  result.data[0][i] = (tmp.data[i][tmp.width - 1] - tmpSum) / tmp.data[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PiotrMydlowski/Gauss-Elimination/main/2"}
{"code": "for (int c = 0; c < colCount; ++c)\n{\n  for (int r = 0; r < rowCount; ++r)\n  {\n    currentPixel = pixels[(r * colCount) + c];\n    newPixel.rgbBlue = ((currentPixel.rgbBlue + currentPixel.rgbGreen) + currentPixel.rgbRed) / 3;\n    newPixel.rgbGreen = newPixel.rgbBlue;\n    newPixel.rgbRed = newPixel.rgbBlue;\n    pixels[(r * colCount) + c] = newPixel;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(newPixel, currentPixel)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rusty2123/OpenMP-Bitmap-Manipulator/ImageManipulation/main/0"}
{"code": "for (int i = 0; i < sizeInner; i++)\n{\n  for (int j = 0; j < sizeInner; j++)\n  {\n    double randResult;\n    drand48_r(&randBuffer, &randResult);\n    angle[i][j] = ((2.0 * randResult) - 1.0) * M_PI;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/Simulation/0"}
{"code": "for (int i = 0; i < numOfRowIndeces; ++i)\n{\n  const double AO_i = row_AO_values[i];\n  const double dAO_dx_i = row_dAO_dx_values[i];\n  const double dAO_dy_i = row_dAO_dy_values[i];\n  const double dAO_dz_i = row_dAO_dz_values[i];\n  for (int j = 0; j < numOfColIndeces; ++j)\n  {\n    const double AO_j = col_AO_values[j];\n    const double dAO_dx_j = col_dAO_dx_values[j];\n    const double dAO_dy_j = col_dAO_dy_values[j];\n    const double dAO_dz_j = col_dAO_dz_values[j];\n    const double Pij = PA.get(i, j);\n    grx += (Pij * AO_i) * dAO_dx_j;\n    gry += (Pij * AO_i) * dAO_dy_j;\n    grz += (Pij * AO_i) * dAO_dz_j;\n    grx += (Pij * AO_j) * dAO_dx_i;\n    gry += (Pij * AO_j) * dAO_dy_i;\n    grz += (Pij * AO_j) * dAO_dz_i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCalcGridX/4"}
{"code": "for (i = 0; i < n; i++)\n  pagerank_old[i] = pagerank[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/8"}
{"code": "for (int i = NGHOST; i < (NX1 + NGHOST); ++i)\n{\n  for (int j = NGHOST; j < (NX2 + NGHOST); ++j)\n  {\n    RHS_RE = (((-dt) * alpha) * dummy2.LaplacianIm(idx, idy, i, j)) + ((dt * V(i, j, NX1, NX2, dx, dy, beta)) * dummy2.GetIm(i, j));\n    RHS_IM = ((dt * alpha) * dummy2.LaplacianRe(idx, idy, i, j)) - ((dt * V(i, j, NX1, NX2, dx, dy, beta)) * dummy2.GetRe(i, j));\n    dummy3.SetRe(i, j, SF.GetRe(i, j) + RHS_RE);\n    dummy3.SetIm(i, j, SF.GetIm(i, j) + RHS_IM);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rc634/Schr-OpenMP-dinger/ErwinSchrodinger/4"}
{"code": "for (int i = 0; i < numProcs; i++)\n{\n  myStart = (lines / numProcs) * i;\n  if ((lines % numProcs) > i)\n  {\n    myStart += i;\n    myEnd = (myStart + (lines / numProcs)) + 1;\n  }\n  else\n  {\n    myStart += i;\n    myEnd = myStart + (lines / numProcs);\n  }\n\n  recvCounts[i] = CYPHER_BLOCK_SIZE * (myEnd - myStart);\n  if (i > 0)\n    displacements[i] = recvCounts[i - 1] + displacements[i - 1];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aalmeidasilva/RSA-OpenMP-MPI/src/rsa/6"}
{"code": "for (int k = 0; k < (N / 2); k += 2)\n  a[k] = b[k];\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-split-1/no_loop_split_1/0"}
{"code": "for (l = 1; l < nzh; l++)\n{\n  dkz = dnz * ((float) l);\n  lj = nxvyh * l;\n  l1 = (nxvyh * nz) - lj;\n  dkz2 = dkz * dkz;\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    dkyz2 = (dky * dky) + dkz2;\n    for (j = 1; j < nxh; j++)\n    {\n      dkx = dnx * ((float) j);\n      at1 = 1.0 / ((dkx * dkx) + dkyz2);\n      zt1 = at1 * (((dkx * cu[3 * ((j + kj) + lj)]) + (dky * cu[1 + (3 * ((j + kj) + lj))])) + (dkz * cu[2 + (3 * ((j + kj) + lj))]));\n      cu[3 * ((j + kj) + lj)] -= dkx * zt1;\n      cu[1 + (3 * ((j + kj) + lj))] -= dky * zt1;\n      cu[2 + (3 * ((j + kj) + lj))] -= dkz * zt1;\n      zt1 = at1 * (((dkx * cu[3 * ((j + k1) + lj)]) - (dky * cu[1 + (3 * ((j + k1) + lj))])) + (dkz * cu[2 + (3 * ((j + k1) + lj))]));\n      cu[3 * ((j + k1) + lj)] -= dkx * zt1;\n      cu[1 + (3 * ((j + k1) + lj))] += dky * zt1;\n      cu[2 + (3 * ((j + k1) + lj))] -= dkz * zt1;\n      zt1 = at1 * (((dkx * cu[3 * ((j + kj) + l1)]) + (dky * cu[1 + (3 * ((j + kj) + l1))])) - (dkz * cu[2 + (3 * ((j + kj) + l1))]));\n      cu[3 * ((j + kj) + l1)] -= dkx * zt1;\n      cu[1 + (3 * ((j + kj) + l1))] -= dky * zt1;\n      cu[2 + (3 * ((j + kj) + l1))] += dkz * zt1;\n      zt1 = at1 * (((dkx * cu[3 * ((j + k1) + l1)]) - (dky * cu[1 + (3 * ((j + k1) + l1))])) - (dkz * cu[2 + (3 * ((j + k1) + l1))]));\n      cu[3 * ((j + k1) + l1)] -= dkx * zt1;\n      cu[1 + (3 * ((j + k1) + l1))] += dky * zt1;\n      cu[2 + (3 * ((j + k1) + l1))] += dkz * zt1;\n    }\n\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    dky = dny * ((float) k);\n    at1 = 1.0 / ((dky * dky) + dkz2);\n    zt1 = at1 * ((dky * cu[1 + (3 * (kj + lj))]) + (dkz * cu[2 + (3 * (kj + lj))]));\n    cu[1 + (3 * (kj + lj))] -= dky * zt1;\n    cu[2 + (3 * (kj + lj))] -= dkz * zt1;\n    cu[3 * (k1 + lj)] = zero;\n    cu[1 + (3 * (k1 + lj))] = zero;\n    cu[2 + (3 * (k1 + lj))] = zero;\n    zt1 = at1 * ((dky * cu[1 + (3 * (kj + l1))]) - (dkz * cu[2 + (3 * (kj + l1))]));\n    cu[1 + (3 * (kj + l1))] -= dky * zt1;\n    cu[2 + (3 * (kj + l1))] += dkz * zt1;\n    cu[3 * (k1 + l1)] = zero;\n    cu[1 + (3 * (k1 + l1))] = zero;\n    cu[2 + (3 * (k1 + l1))] = zero;\n  }\n\n  k1 = nxvh * nyh;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1.0 / ((dkx * dkx) + dkz2);\n    zt1 = at1 * ((dkx * cu[3 * (j + lj)]) + (dkz * cu[2 + (3 * (j + lj))]));\n    cu[3 * (j + lj)] -= dkx * zt1;\n    cu[2 + (3 * (j + lj))] -= dkz * zt1;\n    cu[3 * ((j + k1) + lj)] = zero;\n    cu[1 + (3 * ((j + k1) + lj))] = zero;\n    cu[2 + (3 * ((j + k1) + lj))] = zero;\n    zt1 = at1 * ((dkx * cu[3 * (j + l1)]) - (dkz * cu[2 + (3 * (j + l1))]));\n    cu[3 * (j + l1)] -= dkx * zt1;\n    cu[2 + (3 * (j + l1))] += dkz * zt1;\n    cu[3 * ((j + k1) + l1)] = zero;\n    cu[1 + (3 * ((j + k1) + l1))] = zero;\n    cu[2 + (3 * ((j + k1) + l1))] = zero;\n  }\n\n  cu[2 + (3 * lj)] = zero;\n  cu[3 * (k1 + lj)] = zero;\n  cu[1 + (3 * (k1 + lj))] = zero;\n  cu[2 + (3 * (k1 + lj))] = zero;\n  cu[3 * l1] = zero;\n  cu[1 + (3 * l1)] = zero;\n  cu[2 + (3 * l1)] = zero;\n  cu[3 * (k1 + l1)] = zero;\n  cu[1 + (3 * (k1 + l1))] = zero;\n  cu[2 + (3 * (k1 + l1))] = zero;\n}\n\n", "pragma": "omp for nowait private(j,k,l,k1,l1,lj,kj,dkx,dky,dkz,dkz2,dkyz2,at1,zt1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/16"}
{"code": "for (i = 0; i < (HIgh_h / 2); i++)\n{\n  for (j = Low_w / 4; j < (Low_w / 2); j++)\n  {\n    bicubic_Y[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Y[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/10"}
{"code": "for (int i = 0; i < len_arr; i++)\n{\n  temp1 = temp1 + ((x[i] - x_avg) * (y[i] - y_avg));\n  temp2 = temp2 + ((x[i] - x_avg) * (x[i] - x_avg));\n}\n\n", "pragma": "omp parallel for reduction(+:temp1, temp2) firstprivate(x_avg, y_avg, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/13/Linear_Regression/main/1"}
{"code": "for (int i = 0; i < ((1024 * 1024) * 64); ++i)\n{\n  localSum++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment1/fast/0"}
{"code": "for (i = 0; i < bands; i++)\n{\n  free(zTz_inv[i]);\n  free(zTz[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/27"}
{"code": "for (i = 2; i < (f + 3); i++)\n  for (j = d + 1; j >= 0; j--)\n  for (k = 0; k < d; k++)\n  for (l = 0; l < (d + 2); l++)\n{\n  if (!e)\n    abort();\n\n}\n\n\n\n\n", "pragma": "omp for collapse(2) ordered(4) lastprivate (i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/0"}
{"code": "for (i = 0; i < num_points; i++)\n  before_clusters[i] = after_cluster[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Projects/PC-Project/parallel code/kmean_omp/10"}
{"code": "for (int i = 0; i < W.size(); i++)\n{\n  for (int j = 0; j < W[0].size(); j++)\n  {\n    for (int k = 0; k < input_t[0].size(); k++)\n    {\n      Wx_temp[t] = W[i][j] * input_t[i][k];\n      t++;\n    }\n\n  }\n\n}\n\n", "pragma": "    \t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_4_final/1"}
{"code": "for (int i = 0; i < Np; i++)\n{\n  if ((x[i] <= x_mid) && (y[i] <= y_mid))\n  {\n    p[0].push_back(i);\n  }\n  else\n    if ((x[i] <= x_mid) && (y[i] > y_mid))\n  {\n    p[1].push_back(i);\n  }\n  else\n    if ((x[i] > x_mid) && (y[i] <= y_mid))\n  {\n    p[2].push_back(i);\n  }\n  else\n  {\n    p[3].push_back(i);\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NeoNeuron/minfo/src/mutual_info/0"}
{"code": "for (int t = 1; t < num_thread; t++)\n{\n  int left = (block_size * t) + 1;\n  int right = ((block_size * (t + 1)) < n) ? (block_size * (t + 1)) : (n);\n  int prev_block_sum = prefix_sum[left - 1];\n  for (int i = left; i < right; i++)\n    prefix_sum[i] += prev_block_sum;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/PrefixSum/prefixsum-omp/1"}
{"code": "for (i = 0, result = 0; i < neuron->n_weights; i++)\n{\n  result += neuron->weights[i] * data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/NeuralNet/3"}
{"code": "for (int ia = 0; ia < vol_a; ia++)\n{\n  int it_a = ia;\n  int id_a = id_b;\n  int is = 0;\n  int im_a;\n  int ic;\n  for (int i = 0; i < dim_a; i++)\n  {\n    im_a = it_a * shape_a_inv[i];\n    ic = it_a - (im_a * shape_a[i]);\n    id_a += stride_a_g[i] * ic;\n    is += stride_a_l[i] * ic;\n    it_a = im_a;\n  }\n\n  data_out[id_a] = s[is];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olcf-tutorials/openmp_offloading/nested_tnsrtrns/tnsrtrns/1"}
{"code": "for (i = 0; i < 1024; ++i)\n  z[i] = (a * x[i]) + y[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/saxpy/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < 1100; j++)\n  {\n    flip_spin(spins, neighs, h, energy, gen, ran_u, ran_pos);\n  }\n\n  sum = abs(magnetization(spins));\n  chi = sum * sum;\n  heat = energy * energy;\n  m[MAG] += sum;\n  m[MAG2] += chi;\n  m[MAG4] += chi * chi;\n  m[ENE] += energy;\n  m[ENE2] += heat;\n  m[ENE4] += heat * heat;\n  m[MAGERR] += old_sum * sum;\n  m[SUSERR] += old_chi * chi;\n  m[ENERR] += old_energy * energy;\n  m[CHERR] += old_heat * heat;\n  old_sum = sum;\n  old_energy = energy;\n  old_chi = chi;\n  old_heat = heat;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/8"}
{"code": "for (i = 0; i < blockDimension; i++)\n{\n  final_board[i] = &final_board[0][i * blockDimension];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ippokratoys/Game-Of-Life-MPI-OpenMp-CUDA/openMp/9"}
{"code": "for (int i = 0; i < str_len; i++)\n{\n  cin >> a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_2/search/1"}
{"code": "for (int j = 0; j < y_points; j++)\n{\n  *(y + j) = j * del_y;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/2-D_NonLinear_Convection/2-D_Nonlinear_Convection_Dynamic/main/0"}
{"code": "for (int i = 0; i < w; i++)\n  for (int j = 0; j < h; j++)\n  f[i + (j * w)] = 1 - exp((-(((i - (w / 2)) * (i - (w / 2))) + ((j - (h / 2)) * (j - (h / 2))))) / ((2.0 * r) * r));\n\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/4"}
{"code": "for (j = 0; j < Low_w; j++)\n{\n  for (i = 0; i < Low_h; i++)\n  {\n    input_R[(i * Low_w) + j] = cvGetReal2D(r, i, j);\n    input_G[(i * Low_w) + j] = cvGetReal2D(g, i, j);\n    input_B[(i * Low_w) + j] = cvGetReal2D(b, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/78"}
{"code": "for (int i = 0; i < num_classes; i++)\n{\n  (cout << i) << \"\\t\";\n  for (int j = 0; j < num_classes; j++)\n  {\n    (cout << confuse[i][j]) << \"\\t\";\n    total += confuse[i][j];\n    if (i == j)\n      eq += confuse[i][j];\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/bgd/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src;\n  uint32_t dest = v;\n  uint64_t weight = DoubleToFixed64(0.0001f);\n  Nodes = graph->vertices[dest].outNodes;\n  degree = graph->vertices[dest].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    src = Nodes->dest;\n    Nodes = Nodes->next;\n    vector_output[dest] += MULFixed64V1(weight, vector_input[src]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/17"}
{"code": "for (int wp = img->whitePoint; wp != 0; wp >>= 1)\n  ++outputBits;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/VC5Decompressor/3"}
{"code": "for (uint i = 0; i < molKind.nonBonded.count; ++i)\n{\n  uint p1 = mols.start[molIndex] + molKind.nonBonded.part1[i];\n  uint p2 = mols.start[molIndex] + molKind.nonBonded.part2[i];\n  if (currentAxes.InRcut(distSq, currentCoords, p1, p2, box))\n  {\n    energy += forcefield.particles->CalcEn(distSq, molKind.AtomKind(molKind.nonBonded.part1[i]), molKind.AtomKind(molKind.nonBonded.part2[i]), 1.0);\n    if (electrostatic)\n    {\n      qi_qj_fact = (qqFact * molKind.AtomCharge(molKind.nonBonded.part1[i])) * molKind.AtomCharge(molKind.nonBonded.part2[i]);\n      if (qi_qj_fact != 0.0)\n      {\n        forcefield.particles->CalcCoulombAdd_1_4(energy, distSq, qi_qj_fact, true);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/12"}
{"code": "for (int y = 0; y <= maxNode; y++)\n{\n  numOutLinks[y] = 0;\n  for (int z = 0; z <= maxNode; z = z + 1)\n  {\n    numOutLinks[y] += M[z][y];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/natbprice/pagerank/Task 1/Task_1_Code/1"}
{"code": "for (int i = 0; i < Wx.size(); ++i)\n{\n  for (int j = 0; j < Rh[0].size(); ++j)\n  {\n    sum1[i][j] = Wx[i][j] + Rh[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_3/0"}
{"code": "for (int ii = 0; ii < sizearray3d; ii++)\n{\n  array3d[ii] = (rand() % 100) / 99.;\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/0"}
{"code": "for (i = 0; i < num_snakes; i++)\n{\n  if (snakes[i].direction == 'N')\n    snakes[i].future_head.line = ((snakes[i].head.line - 1) + num_lines) % num_lines;\n\n  if (snakes[i].direction == 'S')\n    snakes[i].future_head.line = (snakes[i].head.line + 1) % num_lines;\n\n  if (snakes[i].direction == 'E')\n    snakes[i].future_head.col = (snakes[i].head.col + 1) % num_cols;\n\n  if (snakes[i].direction == 'V')\n    snakes[i].future_head.col = ((snakes[i].head.col - 1) + num_cols) % num_cols;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nix151515/Parallel-snake/parallel_snake/1"}
{"code": "for (int i = 0; i < pixelList2.size(); i++)\n{\n  (((((((out << pixelList2[i][0]) << ',') << pixelList2[i][1]) << ',') << pixelList2[i][2]) << ',') << pixelList2[i][3]) << ',';\n  (((((((out << pixelList2[i][13]) << ',') << pixelList2[i][15]) << ',') << pixelList2[i][12]) << ',') << pixelList2[i][16]) << ',';\n  (((((((out << pixelList2[i][17]) << ',') << pixelList2[i][18]) << ',') << pixelList2[i][11]) << ',') << pixelList2[i][19]) << ',';\n  (((((((out << pixelList2[i][20]) << ',') << pixelList2[i][9]) << ',') << pixelList2[i][21]) << ',') << pixelList2[i][22]) << ',';\n  (((((((out << pixelList2[i][23]) << ',') << pixelList2[i][10]) << ',') << pixelList2[i][24]) << ',') << pixelList2[i][4]) << ',';\n  (((((((out << pixelList2[i][5]) << ',') << pixelList2[i][6]) << ',') << pixelList2[i][7]) << ',') << pixelList2[i][8]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/52"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt.c, strlen((char *) cur_salt->salt.c), cur_salt->iterations, (unsigned char *) crypt_out[index], 32, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/django_fmt_plug/1"}
{"code": "for (i = 0; i < 1024; i++)\n  a[i] = (i & 31) + (i / 128);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-6/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    vijk = vs[i][j][k];\n    vp1 = vs[i][j + 1][k];\n    vm1 = vs[i][j - 1][k];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dy1ty1 * ((u[i][j + 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j - 1][k][0]))) - (ty2 * (u[i][j + 1][k][2] - u[i][j - 1][k][2]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dy2ty1 * ((u[i][j + 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j - 1][k][1]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][1] * vp1) - (u[i][j - 1][k][1] * vm1)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dy3ty1 * ((u[i][j + 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j - 1][k][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[i][j + 1][k][2] * vp1) - (u[i][j - 1][k][2] * vm1)) + ((((u[i][j + 1][k][4] - square[i][j + 1][k]) - u[i][j - 1][k][4]) + square[i][j - 1][k]) * c2)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dy4ty1 * ((u[i][j + 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j - 1][k][3]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][3] * vp1) - (u[i][j - 1][k][3] * vm1)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dy5ty1 * ((u[i][j + 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j - 1][k][4]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[i][j + 1][k][4] * rho_i[i][j + 1][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j - 1][k][4] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[i][j + 1][k][4]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[i][j - 1][k][4]) - (c2 * square[i][j - 1][k])) * vm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(vijk, vp1, vm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/45"}
{"code": "for (l = 0; l < nz; l++)\n{\n  ll = nxye3 * l;\n  for (k = 0; k < ny; k++)\n  {\n    fxyz[(3 * (nx + (nxe * k))) + ll] = fxyz[((3 * nxe) * k) + ll];\n    fxyz[(1 + (3 * (nx + (nxe * k)))) + ll] = fxyz[(1 + ((3 * nxe) * k)) + ll];\n    fxyz[(2 + (3 * (nx + (nxe * k)))) + ll] = fxyz[(2 + ((3 * nxe) * k)) + ll];\n  }\n\n  for (j = 0; j < nx; j++)\n  {\n    fxyz[(3 * (j + (nxe * ny))) + ll] = fxyz[(3 * j) + ll];\n    fxyz[(1 + (3 * (j + (nxe * ny)))) + ll] = fxyz[(1 + (3 * j)) + ll];\n    fxyz[(2 + (3 * (j + (nxe * ny)))) + ll] = fxyz[(2 + (3 * j)) + ll];\n  }\n\n  fxyz[(3 * (nx + (nxe * ny))) + ll] = fxyz[ll];\n  fxyz[(1 + (3 * (nx + (nxe * ny)))) + ll] = fxyz[1 + ll];\n  fxyz[(2 + (3 * (nx + (nxe * ny)))) + ll] = fxyz[2 + ll];\n}\n\n", "pragma": "omp for nowait private(j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/8"}
{"code": "for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  sum = sum + (a[k] * p[colidx[k]]);\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/CG/cg_macc/7"}
{"code": "for (int thrd_i = 0; thrd_i < total_thrd; ++thrd_i)\n  ((((cout << \"Thread \") << thread_rows[thrd_i].first) << \" -> Processing Chunk starting at Row \") << thread_rows[thrd_i].second) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/changgyhub/distributed-systems/3 OpenMP/Sobel/2"}
{"code": "for (i = 0; i <= q_len; i++)\n{\n  array[i] = malloc((sizeof(int)) * (d_len + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkasfikis/Smith-Waterman-/myProj_OMP_FG/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int bnum = (int) ((((float) m) * (((float) list[i]) - minval)) / range);\n  --bnum;\n  if ((bnum >= m) || (countbucket[bnum] >= bsize))\n  {\n    (cout << \"error\\n\") << endl;\n    ((cout << \"bnum -\") << bnum) << \"\\n\";\n    ((cout << \"m -\") << m) << \"\\n\";\n    ((cout << \"list[i] -\") << list[i]) << \"\\n\";\n    ((cout << \"minval -\") << minval) << \"\\n\";\n    ((cout << \"range -\") << range) << \"\\n\";\n    exit(0);\n  }\n\n  bucket[bnum][countbucket[bnum]++] = list[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/BucketSort/1"}
{"code": "for (int i = 0; i < TEST_EXAMPLES; i++)\n{\n  activate_NN(TEST_DATA[i]);\n  max = OL2[0];\n  predicted_class = 0;\n  for (int j = 1; j < L2_NEURONS; j++)\n  {\n    if (OL2[j] > max)\n    {\n      max = OL2[j];\n      predicted_class = j;\n    }\n\n  }\n\n  if (predicted_class == TEST_CLASS[i])\n    correct++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/9"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB045-doall1-orig-no/1"}
{"code": "for (i = 0; i < MAX_KEY; i++)\n  prv_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/7"}
{"code": "for (l = 0; l < maxII; l++)\n{\n  int cost[3];\n  int tmp;\n  cost[0] = prev[l] + 1;\n  cost[1] = pprev[l] + (a[q] != b[p]);\n  cost[2] = prev[l + 1] + 1;\n  tmp = (cost[0] < cost[1]) ? (cost[0]) : (cost[1]);\n  tmp = (tmp < cost[2]) ? (tmp) : (cost[2]);\n  act[l] = tmp;\n  p++;\n  q--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/VecRec_Tasks/hirschberg_omp/4"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/125"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if ((i == 0) && (debug == 1))\n  {\n    printf(\"number of active threads\");\n  }\n  else\n    if (debug == 1)\n  {\n    printf(\"%i \", omp_get_num_threads());\n    printf(\"%i \\n\\r\", omp_get_thread_num());\n  }\n\n\n  for (int j = 0; j < size; j++)\n  {\n    for (int k = 0; k < size; k++)\n    {\n      result[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(numberThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sajidamro/eclipse-workspace/Lab_1/matrix_Multi/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (nza = 0; nza < arow[i]; nza++)\n  {\n    j = acol[i][nza];\n    scale = size * aelt[i][nza];\n    for (nzrow = 0; nzrow < arow[i]; nzrow++)\n    {\n      jcol = acol[i][nzrow];\n      va = aelt[i][nzrow] * scale;\n      if ((jcol == j) && (j == i))\n      {\n        va = (va + rcond) - shift;\n      }\n\n      goto_40 = FALSE;\n      for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n      {\n        if (colidx[k] > jcol)\n        {\n          for (kk = rowstr[j + 1] - 2; kk >= k; kk--)\n          {\n            if (colidx[kk] > (-1))\n            {\n              a[kk + 1] = a[kk];\n              colidx[kk + 1] = colidx[kk];\n            }\n\n          }\n\n          colidx[k] = jcol;\n          a[k] = 0.0;\n          goto_40 = TRUE;\n          break;\n        }\n        else\n          if (colidx[k] == (-1))\n        {\n          colidx[k] = jcol;\n          goto_40 = TRUE;\n          break;\n        }\n        else\n          if (colidx[k] == jcol)\n        {\n          nzloc[j] = nzloc[j] + 1;\n          goto_40 = TRUE;\n          break;\n        }\n\n\n\n      }\n\n      if (goto_40 == FALSE)\n      {\n        printf(\"internal error in sparse: i=%d\\n\", i);\n        exit(EXIT_FAILURE);\n      }\n\n      a[k] = a[k] + va;\n    }\n\n  }\n\n  size = size * ratio;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/21"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/FDTD-2D/fdtd2d_cpu/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((i != u) && (aRoute[i][v] != 0))\n  {\n    if (LookHorizontaly(i, v, u1, v1, n, m, aRoute) == 1)\n    {\n      for (j = 0; j < 100; j++)\n      {\n        if ((aPath[j][0] == (-12345)) && (aPath[j][1] == (-12345)))\n        {\n          aPath[j][0] = i;\n          aPath[j][1] = v;\n          return 1;\n        }\n\n      }\n\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trannguyendev/transportation-problem/ss/7"}
{"code": "for (int i = 0; i < len; i++)\n  host_arr[i].copy_to_device();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/mymapper/main/3"}
{"code": "for (unsigned int i = 0; i > dim; i++)\n{\n  if (get(part, dim, i, index_cluster) > buf[i])\n  {\n    set(part, dim, i, index_cluster, buf[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/4"}
{"code": "for (iter = 0; iter < my_args.iterations; iter++)\n{\n  r_index = iter % 2;\n  flag_corner_ul = 0;\n  flag_corner_ur = 0;\n  flag_corner_ll = 0;\n  flag_corner_lr = 0;\n  MPI_Startall(NUM_NEIGHBOURS, send_requests[r_index]);\n  for (i = 2; i < my_height; i++)\n  {\n    for (j = 2 * mult; j < my_width; j++)\n    {\n      (*im_after)[i][j] = (int) ((((((((((*im_before)[i][j] * my_args.filter[1][1]) + ((*im_before)[i - 1][j] * my_args.filter[0][1])) + ((*im_before)[i - 1][j + mult] * my_args.filter[0][2])) + ((*im_before)[i][j + mult] * my_args.filter[1][2])) + ((*im_before)[i + 1][j + mult] * my_args.filter[2][2])) + ((*im_before)[i + 1][j] * my_args.filter[2][1])) + ((*im_before)[i + 1][j - mult] * my_args.filter[2][0])) + ((*im_before)[i][j - mult] * my_args.filter[1][0])) + ((*im_before)[i - 1][j - mult] * my_args.filter[0][0]));\n      if ((*im_after)[i][j] < 0)\n        (*im_after)[i][j] = 0;\n      else\n        if ((*im_after)[i][j] > 255)\n        (*im_after)[i][j] = 255;\n\n\n    }\n\n  }\n\n  MPI_Startall(NUM_NEIGHBOURS, recv_requests[r_index]);\n  for (k = 0; k < NUM_NEIGHBOURS; k++)\n  {\n    MPI_Waitany(NUM_NEIGHBOURS, recv_requests[r_index], &index, &recv_stat);\n    if (index == N)\n    {\n      flag_corner_ul++;\n      flag_corner_ur++;\n      for (j = 2 * mult; j < my_width; j++)\n      {\n        (*im_after)[1][j] = (int) ((((((((((*im_before)[1][j] * my_args.filter[1][1]) + ((*im_before)[0][j] * my_args.filter[0][1])) + ((*im_before)[0][j + mult] * my_args.filter[0][2])) + ((*im_before)[1][j + mult] * my_args.filter[1][2])) + ((*im_before)[2][j + mult] * my_args.filter[2][2])) + ((*im_before)[2][j] * my_args.filter[2][1])) + ((*im_before)[2][j - mult] * my_args.filter[2][0])) + ((*im_before)[1][j - mult] * my_args.filter[1][0])) + ((*im_before)[0][j - mult] * my_args.filter[0][0]));\n        if ((*im_after)[1][j] < 0)\n          (*im_after)[1][j] = 0;\n        else\n          if ((*im_after)[1][j] > 255)\n          (*im_after)[1][j] = 255;\n\n\n      }\n\n    }\n    else\n      if (index == NE)\n    {\n      flag_corner_ur++;\n    }\n    else\n      if (index == E)\n    {\n      flag_corner_ur++;\n      flag_corner_lr++;\n      for (i = 2; i < my_height; i++)\n      {\n        for (j = 0; j < mult; j++)\n        {\n          (*im_after)[i][my_width + j] = (int) ((((((((((*im_before)[i][my_width + j] * my_args.filter[1][1]) + ((*im_before)[i - 1][my_width + j] * my_args.filter[0][1])) + ((*im_before)[i - 1][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[i][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[i + 1][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[i + 1][my_width + j] * my_args.filter[2][1])) + ((*im_before)[i + 1][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[i][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[i - 1][my_width_decr_1 + j] * my_args.filter[0][0]));\n          if ((*im_after)[i][my_width + j] < 0)\n            (*im_after)[i][my_width + j] = 0;\n          else\n            if ((*im_after)[i][my_width + j] > 255)\n            (*im_after)[i][my_width + j] = 255;\n\n\n        }\n\n      }\n\n    }\n    else\n      if (index == SE)\n    {\n      flag_corner_lr++;\n    }\n    else\n      if (index == S)\n    {\n      flag_corner_ll++;\n      flag_corner_lr++;\n      for (j = 2 * mult; j < my_width; j++)\n      {\n        (*im_after)[my_height][j] = (int) ((((((((((*im_before)[my_height][j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][j + mult] * my_args.filter[0][2])) + ((*im_before)[my_height][j + mult] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][j + mult] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][j - mult] * my_args.filter[2][0])) + ((*im_before)[my_height][j - mult] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][j - mult] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][j] < 0)\n          (*im_after)[my_height][j] = 0;\n        else\n          if ((*im_after)[my_height][j] > 255)\n          (*im_after)[my_height][j] = 255;\n\n\n      }\n\n    }\n    else\n      if (index == SW)\n    {\n      flag_corner_ll++;\n    }\n\n\n\n\n\n\n    if (index == W)\n    {\n      flag_corner_ul++;\n      flag_corner_ll++;\n      for (i = 2; i < my_height; i++)\n      {\n        for (j = 0; j < mult; j++)\n        {\n          (*im_after)[i][mult + j] = (int) ((((((((((*im_before)[i][mult + j] * my_args.filter[1][1]) + ((*im_before)[i - 1][mult + j] * my_args.filter[0][1])) + ((*im_before)[i - 1][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[i][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[i + 1][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[i + 1][mult + j] * my_args.filter[2][1])) + ((*im_before)[i + 1][j] * my_args.filter[2][0])) + ((*im_before)[i][j] * my_args.filter[1][0])) + ((*im_before)[i - 1][j] * my_args.filter[0][0]));\n          if ((*im_after)[i][mult + j] < 0)\n            (*im_after)[i][mult + j] = 0;\n          else\n            if ((*im_after)[i][mult + j] > 255)\n            (*im_after)[i][mult + j] = 255;\n\n\n        }\n\n      }\n\n    }\n\n    if (index == NW)\n    {\n      flag_corner_ul++;\n    }\n\n    if (flag_corner_ul == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[1][mult + j] = (int) ((((((((((*im_before)[1][mult + j] * my_args.filter[1][1]) + ((*im_before)[0][mult + j] * my_args.filter[0][1])) + ((*im_before)[0][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[1][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[2][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[2][mult + j] * my_args.filter[2][1])) + ((*im_before)[2][j] * my_args.filter[2][0])) + ((*im_before)[1][j] * my_args.filter[1][0])) + ((*im_before)[0][j] * my_args.filter[0][0]));\n        if ((*im_after)[1][mult + j] < 0)\n          (*im_after)[1][mult + j] = 0;\n        else\n          if ((*im_after)[1][mult + j] > 255)\n          (*im_after)[1][mult + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_ur == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[1][my_width + j] = (int) ((((((((((*im_before)[1][my_width + j] * my_args.filter[1][1]) + ((*im_before)[0][my_width + j] * my_args.filter[0][1])) + ((*im_before)[0][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[1][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[2][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[2][my_width + j] * my_args.filter[2][1])) + ((*im_before)[2][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[1][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[0][my_width_decr_1 + j] * my_args.filter[0][0]));\n        if ((*im_after)[1][my_width + j] < 0)\n          (*im_after)[1][my_width + j] = 0;\n        else\n          if ((*im_after)[1][my_width + j] > 255)\n          (*im_after)[1][my_width + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_lr == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[my_height][my_width + j] = (int) ((((((((((*im_before)[my_height][my_width + j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][my_width + j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][my_width_incr_1 + j] * my_args.filter[0][2])) + ((*im_before)[my_height][my_width_incr_1 + j] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][my_width_incr_1 + j] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][my_width + j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][my_width_decr_1 + j] * my_args.filter[2][0])) + ((*im_before)[my_height][my_width_decr_1 + j] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][my_width_decr_1 + j] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][my_width + j] < 0)\n          (*im_after)[my_height][my_width + j] = 0;\n        else\n          if ((*im_after)[my_height][my_width + j] > 255)\n          (*im_after)[my_height][my_width + j] = 255;\n\n\n      }\n\n    }\n\n    if (flag_corner_ll == 3)\n    {\n      for (j = 0; j < mult; j++)\n      {\n        (*im_after)[my_height][mult + j] = (int) ((((((((((*im_before)[my_height][mult + j] * my_args.filter[1][1]) + ((*im_before)[my_height_decr_1][mult + j] * my_args.filter[0][1])) + ((*im_before)[my_height_decr_1][mult_multi_2 + j] * my_args.filter[0][2])) + ((*im_before)[my_height][mult_multi_2 + j] * my_args.filter[1][2])) + ((*im_before)[my_height_incr_1][mult_multi_2 + j] * my_args.filter[2][2])) + ((*im_before)[my_height_incr_1][mult + j] * my_args.filter[2][1])) + ((*im_before)[my_height_incr_1][j] * my_args.filter[2][0])) + ((*im_before)[my_height][j] * my_args.filter[1][0])) + ((*im_before)[my_height_decr_1][j] * my_args.filter[0][0]));\n        if ((*im_after)[my_height][mult + j] < 0)\n          (*im_after)[my_height][mult + j] = 0;\n        else\n          if ((*im_after)[my_height][mult + j] > 255)\n          (*im_after)[my_height][mult + j] = 255;\n\n\n      }\n\n    }\n\n  }\n\n  MPI_Waitall(NUM_NEIGHBOURS, send_requests[r_index], (MPI_Status *) 1);\n  tmp = im_before;\n  im_before = im_after;\n  im_after = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/8"}
{"code": "for (i = 0; i < numberOfTours; i++)\n{\n  if (distanceArray[i] < firstTourIndex.max)\n  {\n    secondTourIndex.max = firstTourIndex.max;\n    secondTourIndex.cityIndex = firstTourIndex.cityIndex;\n    firstTourIndex.max = distanceArray[i];\n    firstTourIndex.cityIndex = i;\n  }\n  else\n    if (distanceArray[i] < secondTourIndex.max)\n  {\n    secondTourIndex.max = distanceArray[i];\n    secondTourIndex.cityIndex = i;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n3nash/Parallel-travellingsalesman/IndMPINode/1"}
{"code": "for (i = 0; i < N; ++i)\n{\n  t1 = omp_get_wtime();\n  sleep(duration[i]);\n  t2 = omp_get_wtime();\n  printf(\"Iteration %d: Thread %d, started %e, duration %e\\n\", i, omp_get_thread_num(), (double) (t1 - t0), (double) (t2 - t1));\n}\n\n", "pragma": "omp for schedule(static,bsize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xi-liu-cs/mpi-openmp-cuda-project/openmp/2022.4.5/0"}
{"code": "for (j = 0; j < NUM_BUCKETS; j++)\n{\n  k1 = (j > 0) ? (bucket_ptrs[j - 1]) : (0);\n  for (i = k1; i < bucket_ptrs[j]; i++)\n  {\n    k = --key_buff_ptr_global[key_buff2[i]];\n    key_array[k] = key_buff2[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(i,j,k,k1) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/2"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  cudaStatus = cudaMalloc(&coordsProducts, allProducts[i].dimensions * (sizeof(double)));\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaProducts);\n  cudaStatus = cudaMemcpy(coordsProducts, allProducts[i].coordinates, allProducts[i].dimensions * (sizeof(double)), cudaMemcpyHostToDevice);\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaProducts);\n  cudaStatus = cudaMemcpy(&cudaProducts[i].coordinates, &coordsProducts, sizeof(double *), cudaMemcpyHostToDevice);\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaProducts);\n}\n\n", "pragma": "#pragma omp parallel for private(coordsProducts)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/18"}
{"code": "for (i = 1; i < n; i++)\n{\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gabarnettjr/learningOpenmp/basicExample/main/0"}
{"code": "for (int i = z; i < (z + 8); i++)\n{\n  x += a[i];\n  *b += a[i] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/task-reduction-8/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  tids[i] = tid;\n}\n\n", "pragma": "omp for schedule(dynamic,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_schedule_dynamic/0"}
{"code": "for (irow = 0; irow < num_rows; irow++)\n{\n  Matrix[irow] = (float *) malloc(num_cols * (sizeof(float)));\n  for (icol = 0; icol < num_cols; icol++)\n  {\n    fscanf(fp, \"%f\", &Matrix[irow][icol]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/hybrid_matrix_multiply/1"}
{"code": "for (i = 0; i < (n + 2); i++)\n{\n  for (j = 0; j < (n + 2); j++)\n  {\n    if (strcmp(algo, \"jacobi\") == 0)\n    {\n      u_old[(i * (n + 2)) + j] = 0.0;\n    }\n\n    u_new[(i * (n + 2)) + j] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terkelbo/OpenMP-Poisson-Problem/src/inittools_ccnuma/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  diffs[i] = 0.0f;\n  nzeros[i] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/page-rank-omp/main/5"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < m; ++j)\n  if (A[(i * n) + j] > max_val)\n  max_val = A[(i * n) + j];\n\n\n\n", "pragma": "    #pragma omp parallel for default(none) shared(n,m,A) private(i,j) reduction(max:max_val)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex6-matrix-max-openmp-wo-cr/1"}
{"code": "for (i = 0; i < (d + 1); i++)\n  for (j = d; j > 0; j--)\n  for (k = 0; k < (d + 2); k++)\n  for (l = 0; l < (d + 4); l++)\n{\n  if (!e)\n    abort();\n\n}\n\n\n\n\n", "pragma": "omp for collapse(2) ordered(4) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-1/2"}
{"code": "for (int depth = start_y; depth < end_y; depth++)\n{\n  for (int row = 0; row < boundary_length; row++)\n  {\n    for (int column = start_x; column < end_x; column++)\n    {\n      property_array[((depth * nz_nx) + ((start_z + row) * nx)) + column] = 0;\n      property_array[((depth * nz_nx) + (((end_z - 1) - row) * nx)) + column] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp  parallel for  collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/ZeroExtension/2"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  (cout << I1[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  data[(i * n) + 4] -= media[4];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/10"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp8ezhg64f.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/projects/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (j = 1; j < (pcinfo.y_cells_num - 1); j++)\n{\n  for (i = 1; i < (pcinfo.x_cells_num - 1); i++)\n  {\n    int index_i = pcinfo.x_cell_pos + i;\n    int index_j = pcinfo.y_cell_pos + j;\n    df[(j * pcinfo.x_cells_num) + i] = ((((f[(j * pcinfo.x_cells_num) + i] - f[((j * pcinfo.x_cells_num) + i) - 1]) / hx_(index_i - 1)) - ((f[((j * pcinfo.x_cells_num) + i) + 1] - f[(j * pcinfo.x_cells_num) + i]) / hx_(index_i))) / hhx_(index_i)) + ((((f[(j * pcinfo.x_cells_num) + i] - f[((j - 1) * pcinfo.x_cells_num) + i]) / hy_(index_j - 1)) - ((f[((j + 1) * pcinfo.x_cells_num) + i] - f[(j * pcinfo.x_cells_num) + i]) / hy_(index_j))) / hhy_(index_j));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/1"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  kpic[k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/26"}
{"code": "for (int i = -1; i <= 1; i++)\n{\n  for (int j = -1; j <= 1; j++)\n  {\n    if (!((i == 0) && (j == 0)))\n    {\n      if ((((row + i) >= 0) && ((row + i) < this->gridRow)) && (((column + j) >= 0) && ((column + j) < this->gridColumn)))\n      {\n        neighbours.push_back(this->nextCellGrid[row + i][column + j]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/batux/parallel_conway_game_of_life/parallel_game_of_life/src/ParallelGameOfLife/2"}
{"code": "for (k = 0; k < 3; k++)\n{\n  for (j = 0; j < N_y; j++)\n  {\n    for (i = 0; i < N_x; i++)\n    {\n      tempPhi[i][j][k] = phi[i][j][k] + ((Delta_t / 2) * k1[i][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DeanJanami/ShallowWaterEquations/SWE_op/1"}
{"code": "for (k = 0; k < np; k++)\n{\n  amp_right[k] = complex(0., 0.);\n  amp_left[k] = complex(0., 0.);\n  for (int i = 0; i < n_SI; i++)\n  {\n    amp_right[k] += ((fac * exp(I * volkov_phase[k])) * exp(((-I) * p[k]) * wf.x1[i_right])) * (((-0.5) * right_2nd[i]) + ((I * Afield) * right_1st[i]));\n    amp_left[k] += ((fac * exp(I * volkov_phase[k])) * exp(((-I) * p[k]) * wf.x1[i_left])) * (((-0.5) * left_2nd[i]) + ((I * Afield) * left_1st[i]));\n  }\n\n}\n\n", "pragma": "    #pragma omp for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/43"}
{"code": "for (i = 0; i < n; i++)\n  p[i] = v1[i] * v2[i];\n\n", "pragma": "omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.54.6/0"}
{"code": "for (unsigned p = 0; p < np; p++)\n  if (errpart[p] == 1)\n{\n  code[p] = CODE_SetOutIgnore(code[p]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/7"}
{"code": "for (i = 0; i < size; i++)\n{\n  if ((i % 2) == 0)\n  {\n    *(outVectorPar + i) = applyFunction(inVector[i]);\n  }\n  else\n  {\n    *(outVectorPar + i) = inVector[i];\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/parallelfor-test/parallelfor/0"}
{"code": "for (int i = M - 100; i < M; ++i)\n{\n  (cout << alleleFreqVec[i]) << ' ';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/7"}
{"code": "for (i = 0; i < A->n; i++)\n{\n  y0 = 0;\n  is = A->ptr[i];\n  ie = A->ptr[i + 1];\n  for (j = is; j < ie; j++)\n  {\n    j0 = index[j];\n    y0 += value[j] * x[j0];\n  }\n\n  y[i] = y0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/spmv/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  x[i] = (y[i] + x[i + 1]) / 7;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment9/Task1/Dependency/4"}
{"code": "for (j = Neighbors->head; j < Neighbors->tail; j++)\n{\n  uint32_t i = Neighbors->queue[j];\n  uint32_t degreeUout = 0;\n  degreeUout = stats->atom[stats->dest[i]].pair.degree;\n  if (degreeUout != 4294967295U)\n  {\n    deltaQtemp = 2 * ((edgeWeightUV * numEdgesm) - ((float) ((degreeVout * degreeUout) * numEdgesm2)));\n    if (((*deltaQ) < deltaQtemp) && (i != v))\n    {\n      *deltaQ = deltaQtemp;\n      *u = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float zzz = ran0(z);\n  dum[i] = (int) (((v1 + ((v2 - v1) * zzz)) * ((float) c)) + zzz);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sg0/bin-packing/direct/bin_packing_omp_par/0"}
{"code": "for (row = 0; row < 1024; row++)\n  for (col = 0; col < 1024; col++)\n  Corg[(row * 1024) + col] = rand();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Indrasish117/Parallel-Matrix-multiplication-in-C-using-OpenMP/MatrixMul/2"}
{"code": "for (int i = 0; i < ArraySize; ++i)\n{\n  A[i] = i % 3;\n  B[i] = i % 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Smirnov-Mikhail/OpenMP/Task2/Task2/Task2/0"}
{"code": "for (int i = 0; i < V; i++)\n  dist[i] = INT_MAX;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/varun2011/openmp/bell/1"}
{"code": "for (unsigned int k = 0; k < mesh.voxels.size(); k++)\n{\n  gradient_vectors[k].resize(1);\n  gradient_vectors[k][0].resize(3, 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/2"}
{"code": "for (i = 0; i < n; ++i)\n  r += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/ex3/5"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = strtof(head, &tail);\n    if (tail == head)\n    {\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n    }\n\n    if (mat->rsizes[i] < 0)\n    {\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n      if (tail == head)\n      {\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n      }\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n      {\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n      }\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/60"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = 1; j < i; j++)\n  {\n    tmpsum += (j + pow(x + j, 1 / 5.)) / (((2 * i) * j) - 1);\n  }\n\n  if (tmpsum != 0)\n  {\n    sum += 1 / tmpsum;\n  }\n\n  tmpsum = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/19"}
{"code": "for (i = 1; i < 9; i++)\n{\n  x_temp = mov[0][i - 1] + pos_x;\n  y_temp = mov[1][i - 1] + pos_y;\n  if (((((x_temp < n) && (x_temp >= 0)) && (y_temp < m)) && (y_temp >= 0)) && (fricc[y_temp][x_temp] > 0.0))\n  {\n    count++;\n    if ((i % 2) != 0)\n    {\n      array[i - temp_temp].val_fricc = fricc[y_temp][x_temp];\n      array[i - temp_temp].x = x_temp;\n      array[i - temp_temp].y = y_temp;\n    }\n    else\n    {\n      array[i - temp_temp].val_fricc = sqrt(2) * fricc[y_temp][x_temp];\n      array[i - temp_temp].x = x_temp;\n      array[i - temp_temp].y = y_temp;\n    }\n\n  }\n  else\n  {\n    temp_temp++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,x_temp,y_temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/cost_dist/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  temp += x[i] * x[i];\n}\n\n", "pragma": "omp parallel for reduction(+:temp) num_threads(threads) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisaho/openmp/solver/4"}
{"code": "for (v = 0; v < V; v++)\n{\n  if ((graph[u][v] && (visited[v] == 0)) && (graph[u][v] < key[v]))\n    from[v] = u, key[v] = graph[u][v];\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parthvshah/parallel-prims/src/bench/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (A[i] == key)\n  {\n    printf(\"Key %d found at position %d: Thread %d\\n\", key, i, omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IT-Department-Labs/Parallel-Computing-Lab/Experiments/linear-search/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  c[i] = sqrt(a[i]) * sqrt(b[i]);\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/math_sqrt_float/math_sqrt_float/0"}
{"code": "for (int idx = 0; idx < data_size; idx++)\n{\n  float angle_out[NUM_JOINTS];\n  float curr_xTargetIn = xTarget_in_h[idx];\n  float curr_yTargetIn = yTarget_in_h[idx];\n  for (int i = 0; i < NUM_JOINTS; i++)\n  {\n    angle_out[i] = 0.0;\n  }\n\n  float angle;\n  float xData[NUM_JOINTS_P1];\n  float yData[NUM_JOINTS_P1];\n  for (int i = 0; i < NUM_JOINTS_P1; i++)\n  {\n    xData[i] = i;\n    yData[i] = 0.f;\n  }\n\n  for (int curr_loop = 0; curr_loop < MAX_LOOP; curr_loop++)\n  {\n    for (int iter = NUM_JOINTS; iter > 0; iter--)\n    {\n      float pe_x = xData[NUM_JOINTS];\n      float pe_y = yData[NUM_JOINTS];\n      float pc_x = xData[iter - 1];\n      float pc_y = yData[iter - 1];\n      float diff_pe_pc_x = pe_x - pc_x;\n      float diff_pe_pc_y = pe_y - pc_y;\n      float diff_tgt_pc_x = curr_xTargetIn - pc_x;\n      float diff_tgt_pc_y = curr_yTargetIn - pc_y;\n      float len_diff_pe_pc = sqrtf((diff_pe_pc_x * diff_pe_pc_x) + (diff_pe_pc_y * diff_pe_pc_y));\n      float len_diff_tgt_pc = sqrtf((diff_tgt_pc_x * diff_tgt_pc_x) + (diff_tgt_pc_y * diff_tgt_pc_y));\n      float a_x = diff_pe_pc_x / len_diff_pe_pc;\n      float a_y = diff_pe_pc_y / len_diff_pe_pc;\n      float b_x = diff_tgt_pc_x / len_diff_tgt_pc;\n      float b_y = diff_tgt_pc_y / len_diff_tgt_pc;\n      float a_dot_b = (a_x * b_x) + (a_y * b_y);\n      if (a_dot_b > 1.f)\n        a_dot_b = 1.f;\n      else\n        if (a_dot_b < (-1.f))\n        a_dot_b = -1.f;\n\n\n      angle = acosf(a_dot_b) * (180.f / PI);\n      float direction = (a_x * b_y) - (a_y * b_x);\n      if (direction < 0.f)\n        angle = -angle;\n\n      if (angle > 30.f)\n        angle = 30.f;\n      else\n        if (angle < (-30.f))\n        angle = -30.f;\n\n\n      angle_out[iter - 1] = angle;\n      for (int i = 0; i < NUM_JOINTS; i++)\n      {\n        if (i < (NUM_JOINTS - 1))\n        {\n          angle_out[i + 1] += angle_out[i];\n        }\n\n      }\n\n    }\n\n  }\n\n  angle_out_h[(idx * NUM_JOINTS) + 0] = angle_out[0];\n  angle_out_h[(idx * NUM_JOINTS) + 1] = angle_out[1];\n  angle_out_h[(idx * NUM_JOINTS) + 2] = angle_out[2];\n}\n\n", "pragma": "          #pragma omp target teams distribute parallel for simd thread_limit(BLOCK_SIZE) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/inversek2j-omp/main/2"}
{"code": "for (i = 0; i < Nnodes; i++)\n{\n  dot = 0;\n  for (j = 0; j < Nnodes; j++)\n  {\n    if (i != j)\n      dot += A[i][j] * x[j];\n\n  }\n\n  x_new = (((1 - 0.85) / Nnodes) - dot) / A[i][i];\n  dsum += (x[i] - x_new) * (x[i] - x_new);\n  x[i] = x_new;\n}\n\n", "pragma": "omp parallel for schedule(auto) private(j,dot,x_new) reduction(+:dsum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/0"}
{"code": "for (int neighbor_ind = row_ptr[vertex]; (neighbor_ind < row_ptr[vertex + 1]) && colorValid; neighbor_ind++)\n{\n  const uint neighbor = col_ind[neighbor_ind];\n  if (colors[neighbor] == minColor)\n  {\n    colorValid = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/11"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  tmp1 = 1.0 / u[i][j][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  fjac[i][j][k][0][0] = 0.0;\n  fjac[i][j][k][0][1] = 0.0;\n  fjac[i][j][k][0][2] = 0.0;\n  fjac[i][j][k][0][3] = 1.0;\n  fjac[i][j][k][0][4] = 0.0;\n  fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1;\n  fjac[i][j][k][1][2] = 0.0;\n  fjac[i][j][k][1][3] = u[i][j][k][1] * tmp1;\n  fjac[i][j][k][1][4] = 0.0;\n  fjac[i][j][k][2][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][2][1] = 0.0;\n  fjac[i][j][k][2][2] = u[i][j][k][3] * tmp1;\n  fjac[i][j][k][2][3] = u[i][j][k][2] * tmp1;\n  fjac[i][j][k][2][4] = 0.0;\n  fjac[i][j][k][3][0] = (-((u[i][j][k][3] * u[i][j][k][3]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][3][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n  fjac[i][j][k][3][2] = ((-c2) * u[i][j][k][2]) * tmp1;\n  fjac[i][j][k][3][3] = ((2.0 - c2) * u[i][j][k][3]) * tmp1;\n  fjac[i][j][k][3][4] = c2;\n  fjac[i][j][k][4][0] = (((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - (c1 * (u[i][j][k][4] * tmp1))) * (u[i][j][k][3] * tmp1);\n  fjac[i][j][k][4][1] = ((-c2) * (u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][4][2] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][4][3] = (c1 * (u[i][j][k][4] * tmp1)) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + ((3.0 * u[i][j][k][3]) * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][4][4] = (c1 * u[i][j][k][3]) * tmp1;\n  njac[i][j][k][0][0] = 0.0;\n  njac[i][j][k][0][1] = 0.0;\n  njac[i][j][k][0][2] = 0.0;\n  njac[i][j][k][0][3] = 0.0;\n  njac[i][j][k][0][4] = 0.0;\n  njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][1][1] = c3c4 * tmp1;\n  njac[i][j][k][1][2] = 0.0;\n  njac[i][j][k][1][3] = 0.0;\n  njac[i][j][k][1][4] = 0.0;\n  njac[i][j][k][2][0] = ((-c3c4) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][2][1] = 0.0;\n  njac[i][j][k][2][2] = c3c4 * tmp1;\n  njac[i][j][k][2][3] = 0.0;\n  njac[i][j][k][2][4] = 0.0;\n  njac[i][j][k][3][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][3][1] = 0.0;\n  njac[i][j][k][3][2] = 0.0;\n  njac[i][j][k][3][3] = ((con43 * c3) * c4) * tmp1;\n  njac[i][j][k][3][4] = 0.0;\n  njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c3c4 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - ((((con43 * c3c4) - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n  njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][4][2] = ((c3c4 - c1345) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][4][3] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][4][4] = c1345 * tmp1;\n}\n\n", "pragma": "omp parallel for firstprivate(c2 ,c1 ,c3c4 ,con43 ,c4 ,c3 ,c1345 ,k ,j ,i ,tmp1 ,tmp2 ,tmp3 ) lastprivate(tmp1 ,tmp2 ,tmp3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/64"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n  fprintf(stderr, \"%0.2lf \", w[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aleksyav/C-MPI-OMP-Gemver/OpenMP/gemver/5"}
{"code": "for (int i = (M * N) - ((M * N) % 4); i < (M * N); i++)\n{\n  C[i] *= beta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/6"}
{"code": "for (i = 1; i < LX1; i++)\n{\n  idmo[iel][face][0][1][LX1 - 1][i] = mor_s_v[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/30"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      Pworksx[LOC3D(i, j, k)] = (Pxfn[LOC4D(i, j, k, ns3)] * Parea[LOC4D(i, j, k, ns3)]) + (Pxfn[LOC4D(i - il1, j - jl1, k - kl1, ns3)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns3)]);\n      Pworksy[LOC3D(i, j, k)] = (Pyfn[LOC4D(i, j, k, ns3)] * Parea[LOC4D(i, j, k, ns3)]) + (Pyfn[LOC4D(i - il1, j - jl1, k - kl1, ns3)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns3)]);\n      Pworksz[LOC3D(i, j, k)] = (Pzfn[LOC4D(i, j, k, ns3)] * Parea[LOC4D(i, j, k, ns3)]) + (Pzfn[LOC4D(i - il1, j - jl1, k - kl1, ns3)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns3)]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t    #pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if ((j % 2) == 0)\n      m[i][j] = 2;\n    else\n      if ((i % 2) == 0)\n      m[i][j] = 3;\n    else\n      m[i][j] = 1;\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab4-Matrix_Sums/rowsum/2"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (5.0 * u[m][i][j][k])));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/131"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  ++(*size_colors)[color[i] - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/30"}
{"code": "for (i__ = 1; i__ <= i__1; ++i__)\n{\n  stemp += sx[i__] * sy[i__];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/46"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    lhs[1][i + 1][j][k] = lhs[1][i + 1][j][k] - comz4;\n    lhs[2][i + 1][j][k] = lhs[2][i + 1][j][k] + comz6;\n    lhs[3][i + 1][j][k] = lhs[3][i + 1][j][k] - comz4;\n    lhs[4][i + 1][j][k] = lhs[4][i + 1][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/21"}
{"code": "for (c2 = 0; c2 <= (nm + (-1)); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/74"}
{"code": "for (c1 = (nj > nk) ? (nj) : (nk); c1 <= (((ni + (-1)) < (nm + (-1))) ? (ni + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/14"}
{"code": "for (int r = 0; r < bmp->height; r++)\n{\n  for (int c = 0; c < bmp->width; c++)\n  {\n    unsigned char gray = ((bmp->copy_pixels[(r * bmp->width) + c].r * 0.3) + (bmp->copy_pixels[(r * bmp->width) + c].g * 0.59)) + (bmp->copy_pixels[(r * bmp->width) + c].b * 0.11);\n    bmp->pixels[(r * bmp->width) + c].r = gray;\n    bmp->pixels[(r * bmp->width) + c].g = gray;\n    bmp->pixels[(r * bmp->width) + c].b = gray;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Victohu1/ParallelImageProcessor/openmp_image_processor/1"}
{"code": "for (count = 0, resultrowptr = result, resultptr = result + (ncols * (nrows - 1)); count < ncols; resultptr++, resultrowptr++, count++)\n{\n  *resultrowptr = (*resultptr = (unsigned char) 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/18"}
{"code": "for (i = 0; i < N; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d: c[%d]= %f\\n\", tid, i, c[i]);\n}\n\n", "pragma": "#pragma omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/LoopWorkSharing/1"}
{"code": "for (d = 0; d < n_pr; d++)\n{\n  *x += buffers[d][0];\n  *y += buffers[d][1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/grid/11"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  z[i] = x[i] + y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw8/main/2"}
{"code": "for (size_t k = 0; k < natoms; ++k)\n{\n  if (mass_list.at(k) >= 3.0)\n  {\n    heavy_atom_matches.push_back(k);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/8"}
{"code": "for (i = 0; i < mat1_1d; i++)\n{\n  free(matr1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/10"}
{"code": "for (i = 0; i < 8; i++)\n{\n  id = omp_get_thread_num();\n  a = id + 1;\n  printf(\"a is %d from thread: %d\\n\", a, id);\n}\n\n", "pragma": "omp parallel for private(a,id) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/ordered/0"}
{"code": "for (i = 0; i < (H - h); i++)\n{\n  int tid = omp_get_thread_num();\n  for (j = 0; j < (W - w); j++)\n  {\n    sadValue = 0;\n    for (m = 0; m < h; m++)\n    {\n      for (n = 0; n < w; n++)\n      {\n        sadValue += abs(img[((i + m) * W) + (j + n)] - im_crop[(m * w) + n]);\n      }\n\n    }\n\n    if (sadValue < min_val[tid])\n    {\n      min_val[tid] = sadValue;\n      idx_i[tid] = i;\n      idx_j[tid] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j,m,n,sadValue)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhattagoutham/parallel-programming/2_template_matching/sad_omp/0"}
{"code": "for (i = 0; i < np; i++)\n  for (j = 0; j < np; j++)\n  C4[i][j] = ((DATA_TYPE) ((i * j) % np)) / np;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/doitgen/doitgen/3"}
{"code": "for (int i = 0; i < NumberOfBodies; i++)\n{\n  maxV = max(maxV, ((v[i][0] * v[i][0]) + (v[i][1] * v[i][1])) + (v[i][2] * v[i][2]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnabycollins/PSCI/step-4/5"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      zeta = ((double) k) * dnzm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[k][m] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m <= 4; m++)\n      {\n        buf[k][m] = dtpp * dtemp[m];\n      }\n\n      cuf[k] = buf[k][3] * buf[k][3];\n      buf[k][0] = (cuf[k] + (buf[k][1] * buf[k][1])) + (buf[k][2] * buf[k][2]);\n      q[k] = 0.5 * (((buf[k][1] * ue[k][1]) + (buf[k][2] * ue[k][2])) + (buf[k][3] * ue[k][3]));\n    }\n\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      km1 = k - 1;\n      kp1 = k + 1;\n      forcing[i][j][k][0] = (forcing[i][j][k][0] - (tz2 * (ue[kp1][3] - ue[km1][3]))) + (dz1tz1 * ((ue[kp1][0] - (2.0 * ue[k][0])) + ue[km1][0]));\n      forcing[i][j][k][1] = ((forcing[i][j][k][1] - (tz2 * ((ue[kp1][1] * buf[kp1][3]) - (ue[km1][1] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][1] - (2.0 * buf[k][1])) + buf[km1][1]))) + (dz2tz1 * ((ue[kp1][1] - (2.0 * ue[k][1])) + ue[km1][1]));\n      forcing[i][j][k][2] = ((forcing[i][j][k][2] - (tz2 * ((ue[kp1][2] * buf[kp1][3]) - (ue[km1][2] * buf[km1][3])))) + (zzcon2 * ((buf[kp1][2] - (2.0 * buf[k][2])) + buf[km1][2]))) + (dz3tz1 * ((ue[kp1][2] - (2.0 * ue[k][2])) + ue[km1][2]));\n      forcing[i][j][k][3] = ((forcing[i][j][k][3] - (tz2 * (((ue[kp1][3] * buf[kp1][3]) + (c2 * (ue[kp1][4] - q[kp1]))) - ((ue[km1][3] * buf[km1][3]) + (c2 * (ue[km1][4] - q[km1])))))) + (zzcon1 * ((buf[kp1][3] - (2.0 * buf[k][3])) + buf[km1][3]))) + (dz4tz1 * ((ue[kp1][3] - (2.0 * ue[k][3])) + ue[km1][3]));\n      forcing[i][j][k][4] = ((((forcing[i][j][k][4] - (tz2 * ((buf[kp1][3] * ((c1 * ue[kp1][4]) - (c2 * q[kp1]))) - (buf[km1][3] * ((c1 * ue[km1][4]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[kp1][0] - (2.0 * buf[k][0])) + buf[km1][0]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[kp1][4] - (2.0 * buf[k][4])) + buf[km1][4]))) + (dz5tz1 * ((ue[kp1][4] - (2.0 * ue[k][4])) + ue[km1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = 1;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[k][m]) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      k = 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[k - 1][m]) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (k = 1 * 3; k <= ((grid_points[2] - (3 * 1)) - 1); k++)\n      {\n        forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      k = grid_points[2] - 3;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])));\n      k = grid_points[2] - 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (5.0 * ue[k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/4"}
{"code": "for (unsigned n = 0; n < set->natoms; n++)\n{\n  set->speed.dx[n] -= normalized_vert[0] * g;\n  set->speed.dy[n] -= normalized_vert[1] * g;\n  set->speed.dz[n] -= normalized_vert[2] * g;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/openmp/2"}
{"code": "for (int j = 0; j < (particle.getNumberOfTriangles() * 3); j++)\n{\n  updateVertices(&particle._xCoordinates.data()[j], &particle._yCoordinates.data()[j], &particle._zCoordinates.data()[j], &particle._refxCoordinates.data()[j], &particle._refyCoordinates.data()[j], &particle._refzCoordinates.data()[j], particle._orientation.data(), particle._centreOfMass.data(), particle._refCentreOfMass.data());\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/core/Engine/3"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (d = 0; d < NDIM; d++)\n  {\n    cell(ci).setL(d, L.at(d));\n    cell(ci).setpbc(d, 1);\n  }\n\n  cell(ci).setNV(nvtmp);\n  cell(ci).initializeVertices();\n  cell(ci).initializeCell();\n  rtmp = 1.0;\n  a0tmp = ((0.5 * nvtmp) * pow(rtmp, 2.0)) * sin((2.0 * PI) / nvtmp);\n  l0tmp = (2.0 * rtmp) * sin(PI / nvtmp);\n  p0tmp = l0tmp * nvtmp;\n  cell(ci).seta0(a0tmp);\n  cell(ci).setl0(l0tmp);\n  cell(ci).setdel(1.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/61"}
{"code": "for (i1 = 0; i1 < (mm1 - 1); i1++)\n{\n  u[(2 * i3) + 1][(2 * i2) + 1][2 * i1] = u[(2 * i3) + 1][(2 * i2) + 1][2 * i1] + (0.25 * z3[i1]);\n  u[(2 * i3) + 1][(2 * i2) + 1][(2 * i1) + 1] = u[(2 * i3) + 1][(2 * i2) + 1][(2 * i1) + 1] + (0.125 * (z3[i1] + z3[i1 + 1]));\n}\n\n", "pragma": "omp parallel for firstprivate(mm1 ,u ,i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/11"}
{"code": "for (i = 0; i < (s + 2); i++)\n{\n  free(filter->array[i]);\n  filter->array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/filter_OMP/8"}
{"code": "for (j = 0; j < dimension; j++)\n{\n  temp = 0;\n  for (k = 0; k < dimension; k++)\n  {\n    temp = temp + (l[i][k] * u[k][j]);\n  }\n\n  if (abs(temp - a[i][j]) > 50)\n  {\n    x = abs(temp - a[i][j]);\n    printf(\"problem\");\n  }\n\n}\n\n", "pragma": "omp parallel for shared(u,l,a,i,dimension) private(j,k,temp,x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akash10nov/GaussianElimination/OpenMP/Matrix_decomp/2"}
{"code": "for (j = 0; j < M; j++)\n{\n  r = 0.0;\n  for (k = 0; k < M; k = k + 4)\n  {\n    r = r + (A[(i * M) + k] * B[(k * M) + j]);\n    r = r + (A[((i * M) + k) + 1] * B[((k + 1) * M) + j]);\n    r = r + (A[((i * M) + k) + 2] * B[((k + 2) * M) + j]);\n    r = r + (A[((i * M) + k) + 3] * B[((k + 3) * M) + j]);\n  }\n\n  C[(i * M) + j] = (alpha * r) + (beta * C[(i * M) + j]);\n}\n\n", "pragma": "omp parallel for reduction(+:r) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemm/5"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].update_dim_size(num_samples);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/12"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (j = jst; j < ny; j++)\n    {\n      tmp = 1.0 / rsd[0][k][j][i];\n      u21j = tmp * rsd[1][k][j][i];\n      u31j = tmp * rsd[2][k][j][i];\n      u41j = tmp * rsd[3][k][j][i];\n      u51j = tmp * rsd[4][k][j][i];\n      tmp = 1.0 / rsd[0][k][j - 1][i];\n      u21jm1 = tmp * rsd[1][k][j - 1][i];\n      u31jm1 = tmp * rsd[2][k][j - 1][i];\n      u41jm1 = tmp * rsd[3][k][j - 1][i];\n      u51jm1 = tmp * rsd[4][k][j - 1][i];\n      flux_G[1][k][i][j] = ty3 * (u21j - u21jm1);\n      flux_G[2][k][i][j] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux_G[3][k][i][j] = ty3 * (u41j - u41jm1);\n      flux_G[4][k][i][j] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/11"}
{"code": "for (int i = 0; i < count; ++i)\n{\n  in >> b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivam-anand/matPar/openmp/gauss/0"}
{"code": "for (int i = 0; i < n_features; i++)\n{\n  W[i] = (1.0 - (lr * lambda)) * W[i];\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/IPSC_Project/src/openmp/2"}
{"code": "for (j = 1; j <= (_PB_MAXGRID - 1); j++)\n  for (i = j; i <= (_PB_MAXGRID - 1); i++)\n  path[j][i] = path[j - 1][i - 1] + mean[j][i];\n\n\n", "pragma": "omp for private (i) collapse(2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/medley/reg_detect/reg_detect/3"}
{"code": "for (z = 0; z < StatesCols; z++)\n{\n  for (j = 0; j < StatesCols; j++)\n  {\n    number = (nodeArr[i][j].prob + transtion[j][z]) + nodeArr[i][j].func;\n    if ((number > nodeArr[i + 1][z].prob) || (nodeArr[i + 1][z].prob == 0))\n    {\n      nodeArr[i + 1][z].prob = number;\n      nodeArr[i + 1][z].parent = j;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for private(number,j,z)\t", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/15"}
{"code": "for (j = 0; j < num_bodies; j++)\n{\n  vhs.x = vel[j].x + ((force[j].x * time_step) / (2 * body_mass));\n  vhs.y = vel[j].y + ((force[j].y * time_step) / (2 * body_mass));\n  vhs.z = vel[j].z + ((force[j].z * time_step) / (2 * body_mass));\n  pos[j].x += vhs.x * time_step;\n  pos[j].y += vhs.y * time_step;\n  pos[j].z += vhs.z * time_step;\n  if ((pos[j].x - body_radius) < 0)\n    pos[j].x = body_radius;\n  else\n    if ((pos[j].x + body_radius) > length)\n    pos[j].x = length - body_radius;\n\n\n  if ((pos[j].y - body_radius) < 0)\n    pos[j].y = body_radius;\n  else\n    if ((pos[j].y + body_radius) > width)\n    pos[j].y = width - body_radius;\n\n\n  if ((pos[j].z - body_radius) < 0)\n    pos[j].z = body_radius;\n  else\n    if ((pos[j].z + body_radius) > depth)\n    pos[j].z = depth - body_radius;\n\n\n  vel[j].x = vhs.x + ((force[j].x * time_step) / (2 * body_mass));\n  vel[j].y = vhs.y + ((force[j].y * time_step) / (2 * body_mass));\n  vel[j].z = vhs.z + ((force[j].z * time_step) / (2 * body_mass));\n  if (((pos[j].x - body_radius) <= 0) || ((pos[j].x + body_radius) >= length))\n  {\n    vel[j].x = -vel[j].x;\n  }\n\n  if (((pos[j].y - body_radius) <= 0) || ((pos[j].y + body_radius) >= width))\n  {\n    vel[j].y = -vel[j].y;\n  }\n\n  if (((pos[j].z - body_radius) <= 0) || ((pos[j].z + body_radius) >= depth))\n  {\n    vel[j].z = -vel[j].z;\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejasPote/N-Body-OpenMP/many_body_sim_program/1"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) RHO[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/109"}
{"code": "for (row = 1; row < (height - 1); row++)\n{\n  for (col = 1; col < (width - 1); col++)\n  {\n    const size_t POS = (row * width) + col;\n    const size_t N = ((row - 1) * width) + col;\n    const size_t NE = ((row - 1) * width) + (col + 1);\n    const size_t E = (row * width) + (col + 1);\n    const size_t SE = ((row + 1) * width) + (col + 1);\n    const size_t S = ((row + 1) * width) + col;\n    const size_t SW = ((row + 1) * width) + (col - 1);\n    const size_t W = (row * width) + (col - 1);\n    const size_t NW = ((row - 1) * width) + (col - 1);\n    int val = gradientMagnitudes[POS];\n    if (val > 255)\n      val = 255;\n\n    switch ((int) edgeDirections[POS])\n    {\n      case 0:\n        if ((gradientMagnitudes[POS] <= gradientMagnitudes[E]) || (gradientMagnitudes[POS] <= gradientMagnitudes[W]))\n      {\n        edges[POS] = 0;\n      }\n      else\n      {\n        edges[POS] = val;\n      }\n\n        break;\n\n      case 45:\n        if ((gradientMagnitudes[POS] <= gradientMagnitudes[NE]) || (gradientMagnitudes[POS] <= gradientMagnitudes[SW]))\n      {\n        edges[POS] = 0;\n      }\n      else\n      {\n        edges[POS] = val;\n      }\n\n        break;\n\n      case 90:\n        if ((gradientMagnitudes[POS] <= gradientMagnitudes[N]) || (gradientMagnitudes[POS] <= gradientMagnitudes[S]))\n      {\n        edges[POS] = 0;\n      }\n      else\n      {\n        edges[POS] = val;\n      }\n\n        break;\n\n      case 135:\n        if ((gradientMagnitudes[POS] <= gradientMagnitudes[NW]) || (gradientMagnitudes[POS] <= gradientMagnitudes[SE]))\n      {\n        edges[POS] = 0;\n      }\n      else\n      {\n        edges[POS] = val;\n      }\n\n        break;\n\n      default:\n        edges[POS] = val;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/canny-edge-detection/OpenMP/processor/2"}
{"code": "for (i = 0; i < x; i++)\n  b[i] += 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/pr66714/0"}
{"code": "for (int _i0 = 1; _i0 <= R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 1; _i1 <= C; _i1 = _i1 + 1)\n  {\n    Iyy[(_i0 * (2 + C)) + _i1] = Iy[(_i0 * (2 + C)) + _i1] * Iy[(_i0 * (2 + C)) + _i1];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/2"}
{"code": "for (unsigned v = 0; v < ndv; v++)\n{\n  float val = Population[(minDex * ndv) + v];\n  printf(\"%f, \", val);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feildawproton/Genetic-Algorithm-with-OpenMP/GA/GA/11"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/105"}
{"code": "for (int i = 0; i < (*aNumberOfCentroids); i++)\n{\n  double dist = sqrt(pow((*aPoint).mX - aCentroids[i].mX, 2) + pow((*aPoint).mY - aCentroids[i].mY, 2));\n  if (dist < (*aPoint).mDistnceToCenter)\n  {\n    (*aPoint).mDistnceToCenter = dist;\n    (*aPoint).mCentroidId = aCentroids[i].mId;\n    return true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/3"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  if (v[i] != i)\n  {\n    printf(\"Check failed: v[%d]=%d, expected %d\\n\", i, v[i], i);\n    abort();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/omp-odd-even/3"}
{"code": "for (i = 1; i < (size - 1); i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    if (j == 0)\n    {\n      sum = ((((((A[size - 1][i + 1] + A[size - 1][i - 1]) + A[size - 2][i]) + Row[DOWN][i]) + A[size - 2][i - 1]) + A[size - 2][i + 1]) + Row[DOWN][i - 1]) + Row[DOWN][i + 1];\n      B[size - 1][i] = Populate(size - 1, i, sum, A);\n    }\n    else\n      if (j == 1)\n    {\n      sum = ((((((A[0][i + 1] + A[0][i - 1]) + A[1][i]) + Row[UP][i]) + A[1][i - 1]) + A[1][i + 1]) + Row[UP][i + 1]) + Row[UP][i - 1];\n      B[0][i] = Populate(0, i, sum, A);\n    }\n    else\n      if (j == 2)\n    {\n      sum = ((((((A[i][1] + A[i - 1][0]) + A[i + 1][0]) + Row[LEFT][i]) + A[i + 1][1]) + A[i - 1][1]) + Row[LEFT][i + 1]) + Row[LEFT][i - 1];\n      B[i][0] = Populate(i, 0, sum, A);\n    }\n    else\n    {\n      sum = ((((((A[i][size - 2] + A[i - 1][size - 1]) + A[i + 1][size - 1]) + Row[RIGHT][i]) + A[i - 1][size - 2]) + A[i + 1][size - 2]) + Row[RIGHT][i + 1]) + Row[RIGHT][i - 1];\n      B[i][size - 1] = Populate(i, size - 1, sum, A);\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taggelos/GameOfLife/Paradoteo/mpi_openmp/functions/1"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  for (size_t n = 0; n < this_nodes; n++)\n  {\n    double *sample_deltas = deltas + (s * deltas_size);\n    double *sample_prev_deltas = prev_deltas + (s * deltas_size);\n    double error = 0;\n    for (size_t next_n = 0; next_n < next_nodes; next_n++)\n    {\n      error += sample_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n    }\n\n    double output_val = this_outputs[(s * this_nodes) + n];\n    sample_deltas[n] = (error * output_val) * (1 - output_val);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU8/1"}
{"code": "for (int i = 0; i < An; i++)\n{\n  int nnzpv = nnzcum;\n  Crow[i] = nnzcum;\n  if ((nnzcum + An) > (*Csize))\n  {\n    *Csize += (An > ((*Csize) / 4)) ? (An) : ((*Csize) / 4);\n    *Ccol = realloc(*Ccol, (*Csize) * (sizeof(int)));\n  }\n\n  for (int jj = Arow[i]; jj < Arow[i + 1]; jj++)\n  {\n    int j = Acol[jj];\n    for (int kp = Brow[j]; kp < Brow[j + 1]; kp++)\n    {\n      int k = Bcol[kp];\n      if (!xb[k])\n      {\n        xb[k] = 1;\n        (*Ccol)[nnzcum] = k;\n        nnzcum++;\n      }\n\n    }\n\n  }\n\n  if (nnzcum > nnzpv)\n  {\n    quickSort(*Ccol, nnzpv, nnzcum - 1);\n    for (int p = nnzpv; p < nnzcum; p++)\n    {\n      xb[(*Ccol)[p]] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/old/SpGEMM_mpi_omp/1"}
{"code": "for (int i = 0; i < nweights; i++)\n{\n  weights[i] += p1 * weight_updates[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/connect-omp-cpu/6"}
{"code": "for (uint64_t i = 0; i < iterations; i++)\n{\n  double x = generator.rand2();\n  double y = generator.rand2();\n  if (((x * x) + (y * y)) <= 1.0)\n  {\n    if ((i % progress) == 0)\n    {\n    }\n\n    ++points_inside;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dtison/parallel-monte-carlo-pi/pi-omp/1"}
{"code": "for (int i = 0; i < n_unknowns; i++)\n{\n  x_temp[i] = 0.0;\n  b_temp[i] = 1.0 * h2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hariharas-wq/Parallelizing-deep-neural-networks-for-high-frequency-stock-prediction/ADA GRAD/ada_omp/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    s = 0.0;\n    for (k = 0; k < n; ++k)\n      s += ELEM(A, an, i, k) * ELEM(B, bn, k, j);\n\n    ELEM(C, cn, i, j) = s;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/non-automated/strassen/strassen/1"}
{"code": "for (long i = 1; i <= (step - 1); i++)\n{\n  double x = start + (((end - start) * i) / step);\n  omp_set_lock(&sum_lock);\n  middle_sum += fun(x);\n  omp_unset_lock(&sum_lock);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/J3FALL/HPC-OpenMP/integral/1"}
{"code": "for (y = 0; y < y_size1; y++)\n  for (x = 0; x < x_size1; x++)\n{\n  h1[image1[y][x]]++;\n}\n\n\n", "pragma": "omp for collapse(2) private(x,y,h1) schedule(static,5000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/neha-boloor/Parallel-Computing---Otsu/otsu_omp_critical/1"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int k = 0; k < 3; ++k)\n  {\n    v[i][k] *= lambda;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/6"}
{"code": "for (uint ix = 2; ix < (nx - 2); ++ix)\n{\n  for (uint iz = 2; iz < (nz - 2); ++iz)\n  {\n    vx[ix][iz] = taper[ix][iz] * (vx[ix][iz] + ((b_vx[ix][iz] * dt) * ((((coeff1 * (txx[ix][iz] - txx[ix - 1][iz])) + (coeff2 * (txx[ix - 2][iz] - txx[ix + 1][iz]))) / dx) + (((coeff1 * (txz[ix][iz] - txz[ix][iz - 1])) + (coeff2 * (txz[ix][iz - 2] - txz[ix][iz + 1]))) / dz))));\n    vz[ix][iz] = taper[ix][iz] * (vz[ix][iz] + ((b_vz[ix][iz] * dt) * ((((coeff1 * (txz[ix + 1][iz] - txz[ix][iz])) + (coeff2 * (txz[ix - 1][iz] - txz[ix + 2][iz]))) / dx) + (((coeff1 * (tzz[ix][iz + 1] - tzz[ix][iz])) + (coeff2 * (tzz[ix][iz - 1] - tzz[ix][iz + 2]))) / dz))));\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/larsgeb/fd-wave-modelling-gpu/main/3"}
{"code": "for (int i = 0; i < cant; i++)\n{\n  rango = omp_get_thread_num();\n  it = arreglo.begin() + (rango * quantity);\n  if ((it + quantity) != arreglo.end())\n  {\n    sort(it, it + quantity);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dess96/Paralela-openmp/Labs cortos/Ejercicio 3/Source/1"}
{"code": "for (int i = 0; i < thread_number; i++)\n{\n  temp[i] = malloc(column_size * (sizeof(double)));\n  result[i] = 0.0;\n  for (int j = 0; j < column_size; j++)\n    temp[i][j] = 0.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/3"}
{"code": "for (j = 0; j < uZ.ny; j++)\n{\n  factLat = (Dx * cosdeg(uZ.getY(0, j))) * Dy;\n  for (i = 0; i < uZ.nx; i++)\n    energy += pow(uZ(i, j), 2.) * factLat;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/13"}
{"code": "for (int y = 0; y < context->WindowSize.Height; ++y)\n  for (int x = 0; x < context->WindowSize.Width; ++x)\n{\n  const int index = Get1DIndexFrom2D(x, y, context->WindowSize.Width - 1);\n  const int colorValue = context->CurrentFrame[index];\n  if (colorValue != 0)\n    SDL_RenderDrawPoint(context->pRender, x, y);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rewlion/Concurrency/OpenMP-GameLife/source/Task2/main/0"}
{"code": "for (int i = 1; i < N; i++)\n{\n  for (int j = i; j < N; j++)\n  {\n    tmpsum2 += (j + pow(x + j, 1 / 3.)) / (((2 * i) * j) - 1);\n  }\n\n  sum += 1 / tmpsum2;\n  tmpsum2 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/1"}
{"code": "for (int jj = 0; jj < params.nx; jj++)\n{\n  if ((((!obstacles[(ii * params.nx) + jj]) && ((cells[(ii * params.nx) + jj].speeds[3] - w1) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[6] - w2) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[7] - w2) > 0.0))\n  {\n    cells[(ii * params.nx) + jj].speeds[1] += w1;\n    cells[(ii * params.nx) + jj].speeds[5] += w2;\n    cells[(ii * params.nx) + jj].speeds[8] += w2;\n    cells[(ii * params.nx) + jj].speeds[3] -= w1;\n    cells[(ii * params.nx) + jj].speeds[6] -= w2;\n    cells[(ii * params.nx) + jj].speeds[7] -= w2;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/borektsioglou/OpenMP/d2q9-bgk/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << TOTAL_KEYS_LOG_2) - 1)))\n    switch ('S')\n  {\n    case 'S':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'W':\n      if (i < 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'A':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'B':\n      if (((i == 1) || (i == 2)) || (i == 4))\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'C':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/57"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->present[i] == BOTTOMUP_NOT_VISITED_MARKER)\n  {\n    int start_edge = g->incoming_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->incoming_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int incoming = g->incoming_edges[neighbor];\n      if (frontier->present[incoming] == iteration)\n      {\n        distances[i] = distances[incoming] + 1;\n        local_count++;\n        frontier->present[i] = iteration + 1;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:local_count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chaihf/BFS-OpenMP/bfs/bfs/0"}
{"code": "for (i = 0; i < (SIMD_COEF_32 * SIMD_PARA_SHA1); i++)\n{\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, cur_salt->salt, cur_salt->saltSize);\n  SHA1_Update(&ctx, saved_key[idx + i], saved_len[idx + i]);\n  SHA1_Final(hashBuf, &ctx);\n  for (j = 4; j < 24; j++)\n    keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((j & (0xffffffff - 3)) * SIMD_COEF_32)) + (j & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = hashBuf[j - 4];\n\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((j & (0xffffffff - 3)) * SIMD_COEF_32)) + (j & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0x80;\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((63 & (0xffffffff - 3)) * SIMD_COEF_32)) + (63 & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 192;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/13"}
{"code": "for (i = 0; i < dim; i++)\n{\n  A[i] = random() % limit;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adricarda/parallel-Bucket-Sort/parallelBucketSort/parallelBucketSort/3"}
{"code": "for (int j = 0; j < m; j++)\n{\n  for (int i = n; i < (n + add_rows); i++)\n  {\n    grayContent[i][j] = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IGMercier/15418-S20-Parallel-Compression-/src/parallel_omp/src/compression/2"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  printf(\"array[%d] ==> %d \\n\", i, array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Elusive7733/OpenMP-vs-Pthread-vs-Serial-Sorting/OpenMP/MergeSort_OpenMP/3"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; ++j)\n  for (k = 0; k < N; ++k)\n{\n  bar();\n}\n\n\n\n", "pragma": "omp parallel for ordered(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/sink-fold-1/0"}
{"code": "for (l = 0; l < (ISIZ1 * ISIZ2); l++)\n{\n  for (n = 0; n < 5; n++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      a[n][m][l] = 0.0;\n      b[n][m][l] = 0.0;\n      c[n][m][l] = 0.0;\n      d[n][m][l] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/ssor/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpms5m8919.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (size_t i = 0; i < (network.size() - 1); i++)\n{\n  network[i].grad += (_lambda / _data_quantity) * network[i].theta;\n  network[i].grad.col(0) -= (_lambda / _data_quantity) * network[i].theta.col(0);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatheusNBDG/Neural-Network/network/3"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    mat1[i][j] = mat1[i][j] + mat2[i][j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp5/matrix-add/0"}
{"code": "for (int ieta = 0; ieta < eta_pts; ieta++)\n{\n  etaValues[ieta] = eta_tab->get(1, ieta + 1);\n  etaWeights[ieta] = eta_tab->get(2, ieta + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/2"}
{"code": "for (f = 0; f < TOPEF; f++)\n{\n  n = (rand() % TOPEF) + 1;\n  v[f] = n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nishi1612/High-Performance-Computing/Lab2/201601408-201601059-trapezoidal-critical/parallel_measurement/0"}
{"code": "for (i = 0; i < 10000; i++)\n  if (Buyers[i].quantityHeld == 1)\n{\n  sum += Buyers[i].price;\n  sum2 += pow(Buyers[i].price, 2);\n  N++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp1/5"}
{"code": "for (int r = 0; r < n; r++)\n{\n  for (int c = 0; c < k; c++)\n  {\n    buf[(c * n) + r] = rightMat[(r * k) + c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/mpi/matrixMulti/gemm/2"}
{"code": "for (int j = 1; j < numOfProcs; j++)\n{\n  MPI_Send(&qualityMeasure, 1, MPI_DOUBLE, j, MASTER, MPI_COMM_WORLD);\n  MPI_Send(allClusters, numOfClusters, ClusterMPIType, j, MASTER, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/0"}
{"code": "for (size_t k = 0; k < C_len; k++)\n{\n  C[k] += C_loc[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pepealessio/countingsort_openmp/source/counting_sort/6"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    Du[IDX(3, j, k)] = (((u[IDX(6, j, k)] - (3.0 * u[IDX(5, j, k)])) + (3.0 * u[IDX(4, j, k)])) - u[IDX(3, j, k)]) / smr3;\n    Du[IDX(4, j, k)] = ((((u[IDX(7, j, k)] - (6.0 * u[IDX(6, j, k)])) + (12.0 * u[IDX(5, j, k)])) - (10.0 * u[IDX(4, j, k)])) + (3.0 * u[IDX(3, j, k)])) / smr2;\n    Du[IDX(5, j, k)] = (((((u[IDX(8, j, k)] - (6.0 * u[IDX(7, j, k)])) + (15.0 * u[IDX(6, j, k)])) - (19.0 * u[IDX(5, j, k)])) + (12.0 * u[IDX(4, j, k)])) - (3.0 * u[IDX(3, j, k)])) / smr1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/38"}
{"code": "for (int i = last_sends[rank]; i < mpi_sends[rank].size(); i++)\n  if (mpi_sends[rank][i].done == 0)\n{\n  MPI_Type_size(mpi_sends[rank][i].datatype, &s);\n  mpi_sends[rank][i].dt_size = s;\n  sizes[rank] += s * mpi_sends[rank][i].count;\n  ns[rank]++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/5"}
{"code": "for (i = 0; i < 5; i++)\n  switch ('A')\n{\n  case 'S':\n    test_index_array[i] = S_test_index_array[i];\n    test_rank_array[i] = S_test_rank_array[i];\n    break;\n\n  case 'A':\n    test_index_array[i] = A_test_index_array[i];\n    test_rank_array[i] = A_test_rank_array[i];\n    break;\n\n  case 'W':\n    test_index_array[i] = W_test_index_array[i];\n    test_rank_array[i] = W_test_rank_array[i];\n    break;\n\n  case 'B':\n    test_index_array[i] = B_test_index_array[i];\n    test_rank_array[i] = B_test_rank_array[i];\n    break;\n\n  case 'C':\n    test_index_array[i] = C_test_index_array[i];\n    test_rank_array[i] = C_test_rank_array[i];\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/IS/is_single/1"}
{"code": "for (i = 0; i <= 524286; i += 1)\n{\n  prv_buff1[i + 1] += prv_buff1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/11"}
{"code": "for (size_t i = 0; i < part_size; i++)\n{\n  if ((*(begin + i)) > (*(rhs.begin + i)))\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keyzj-archive/dev_sort/HeapSort/src/main/main_packed/0"}
{"code": "for (size_t l = 1; l < MAX_THREADS; l++)\n{\n  sum_val += sum[l];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m7azeem/HPC-OpenMP/part3/1.4/without_critical_serial_sum/2"}
{"code": "for (i = 0; i < 2000; i++)\n  A[i] += 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/critical-2/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      xi = ((double) i) * dnxm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[m][i] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[m][i] = dtpp * dtemp[m];\n      }\n\n      cuf[i] = buf[1][i] * buf[1][i];\n      buf[0][i] = (cuf[i] + (buf[2][i] * buf[2][i])) + (buf[3][i] * buf[3][i]);\n      q[i] = 0.5 * (((buf[1][i] * ue[1][i]) + (buf[2][i] * ue[2][i])) + (buf[3][i] * ue[3][i]));\n    }\n\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      im1 = i - 1;\n      ip1 = i + 1;\n      forcing[k][j][i][0] = (forcing[k][j][i][0] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n      forcing[k][j][i][1] = ((forcing[k][j][i][1] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n      forcing[k][j][i][2] = ((forcing[k][j][i][2] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n      forcing[k][j][i][3] = ((forcing[k][j][i][3] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n      forcing[k][j][i][4] = ((((forcing[k][j][i][4] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = 1;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((5.0 * ue[m][i]) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      i = 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((((-4.0) * ue[m][i - 1]) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n    }\n\n    for (i = 3; i <= (grid_points[0] - 4); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = grid_points[0] - 3;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])));\n      i = grid_points[0] - 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (5.0 * ue[m][i])));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/19"}
{"code": "for (int j = 0; j < array_length; j++)\n{\n  sum += array[j];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ciarancourtney/concurrent_openmp_opencl_examples/openmp_array_reduce/0"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  contadores[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raphael28/cp2018/Trabalho/Codigo/src/bucketSortPrl/0"}
{"code": "for (int from = Xi; from < (Xi + n); from++)\n{\n  for (int to = Xj; to < (Xj + n); to++)\n  {\n    if (((from != to) && (from != via)) && (to != via))\n    {\n      omp_set_lock(&dist_locks[from][to]);\n      dist[from][to] = min(dist[from][to], dist[from][via] + dist[via][to]);\n      omp_unset_lock(&dist_locks[from][to]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahzebp/floyd_warshall_parallel/openmp/1-recursive/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 100; j++)\n  {\n    test();\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hgc123123/openmp/double_for/1"}
{"code": "for (j = jbeg; j <= jfin; j += 1)\n{\n  jglob = j;\n  k = ki1;\n  phi1[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n  k = ki2;\n  phi2[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n}\n\n", "pragma": "omp parallel for private (k,jglob,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/68"}
{"code": "for (int i = 1; i < (1000000 + 1); i++)\n  A_ptr[i] = A_ptr[i - 1] + 5;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/0"}
{"code": "for (int i = 0; i <= M; i++)\n{\n  for (int j = 0; j <= N; j++)\n  {\n    tempCells[(i * M) + j] = cells[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WajWaraich/Cellular_Automata_Assignment_ParallelProgramming/mainwindow/1"}
{"code": "for (int n_thread = 1; n_thread <= 16; n_thread *= 2)\n{\n  omp_set_num_threads(n_thread);\n  parallelFilterFirst(((512 * 512) * 128) * n_thread, input_array, output_array, filter_len, filter_list);\n  memset(output_array, 0, ((512 * 512) * 128) * 16);\n  parallelDataFirst(((512 * 512) * 128) * n_thread, input_array, output_array, filter_len, filter_list);\n  memset(output_array, 0, ((512 * 512) * 128) * 16);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adiggo/openmp/source/filterScaleUp/3"}
{"code": "for (aabb2 = first_aabb; aabb2; aabb2 = aabb2->next)\n{\n  for (i = 0; i < 6; i++)\n    db[i] = aabb2->dbounds[i];\n\n  for (int level = aabb2->level; level <= maxlevel; level++)\n  {\n    for (int xi = db[0]; xi <= db[1]; xi++)\n    {\n      for (int yi = db[2]; yi <= db[3]; yi++)\n      {\n        for (int zi = db[4]; zi <= db[5]; zi++)\n        {\n          unsigned long hi = getVirtualAddress(level, xi, yi, zi) % sz;\n          Node * node;\n          for (node = table[hi]; node; node = node->next)\n          {\n            if (node->aabb == aabb2)\n              continue;\n\n            if ((((node->aabb->level == level) && (node->x == xi)) && (node->y == yi)) && (node->z == zi))\n            {\n              unsigned char mask;\n              if (aabb2->index <= node->aabb->index)\n              {\n                i = (aabb2->index * tested_rowsize) + (node->aabb->index >> 3);\n                mask = 1 << (node->aabb->index & 7);\n              }\n              else\n              {\n                i = (node->aabb->index * tested_rowsize) + (aabb2->index >> 3);\n                mask = 1 << (aabb2->index & 7);\n              }\n\n              dIASSERT((i >= 0) && (i < (tested_rowsize * n)));\n              if ((tested[i] & mask) == 0)\n              {\n                collideAABBs(aabb2->geom, node->aabb->geom, _data, callback);\n              }\n\n              tested[i] |= mask;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < 6; i++)\n      db[i] >>= 1;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zcl2016/Gazebo-exercise/gazebo7_7.14.0_exercise/deps/opende/src/collision_space/7"}
{"code": "for (i = 0; i < 100; i++)\n{\n  A[i] = rand() * dc_inv;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Reduction/C/reduction/3"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if ((i % 2) != 0)\n  {\n    omp_set_lock(&forks[i]);\n    printf(\"the philosopher %d took the fork on his left '\\n\", i);\n    omp_set_lock(&forks[i + 1]);\n    printf(\"the philosopher %d took the fork on his right '\\n\", i);\n    omp_unset_lock(&forks[i]);\n    printf(\"the philosopher %d released the fork on his left '\\n\", i);\n    omp_unset_lock(&forks[i + 1]);\n    printf(\"the philosopher %d released the fork on his right '\\n\", i);\n    printf(\"The philosopher %d has done eating '\\n\", i);\n  }\n  else\n  {\n    omp_set_lock(&forks[i + 1]);\n    printf(\"the philosopher %d took the fork on his right'\\n\", i);\n    omp_set_lock(&forks[i]);\n    printf(\"the philosopher %d took the fork his left '\\n\", i);\n    omp_unset_lock(&forks[i + 1]);\n    printf(\"the philosopher %d released the fork his right '\\n\", i);\n    omp_unset_lock(&forks[i]);\n    printf(\"the philosopher %d released the fork his left '\\n\", i);\n    printf(\"The philosopher %d has done eating '\\n\", i);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/philosopherPb/1"}
{"code": "for (i = 0; i < 10; i++)\n  vec[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/parallel/cluster-system/openmp/reduction-omp-carte/1"}
{"code": "for (int x = 0; x < 100; x++)\n  compute();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/parallel-processing/OpenMP-Nbody/nbody/0"}
{"code": "for (j = PosA - 1; j > relmaxpos[0]; --j)\n{\n  MaxB[MaxBcounter] = dash;\n  ++MaxBcounter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double xval = i * dx;\n  double h = sqrt(1 - pow(xval, 2));\n  sum += h * dx;\n}\n\n", "pragma": "omp parallel for num_threads(nthreads) reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-7-openmp/omp-pi/0"}
{"code": "for (i = 0; i < order; i++)\n{\n  for (j = 0; j < rrank; j++)\n  {\n    for (k = 0; k < rrank; k++)\n    {\n      int pos1 = (i * mult) + j;\n      int pos2 = (i * mult) + k;\n      int now = (((i * rrank) * rrank) + (j * rrank)) + k;\n      pre_check[now] = 0;\n      for (l = 0; l < dim[i]; l++)\n      {\n        pre_check[now] += FactorM[pos1 + (l * rrank)] * FactorM[pos2 + (l * rrank)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/11"}
{"code": "for (int i = 0; i < k; i++)\n{\n  memcpy(str_buffer, genes[i].c_str(), genes_length[i]);\n  MPI_Bcast(str_buffer, genes_length[i], MPI_CHAR, root, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing12/test/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/86"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  if (a[i][i] == 0.0)\n  {\n    printf(\"Mathematical Error!\");\n    exit(0);\n  }\n\n  for (j = i + 1; j < n; j++)\n  {\n    ratio = a[j][i] / a[i][i];\n    for (k = 0; k < (n + 1); k++)\n    {\n      a[j][k] = a[j][k] - (ratio * a[i][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/0"}
{"code": "for (row = xoffset; row < (xoffset + myxsize); row++)\n{\n  for (col = yoffset; col < (yoffset + myysize); col++)\n  {\n    s[row][col] = u[old][row + 1][col + 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/5"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    C[i][j] = 0;\n  }\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code7777/MatrixMultiplierParallelProcessing/hw1/2"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      Dyu[pp] = (((u[pp - (2 * nx)] - (8.0 * u[pp - nx])) + (8.0 * u[pp + nx])) - u[pp + (2 * nx)]) * idy_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/5"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  jglob = j;\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    exact(0, jglob, k, &u[0][j][k][0]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/142"}
{"code": "for (int w = 0; w < previousLayer->numberOfNodes; ++w)\n{\n  temp += previousLayer->nodes[w].output * node->weights[w];\n}\n\n", "pragma": "omp parallel for reduction(+: temp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/2"}
{"code": "for (uint i = 0; i <= N; i++)\n  isPrime[i] = 1;\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe/0"}
{"code": "for (i = 1; i <= DIM; i++)\n{\n  for (j = 1; j <= DIM; j++)\n  {\n    next_grid[(i * (DIM + 2)) + j] = (temp_grid[(i * (DIM + 2)) + j] + (parms.cx * ((temp_grid[((i + 1) * (DIM + 2)) + j] + temp_grid[((i - 1) * (DIM + 2)) + j]) - (2.0 * temp_grid[(i * (DIM + 2)) + j])))) + (parms.cy * ((temp_grid[(i * (DIM + 2)) + (j + 1)] + temp_grid[(i * (DIM + 2)) + (j - 1)]) - (2.0 * temp_grid[(i * (DIM + 2)) + j])));\n  }\n\n}\n\n", "pragma": "omp for schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nbishdev/2d-conduction-heat-parallel/src/OpenMP/main/0"}
{"code": "for (int _i = 1; _i < sN; _i++)\n  for (int _j = 1; _j < _M; _j++)\n{\n  int aux_size[3] = {0, 0, 0};\n  int aux_size2[3] = {0, 0, 0};\n  s->m3d_x = _i;\n  s->m3d_y = _j;\n  s->Bt = s->sBt;\n  vmul_T_3d_set_tmp(N, tmp, tmp_n, tmp2, tmp_n2);\n  if (toeplitz_mult_alg == 0)\n  {\n    for (int i = 1; i < K; i++)\n    {\n      double v = 0.0;\n      for (int j = 1; j <= i; j++)\n        v += s->Bt[idx(_i, _j, j)] * s->Tm[2][(i - j) + 1];\n\n      if (space_der == 1)\n        for (int j = i + 1; j < K; j++)\n        v -= s->Bt[idx(_i, _j, j)] * s->Tm[2][(j - i) + 1];\n\n\n      if (implicit_row_scaling == 1)\n        v /= s->RS[idx(_i, _j, i)];\n\n      r[idx(_i, _j, i)] += v * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n    }\n\n  }\n\n  if (toeplitz_mult_alg == 1)\n  {\n    for (int i = 1; i < K; i++)\n      tmp[1][i] = s->Bt[idx(_i, _j, i)];\n\n    Toeplitz_mult(s->Tm[2] + 1, tmp[1] + 1, tmp[0], K - 1, 1);\n    for (int i = 1; i < K; i++)\n    {\n      if (implicit_row_scaling == 1)\n        tmp[0][i - 1] /= s->RS[idx(_i, _j, i)];\n\n      r[idx(_i, _j, i)] += tmp[0][i - 1] * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n      ;\n    }\n\n  }\n\n  if (toeplitz_mult_alg == 2)\n  {\n    aux_size[0] = (aux_size2[0] = 0);\n    Tm_diags_mul_left(K, s, tmp[0], tmp_n[0], aux_size[0], r, 1, 0, _i, _j);\n    if (space_der == 1)\n      Tm_diags_mul_right(K, s, tmp2[0], tmp_n2[0], aux_size2[0], r, 0, _i, _j);\n\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2)\t\t\t\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/158"}
{"code": "for (long i = 0; i < size; i++)\n{\n  for (long j = 0; j < size; j++)\n  {\n    result[i] += matrix[i][j] * vector[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) collapse(2) shared(matrix,vector,result,size) schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Vector_Multiplication_Serial_Parallel/0"}
{"code": "for (int x = 0; x < 5; x++)\n{\n  i = omp_get_thread_num();\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jmanno1/OpenMP_playground/OpenMP/cases/2"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  double fjac[PROBLEM_SIZE + 1][5][5];\n  double njac[PROBLEM_SIZE + 1][5][5];\n  double lhs[PROBLEM_SIZE + 1][3][5][5];\n  double tmp1;\n  double tmp2;\n  double tmp3;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 0; i <= isize; i++)\n    {\n      tmp1 = rho_i[k][j][i];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i][0][0] = 0.0;\n      fjac[i][1][0] = 1.0;\n      fjac[i][2][0] = 0.0;\n      fjac[i][3][0] = 0.0;\n      fjac[i][4][0] = 0.0;\n      fjac[i][0][1] = (-((u[k][j][i][1] * tmp2) * u[k][j][i][1])) + (c2 * qs[k][j][i]);\n      fjac[i][1][1] = (2.0 - c2) * (u[k][j][i][1] / u[k][j][i][0]);\n      fjac[i][2][1] = (-c2) * (u[k][j][i][2] * tmp1);\n      fjac[i][3][1] = (-c2) * (u[k][j][i][3] * tmp1);\n      fjac[i][4][1] = c2;\n      fjac[i][0][2] = (-(u[k][j][i][1] * u[k][j][i][2])) * tmp2;\n      fjac[i][1][2] = u[k][j][i][2] * tmp1;\n      fjac[i][2][2] = u[k][j][i][1] * tmp1;\n      fjac[i][3][2] = 0.0;\n      fjac[i][4][2] = 0.0;\n      fjac[i][0][3] = (-(u[k][j][i][1] * u[k][j][i][3])) * tmp2;\n      fjac[i][1][3] = u[k][j][i][3] * tmp1;\n      fjac[i][2][3] = 0.0;\n      fjac[i][3][3] = u[k][j][i][1] * tmp1;\n      fjac[i][4][3] = 0.0;\n      fjac[i][0][4] = (((c2 * 2.0) * square[k][j][i]) - (c1 * u[k][j][i][4])) * (u[k][j][i][1] * tmp2);\n      fjac[i][1][4] = ((c1 * u[k][j][i][4]) * tmp1) - (c2 * (((u[k][j][i][1] * u[k][j][i][1]) * tmp2) + qs[k][j][i]));\n      fjac[i][2][4] = ((-c2) * (u[k][j][i][2] * u[k][j][i][1])) * tmp2;\n      fjac[i][3][4] = ((-c2) * (u[k][j][i][3] * u[k][j][i][1])) * tmp2;\n      fjac[i][4][4] = c1 * (u[k][j][i][1] * tmp1);\n      njac[i][0][0] = 0.0;\n      njac[i][1][0] = 0.0;\n      njac[i][2][0] = 0.0;\n      njac[i][3][0] = 0.0;\n      njac[i][4][0] = 0.0;\n      njac[i][0][1] = (((-con43) * c3c4) * tmp2) * u[k][j][i][1];\n      njac[i][1][1] = (con43 * c3c4) * tmp1;\n      njac[i][2][1] = 0.0;\n      njac[i][3][1] = 0.0;\n      njac[i][4][1] = 0.0;\n      njac[i][0][2] = ((-c3c4) * tmp2) * u[k][j][i][2];\n      njac[i][1][2] = 0.0;\n      njac[i][2][2] = c3c4 * tmp1;\n      njac[i][3][2] = 0.0;\n      njac[i][4][2] = 0.0;\n      njac[i][0][3] = ((-c3c4) * tmp2) * u[k][j][i][3];\n      njac[i][1][3] = 0.0;\n      njac[i][2][3] = 0.0;\n      njac[i][3][3] = c3c4 * tmp1;\n      njac[i][4][3] = 0.0;\n      njac[i][0][4] = (((((-((con43 * c3c4) - c1345)) * tmp3) * (u[k][j][i][1] * u[k][j][i][1])) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][2] * u[k][j][i][2]))) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][3] * u[k][j][i][3]))) - ((c1345 * tmp2) * u[k][j][i][4]);\n      njac[i][1][4] = (((con43 * c3c4) - c1345) * tmp2) * u[k][j][i][1];\n      njac[i][2][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][2];\n      njac[i][3][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][3];\n      njac[i][4][4] = c1345 * tmp1;\n    }\n\n    lhsinit(lhs, isize);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      tmp1 = dt * tx1;\n      tmp2 = dt * tx2;\n      lhs[i][AA][0][0] = (((-tmp2) * fjac[i - 1][0][0]) - (tmp1 * njac[i - 1][0][0])) - (tmp1 * dx1);\n      lhs[i][AA][1][0] = ((-tmp2) * fjac[i - 1][1][0]) - (tmp1 * njac[i - 1][1][0]);\n      lhs[i][AA][2][0] = ((-tmp2) * fjac[i - 1][2][0]) - (tmp1 * njac[i - 1][2][0]);\n      lhs[i][AA][3][0] = ((-tmp2) * fjac[i - 1][3][0]) - (tmp1 * njac[i - 1][3][0]);\n      lhs[i][AA][4][0] = ((-tmp2) * fjac[i - 1][4][0]) - (tmp1 * njac[i - 1][4][0]);\n      lhs[i][AA][0][1] = ((-tmp2) * fjac[i - 1][0][1]) - (tmp1 * njac[i - 1][0][1]);\n      lhs[i][AA][1][1] = (((-tmp2) * fjac[i - 1][1][1]) - (tmp1 * njac[i - 1][1][1])) - (tmp1 * dx2);\n      lhs[i][AA][2][1] = ((-tmp2) * fjac[i - 1][2][1]) - (tmp1 * njac[i - 1][2][1]);\n      lhs[i][AA][3][1] = ((-tmp2) * fjac[i - 1][3][1]) - (tmp1 * njac[i - 1][3][1]);\n      lhs[i][AA][4][1] = ((-tmp2) * fjac[i - 1][4][1]) - (tmp1 * njac[i - 1][4][1]);\n      lhs[i][AA][0][2] = ((-tmp2) * fjac[i - 1][0][2]) - (tmp1 * njac[i - 1][0][2]);\n      lhs[i][AA][1][2] = ((-tmp2) * fjac[i - 1][1][2]) - (tmp1 * njac[i - 1][1][2]);\n      lhs[i][AA][2][2] = (((-tmp2) * fjac[i - 1][2][2]) - (tmp1 * njac[i - 1][2][2])) - (tmp1 * dx3);\n      lhs[i][AA][3][2] = ((-tmp2) * fjac[i - 1][3][2]) - (tmp1 * njac[i - 1][3][2]);\n      lhs[i][AA][4][2] = ((-tmp2) * fjac[i - 1][4][2]) - (tmp1 * njac[i - 1][4][2]);\n      lhs[i][AA][0][3] = ((-tmp2) * fjac[i - 1][0][3]) - (tmp1 * njac[i - 1][0][3]);\n      lhs[i][AA][1][3] = ((-tmp2) * fjac[i - 1][1][3]) - (tmp1 * njac[i - 1][1][3]);\n      lhs[i][AA][2][3] = ((-tmp2) * fjac[i - 1][2][3]) - (tmp1 * njac[i - 1][2][3]);\n      lhs[i][AA][3][3] = (((-tmp2) * fjac[i - 1][3][3]) - (tmp1 * njac[i - 1][3][3])) - (tmp1 * dx4);\n      lhs[i][AA][4][3] = ((-tmp2) * fjac[i - 1][4][3]) - (tmp1 * njac[i - 1][4][3]);\n      lhs[i][AA][0][4] = ((-tmp2) * fjac[i - 1][0][4]) - (tmp1 * njac[i - 1][0][4]);\n      lhs[i][AA][1][4] = ((-tmp2) * fjac[i - 1][1][4]) - (tmp1 * njac[i - 1][1][4]);\n      lhs[i][AA][2][4] = ((-tmp2) * fjac[i - 1][2][4]) - (tmp1 * njac[i - 1][2][4]);\n      lhs[i][AA][3][4] = ((-tmp2) * fjac[i - 1][3][4]) - (tmp1 * njac[i - 1][3][4]);\n      lhs[i][AA][4][4] = (((-tmp2) * fjac[i - 1][4][4]) - (tmp1 * njac[i - 1][4][4])) - (tmp1 * dx5);\n      lhs[i][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][0][0])) + ((tmp1 * 2.0) * dx1);\n      lhs[i][BB][1][0] = (tmp1 * 2.0) * njac[i][1][0];\n      lhs[i][BB][2][0] = (tmp1 * 2.0) * njac[i][2][0];\n      lhs[i][BB][3][0] = (tmp1 * 2.0) * njac[i][3][0];\n      lhs[i][BB][4][0] = (tmp1 * 2.0) * njac[i][4][0];\n      lhs[i][BB][0][1] = (tmp1 * 2.0) * njac[i][0][1];\n      lhs[i][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][1][1])) + ((tmp1 * 2.0) * dx2);\n      lhs[i][BB][2][1] = (tmp1 * 2.0) * njac[i][2][1];\n      lhs[i][BB][3][1] = (tmp1 * 2.0) * njac[i][3][1];\n      lhs[i][BB][4][1] = (tmp1 * 2.0) * njac[i][4][1];\n      lhs[i][BB][0][2] = (tmp1 * 2.0) * njac[i][0][2];\n      lhs[i][BB][1][2] = (tmp1 * 2.0) * njac[i][1][2];\n      lhs[i][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][2][2])) + ((tmp1 * 2.0) * dx3);\n      lhs[i][BB][3][2] = (tmp1 * 2.0) * njac[i][3][2];\n      lhs[i][BB][4][2] = (tmp1 * 2.0) * njac[i][4][2];\n      lhs[i][BB][0][3] = (tmp1 * 2.0) * njac[i][0][3];\n      lhs[i][BB][1][3] = (tmp1 * 2.0) * njac[i][1][3];\n      lhs[i][BB][2][3] = (tmp1 * 2.0) * njac[i][2][3];\n      lhs[i][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][3][3])) + ((tmp1 * 2.0) * dx4);\n      lhs[i][BB][4][3] = (tmp1 * 2.0) * njac[i][4][3];\n      lhs[i][BB][0][4] = (tmp1 * 2.0) * njac[i][0][4];\n      lhs[i][BB][1][4] = (tmp1 * 2.0) * njac[i][1][4];\n      lhs[i][BB][2][4] = (tmp1 * 2.0) * njac[i][2][4];\n      lhs[i][BB][3][4] = (tmp1 * 2.0) * njac[i][3][4];\n      lhs[i][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][4][4])) + ((tmp1 * 2.0) * dx5);\n      lhs[i][CC][0][0] = ((tmp2 * fjac[i + 1][0][0]) - (tmp1 * njac[i + 1][0][0])) - (tmp1 * dx1);\n      lhs[i][CC][1][0] = (tmp2 * fjac[i + 1][1][0]) - (tmp1 * njac[i + 1][1][0]);\n      lhs[i][CC][2][0] = (tmp2 * fjac[i + 1][2][0]) - (tmp1 * njac[i + 1][2][0]);\n      lhs[i][CC][3][0] = (tmp2 * fjac[i + 1][3][0]) - (tmp1 * njac[i + 1][3][0]);\n      lhs[i][CC][4][0] = (tmp2 * fjac[i + 1][4][0]) - (tmp1 * njac[i + 1][4][0]);\n      lhs[i][CC][0][1] = (tmp2 * fjac[i + 1][0][1]) - (tmp1 * njac[i + 1][0][1]);\n      lhs[i][CC][1][1] = ((tmp2 * fjac[i + 1][1][1]) - (tmp1 * njac[i + 1][1][1])) - (tmp1 * dx2);\n      lhs[i][CC][2][1] = (tmp2 * fjac[i + 1][2][1]) - (tmp1 * njac[i + 1][2][1]);\n      lhs[i][CC][3][1] = (tmp2 * fjac[i + 1][3][1]) - (tmp1 * njac[i + 1][3][1]);\n      lhs[i][CC][4][1] = (tmp2 * fjac[i + 1][4][1]) - (tmp1 * njac[i + 1][4][1]);\n      lhs[i][CC][0][2] = (tmp2 * fjac[i + 1][0][2]) - (tmp1 * njac[i + 1][0][2]);\n      lhs[i][CC][1][2] = (tmp2 * fjac[i + 1][1][2]) - (tmp1 * njac[i + 1][1][2]);\n      lhs[i][CC][2][2] = ((tmp2 * fjac[i + 1][2][2]) - (tmp1 * njac[i + 1][2][2])) - (tmp1 * dx3);\n      lhs[i][CC][3][2] = (tmp2 * fjac[i + 1][3][2]) - (tmp1 * njac[i + 1][3][2]);\n      lhs[i][CC][4][2] = (tmp2 * fjac[i + 1][4][2]) - (tmp1 * njac[i + 1][4][2]);\n      lhs[i][CC][0][3] = (tmp2 * fjac[i + 1][0][3]) - (tmp1 * njac[i + 1][0][3]);\n      lhs[i][CC][1][3] = (tmp2 * fjac[i + 1][1][3]) - (tmp1 * njac[i + 1][1][3]);\n      lhs[i][CC][2][3] = (tmp2 * fjac[i + 1][2][3]) - (tmp1 * njac[i + 1][2][3]);\n      lhs[i][CC][3][3] = ((tmp2 * fjac[i + 1][3][3]) - (tmp1 * njac[i + 1][3][3])) - (tmp1 * dx4);\n      lhs[i][CC][4][3] = (tmp2 * fjac[i + 1][4][3]) - (tmp1 * njac[i + 1][4][3]);\n      lhs[i][CC][0][4] = (tmp2 * fjac[i + 1][0][4]) - (tmp1 * njac[i + 1][0][4]);\n      lhs[i][CC][1][4] = (tmp2 * fjac[i + 1][1][4]) - (tmp1 * njac[i + 1][1][4]);\n      lhs[i][CC][2][4] = (tmp2 * fjac[i + 1][2][4]) - (tmp1 * njac[i + 1][2][4]);\n      lhs[i][CC][3][4] = (tmp2 * fjac[i + 1][3][4]) - (tmp1 * njac[i + 1][3][4]);\n      lhs[i][CC][4][4] = ((tmp2 * fjac[i + 1][4][4]) - (tmp1 * njac[i + 1][4][4])) - (tmp1 * dx5);\n    }\n\n    binvcrhs(lhs[0][BB], lhs[0][CC], rhs[k][j][0]);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      matvec_sub(lhs[i][AA], rhs[k][j][i - 1], rhs[k][j][i]);\n      matmul_sub(lhs[i][AA], lhs[i - 1][CC], lhs[i][BB]);\n      binvcrhs(lhs[i][BB], lhs[i][CC], rhs[k][j][i]);\n    }\n\n    matvec_sub(lhs[isize][AA], rhs[k][j][isize - 1], rhs[k][j][isize]);\n    matmul_sub(lhs[isize][AA], lhs[isize - 1][CC], lhs[isize][BB]);\n    binvrhs(lhs[isize][BB], rhs[k][j][isize]);\n    for (i = isize - 1; i >= 0; i--)\n    {\n      for (m = 0; m < BLOCK_SIZE; m++)\n      {\n        for (n = 0; n < BLOCK_SIZE; n++)\n        {\n          rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[i][CC][n][m] * rhs[k][j][i + 1][n]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/37"}
{"code": "for (i = 0; i < n; ++i)\n  temp += (x[i] - r[s_mean]) * (x[i] - r[s_mean]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/main/1"}
{"code": "for (int it = 0; it < num_itr; it++)\n{\n  for (int i = 1; i < (y_points - 1); i++)\n  {\n    for (int j = 1; j < (x_points - 1); j++)\n    {\n      p_new[i][j] = ((((del_y * del_y) * (p[i][j + 1] + p[i][j - 1])) + ((del_x * del_x) * (p[i + 1][j] + p[i - 1][j]))) - ((((del_x * del_x) * del_y) * del_y) * b[i][j])) / (2 * ((del_x * del_x) + (del_y * del_y)));\n    }\n\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    p_new[i][0] = 0;\n    p_new[i][x_points - 1] = 0;\n  }\n\n  for (int j = 0; j < x_points; j++)\n  {\n    p_new[0][j] = 0;\n    p_new[y_points - 1][j] = 0;\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    for (int j = 0; j < x_points; j++)\n    {\n      p[i][j] = p_new[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Poissons Equation/2-D_Poissons_Equation/main/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (fabsf(finalVec[i] - finalVec_host[i]) > 1e-3)\n  {\n    printf(\"Result mismatch at index %d: %f(device)  %f(host)\\n\", i, finalVec[i], finalVec_host[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/4"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  result[i] = a[i] > b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/29"}
{"code": "for (i = 0; i < V; i++)\n{\n  dijkstra(i);\n  x = omp_get_num_threads();\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zsims92/All-Shortest-Paths-Optimized/allShortestPathsParallel/openmpDS/5"}
{"code": "for (int i = 0; i < alto; i++)\n{\n  for (int j = 0; j < ancho; j++)\n  {\n    padded_image[(((i + padding) * (ancho + padding_size)) + j) + padding] = out_arr[(i * ancho) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/3"}
{"code": "for (d1 = a1; d1 < b1; d1++)\n  for (d2 = a2; d2 < b2; d2++)\n  u[(d1 * 32) + d2] = v[(d1 * 32) + d2] + w[(d1 * 32) + d2];\n\n\n", "pragma": "omp parallel for simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) lastprivate(d1, d2) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_2_0_release/testsuite/libgomp.c/pr66199-1/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/5"}
{"code": "for (i = 1; i < (n - 1); i += 2)\n{\n  if (a1[i] > a1[i + 1])\n  {\n    temp = a1[i + 1];\n    a1[i + 1] = a1[i];\n    a1[i] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) default(none) shared(a1, n) private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/15"}
{"code": "for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  Bxc[i][j][k] = B0x * tanh((grid->getYC(i, j, k) - (Ly / 2)) / delta);\n  Byc[i][j][k] = B0y;\n  Bzc[i][j][k] = B0z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/75"}
{"code": "for (int k = 0; k < (len_a + 1); k++)\n{\n  DP_Results[k] = (short *) calloc(len_b + 1, sizeof(short));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/hybrid/row_wise_v2/row_wise_v2/5"}
{"code": "for (i = 0; i < 5; i++)\n{\n  if ((x[num][i] % 2) == 0)\n  {\n    count += 1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Constructs/master_construct/0"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = 0; kk < depth; ++kk)\n  {\n    int base = jj * _chunk.x;\n    buffer[base + ((HALO_PAD - kk) - 1)] = buffer[base + (HALO_PAD + kk)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/0"}
{"code": "for (j = 0; j < 1024; j++)\n{\n  for (i = 0; i < (1024 - 1); i++)\n  {\n    A[i][j] = (2.0 * A[i + 1][j]) + B[i + 1][j];\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A,B), private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Canario0/Openmp/Ejercicio1/Ejercicio1/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < STATES; j++)\n  {\n    printf(\"(%f, %d)  \", subMat[i][j].nodeProb, subMat[i][j].nodeParent);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/26"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < dim2; k++)\n    {\n      for (l = 0; l < dim3; l++)\n      {\n        long long rand = random();\n        if ((rand % nz_ratio) == 0)\n        {\n          int reduced_range = rand % range;\n          while (reduced_range == 0)\n          {\n            reduced_range = random() % range;\n          }\n\n          result[i][j][k][l] = reduced_range;\n        }\n        else\n        {\n          result[i][j][k][l] = 0;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetitSamuel/CNN_optimisation/conv-harness/6"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    ptrmatrixA[i][j] = ptrarrayA[(i * N) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/OMPmultMatrices/OMPmultMatrices/OMPmultMatrices/2"}
{"code": "for (i = 0; i < 24576; i++)\n{\n  for (j = 0; j < 24576; j++)\n  {\n    x1[i] = x1[i] + (a[(i * 24576) + j] * y1[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/MVT/mvt_cpu/9"}
{"code": "for (int steps = num_processes - 3; steps >= (num_processes % 3); steps -= 3)\n{\n  for (int move = 0; move < steps; move++)\n  {\n    if ((move != 0) || (steps != (num_processes - 3)))\n    {\n      shift_right(c[i], f[i], &b[i], rank, num_processes, num_particles_per_process);\n    }\n    else\n    {\n      compute_three_same_sets_forces(c[1], f[1], b[1], num_processes, num_particles);\n      compute_two_same_sets_forces(c[1], c[2], f[1], f[2], b[1], b[2], num_processes, num_particles);\n      compute_two_same_sets_forces(c[0], c[2], f[0], f[2], b[0], b[2], num_processes, num_particles);\n    }\n\n    if (steps == (num_processes - 3))\n    {\n      compute_two_same_sets_forces(c[1], c[0], f[1], f[0], b[1], b[0], num_processes, num_particles);\n    }\n\n    compute_unique_sets_forces(c[0], c[1], c[2], f[0], f[1], f[2], b[0], b[1], b[2], num_processes, num_particles);\n  }\n\n  i = (i + 1) % 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jankopanski/Three-Body-Problem/body3_mpi_omp/4"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  if (i == (iter / 2))\n  {\n    time1_local = omp_get_wtime();\n  }\n\n  evolve(u, w, h);\n  if (i == (iter / 2))\n  {\n    time2_local = omp_get_wtime();\n    elapsed_local = time2_local - time1_local;\n    printf(\"Evolve function time > %f \\n\", elapsed_local);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task3_gameoflife/gameoflife_omp/gameoflife/0"}
{"code": "for (int k = j + 1; k < N; k++)\n{\n  m = A[k][j] / A[j][j];\n  for (i = j; i < N; i++)\n  {\n    A[k][i] = A[k][i] - (m * A[j][i]);\n  }\n\n  b[k] = b[k] - (m * b[j]);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-5/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  if (A[i] != 1)\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, ((double) (2.0 + 3.0)) * 1, A[i]);\n    fail = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute/test/2"}
{"code": "for (l = 0; l < (N * N); l++)\n{\n  C[l] = C[l] * result;\n}\n\n", "pragma": "omp parallel for shared(C)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/4"}
{"code": "for (int i = 0; i < A_row; i++)\n{\n  for (int j = 0; j < B_col; j++)\n  {\n    fprintf(out, \"%d \", C[i][j]);\n  }\n\n  fprintf(out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coherent17/Matrix-Multiplication-optimize-by-OpenMP/Parallel_Matrix_Multiplication_With_Openmp/ijk_optimize/5"}
{"code": "for (i = 0; i < (c->nrows + 1); ++i)\n  printf(\"%u \", (int) c->rowPtr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/13"}
{"code": "for (int g = 0; g < egroups; g++)\n{\n  const float y2 = f2[g];\n  const float y3 = f3[g];\n  const float c0 = y2;\n  const float c1 = (y3 - y2) / dz;\n  q0[g] = c0 + (c1 * zin);\n  q1[g] = c1;\n  q2[g] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/0"}
{"code": "for (i = 0; i < h; i++)\n{\n  for (j = 0; j < w; j++)\n  {\n    out.arr[i][j] = truncate(img1.arr[i][j] + brichange) % 255;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for collapse(2) private(i,j) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Images/Ivpomp/7"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  pthread_join(p[i], NULL);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souravmohapatra/parallel_bfs/bfs_parallel/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  temp = unoptimized_parallel_dynamic(l, m, n, num_t, i);\n  average_dt += temp[0];\n  average_rate += temp[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/3"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_min = fmin(host_min, a[x] + b[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_min/1"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  x = i;\n  c[i] = i;\n}\n\n", "pragma": "omp parallel for private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_parallel_for_02/0"}
{"code": "for (i = 0; i < ndim; i++)\n{\n  amu[i] += amu[(i + (ndim * (nx + (nxe * ny)))) + (nnxye * nz)];\n  amu[(i + (ndim * (nx + (nxe * ny)))) + (nnxye * nz)] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/22"}
{"code": "for (int i = 0; i < partitions_outer_length; i++)\n{\n  partitions_inner_lengths[i] = rand() % 100;\n  partitions_length += partitions_inner_lengths[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/real_mapper/main/0"}
{"code": "for (int i = 0; i < ans.size(); i++)\n{\n  ans[i] = vec1[i] - vec2[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector/sub/0"}
{"code": "for (q = 0; q < nr_colors; q++)\n{\n  if (dist[q] > max)\n  {\n    max = dist[q];\n    pos = q;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SebastianEne/Tema-1-APD-problemaSenatori/1/3"}
{"code": "for (int i = 0; i < siz; i++)\n{\n  for (int j = 0; j < siz; j++)\n  {\n    grid[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/0"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n{\n  if (((i + j) % 7) == 0)\n    a[i][j] = 2.;\n  else\n    a[i][j] = 0.;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohinarora/OpenMP/Sparse_MatMul_OpenMP/M-M_omp_sparse/1"}
{"code": "for (z = 0; z < OMP_zMax; z++)\n{\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      double r = (conv[OMP_Index(x, y, z)] * f[OMP_Index(x, y, z)]) / sigma2;\n      r = (r * (2.38944 + (r * (0.950037 + r)))) / (4.65314 + (r * (2.57541 + (r * (1.48937 + r)))));\n      conv[OMP_Index(x, y, z)] -= f[OMP_Index(x, y, z)] * r;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(x,y,z) num_threads(16)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maeneka/Gaussian-Deblur-OpenMP/ompDeblur/4"}
{"code": "for (int region = 0; region < num_regions; region++)\n{\n  processSetCount = mandelbrotSetCount(inputs[region].real_lower, inputs[region].real_upper, inputs[region].img_lower, inputs[region].img_upper, inputs[region].num, inputs[region].maxiter, comm_size, world_rank);\n  MPI_Reduce(&processSetCount, &totalSetCount, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000003, 0, 1);\n  if (world_rank == 0)\n  {\n    inputs[region].result = totalSetCount;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongfeiyang/parallel-mandelbrot-set/mandelbrot/1"}
{"code": "for (int i = start; i < end; i++)\n{\n  if (fabs(data[i].data[dim] - median) < min_local)\n  {\n    min_local = fabs(data[i].data[dim] - median);\n    index_local = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erikalena/hpc_assignment2/src/sorting_data/1"}
{"code": "for (i = 0; i < 256; i++)\n{\n  p[i] = i * 3.14159;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/43"}
{"code": "for (unsigned long long int i = 0; i < 76; i++)\n{\n  printf(\"%06d \", p.path[i]);\n  if (((i + 1) % 10) == 0)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebaMederos/TSP-OpenMP/sim-ann/SA/4"}
{"code": "for (int i = 200; i > 100; i -= 2)\n  total += (4 * i) * i;\n\n", "pragma": "omp for schedule(dynamic) reduction(+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonibofarull/mini-openmp/miniomp/test/tfinal/2"}
{"code": "for (int row = 0; row < N; row++)\n{\n  rowsum = 0.0;\n  for (int col = 0; col < N; col++)\n  {\n    float value = rand() / ((double) 32767);\n    if (col == row)\n    {\n      A_d[col] = value;\n      B[col + (row * N)] = 0;\n    }\n    else\n      B[col + (row * N)] = value;\n\n    A[col + (row * N)] = value;\n    rowsum += value;\n  }\n\n  A[row + (row * N)] += rowsum;\n  A_d[row] += rowsum;\n  A_d[row] = 1.0f / A_d[row];\n  b[row] = rand() / ((float) 32767);\n  x[row] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AbduElturki/HPC-Jacobi/jacobi/3"}
{"code": "for (i = first; i < N; i += prime)\n  marked[i] = 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 10/prime/0"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    F[(i * 512) + j] = 0;\n    for (k = 0; k < 512; ++k)\n    {\n      F[(i * 512) + j] += C[(i * 512) + k] * D[(k * 512) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3MM/src/3mm/6"}
{"code": "for (int i = 0; i < M; i++)\n  for (int j = 0; j < N; j++)\n  A[(i * N) + j] = (i == j) ? (1.0) : ((j > i) ? (0.0) : ((drand48() * 2.0) - 1.0));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/sollve_vv/tests/5.0/application_kernels/lsms_triangular_packing/0"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  produit[i] = malloc((sizeof(int)) * 3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP2EX3/3"}
{"code": "for (int i = 1; i <= n_edges; i++)\n{\n  int node_out;\n  int node_in;\n  if (fscanf(f, \"%d %d\\n\", &node_out, &node_in) == 2)\n    nodes[node_out].out_nodes = push_front(nodes[node_out].out_nodes, node_in);\n\n  nodes[node_in].inc_degree++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kounelisagis/OpenMP-Topological-Sorting-Algorithm/parallel/3"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  if (in[i] > in[j])\n  pos[i]++;\n\n\n\n", "pragma": "omp parallel for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa09/silly/1"}
{"code": "for (int i = 0; i < NI; i++)\n{\n  B[i] = A[i];\n}\n\n", "pragma": "  #pragma omp parallel for use(hrw) module(loopback)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/loopback/sw/src/main/1"}
{"code": "for (nnz = 0, i = 0; i < nrows; i++)\n{\n  nnz += mat->rowptr[rind[i] + 1] - mat->rowptr[rind[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/19"}
{"code": "for (i = 0; i < StatesCols; i++)\n{\n  *((*trans) + i) = (float *) malloc((sizeof(float)) * StatesCols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/14"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  for (i = iend - 1; i >= ist; i--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[j][i][m] = omega * (((((udz[j][i][0][m] * v[k + 1][j][i][0]) + (udz[j][i][1][m] * v[k + 1][j][i][1])) + (udz[j][i][2][m] * v[k + 1][j][i][2])) + (udz[j][i][3][m] * v[k + 1][j][i][3])) + (udz[j][i][4][m] * v[k + 1][j][i][4]));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/3"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  nn = nnxhd * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nnxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nnxhyd * l1;\n      i1 = nn;\n      i0 = i1 + ll;\n      i1 += l1;\n      for (i = 0; i < nxh; i++)\n      {\n        for (jj = 0; jj < ndim; jj++)\n        {\n          t1 = f[(jj + (ndim * i)) + i1];\n          f[(jj + (ndim * i)) + i1] = f[(jj + (ndim * i)) + i0];\n          f[(jj + (ndim * i)) + i0] = t1;\n        }\n\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nnxhyd * (j + k1);\n        j2 = nnxhyd * (j + k2);\n        t1 = sct[kmr * j];\n        i1 = nn;\n        i0 = i1 + j1;\n        i1 += j2;\n        for (i = 0; i < nxh; i++)\n        {\n          for (jj = 0; jj < ndim; jj++)\n          {\n            t2 = t1 * f[(jj + (ndim * i)) + i1];\n            f[(jj + (ndim * i)) + i1] = f[(jj + (ndim * i)) + i0] - t2;\n            f[(jj + (ndim * i)) + i0] += t2;\n          }\n\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,jj,j1,j2,nn,ll,l1,i0,i1,t1,t2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/19"}
{"code": "for (n = 0; n <= N; ++n)\n{\n  printf(\"no_opt[%d]= %d\\n\", n, no_dependency_opt[n]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/loopd/5"}
{"code": "for (k = 0; k < n_row; k++)\n{\n  int swap;\n  int cRow;\n  cRow = cur_pos;\n  swap = *((A + k) + (cRow * n_col));\n  *((A + (cRow * n_col)) + k) = *((A + (row_pos * n_col)) + k);\n  *((A + (row_pos * n_col)) + k) = swap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ddsihongliang/ece_5720/hw2/hs983_hw2_openmp_sort_block/1"}
{"code": "for (int i = 0; i < 5000; i++)\n{\n  C[i] = 0.0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice8/4"}
{"code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  m = part[1 + (idimp * j)];\n  n = n / mx;\n  m = m / my;\n  m = n + (mx1 * m);\n  if (m < mxy1)\n  {\n    kpic[m] += 1;\n  }\n  else\n  {\n    ierr = (ierr > ((m - mxy1) + 1)) ? (ierr) : ((m - mxy1) + 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/27"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%d \", particleType[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/119"}
{"code": "for (int i = 0; i < k; i++)\n{\n  for (int j = 0; j < outClusters[i].size(); j++)\n  {\n    sum2[i] += outClusters[i][j][1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MohamedAhmedIsmail/Kmeans-OpenMp-and-Sequential/K-MeansDC/Source/7"}
{"code": "for (int j = 0; j < multitask_params->num_tries; j++)\n{\n  num_thr = 0;\n  for (int k = 0; k < range_threads; k++)\n  {\n    if (num_thr <= multitask_params->num_thr_end)\n    {\n      num_thr++;\n    }\n    else\n    {\n      break;\n    }\n\n    records[k].num_threads = num_thr;\n    records[k].processes = sysconf(_SC_NPROCESSORS_ONLN);\n    get_runtime_stats(&records[k]);\n    double start_time = omp_get_wtime();\n    run_multitask(num_thr);\n    double time = omp_get_wtime() - start_time;\n    results[k] = time;\n  }\n\n  int min_index = find_min(results, range_threads);\n  pthread_mutex_lock(&lock);\n  write_in_dataset(\"\", &records[min_index]);\n  pthread_mutex_unlock(&lock);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/34"}
{"code": "for (i = 0; i < str_len; ++i)\n{\n  rotations[i] = malloc((str_len + 1) * (sizeof(*(*rotations))));\n  strcpy(rotations[i], str);\n  rotations[i][str_len] = '\\0';\n  rotate_right(str);\n}\n\n", "pragma": "omp parallel for shared(i,rotations,str_len,str) schedule(dynamic) num_threads(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DragosUnguru/ParallelFrameworksAnalyze/parallel_encoder/0"}
{"code": "for (i = 0; i < 4096; i++)\n  for (j = 0; j < 4096; j++)\n  x1[i] += a[(i * 4096) + j] * y1[j];\n\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/8"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  for (int j = 0; j < Ndim; j++)\n  {\n    Cut_off_Ellipsoid.nM[i][j] = updated_Cut_off_Ellipsoid.nM[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/20"}
{"code": "for (int j = 0; j < cols; j++)\n{\n  result[j] = data[(0 * cols) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/pathfinder/pathfinder.ref/1"}
{"code": "for (p = vec; p < vec_end; p++)\n{\n  printf(\"%f \", *p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-7-openmp/omp_vectors/6"}
{"code": "for (int i = 2; i <= 16; i *= 2)\n{\n  ((cout << \"Number threads: \") << i) << endl;\n  start_time = omp_get_wtime();\n  result2 = get_max(array, n, 1, i);\n  time2 = omp_get_wtime() - start_time;\n  start_time = omp_get_wtime();\n  result3 = get_max(array, n, 2, i);\n  time3 = omp_get_wtime() - start_time;\n  ((cout << \"result with critical: \") << result2) << endl;\n  ((cout << \"time: \") << time2) << endl;\n  ((cout << \"result with reduction: \") << result2) << endl;\n  ((cout << \"time: \") << time3) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/max_of_vector/2"}
{"code": "for (int i = 0; i < (N - 1); ++i)\n{\n  N_array[i] = count;\n  if (i == 0)\n  {\n    not_prime[i] = 0;\n  }\n  else\n  {\n    not_prime[i] = 1;\n  }\n\n  count++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sm6412/Parallel-Computing-Assignments/OpenMP/genprimes/1"}
{"code": "for (int i = 100000 / 4; i < (100000 / 2); i++)\n{\n  int isHeavy = (rand() % 2) == 0;\n  if (isHeavy)\n    heavyTask();\n\n  task1(gl_taskData.execTasks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p3/task/3"}
{"code": "for (i = 0; i < b->size; i++)\n{\n  if (getBit(b, i))\n  {\n    inv_v = labels[i];\n    localFrontierQueue->queue[localFrontierQueue->tail] = inv_v;\n    localFrontierQueue->tail++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/arrayQueue/4"}
{"code": "for (i = stopFinWave; i >= startFinWave; i--)\n{\n  sprintf(outstr, \"%f,\", wavelen[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/18"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"Hello %d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philipaconrad/openmp-talk-code/exercises/hello-world/main/0"}
{"code": "for (idx_t x = 0; x < (rank * rank); ++x)\n{\n  av[x] = 1.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/20"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  for (i = iend - 1; i >= ist; i--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[j][i][m] = omega * (((((udz[j][i][0][m] * v[k + 1][j][i][0]) + (udz[j][i][1][m] * v[k + 1][j][i][1])) + (udz[j][i][2][m] * v[k + 1][j][i][2])) + (udz[j][i][3][m] * v[k + 1][j][i][3])) + (udz[j][i][4][m] * v[k + 1][j][i][4]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/buts/0"}
{"code": "for (i = 0; i < (n / 2); i++)\n{\n  v_b = _mm_loadu_pd(b + (i * 2));\n  v_a = _mm_loadu_pd(a + (i * 2));\n  v_a = _mm_add_pd(v_a, _mm_mul_pd(v_alpha, v_b));\n  _mm_storeu_pd(a, v_a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu_simd/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/nvptx_target_cuda_mode_messages/0"}
{"code": "for (mm = 0; mm < (SizeX - 1); mm++)\n{\n  Hy(mm) = (Chyh(mm) * Hy(mm)) + (Chye(mm) * (Ez(mm + 1) - Ez(mm)));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/milogoestocollege/fdtd4/fdtd4/update3/0"}
{"code": "for (unsigned int i = 0; i < triangle_side; ++i)\n{\n  for (unsigned int j = 0; j < triangle_side; ++j)\n  {\n    uint32_t x = compute_coord_owner_info_bgp(i, j, xlen, ylen, zlen, tlen);\n    owner_table[i][j] = x;\n    reverse_owner_table[x / nsubranks_1d][x % nsubranks_1d] = (i << 16) | j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/4"}
{"code": "for (int i = 0; i < n_walkers; i++)\n{\n  fprintf(walkOPEN, \"%f \", A[i]);\n  fprintf(walkOPEN, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juandapradam12/JuanPrada_Ejercicio30/walkOPEN/3"}
{"code": "for (int i = 0; i < order; i += 1)\n{\n  mask[i][0] = cornerX;\n  mask[i][1] = cornerY + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serrearthur/Fauxtoshop/source/src/base/mask/3"}
{"code": "for (int i = 0; i < shared_block.rowSize; i++)\n{\n  shared_block.mat[i][0] = i * gapPenalty;\n}\n\n", "pragma": "\t#pragma omp for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaraaSameer/Pairwise-Sequence-Alignment/SequenceAlgo_OpenMP/0"}
{"code": "for (unsigned int i = 0; i < (((2048 / 1) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((2048 / NODESY) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/66"}
{"code": "for (unsigned long long int i = 0; i <= n; i++)\n{\n  sum += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidWallacedot/openMP/parallel_sum/0"}
{"code": "for (int i = 0; i < vec.size(); i++)\n  printf(\"%d%c\", vec[i], (i < (vec.size() - 1)) ? (' ') : ('\\n'));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/radixSort/sort_radix/0"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    random_row = ((unsigned char) rand()) % 8;\n    POPULATION[i][j] = random_row;\n    NEW_POPULATION[i][j] = random_row;\n  }\n\n}\n\n", "pragma": "omp parallel for private(random_row)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.0/0"}
{"code": "for (int k = 0; k < WEEK_ARRAY_DIM; k++)\n{\n  temp_borough->weekAccidentsCounter[k] += b[i].weekAccidentsCounter[k];\n  temp_borough->weekLethal[k] += b[i].weekLethal[k];\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(temp_borough, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/borough/0"}
{"code": "for (long i = 0; i < 500; i++)\n{\n  for (long k = 0; k < 500; k++)\n  {\n    C[i][k] = 0;\n    for (long j = 0; j < 500; j++)\n    {\n      C[i][k] += A[i][j] * B[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q4/q4/0"}
{"code": "for (i = 0; i < NI; ++i)\n{\n  for (j = 0; j < NJ; ++j)\n  {\n    A[(i * NJ) + j] = ((float) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/1"}
{"code": "for (int i = 0; i < div; i++)\n  integral += paralel_integral(xmin + (i * delta), xmin + ((i + 1) * delta), n, i, div);\n\n", "pragma": "        #pragma omp parallel for reduction(+: integral) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joaocassianox7x/Parallel_Integral/paralel_integral/1"}
{"code": "for (long i = 0; i < 11; i++)\n{\n  result++;\n  result++;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_atomic/0"}
{"code": "for (unsigned int i = 0; i < mVectorsOfNeighNodes.size(); ++i)\n{\n  unsigned int n_neigh = mVectorsOfNeighNodes[i].size();\n  mVectorsOfRadii[i].resize(n_neigh);\n  for (unsigned int j = 0; j < n_neigh; ++j)\n  {\n    mVectorsOfRadii[i][j] = mVectorsOfNeighNodes[i][j]->FastGetSolutionStepValue(NODAL_AREA);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/3"}
{"code": "for (i = 0; i < matrixSize; i++)\n{\n  double *MHead = &M[i * matrixSize];\n  double tmp = 0;\n  for (j = 0; j < matrixSize; j++)\n  {\n    tmp += MHead[j] * V[j];\n  }\n\n  results[i] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/tasking/matrixTasking/1"}
{"code": "for (i = 0; i < col; i++)\n  printf(\"%d%c\", multVector[i], (i == (col - 1)) ? ('\\n') : (' '));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/sparceMatrix/sparceMatrix_parallel/10"}
{"code": "for (int i = 0; i < (pattlength - 1); i++)\n  h = (d * h) % prime;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RadhikaBailurkar/OpenMP/PatternSearch/0"}
{"code": "for (i = 0; i < (1 << MAX_KEY_LOG_2); i++)\n  key_buff1[i] += prv_buff1[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/56"}
{"code": "for (number >>= 2; number; number >>= 2)\n{\n  ret <<= 2;\n  ret |= number & 3;\n  count -= 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/immanuelsavio/Parallel-Processing-Using-OpenMP/radix4/2"}
{"code": "for (int i = 0; i < len; i++)\n{\n  output[i] = input[i] * SCALAR;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/0"}
{"code": "for (i = 0, aux = 0; i < nBuckets_r; i++)\n{\n  size_bucket = bucketsVector[i].total;\n  for (j = 0; j < size_bucket; j++)\n    r[aux + j] = bucketsVector[i].value[j];\n\n  aux += size_bucket;\n  free(bucketsVector[i].value);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PietroPan/Parallel-BucketSort/bucket_sort/3"}
{"code": "for (int i = 0; i < numProcs; ++i)\n{\n  slave.push_back(threadId);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shohirose/openmp-examples/src/gather/0"}
{"code": "for (size_t i_node = 0; i_node < rThisGeometry.size(); ++i_node)\n{\n  AtomicAddMatrix(rThisGeometry[i_node].GetValue(rThisVar), (N[i_node] * origin_value) * Weight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_processes/internal_variables_interpolation_process/2"}
{"code": "for (j = 0; j < 80000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KonstantinosKr/delta/meta/benchmark/ham7/stream/stream/5"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  while (1)\n  {\n    u1 = getRand(0, 1);\n    u2 = getRand(0, 1);\n    c1 = floor(u1 * n);\n    c2 = floor(u2 * n);\n    if (a[c1] != a[c2])\n      break;\n\n  }\n\n  temp = aux[c1];\n  aux[c1] = aux[c2];\n  aux[c2] = temp;\n  int newCost = getCost(D, aux, n);\n  int delta = newCost - cost;\n  double expo = exp(((double) (-delta)) / t);\n  double u = ((double) rand()) / 32767;\n  if ((delta < 0) || (expo >= u))\n  {\n    int t = a[c1];\n    a[c1] = a[c2];\n    a[c2] = t;\n    cost = newCost;\n    i = 0;\n  }\n  else\n  {\n    temp = aux[c2];\n    aux[c2] = aux[c1];\n    aux[c1] = temp;\n    i = i + 1;\n  }\n\n  t = 0.999 * t;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Mini Project - ROOM ASSIGNMENT/mpi_room_assignment/0"}
{"code": "for (j = ((0x7fffffffffffffffLL * 2ULL) + 1) - 3; j >= (0x7fffffffffffffffLL + 70ULL); j -= 0x7fffffffffffffffLL + 50ULL)\n{\n  if (j == (((0x7fffffffffffffffLL * 2ULL) + 1) - 3))\n    set(3, 0);\n  else\n    e = 1;\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-6/3"}
{"code": "for (long c = 0; c < ncside; c++)\n{\n  free(grid[c]);\n  free(dummy[c]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nekrotzar/simpar/simpar-omp/2"}
{"code": "for (int i = s0; i < e0; i++)\n{\n  int neighbour_1 = adj[i];\n  int s1 = xadj[neighbour_1];\n  int e1 = xadj[neighbour_1 + 1];\n  for (int j = s1; j < e1; j++)\n  {\n    int neighbour_2 = adj[j];\n    if (neighbour_2 == index)\n      continue;\n\n    int s2 = xadj[neighbour_2];\n    int e2 = xadj[neighbour_2 + 1];\n    for (int k = s2; k < e2; k++)\n    {\n      int neighbour_3 = adj[k];\n      if (neighbour_3 == index)\n        continue;\n\n      if (neighbour_3 == neighbour_1)\n        continue;\n\n      int s3 = xadj[neighbour_3];\n      int e3 = xadj[neighbour_3 + 1];\n      for (int n = s3; n < e3; n++)\n      {\n        int neighbour_4 = adj[n];\n        if (neighbour_4 == index)\n          continue;\n\n        if (neighbour_4 == neighbour_1)\n          continue;\n\n        if (neighbour_4 == neighbour_2)\n          continue;\n\n        int s4 = xadj[neighbour_4];\n        int e4 = xadj[neighbour_4 + 1];\n        for (int o = s4; o < e4; o++)\n        {\n          int neighbour_5 = adj[o];\n          if (neighbour_5 == index)\n          {\n            localcount += 1;\n            break;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/3"}
{"code": "for (c = 0; c < size; c++)\n  for (d = 0; d < size; d++)\n{\n  if ((*((matrixA + (c * size)) + d)) != (*((matrixB + (c * size)) + d)))\n    return 0;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MeghanaVankadari/Gemm_parallel/gemm_parallel/2"}
{"code": "for (i = 0; i < (len - 1); i++)\n  a[i] = a[i] + 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/target/0"}
{"code": "for (i = 0; i < 10000000; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp parallel for shared(a, b, c) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lephin/C-parallel-programming.-OpenMP/Hello/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < P; ++j)\n  {\n    B[i][j] = rand() % 5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vidit23/ParallelProgramming/Assignment-1/Q4/q4/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < n; k++)\n      c[(i * n) + j] += a[(i * n) + k] * b[(k * n) + j];\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/mm/main/0"}
{"code": "for (int count = 0; count < (V - 1); count++)\n{\n  int u = minDistance(dist, sptSet, V);\n  sptSet[u] = 1;\n  for (int v = 0; v < V; v++)\n    if (((!(sptSet[v] == 1)) && graph[u][v]) && ((dist[u] + graph[u][v]) < dist[v]))\n  {\n    parent[v] = u;\n    dist[v] = dist[u] + graph[u][v];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/shpth/4"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    if (!obstacles[(ii * params.nx) + jj])\n    {\n      index = (ii * params.nx) + jj;\n      double local_density = 0.0;\n      for (int kk = 0; kk < 9; kk++)\n      {\n        local_density += cells[index].speeds[kk];\n      }\n\n      double u_x = (((cells[index].speeds[1] + cells[index].speeds[5]) + cells[index].speeds[8]) - ((cells[index].speeds[3] + cells[index].speeds[6]) + cells[index].speeds[7])) / local_density;\n      double u_y = (((cells[index].speeds[2] + cells[index].speeds[5]) + cells[index].speeds[6]) - ((cells[index].speeds[4] + cells[index].speeds[7]) + cells[index].speeds[8])) / local_density;\n      tot_u += sqrt((u_x * u_x) + (u_y * u_y));\n      ++tot_cells;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk.pomp/3"}
{"code": "for (i = 0; i < 11; i++)\n{\n  printf(\"%g\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nadezhdagub/OpenMP-MPI/lab7_1/1"}
{"code": "for (int gene = 0; gene < 500; gene++)\n{\n  eval = evaluation(POPULATION[gene]);\n  if (eval == 0)\n    return gene;\n\n  gene_score = 1.0 / eval;\n  sum_score += gene_score;\n  scores[gene] = gene_score;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.1/0"}
{"code": "for (int i = 0; i < n; ++i)\n  f >> a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Fast Fourier Transform/fft_parallel/2"}
{"code": "for (i = 0; i < threads; i++)\n{\n  my_id = omp_get_thread_num();\n  data += \" \" + to_string(my_id);\n}\n\n", "pragma": "    #pragma omp parallel for    \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aqfort/mipt_omp/main/ring/0"}
{"code": "for (NUM_THREADS = 8; NUM_THREADS <= 8; NUM_THREADS++)\n{\n  cout << \"\u6734\u7d20\u5206\u9664\uff1a\";\n  timing(ver2);\n  cout << \"SIMD\u5206\u9664\uff1a\";\n  timing(ver3);\n  cout << \"auto simd horizontal\uff1a\";\n  timing(ver6);\n  cout << \"auto simd vertical\uff1a\";\n  timing(ver10);\n  cout << \"dynamic\uff1a\";\n  timing(ver8);\n  cout << \"guided\uff1a\";\n  timing(ver9);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ching-Yee-Chan/openMP/arm/4"}
{"code": "for (idx = 0; idx < 30; ++idx)\n{\n  a[idx] = (b[idx] = 1.0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/vec_add/vec_add/0"}
{"code": "for (j = 0; j < c; j++)\n{\n  if (maxScore[j] == preScore)\n  {\n    tmp = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/3"}
{"code": "for (int p = 1; p < pcount; p++)\n{\n  int start = (N * p) / pcount;\n  int end = (N * (p + 1)) / pcount;\n  MPI_Recv(buf, N * (end - start), MPI_DOUBLE, p, 0, MPI_COMM_WORLD, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olegharacidi/superprak4/floyd/4"}
{"code": "for (j = 0; j < N; ++j)\n{\n  t = b[i_max];\n  b[i_max] = b[curpos];\n  b[curpos] = t;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markusFrost/OpenMp-gaussian-elimination/TestProject_1/TestProject_1/3"}
{"code": "for (int i = 0; i < mat.size(); i++)\n{\n  mat[i].resize(cols, initial);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i - 1][j][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/101"}
{"code": "for (int s = 0; s < nk; ++s)\n{\n  (bitset < 15) > (s.to_string() << endl);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    sum = 0.;\n    for (k = 0; k < N; k++)\n    {\n      sum = sum + (A[i][k] * B[k][j]);\n    }\n\n    Result[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k) shared(sum,A,B,M,N,Result)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vidya-vidz/OpenMpi/dgemm_l1/0"}
{"code": "for (int i = 1; i <= 10; i++)\n{\n  prod *= i;\n}\n\n", "pragma": "#pragma omp parallel for reduction(*: prod) num_threads(10)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest05/simple_test_05cpp/1"}
{"code": "for (int z = 0; z < (rows * columns); ++z)\n{\n  x = z / columns;\n  y = z % columns;\n  for (int i = 0; i < krows; ++i)\n  {\n    for (int j = 0; j < kcolumns; ++j)\n    {\n      a = (x + i) - (krows / 2);\n      b = (y + j) - (kcolumns / 2);\n      if (a < 0)\n        index1 = rows + a;\n      else\n        if (a > (rows - 1))\n        index1 = a - rows;\n      else\n        index1 = a;\n\n\n      if (b < 0)\n        index2 = columns + b;\n      else\n        if (b > (columns - 1))\n        index2 = b - columns;\n      else\n        index2 = b;\n\n\n      output[(x * columns) + y] += input[(index1 * columns) + index2] * kernel[(i * kcolumns) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for private(x,y,a, b, index1, index2) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rdb987/2DConvolution/src/hpc_conv_hybrid/0"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    (cout << \" \") << matrix1OMP[i][j];\n    if (j == 3)\n      cout << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/6"}
{"code": "for (i = 0; (i < ((sizeof(\"$WoWSRP$\")) - 1)) && (i < (ct2_size - 1)); ++i)\n  *(ct2++) = *(ct++);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/wow_srp_fmt_plug/2"}
{"code": "for (i = 0; i < tnum; i++)\n{\n  free(list_array[i]);\n  free(r_mask_array[i]);\n  free(c_mask_array[i]);\n  free(b_mask_array[i]);\n  free(cp_sudokus_array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/omp/sudoku-omp/1"}
{"code": "for (k = 0; k < matrixScale; k++)\n  matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nersle/parallelProgramingProject/cannon/cannonOpenMP/5"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      z = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      nn = x;\n      mm = y;\n      ll = z;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      dzp = z - ((float) ll);\n      n[j] = ((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      dx1 = dxp * dyp;\n      dyp = amx * dyp;\n      amx = amx * amy;\n      amz = 1.0f - dzp;\n      amy = dxp * amy;\n      s[j] = amx * amz;\n      s[j + 32] = amy * amz;\n      s[j + (2 * 32)] = dyp * amz;\n      s[j + (3 * 32)] = dx1 * amz;\n      s[j + (4 * 32)] = amx * dzp;\n      s[j + (5 * 32)] = amy * dzp;\n      s[j + (6 * 32)] = dyp * dzp;\n      s[j + (7 * 32)] = dx1 * dzp;\n      t[j] = x;\n      t[j + 32] = y;\n      t[j + (2 * 32)] = z;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = (nn + mxv) - 2;\n      ll = (nn + mxyv) - 4;\n      k = (ll + mxv) - 2;\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      for (i = 0; i < 8; i++)\n      {\n        if (i > 5)\n        {\n          nn = k;\n        }\n        else\n          if (i > 3)\n        {\n          nn = ll;\n        }\n        else\n          if (i > 1)\n        {\n          nn = mm;\n        }\n\n\n\n        dx += sfxyz[4 * (i + nn)] * s[j + (32 * i)];\n        dy += sfxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        dz += sfxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n        ox += sbxyz[4 * (i + nn)] * s[j + (32 * i)];\n        oy += sbxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        oz += sbxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n      s[j + (2 * 32)] = dz;\n      s[j + (3 * 32)] = ox;\n      s[j + (4 * 32)] = oy;\n      s[j + (5 * 32)] = oz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      z = t[j + (2 * 32)];\n      dx = qtmh * s[j];\n      ;\n      dy = qtmh * s[j + 32];\n      dz = qtmh * s[j + (2 * 32)];\n      acx = ppart[((j + joff) + (3 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (4 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (5 * nppmx)) + npoff] + dz;\n      p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n      gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n      qtmg = qtmh * gami;\n      sum1 += (gami * p2) / (1.0f + gami);\n      omxt = qtmg * s[j + (3 * 32)];\n      omyt = qtmg * s[j + (4 * 32)];\n      omzt = qtmg * s[j + (5 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n      dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n      s[j] = x + (vx * dtg);\n      s[j + 32] = y + (vy * dtg);\n      s[j + (2 * 32)] = z + (vz * dtg);\n      s[j + (3 * 32)] = vx;\n      s[j + (4 * 32)] = vy;\n      s[j + (5 * 32)] = vz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      dz = s[j + (2 * 32)];\n      vx = s[j + (3 * 32)];\n      vy = s[j + (4 * 32)];\n      vz = s[j + (5 * 32)];\n      if (ipbc == 2)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n        if ((dz < edgelz) || (dz >= edgerz))\n        {\n          dz = t[j + (2 * 32)];\n          vz = -vz;\n        }\n\n      }\n      else\n        if (ipbc == 3)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = dz;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = vx;\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = vy;\n      ppart[((j + joff) + (5 * nppmx)) + npoff] = vz;\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        vz = -vz;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,ipp,joff,nps,nn,mm,ll,nm,x, y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz, omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, p2,gami,qtmg,dtg,sum1,sfxyz,sbxyz,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/8"}
{"code": "for (int i = 0; i < 10; ++i)\n  for (int j = 0; j < 10; ++j)\n  v[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_collapse_01/1"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n  {\n    A[(i * 1500) + j] = (((DATA_TYPE) i) * j) / 1500;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    for (int k = 0; k < n; k++)\n      m3[(i * n) + j] += m1[(i * n) + k] * m2[(k * n) + j];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/acavelan/openmp_course_2021/exercises/matmul/matmul_cpp/target/0"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  a[(i * N) + j] = ((double) rand()) / ((32767 * 2.0) - 1.0);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gkonto/openmp/src/_affinity/omp_mxv_1d/1"}
{"code": "for (i = 0; i <= (672 + 1); i++)\n{\n  Temperature_last[i][0] = 0.0;\n  Temperature_last[i][672 + 1] = (100.0 / 672) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/3"}
{"code": "for (j = 0; j < input->nRegions; j++)\n{\n  printf(\"Reg %d: menor: %d, maior: %d, mediana: %.2lf, media: %.2lf e DP: %.2lf\\n\", j, (int) measuresByRegion[0][j], (int) measuresByRegion[1][j], measuresByRegion[2][j], measuresByRegion[3][j], measuresByRegion[4][j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/utilspar/15"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  tmp_vec_a[i] = a;\n  tmp_vec_b[i] = b;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArtTikidji/Study_openMP_AVX/main/4"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  cast_out->vec_[ai] = cast_in->vec_[ai];\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (this->mat_.col[aj] < ai)\n    {\n      cast_out->vec_[ai] -= this->mat_.val[aj] * cast_out->vec_[this->mat_.col[aj]];\n    }\n    else\n    {\n      if (this->L_diag_unit_ == false)\n      {\n        assert(this->mat_.col[aj] == ai);\n        diag_aj = aj;\n      }\n\n      break;\n    }\n\n  }\n\n  if (this->L_diag_unit_ == false)\n  {\n    cast_out->vec_[ai] /= this->mat_.val[diag_aj];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/23"}
{"code": "for (unsigned i = 131071; i <= 2147483647; i += 127)\n  a[i] += foo();\n\n", "pragma": "#pragma omp for schedule(static, 5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_codegen/6"}
{"code": "for (int j = 0; j < k; j++)\n{\n  printf(\"Cluster %d; tid=%d\\n\", j + 1, omp_get_thread_num());\n  for (int i = 0; i < n; i++)\n  {\n    if (kc[i] == j)\n    {\n      printf(\"point %d: (%d,%d)\\n\", i, x[i], y[i]);\n      clust_size[j] += 1;\n      xc[j][clust_size[j] - 1] = x[i];\n      yc[j][clust_size[j] - 1] = y[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/serial/pc/0"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (i = 0; i < fftblock; i++)\n  {\n    y0[k][i].real = x[k][j][i + ii].real;\n    y0[k][i].imag = x[k][j][i + ii].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for private(k) firstprivate(i ,ii ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/FT/ft/7"}
{"code": "for (unsigned ci = 0; ci < GetCount(); ci++)\n{\n  const unsigned np = List[ci]->GetNpartInit();\n  if ((npart + np) > nparttot)\n    Run_Exceptioon(\"Number of initial inlet/outlet particles is invalid.\");\n\n  List[ci]->LoadInitialParticles(np, pos + npart);\n  for (unsigned cp = 0; cp < np; cp++)\n  {\n    const unsigned p = npart + cp;\n    idp[p] = idpfirst + p;\n    code[p] = typecode(CODE_TYPE_FLUID_INOUT) + ci;\n    velrhop[p] = TFloat4(0, 0, 0, 1000);\n  }\n\n  npart += np;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/5"}
{"code": "for (; i < ie; i++)\n{\n  Add(hi[i], lo[i], vec1.hi[i], vec1.lo[i], (-1) * vec2.data()[i], (-1) * 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_sub_dd/2"}
{"code": "for (int j = 0; j < (ny + 2); j++)\n{\n  temperature(0, j) = 85.0;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/hybrid/heat-hybrid/cpp/solution/heat/0"}
{"code": "for (int i = 0; i < len; i++)\n  a[i] = 0.;\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  m |= a[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/1"}
{"code": "for (i = 0; i < num_ph; i++)\n{\n  fprintf(fPtr, \"%0.13e\\t\", (ph + i)->p0);\n  fprintf(fPtr1, \"%0.13e\\t\", (ph + i)->p1);\n  fprintf(fPtr2, \"%0.13e\\t\", (ph + i)->p2);\n  fprintf(fPtr3, \"%0.13e\\t\", (ph + i)->p3);\n  fprintf(fPtr4, \"%0.13e\\t\", (ph + i)->r0);\n  fprintf(fPtr5, \"%0.13e\\t\", (ph + i)->r1);\n  fprintf(fPtr6, \"%0.13e\\t\", (ph + i)->r2);\n  fprintf(fPtr7, \"%e\\t\", (ph + i)->num_scatt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/PARALLELIZE/mclib/0"}
{"code": "for (uint32_t i = 1; i < m; i++)\n{\n  distanceXY[i] = distanceXY[i - 1] + distanceIncrement;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogether/2"}
{"code": "for (x = 0; x < nptsside; x++)\n{\n  for (y = 0; y < nptsside; y++)\n  {\n    xv = (x - side2) / side4;\n    yv = (y - side2) / side4;\n    z = xv + (yv * I);\n    if (inset(z))\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1B/mandelbrot/1"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  D.zeros();\n  shuffle = uvec > ((n, distr_param(0, B.n_cols - 1)));\n  BG = B.cols(shuffle);\n  strp.zeros();\n  for (j = 0; j < n; j++)\n  {\n    Res = StrROne(D, P, data_proc.col(j).head(cov_num), cov_num, level_num, bsize, B, BG, strp);\n    strp = Res(0, 0);\n    BG = Res(1, 0);\n    assignew(j) = Res(2, 0)(0, 0);\n    D = Res(3, 0);\n  }\n\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Lp;\n  TL = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (diff_data - Lp);\n  mupdate = ((diff_data - Lp) > (2 * (diff_data - Lm))) || ((diff_data - Lp) < ((diff_data - Lm) * 0.5));\n  Lp = (TL < (diff_data - ((Lp * n1c) / n))) ? (Lp + ((c * alpha) / m)) : (Lp - ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Lm = (mupdate) ? (Lp) : (Lm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/46"}
{"code": "for (int iState = 0; iState < nState; iState++)\n{\n  float maxProb = 0.0;\n  int maxState = -1;\n  for (int preState = 0; preState < nState; preState++)\n  {\n    float p = maxProbOld[preState] + mtState[(iState * nState) + preState];\n    if (p > maxProb)\n    {\n      maxProb = p;\n      maxState = preState;\n    }\n\n  }\n\n  maxProbNew[iState] = maxProb + mtEmit[(obs[t] * nState) + iState];\n  path[t - 1][iState] = maxState;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hmm-omp/ViterbiCPU/2"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  y[i].v_ = (a * x[i].v_) + y[i].v_;\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_saxpy/c1_1/saxpy/0"}
{"code": "for (run = 0; run <= nruns; run++)\n{\n  begin = omp_get_wtime();\n  pipeline_harris(C, R, data, res);\n  end = omp_get_wtime();\n  stime = end - begin;\n  if (run != 0)\n  {\n    printf(\"Run %i : \\t\\t %f ms\\n\", run, ((double) stime) * 1000.0);\n    avgt += stime;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(avgt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/main/2"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET_VERBOSE(errors, saved_x[i] != i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/requires/test_requires_dynamic_allocators/1"}
{"code": "for (i = 1; i <= 23; i++)\n{\n  R23 = 0.50 * R23;\n  T23 = 2.0 * T23;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/1"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    res(i, j) = this->mat[i][j] + obj;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/18"}
{"code": "for (i = 1; i < (grid->getNXC() - 1); i++)\n  for (j = 1; j < (grid->getNYC() - 1); j++)\n  for (k = 1; k < (grid->getNZC() - 1); k++)\n  MaxwellianFromFluidCell(col, is, i, j, k, counter, x, y, z, q, u, v, w, ParticleID);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/4"}
{"code": "for (int x = kern_cent_X; x < (data_size_X - kern_cent_X); x++)\n{\n  for (int y = data_size_Y - kern_cent_Y; y < data_size_Y; y++)\n  {\n    for (int j = -kern_cent_Y; j <= ((data_size_Y - 1) - y); j++)\n    {\n      for (int i = -kern_cent_X; i <= kern_cent_X; i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kt9302/ImageConvolution/part2/5"}
{"code": "for (m = 1; m <= 4; m += 1)\n{\n  buf[j][m] = dtpp * dtemp[m];\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dtpp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/19"}
{"code": "for (unsigned long long p = 2; p <= sqrt_time; p++)\n{\n  if (get_bit(array, p) == 0)\n  {\n    for (unsigned long long i = p * p; i <= n; i += p)\n    {\n      if (get_bit(array, i) == 0)\n        toggle_bit(array, i);\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabiopereira96/crivo-eratostenes-paralelo/sieve_time/1"}
{"code": "for (int index = 0; index < n; index++)\n{\n  fscanf(fp, \"%d\", &array[index]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/caolanb10/Concurrent-Systems/parallelsearch/1"}
{"code": "for (j = 0; j <= 999; j += 1)\n{\n  a[i][j] = (i * j) + 0.01;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB062-matrixvector2-orig-no/1"}
{"code": "for (int jj = 1; jj < (params.lx + 1); ++jj)\n{\n  int x_e = jj + 1;\n  int x_w = jj - 1;\n  if ((((!obstacles[(row2 * params.lx) + (jj - 1)]) && ((cells[((row2 + 1) * params.nx) + x_w].speeds[1] - w1a) > 0.0f)) && ((cells[((row1 + 1) * params.nx) + x_w].speeds[8] - w2a) > 0.0f)) && ((cells[((row3 + 1) * params.nx) + x_w].speeds[5] - w2a) > 0.0f))\n  {\n    cells[((row2 + 1) * params.nx) + x_e].speeds[3] += w1a;\n    cells[((row1 + 1) * params.nx) + x_e].speeds[7] += w2a;\n    cells[((row3 + 1) * params.nx) + x_e].speeds[6] += w2a;\n    cells[((row2 + 1) * params.nx) + x_w].speeds[1] -= w1a;\n    cells[((row1 + 1) * params.nx) + x_w].speeds[8] -= w2a;\n    cells[((row3 + 1) * params.nx) + x_w].speeds[5] -= w2a;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  u1[i] = i;\n  u2[i] = ((i + 1) / n) / 2.0;\n  v1[i] = ((i + 1) / n) / 4.0;\n  v2[i] = ((i + 1) / n) / 6.0;\n  y[i] = ((i + 1) / n) / 8.0;\n  z[i] = ((i + 1) / n) / 9.0;\n  x[i] = 0.0;\n  w[i] = 0.0;\n  for (j = 0; j < n; j++)\n    A[i][j] = (((DATA_TYPE) i) * j) / n;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gemver/gemver/4"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    w[i][j] = mean;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 4/heated-plate-parallel/6"}
{"code": "for (i = 0; i < width; i++)\n  for (j = 0; j < height; j++)\n{\n  helpMassive[i][j].present = mainField[i][j].past;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/lgame/7"}
{"code": "for (register int s = 0; s < getNOP(); s++)\n{\n  temp = u[s];\n  temp2 = v[s];\n  u[s] = (temp * cos(theta)) + (v[s] * sin(theta));\n  v[s] = ((-temp) * sin(theta)) + (temp2 * cos(theta));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/23"}
{"code": "for (i = 0; i < row1; i++)\n{\n  for (j = 0; j < col2; j++)\n  {\n    mul[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j) shared(row1,col2,mul) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zeeshanmahar007/Matrix-Matrix-Multiplication-in-Parallel/omp_parallel/5"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  free(*(bits + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/16"}
{"code": "for (int i = 0; i < N; ++i)\n  hst_ptr[i] -= 1;\n\n", "pragma": "omp target teams distribute parallel for device(device) map(tofrom:hst_ptr[0 : N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/test/api/omp_host_pinned_memory/0"}
{"code": "for (int i = 0; i < (dim * dim); i++)\n{\n  if ((i % dim) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\": %f\", M[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZdravkoDimitrovArnaudov/PPCTR/p3/src/matmul/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i;\n  dsum = dsum + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bhuvaneswar005/OpenMP/Assignment 3/Code/reductionclause_for/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    B[(i * 2048) + j] = ((((DATA_TYPE) i) * j) + 1) / 2048;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm/1"}
{"code": "for (i = 0; i < N; ++i)\n{\n  for (j = 0; j < N; ++j)\n    result_vect[i] += Matr[i][j] * vect[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/3/3/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, sizeof(float), cols * bands, fin);\n  printf(\"Unmixing at row %d of %d\\r\", i + 1, rows);\n  for (j = 0; j < cols; j++)\n  {\n    for (k = 0; k < bands; k++)\n    {\n      b[k] = buffer[(k * cols) + j];\n    }\n\n    for (l = 0; l < nendmembers; l++)\n    {\n      c = 0.0;\n      if (b[0] == nvalue)\n      {\n        buffer2[(l * cols) + j] = nvalue;\n      }\n      else\n      {\n        for (m = 0; m < bands; m++)\n        {\n          c += N[l][m] * b[m];\n        }\n\n        buffer2[(l * cols) + j] = c;\n      }\n\n    }\n\n  }\n\n  fwrite(buffer2, sizeof(float), nendmembers * cols, fend);\n  for (j = 0; j < (cols * nendmembers); j = j + 30)\n  {\n    fprintf(report, \" %f\", buffer2[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/Unmixing/9"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    printf(\"%d \", mat2[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Matrices/matrix_difference/2"}
{"code": "for (int i = 1; i < (blockheight - 1); i++)\n  for (int l = 1; l < (blockwidth - 1); l++)\n{\n  unsigned int offset = (i * blockwidth) + l;\n  unsigned int val = ((src_buf[(offset - blockwidth) - 1] * filter[DIR_DRIGHT]) + (src_buf[offset - blockwidth] * filter[DIR_DOWN])) + (src_buf[(offset - blockwidth) + 1] * filter[DIR_DLEFT]);\n  ;\n  val += ((src_buf[offset] * filter[DIR_CENTER]) + (src_buf[offset - 1] * filter[DIR_RIGHT])) + (src_buf[offset + 1] * filter[DIR_LEFT]);\n  ;\n  val += ((src_buf[(offset + blockwidth) - 1] * filter[DIR_URIGHT]) + (src_buf[offset + blockwidth] * filter[DIR_UP])) + (src_buf[(offset + blockwidth) + 1] * filter[DIR_ULEFT]);\n  ;\n  val /= filt_total;\n  dest_buf[offset] = ((char) val) & 0xFF;\n}\n\n\n", "pragma": "omp parallel for num_threads(THREADNUM)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikofil/convolution/mpi/convolution/0"}
{"code": "for (int a = r; a < (r + window); a++)\n{\n  for (int b = c; b < (c + window); b++)\n  {\n    mat[a][b] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/5"}
{"code": "for (int i = 0; i < 128; i++)\n{\n  for (int j = 0; j < 128; j++)\n  {\n    m[i][j] = ((i * 128) + j) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/omp_MMMUL/1"}
{"code": "for (j = 0; j < (width * height); j++)\n{\n  int moy;\n  moy = ((pi[j].r + pi[j].g) + pi[j].b) / 3;\n  if (moy < 0)\n    moy = 0;\n\n  if (moy > 255)\n    moy = 255;\n\n  pi[j].r = moy;\n  pi[j].g = moy;\n  pi[j].b = moy;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/grey_filter/0"}
{"code": "for (unsigned int i = 0; i < density_names.size(); i++)\n{\n  ((((((((((((((((((((((((((((((((((os << \"   \") << density_names[i]) << \":\") << endl) << \"     units: \") << density_units[i]) << endl) << \"     diffusion coefficient: \") << diffusion_coefficients[i]) << \" \") << spatial_units) << \"^2 / \") << time_units) << endl) << \"     decay rate: \") << decay_rates[i]) << \" \") << time_units) << \"^-1\") << endl) << \"     diffusion length scale: \") << sqrt(diffusion_coefficients[i] / (1e-12 + decay_rates[i]))) << \" \") << spatial_units) << endl) << \"     initial condition: \") << default_microenvironment_options.initial_condition_vector[i]) << \" \") << density_units[i]) << endl) << \"     boundary condition: \") << default_microenvironment_options.Dirichlet_condition_vector[i]) << \" \") << density_units[i]) << \" (enabled: \";\n  if (dirichlet_activation_vector[i] == true)\n  {\n    os << \"true\";\n  }\n  else\n  {\n    os << \"false\";\n  }\n\n  (os << \")\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/8"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    old_val = U_old[i][j];\n    U_old[i][j] = ((((U[i][j - 1] + U[i][j + 1]) + U[i - 1][j]) + U[i + 1][j]) + ((Delta * Delta) * F[i][j])) * one_fourth;\n    old_val -= U_old[i][j];\n    d_temp += (old_val < 0) ? (-old_val) : (old_val);\n  }\n\n}\n\n", "pragma": "omp for private(i,j,old_val) reduction(+:d_temp) schedule(runtime)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/martinverup/OpenMP-Poisson-Problem/poisson/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    C[(i * 2048) + j] = ((((DATA_TYPE) i) * j) + 2) / 2048;\n    C_OMP[(i * 2048) + j] = ((((DATA_TYPE) i) * j) + 2) / 2048;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm/2"}
{"code": "for (i = 0; i < num_buckets; ++i)\n{\n  thresholds[i] = 0;\n  thresholds_count[i] = 0;\n  thresholds_totalDegrees[i] = 0;\n  thresholds_totalReuses[i] = 0;\n  thresholds_totalReuses_region[i] = 0;\n  thresholds_totalMisses[i] = 0;\n  thresholds_avgDegrees[i] = 0.0f;\n  thresholds_avgReuses[i] = 0.0f;\n  thresholds_avgReuses_region[i] = 0.0f;\n  thresholds_avgMisses[i] = 0.0f;\n  thresholds_totalAccesses[i] = 0;\n  thresholds_avgAccesses[i] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/45"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 256; j++)\n    S[(i * S_COLUMNS) + j] = Svalues[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zagorskid/blowfish-omp/blowfish-omp/blowfish-omp/2"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (ii = 0; ii <= (d[0] - fftblock); ii += fftblock)\n  {\n    for (j = 0; j < d[1]; j++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        y0[j][i].real = x[k][j][i + ii].real;\n        y0[j][i].imag = x[k][j][i + ii].imag;\n      }\n\n    }\n\n    int _imopVarPre254;\n    int _imopVarPre255;\n    _imopVarPre254 = d[1];\n    _imopVarPre255 = logd[1];\n    cfftz(is, _imopVarPre255, _imopVarPre254, y0, y1);\n    for (j = 0; j < d[1]; j++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        xout[k][j][i + ii].real = y0[j][i].real;\n        xout[k][j][i + ii].imag = y0[j][i].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/5"}
{"code": "for (int i = 1; i < (y_points - 1); i++)\n{\n  for (int j = 1; j < (x_points - 1); j++)\n  {\n    u_new[i][j] = (((u[i][j] + (((nu * del_t) / (del_x * del_x)) * ((u[i][j + 1] + u[i][j - 1]) - (2 * u[i][j])))) + (((nu * del_t) / (del_y * del_y)) * ((u[i + 1][j] + u[i - 1][j]) - (2 * u[i][j])))) - (((del_t / del_x) * u[i][j]) * (u[i][j] - u[i][j - 1]))) - (((del_t / del_y) * v[i][j]) * (u[i][j] - u[i - 1][j]));\n    v_new[i][j] = (((v[i][j] + (((nu * del_t) / (del_x * del_x)) * ((v[i][j + 1] + v[i][j - 1]) - (2 * v[i][j])))) + (((nu * del_t) / (del_y * del_y)) * ((v[i + 1][j] + v[i - 1][j]) - (2 * v[i][j])))) - (((del_t / del_x) * u[i][j]) * (v[i][j] - v[i][j - 1]))) - (((del_t / del_y) * v[i][j]) * (v[i][j] - v[i - 1][j]));\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Burgers Equation/2-D_Burgers_Equation/main/2"}
{"code": "for (k = left; k < right2; k++)\n{\n  data[k] = aux[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUSTechBruce/Multithread-merge_sort/merge_sort/2"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int result_r = 0;\n    int result_g = 0;\n    int result_b = 0;\n    for (int s = -2; s <= 2; s++)\n    {\n      if (((i + s) < 0) || ((i + s) >= height))\n      {\n        result_r += 0;\n        result_g += 0;\n        result_b += 0;\n      }\n      else\n      {\n        for (int t = -2; t <= 2; t++)\n        {\n          if (((j + t) < 0) || ((j + t) >= width))\n          {\n            result_r += 0;\n            result_g += 0;\n            result_b += 0;\n          }\n          else\n          {\n            result_r += m[s + 2][t + 2] * pixels[i + s][j + t].r;\n            result_g += m[s + 2][t + 2] * pixels[i + s][j + t].g;\n            result_b += m[s + 2][t + 2] * pixels[i + s][j + t].b;\n          }\n\n        }\n\n      }\n\n    }\n\n    pixels_aux[i][j].r = weight * result_r;\n    pixels_aux[i][j].g = weight * result_g;\n    pixels_aux[i][j].b = weight * result_b;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariomnz/Cpp-parallelism-image-filter/image-par/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      if (betaz[pp] > 0.0)\n      {\n        Dzu[pp] = ((((((-3.0) * u[pp - n]) - (10.0 * u[pp])) + (18.0 * u[pp + n])) - (6.0 * u[pp + (2 * n)])) + u[pp + (3 * n)]) * idz_by_12;\n      }\n      else\n      {\n        Dzu[pp] = (((((-u[pp - (3 * n)]) + (6.0 * u[pp - (2 * n)])) - (18.0 * u[pp - n])) + (10.0 * u[pp])) + (3.0 * u[pp + n])) * idz_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/17"}
{"code": "for (int i = 0; i < channels.size(); ++i)\n{\n  int type = channels[i].type();\n  memcpy(&buffer[0], channels[i].data, (rows * cols) * (sizeof(uchar)));\n  ((((cout << \"Processo 0 enviando para \") << (i + 1)) << \" tipo: \") << type) << endl;\n  MPI_Send(&type, 1, MPI_INT, i + 1, MASTER_TO_SLAVE_TAG, MPI_COMM_WORLD);\n  ((((cout << \"Processo 0 enviando para \") << (i + 1)) << \" rows: \") << rows) << endl;\n  MPI_Send(&rows, 1, MPI_INT, i + 1, MASTER_TO_SLAVE_TAG + 1, MPI_COMM_WORLD);\n  ((((cout << \"Processo 0 enviando para \") << (i + 1)) << \" cols: \") << cols) << endl;\n  MPI_Send(&cols, 1, MPI_INT, i + 1, MASTER_TO_SLAVE_TAG + 2, MPI_COMM_WORLD);\n  ((((cout << \"Processo 0 enviando para \") << (i + 1)) << \" data: \") << channels[i].data[0]) << endl;\n  MPI_Send(&buffer[0], rows * cols, MPI_UNSIGNED_CHAR, i + 1, MASTER_TO_SLAVE_TAG + 3, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmunidario/Trab02-Grupo20-B/paralelo/1"}
{"code": "for (y = height - 2; y >= 0; y--)\n{\n  dbase -= dststep;\n  a = lut[dbase[(width - 1) + dststep]];\n  dbase[width - 1] = uchar(MIN(a, dbase[width - 1]));\n  for (x = width - 2; x >= 0; x--)\n  {\n    int b = dbase[x + dststep];\n    a = lut[MIN(a, b)];\n    dbase[x] = uchar(MIN(a, dbase[x]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvdistransform/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/105"}
{"code": "for (int i = 1; i < (N - 1); ++i)\n{\n  for (int j = 1; j < (N - 1); ++j)\n  {\n    psi2[i][j] = ((c(0.75) * psi[i][j]) + (c(0.25) * psi1[i][j])) + (c(0.25 * dt) * F(psi1[i + 1][j], psi1[i - 1][j], psi1[i][j + 1], psi1[i][j - 1], psi1[i][j], i, j));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruifm/gross-pitaevskii/g25s6c3b/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (((a[i] == \"taa\") || (a[i] == \"tag\")) || (a[i] == \"tga\"))\n  {\n    ab[20].frequen += 1;\n    ab[20].name = \"stopping codon\";\n    continue;\n  }\n\n  if ((a[i] == \"ttt\") || (a[i] == \"ttc\"))\n  {\n    ab[0].frequen += 1;\n    ab[0].name = \"phe\";\n    continue;\n  }\n\n  if ((((((a[i] == \"tta\") || (a[i] == \"ttg\")) || (a[i] == \"ctt\")) || (a[i] == \"ctc\")) || (a[i] == \"cta\")) || (a[i] == \"ctg\"))\n  {\n    ab[1].frequen += 1;\n    ab[1].name = \"leu\";\n    continue;\n  }\n\n  if (((a[i] == \"att\") || (a[i] == \"atc\")) || (a[i] == \"ata\"))\n  {\n    ab[2].frequen += 1;\n    ab[2].name = \"iie\";\n    continue;\n  }\n\n  if (a[i] == \"atg\")\n  {\n    ab[3].frequen += 1;\n    ab[3].name = \"met\";\n    continue;\n  }\n\n  if ((((a[i] == \"gtt\") || (a[i] == \"gtc\")) || (a[i] == \"gta\")) || (a[i] == \"gtg\"))\n  {\n    ab[4].frequen += 1;\n    ab[4].name = \"val\";\n    continue;\n  }\n\n  if ((((((a[i] == \"tct\") || (a[i] == \"tcc\")) || (a[i] == \"tca\")) || (a[i] == \"tcg\")) || (a[i] == \"agt\")) || (a[i] == \"agc\"))\n  {\n    ab[5].frequen += 1;\n    ab[5].name = \"ser\";\n    continue;\n  }\n\n  if ((((a[i] == \"cct\") || (a[i] == \"ccc\")) || (a[i] == \"cca\")) || (a[i] == \"ccg\"))\n  {\n    ab[6].frequen += 1;\n    ab[6].name = \"pro\";\n    continue;\n  }\n\n  if ((((a[i] == \"act\") || (a[i] == \"acc\")) || (a[i] == \"aca\")) || (a[i] == \"acg\"))\n  {\n    ab[7].frequen += 1;\n    ab[7].name = \"thr\";\n    continue;\n  }\n\n  if ((((a[i] == \"gct\") || (a[i] == \"gcc\")) || (a[i] == \"gca\")) || (a[i] == \"gcg\"))\n  {\n    ab[8].frequen += 1;\n    ab[8].name = \"ala\";\n    continue;\n  }\n\n  if ((a[i] == \"tat\") || (a[i] == \"tac\"))\n  {\n    ab[9].frequen += 1;\n    ab[9].name = \"tyr\";\n    continue;\n  }\n\n  if ((a[i] == \"cat\") || (a[i] == \"cac\"))\n  {\n    ab[10].frequen += 1;\n    ab[10].name = \"his\";\n    continue;\n  }\n\n  if ((a[i] == \"caa\") || (a[i] == \"cag\"))\n  {\n    ab[11].frequen += 1;\n    ab[11].name = \"gin\";\n    continue;\n  }\n\n  if ((a[i] == \"aat\") || (a[i] == \"aac\"))\n  {\n    ab[12].frequen += 1;\n    ab[12].name = \"asn\";\n    continue;\n  }\n\n  if ((a[i] == \"aaa\") || (a[i] == \"aag\"))\n  {\n    ab[13].frequen += 1;\n    ab[13].name = \"lys\";\n    continue;\n  }\n\n  if ((a[i] == \"gat\") || (a[i] == \"gac\"))\n  {\n    ab[14].frequen += 1;\n    ab[14].name = \"asp\";\n    continue;\n  }\n\n  if ((a[i] == \"gaa\") || (a[i] == \"gag\"))\n  {\n    ab[15].frequen += 1;\n    ab[15].name = \"glu\";\n    continue;\n  }\n\n  if ((a[i] == \"tgt\") || (a[i] == \"tgc\"))\n  {\n    ab[16].frequen += 1;\n    ab[16].name = \"cys\";\n    continue;\n  }\n\n  if (a[i] == \"tgg\")\n  {\n    ab[17].frequen += 1;\n    ab[17].name = \"trp\";\n    continue;\n  }\n\n  if ((((((a[i] == \"cgt\") || (a[i] == \"cgc\")) || (a[i] == \"cga\")) || (a[i] == \"cgg\")) || (a[i] == \"aga\")) || (a[i] == \"agg\"))\n  {\n    ab[18].frequen += 1;\n    ab[18].name = \"arg\";\n    continue;\n  }\n\n  if ((((a[i] == \"ggt\") || (a[i] == \"ggc\")) || (a[i] == \"gga\")) || (a[i] == \"ggg\"))\n  {\n    ab[19].frequen += 1;\n    ab[19].name = \"gly\";\n    continue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ayman1231/translate-a-gene-into-codons-using-OpenMP/Lab1q2/2.main/3"}
{"code": "for (m = 0; m < nb_colors; m++)\n{\n  uint64_t start = (m * size) / nb_colors;\n  uint64_t end = ((m + 1) * size) / nb_colors;\n  dragon_draw_raw(start, end, dragon, dragon_width, dragon_height, limits, m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP1/inf8601-lab1-2.1.0/src/dragon/6"}
{"code": "for (i = 2 * B; i < (height - (2 * B)); i++)\n{\n  for (j = 2 * B; j < (width - (2 * B)); j++)\n  {\n    for (c = 0; c < CHANNELS; c++)\n    {\n      if (((int) first_image[i][j][c]) != ((int) second_image[i][j][c]))\n      {\n        identical = 0;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yannikab/parsys/spmd/common/filter/5"}
{"code": "for (int j = 0; j < num_devices; j++)\n{\n  if (j == (num_devices - 1))\n  {\n    err = clEnqueueReadBuffer(queues[j], bufF[j], CL_TRUE, 0, (sizeof(float)) * last, Error_T + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n  }\n  else\n  {\n    err = clEnqueueReadBuffer(queues[j], bufF[j], CL_TRUE, 0, (sizeof(float)) * NNZ_PER_DEVICE, Error_T + (j * NNZ_PER_DEVICE), 0, NULL, NULL);\n    CHECK_ERROR(err);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/24"}
{"code": "for (itr = dictionary.begin(); itr != dictionary.end(); ++itr)\n{\n  (((cout << itr->first) << '\\t') << itr->second) << '\\n';\n  if (i == 9)\n    break;\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasag17/TET-Project2/intentosAnteriores/pcam/1"}
{"code": "for (i = 0; i < (1 + 2); i++)\n  for (j = 0; j < (5 + 2); j++)\n  TOPO[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/3"}
{"code": "for (i = 1; i < pointsInProc; ++i)\n{\n  pointsProc[i] = pointsProc[i - 1] + DIMS;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/4"}
{"code": "for (iy = 0; iy < iy_max; iy++)\n{\n  y = y_min + (iy * pix_h);\n  if (fabs(y) < (pix_h / 2))\n    y = 0.0;\n\n  for (ix = 0; ix < ix_max; ix++)\n  {\n    x = x_min + (ix * pix_w);\n    Zx = 0.0;\n    Zy = 0.0;\n    Zx2 = Zx * Zx;\n    Zy2 = Zy * Zy;\n    for (t = 1; (t < t_max) && ((Zx2 + Zy2) < (esc_rad * esc_rad)); t++)\n    {\n      Zy = ((2 * Zx) * Zy) + y;\n      Zx = (Zx2 - Zy2) + x;\n      Zx2 = Zx * Zx;\n      Zy2 = Zy * Zy;\n    }\n\n    if (t == t_max)\n    {\n      color[0] = 0;\n      color[1] = 0;\n      color[2] = 0;\n    }\n    else\n    {\n      color[0] = 255;\n      color[1] = 255;\n      color[2] = 255;\n    }\n\n    ;\n    fseek(fp, (((iy * 800) + ix) * 3) + 22, 0);\n    fwrite(color, 1, 3, fp);\n  }\n\n}\n\n", "pragma": "omp parallel for private(y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ram-Aditya/Parallel-Computing/MandelBrot`s Set/Mandelbrot_Parallel/0"}
{"code": "for (size_t i = 0; i < W.size(); i++)\n{\n  g[i] += dW[i] * dW[i];\n  W[i] -= (alpha * dW[i]) / (sqrt(g[i]) + eps);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/optimizer/0"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    c[i] += a[i][j] * b[j];\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vishal-subbu/OpenMP/mat_vec/0"}
{"code": "for (int i = 0; i < N; i++)\n  (cout << a[i]) << \", \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/0"}
{"code": "for (int i = m + 1; i < N; ++i)\n{\n  error += d[pivot[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  printf(\"%4d\", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utwente-fmt/vercors/examples/openmp/add-spec-simd/3"}
{"code": "for (i = 0; i < (point.k - 1); i++)\n  printf(\"%f \", point.inputs[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorelShoshany/Perceptron-Algorithm/hw4/work/0"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  if (parent_nodes_results_matrix[i] != parent_nodes_results_matrix[40000 + i])\n    pn_errors += 1;\n\n  if (distance_results_matrix[i] != distance_results_matrix[40000 + i])\n    dis_errors += 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/4"}
{"code": "for (i = 0; i < 256; i++)\n{\n  local_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par/0"}
{"code": "for (int instanceToComputeNo = 0; instanceToComputeNo < nInstancesToCompute; instanceToComputeNo++)\n{\n  vmValues[instanceToComputeNo] = state0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/breyerml/OpenMP_Offloading_to_SYCL_mwe/hodgkin_huxley_1952_gpu_fast_monodomain.0/7"}
{"code": "for (int i = 1; i < K; i++)\n{\n  for (int j = 1; j < (i + N); j++)\n  {\n    tmpsum1 += (j + log((1 + x) + j)) / (((2 * i) * j) - 1);\n  }\n\n  sum += 1 / tmpsum1;\n  tmpsum1 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/8"}
{"code": "for (int m = 0; m < 16; m++)\n{\n  total[0] += rrr[m];\n  total[1] += ggg[m];\n  total[2] += bbb[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NYXFLOWER/Mosaics-CUDA-OpenMP/mosaic_vs/mosaic_vs/mosaic_vs/openmp_versions/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < l; ++j)\n  {\n    prd[i][j] = 0;\n    for (int k = 0; k < m; ++k)\n    {\n      prd[i][j] += mat1[i][k] * mat2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/1"}
{"code": "for (int i = 0; i < 50; i++)\n  printf(\"===\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/5. N-queens problem/gen06/3"}
{"code": "for (i = 0; i < 5; i++)\n  ;\n\n", "pragma": "omp for collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/collapse-1/0"}
{"code": "for (unsigned f = 0; f < coupled_images_creation_locks.size(); ++f)\n  omp_destroy_lock(&coupled_images_creation_locks[f]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/8"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  for (j = 0; j < NCB; j++)\n    printf(\"%6.2f \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/logisi-hub/openmp-C/threads_matrix/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  graph[i] = (long int *) malloc((sizeof(long int)) * (N + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avisenna01/Djikstra-OpenMP/src/dijkstra_omp/5"}
{"code": "for (j = 1; j <= i__1; ++j)\n{\n  i__2 = j - 1;\n  ajj = a[j + (j * a_dim1)] - sdot_(&i__2, &a[(j * a_dim1) + 1], &c__1, &a[(j * a_dim1) + 1], &c__1);\n  if (ajj <= 0.f)\n  {\n    a[j + (j * a_dim1)] = ajj;\n    goto L30;\n  }\n\n  ajj = sqrt(ajj);\n  a[j + (j * a_dim1)] = ajj;\n  if (j < (*n))\n  {\n    i__2 = j - 1;\n    i__3 = (*n) - j;\n    sgemv_((char *) \"Transpose\", &i__2, &i__3, &c_b10, &a[((j + 1) * a_dim1) + 1], lda, &a[(j * a_dim1) + 1], &c__1, &c_b12, &a[j + ((j + 1) * a_dim1)], lda);\n    i__2 = (*n) - j;\n    r__1 = 1.f / ajj;\n    sscal_(&i__2, &r__1, &a[j + ((j + 1) * a_dim1)], lda);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/48"}
{"code": "for (i = 2; i <= (20 * ((((512 * 512) / 4) + ((512 * 512) / 4)) + ((512 * 512) / 4))); i++)\n{\n  ex[i] = ex[i - 1] * ex[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/19"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n  {\n    for (k = 0; k < 1500; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TNanukem/parallel-computing/matrix_multiplication_OMP/0"}
{"code": "for (int tid = 0; tid < output_size; tid++)\n{\n  int C = nChanels;\n  int B = N * C;\n  int A = N * B;\n  int Y = nChanels * nContractions;\n  int f = (tid % Y) % nChanels;\n  int Case = ((tid % Y) / nChanels) + 1;\n  int y = (tid / Y) % N;\n  int x = (tid / Y) / N;\n  int a;\n  int b;\n  int c;\n  int d;\n  int e;\n  T adj_value;\n  T sum = (T) 0;\n  if (Case == 1)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 2)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 3)\n  {\n    b = x;\n    c = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          for (a = 0; a < N; ++a)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 4)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (a = 0; a < N; ++a)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 5)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (a = 0; a < N; ++a)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 6)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        c = d;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 7)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      e = d;\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 8)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          c = b;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 9)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        b = e;\n        for (c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 10)\n  {\n    b = x;\n    c = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          a = d;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 11)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (a = 0; a < N; ++a)\n        {\n          c = a;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 12)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        a = e;\n        for (int c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 13)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        c = e;\n        for (int a = 0; a < N; ++a)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 14)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int a = 0; a < N; ++a)\n      {\n        b = a;\n        for (int c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 15)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int b = 0; b < N; ++b)\n      {\n        c = b;\n        for (int a = 0; a < N; ++a)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 16)\n  {\n    a = x;\n    d = y;\n    for (int e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        b = e;\n        c = e;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 17)\n  {\n    b = x;\n    d = y;\n    for (int e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        a = e;\n        c = e;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 18)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int a = 0; a < N; ++a)\n      {\n        b = a;\n        c = a;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  value[tid] = sum;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/contract-omp/main/0"}
{"code": "for (long i = 2; i < MAX; ++i)\n{\n  array[i] = true;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  r[i] = dicho(a[i], b, m);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaokun-X/openmp_archive/merge/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    grid[i][j] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patricia-souza/JogoVidaOpenMP/Critical/1"}
{"code": "for (int j = 0; j < 10000; j++)\n  if (!TheAntHasVisitiedCity[j])\n  summation += TauValues_to_A[I][j] * CalculatedDistances_to_mBETA[I][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant05/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_messages/3"}
{"code": "for (int i = 0; i < num_persons; i++)\n{\n  for (int j = 0; j < num_training; j++)\n  {\n    if (dist[i][j] < closestValue)\n    {\n      closestValue = dist[i][j];\n      closest = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/2"}
{"code": "for (i = 0; i < r; ++i)\n{\n  b[i] = (float *) malloc(c * (sizeof(float)));\n  for (j = 0; j < c; ++j)\n  {\n    fscanf(fptr, \"%f\", &n);\n    b[i][j] = n;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_2/3"}
{"code": "for (uint i = 1; i < numBuckets; ++i)\n{\n  exScanHisto[i] = exScanHisto[i - 1] + histogramRadixFrequency[i - 1];\n  histogramRadixFrequency[i - 1] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/7"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    double *_imopVarPre418;\n    double (*_imopVarPre419)[5];\n    double (*_imopVarPre420)[5];\n    _imopVarPre418 = rhs[i][j][0];\n    _imopVarPre419 = lhs[i][j][0][2];\n    _imopVarPre420 = lhs[i][j][0][1];\n    binvcrhs(_imopVarPre420, _imopVarPre419, _imopVarPre418);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/81"}
{"code": "for (i = 0; i < 18; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"\\nvalue of i is %d and thread ID is %d\", i, omp_get_thread_num());\n  if (id == 0)\n    t0 = t0 + 1;\n  else\n    if (id == 1)\n    t1 = t1 + 1;\n  else\n    if (id == 2)\n    t2 = t2 + 1;\n  else\n    t3 = t3 + 1;\n\n\n\n}\n\n", "pragma": "omp for schedule(static,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pushpinder107/parallel-programming-lab/thread-scheduling/sched1/0"}
{"code": "for (i = 0; i < Nparticles; i++)\n  seed[i] = time(0) * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/21"}
{"code": "for (int i = 0; i < matrixN; i++)\n{\n  Vec[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/3/3/3"}
{"code": "for (int i = 1; i < (M - 1); i++)\n{\n  current_iteration[N - 1][i] = current_iteration[1][i];\n}\n\n", "pragma": "\t#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmin-ionita/OpenMP-Game-Of-Life/g_omp/2"}
{"code": "for (int i = 0; i < color_depth; i++)\n{\n  for (int j = 0; j < (i + 1); j++)\n  {\n    transfer_function[i] += (color_depth * ((float) histogram[j])) / image_size;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(n_threads) schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lionleaf/parallel-c-programs/4-histogram-equalization-openmp-pthreads/histogram_omp/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(fptr, \"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/3"}
{"code": "for (int i = 0; i < 10; i++)\n  v[i] = float_rand(a, b);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeGiacomoSimoes/OpenMP/vector_parallel_print/1"}
{"code": "for (i = 0; i < N; i++)\n  p[i] = (i % 20) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcm/mmc/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  categories[i] = categorize(arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/Intel Vtune Amplifier and histogram/cat/4"}
{"code": "for (int i = 0; i < ny; i++)\n{\n  b[0][i + 1] = rget((iface.pointerB + iface.startIndex) + (iface.stride * i)).wait();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_DimensionalSplittingUpcxx/1"}
{"code": "for (int k = 0; k < Xk; k++)\n{\n  img_integration_kernel(d_pProj, nDetXMap, nDetYMap, integrateXcoord, 0, k * 9, nProj, teams, teamX, teamY, threads, threadX, threadY, threadZ);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/12"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET_VERBOSE(default_errors, a[i] != i);\n  OMPVV_TEST_AND_SET_VERBOSE(p_errors, b[i] != (i + 1));\n  OMPVV_TEST_AND_SET_VERBOSE(t_errors, c[i] != (i + 2));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_variant/test_declare_variant/4"}
{"code": "for (int i = 0; i < POINTS_NUMBER; i++)\n{\n  (((((outfile << pointSoA.x[i]) << \" \") << pointSoA.y[i]) << \" \") << pointSoA.cluster[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mb98-unifi/K-Means_OpenMP/mainSoA/5"}
{"code": "for (int shift = 0; shift < Size; shift++)\n{\n  float sum = 0.;\n  for (int i = 0; i < Size; i++)\n  {\n    sum += Array[i] * Array[i + shift];\n  }\n\n  Sums[shift] = sum;\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ehean/Parallel-Programming-Strategy-Comparison/code/openMP/openMP_multithreaded/0"}
{"code": "for (int y = 0; y < Y_SIZE; y++)\n  for (int x = 0; x < X_SIZE; x++)\n{\n  const float lx_rot = 30.0f;\n  const float ly_rot = 0.0f;\n  const float lx_expan = 0.5f;\n  const float ly_expan = 0.5f;\n  int lx_move = 0;\n  int ly_move = 0;\n  float affine[2][2];\n  float i_affine[2][2];\n  float beta[2];\n  float i_beta[2];\n  float det;\n  float x_new;\n  float y_new;\n  float x_frac;\n  float y_frac;\n  float gray_new;\n  int m;\n  int n;\n  unsigned short output_buffer;\n  affine[0][0] = lx_expan * cosf((lx_rot * PI) / 180.0f);\n  affine[0][1] = ly_expan * sinf((ly_rot * PI) / 180.0f);\n  affine[1][0] = lx_expan * sinf((lx_rot * PI) / 180.0f);\n  affine[1][1] = ly_expan * cosf((ly_rot * PI) / 180.0f);\n  beta[0] = lx_move;\n  beta[1] = ly_move;\n  det = (affine[0][0] * affine[1][1]) - (affine[0][1] * affine[1][0]);\n  if (det == 0.0f)\n  {\n    i_affine[0][0] = 1.0f;\n    i_affine[0][1] = 0.0f;\n    i_affine[1][0] = 0.0f;\n    i_affine[1][1] = 1.0f;\n    i_beta[0] = -beta[0];\n    i_beta[1] = -beta[1];\n  }\n  else\n  {\n    i_affine[0][0] = affine[1][1] / det;\n    i_affine[0][1] = (-affine[0][1]) / det;\n    i_affine[1][0] = (-affine[1][0]) / det;\n    i_affine[1][1] = affine[0][0] / det;\n    i_beta[0] = ((-i_affine[0][0]) * beta[0]) - (i_affine[0][1] * beta[1]);\n    i_beta[1] = ((-i_affine[1][0]) * beta[0]) - (i_affine[1][1] * beta[1]);\n  }\n\n  x_new = ((i_beta[0] + (i_affine[0][0] * (x - (X_SIZE / 2.0f)))) + (i_affine[0][1] * (y - (Y_SIZE / 2.0f)))) + (X_SIZE / 2.0f);\n  y_new = ((i_beta[1] + (i_affine[1][0] * (x - (X_SIZE / 2.0f)))) + (i_affine[1][1] * (y - (Y_SIZE / 2.0f)))) + (Y_SIZE / 2.0f);\n  m = (int) floorf(x_new);\n  n = (int) floorf(y_new);\n  x_frac = x_new - m;\n  y_frac = y_new - n;\n  if ((((m >= 0) && ((m + 1) < X_SIZE)) && (n >= 0)) && ((n + 1) < Y_SIZE))\n  {\n    gray_new = ((1.0f - y_frac) * (((1.0f - x_frac) * input_image[(n * X_SIZE) + m]) + (x_frac * input_image[((n * X_SIZE) + m) + 1]))) + (y_frac * (((1.0f - x_frac) * input_image[((n + 1) * X_SIZE) + m]) + (x_frac * input_image[(((n + 1) * X_SIZE) + m) + 1])));\n    output_buffer = (unsigned short) gray_new;\n  }\n  else\n    if (((((m + 1) == X_SIZE) && (n >= 0)) && (n < Y_SIZE)) || ((((n + 1) == Y_SIZE) && (m >= 0)) && (m < X_SIZE)))\n  {\n    output_buffer = input_image[(n * X_SIZE) + m];\n  }\n  else\n  {\n    output_buffer = WHITE;\n  }\n\n\n  output_image[(y * X_SIZE) + x] = output_buffer;\n}\n\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/affine-omp/main/0"}
{"code": "for (i = 0; i < n; i++)\n  myres += x[i] * x[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahmedGHANIM327/openMP/norm2/main/1"}
{"code": "for (row = a.begin(); row != a.end(); ++row)\n{\n  *row = ROW(size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_3/parallel_3/3"}
{"code": "for (int l = 0; l < n; l++)\n{\n  if (D[m - 1][l])\n    index.push_back(l);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranshumaheshwari/Parallel-String-Matching/parallel_shift_and/3"}
{"code": "for (int i = orig_nrows; i < m.cols(); i++)\n{\n  m.row(i).setZero();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/5"}
{"code": "for (int digits = 0; digits < 32; digits += granularity)\n{\n  for (i = 0; i < (2 * bitmask); ++i)\n  {\n    vertex_count[i] = 0;\n  }\n\n  for (i = 0; i < edges; ++i)\n  {\n    key = graph->sorted_edges_array[i].src;\n    vertex_count[(key >> digits) & bitmask]++;\n  }\n\n  for (i = 1; i < (2 * bitmask); ++i)\n  {\n    vertex_count[i] += vertex_count[i - 1];\n  }\n\n  for (i = edges - 1; i >= 0; --i)\n  {\n    key = graph->sorted_edges_array[i].src;\n    pos = vertex_count[(key >> digits) & bitmask] - 1;\n    sorted_edges_array[pos] = graph->sorted_edges_array[i];\n    vertex_count[(key >> digits) & bitmask]--;\n  }\n\n  temp = graph->sorted_edges_array;\n  graph->sorted_edges_array = sorted_edges_array;\n  sorted_edges_array = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/8"}
{"code": "for (int i = 0; i < size; i++)\n{\n  temp_point[i].x = data(0, i);\n  temp_point[i].y = data(1, i);\n  temp_point[i].z = data(2, i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xiaoxiaotao/icp-openmp-kdtree/src/icp/0"}
{"code": "for (int i = 0; i < nb; i++)\n  free(blocks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zooltd/LU-decomposition/lu/2"}
{"code": "for (int i = 0; i < corr_idx; ++i)\n{\n  p_idx += corrs[i]->get_Np();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/0"}
{"code": "for (int var = 0; var < 2; var++)\n{\n  for (int var2 = 0; var2 < num_tasks; var2++)\n  {\n    int pno = min + (rand() % ((max - min) + 1));\n    int tmpid = selectedProcessors[pno].getId();\n    chrmsm[csno].push_back(tmpid);\n    if ((var2 == (num_tasks - 1)) || (var2 == ((num_tasks - 1) / 2)))\n    {\n      csno++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/10"}
{"code": "for (int i = 0; i < (size - 1); i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    a[(i * (size + 1)) + j] = sumPowX(pairs, ((size - 1) - i) + ((size - 1) - j), pointCount);\n  }\n\n  a[(i * (size + 1)) + size] = sumPowXY(pairs, (size - 1) - i, pointCount);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SultanGG505/Parall_OpenMP/MethodOfLessCubs/MethodOfLessCubs/3"}
{"code": "for (i = 0; i < (2 * (nendmembers - 1)); i++)\n{\n  for (j = 0; j < (2 * (nendmembers - 1)); j++)\n  {\n    if (i != j)\n    {\n      ssad[i] += sad[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/20"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n    printf(\"%lf\\t\", InputMatrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/recc/5"}
{"code": "for (c1 = (0 > ((c0 - ((N + 13) / 16)) + 1)) ? (0) : ((c0 - ((N + 13) / 16)) + 1); c1 <= c0; c1 += 1)\n  for (c3 = (((16 * c0) + (16 * c1)) > (((16 * c0) - (16 * c1)) + 4)) ? ((16 * c0) + (16 * c1)) : (((16 * c0) - (16 * c1)) + 4); c3 <= ((((((((2 * N) - (16 * c0)) + (16 * c1)) - 2) < ((N + (16 * c1)) + 14)) ? ((((2 * N) - (16 * c0)) + (16 * c1)) - 2) : ((N + (16 * c1)) + 14)) < (((16 * c0) + (16 * c1)) + 45)) ? ((((((2 * N) - (16 * c0)) + (16 * c1)) - 2) < ((N + (16 * c1)) + 14)) ? ((((2 * N) - (16 * c0)) + (16 * c1)) - 2) : ((N + (16 * c1)) + 14)) : (((16 * c0) + (16 * c1)) + 45)); c3 += 1)\n  for (c4 = ((c0 - c1) > ((((-2) * c1) + ((c3 + 3) / 16)) - 2)) ? (c0 - c1) : ((((-2) * c1) + ((c3 + 3) / 16)) - 2); c4 <= ((((((N - 2) / 16) < ((-c1) + ((c3 - 1) / 16))) ? ((N - 2) / 16) : ((-c1) + ((c3 - 1) / 16))) < ((-c1) + (((((16 * c0) + (16 * c1)) + c3) + 13) / 32))) ? ((((N - 2) / 16) < ((-c1) + ((c3 - 1) / 16))) ? ((N - 2) / 16) : ((-c1) + ((c3 - 1) / 16))) : ((-c1) + (((((16 * c0) + (16 * c1)) + c3) + 13) / 32))); c4 += 1)\n  for (c6 = (((((((2 > (16 * c1)) ? (2) : (16 * c1)) > (((-N) + c3) + 1)) ? ((2 > (16 * c1)) ? (2) : (16 * c1)) : (((-N) + c3) + 1)) > (((((-8) * c0) + (8 * c1)) + (c3 / 2)) - 7)) ? ((((2 > (16 * c1)) ? (2) : (16 * c1)) > (((-N) + c3) + 1)) ? ((2 > (16 * c1)) ? (2) : (16 * c1)) : (((-N) + c3) + 1)) : (((((-8) * c0) + (8 * c1)) + (c3 / 2)) - 7)) > ((((-8) * c4) + ((c3 + 1) / 2)) - 7)) ? ((((((2 > (16 * c1)) ? (2) : (16 * c1)) > (((-N) + c3) + 1)) ? ((2 > (16 * c1)) ? (2) : (16 * c1)) : (((-N) + c3) + 1)) > (((((-8) * c0) + (8 * c1)) + (c3 / 2)) - 7)) ? ((((2 > (16 * c1)) ? (2) : (16 * c1)) > (((-N) + c3) + 1)) ? ((2 > (16 * c1)) ? (2) : (16 * c1)) : (((-N) + c3) + 1)) : (((((-8) * c0) + (8 * c1)) + (c3 / 2)) - 7)) : ((((-8) * c4) + ((c3 + 1) / 2)) - 7); c6 <= ((((((16 * c1) + 15) < ((c3 - (16 * c4)) - 1)) ? ((16 * c1) + 15) : ((c3 - (16 * c4)) - 1)) < ((((-8) * c0) + (8 * c1)) + (c3 / 2))) ? ((((16 * c1) + 15) < ((c3 - (16 * c4)) - 1)) ? ((16 * c1) + 15) : ((c3 - (16 * c4)) - 1)) : ((((-8) * c0) + (8 * c1)) + (c3 / 2))); c6 += 1)\n  for (c10 = ((16 * c4) > ((c3 - (2 * c6)) + 1)) ? (16 * c4) : ((c3 - (2 * c6)) + 1); c10 <= ((((16 * c4) + 15) < ((c3 - c6) - 1)) ? ((16 * c4) + 15) : ((c3 - c6) - 1)); c10 += 1)\n  table[(c3 - c6) - c6][c3 - c6] = (table[(c3 - c6) - c6][c3 - c6] < ((table[(c3 - c6) - c6][c10] + table[c10][c3 - c6]) + cost((c3 - c6) - c6, c3 - c6, c10))) ? (table[(c3 - c6) - c6][c3 - c6]) : ((table[(c3 - c6) - c6][c10] + table[c10][c3 - c6]) + cost((c3 - c6) - c6, c3 - c6, c10));\n\n\n\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1) private(c1,c3,c4,c6,c10) shared(c0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/triang/triang/3"}
{"code": "for (int run = 0; run < numRuns; run++)\n{\n  test(hiddenSize, miniBatch, seqLength, numLayers, cs);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/pointwise-omp/main/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  X[i] = (double *) malloc((sizeof(double)) * D);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/14"}
